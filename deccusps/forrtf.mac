	TITLE RTFORT  -  REAL TIME FORTRAN SUBROUTINES   V32(I416)
;***COPYRIGHT 1969,1970,1971,1972,1973,1974 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

	ENTRY	RTINIT,LOCK,RTSLP,RTWAKE,UNLOCK
	INTERNAL CONECT,RTREAD,RTWRIT,BLKRW,STATO,STATI
	INTERNAL RTSTRT,DISCON,DISMIS
	EXTERNAL .JBCNI,.JBREL

	JOBPRT=140

	OPDEF UJEN[1B2]
	OPDEF UNLOK.[CALLI 120]

	U=1		;UNIT NUMBER
	BLK=2		;RTBLK ADDRESS
	TAC=3		;TEMPORARY AC
	TAC1=4		;TEMPORARY AC
	AC0=0		;SCRATCH

	RTTRP=57
	LOCKU=60
	SLEEP=31
	EXIT==12
	RTCFLG==1
	RTIFLG==2
	PION=200
	PIOFF=400

	RTDEVN==2	;NUMBER OF REAL TIME DEVICES WHICH CAN BE
			;HANDLED SIMULTANEOUSLY BY THESE ROUTINES

	SHORT==0	;IF SHORT=-1 THE SHORT FORM OF ERROR MESSAGES ARE USED
			;THIS SAVES RUN TIME CORE

	DEFINE CHUNIT
<	SKIPLE U,@(16)		;CHECK THE VALIDITY OF THE UNIT NUMBER
	CAILE U,RTDEVN
	JRST NOUNIT>

	DEFINE CUNITB
<	CHUNIT
	MOVE BLK,U
	LSH BLK,2>

	DEFINE MES (A,B) <
IFE SHORT,<	TTCALL 3,[ASCIZ/A/]>
IFN SHORT,<	TTCALL 3,[ASCIZ/?B
/]>>
RTINIT:	Z			;CALL RTINIT(U,DEV,PI,TRPADR,MSKADR)
	CHUNIT
	JSA 16,DISCON		;DISCONECT THIS DEVICE FIRST
	JUMP U			;U CONTAINS THE UNIT NUMBER
	CUNITB
	MOVE AC0,@1(16)		;GET THE DEVICE CODE
	LSH AC0,-2		;MAKE IT A 7-BIT BYTE
	DPB AC0,[POINT 7,RTBLK+2(BLK),9];CONSO INSTRUCTION
	DPB AC0,[POINT 7,DATAOT(U),9]	;DATAO
	DPB AC0,[POINT 7,DATAIT(U),9]	;DATAI
	DPB AC0,[POINT 7,CONOT(U),9]	;CONO
	DPB AC0,[POINT 7,CONIT(U),9]	;CONI TABLE
	HRL AC0,@2(16)		;GET PI VALUE
	HRR AC0,@3(16)		;GET TRAP ADDRESS
	MOVEM AC0,RTBLK(BLK)	;STORE IN CALL BLOCK
	HRR AC0,4(16)		;GET THE MASK ADDRESS
	HRRM AC0,RTBLK+2(BLK)	;STORE ADDRESS IN CONSO INSTRUCTION
	MOVSI AC0,RTIFLG	;MARK THAT AN INIT HAS BEEN DONE
	MOVEM AC0,FLAGT(U)	;STORE FLAGS
	JRA 16,5(16)		;RETURN TO USER

CONECT:	Z			;CALL CONECT(UNIT,MODE)
	CUNITB
	MOVE AC0,FLAGT(U)	;GET THE FLAG REGISTER
	TLNN AC0,RTIFLG		;HAS THIS UNIT BEEN INITIALIZED?
	JRST INITER		;NO, GO TELL USER
	SKIPN TAC,@1(16)	;SINGLES MODE?
	JRST CON1		;YES
	MOVSI TAC,(BLKI)	;GET INSTRUCTION ROOT
	SKIPG @1(16)		;INPUT OR OUTPUT?
	TLO TAC,100		;WRITING - SET UP BLKO
	HRRI TAC,BLKADT(U)	;SET UP ADDRESS OF POINTER WORD
	LDB TAC1,[POINT 7,RTBLK+2(BLK),9]
	DPB TAC1,[POINT 7,TAC,9];SET UP DEV CODE
	MOVE TAC1,[IOWD 1,DUMMY];GET DUMMY POINTER WORD
	MOVEM TAC1,BLKADT(U)	;STORE IN BLKI/O POINTER LOCATION
CON1:	MOVEM TAC,RTBLK+3(BLK)	;STORE BLKI/O WORD
	MOVEM 15,SAVE15		;SAVE DO LOOP AC
	MOVEM 16,SAVE16		;SAVE RETURN ADDRESS
	MOVEM 17,SAVE17		;RTTRP DESTROYES ALL AC'S AT INTERRUPT LEVEL
	MOVEI AC0,RTBLK(BLK)	;GET BLOCK ADDRESS
	CALLI AC0,RTTRP		;CONNECT DEVICE TO PI LEVEL
	  JRST RTTERR		;FAILED, GO TYPE OUT ERROR MESSAGE
	MOVE 17,SAVE17		;RESTORE PDP
	MOVE 16,SAVE16		;RESTORE RETURN ADDRESS
	MOVE 15,SAVE15		;RESTORE DO LOOP AC
	MOVSI AC0,RTCFLG	;SET APPROPRIATE FLAG
	IORM AC0,FLAGT(U)	;IN FLAG TABLE
	JRA 16,2(16)		;RETURN TO THE USER
RTSTRT:	Z			;CALL RTSTRT (UNIT,CONOMSK,CONSOMSK)
	CUNITB
	MOVE AC0,FLAGT(U)	;GET FLAGS
	TLNN AC0,RTCFLG		;RT DEVICE CONNECTED YET?
	JRST CONERR		;NO, ERROR
	MOVE AC0,@2(16)		;GET CONSO MASK
	MOVE TAC,@1(16)		;GET CONO BIT MASK
	HLRZ TAC1,CONOT(U)	;CHECK FOR PI OR APR
	CAIGE TAC1,(CONO 10,0)	;DONT DO CONO 0 TO EITHER PI OR APR
	JUMPE TAC,RTST1
	HRRZ TAC1,RTBLK+2(BLK)	;GET CONSO MASK ADDRESS
	CONO PI,PIOFF
	MOVEM AC0,(TAC1)	;STORE CONSO MASK
	XCT CONOT(U)		;TURN DEVICE ON
	CONO PI,PION
RTST1:	JRA 16,3(16)		;RETURN TO USER

DISCON:	Z			;CALL DISCON (UNIT)
	CUNITB
	MOVE AC0,FLAGT(U)	;GET FLAGS
	TLZN AC0,RTCFLG		;DEVICE CONNECTED
	JRA 16,1(16)		;NO, RETURN TO USER
	MOVSI AC0,RTCFLG	;GET FLAG
	SETZM RTBLK(BLK)	;PREPARE TO DELETE RT DEVICE
	MOVEM 15,SAVE15		;SAVE NECESSARY AC'S
	MOVEM 16,SAVE16		;RTTRP KILLS ALL ACS
	MOVEM 17,SAVE17
	MOVEI TAC,RTBLK(BLK)	;GET ADDRESS OF RT BLOCK
	ANDCAM AC0,FLAGT(U)	;CLEAR CONNECT FLAG
	CALLI TAC,RTTRP		;REMOVE DEVICE
	  JRST RTTERR		;ERROR
	MOVE 17,SAVE17		;RESTORE PDP AC
	MOVE 16,SAVE16		;RESTORE RETURN ADDRESS AC
	MOVE 15,SAVE15		;RESTORE DO LOOP AC
	JRA 16,1(16)		;RETURN
RTREAD:	Z			;CALL RTREAD(UNIT,ADR)
	CHUNIT
	XCT DATAIT(U)		;DATAI DEV,@1(16)
	JRA 16,2(16)		;RETURN TO CALLING ROUTINE

RTWRIT:	Z			;CALL RTWRIT(UNIT,ADR)
	CHUNIT
	XCT DATAOT(U)		;DATAO DEV,@1(16)
	JRA 16,2(16)		;RETURN TO CALLER

STATO:	Z			;CALL STATO(UNIT,ADR)
	CHUNIT
	MOVE TAC,@1(16)		;GET STATUS BITS TO SEND OUT
	XCT CONOT(U)		;CONO DEV,(TAC)
	JRA 16,2(16)		;RETURN TO CALLING PROGRAM

STATI:	Z			;CALL STATI(UNIT,ADR)
	CHUNIT
	XCT CONIT(U)		;CONI DEV,@1(16)
	JRA 16,2(16)		;RETURN TO CALLER

RTSLP:	Z			;CALL RTSLP(TIME)
	SKIPE DONFLG		;HAVE WE BEEN WOKEN UP AT INTERRUPT LEVEL
	JRST WAKE1		;YES, GO RETURN TO CALLING ROUTINE
	MOVE AC0,@(16)		;GET SLEEP TIME
	SETZ	U,		;INFINITE SLEEP
	HIBER	U,		;IF WE CAN HIBERNATE
	  CALLI AC0,SLEEP	;GO TO SLEEP
	JRST RTSLP+1		;WAKE UP AND TRY AGAIN
WAKE1:	SETZM DONFLG		;CLEAR FLAG
	SKIPN TAC,ERRFLG	;WERE THERE ANY ERRORS?
	JRA 16,1(16)		;NO, JUST RETURN TO USER
	JRST (TAC)		;YES, GO TO ERROR ROUTINE

RTWAKE:	Z			;CALL RTWAKE
	MOVEM 15,SAVE15		;SAVE NECESSARY AC'S
	MOVEM 16,SAVE16		;RTTRP KILLS ALL ACS
	MOVEM 17,SAVE17
	SETOB DONFLG		;SET WAKE UP FLAG
	WAKE			;WAKE THIS JOB
	  JFCL			;IGNORE ERROR RETURN, IF WAKE NOT IMPLEMENTED
	MOVE 17,SAVE17		;RESTORE PDP AC
	MOVE 16,SAVE16		;RESTORE RETURN ADDRESS AC
	MOVE 15,SAVE15		;RESTORE DO LOOP AC
	JRA 16,(16)		;RETURN TO CALLER
BLKRW:	Z			;CALL BLKRW(UNIT,WORDS,ADR)
	CUNITB
	MOVE AC0,FLAGT(U)	;CHECK FLAGS FOR CONECT
	TLNN AC0,RTCFLG		;THE DEVICE MUST BE CONNECTED
	JRST CONERR		;IT ISNT, THIS IS AN ERROR
	HRRZ AC0,2(16)		;GET STARTING ADDRESS
	CAILE AC0,JOBPRT	;IS IT TOO LOW
	CAMLE AC0,.JBREL	;OR TOO HIGH
	JRST BNDERR		;YES,
	ADD AC0,@1(16)		;CALCULATE END OF BLOCK
	CAILE AC0,@2(16)	;IS THIS TOO LOW
	CAMLE AC0,.JBREL	;OR TOO HIGH?
	JRST BNDERR		;YES, ERROR
	MOVN AC0,@1(16)		;GET NEGATIVE NUMBER OF WORDS
	MOVSS AC0		;PUT IT IN LEFT HALF OF AC
	HRR AC0,2(16)		;GET START ADDRESS OF BLOCK
	ADD AC0,RELOCA		;MAKE IT ABSOLUTE
	MOVEM AC0,BLKADT(U)	;STORE IT IN THE POINTER TABLE
	JRA 16,3(16)		;RETURN TO CALLER

LOCK:	Z			;CALL LOCK
	MOVE AC0,[XWD 1,1]	;LOCK BOTH HALVES
	CALLI AC0,LOCKU		;TRY TO LOCK THE JOB IN CORE
	JRST LOKERR		;NO SUCH LUCK
	HRRZS AC0		;ZERO HIGH SEGMENT START ADDRESS
	LSH AC0,^D9		;MAKE ADDRESS CORRECT
	SUBI AC0,1		;OFFSET RELOCATION FOR LATER USE
	HRRZM AC0,RELOCA	;STORE FOR BLKRW CALLS
	JRA 16,(16)		;RETURN TO CALLER

UNLOCK:	Z
	MOVE	AC0,[1,,1]	;NOT NEEDED, BUT SET FOR FUTURE
	UNLOK.	AC0,		;TRY TO UNLOCK JOB
	  JFCL			;NOT IN THIS MONITOR
	SETZM	FLAGT+1		;CLEAR FIRST WORD OF BLOCK
IFG RTDEVN-1,<
	MOVE	AC0,[FLAGT+1,,FLAGT+2]
	BLT	AC0,FLAGT+RTDEVN ;CLEAR REST OF IT
>
	JRA	16,(16)		;RETURN TO CALLER

DISMIS:	Z			;CALL DISMIS
	UJEN			;DISMISS THIS INTERRUPT
NOUNIT:	MOVEI TAC,NOUNIT	;GET ERROR ADDRESS
	MOVEM TAC,ERRFLG	;STORE IT IN CASE WE ARE AT INTERRUPT LEVEL
	MES (<?ILLEGAL UNIT NUMBER.
TO HANDLE MORE DEVICES, REASSEMBLE RTFORT WITH A LARGER "RTDEVN".>,1)
	SETZM ERRFLG		;CLEAR ERROR FLAG
	CALLI EXIT

INITER:	MOVEI TAC,INITER	;GET ERROR ADDRESS
	MOVEM TAC,ERRFLG	;STORE IT FOR USER LEVEL USE
	MES (<?RTINIT MUST BE CALLED BEFORE CONECT>,2)
	SETZM ERRFLG		;CLEAR ERROR FLAG
	CALLI EXIT

RTTERR:	MOVE 17,SAVE17		;RESTORE 17
	MOVEI TAC,RTTER1	;GET USER LEVEL ERROR ADDRESS
	MOVEM TAC,ERRFLG	;STORE ERROR ADDRESS
	HRLM AC0,ERRFLG	;STORE ERROR BITS
RTTER1:	HLRZ TAC,ERRFLG		;PICK UP ERROR BITS
	MES (<?RTTRP ERROR
>,7)
	TRNE TAC,3		;PI CHL NOT AVAILABLE
	MES (<?ILLEGAL PI NUMBER
>,A)
	TRNE TAC,4		;TRAP ADDRESS OUT OF BOUNDS
	MES (<?TRAP ADDRESS OUT OF BOUNDS
>,B)
	TRNE TAC,100		;NO MORE RT DEVICES LEFT
	MES (<?SYSTEM LIMIT FOR REAL TIME DEVICES EXCEEDED
>,C)
	TRNE TAC,200		;JOB NOT LOCKED IN CORE
	MES (<?JOB NOT LOCKED IN CORE OR NOT PRIVELEGED
>,D)
	TRNE TAC,1000		;ILLEGAL DEVICE
	MES(<?DEVICE ALREADY IN USE BY ANOTHER JOB>,E)
	SETZM ERRFLG		;CLEAR ERROR FLAG
	CALLI EXIT

CONERR:	MOVEI TAC,CONERR	;GET ERROR ADDRESS
	MOVEM TAC,ERRFLG	;SAVE FOR USER LEVEL USE
	MES (<?CONECT MUST BE CALLED BEFORE RTSTRT>,3)
	SETZM ERRFLG		;CLEAR ERROR FLAG
	CALLI EXIT

BNDERR:	MOVEI TAC,BNDERR	;GET ERROR ADDRESS
	MOVEM ERRFLG		;SAVE IT IN CASE WE ARE NOT AT USER LEVEL
	MES (<?REAL TIME BLOCK OUT OF BOUNDS>,4)
	SETZM ERRFLG		;CLEAR ERROR FLAG
	CALLI EXIT

LOKERR:	MES (<?JOB CANNOT BE LOCKED IN CORE>,5)
	CAIN AC0,1
	MES (<?JOB NOT PRIVELEGED.>,A)
	CAIE AC0,2
	CAIN AC0,3
	MES(<?NOT ENOUGH CORE AVAILABLE FOR LOCKING.>,B)
	SETZM ERRFLG		;CLEAR ERROR FLAG
	CALLI EXIT

APRTRP:	Z			;APR ERROR AT INTERRUPT LEVEL
	MOVEI TAC,APRERR	;GET ERROR ADDRESS
	MOVEM TAC,ERRFLG	;STORE FOR USER LEVEL USE
	MOVEI 15,RTDEVN		;DISCONECT REAL TIME DEVICES
APRTP1:	MOVE AC0,FLAGT(15)	;GET FLAGS
	TLNE AC0,RTCFLG		;MAKE SURE DEVICE IS CONNECTED
	JSA 16,RTSTRT		;DO CONO 0 TO ALL DEVICES
	JUMP 15
	JUMP [0]
	JUMP [0]
	SOJG 15,APRTP1
	MOVEI 15,RTDEVN		;DISCONECT AS MANY REAL TIME DEVICES
APRTP2:	JSA 16,DISCON		;AS POSSIBLE
	JUMP 15
	SOJG 15,APRTP2		;LOOP BACK FOR MORE
	UJEN

APRERR:	MES (<?APR ERROR AT INTERRUPT LEVEL
>,6)
	MOVE TAC,.JBCNI		;PICK UP ERROR BITS
	TRNE TAC,200000		;PDL?
	MES (<?PDL OVERFLOW
>,A)
	TRNE TAC,30000		;ILL MEM REF OR NON EX MEM
	MES (<?ILLEGAL MEMORY REFERENCE>,B)
	SETZM ERRFLG		;CLEAR ERROR FLAG
	CALLI EXIT
; VARIABLES AND STORAGE ALLOCATION

RELOCA:	Z		;RELOCATION VALUE FOR BLKRW
DUMMY:	Z		;DUMMY I/O WORD
ERRFLG:	Z		;ERROR ROUTINE TO BE EXECUTED WHEN ERROR
			;OCCURS AT INTERRUPT LEVEL
DONFLG:	Z		;SLEEP COMMUNICATIONS FLAG

SAVE15:	Z		;SAVE AC 15 AT INTERUPT LEVEL
SAVE16:	Z		;SAVE AC 16
SAVE17:	Z		;SAVE AC 17
RTBLK=.-4
	REPEAT RTDEVN,<
		Z
		APRTRP
		CONSO @0
		Z>

BLKADT=.-1
	BLOCK RTDEVN

DATAOT=.-1
	REPEAT RTDEVN,<
		DATAO @1(16)>

DATAIT=.-1
	REPEAT RTDEVN,<
	DATAI @1(16)>

CONOT=.-1
	REPEAT RTDEVN,<
		CONO (TAC)>

CONIT=.-1
	REPEAT RTDEVN,<
	CONI @1(16)>

FLAGT=.-1
	BLOCK RTDEVN

LIT
	END
