	TITLE FOROTS %4A.(406) - FORTRAN OBJECT TIME SYSTEM
	SUBTTL	D. TODD/DRT/HPW/MD/NEA		 16-OCT-74


;***COPYRIGHT 1972,1973,1974, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

	MLON


	ENTRY	FOROT%	;ENTRY POINT TO FOROTS - MUST BE DEFINED BEFORE
.JBOPS=135
.JBVER=137
	EXTERNAL	FORER%	;DEFINE FORERR AS EXTERNAL
	EXTERNAL	TRACE%	;DEFINE TRACE AS EXTERNAL


	SEARCH	FORPRM	;GLOBAL SYMBOL DEFINED IN FORPRM

VERNO==04		;MAJOR VERSION NUMBER
VEDIT==406		;MAJOR EDIT NUMBER
VMINOR==01		;MINOR EDIT NUMBER
VWHO==0			;WHO EDITED LAST

VEROTS==BYTE (3)VWHO(9)VERNO(6)VMINOR(18)VEDIT

	SUBTTL	REVISION HISTORY

;247	 -----	IMPLEMENT FULL SLIST AND ELIST
;250	 -----	IMPLEMENT ARRAY BOUNDS CHECKING
;256	 -----	CORRECTION TO EDIT 247
;		ALLOW ELISTS WITH 1 ARRAY
;260	 -----	SWITCH FT.EXT AND FT.ELT
;271	 -----	ALLOW ' TO DELIMIT FORMAT ELEMENT
;275	 -----	FIX DOUBLE WORD BINARY AND FORMATTED IOLST
;		PROCESSING WITH NON-UNARY INCREMENT
;276	 -----	FIX RELOC TO RETURN ONLY RIGHT HALF OF IMMEDIATE MODE ARGUMENTS
;		FIX FOROTS TO READ CHARACTER COUNT IN ENCODE/DECODE
;		IN NEW IMMEDIATE MODE FORMAT
;326	(QAR)	SLIST AND ELIST DO NOT RETURN ALL ALLOCATED
;		CORE BLOCKS.
;341	 (QAR)	CORRECT CHAIN OF BLOCKS FOR SLIST AND ELIST
;342	(Q2338)	IN DIALOG MODE TYPE CR-LF AFTER ALTMODE SEEN
;343	(Q2072)	VERSION NUMBER IS FULL WORD
;344	(Q2046)	IMPLEMENT /DISPOSE=LIST FOR OPEN/CLOSE STATEMENT
;345	(Q2322)	F FORMAT WILL OUTPUT DBLE-PREC VAR AS D
;346	 -----	PRESERVE .JBHRL TO CALL FORQUE
;347	 -----	RESTRICT DELIMITER FOR LIST-DIRECTED INPUT
;		TO BLANK, COMMA AND LINE TERMINATOR
;350	(13704)	LIST-DIRECTED INPUT DOES NOT TAKE END= RETURN
;351	(Q2394)	RETURN AC0/-1 IF NO CORE AVAILABLE (ALCOR.)
;352	(Q2337)	TEST FULL WORD FOR MTA DENSITY ARGUMENT
;353	 -----	FIX TO EDIT 332
;354	 -----	FIX FREE FORMAT INPUT
;355	(13315)	ALLOW ARGUMENT BLOCK IN REGISTERS
;356	(13877)	MOVE CONSTANTS IN FORDBL
;357	 -----	REDEFINE LABEL ERROR IN FORCNV
;360	 -----	FIX CONTINUATION LINE FOR MACRO V50
;361	(13134)	MTA POSITIONNING PROBLEMS
;362	(13976)	MAKE SWITCHING FROM READ TO WRITE ALWAYS USE THE WHOLE BLOCK
;363	 ----- 	DEFINE CEXIT. FOR NON FORTRAN USE OF LIB ROUTINES
;364	 -----	DEFINE FDDT. IF FORDDT NOT LOADED
;365	 -----	INSERT FORX40 IN FORMSC
;366	 -----	FIX LIST-DIRECTED INPUT TO ARRAYS
;367	(13951)	FIXED INTEGER FORMAT LOOSES BLANKS AT END OF RECORD
;370	(Q2648)	FIX CLEAN UP OF ENCODED FORMAT LIST
;371	(Q2600)	FIX EOF IN IMAGE MODE
;372	 -----	FIX NAMELIST
;373	(13917)	FIX SCALING FACTOR
;374	 -----	END OF NAMELIST LIST FOR F10-V2
;375	 -----	DO NOT ALLOW SEQUENTIAL ACCESS ON RANDOM FILE
;376	 -----	CORRECT FIXED "A" FORMAT AFTER FREE FORMAT
;377	 -----	CORRECT F FORMAT
;400	 -----	FIX TO EDIT 372
;401	 -----	SAVING REGISTERS IN FORINI MAY FAIL
;402	 -----	COMPLETE EDIT 375 (APPEND MODE)
;***** BEGINNING OF VERSION 4A
;***** SPECIAL EDIT FOR DATE 75
;406	 -----	COMFORM TO DATE 75 STANDARDS
;	DEFINE THE LOADING

	LOC	.JBOPS		;MUST DEFINE .JBOPS
	Z			;EQUAL TO ZERO TELLS FORINI THAT
				;FOROTS WAS LOADED FROM FORLIB
	LOC	.JBVER
	VEROTS

	SEGMEN
	SUBTTL FOROTS ENTRY POINTS DEFINED BY FORDIR IN (FORPRM)
FOROT%=.
	LALL
	FORDIR
	SALL

EXTERN	FUNCT%			;[232] DEFINE OVERLAY ENTRY

	SUBTTL RESET FOROTS INITIALIZATION ROUTINE

; CALLED BY FORINI IN THE LOW SEGMENT
; .JBFF POINTS TO THE BEGINNING OF THE DYNAMIC CORE AREA
; .JBOPS AND P4 CONTAIN THE BASE REGISTER TO THE STATIC LOW SEGMENT
; AC'S 0-16 ARE SAVE FY FORINI IN ACC.SV

	INTERNAL	INIT%
INIT%:				;THIS ROUTINE FINISHES THE JOB OF
				; INITIALIZATION STARTED BY FORINI

	MOVEI	T1,LOW.SZ(P4)	;GET THE END OF THE STATIC AREA
	HRRZM	T1,.JBFF	;UPDATE  JOB FIRST FREE
	CAMG	T1,.JBREL	;IN OUR ADDRESSING SPACE
	JRST	.+3		;YES, OK
	CORE	T1,		;NO, PUT IT IN OUT ADDRESSING SPACE
	  HALT			;NO, CORE AVAILABLE
	HRRI	T2,ACC.SV+21(P4);BUILD A BLT POINTER TO CLEAR THE LOW
	HRLI	T2,ACC.SV+20(P4); SEGMENT FROM THE SAVE AREA
	SETZM	ACC.SV+20(P4)	;CLEAR THE FIRST WORD
	BLT	T2,@.JBREL	; TOP OF THE DYNAMIC AREA
	MOVE	T1,ACC.SV+0(P4)	;[320]
	MOVEM	T1,REGS.0(P4)	;[320]
	MOVE	T1,ACC.SV+7(P4)	;[320]
	MOVEM	T1,REGS.1(P4)	;[320]
	MOVE	T1,ACC.SV+11(P4);[320]
	MOVEM	T1,REGS.2(P4)	;[320]
	MOVEI	T1,LOW.SZ(P4)	;GET THE LOCATION OF THE DYNAMIC CORE
	MOVE	T2,.JBREL	;[306] GET .JBREL
	ADDI	T2,1		;[306] BUILD A NEW JOBFF
	HRRM	T2,.JBFF	;SAVE AS END OF DYNAMIC MEMORY
	SUBI	T2,(T1)		;COMPUTE LENGTH OF DYNAMIC CORE
	HRLZM	T2,(T1)		;SAVE AS A CONTROL WORD FOR GMEM%%
	HRRZM	T1,FRE.DY(P4)	;START THE FREE CORE LIST

				; STRUCTURED DYNAMIC CORE
	HRRI	P,STK.SV-1(P4)	;BUILT THE FOROTS STACK POINTER
	HRLI	P,-STK.SZ	;PUT THE SIZE OF THE STACK IN THE LEFT


	MSTIME	T1,		;GET THE CURRENT TIME OF DAY
	MOVEM	T1,DAY.TM(P4)	;SAVE IN STATIC LOW CORE
	SETZ	T1,		;CLEAR AC FOR OUR JOB
	RUNTIM	T1,		;GET THE RUNTIME SO FAR (SINCE LOG IN)
	MOVEM	T1,RUN.TM(P4)	;SAVE IN STATIC LOW CORE
	MOVEI	T1,2		;SET UP THE MAX ERROR COUNT
	MOVEM	T1,ERRMX.(P4)	;STORE THE ERROR COUNTER

	MOVE	T1,[XWD 17,11]	;GET CNFTBL (CONFIGURATION TABLE)
	GETTAB	T1,		; FROM THE MONITOR
	SETZ	T1,		;MUST BE A 4 SERIES MONITOR
	MOVEM	T1,MON.SV(P4)
	TLNN	T1,1		;IS THE MONITOR BUILT FOR FOROTS
	ERROR	(SYS,3,17)	;NO, STOP THIS JOB

	SETOM	JOB.SV(P4)	;SET FLAG TO GET OUR CHARASTICS
	GETLCH	JOB.SV(P4)	;GET OUR CHARASTICS


	MOVEI	T0,DDB.SZ	;GET A TTY DDB
	PUSHJ	P,GMEM%%	;ALLOCATE THE MEMORY
	HRRI	P3,(T1)		;LOAD THE I/O REG
	HRLI	P3,IO.FMT!IO.CCC!IO.TTA!IO.TTY!IO.INT!
		IO.OPN!IO.SIN!IO.SOU			;[360] SET FLAGS
	MOVSI	T0,(SIXBIT /TTY/);GET THE TTY NAME
	MOVEM	T0,DD.DEV(P3)	;SAVE IN THE DD.BLK
	MOVSI	T0,DD.HRO(P3)	;GET THE OUTPUT RING HEADER
	HRRI	T0,DD.HRI(P3)	;GET THE INPUT RING HEADER
	MOVEM	T0,DD.RNG(P3)	;SAVE IN THE DD.BLK
	MOVE	G3,[XWD DV.TTA!DV.TTY!DV.AVL!DV.IN!DV.OUT,400403]
	MOVEM	G3,DD.STS(P3)	;SAVE THE DEVICE STATUS
	MOVE	G1,[XWD 2,23]	;GET THE BUF SIZE AND COUNT
	MOVSI	T1,(20B12)	;SET TTY ON PSEUDO CHANNEL 0
	HLLZM	T1,DD.UNT(P3)	;PUT THE CHANNEL ENTRY IN THE DD.BLK
	PUSHJ	P,OPEND6	;OPEN THE TTY

	PUSHJ	P,TRPIN.##	;INITIALIZE THE TRAP ROUTINE


	MOVEM	L,USR.PC(P4)	;SAVE THE USR'S PC
	HRLZI	L,ACC.SV(P4)	;LOAD THE USER'S AC SAVE AREA
	BLT	L,L		;RESTORE THE USERS AC'S
	JRST	1(L)		;RETURN TO THE USER
	SUBTTL SAVE. GENERAL AC SAVE ROUTINE

; SAVE. IS CALLED ON ALL ENTRIES INTO THE FOROTS SYSTEM
; ALL AC'S ARE SAVE IN THE STATIC CORE ACC.SV
; ACC.SV+P CONTAINS A PUSHDOWN POINTER WHOSE ADDRESS IS TWO (2)
; GREATER THAN THE STACK ADDRESS OF THE ROUTINE
; THAT CALLED FOROTS. (USED BY THE ERROR ROUTINE FOR TRACE)

SAVE.::	PUSH	P,P4		;SAVE P4 ON THE STACK
	HRRZ	P4,.JBOPS	;LOAD THE SAVE AREA POINTER
	POP	P,ACC.SV+P4(P4)	;SAVE P4 IN THE SAVE AREA
	DMOVEM	L,ACC.SV+L(P4)	;SAVE THE LINK AND STACK POINTER
	TRNN	L,-20		;[355] LINK POINTER TO ACS
	ADDI	L,ACC.SV(P4)	;[355] YES, RELOCATE
	MOVEM	P3,ACC.SV+P3(P4);SAVE P3 IN THE SAVE AREA
	MOVEI	P3,ACC.SV(P4)	;SET UP A BLT TO SAVE THE USR'S ACS
	BLT	P3,ACC.SV+P2(P4);SAVE ALL AC'S T0-P2
	POP	P,T1		;RESTORE THE CALLER'S  ADDRESS
	POP	P,USR.PC(P4)	;SAVE THE USER'S PC AND FLAGS
	PUSHJ	P,(T1)		;RETURN TO SAVE CALLER
	JFCL			;[337] PREVENT ERRONEOUS RETURN
	MOVSI	L,ACC.SV+L(P4)	;SET UP A JRA RETURN AND RESTORE L
	HRR	L,USR.PC(P4)	;GET THE USER'S RETURN ADDRESS
	MOVSI	P4,ACC.SV(P4)	;FOROTS, RETURNS HERE LOAD SAVE AREA
	BLT	P4,P4		;RESTORE ALL AC'S BUT L
	JRA	L,(L)		;RETURN TO THE USER
	SUBTTL OPEN ROUTINE TO PROCESS THE OPEN STATEMENT

SETOPN:			;DEFAULT OPEN ROUTINE
	PUSH	P,G2		;[255] PRESERVE THE FLU
	PUSH	P,L		;SAVE THE LINK REGISTER
	PUSH	P,P2		;SAVE THE FLAG REGISTER
	MOVEI	T0,6		;ALLOCATE SPACE FOR AN ARG BLOCK
	PUSHJ	P,GMEM%%		;FROM THE HEAP
	PUSH	P,T1		;SAVE THE ADDRESS
	MOVEI	L,1(T1)		;POINT THE ARG BLOCK +1
	MOVSI	T1,-5		;SET THE ARG COUNT
	MOVEM	T1,-1(L)	;STORE
	MOVEM	G2,(L)		;PUT IN ARG BLOCK
	HRRZ	T1,ERR.PC(P4)	;[176] END= ?
	JUMPE	T1,SETOP1	;[176] NO
	HRLI	T1,340		;[176] SET TP%LAB
	MOVEM	T1,1(L)		;[176] SET IN ARGUMENT BLOCK
SETOP1:	HLRZ	T1,ERR.PC(P4)	;[176] ERR= ?
	JUMPE	T1,SETOP2	;[176] NO
	HRLI	T1,340		;[176] SET TP%LAB
	MOVEM	T1,2(L)		;[176] SET IN ARGUMENT BLOCK
SETOP2:				;[176] END OF PATCH
	MOVE	T1,[XWD 12740,[ASCIZ /ASCII/]] ;ASSUME ASCII MODE
	TLNN	P2,IO.FMT	;CHECK MODE BIT
	HRRI	T1,[ASCIZ /BINARY/] ;SWITCH TO BINARY
	MOVEM	T1,3(L)		;SAVE THE MODE ARGUEMNT
	MOVE	T1,[XWD 2740,[ASCIZ/SEQIN/]] ;ASSUME INPUT
	TLNN	P2,IO.SIN	;SEQIN MODE
	HRRI	T1,[ASCIZ/SEQOUT/] ;NO SET OUTPUT
	TLC	P2,IO.SIN!IO.SOU;CHECK FOR
	TLCN	P2,IO.SIN!IO.SOU;SEQIN OUT MODE
	HRRI	T1,[ASCIZ /SEQINOUT/]
	TLNE	P2,IO.RAN	;UNLESS RANDOM ACCESS
	HRRI	T1,[ASCIZ /RANDOM/]
	MOVEM	T1,4(L)		;PUT IN ARG BLOCK
	PUSHJ	P,OPEN%%	;OPEN THE DEVICE
	POP	P,T1		;GET THE HEAP POINTER BACK
	POP	P,P2		;RESTORE THE FLAGS
	POP	P,L		;RESTORE THE LINK
	POP	P,G2		;[255] RESTORE THE FLU
	PJRST	PMEM%%		;RETURN THE HEAP SPACE, RETURN TO CALLER
	SUBTTL OPEN% ROUTINE TO DEFINE THE DD.BLK

;AC USAGE
;	P=	THE PUSH DOWN POINTER
;	L=	THE POINTER TO THE ARGUMENT BLOCK
;	P4=	THE LOW SEG BASE POINTER
;	P3=	THE DIALOG DEVICE
;	P2=	THE POINTER TO THE DD.BLK BEING DEFINE
;	P1=	THE JSP POINTER
;	G4=	ACCESS IN OPEND
;		CHARACTER COUNT IN SCNNER
;	G3=	THE CURRENT DISPATCH ENTRY
;	G2=	GLOBAL SCRATCH
;	G1=	POINT TO THE INCORE ARGUMENT (SET BY EFCTIVL)
;	T5=	TYPE ARGUMENT TYPE CODE
;	T4=	SCRATCH
;	T3=	SCRATCH
;	T2=	FLAGS DEFINING WHAT STOPPED THE DIALOG SCAN
;	T1=	A VALUE RETURNED FROM SCNNER (SWITCH NAME OR VALUE)
;	T0=	USED TO ASSEMBLE THE CONTENTS OF T1

	SIXBIT	/OPEN./		;NAME FOR TRACE
OPEN%:	PUSHJ	P,SAVE.		;SAVE ALL AC'S AND LOAD P4
OPEN%%:	JSP	P1,SRCFLU	;IS THE FLU ASSIGNED
	JRST	OPEN0		;NO, CONTINUE
	PUSHJ	P,RELE%%	;YES, RELEASE THE UNIT FIRST
OPEN0:	MOVEI	T0,DDB.SZ	;FOROTS ENTRY - LOAD THE DD BLOCK SIZE
	PUSHJ	P,GMEM%%	;GET DYNAMIC MEMORY TO DD BLOCK
	MOVEI	P2,(T1)		;SET UP P2 POINTING TO THE DD BLOCK
	HRRZM	G2,DD.UNT(P2)	;PUT THE FLU IN THE DD.BLK
	JSP	P1,GT.CHN	;[265] GET A SOFTWARE CHANNEL
	ERROR	(OPN,10,10,)	;NO CHANNEL AVAILABLE
	LSH	T1,5		;PUT THE CHANNEL IN THE AC FIELD
	HRLM	T1,DD.UNT(P2)	;PUT THE CHANNEL IN THE DD.BLK
	PUSHJ	P,OPNARG	;GET THE OPEN STATEMENT ARGUMENTS
OPEN5:	MOVEI	P3,(P2)		;SET OP TO OPEN THE DEVICE
	PUSHJ	P,OPEND		;OPEND THE DEVICE
	POPJ	P,		;DEVICE IS OK
	MOVEI	P2,(P3)		;ERROR DURING OPEN
	TLO	P2,OP.ERR	;SET THE ERROR FLAG
	PUSHJ	P,OPNAR5	;FORCE ERROR DIALOG (MY BE BATCH)
	JRST	OPEN5		;TRY TO OPEN AGAIN
	SUBTTL ROUTINES TO OPEN THE DEVICE AND ASSIGN BUFFERS
OPEND:
	SKIPN	T1,DD.DEV(P3)	;GET THE DEVICE NAME
	HRRZ	T1,DD.UNT(P3)	;NO DEVICE SPECIFIED, GET FLU
	PUSHJ	P,GETDV.	;GET THE DEVICE SPECS
	MOVEM	G1,DD.DEV(P3)	;STORE THE FAULTY DEVICE NAME
	JUMPN	G3,OPEND3	;DEVICE EXISTS
	ERROR	(OPN,6,7,OPENER);NO, SUCH DEVICE
OPEND3:	MOVEM	G2,DD.DEV(P3)	;SAVE THE PHYSICAL DEVICE NAME
	TLNN	G3,DV.AVL	;IS THE DEVICE AVAILABLE
	ERROR	(OPN,5,7,OPENER);NO,ERROR GO TO DIALOG 
	LDB	G4,[POINT 4,DD.BLK(P3),9] ;GET THE ACCESS INDEX
	HRLZ	G4,ACC.DP(G4)	;GET THE ACCESS BITS
	TLNN	G4,IO.SIN	;IS INPUT REQUIESTED
	TLO	P3,IO.INO	;NO, SET OUTPUT MODE
	MOVSI	T1,7		;SET UP A MASK
	AND	T1,G4		;GET A COPY OF THE DEVICE CHARASTICS
	IOR	P3,T1		;SET THE ACCESS IN P3
	TDZ	T1,G3		;MATCH THE I/O REQUIREMENTS
	TLNE	G4,IO.RAN	;RANDOM ACCESS FILES REQUIRE A DISK
	TLNE	G3,DV.DSK	;YES, MUST BE A DISK TYPE DEVICE
	TLNE	T1,DV.IN!DV.OUT ;CAN THE DEVICE PREFORM THE NEEDED I/O
	ERROR	(OPN,2,7,OPENER);NO, DEVICE CAN NOT PREFORM I/O
	TLNN	G4,IO.RAN	;[257] RANDOM ACCESS REQUESTED
	JRST	OPENDB		;[257] NO
	LDB	T1,[POINT 4,DD.BLK(P3),13]	;[257] YES - LOOK AT MODE
	CAIN	T1,MOD.DU	;[257] DUMP MODE REQUESTED
	ERROR	(OPN,15,7,OPENER)	;[257] CANNOT RANDOM ACCESS FILE IN DUMP MODE
OPENDB:	TRNN	G3,DV.ASP	;[257] IS DEVICE ASSIGND BY PROGRAM
	JRST	OPEND2		;NO, CONTINUE
	MOVSI	T2,-20		;SET UP AN AOBJP T2,POINTER
	HRRI	T2,CHN.TB(P4)	;TO THE CHANNEL TABLE
	AOBJP	T2,OPEND2	;NOT IN THE TABLE
	SKIPE	T1,(T2)		;IS THE CHANNEL DEFINED
	CAME	G2,DD.DEV(T1)	;AND POINTED TO BY THIS DEVICE
	JRST	.-3		;NO, LOOK AT THE NEXT ENTRY
	PUSH	P,T1		;YES, SAVE THE DD POINTER
	PUSHJ	P,RELE%1	;RELEASE THIS BLOCK
	POP	P,P3		;SET UP P3 WITH THE DD.BLK POINTER
OPEND1:	HLRZ	T1,DD.UNT(P3)   ;GET THE PSEUDO CHANNEL
	LSH	T1,-5		;POSITION PSEUDO CHANNEL
	DPB	T1,FLU.BP(P4)	;POINT FLU TO THE CHANNEL TABLE
	POPJ	P,		;RETURN


OPEND2:	MOVE	G2,DD.DEV(P3)	;GET THE DEVICE NAME
	DEVTYP	G2,		;GET THE DEVICE TYPE BITS
	SETZ	G2,		;UUO NOT IMPLEMENTED
	TLNE	G2,TY.INT	;IS DEVICE INTERACTIVE
	TLO	P3,IO.INT	;YES, SET INTERACTIVE BITS
	TLNE	G2,TY.SPL	;IS DEVICE BEING SPOOLED
	TLO	G3,DV.DIR	;YES, SET THE DISK BITS
	MOVEI	T1,(G2)		;GET THE DEVTYPE BIT
	ANDI	T1,77		;ISOLATE THE DEVICE CODE
	CAIN	T1,12		;IS THIS A PSEUDO TTY
	TLO	G3,DV.PTY	;YES SET TTY FLAG
	MOVEM	G3,DD.STS(P3)	;SAVE THE DEVCHR BITS (SAVES TIME)
	JSP	P1,OPENDM	;DEFINE THE MODE IN THE DD.BLK
	ERROR	(OPN,1,7,OPENER);ILLEGAL MODE FOR DEVICE

	TLNE	G3,DV.TTA	;IS THIS THE USER'S TTY
	JRST	[PUSHJ P,RELE%1	;YES DEALLOCATE THE DDB
		MOVE	P3,CHN.TB+20(P4) ;GET THE TTY CHANNEL
		JRST	OPEND1]	;SET UP THE CHANNEL TABLE
	SETZ	T1,		;CLEAR THE RING HEADER
	TLNE	G3,DV.IN	;INPUT MODE REQUESTED
	HRRI	T1,DD.HRI(P3)	;YES, SET POINTER TO INPUT RING
	TLNE	G3,DV.OUT	;OUTPUT MODE REQUESTED
	HRLI	T1,DD.HRO(P3)	;SET POINTER TO OUTPUT RING HEADER
	MOVEM	T1,DD.RNG(P3)	;PUT POINTER IN OPEN BLOCK

	HLL	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T1,(OPEN)	;SET OPEN UUO IN T1
	HRRI	T1,DD.OPN(P3)	;SET POINTER TO OPEN ARGS
	XCT	T1		;OPEN THE UNIT
	ERROR	(OPN,5,7,OPENER);DEVICE NOT AVAILABLE
	TLNN	G3,DV.DIR	;DIRECTORY DEVICE
	JRST	OPEND5		;NO, IGNORE LOOKUP/ENTER
	PUSHJ	P,FILDFT	;CHECK ON FILE NAME
	TLNN	G3,DV.DTA	;IS THIS A DEC TAPE UNIT
	JRST	OPEND4		;MUST BE A DISK OF SOME SORT
	SKIPN	T1,DD.PPN(P3)	;WAS A PPN SPECIFIED
	JRST	.+4		;NO, DON'T WORRY ABOUT IT
	TLZN	T1,-1		;YES, CHECK FOR A SFD'S LIST
	PUSHJ	P,PMEM%%		;YES, RETURN SFD LIST TO FREE CORE
	SETZM	DD.PPN(P3)	;CLEAR THE PPN POINTER FOR DECTAPE
IFE QUEUER,<			;[240] IF QUEUEING IS NOT ALLOWED
OPEND4:	MOVEI	T1,DD.ALC-DD.CNT ;[240] SET ARG BLOCK SIZE FOR LOOKUP/ENTER
>				;[240] END OF QUEUER CONDITIONAL
IFN QUEUER,<			;[240] IF QUEUEING IS ALLOWED
OPEND4:	MOVEI	T1,DD.STR-DD.CNT ;[240] SET ARG BLOCK SIZE FOR LOOKUP/ENTER
>				;[240] END OF QUEUER CONDITIONAL
	MOVEM	T1,DD.CNT(P3)	;PUT COUNT IN DD.BLK


;	ROUTINE TO DO ENTERS/LOOKUPS ON THE DSK TYPE DEVICE

FILOPN:	TLNN	G4,IO.RAN!IO.SIN;CHECK FOR SEQOUT MODE
	JRST	FILOP2		;YES, PROCESS SPEERATELY
	JSP	P1,LOOKU.	;DO A LOOKUP(SEQIN,SEQINOUT,RANDOM,APPEND)
	JRST	FILOP3		;FILE NOT FOUND,  CHECK IF FATAL
	TLNE	G4,IO.SOU	;CHECK FOR APPEND OR RANDOM ACCESS
	TLNN	G4,IO.RAN	;RANDOM ACCESS OF APPEND
	JRST	FILOP4		;NO, MUST BE SEQIN OR RANDIN ALL DONE
	JSP	P1,ENTER.	;DO AND ENTER (UPADTE MODE)
	ERROR	(OPN,0,7,OPENER)	;BAD (CAN DO LOOKUP BUT NO ENTER)
				;MUST BE READ ONLY FILE
	JRST	FILOP4		;[300] ALL DONE

FILOP3:	LDB T1,[POINT 4,DD.BLK(P3),9];GET THE ACCESS BITS
	CAIN	T1,ACC.RO	;RANDOM MODE
	JRST	FILOP6
	TLNN	G4,IO.SOU	;IS OUTPUT LEGAL
	ERROR	(OPN,0,6,OPENER);NO, FILE NOT FOUND
FILOP2:
FILOP6:	JSP	P1,ENTER.	;SEQOUT OR RANDOM ACCESS CREATE A FILE
	ERROR	(OPN,0,7,OPENER);CAN'T ENTER THE FILE
	TLNN	P3,IO.RAN	;[205] RANDOM ACCESS?
	JRST	FILOP7		;[205] NO - SEQOUT - JUST ENTER FILE
	HLLZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T1,(CLOSE)	;SET UP TO CLOSE THE DUMMY FILE
	XCT	T1		;CLOSE THE DUMMY FILE
	JRST	FILOPN		;START OVER WITH A FILE

;

FILOP7:	TLO	P3,IO.INO	;[213] SET OUTPUT LAST
FILOP4:				;END OF LOOKUP/ENTER ROUNTINE
	TLNE	G4,IO.RAN	;[300] RANDOM ACCESS?
	TLNN	G4,IO.SIN	;[327] APPEND DOES NOT REQUIRE IT
	JRST	OPEND5		;[327] NO NEED FOR RECORD SIZE
	SKIPL	DD.LOG(P3)	;[300] [327] YES. MUST HAVE A RECORD LENGTH
;;;;;	JRST	OPEND5		;[300] [327] NO RANDOM ACCESS OR OK
	ERROR	(OPN,12,6,OPENER) ;[300]TELL USER TO ENTER RECORD SIZE

;;	ALOCATE BUFFERS FOR THE DEVICE INCREASE BUFF COUNT FOR
;;	FIXED LENGTH RECORDS IF REQUIRED

OPEND5:	CAIN	T5,MOD.DU	;DUMP MODE I/O
	JRST	OPEND7		;YES, SKIP THE BUFFER STUFF
	MOVEI	T4,DD.OPN(P3)	;GET POINTER FOR DEVSIZ UUO
	DEVSIZ	T4,		;GET THE DEFAULT BUFFERCOUNT,,BUFFER SIZE
	ERROR	(SYS,3,17,)	;MUST HAVE THE DEVSIZ UUO (ALWAYS)
	MOVE	G1,DD.BUF(P3)	;GET THE USER'S COUNT,,SIZE
	TRNE	G1,-1		;BUFFER SIZE SPECIFIED?
	TLNN	G2,TY.VAR	;DOES DEVICE SUPPORT VARIABLE BUFFERS
	HRR	G1,T4		;NO, SET MONITOR DEFAULT
	TLNN	G1,-1		;USER SUPPLIED BUFFER COUNT
	HLL	G1,T4		;NO, USE MONITOR DEFAULT (2)
OPEND6:	MOVEM	G1,DD.BUF(P3)	;SAVE THE BUFCNT,,BUFSIZ
	PUSHJ	P,ALCBUF	;ALLOCATE THE BUFFER RING
	HRRI	T2,-2(T1)	;MAKE A CORE BLOCK POINTER
	HRRM	T2,-1(P3)	;LINK BUFFERS TO DD.BLK
	HRLI	T1,400000	;SET THE USE BIT ON (BUFFERS ALLOCATED)
	TLNE	G3,DV.IN	;CAN DEVICE DO INPUT
	MOVEM	T1,DD.HRI(P3)	;SET POINTER TO BUFFER RING (INPUT)
	TLNE	G3,DV.OUT	;CAN DEVICE DO OUTPUT
	MOVEM	T1,DD.HRO(P3)	;SET POINTER TO BUFFER RING (OUTPUT)
	TLNN	G3,DV.TTA!DV.TTY!DV.PTY;SOME TYPE OF TTY
	JRST	OPEND8		;NO, SINGLE RINGS O/K
	HLL	T1,(T1)		;GET THE SIZE FILED
	EXCH	T1,(T1)		;REALLOCATE THE TWO BUFFERS
	MOVEM	T1,(T1)		;INTO TWO SINGLE BUFFER RINGS
	HRRM	T1,DD.HRO(P3)	;SET UP THE OUTPUT RING HEADER
	TLNN	G3,DV.TTA	;USER'S TTY
	JRST	OPEND8		;NO, SLAVE TTY
	HRLI	T1,(POINT 7)	;ASCII
	ADDI	T1,1		;POINT TO THE DATA AREA
	MOVEM	T1,DD.HRO+1(P3)	;PUT IN RING HEADER
	SETZM	DD.HRI+2(P3)	;CLEAR THE BYTE COUNTER
	MOVEM	P3,CHN.TB+20(P4)	;DEFINE THE TTY CHANNEL
	POPJ	P,		;RETURN
OPEND8:	TLC	G4,IO.RAN!IO.SOU	;CHECK FOR APPEND
	TLCE	G4,IO.RAN!IO.SIN!IO.SOU
	JRST	OPEND9		;NO, 
	MOVE	T4,DD.SIZ(P3)	;GET THE TOTAL SIZE OF THE FILE(WORDS)
	IDIVI	T4,200		;CONVERT TO BLOCKS AND WORD
	MOVEI	T0,1(T4)	;GET THE BLOCK POINTER
	HRRM	T0,DD.BLK(P3)	;SAVE THE BLOCK NUMBER
	HLL	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	SKIPN	T4		;CHECK FOR A NULL FILE
	JUMPE	T5,OPEND0	;AND A NULL WORD COUNT
	TLO	T0,(USETI)	;SET UP FOR INPUT OF LAST BLOCK
	XCT	T0		;GET THE FILSER TO THE LAST BLOCK
	HLLZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T1,(IN)		;TRY TO READ THE LAST BLOCK
	XCT	T1		;GET THE BLOCK
	  JFCL			;READ PROTECTED IGNORE
	TLO	T0,(USETO)	;SET THE OUTPUT BLOCK NUMBER
	XCT	T0		;TELL FILSER
OPEND0:	HRRZ	T1,DD.HRI(P3)	;GET THE INPUT HEADER
	PUSHJ	P,FIND4		;SET UP THE RING HEADRS
	TLO	P3,IO.RNG	;SET RING CHANGE FLAG
OPEND9:	JUMPI	OPENDA		;JUMP ON INPUT
	TLNN	P3,IO.RAN	;RANDOM ACCESS
	PUSHJ	P,OBLOK.	;DO A DUMMY OUTPUT
OPENDA:	TLNE	G3,DV.TTY!DV.TTA!DV.LPT	;CHECK FOR FORM CONTROL
					;NO, FORMS CONTROL ON A PTY
	TLO	P3,IO.CCC	;SET FORMS FLAG
OPEND7:	HLRZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	LSH	T1,-5		;POSITION THE CHANNEL NUMBER
	DPB	T1,FLU.BP(P4)	;PUT TH CHANNEL IN THE FLU TABLE
	ADDI	T1,CHN.TB(P4)	;RELOCATE TO THE CHANNEL TABLE
	TLO	P3,IO.OPN	;SET FILE OPEN
	MOVEM	P3,(T1)		;SAVE THE I/O REG IN THE CHANNEL TABLE
	TLNN	G3,DV.MTA	;IS THIS A MAG TAPE
	SKIPN	T1,DD.RLS(P3)	;CHECK FOR A REELS PARAMETER
	POPJ	P,		;RETURN
	SETZM	DD.RLS(P3)	;CLEAR THE REELS POINTER
	PJRST	PMEM%%		;YES, DELETE THE REELS ARRAY



OPENER:	HLLZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T1,(RELEAS)	;GET A RELEASE UUO
	XCT	T1		;DELETE ALL MONITOR REFERENCES
	HRRZ	T1,-1(P3)	;GET THE BUFFER LINK POINTER
	JUMPE	T1,OPENE0	;ARE BUFFERS ASSIGNED
	HLLZS	-1(P3)		;CLEAR THE LINK POINTER
	PUSHJ	P,PMEM13	;DELETE THE BUFFERS
OPENE0:	AOS	(P)		;SKIP ON ERROR RETURN
	POPJ	P,		;TAKE THE ERROR RETURN
	SUBTTL ALCXXX GENERAL ROUTINES TO ACCESS AND DEFINE DD.BLK AREAS

ALCBUF:	PUSH	P,G2		;SAVE GLOBAL G2
	HLRZ	G2,G1		;LOAD THE BUFFER COUNT
	PUSH	P,G1		;SAVE THE CONTROL WORD
	HRLZI	G1,-2(G1)	;GET THE TRUE BUFFER SIZE
	HRRZ	T0,(P)		;GET THE SIZE OF THE CORE BLOCK
	PUSHJ	P,GMEM%%	;ALLOCATE THE CORE BLOCK
	HRRI	G1,1(T1)	;SET G1 TO THE SECOND WORD OF THE RING HEADER
	PUSH	P,G1		;SAVE THE INITIAL POINTER TO THE RING
	SOJLE	G2,ALCBU2	;CHECK FOR SINGLE BUFFERING
ALCBU1:	HRRZ	T0,-1(P)	;GET THE CORE BLOCK SIZE
	PUSHJ	P,GMEM%%	;GET ANOTHER CORE BLOCK
	MOVEM	G1,1(T1)	;SET THE SECOND WORD OF THE RING HEADER
	SUBI	T1,1		;POINT TO THE LINK WORD IN THE CORE LIST
	HRRM	T1,-2(G1)	;LINK THE CORE BLOCK TOGETHER
	HRRI	G1,2(T1)	;CREATE THE NEXT RING POINTER
	SOJG	G2,ALCBU1	;BACK FOR ANOTHER BUFFER
ALCBU2:	POP	P,T1		;GET THE INITIAL RING POINTER
	MOVEM	G1,(T1)		;LINK THE BUFFER IN A RING
	POP	P,G1		;RESTORE THE ARGUMENT WORD
	POP	P,G2		;RESTORE GLOBAL G2
	POPJ	P,0		;RETURN


;	GENERAL LOOKUP/ENTER ROUTINES FOR DECTAPE AND DSK

RENAM.:	MOVE	T1,[RENAME 0,DD.CNT(P3)]	;GET THE RENAME  UUO
	JRST	ENTER.+1
LOOKU.:	SKIPA	T1,[LOOKUP 0,DD.CNT(P3)]	;GET LOOKUP FOR DSK
ENTER.:	MOVE	T1,[ENTER 0,DD.CNT(P3)]	;GET ENTER FOR DSK
	HLLZS	DD.EXT(P3)	;CLEAR THE ERROR BITS
				;**;[406],ENTER.+2,MD,10/16/74
	MOVSI	T0,777740	;[406] SET MASK FOR PROTECTION CODE
	ANDM	T0,DD.PRV(P3)	;[406] CLEAR ALL BUT PROT. AND MODE
				;[406] MONITOR TAKES CARE OF DATES
	HLLZ	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER (BITS 9-12)
	IOR	T1,T0		;PUT CHANNEL NUMBER IN UUO
	TLNN	G3,DV.DSK	;IS THIS A DSK(EXTENDED LOOKUP/ENTER)
	ADDI	T1,DD.NAM-DD.CNT;LEVEL C OR NOT DSK(USE STANDARD LOOKUP)
	XCT	T1		;DO THE UUO
	SKIPA	T1,DD.EXT(P3)	;GET THE ERROR CODE IN T1
	JRST	1(P1)		;OK RETURN
	TRNE	T1,-1		;CHECK FOR FILE NOT FOUND
	ERROR	(OPN,0,7,OPENER);SOMETHIN ELSE ERROR RETURN TO TRY AGAIN
	JRST	(P1)		;TAKE FILE NOT FOUND RETURN

;DEFINE THE MODE OF THE FILE

OPENDM:	LDB	T5,[POINT 4,DD.BLK(P3),13] ;GET THE MODE INDEX
	HLRZ	T4,MOD.DP(T5)	;GET THE OPEN MODE
	ANDI	T4,17		;MAKE IN 4 BITS WIDE
	MOVEI	T3,1		;MAKE A 1 BIT MASK
	LSH	T3,(T4)		;POSITION THE BIT FOR MODE CHECK
	TDNN	T3,DD.STS(P3)	;IS THE MODE LEGAL
	JRST	(P1)		;TAKE ERROR RETURN
	MOVEI	T3,17		;GET A 4 BIT MASK
	ANDCAM	T3,DD.OPN(P3)	;CLEAR THE MODE FIELD
	LDB	T3,[POINT 3,DD.BLK(P3),5];GET PARITY/DENSITY
	LSH	T3,7		;POSITION
	TLNE	G3,DV.MTA	;IS THE DEVICE MAG TAPE
	IORI	T4,(T3)		;YES, PUT IN THE OPEN STATUS
	IORM	T4,DD.OPN(P3)	;YES, LEGAL MODE STORE FOR OPEN
	CAIGE	T5,MOD.FM	;IS THE MODE REQUESTE FORMATED
	TLO	P3,IO.FMT	;YES, SET FORMATED I/O MODE
	CAIE	T5,MOD.AS-MOD.DP;ASCII MODE
	CAIN	T5,MOD.BN-MOD.DP;OR BINARY
	TLZA	P3,IO.NON	;YES, CLEAR NON- STANDARD MODE
	TLO	P3,IO.NON	;NON-STANDARD MODE REQUEST
	JRST	1(P1)		;RETURN TO CALLER
	SUBTTL	OPNARG PICKS UP THE OPEN/CLOSE STATEMENT ARGS
OPNARG:
	SETZ	P3,		;CLEAR THE I/O REGISTER
IFN %V1,<
	JUMPL	L,OPNAR0	;JUMP IF NEW CALL
	LDB	T1,[POINT 9,(L),8];GET THE ARG COUNT
	MOVNI	T1,(T1)		;NEGATIVE COUNT
	HRLI	L,(T1)		;BUILD THE AOBJN POINTER
>
OPNAR0:	AOBJP	L,OPNAR4	;JUMP IF ARG LIST IS NULL
OPNAR1:	JSP	P1,EFCTV.	;[265] GET THE EFFECTIVE ADDRESS
	TRNN	G1,-20		;IN THE AC SAVE AREA
	ADDI	G1,ACC.SV(P4)	;YES, RELOCATE
	MOVE	T1,(G1)		;GET THE VALUE OF THE ARGUMENT
	LDB	T5,[POINT 4,(L),12]	  ;GET THE USER SUPPLIED ARG TYPE
	LDB	G3,[POINT 8,(L),8] ;GET THE FUNCTION CODE
	LDB	G2,[POINT 3,OP.DSP(G3),8] ;GET THE ARGUMENT TYPE
	CAILE	G2,SCNSIX-SCNNER	;COMPARE THE ARGUMENT
	CAIN	T5,TP%LIT	;AGAINST THE USER'S SUPPLIED
	PUSHJ	P,SCNNER(G2)	;YES, CONVERT TO SIXBIT
	PUSHJ	P,@OP.DSP(G3)	;GO TO SWITCH ROUTINE
	AOBJN	L,OPNAR1	;GET THE NEXT ARGUMENT
	JUMPE	P3,OPNAR4	;DIALOG PARAMETERS PENDING
OPNAR3:	TLO	P2,OP.OPN	;YES, COLLECT THE PARAMETERS
	PUSHJ	P,DIALOG	;GO TO THE DIALOG ROUTINE
OPNAR4:	TLNN	P2,OP.ERR	;ERROR PENDING
	POPJ	P,		;END OF OPEN ARG AND DIALOGS
OPNAR5:	SKIPGE	JOB.SV(P4)	;FORCE THE ERROR DIALOG IF NOT BATCH
	ERROR	(SYS,4,16,)	;EXIT WITH FATAL ERROR MESSAGE
	MOVE	P3,CHN.TB+20(P4);GET THE TTY CHANNEL FOR DIALOG
	JRST	OPNAR3		;DO IT AGAIN WITH THE USER'S TTY
	SUBTTL OPEN DIALOG MODE ROUTINE
SCNSWT:	SETZ	G3,		;CLEAR THE SWITCH INDEX
	JUMPN	T2,SCNSW0	;IS THERE A DELIMETER PENDING
SCNSWZ:	PUSHJ	P,SCNSIX	;NO, GO GET SOMETHING
	JUMPE	T1,SCNSW0	;GO CHECK FOR A SWITCH
	MOVEI	G3,INXNAM	;ASSUME A FILE NAME
	TRZE	T2,1B':'	;IS THIS A DEVICE
	MOVEI	G3,INXDEV	;YES, PROCESS THE DEVICE NAME
	JRST	SCNSW6		;DATAM IS IN  AC T1
SCNSW0:	TLZE	T2,(1B'/')	;IS THIS A SWITCH
	JRST	SCNSW1		;YES, PROCESS THE SWITCH
	TLZE	T2,400000	;CHECK FOR END
	POPJ	P,
	TRZE	T2,1B'<'	;CHECK FOR A PROTECTION CODE
	MOVEI	G3,INXPRV	;YES, GO TO PROTECTION ROUTINE
	TRZE	T2,1B19		;NO,CHECK FOR A [ PPN,SFD]
	MOVEI	G3,INXPPN	;YES GO PROCESS THE PPN,SFD
	JUMPN	G3,SCNSW5	;PROCESS THE PSEUDO SWITCH
SWTDLM:	SETZB	T1,T1		;[237] SET ILLEGAL DELIMITER
SWTERR:	SETZB	G3,G3		;SET SWITCH ERROR FOUND(MAKE SURE IT IS ZERO)
SWTERV:	TLO	P2,OP.ERR	;SET ERROR FOUND FLAG(ARGUMENT)
	ERROR	(OPN,11,7,CPOPJ)

SCNSW1:	TLNE	P2,OP.DIA	;SWITCH STOP THE DIALOG ARGUMENT SCAN
	POPJ	P,		;RETURN
	PUSHJ	P,SCNFIV	;GET THE SWITCH ID
	TRZN	T2,1B'='!1B':'	;SWITCH MUST BE TERMINATES BY AN =
	JRST	SWTDLM		;[237] ILLEGAL DELIMITER
	MOVE	T4,[XWD -OP.MAX,OP.SWT]	;GET THE SWITCH TABLE
	JSP	P1,SCNTBL	;SCAN THE TABLE
	JRST	SWTERR		;NOT AN UNIQUE TABLE ENTRY
	MOVEI	G3,(T4)		;GET THE SWITCH INDEX
SCNSW5:	LDB	G2,[POINT 3,OP.DSP(G3),8] ;LOAD THE SCANNER TYPE
	PUSHJ	P,SCNNER(G2)	;GET THE ARGUMENT FOR THE SWITCH
SCNSW6:	PUSHJ	P,@OP.DSP(G3)	;PROCESS THE ARGUMENT
	JRST	SCNSWT		;PROCESS NEXT SWITCH
	SUBTTL OPNXXX SWITCH PROCESSING ROUTINES
OPNDEV:
	MOVEM	T1,DD.DEV(P2)	;SAVE THE DEVICE NAME
	POPJ	P,		;RETURN TO THE SWITCH SCANNER

OPNBUF:
	HRLM	T1,DD.BUF(P2)	;SAVE THE BUFFER COUT
	POPJ	P,		;RETURN TO THE SWITCH SCANNER

OPNBLK:
	ADDI	T1,3		;ALLOCATE SPACE FOR BUFFER HEADER
	HRRM	T1,DD.BUF(P2)	;SAVE THE BLOCK SIZE
	POPJ	P,		;RETURN TO THE SWITCH SCANNER

OPNNAM:
	MOVEM	T1,DD.NAM(P2)	;SAVE THE FILE NAME
	MOVSI	T1,(SIXBIT /DAT/);DEFAULT EXTENSION
	TLZE	T2,(1B'.')	;IS THERE AN EXTENSION FOLLOWING
	PUSHJ	P,SCNSIX	;YES, GET THE EXTENSION
	HLLZM	T1,DD.EXT(P2)	;SAVE THE EXTENSION
	POPJ	P,		;RETURN TO THE SWITCH SCANNER

OPNPPN:
	TLNN	P2,OP.OPN!OP.DIA	;DIALOG MODE
	CAIN	T5,TP%LIT	;LITERAL TYPE
	JRST	OPNPP2		;YES, TREAT AS DIALOG MODE
	SKIPN	G2,T1		;DEFAULT PPN
	JRST	OPNPP3		;YES
	TLNE	G2,-1		;PROJECT NUMBER IN THE LEFT
	JRST	OPNPP3		;YES, PPN IS OK
	HRL	G2,T1		;NO, PUT PROJ NUMBER IN LEFT
	HRR	G2,1(G1)	;PUT PROGRAMMER  NUMBER IN RIGHT HALF
	AOS	G1		;UPDATE POINTER
OPNPP3:	AOJA	G1,OPNPP4	;UPDATE POINTER
OPNPP2:	TLZN	T2,(1B',')	;[237] CHECK FOR A COMMA
	PJRST	SCNDLM		;[237] ILLEGAL DELIMITER
	JUMPG	T2,SCNDLM	;[237] ILLEGAL DELIMITER
	HRLZ	G2,T1		;SAVE THE PROJECT NUMBER
	PUSHJ	P,SCNOCT	;GET THE PROGRAMMER NUMBER
	TRZ	T2,1B21		;[237] CLEAR RIGHT BRACKET
	TLNN	T2,(1B','!1B'/');[237] ALLOW / OR , AFTER PPN
	JUMPG	T2,SCNDLM	;[237] ILLEGAL DELIMITER
	HRR	G2,T1		;SAVE PROGRAMMER NUMBER
OPNPP4:	SKIPN	T1,DD.PPN(P2)	;GET THE POINTER WORD
	HRLI	T1,-1		;CORE BLOCK NOT AVAILABLE
	TLNN	T2,(1B'/')	;[237] NO SFD AFTER /
	JUMPG	T2,OPNPP5	;[237] NO, CHECK FOR SFD'S
	TLNN	T1,-1		;PPN OR CORE POINTER
	PUSHJ	P,PMEM%%	;CORE POINTER DELETE CORE BLOCK
	MOVEM	G2,DD.PPN(P2)	;SAVE THE PPN
	POPJ	P,		;RETURN

OPNPP5:	MOVEI	T0,^D11		;MAX SFD'S =8 + PPN'S
	PUSH	P,T5		;SAVE THE TYPE CODE
	TLNE	T1,-1		;CHECK FOR A CORE POINTER OF PPN
	PUSHJ	P,GMEM%%	; PPN, GET DYNAMIC CORE
	POP	P,T5		;RESTORE THE TYPE CODE
	HRRZM	T1,DD.PPN(P2)	;SAVE SFD POINTER
	MOVEM	G2,2(T1)	;SAVE PPN
	MOVEI	G2,3(T1)	;SET UP THE POINTER TO THE SFD LIST
	HRLI	G2,-^D8		;MAKE AN AOBJN POINTER
	PJRST	SCNSTR		;GET THE ID FIELD FORM SCNSTR

OPNPR1:	PUSHJ	P,SCNOCT
OPNPRV:	SKIPGE	P2		;DIALOG MODE
	JUMPE	T2,SCNDLM	;[237] YES, NOT AN OCTAL NUMBER
	DPB	T1,[POINT 9,DD.PRV(P2),8]	;[322] SAVE PROTECTION CODE
	TRZ	T2,1B'>'	;CHECK THE TERMINATOR
	POPJ	P,		;JUST RETURN

OPNEST:
	MOVEM	T1,DD.EST(P2)	;SAVE ESTIMATED FILE SIZE
	POPJ	P,		;RETURN

OPNREC:
	MOVNM	T1,DD.LOG(P2)	;SAVE THE LOGICAL RECORD LENGTH
				;SET NEGATIVE DON'T KNOW (CHAR/WORD)
	POPJ	P,		;RETURN

OPNVER:
	MOVEM	T1,DD.VER(P2)	;[343] STORE VERSION NUMBER
	POPJ	P,		;RETURN

OPNRLS:
	MOVEI	T0,^D12		;NO, ASK FOR DYNAMIC CORE
	PUSH	P,T5		;SAVE THE TYPE CODE
	SKIPN	T1,DD.RLS(P2)	;HAS SPACE BEEN ALLOCATED FOR REELS
	PUSHJ	P,GMEM%%	;GET DYNAMIC CORE FOR REELS ARRAY
	POP	P,T5		;RESTORE THE TYPE CODE
	HRRZM	T1,DD.RLS(P2)	;SAVE THE ADDRESS OF THE ARRAY
OPNRL1:	MOVEI	G2,(T1)		;GET THE ADDRESS
	HRLI	G2,-^D10	;MAKE AN AOBJN POINTER TO THE REELS BLOCK
	PJRST	SCNSTR		;GET THE ID FIELDS FOR SCNSTR
				; T1 = THE FIRST REEL ID

OPNLIM:
	MOVEM	T1,DD.LIM(P2)	;SAVE IN DD BLOCK
	POPJ	P,		;RETURN

OPNASC:
	HRRZM	G1,DD.ASC(P2)	;SAVE THE ASSOCIATE VARIABLE ADDRESS
	POPJ	P,		;RETURN

OPNERV:
	HRRZM	G1,DD.ERV(P2)	;SAVE THE ERROR VARIABLE ADDRESS
	POPJ	P,		;RETURN
OPNUNT:
	POPJ	P,		;RETURN

OPNACC:				;DEFINE THE ACCESS METHOD
	MOVE	T4,[XWD -ACC.SZ,ACC.TB]	;GET THE TABLE ENTRY
	JSP	P1,SCNTBL	;FIND THE ENTRY
	JRST	SWTERV		;NOT FOUND
	DPB	T4,[POINT 4,DD.BLK(P2),9] ;STORE THE ACCESS POINTER
	POPJ	P,		;RETURN

OPNMOD:				;DEFINE THE FILE MODE AND ACCESS
	MOVE	T4,[XWD -MOD.SZ,MOD.TB]	;GET THE MODE TABLE
	JSP	P1,SCNTBL	;FIND THE ENTRY
	JRST	SWTERV		;NOT FOUND
	DPB	T4,[POINT 4,DD.BLK(P2),13] ;STORE THE MODE INDEX
	POPJ	P,		;RETURN

OPNDIS:				;DEFINE THE DISPOSE ARGUMENT
	MOVE	T4,[XWD -DIS.SZ,DIS.TB]	;GET THE TABLE ENTRY
	JSP	P1,SCNTBL	;FIND THE ENTRY
	JRST	SWTERV		;NOT FOUND
	DPB	T4,[POINT 4,DD.BLK(P2),17] ;STORE THE DISPOSE INDEX
	POPJ	P,		;RETURN

OPNPAR:			;MAG TAPE PARITY
	MOVSI	T3,(1B3)	;SET UP A MASK FOR PARITY
	ANDCAM	T3,DD.BLK(P2)	;CLEAR THE PARITY BIT
	HLRZS	T1		;GET THE PARITY IN THE RIGHT HALF
	CAIN	T1,'ODD'	;/PARITY=ODD
	POPJ	P,		;YES, EXIT
	CAIE	T1,'EVE'	;/PARITY=EVEN
	JRST	SWTERV		;NO, ILLEGAL ARGUMENT
	IORM	T3,DD.BLK(P2)	;YES, SET EVEN PARITY
	POPJ	P,		;RETURN

OPNDEN:				;MAG TAPE DENSITY
	SETZ	T0,		;[352] CLEAR
	MOVSI	T3,(3B5)	;MASK TO CLEAR THE DENSITY
	ANDCAM	T3,DD.BLK(P2)	;CLEAR THE DENSITY
	CAMN	T1,['200',,0]	;[352] /DENSITY=200
	TLO	T0,(1B5)	;YES, SET IT
	CAMN	T1,['556',,0]	;[352] /DENSITY=556
	TLO	T0,(2B5)	;YES, SET IT
	CAMN	T1,['800',,0]	;[352] /DENSITY=800
	TLO	T0,(3B5)	;YES, SET IT
	JUMPE	T0,SWTERV	;NO, ERROR
	IORM	T0,DD.BLK(P2)	;STORE THE DENSITY
	POPJ	P,		;RETURN
OPNDIA:			;DILOG ROUTINE TO CHANGE THE INPUT DEVICE
			;FOR OPEN STATEMENT ARGUMENTS
	SKIPE	T1,P3		;IS A BLOCK ASSIGNED
	TLNE	P3,IO.TTA	;AND THE USR'S TTY
	JRST	.+2		;NO,
	PUSHJ	P,RELE%1	;RELEASE THE SYSTEM CHANNEL
	PUSH	P,P2		;SAVE THE CURRENT DD.BLK POINTER
	PUSH	P,T5		;[204] GMEM CLOBBERS T5
	MOVEI	T0,DDB.SZ	;ALLOCATE A DDB WORD BLOCK
	PUSHJ	P,GMEM%%	;ALLOCATE IT
	POP	P,T5		;[204] RESTORE T5
	MOVEI	P2,(T1)		;SET UP NEW POINTER TO DIALOG BLOCK
	MOVSI	T1,(SIXBIT /TTY/)	;DEFAULT DEVICE IS TTY
	MOVEM	T1,DD.DEV(P2)	;PUT IN DD.BLK OVERRIDDEN BY DIALOG
	TLO	P2,OP.DIA	;TELL SCAN LOOKING DIALOG ARGS
	SETZ	T2,		;CLEAT THE FLAGS FOR THE SCANNER
	PUSHJ	P,SCNSWT	;SCAN THE DIALOG ARGUMENT
	MOVEI	P3,(P2)		;SET THE DIALOG BLOCK IN P3
	PUSHJ	P,OPEND		;OPEN THE DIALOG BLOCK
	JRST	OPNDI2		;BLOK OPEN
	ERROR	(OPN,14,7,OPNDI1)	;ERROR IN DIALOG OPN
OPNDI1:	PUSHJ	P,RELE%1	;RELEASE THE DDB BLOCK
	SETZ	P3,		;CLEAR THE DIALOG BLOCK
	TLO	P2,OP.ERR	;SET THE ERROR FLAG
OPNDI2:	POP	P,P2		;RESTORE THE PRIMARY DD UNIT
	JUMPGE	P2,CPOPJ	;RETURN IF NOT ALREADY IN DIALOG
;	PJRST	DIALOG

;	ROUTINE TO ACCESS THE DIALOG DEVICE

DIALOG:
	TLNN	P3,IO.TTA	;USER'S TTY
	JRST	DIALO1		;DON'T OUTPUT A MESSAGE
	TLZE	P2,OP.ERR	;ERROR CONDITION WITH TTY DEFAULT
	JRST	DIALO2	;YES, DDB HAS BEEN TYPED
	EXCH	P2,P3		;SET UP TO TYPE THE DDB
	PUSHJ	P,TY%DDB##	;TELL THE USER THE UNIT
	EXCH	P2,P3		;RESTORE THE I/O REG'S
DIALO2:
	OUTSTR	[ASCIZ/
Enter new file specs. End with an $(ALT)
*/]
	PUSHJ	P,IBLOK2	;FLUSH THE TTY INPUT BUFFER
DIALO1:	SETZ	T2,		;CLEAR THE DELIMITER SWITCH
	TLZ	P3,IO.INO	;FORCE INPUT MODE
	PJRST	SCNSWT		;GET THE ARGS
SUBTTL SCANNER ROUTINE FOR PPN AND REELS
SCNSTR:			;SPECIAL STRING SCANNER FOR REELS/PPN ROUTINES
	PUSHJ	P,SCNSIX	;GET THE ID NAME
SCNST1:	MOVEM	T1,(G2)		;SAVE THE  ID NAME
	SKIPL	P2		;CHECK FOR SCANNER MODE
	SKIPE	(G1)		;CHECK FOR A NULL TERMINATOR
	TLZN	T2,(1B','!1B' ');COMMA OR BLANK
	TRZA	T2,1B21		;RIGHT BRACKET ]
	AOBJN	G2,SCNSTR	;GET NEXT ID ARG
SCNST2:	SETZM	1(G2)		;SET END OF ARRAY FLAG
	POPJ	P,		;RETURN


;ROUTINE TO SCAN A TABLE FOR AN UNIQUE ENTRY ARG MAY BE ABR.

;ENTRY
;	T0	SCRATCH
;	T1=	FIVE NAME TO SCAN FOR
;	T2=	NOT USED (CONTAINS FLAGS)
;	T3=	SCRATCH
;	T4=	-TABLE SIZE,,TABLE ADDRESS
;	T5=	SCRATCH

;RETURN
;	T4=	THE INDEX INTO THE TABLE (N,,N)
;	NON-SKIP RETURN OF ENTRY NOT FOUND
;	SKIP RETURN OF FOUND IN THE TABLE
SCNTBL:
	PUSH	P,T4		;SAVE THE ARGUMENT
	SETZ	T0,		;CLEAR THE FLAG WORD
	SETO	T3,		;SET UP A MASK
	LSH	T3,-5		;SHIFT MASK
	TDNE	T1,T3		;CHECK MASK AGAINST SIGNIFICANT BYTES
	JUMPN	T3,.-2		;RETRY THE MASK TEST
SCNTB1:	MOVE	T5,(T4)		;SEARCH TABLE FOR DEFINED SWITCHES
	ANDCAM	T3,T5		;REDUCE THE SWITCH TO USER LENGTH
	CAME	T5,T1		;IS THIS THE SWITCH
SCNTB2:	AOBJN	T4,SCNTB1	;REDUCE COUNT AND CONTINUE SEARCH
	JUMPGE	T4,SCNTB3	;END OF LIST CHECK RESULTS
	SKIPE	T0		;HAVE WE SEEN A ABRIV. SWITCH
	SETO	T0,		;YES, SET MULTI SWITCH FLAG
	HRRI	T0,(T4)		;SAVE SWITCH INDEX IN ANY CASE
	CAME	T1,(T4)		;EXACT MATCH
	JRST	SCNTB2		;NO CONTINUE
	ANDI	T0,-1		;YES, CLEAR THE MULTI SWITCH FLAG
SCNTB3:	MOVE	T4,T0		;GET THE ABS ADDRESS IN T4
	POP	P,T0		;GET THE ARGUMENT BACK
	JUMPLE	T4,(P1)		;ERROR ARGUMENT NOT IN TABLE
	SUB	T4,T0		;RELOCATE TO INDEX
	ANDI	T4,-1		;RIGHT HALF ONLY
	JRST	1(P1)		;RETUNRN
	SUBTTL TABLES FOR THE OPEN STATEMENT
OP.SWT::
	FIVBIT	(UNIT  )	;00 /UNIT=INTEGER
	FIVBIT	(DIALOG)	;01 /DIALOG=STRING
	FIVBIT	(ACCESS)	;02 /ACCESS=STRING
	FIVBIT	(DEVICE)	;03 /DEVICE=STRING
	FIVBIT	(BUFFCOU)	;04 /BUFFER=INTEGER
	FIVBIT	(BLOCKSI)	;05 /BLOCK SIZE=INTEGER
	FIVBIT	(FILE   )	;06 /FILE NAME=STRING.STRING
	FIVBIT	(PROTECT)	;07 /PROTECTION=OCTAL
	FIVBIT	(DIRECT)	;10 /DIRECTORY=OCTAL,OCTAL,STRING,,,
	FIVBIT	(LIMIT )	;11 /LIMIT=INTEGER
	FIVBIT	(MODE  )	;12 /MODE=STRING
	FIVBIT	(FILESIZ)	;13 /FILE SIZE=INTEGER
	FIVBIT	(RECORDS)	;14 /RECORD SIZE=INTEGER
	FIVBIT	(DISPOSE)	;15 /DISPOSE=STARING
	FIVBIT	(VERSION)	;16 /VERSION=INTEGER
	FIVBIT	(REELS )	;17 /REELS=STRING,STRING....
	FIVBIT	(MOUNT )	;20 /MOUNT=STRING
	OCT	-1		;21 ERROR VARIABLE
	OCT	-1		;22 ASSOCIATE VARIABLE
	FIVBIT	(PARITY)	;23 /PARITY=STRING
	FIVBIT	(DENSITY)	;24 /DENSITY=STRING
OP.MAX==.-OP.SWT			;MAXIUM TABLE SIZE
	DEFINE OPNARG(LABEL,CONTYP,TYPE)
<IFNDEF DD.'LABEL,<DDBINX==0>
IFDEF DD.'LABEL,<DDBINX==DD.'LABEL>
BYTE	(6)DDBINX(3)<SCN'CONTYP-SCNNER>(4)TP%'TYPE(5)0(18)OPN'LABEL
	INX'LABEL==.-OP.DSP-1>

OP.DSP::
	OPNARG	UNT,DEC,INT	;0	UNIT=	
	OPNARG	DIA,NER,LIT	;1	DIALOG=		/DIALOG=
	OPNARG	ACC,FIV,LIT	;2	ACCESS=		/ACCESS=ILLEGAL
	OPNARG	DEV,SIX,LIT	;3	DEVICE=		STRING:
	OPNARG	BUF,DEC,INT	;4	BUF COUNT=	/BUF COUNT=
	OPNARG	BLK,DEC,INT	;5	BLOCK SIZE=	/BLOCK SIZE=
	OPNARG	NAM,SIX,LIT	;6	FILE NAME=	STRING.STRING
	OPNARG	PRV,OCT,OCT	;7	PROTECTION=	/PROTECT= OR <NNN>
	OPNARG	PPN,OCT,OCT	;10	DIRECTORY=	/DIRECTORY OR [N,N,STRING]
	OPNARG	LIM,DEC,INT	;11	LIMIT=		/LIMIT=
	OPNARG	MOD,FIV,LIT	;12	MODE=		/MODE=
	OPNARG	EST,DEC,INT	;13	FILE SIZE=	/FILE SIZE=
	OPNARG	REC,DEC,INT	;14	RECORD SIZE=	/RECORD=
	OPNARG	DIS,FIV,LIT	;15	DISPOSE=	/DISPOSE=
	OPNARG	VER,OCT,OCT	;16	VERSION=	/VERSION=
	OPNARG	RLS,NER,LIT	;17	REELS=		/REELS=STRING,STRING,...
	OPNARG	MNT,SIX,LIT	;20	MOUNT=		/MOUNT=
	OPNARG	ERV,OCT,UDF	;21	ERROR=
	OPNARG	ASC,OCT,UDF	;22	ASSOCIATE VARIABLE=
	OPNARG	PAR,SIX,LIT	;23	PARITY=		/PARITY=STRING
	OPNARG	DEN,SIX,LIT	;24	DENSITY=	/DENSITY=STRING


OPNMNT:
	POPJ	P,


;	THE FOLLOWING MODES ARE NOT IMPLEMENTED
;	(LINED,SIXBIT,EBCDIC,BCD)

MOD.TB::			;/MODE=STRING
	FIVBIT	(ASCII)		;0  /MODE=ASCII
OCT -1;	FIVBIT	(LINED)		;1  /MODE=LINED,INTEGER
OCT -1;	FIVBIT	(SIXBIT)	;2  /MODE=SICBIT
OCT -1;	FIVBIT	(EBCDIC)	;3  /MODE=EBCDIC
OCT -1;	FIVBIT	(BCD)		;4  /MODE=BCD
	FIVBIT	(BINARY)	;5  /MODE=BINARY
	FIVBIT	(IMAGE)		;6  /MODE=IMAGE
	FIVBIT	(DUMP)		;7  /MODE=DUMP
MOD.SZ==.-MOD.TB


	DEFINE MODARG(BYTSIZ,MODE)<
	BYTE (6)0(6)BYTSIZ(2)0(4)MODE(18)0>

MOD.DP:				;DEFINE THE ACCESS MODE BITS
MOD.AS:	MODARG	7,0		;/ASCII
	MODARG	7,0		;/LINED
	MODARG	6,14		;/SIXBIT
	MODARG	8,14		;/EBCDIC
	MODARG	6,14		;/BCD
MOD.FM=.-MOD.DP		;DEFINE THE END OF THE FORMATED I/O MODES
MOD.BN:	MODARG	44,14		;/BINARY
MOD.IM:	MODARG	(0,10)		;/IMAGE
MOD.DU==.-MOD.DP		;DEFINE THE DUMP MODE NDEX
	MODARG	44,17		;/DUMP

ACC.TB::			;ACCESS TABLE
	FIVBIT	(SEQINOU)	;SEQUENTAIL INPUT/OUTPUT(DEFAULT)
ACC.SI==.-ACC.TB		;[316] DEFINE SEQIN ACCESS
	FIVBIT	(SEQIN)		;SEQUENTAIL INPUT
	FIVBIT	(SEQOUT)	;SEQUENTAIL OUTPUT
ACC.RO==.-ACC.TB		;[316] DEFINE RANDOM ACCESS
	FIVBIT	(RANDOM)	;RANDOM ACCESS
	FIVBIT	(RANDIN)	;RANDOM INPUT
				;**;[402],ACC.TB+5,MD,9/17/74
ACC.AP==.-ACC.TB		;[402] DEFINE APPEND ACCESS
	FIVBIT	(APPEND)	;APPEND MODE
ACC.SZ==.-ACC.TB		;ACCESS TABLE SIZE

ACC.DP:				;ACCESS FLAG BITS
	XWD	IO.SIN!IO.SOU	;SEQ IN/OUT(DEFAULT)
	XWD	IO.SIN		;SEQ IN
	XWD	IO.SOU		;SEQ OUT
	XWD	IO.RAN!IO.SIN	;RANDOM INPUT.OUTPUT(IO.SOU GET SET
				;AT THE FIRST ENTER
	XWD	IO.RAN!IO.SIN		;RANDOM INPUT
	XWD	IO.RAN!IO.SOU		;APPEND OUTPUT

DIS.TB::			;DISPOSE TABLE
	FIVBIT	(SAVE)		;/DISPOSE=SAVE	(DEFAULT)
	FIVBIT	(DELETE)	;/DISPOSE=DELETE
	FIVBIT	(RENAME)	;/DISPOSE=RENAME
QUE.DP==.-DIS.TB		;FOLLOWING ENTRIES REQUIRED QMANGR TO EXECUTE
	FIVBIT	(PRINT)		;/DISPOSE=PRINT
	FIVBIT	(PUNCH)		;/DISPOSE=PUNCH
DIS.LS==.-DIS.TB		;[344] CODE NUMBER OF LIST
	FIVBIT	(LIST)		;[344] /DISPOSE=LIST
DIS.SZ==.-DIS.TB		;TABLE SIZE
	SUBTTL	SCANNER ROUTINE TO SCAN AND CONVERT ASCII STRINGS
SCNDLM:	MOVEI	T2,1		;[237] SET ILLEGAL DELIMITER
SCNNER:	POPJ	P,		;DUMMY ENTRY POINT
SCNFIV:	SKIPA	T2,[POINT 5]	;SET FIVBIT SCAN MODE
SCNSIX:	MOVSI	T2,(POINT 6)	;SET SIXBIT BYTE POINTER
	AOJA	T2,SCNCON	;SET BYTE POINTER TO T1 ADDRESS
SCNOCT:	SKIPA	T2,[10]		;SET OCTAL SCAN MODE
SCNDEC:	MOVEI	T2,12		;SET DECIMAL SCAN MODE
SCNCON:	SETZ	T1,		;CLEAR THE OUTPUT WORD
	JUMPL	P2,SCNSI0	;CHECK FOR MEMORY SCAN(DIALOG)
	TLNE	G1,-1		;[217] IS G1 ALREADY A BYTE POINTER?
	JRST	SCNSI1		;[217] YES - CONTINUE SCAN
	HRLI	G1,(POINT 7)	;NO - MAKE G1 A BYTE POINTER
	MOVEI	G4,^D6		;[217] ASSUME SINGLE PRECISION (5 CHAR + NULL)
	CAIE	T5,TP%DOR	;CHECK FOR DOUBLE PRECISION
	CAIN	T5,TP%COM	;OR COMPLEX VARIABLE
	MOVEI	G4,^D11		;[217] YES, DOUBLE PRECISION (10 CHAR + NULL)
	CAIN	T5,TP%LIT	;[217] CHECK FOR STRING VARIABLE
SCNSI0:	SETO	G4,		;[217] ALLOW INFINITE STRING
SCNSI1:	SOJE	G4,SCNSIZ	;END OF ALLOWABLE CHARACTER COUNT
	JUMPGE	P2,SCNSI8	;G1=ARGUMENT ADDR FOR OPEN STATEMENT
				; OR A POINTER TO THE DIALOG BLOCK (DIALOG)
	TLNE	P3,IO.EOL	;AT END OF LINE
	PUSHJ	P,NXTLNI	;YES, GET THE NEXT INPUT LINE
	JSP	P1,IBYTE.	;GET AN INPUT CHARACTER
	CAIE	T0,176		;CHECK FOR THE ALT MODES
	CAIN	T0,175		;AGAIN
	MOVEI	T0,33		;REPLACE WITH STANDARD ALT MODE
	CAIE	T0,33		;IS THIS AN ALTMODE
	JRST	SCNSI9		;NO CONTINUE
	TLNE	P3,IO.TTY!IO.TTA;TTY TYPE DEVICE
	OUTSTR	[ASCIZ /
/]				;[342] TYPE CR-LF
SCNSIZ:	TDZA	T0,T0		;CLEAR OUT THE CHARACTER
SCNSI8:	ILDB	T0,G1		;LOAD ASCII CHARACTER (OPEN ARGS)
SCNSI9:	JUMPE	T0,SCNSI7	;QUIT ON A NULL
	TRC	T0,140		;INVERT CONTROL AND SHIFT BITS
	TRNN	T0,140		;LOWER CASE ALPHA CHARACTER
	IORI	T0,40		;YES, SET TO UPPER CASE
	ANDCMI	T0,100		;SET TO SIXBIT AND CLEAR HIGH ORDER BIT
	CAIL	T0,'0'		;CHECK FOR CHARACTER RANGE
	CAILE	T0,'Z'		;IS THE A ALPHA NUMBERIC CHARACTER
	JRST	SCNSI2		;NO, CHECK FOR DELIMITER
	CAIGE	T0,'A'		;CHECK FOR ALPHA CHARACTER
	CAIG	T0,'9'		;CHECK FOR NUMBERIC
	JRST	SCNSI3		;YES ALPHA NUMBERIC CHARACTER
SCNSI2:	JUMPN	T0,SCNSI5	;CHECK FOR A BLANK CHARACTER
	JUMPE	T1,SCNSI1	;DIGIT, IGNORE LEADING BLANKS
	TLNE	T2,-1		;BLANK, CHECK FOR DIGIT OR ALPHA MODE
	JRST	SCNSI1		;ALHA-DIALOG, IGNORE BLANKS ALWAYS
SCNSI5:	CAILE	T0,'Z'		;IS DELIMITER IN THE 7X GROUP
	ANDCMI	T0,50		;YES PUT IN THE 2X GROUP
SCNSI7:	MOVSI	T2,400000	;MAKE A 1 BIT FLAG FOR THE DELIMITER
SCNSI4:	MOVN	T3,T0		;SET THE SHIFT COUNT
	LSH	T2,(T3)		;SET THE FLAG FOR THE DELIMITER
	POPJ	P,		;RETURN TO CALLER
SCNSI3:	TLNN	T2,-1		;CHECK FOR DIGIT MODE
	JRST	SCNSI6		;[217] YES, GO TO DIGIT ROUTINE
	TLNE	T2,760000	;[217] ALPHA/DIGIT ANY ROOM FOR OUTPUT
	IDPB	T0,T2		;YES, DEPOSITE BYTE
	JRST	SCNSI1		;RETURN FOR NEXT
SCNSI6:	CAIL	T0,+20(T2)	;[217] IS DIGIT IN RANGE (OCTAL/DECIMAL)
	JRST	SCNDLM		;[237] RETURN IMPOSSIBLE DELIMITER
	IMULI	T1,(T2)		;IN RANGE MAKE ROOM FOR NEW DIGIT
	ANDI	T0,17		;MAKE A BINARY DIGIT
	ADD	T1,T0		;ACCUMULATE THE SUM
	JRST	SCNSI1		;RETURN FOR NEXT DIGIT
	SUBTTL		GENERAL ROUTINES TO SET,CLEAR AND SEARCH TABLES

;ROUTINE TO SEARCH THE FORTRAN LOGICAL UNIT TABLE AND RETURN IN
;(P3) THE CHANNEL CONTROL WORD.
;(L)  AOBX POINTER   -N,,ARGLST NEW CALLS
;			0,,ARGLST FOR VERSION 1 CALLS

SRCFLU:	SETZ	T3,		;CLEAR THE ERROR RETURN ADDRESS
	PUSH	P,P1		;SAVE THE RETURN ADDRESS
	JSP	P1,EFCTV.	;[265] GET THE EFFECTIVE ADDRESS OF THE FLU
	MOVSI	T2,740		;[247] IMMEDIATE MODE
	TDNE	T2,0(L)		;[247] CONSTANT?
	JSP	P1,RELOC%	;[247] NO - GET ACTUAL VALUE
	MOVEI	G2,(G1)		;SAVE THE FLU IN G2
IFN %V1,<
	HLRZ	T2,(L)		;GET THE OLD COUNT FIELD
	LSH	T2,-^D9		;BITS 0-8 ONLY
	JUMPN	T2,SRCFL3	;NEW CALL, CONTINUE BELOW
>
	HLL	L,-1(L)		;GET THE NEGATIVE ARG COUNT
	AOBJP	L,SRCFL3	;END = ADDRESS
	JSP	P1,EFCTV.	;[265] GET THE ADDRESS
	MOVEI	T3,(G1)		;PUT IN THE RIGHT HALF
	AOBJP	L,SRCFL3	;ERR= ADDRESS
	JSP	P1,EFCTV.	;[265] GET THE ADDRESS
	HRLI	T3,(G1)		;PUT IN THE LEFT HALF
SRCFL3:	MOVEM	T3,ERR.PC(P4)	;STORE THE RETURN ADDRESS
	HRRZI	T1,6(G2)	;CONVERT TO A POSITIVE FLU
	JUMPN	T1,SRCFL0	;NOT A REREAD DEVICE
	SKIPE	P3,RER.SV(P4)	;[267] IS THERE A REREAD DEVICE
	TLNE	P3,IO.EOF	;[267] END OF FILE DETECTED
	ERROR	(DAT,12,10)	;[267] NO REREAD DEV. OR EOF
				;[267] EXIT WITH MESSAGE
	AOS	(P)		;SET SKIP RETURN
	MOVE	G3,DD.STS(P3)	;GET THE DEVICE STATUS
	PJRST	BSREAD		;BACK UP A RECORD
SRCFL0:	CAIE	T1,6		;[254] UNIT 0 SPECIFIED?
	CAILE	T1,FLU.MX+6	;IS THE FLU IN RANGE
	ERROR	(OPN,13,10,)	;NO, DIE
SRCFL1:	POP	P,P1		;RESTORE THE RETURN ADDRESS
	IDIVI	T1,^D6		;YES, SIX ENTRIES /WORD
	IMULI	T2,^D6		;NUMBER OF BITS LEFT
	ROT	T2,-^D6		;POSITION FOR THE BYTE POINTER
	IOR	T2,[POINT 6,FLU.TB(P4),35];SET THE SIZE FIELD
	ADDI	T2,(T1)		;POINT TO THE WORD ENTRY
	LDB	T1,T2		;LOAD THE CHANNEL INDEX
	MOVEM	T2,FLU.BP(P4)	;SAVE THE BYTE POINTER
	ADDI	T1,CHN.TB(P4)	;SET THE OFFSET FOR CHANNEL CONTROL WD
	SKIPE	P3,(T1)		;SETUP THE I/O REG
	JRST	1(P1)		;CHANNEL ASSIGNED T1=STATIC CORE POINTER
	JRST	(P1)		;CHANNEL NOT ASSIGNED P3=0


FLUSIX:				;CONVERT FORTRAN LOGICAL UNIT TO SIXBIT
	IDIVI	T1,12		;SEPERATE UNITS POSITION INTO T2
	LSH	T1,6		;SHIFT TWO OCTAL DIGITS
	ADDI	T1,2020(T2)	;CONVERT TO SIXBIT IN T1
	LSHC	T1,-^D12		;PUT SIXBIT FLU LEFT HALF ON T2
	JRST	(P1)		;RETURN T1=JUNK, T2=FLU IN SIXBIT


FILDFT:	SKIPE	T1,DD.NAM(P3)	;IS THERE A FILE NAME
	POPJ	P,		;YES, RETURN
	HRRE	T1,DD.UNT(P3)	;GET THE FORTRAN LOGICAL UNIT NUMBER
	JUMPGE	T1,.+2		;JUMP IF A +FLU
	SKIPA	T2,DEVTB.(T1)	;NO GET THE DEVICE NAME FOR A FILE NAME
	JSP	P1,FLUSIX	;CONVERT TO SIXBIT
	MOVSI	T1,(SIXBIT/FOR/);SET UP T1 WITH DEFAULT FILE NAME
	HLR	T1,T2		; AS FORXXX  XXX=FLU
	MOVEM	T1,DD.NAM(P3)	;PUT FILE NAME IN DD.BLK
EXTDFT:	SKIPE	T1,DD.EXT(P3)	;IS THERE AN EXTENSION
	POPJ	P,		;YES, RETURN
	MOVSI	T1,(SIXBIT /DAT/);NO, USE DAT AS A DEFAULT
	MOVEM	T1,DD.EXT(P3)	;PUT EXTENSION IN DD.BLK
	POPJ	P,		;RETURN

	SIXBIT	/ALCHN./	;SUBROUTINE NAME FOR TRACE
ALCHN%:	PUSHJ	P,SAVE.		;USER'S ENTRY TO GET A CHANNEL
	JSP	P1,EFCTV.	;[265] GET THE USERS ADDRESS
	TRNN	G1,-20		;AC ARGUMENT
	ADDI	G1,ACC.SV(P4)	;YES, RELOCATE
	SKIPN	T1,(G1)		;IS THERE A USER'S ARGUMENT
	JSP	P1,GT.CHN	;[265] NEW GET AN AVAILABLE CHANNEL
	  JFCL			;NO CHANNELS (GET THE ERROR LATER)
	CAILE	T1,17		;MUST BE IN RANGE 1-17
	JRST	ALCHN1		;ERROR RETURN AC0=-1
	ADDI	T1,CHN.TB(P4)	;POINT TO THE CHANNEL TABLE
	SKIPE	(T1)		;IS THE CHANNEL AVAILABLE
	JRST	ALCHN1		;NO ERROR
	SETOM	(T1)		;YES, IN USE BY THE USER
	SUBI	T1,CHN.TB(P4)	;GET THE CHANNEL NUMBER BACK
ALCHN2:	HRRZM	T1,ACC.SV+T0(P4);STORE THE CHANNEL NUMBER
	POPJ	P,		;RETURN TO THE CALLER

ALCHN1:	SETOB	T1,ACC.SV+T0(P4);[214] NO CHANNELS AVAILABLE
	POPJ	P,		;[214] RETURN ERROR INDICATION

GT.CHN::			;[265] FOROTS ENTRY TO ALLOCATE A CHANNEL
	MOVSI	T1,-17		;SET CHANNEL SEARCH COUNT
	HRRI	T1,CHN.TB+1(P4)	;SET SOFTWARE CHANNEL ORGIN
	SKIPE	(T1)		;IS THIS CHANNEL AVAILABLE
	AOBJN	T1,.-1		;END OF SEARCH ..... NO CHANNEL
	JUMPGE	T1,(P1)		;JUMP IF NO CHANNEL AVAILABLE
	ANDI	T1,-1		;CLEAR THE LEFT HALF
	SUBI	T1,CHN.TB(P4)	;RELOACTE T1 TO CHANNEL NUMBER
	JRST	1(P1)		;RETURN TO CALLER

	SIXBIT	/DECHN./	;SUBROUTINE NAME FOR TRACE
DECHN%:	PUSHJ	P,SAVE.		;USER'S ENTRY TO RELEASE A CHANNEL
	JSP	P1,EFCTV.	;[265] GET THE ARGUMENT ADDRESS
	TRNN	G1,-20		;AC ARGUMENT
	ADDI	G1,ACC.SV(P4)	;YES, RELOCATE
	SKIPLE	T1,(G1)		;LESS THAN OR EQUAL ZERO
	CAILE	T1,17		;MUST BE BETWEEN 1-17
	JRST	ALCHN1		;ERROR RETURN
	ADDI	T1,CHN.TB(P4)	;RELOCATE TO THE CHANNEL TABLE
	SETCM	T0,(T1)		;WAS THIS A USER'S CHANNEL
	JUMPN	T0,ALCHN1	;NO, ERROR RETRUN
	SETZB	T1,(T1)		;[214] CLEAR CHANNEL ENTRY
	JRST	ALCHN2		;RETURN AC0 = 0

PUTCHN:				;FOROTS ENTRY TO RELEASE A CHANNEL
	ADDI	T1,CHN.TB(P4)	;RELOACTE TO CHANNEL TABLE
	SETZM	(T1)		;CLEAR THE CHANNEL ENTRY
	JRST	(P1)		;RETURN

GETDV.:			;GET THE PHYSICAL DEVICE AND CHARASTICS
	;T1 = SIXBIT DEVICE NAME 
	;OR   THE FORTRAN LOGCIAL UNIT NUMBER
	;RETURN
	;G3 = DEVCHR BITS
	;G2 = PHYSICAL DEVICE NAME
	;G1 = LOGICAL DEVICE NAME

	TLNE	T1,-1		;IS THIS A FLU
	JRST	GETDV2		;NO, A LOGICAL DEVICE NAME
	HRRES	T3,T1		;GET THE SIGN FOR DEFAULT DEVICES
	JUMPL	T1,GETDV1	;IS THIS A NEGATIVE DEFAULT
	JSP	P1,FLUSIX	;CONVERT FLU TO SIXBIT
	TLNN	T2,170000	;IS THE FLU LESS THAN 10
	LSH	T2,6		;YES KILL THE LEADING ZERO
	MOVE	G3,T2		;GET THE FLU FOR A LOGICAL DEVICE CHECK
	MOVE	G1,T2		;SET UP DEVICE NAME FOR PHYSICAL NAME
	DEVCHR	G3,		;GET THE DEVICE CHARASTICS
	JUMPN	G3,GETDV3	;THE DEVICE IS A LOGICAL NAME
GETDV1:	CAIG	T3,DEV.SZ	;IS THE FLU IN THE TABLE RANGE
	SKIPN	G1,DEVTB.(T3)	;GET THE DEVICE NAME
	MOVSI	G1,(SIXBIT /DSK/)	;NOT IN RANGE OR ZERO ENTRY
	JRST	.+2		;CONTINUE
GETDV2:	MOVE	G1,T1		;SET UP FOR A DEVCHR UUO
	MOVE	G3,G1		;SET UP THE PHYSICAL NAME UUO
	DEVCHR	G3,		;GET THE DEVICE BITS IN G3
GETDV3:	MOVE	G2,G1		;GET THE DEVICE NAME
	DEVNAM	G2,		;GET THE PHYSICAL DEVICE NAME
	JFCL			;IGNORE THE ERROR RETURN
	POPJ	P,		;RETURN

EFCTV.::			;[265]
	MOVE	G1,(L)		;GET THE ARGUMENT POINTED TO BY (L)
EFCTV1:	HLRZ	T1,G1		;GET THE INDEX AND INDIRECT BITS
	ANDI	T1,17		;SAVE THE INDEX BITS
	JUMPE	T1,EFCTV2	;NO INDEXING
	ADDI	T1,ACC.SV(P4)	;RELOCATE TO THE SAVE AREA
	HRRZ	T1,(T1)		;GET THE CONTENTS ON THE INDEX REG
	ADDI	G1,(T1)		;GET THE NEW EFFECTIVE ADDRESS
EFCTV2:	TLZ	G1,777757	;CLEAR ALL EXCEPT THE INDIRECT BIT
	TLZN	G1,20		;INDIRECT BIT ON
	JRST	(P1)		;NO G1 IS THE EFFECTIVE ADDRESS
	TRNN	G1,-20		;IN THE AC SAVE AREA
	ADDI	G1,ACC.SV(P4)	;YES,RELOCATE
	MOVE	G1,(G1)		;YES, GO COMPUTE A NEW EFFECTIVE ADDRESS
	JRST	EFCTV1		;DO IT AGAIN


;ROUTINE TO COMPUT A FOLDED CHECKSUM IN T1
;THE WORD TO BE CHECK SUMMED IS IN G3
;THE FOLDED CHECK SUM IS RETRUN IN T1 BITS( 27-35) 9 BITS

IFN CHKSUM,<
CHKSM.:	HLRZ	T1,G3		;GET THE HIGH ORDER 18 BITS
	XORB	T1,G3		;CHECK SUM THE HIGH AND LOW ORDER
	LSH	T1,-^D9		;POSITION FOR A 9 BIT CHACKSUM
	XOR	T1,G3		;GET THE 9 BIT CHECKSUM
	ANDI	T1,777		;SAVE ONLY NINE BITS
	JRST	(P1)		;RETURN
>

	SUBTTL INBYTE GENERAL INPUT ROUTINES

	INTERNAL IBYTE.,IBLOK.,IPEEK.

IPEEK.:	SKIPG	DD.HRI+2(P3)	;PEEK AT NEXT CHARACTER ANY LEFT
	PUSHJ	P,IBLOK.	;NO, GET NEXT BLOCK
	TLNE	P3,IO.EOF	;DID PEEK CAUSE AN EOF
	JRST	IBYTE2		;YES, RETURN A BLANK
	MOVE	T0,DD.HRI+1(P3)	;GET THE BYTE POINTER
	ILDB	T0,T0		;PEEK AT THE NEXT CHARACTER
	JUMPN	T0,(P1)		;RETURN WITH T0 = PEEKED CHARACTER
	IBP	DD.HRI+1(P3)	;SKIP THE NULL
	SOS	DD.HRI+2(P3)	;ACCOUNT FOR THE CHARACTER POS.
	JRST	IPEEK.		;TRY AGAIN

IBYTE.:
	TLNE	P3,IO.EOL!IO.EOF	;CHECK FOR END OF LINE
	JRST	IBYTE2		;[244] YES, RETURN A BLANK
	SKIPG	DD.HRI+2(P3)	;REDUCE INPUT BYTE COUNT
	PUSHJ	P,IBLOK.	;NONE LEFT , GET A BUFFER
	TLNE	P3,IO.EOL!IO.EOF;[177] END OF FILE OR END OF CHUNK
	JRST	IBYTE2		;[177] STOP THE INPUT
IBYTE0:	SOS	DD.HRI+2(P3)	;COUNT THIS DATA ITEM
	TLNE	P3,IO.FMT	;IS THIS FORMATED I/O
	JRST	IBYTE1		;YES, DO THE ILDB
	AOS	DD.HRI+1(P3)	;NO, UPDATE THE BYTE POINTER
	MOVE	T0,@DD.HRI+1(P3);GET THE DATA ITEM
	JRST	(P1)		;RETURN

IBYTE1:	ILDB	T0,DD.HRI+1(P3)	;GET INPUT CHARACTER
	JUMPE	T0,IBYTE.	;IGNORE NULL CHARACTERS
	CAIN	T0,15		;CHECK FOR A CARRAGE RETURN
	JRST	IBYTE.		;YES, IGNORE ALL CR'S
	CAIG	T0,15		;CHECK FOR A LINE TERMINATOR CHACTER
	CAIGE	T0,12		;VT, FF, LF
	JRST	(P1)		;NO, RETURN DATA CHARACTER

IBYTE2:	TLO	P3,IO.EOL	;YES SET END OF LINE FLAG
	MOVEI	T0," "		;[244] SET UP A BLANK FOR RETURN
	JRST	(P1)		;RETURN TO CALLER

IBLOK.:	TLNE	P3,IO.STR!IO.EDC;CHECK FOR A STRING
	JRST	IBLOKS		;YES, (SKIP UUO PROCESS)
	TLNE	P3,IO.TTA	;USER'S TTY
	JRST	IBLOK2		;YES, USE A TTCALL
	AOS	DD.BLK(P3)	;COUNT THIS BLOCK
IBLOK0:	HLLZ	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T0,(IN)		;SETUP AN INPUT UUO
	TLZE	P3,IO.RNG	;CHANGING RINGS
	HRR	T0,DD.HRI(P3)	;GET THE NEW RING ADDRESS
	XCT	T0		;EXECUTE THE UUO
	POPJ	P,		;GET THE NEXT CHARACTER FROM THE BLOCK
	ERROR	(DEV,0,5,IBLOK1);DO THE ERROR PROCESSING

IBLOK1:	TLO	P3,IO.EOL!IO.EOF;SET END OF LINE
	POPJ	P,		;RETURN

IBLOK2:	PUSH	P,T1		;SAVE T1
IBLOK6:	HRRZS	T1,DD.HRI(P3)	;[177] GET THE BUFFER ADDRESS CLEAR USE BIT
	AOSN	-1(T1)		;END OF FILE SET LAST TIME (-1)
	ERROR	(DEV,4,5,IBLKT0);[307] CALL THE ERROR ROUTINE
	TLNE	P3,IO.EOF	;[307] EOF SEEN ALREADY?
	JRST	IBLOKT		;[307] YES- SET END OF LINE
	HRLI	T1,440700	;SET UP AN ASCII BYTE POINTER
	ADDI	T1,2		;POINT TO DATA
	SETZM	POS.TB+1(P4)	;[226] CLEAR INITIAL LINE POSITION
	MOVEM	T1,DD.HRI+1(P3)	;SET BYTE POINTER IN RING BUFFER
	PUSH	P,T2		;SAVE AC 2
	MOVSI	T2,-<<23-3>*5-1>;[177] CLEAR THE BYTE COUNT
	INCHWL	T0		;WAIT FOR A CHARACTER
	JRST	IBLOK4		;GO A CHARACTER
IBLOK3:	INCHSL	T0		;GET ANOTHER CHARACTER
	JRST	IBLOK5		;NONE LEFT
IBLOK4:	CAIN	T0,32		;^Z FOR EOF
	JRST	[MOVE	T1,DD.HRI(P3)	;GET THE RING ADDRESS
		SETOM	-1(T1)		;SET EOF FLAG
		TRNE	T2,-1		;[177] ANY CHARACTERS INPUT
		JRST	IBLOK5		;YES, EXIT WITH EOF SET
		POP	P,T2		;[177] REMOVE THE NULL ITEM COUNT
		JRST	IBLOK6]		;[177] CALL THE EOF ROUTINE
	IDPB	T0,T1		;STORE CHARACTER IN BUFFER
	AOBJP	T2,IBLOK5	;ANY ROOM LEFT .... NO
	CAIG	T0,14		;CHECK FOR A TERMINATOR
	CAIGE	T0,12		;(LF,VT,FF)
	JRST	IBLOK3		;GET THE NEXT CHARACTER
IBLOK5:	HRRZM	T2,DD.HRI+2(P3)	;YES, SAVE THE CHARACTER COUNT
TPOPJ2:	POP	P,T2		;[353] RESTORE AC 2
TPOPJ:	POP	P,T1		;RESTORE T1
CPOPJ:	POPJ	P,		;RETURN

IBLOKS:				;STRING INPUT
	TLNE	P3,IO.EDC	;ENCODE/DECODE REQUEST
	JRST	IBLOK1		;SET THE END OF ARRAY FLAGS
	PUSH	P,T1		;GET A TEMP
	HRRZ	T1,DD.HRI(P3)	;GET THE CURRENT CHUNK ADDRESS
	HRRZ	T1,(T1)		;GET THE NEXT ADDRESS
	JUMPE	T1,IBLOKT	;[177] SET END OF LINE ETC
				;END OF STRING
	HRLI	T1,(POINT 7,0,34);ASCII BYTE POINTER
	HRRM	T1,DD.HRI(P3)	;STORE THE CURRENT CHUNK
	MOVEM	T1,DD.HRI+1(P3)	;STORE THE BYTE POINTER
	MOVEI	T1,STRCNK*5	;CHARACTER COUNT
	MOVEM	T1,DD.HRI+2(P3)	;STORE
	PJRST	TPOPJ		;RESTORE T1 AND RETURN

IBLKT0:	TLO	P3,IO.EOF	;[307] SET EOF SEEN
IBLOKT:	TLO	P3,IO.EOL	;[177] SET END OF LINE
	PJRST	TPOPJ		;[177] RETURN
	SUBTTL END OF FORMATED LINE ROUTINES

;ADVANCE TO THE END OF THE CURRENT INPUT LINE

	INTERNAL	NXTLN.,ENDLN.	;[325]

NXTLN.:
NXTLNI:	TLNE	P3,IO.EDC	;ENDCODE/DECODE REQUEST
	JRST	NXTENC		;PROCESS SEPERATE
	PUSHJ	P,ENDLN.	;FINISH UP THE CURRENT LINE
	JUMPO	NXTLN2		;JUMP ON OUTPUT
	JSP	P1,IPEEK.	;PEEK AT THE NEXT CHARACTER
	CAIG	T0,14		;IGNORE VT,FF,LF IN THE POS FIELD
	CAIGE	T0,12		;IS THIS THE END OF THE POS FIELD
	TLZA	P3,IO.EOL	;YES, CLEAR EOL
NXTLN1:	SOJA	P1,IBYTE0	;NO, EAT NEXT CHARACTER AND RETURN TO PEEK
NXTLN2:	TLNE	P3,IO.STR	;STING REQUIRED
	PJRST	SETSTR		;YES, SET UP THE STRING
	POPJ	P,		;POSITIONED AT NEXT INPUT LINE

ENDLN.:	SETZM	CH.SAV(P4)	;[354] CLEAR SAVED DELIMITER
	TLNN	P3,IO.STR	;IS THIS A STRING
	JRST	ENDLN1		;NO
	PUSHJ	P,DMPSTR	;YES, DUMP THE STRING
	JUMPO	.+2		;CHECK IF OUTPUT
	TLOA	P3,IO.EOL	;INPUT  SET EOL AND EXIT
	PUSHJ	P,ENDLN1	;DO END OF LINE
	TLO	P3,IO.STR	;TURN THE STRING FLAG ON
	POPJ	P,		;RETURN
ENDLN1:	JUMPO	ENDLNO		;FINISH UP THE CURRENT LINE
ENDLNI:				;FINISH OF THE CURRENT INPUT LINE
	JSP	P1,IBYTE.	;EAT THE NEXT CHARACTER
	TLNN	P3,IO.EOL!IO.EOF;CHECK FOR END OF LINE FLAG
	PJSP	IBYTE.		;NO,EAT ANOTHER RETURN AT (.-1)
	POPJ	P,		;AT THE END OF THE CURRENT LINE OF INPUT

ENDLNO:
NXTLNO:	TLNE	P3,IO.INT	;OUTPUT, INTERACTIVE DEVICE?
	PUSHJ	P,OBLOK.	;YES, DUMP THE BUFFER
	MOVEI	T0,15		;GET A CARRAGE RETURN
	TLC	P2,FT.FIN!FT.DOL;COMPLEMENT LAST RIGHT PAREN AND DOL FLAG
	TLCN	P2,FT.FIN!FT.DOL;IF BOTH ON SKIP THE CR AND RESTORE THE FLAGS
	JRST	.+4		;SKIPT THE CR/LF
	JSP	P1,OBYTEC	;OUTPUT THE CARRAGE RETURN
	MOVEI	T0,12		;GET A LINE FEED
	JSP	P1,OBYTEC	;OUTPUT THE LINE FEED
				;(THIS LINE FEED MAY BE CHANGED BY THE
				; BY THE FORMAT CARRAGE CONTROL ROUTINE)
	TLNE	P3,IO.CCC	;CHECK FOR FORMATED OUTPUT
	JRST	NXTLNF		;WORD BOUNDRY NOT REQUIRED
	MOVSI	T0,760000	;SET UP A BYTE POINTER MASK AND A
				;PSEUDO NULL IN THE RIGHT
	SKIPE	DD.LOG(P3)	;FIXED LENGTH RECORDS
	TLZE	P3,IO.EOL	;YES, AT END OF LINE
	JRST	.+3		;YES, GO FILL OUT LAST WORD
	JSP	P1,OBYTE.	;NO, OUTPUT THE NULL
	JRST	.-3		;CONTINUE UNTIL END OF FIXED RECORD
	TDNN	T0,DD.HRO+1(P3)	;MUST FILL OUT THE LAST WORD
	JRST	.+3		;WORD FILLED OUT
	JSP	P1,OBYTEC	;OUTPUT A NULL
	JRST	.-3		;CONTINUE FILLING
	TSOA	T0,DD.LOG(P3)	;GET THE LOGCIAL RECORD SIZE
NXTLNF:	MOVEI	T0,1		;SET A FORMAT FLAG
	HRRZM	T0,POS.TB(P4)	;STORE IN THE POSITION TABLE
	POPJ	P,		;RETURN (AT END OF CURRENT OUTPUT)

NXTENC:				;END OF RECORD FOR ENCODE/DECODE
	MOVEI	T1,DD.HRI(P3)	;INPUT HEADER
	JUMPI	.+2		;JUMP ON INPUT
	MOVEI	T1,DD.HRO(P3)	;OUTPUT HEADER
	MOVEI	P1,.+1		;SET UP A RETURN FROM THE BYTE ROUTINE
NXTEN1:	MOVSI	T0,760000	;SET UP AN END OF WORD MASK
	TLNN	P3,IO.EOL	;RETURN IF EOL SET
	TDNN	T0,1(T1)	;ON A WORD BOUNDRY
	POPJ	P,		;RETURN
	JUMPI	IBYTE.		;SKIP A CHARACTER
	HRRI	T0," "		;FILL WITH BLANKS
	JUMPO	OBYTE.		;OUTPUT A FILL CHARACTER
	SUBTTL OUT BYTE GENERAL OUTPUT ROUTINES

	INTERNAL OBYTE.,OBLOK.
OBYTE.:	TLNE	P3,IO.EOL	;CHECK FOR END OF LOGICAL FIXED RECORD
	JRST	(P1)		;YES, CAN NOT OUTPUT CHARACTER
	TLNE	P3,IO.STR	;OUTPUT TO AN INCORE STRIN
	JRST	OBYTEC		;YES, DON'T COUNT
	SOSN	POS.TB(P4)	;COUNT THIS ITEM IN THE HORIZ. POS
	PJRST	OUTCCC		;FIRST CHARACTER, CHECK FOR CARRIAGE CONTROL
OBYTEC:	SKIPG	DD.HRO+2(P3)	;CHECK FOR A FULL BUFFER
	PUSHJ	P,OBLOK.	;BUFFER IS FULL
	SOS	DD.HRO+2(P3)	;REDUCE THE ITEM COUNT
	IDPB	T0,DD.HRO+1(P3)	;PUT THE CHARACTER IN THE OUTPUT BUFFER
	JRST	(P1)		;RETURN

OBLOK.:	TLNE	P3,IO.STR!IO.EDC;CHECK FOR ENCODE/DECODE/STRING
	JRST	OBLOKS		;YES, (SKIP UUO)
	PUSH	P,T0		;SAVE THE OUTPUT WORD
	TLNE	P3,IO.TTA	;USER'S TTY
	JRST	OBLOK2		;YES, USE A TTCALL
	TLNE	P3,IO.RAN	;RANDOM ACCESS OUTPUT
	JRST	[PUSH	P,P1	;SAVE THE JSP RETURN
		PUSHJ	P,WBLOK.	;WRITE THIS BLOCK
		AOS	DD.BLK(P3)	;STEP TO THE NEXT BLOCK
		HRRZ	T0,DD.HRO(P3)	;GET THE OUTPUT HEADER ADDRESS
		MOVEM	T0,DD.HRI(P3)	;REUSE THE SAME BUFFER FOR INPUT
		PUSHJ	P,RBLOK.	;READ THE NEXT BLOCK
		POP	P,P1		;RESTORE THE JSP POINTER
		JRST	OBLOK3]		;COMMON EXIT
	AOS	DD.BLK(P3)	;COUNT THIS BLOCK
OBLOK0:	HLLZ	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T0,(OUT)	;NO, BUFFERED OUTPUT
	TLZE	P3,IO.RNG	;CHANGING RINGS
	HRR	T0,DD.HRO(P3)	;GET THE NEW RING ADDRESS
	XCT	T0		;OUTPUT THE BUFFER
	PJRST	OBLOK3		;EXIT FROM BLOCK ROUTINE
	ERROR	(DEV,0,5,OBLOK1);DO THE ERROR REPORT

OBLOK1:	TLO	P3,IO.EOL	;SET END OF LING FLAG
	JRST	OBLOK3		;RESTORE AND EXIT

OBLOK2:	MOVSI	T0,440700	;SET AN ASCII BYTE POINTER
	IDPB	T0,DD.HRO+1(P3)	;SET A NULL AT THE END
	HRR	T0,DD.HRO(P3)	;GET THE BUFFER ADDRESS
	ADDI	T0,2		;POINT TO DATA
	MOVEM	T0,DD.HRO+1(P3)	;SET IN RING HEADER
	MOVEI	T0,<23-3>*5-1  ;GET BUFFER SIZE IN CHARACTERS
	MOVEM	T0,DD.HRO+2(P3)	;SAVE IN RING HEADER
	OUTSTR	@DD.HRO+1(P3)	;OUTPUT THE STRING
OBLOK3:	POP	P,T0		;RETORE THE OUTPUT WORD
	POPJ	P,		;RETURN

OBLOKS:	TLNN	P3,IO.STR	;STRING CALL
	JRST	[PUSH	P,T0	;SAVE AS T0
		PJRST	OBLOK1]	;EXIT WITH END OF ARRAY SET
				;APPEND A NEW CHUNK TO THE STRING
	ADD	P,[XWD T5+1,T5+1]	;SAVE THE TEMPS
	MOVEM	T5,(P)		;SAVE T5
	MOVEI	T5,-<T5>(P)	;BLT THE ACS
	BLT	T5,-1(P)	;SAVE THE TEMPS
	HRRZ	T2,DD.HRO(P3)	;LOOK FOR A LINK
	HRRZ	T1,(T2)		;FOR THE NEXT CHUNK
	JUMPN	T1,OBLOK5	;YES, DO NOT ALLOCATE A NEW LINK
	MOVEI	T0,STRCNK	;GET THE CHUNK SIZE
	PUSHJ	P,GMEM%%	;ALLOCATE FROM THE HEAP
	MOVEI	T1,-1(T1)	;GET THE LINK ADDRESS
	MOVE	T2,DD.HRO(P3)	;GET THE STRING LINKS
	HRRM	T1,(T2)		;LINK THE NEW CHUNK
OBLOK5:	HRLI	T1,(POINT 7,0,34);ASCII BYTE POINTER
	HRRM	T1,DD.HRO(P3)	;STORE THE CURRENT CHUNK
	MOVEI	T2,STRCNK*5	;GET THE CHARACTER COUNT
	DMOVEM	T1,DD.HRO+1(P3)	;STORE BYTE POINTER AND CHARACTEK COUNT
	MOVSI	T5,-<T5>(P)	;SET UP BLT POINTER TO RESTRE THE TEMPS
	BLT	T5,T5		;RESTORE
	SUB	P,[XWD T5+1,T5+1];ADJUST THE STACK POINTER
	POPJ	P,		;RETURN AND STORE THE CHARACTR
	SUBTTL CARRAGE CONTROL ROUTINES
OUTCCC:	TLNN	P3,IO.CCC	;FORMS CONTROL REQUIRED
	JRST	[TLO	P3,IO.EOL ;SET END OF LINE FLAG
		JRST	OBYTEC]	;OUTPUT THIS CHARACTER
	PUSH	P,P1		;SAVE THE RETURN ADDRESS(POPJ ED)
	PUSH	P,T0		;SAVE THE CONTROL CHARACTER
	SUBI	T0,"*"		;RELOCATE CONTROL CHARACTER FOR INDEXING
	JUMPL	T0,OUTCC2	;CHARACTER IS NOT IN RANGE
	CAILE	T0,"3"-"*"	;CHECK THE HIGH END
	JRST	OUTCC2		;NOT IN RANGE USE THE PREVIOUS CCC
	ADDI	T0,CCC.TB	;POINT TO THE TABLE
	MOVE	T0,@T0		;GET THE CONTROL CHARACTERS
	ROT	T0,5		;GET THE LOW ORDER 4 BITS
	TLNN	P3,IO.TTA	;IS THIS THE USER'S TTY
	JRST	OUTCC0		;NO,CONTINUE NORMAL
	SKIPN	T0		;+ CARRIAGE CONTROL
	MOVEI	T0,177		;YES, SEND A RUB OUT (NULL'S DON'T WORD)
	SKIPGE	DD.HRO+1(P3)	;IS THE TTY BUFFER EMPTY
	JSP	P1,OBYTEC	;YES, OUTPUT THIS NORMAL
OUTCC0:	DPB	T0,DD.HRO+1(P3)	;OVER RIDE THE PRECIOUS CHARACTER
OUTCC1:	ANDCMI	T0,177		;CLEAR THE LAST CHARACTER
	JUMPE	T0,OUTCC2	;NONE LEFT EXIT
	ROT	T0,5		;GET THE NEXT CHARACTER
	JSP	P1,OBYTEC	;OUTPUT THE CHARACTER AND ADVANCE
	JRST	OUTCC1		;CHECK FOR MORE CHARACTER
OUTCC2:	POP	P,T0		;RESTORE THE CHARACTER
	POP	P,P1		;RESTORE THE JSP POINTER
	JRST	(P1)		;RETURN

CCC.TB:			;CARRAGE CONTROL CHARACTER CONVERSION TABLES
	BYTE (5)023(13)000		;*;
	BYTE (5)000(13)000		;+;
	BYTE (5)021(13)000		;,;
	BYTE (5)012(5)012(5)12(3)0	;-;
	BYTE (5)022(13)000		;.;
	BYTE (5)0024(13)000		;/;
	BYTE (5)012(5)012(8)000		;0;
	BYTE (5)014(13)000		;1;
	BYTE (5)020(13)000		;2;
	BYTE (5)013(13)000		;3;
	SUBTTL INCORE STRING ROUTINES
;ACC USAGE DURING THE STRING COPY FUNCTIONS BELOW
;	P=	STACK POINTER
;	L=	NOT USED
;	P4=	LOW SEG POINTER
;	P3=	I/O REGISTER
;	P2=	NOT USED
;	P1=	JSP POINTER
;	G4-G1	NOT USED
;	T5=	POINTER TO THE RING FOR PHYSICAL I/O
;	T4=	POINTER TO THE RING FOR STRING I/O
;	T3=	CHARACTER COUNT (BUILD A RING HEADER FOR STRING I/O)
;	T2=	BYTE POINTER " "
;	T1=	RING HEADER FOR STRINGS " "
;	T0=	CHARACTER REGISTER TO TRANSFER STRINGS

SETSTR:
	MOVEI	T0,STRCNK+3	;GET THE STRING CHUNK SIZE (+RING HEADER)
	PUSHJ	P,GMEM%%	;ALLOCATE FROM THE HEAP
	MOVEI	T1,-1(T1)	;POINT TO THE LINK WORD
	MOVEI	T4,DD.HRO(P3)	;SAVE THE OUTPUT RING HEADER
	JSP	P1,STRRNG	;GO SET UP THE RING HEADERS
	JUMPO	SETST1		;JUMP ON OUTPUT
	TLZ	P3,IO.STR	;CLEAR THE STRING FLAG
	PUSHJ	P,CPYSTR	;START THE COPY
	HRLI	T4,1(T1)	;[253] RESTORE
	HRRI	T4,DD.HRO(P3)	;[253] OUTPUT BUFFER
	BLT	T4,DD.HRO+2(P3)	;[253] RING HEADER
	MOVSI	T4,DD.HRI(P3)	;SAVE THE CURRENT INPUT HEADR
	HRRI	T4,1(T1)	;IN THE SAVE AREA
	BLT	T4,3(T1)	;SAVE IT
	DMOVEM	T1,DD.HRI(P3)	;REPACE WITH THE STRING POINTR
	MOVEM	T3,DD.HRI+2(P3)	;ETC
SETST1:	TLO	P3,IO.STR	;COMMON EXIT
	POPJ	P,		;EXIT

DMPSTR:				;ROUTINE TO DUMP STRINGS TO THE OUTPUT DEV
	MOVEI	T4,DD.HRI(P3)	;GET THE INPUT RING HEADER
	JUMPI	DMPST1		;JUMP ON INPUT
	HLRZ	T1,DD.HRO(P3)	;GET THE FIRST CHUNK ADDRESS
	MOVSI	T2,1(T1)	;RESTORE THE OUTPUT RING HEADER
	HRRI	T2,DD.HRO(P3)	;FROM THE SAVE AREA
	BLT	T2,DD.HRO+2(P3)	;BLT
	JSP	P1,STRRNG	;SET UP THE RINGS
	TLO	P3,IO.STR	;SET THE STRING FLAG
	PUSHJ	P,CPYSTR	;COPY THE STRING TO THE DEVICE
DMPST1:				;REMOVE THE INPUT CHUNKS
	HLRZ	T1,(T4)		;GET THE STARTING CHUNK
	MOVEI	T5,(T4)		;GET THE HEADER ADDRESS
	HRLI	T5,1(T1)	;SET UP TO RESTORE THE RING HEADER
	BLT	T5,2(T4)	;RESTORE THE WITH THE ORGIONAL VALUE
	TLZ	P3,IO.STR	;CLEAR THE STRING BIT
	MOVEI	T1,1(T1)	;STEP PAST THE LINK WORD
	PJRST	PMEM%%		;RETURN THE HEAP SPACE

STRRNG:				;SET UP THE RING HEADERS
	MOVEI	T2,1(T1)	;SAVE THE RING HEADER
	HRLI	T2,(T4)		;SET UP THE BLT
	BLT	T2,3(T1)	;SAVE IT
	HRLI	T1,(T1)		;SET UP THE CONTROL WORDS
	MOVEI	T2,3(T1)	;SKIP THE HEADER
	HRLI	T2,(POINT 7,0,34);ASCII BYTE POINTER
	MOVEI	T3,STRCNK*5	;AND THE CHARACTER COUNT
	DMOVEM	T1,(T4)		;STORE THE STRING HEADER FOR COPY
	MOVEM	T3,2(T4)	;AND THE CHARACTER COUNT
	JRST	(P1)		;RETURN

CPYSTR:				;COPY DATA FROM THE INPUT TO OUTPUT
	JSP	P1,IBYTE.	;GET AN INPUT CHARACTER
	TLZE	P3,IO.EOL!IO.EOF;END OF LINE
	POPJ	P,		;YES, STOP THE COPY
	TLC	P3,IO.STR	;SET STRING FOR OUTPUT
	JSP	P1,OBYTE.	;OUTPUT
	TLC	P3,IO.STR	;COMPLEMENT
	JRST	CPYSTR		;CONTINUE
	SUBTTL FIND RANDOM ACCESS POSITIONING ROUTINES
	SIXBIT	/FIND./		;NAME FOR TRACE
FIND%:				;ENTRY TO POSITION FOR THE NEXT RANDOM BLOCK
	PUSHJ	P,SAVE.		;SAVE THE USER'S AC'S
	JSP	P1,SRCFLU	;IS THE FLU DEFINED
	POPJ	P,		;NO, EXIT
	MOVE	G1,3(L)		;GET THE ASSOCATE VARIABLE ADDRESS
	JSP	P1,EFCTV1	;GET THE EFFECTIVE ADDRESS
	TRNN	G1,-20		;IN THE AC'S
	ADDI	G1,ACC.SV(P4)	;RELOCATE
	MOVE	T0,(G1)		;GET THE VALUE
	MOVEM	T0,DD.LIM(P3)	;[330] CURRENT LOGICAL RECORD
	SKIPE	T1,DD.ASC(P3)	;GET THE ASSOCIATE VARIABLE ADDRESS
	MOVEM	T0,(T1)		;STORE THE NEW VALUE
	POPJ	P,		;RETURN
FIND%%:	JUMPGE	P2,FIND6	;JUMP ON INPUT
	TLOE	P3,IO.SOU	;ENTER BEEN DONE
	JRST	FIND6		;YES, CONTINUE
	LDB	T1,[POINT 4,DD.BLK(P3),9];NO,GET THE ACCESS MODE
	CAIE	T1,ACC.RO	;RANDOM INPUT/OUTPUT
	ERROR	(OPN,2,10,)	;CAN NOT WRITE A READ ONLY FILE
	JSP	P1,ENTER.	;DO AN ENTER
	ERROR	(OPN,0,7,)	;CAN NOT ENTER
FIND6:
	TLZ	P3,IO.EOL!IO.EOF;[233] CLEAR EOL AND EOF
	JSP	P1,EFCTV1	;GET THE ADDRESS
	TRNN	G1,-20		;IN THE AC SAVE AREA
	ADDI	G1,ACC.SV(P4)	;YES, RELOCATE TO THE SAVE AREA
	SKIPG	T4,(G1)		;GET THE RECORD NUMBER
	MOVEI	T4,1		;ILLEGAL RECORD NUMBERS GET A 1(ONE)
	MOVEM	T4,DD.LIM(P3)	;[330] CURRENT LOGICAL RECORD
	SKIPE	T1,DD.ASC(P3)	;GET THE ASSOCIATE VARIABLE ADDRESS
	MOVEM	T4,(T1)		;STORE THE CURRENT RECORD NUMBER
				;UPDATED BY ("NXTLN.")
	SUBI	T4,1		;START AT RELATIVE REOCRD 0
	HRRZ	T2,DD.LOG(P3)	;GET THE LOGICAL RECORD SIZE
	IMULI	T4,(T2)		;COMPUT THE NUMBER OF WORD FROM THE BOF.
	IDIVI	T4,200		;GET THE BLOCK IN T4/ WORD IN T5
	ADDI	T4,1		;BLOCK START AT 1 FOR FILSER
	HRRZ	T0,DD.BLK(P3)	;GET THE CURRENT BLOCK NUMBER
	JUMPGE	G4,[JUMPI	FIND0	;INPUT
		JRST	FIND00]	;OUTPUT
	TLCE	P3,IO.INO	;YES, OUTPUT LAST
FIND00:	JUMPN	T0,FIND3A	;NO INCORE BLOCKS
FIND0:	CAILE	T0,(T4)		;IS THE BLOCK CURRENT OR ADVANCING IN THE FILE
	JRST	FIND3		;NO, BACKING UP
FIND1:	SKIPA	T1,DD.HRI(P3)	;GET THE INPUT HEADER
FIND2:	HRRZI	T1,(T2)		;STEP ALONG THE BUFFER CHAIN
	SKIPL	T2,(T1)		;GET THE BUFFER HEADER
	JRST	FIND3		;NO, END OF ACTIVE BUFFERS
	CAIN	T0,(T4)		;IS THIS THE BLOCK WE WANT
	JRST	FIND5		;YES, THIS IS THE BUFFER
	TLZ	T2,400000	;CLEAR THE USE BIT
	MOVEM	T2,(T1)		;STORE THE BUFFER HEADER (USE=0)
	AOJA	T0,FIND2	;NO, STEP TO THE NEXT BUFFER
FIND5:	MOVEM	T1,DD.HRI(P3)	;SET THIS AS THE CURRENT BUFFER
	HRRM	T4,DD.BLK(P3)	;STORE THE CURRENT BLOCK NUMBER
	JRST	FIND4		;GO SET UP THE REST OF THE RING HEADER
FIND3A:	PUSHJ	P,WBLOK.	;GO DUMP THE INCORE BLOCK
FIND3:	HRRM	T4,DD.BLK(P3)	;SET UP THE BLOCK NUMBER
	PUSHJ	P,RBLOK.	;GET THE NEXT RANDOM BLOCK
	HRRZ	T1,DD.HRI(P3)	;GET THE CURRENT BUFFER
FIND4:	MOVEM	T1,DD.HRO(P3)	;SAVE IN THE OUTPUT RING HEADER
	MOVE	T2,1(T1)	;[233] LOAD BUFFER SIZE
	SUBI	T2,(T5)		;[233] MINUS THE WORDS SKIPPED
	TLNE	P3,IO.FMT	;[233] CHECK FOR ASCII I/O
	IMULI	T2,5		;[233] CONVERT TO CHARACTERS
	MOVEM	T2,DD.HRI+2(P3)	;[233] SAVE IN THE INPUT RING HEADER
	MOVEM	T2,DD.HRO+2(P3)	;[233] AND THE OUTPUT RING HEADER
	MOVEI	T2,200		;[233] LOAD DISK BUFFER SIZE
	CAMN	T2,1(T1)	;[233] FULL BUFFER?
	JRST	FIND7		;[233] YES - OUTPUT COUNT IS RIGHT
				;[233] RECOMPUTE OUTPUT COUNT
	SUBI	T2,0(T5)	;[233] COMPUTE WORDS REMAINING
	TLNE	P3,IO.FMT	;[233] FORMATTED I/O
	IMULI	T2,5		;[233] CONVERT TO CHARACTERS
	MOVEM	T2,DD.HRO+2(P3)	;[233] RESET OUTPUT RING HEADER
FIND7:	HLL	T1,DD.HRI+1(P3)	;[233] GET THE BYTE INFO
	TLZ	T1,770000	;[233] CLEAR THE POSITION FIELD
	ADDI	T1,1(T5)	;[233] POINT TO THE DATA WORD - 1
	MOVEM	T1,DD.HRI+1(P3)	;[233] STORE IN THE INPUT RING HEADER
	MOVEM	T1,DD.HRO+1(P3)	;[233] AND THE OUTPUT RING HEADER
	POPJ	P,		;RETURN

RBLOK.:			;GET THE NEXT RANDOM BLOCK IN CORE
	JSP	P1,WAIT.	;STOP THE DEVICE
	JSP	P1,CLRUSE
	MOVE	T0,DD.BLK(P3)	;GET THE BLOCK NUMBER
	HLL	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T0,(USETI)	;TELL FILSER THE BLOCK WE WANT
	XCT	T0		;DO IT
	PUSH	P,T0		;SAVE THE USETI BLK#
	HLLZ	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	IOR	T0,[STATO 0,20000] ;CHECK FOR EOF
	XCT	T0		;DO IT
	JRST	RBLOK1		;OK, NO EOF
	JUMPI	RBLOK1		;ALLOW EOF TO STAND ON INPUT
	HLLZ	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	IOR	T0,[SETSTS 0,@DD.OPN(P3)] ;RESET THE THE DEVICE STATS
	XCT	T0		;DO IT
	POP	P,T0		;RESTORE THE USETI BLK#
	TLO	T0,(USETO)	;CHANGE THE USETI TO USETO
	XCT	T0		;ALLOCATE THE DISK SPACE
	HRRZ	T1,DD.HRI(P3)	;[233] LOCATE BUFFER
	HRLI	2(T1)		;[233] SET UP BLT POINTER
	HRRI	3(T1)		;[233] SET UP BLT POINTER
	SETZM	2(T1)		;[233] CLEAR THE
	BLT	201(T1)		;[304] [233] BUFFER
	POPJ	P,		;RETURN
RBLOK1:	TLO	P3,IO.RNG	;CHANG RINGS FLAG
	POP	P,T0		;RESTORE THE STACK
	PJRST	IBLOK0		;INPUT THE BLOCK

WBLOK.:				;WRITE THE CURRENT BLOCK
	PUSH	P,T1		;[353]
	PUSH	P,T2		;[353]
	JSP	P1,WAIT.	;STOP THE DEVICE
	PUSH	P,@DD.HRO(P3)	;SAVE THE CURRENT BUFFER
	JSP	P1,CLRUSE	;CLEAR THE USE BITS
	POP	P,@DD.HRO(P3)	;RESTORE THE CURRENT BUFFER
	MOVE	T0,DD.BLK(P3)	;NO, GET THE CURRENT BLOCK NUMBER
	HLL	T0,DD.UNT(P3)	;NO, GET THE CHANNEL NUMBER
	TLO	T0,(USETO)	;SET UP A USETO TO THE LAST BLOCK
	XCT	T0		;DO IT
	TLO	P3,IO.RNG	;SET CHANGE RING FLAG
	HRRZ	T0,DD.HRO+1(P3)	;[332] GET BYTE POINTER
	HRRZ	T1,DD.HRO(P3)	;[332] ADDR OF BUFFER
	SUBI	T0,1(T1)	;[332] WORDS WITH DATA
	CAMGE	T0,1(T1)	;[332] LESS THAN WORDS READ?
	PUSHJ	P,STASET	;[332] YES-FORCE COUNT
	MOVEI	T0,.+3		;[332]
	PUSH	P,T0		;[332]
	PUSHJ	P,OBLOK0	;[332] OUTPUT THE BLOCK
	PUSHJ	P,STACLR	;[353] CLEAR IO.UWC IF WAS SET
	PJRST	TPOPJ2		;[353] RESTORE AND RETURN

STACLR:	TRZA	T2,-1		;[332] TO CLEAR THE BIT
STASET:	MOVEI	T2,1		;[332] THE BIT = IO.UWC
	HLLZ	T0,DD.UNT(P3)	;[332] GET CHANNEL NUMBER
	TLO	T0,(GETSTS)	;[332] WHAT TO DO
	HRRI	T0,T1		;[332] WILL GO INTO T1
	XCT	T0		;[332] GET STATUS
	DPB	T2,[POINT 1,T1,31]	;[332] SET OR CLEAR
	HLLZ	T0,DD.UNT(P3)	;[332] CHANNEL
	TLO	T0,(SETSTS (T1));[332] FUNCTION
	XCT	T0		;[332] SET STATUS
	POPJ	P,		;[332] END


WAIT.:				;WAIT FOR THE DEVICE TO STOP
	HLLZ	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	IOR	T0,[WAIT]	;SET UP A WAIT UUO
	XCT	T0		;STOP THE DEVICE FROM FILLINGG BUFFERS
	JRST	(P1)		;RETURN TO THE CALLER

CLRUSE:				;ROUTINE TO CLEAR THE USE BITS IN A RING
	PUSH	P,T1		;SAVE T1
	MOVSI	T0,400000	;SET UP A USE BIT MASK
	IORM	T0,DD.HRI(P3)	;*****"RI514H"***********
	MOVE	T1,DD.HRI(P3)	;GET THE RING BUFFER POINTER
CLRUS2:	SKIPL	(T1)		;USE BIT SET
	JRST	CLRUS1		;NO, EXIT
	ANDCAM	T0,(T1)		;CLEAR THE USE BIT
	MOVE	T1,(T1)		;GET THE NEXT BUFFER
	JRST	CLRUS2		;CONTINUE
CLRUS1:	POP	P,T1		;YES, RESTORE T1
	JRST	(P1)		;RETURN
	SUBTTL ENCODE/DECODE SETUP ROUNTINES
	SIXBIT	/ENC./
ENC%:	PUSHJ	P,SAVE.		;SAVE THE USER'S AC'S
	MOVSI	P3,IO.INO!IO.EDC!IO.FMT!IO.SOU	;ENCODE/OUTPUT/FORMAT
	MOVEI	P2,ENC.TB(P4)	;ADDRESS OF THE ENCODE HEADER
	JRST	ENCDEC		;GO TO COMMON CODE

	SIXBIT	/DEC./
DEC%:	PUSHJ	P,SAVE.		;SAVE THE USER'S AC'S
	MOVSI	P3,IO.EDC!IO.FMT!IO.SIN	;DECODE/INPUT/FORMAT
	MOVEI	P2,DEC.TB(P4)	;ADDRESS OF THE DECODE HEADER

ENCDEC:	HRRI	P3,DEC.TB-DD.HRI(P4)	;GET A DUMMY DD POINTER
	JSP	P1,EFCTV.	;[265] GET EFFECTIVE ADDRESS (E)
	MOVSI	T1,740		;[276] IMMEDIATE MODE CONSTANT
	TDNE	T1,0(L)		;[276] IMMEDIATE MODE CONSTANT
	JSP	P1,RELOC%	;[276] NO - LOAD REAL VALUE
	MOVEM	G1,2(P2)	;SAVE CHARACTER COUNT IN HEADER BLOCK
	MOVEM	G1,POS.TB(P4)	;STORE THE MAX COLUMN POS.
	SETZB	T3,ERR.PC(P4)	;CLEAR THE ERROR RETURN
IFN %V1,<
	HLRZ	T1,(L)		;GET THE ARG COUNT
	TRNN	T1,777000	;CHECK FOR OLD CALL
	JRST	ENCDE2		;JUMP IF A NEW CALL
	MOVE	T3,1(L)		;GET THE RETURN ADDRESS
	MOVE	G1,3(L)		;GET THE ARRAY ADDRESS
	AOJA	L,ENCDE3	;COMMON ROUTINE
ENCDE2:
>
	HLL	L,-1(L)		;GET THE NEW ARG COUNT
	AOBJP	L,[ERROR (SYS,2,10)]	;ILLEGAL ARGUMENT BLOCK
	JSP	P1,EFCTV.	;[265] 
	MOVEI	T3,(G1)		;PUT IN THE RIGHT HALF
	AOBJP	L,[ERROR (SYS,2,10)]	;ILLEGAL ARGUMENT BLOCK
	JSP	P1,EFCTV.	;[265] GET THE ADDRESS
	HRLI	T3,(G1)		;PUT IN THE LEFT HALF
	MOVE	G1,3(L)		;GET THE ARRAY ADDRESS
ENCDE3:	MOVEM	T3,ERR.PC(P4)	;STORE THE ERROR RETURN
	JSP	P1,EFCTV1	;GET THE ARRAY ADDRESS
	TRNN	G1,-20		;[224] IN AC SAVE AREA
	ADDI	G1,ACC.SV(P4)	;[224] YES - RELOCATE TO AC SAVE AREA
	HRLI	G1,(POINT 7)	;MAKE A BYTE POINTER
	MOVEM	G1,1(P2)	;PUT IN HEADER BLOCK
	MOVEI	T1,-2(G1)	;SET UP A DUMMY BUFFER HEADER
	MOVEM	T1,(P2)		;STORE IN THE RING HEADER
	JUMPI	SETIO3		;SKIP ON INPUT
	MOVE	T0,[ASCII /     /];FILL THE ARRAY WITH BLANKS
	MOVE	T1,2(P2)	;GET THE CHARACTER COUNT
	IDIVI	T1,5		;FIVE CHARACTERS/WORD
	SOJL	T1,.+3		;ONLY FULL WORDS
	MOVEM	T0,(G1)		;BLANK THE ARRAY
	AOJA	G1,.-2		;CONTINUE
	MOVEI	T0," "		;GET A BLANK
	JUMPE	T2,SETIO3	;NO PARTICAL WORDS TO FILL
	IDPB	T0,G1		;YES, STORE A BLANK
	SOJA	T2,.-2		;CONTINUE
SUBTTL I/O INITIALIZATION ROUTINES

	SIXBIT	/NLO./		;NAME FOR TRACE
NLO%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	MOVSI	P2,IO.INO!IO.FMT!IO.SOU!FT.NML	;SET NAMELIST OUTPUT
	JRST	SETIO		;GO TO SETUP

	SIXBIT	/NLI./		;NAME FOR TRACE
NLI%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	MOVSI	P2,IO.FMT!IO.SIN!FT.NML ;SET NAMELIST INPUT
	JRST	SETIO

	SIXBIT	/IN./		;NAME FOR TRACE
IN%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	MOVSI	P2,IO.FMT!IO.SIN	;SET FORMATED INPUT
	JRST	SETIO

	SIXBIT	/OUT./		;NAME FOR TRACE
OUT%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	MOVSI	P2,IO.INO!IO.FMT!IO.SOU	;SET FORMATED OUTPUT
	JRST	SETIO

	SIXBIT	/RTB./		;NAME FOR TRACE
RTB%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	MOVSI	P2,IO.SIN		;SET UN-FORMATED INPUT
	JRST	SETIO

	SIXBIT	/WTB./		;NAME FOR TRACE
WTB%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	MOVSI	P2,IO.INO!IO.SOU	;SET UN-FORMATED OUTPUT
;	JRST	SETIO

SETIO:
IFN %V1,<			;VERSION 1 CODE
	HLRZ	T2,(L)		;GET THE ARG COUNT FIELD
	LSH	T2,-^D9		;BITS 0-8 ONLY
	JUMPN	T2,SETIO0	;SKIP IF OLD CALL
>
	HLRZ	T2,-1(L)	;GET THE ARG LIST COUNT
IFN %V1,<
SETIO0:	CAIE	T2,4		;RANDOM ACCESS CALL
>
	CAIN	T2,-6		;RANDOM ACCESS CAL VERSION 2
	TLO	P2,IO.RAN	;YES, SET RANDOM ACCESS FLAG
	JSP	P1,SRCFLU	;SEE IF THE UNIT IS DEFINED
	PUSHJ	P,SETOPN	;DO A DEFAULT OPEN
	HRRM	G2,DD.UNT(P3)	;[255] SET THE FLU
IFN %V1,<
	JUMPL	L,.+4		;SKIP IF A NEW CALL
	SKIPE	T3,1(L)		;GET THE RETURN ADDRESS
	MOVEM	T3,ERR.PC(P4)	;STORE
	ADDI	L,1		;POINT TO THE FMT WORD
>
	JUMPGE	P2,SETIOB	;[316] JUMP IF INPUT REQUIRED
	LDB	T1,[POINT 4,DD.BLK(P3),9];[316] GET ACCESS SPECIFIED
	CAIN	T1,ACC.SI	;[316] SEQUENTIAL INPUT?
				;[316] RANDIN IS TESTED LATER
	ERROR	(OPN,2,10,)	;[316] YES - ERROR
SETIOB:				;[316]
	MOVE	G3,DD.STS(P3)	;GET THE DEVCHR BITS
	TLNN	P3,IO.OPN	;IS THE FILE OPEN
	PUSHJ	P,SETDIR	;NO, SET UP THE DIRECTORY
				;**;[402],SETIOB+3,MD,9/17/74
	LDB	G4,[POINT 4,DD.BLK(P3),9]	;[402] GET ACCESS
	HLL	T1,P2		;[402] GET ACCESS REQUIRED
	CAIL	G4,ACC.RO	;[402] SEQUENTIAL ACCESS
	CAIN	G4,ACC.AP	;[402] AND APPEND
	TLCE	T1,IO.RAN	;[402] MUST NOT REQUIRE RANDOM ACCESS
	TLNE	T1,IO.RAN	;[402] RANDOM AND RANDIN REQUIRE IT
	JRST	SETIOA		;[402] OK
	TLNE	P2,IO.RAN	;[375] RANDOM REQUIRED ?
	ERROR	(DAT,13,10,)	;[375] YES-CAN NOT RANDOM A SEQUENTIAL FILE
	ERROR	(DAT,17,10,)	;[375] CAN NOT DO SEQUENTIAL TO RANDOM
SETIOA:	MOVE	G4,P2		;COPY THE FLAGS
	XOR	G4,P3		;CHECK FOR MODE CHANGES
	JUMPGE	G4,SETIO1	;SWITCHING FROM IN/OUT OR OUT/IN
	TLNN	P3,IO.RAN	;UNLESS RANDOM ACCESS MODE
	PUSHJ	P,SETRWR	;YES, DO A MODE SWITCH
SETIO1:	TLNE	G4,IO.FMT	;SWITCHING FROM FORMATED/UN-FORMATED
	PUSHJ	P,SETMOD	;DO A MODE SWITCH
	SKIPL	T1,DD.LOG(P3)	;ARE THERE FIXED LENGTH RECORDS
	JRST	SETIO2		;ALREADY DEFINED
	MOVNS	T5,T1		;YES, GET THE USER'S RECORD SIZE
	LDB	T2,[POINT 6,DD.HRI+1(P3),11] 	;GET THE BITS/CHARACTER
	LDB	T4,[POINT 4,DD.BLK(P3),13]	;GET THE MODE TYPE POINTER
	CAIE	T4,MOD.IM-MOD.DP;IMAGE MODE
	ADDI	T1,2		;NO, ALLOW FOR (LSCW OR CR-LF)
	MOVEI	T3,44		;GET THE NUMBER OF BITS PER WORD
	IDIVI	T3,(T2)		;GET THE ITEMS PER WORD
	IDIVI	T1,(T3)		;GET THE NUMBER OF WORD/RECORD
	SKIPE	T2		;IS THERE A PARTICAL WORD
	ADDI	T1,1		;YES, ALLOCATE ANOTHER WORD
	HRLI	T1,(T5)		;GET THE ITEMS/RECORD (USER VALUE)
	MOVEM	T1,DD.LOG(P3)	;STORE THE LOG REC SIZE
SETIO2:	TLNE	P3,IO.CCC	;IS THE OUTPUT FORMATED
	MOVSI	T1,1		;SET UP A FLAG FOR "OUTCCC"
	HLRZM	T1,POS.TB(P4)	;SET UP THE POSITION TABLE
	TLNN	P2,IO.RAN	;RANDOM ACCESS REQUEST
	JRST	SETIO5		;SEQUENTIAL I/O
IFN %V1,<
	MOVE	G1,2(L)		;ASSUME AN OLD CALL
	SKIPG	L		;TEST
>
	MOVE	G1,3(L)		;GET THE ADDRESS OF THE RECORD NUMBER
	PUSHJ	P,FIND%%	;GO SET UP THE BUFFERS
SETIO5:	TLNN	P3,IO.FMT	;IS THIS FORMATED I/O
	JRST	BINIO		;NO, GO TO BINARY ROUTINES
	TLNN	P2,FT.NML	;YES, NAME LIST I/O
	JRST	SETIO3		;NO,
IFN %V1,<
	SKIPL	L		;OLD CALL
	AOSA	L		;YES, UPDATE THE POINTER WORD
>
	AOBJP	L,[ERROR (SYS,2,10,CPOPJ)];ILLEGAL ARG BLOCK
	JSP	P1,EFCTV.	;[265] GET THE EFFECTIVE ADDRESS
	PUSHJ	P,NMLST%##	;GO PROCESS THE NAME LIST REQUEST
	PJRST	FINF1		;GO TO FIN% TO CLEAN UP
SETIO3:	MOVE	T1,DD.HRO+1(P3)	;OUTPUT GET THE OUTPUT HEADER
	JUMPO	SETIO4		;JUMP ON INPUT
	TLNE	P3,IO.EOL	;AT END OF LAST LINE
	PUSHJ	P,NXTLNI	;YES, GET THE NEXT INPUT LINE
	MOVE	T1,DD.HRI+1(P3)	; GET THE BEGINNNG BYTE POINTER
SETIO4:	TLZ	P3,IO.EOL	;CLEAR THE END OF LINE
	MOVEM	T1,POS.TB+1(P4)	;SAVE FOR AN ERROR PRINT (T FORMAT)
	SETZM	SCL.SV(P4)	;CLEAR THE SCALING FACTOR
	JRST	FMTSRC		;GO TO THE FORMAT SCANNER
	SUBTTL	ACCESS MODE CHANGE ROUTINES

SETDIR:	HLLZS	DD.BLK(P3)	;CLEAR THE BLOCK COUNT
	TLNN	G3,DV.DIR	;DIRECTORY DEVICE
	JRST	SETDI1		;NO, DO NOT LOOKUP/ENTER
	SETZM	DD.ALC(P3)	;***** CLEAR BLOCKS ALLOCATED
	MOVEI	P1,LOOKU.	;ASSUME INPUT
	JUMPGE	P2,SETDI0	;JUMP ON INPUT
	MOVEI	P1,ENTER.	;SET OUTPUT
SETDI0:	JSP	P1,(P1)		;SET UP THE FILE
	ERROR	(OPN,0,7,)	;FILE NOT FOUND
SETDI1:	JUMPGE	P2,SETDI2	;JUMP ON OUTPUT
	LDB	T4,[POINT 4,DD.BLK(P3),13]	;[236] GET THE MODE TYPE
	CAIE	T4,MOD.DU	;[236] DUMP MODE OUTPUT
	PUSHJ	P,OBLOK.	;[236] NO - DUMMY OUTPUT
	TLOA	P3,IO.INO	;SET OUTPUT
SETDI2:	TLZ	P3,IO.INO	;SET INPUT
	TLO	P3,IO.OPN	;SET FILE OPEN
	POPJ	P,		;RETURN


SETMOD:	MOVEI	T0,MOD.AS-MOD.DP;ASSUME ASCII MODE SWITCH
	TLZE	P3,IO.FMT	;CHECK THE PREVIOUS I/O MODE
	MOVEI	T0,MOD.BN-MOD.DP;SET BINARY MODE
	DPB	T0,[POINT 4,DD.BLK(P3),13] ;SAVE THE NEW MODE INDEX
	TLNN	P3,IO.NON	;NON STANDARD MODE (ERROR IF SO)
	JSP	P1,OPENDM	;MAKE THE MODE SWITCH
	ERROR	(OPN,1,10)	;ILLEGAL MODE
	HLLZ	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T0,(SETSTS)	;SET UP A STATUS UUO
	HRR	T0,DD.OPN(P3)	;GET THE STATUS ADDRESS
	XCT	T0		;TELL THE MONITOR ABOUT THE MODE CHANGE
	HLRZ	T0,MOD.DP(T5)	;GET THE BYTE SIZE
	ANDI	T0,7700		;CLEAR OUT ALL BUT BYTE SIZE
	HRLM	T0,DD.HRI+1(P3)	;SET UP THE NEW BYTE POINTER
	HRLM	T0,DD.HRO+1(P3)	;BOTH INPUT AND OUTPUT
	MOVE	T1,DD.HRI+2(P3)	;GET THE INTPUT ITEM COUNT
	JUMPI	.+2		;SKIP ON INPUT
	MOVE	T1,DD.HRO+2(P3)	;GET THE OUTPUT ITEM COUNT
	JUMPE	T1,CPOPJ	;EXIT IF THE BUFFER IS EMPTY/FULL
	TLNE	P3,IO.FMT	;SWITCHING TO FORMAT
	IMULI	T1,5		;YES, CHANGE ITEM COUNT TO CHARACTER
	TLNN	P3,IO.FMT	;SWITCHING TO BINARY
	IDIVI	T1,5		;YES, CHANGE CHARACTERS TO WORDS
	MOVEM	T1,DD.HRI+2(P3)	;SAVE THE NEW ITEM COUNT
	MOVEM	T1,DD.HRO+2(P3)	;FOR BOTH INPUT/OUTPUT
	POPJ	P,		;RETUNR
	SUBTTL SETWRT ROUTINE TO SWITCH THE FILE FROM READ TO WRITE MODE
SETRWR:	TLNN	G3,DV.TTY!DV.TTA!DV.PTY	;USER'S TTY
	JRST	SETRW1		;NO, CONTINUE
	TLCE	P3,IO.INO	;YES, OUTPUT LAST
	PJRST	OBLOK.		;YES, DUMP THE LAST BLOCK
	JRST	SETRW7		;EXIT RETURN
SETRW1:	HRRZ	T2,DD.BLK(P3)	;GET THE BLOCK COUNT
	JUMPE	T2,SETRW0	;BEGINNING OF FILE ANY SWITCH OK
	JUMPI	SETRW2		;SWITCH TO OUTPUT IS LEGAL
	ERROR	(DAT,10,10,)	;KILL THE JOB READ_WRITE

;;	SUPERCEDING SEQINOUT FILE
;;	LOOKUP BUT NOT ENTER PERFORMED BY FILOPN
;;	CLOSE FILE AND ENTER TO EFFECT SUPERCEDE

SETRW0:	HLLZ	T1,DD.UNT(P3)	;[240] GENERATE CLOSE UUO
	TLO	T1,(CLOSE)	;[205] GENERATE CLOSE UUO
	XCT	T1		;[205] UNDO LOOKUP - KEEP OUT OF UPDATE MODE
	PJRST	SETDIR		;[205] ENTER THE FILE INSTEAD


;;	SWITCH TO OUTPUT

SETRW2:	JSP	P1,WAIT.	;STOP THE DEVICE
	TLNN	G3,DV.OUT	;CAN THE DEVICE DO OUTPUT
	ERROR	(OPN,2,7,)	;NO, KILL THE JOB WITH A MESSAGE
	HRRZ	T4,DD.HRI(P3)	;[362] GET ADDRESS OF CURRENT BUFFER
	HLRZ	G1,(T4)		;[362] GET "SIZE+1" FROM THE BUFFER
	TRZ	G1,400000	;[362] USE BIT IS NOT PART OF SIZE
	ADDI	G1,(T4)		;[362] COMPUTE ADDRESS OF LAST BUF WORD
	HRRZ	T4,DD.HRI+1(P3)	;[362] GET CURRENT BUF WORD ADDRESS
	SUBI	G1,(T4)		;[362] DIFF IS NUMBER OF UNUSED WORDS
	TLNN	P3,IO.FMT	;[362] IF FORMAT (ASCII), THEN 5*...
	JRST	SETRW6		;[362] FINISHED COMPUTING IF WORD MODE
	IMULI	G1,5		;[362] NUMBER OF BYTES IN UNUSED WORDS
	LDB	T4,[POINT 6,DD.HRI+1(P3),5]	;[362] GET "P"
	IDIVI	T4,7		;[362] UNUSED BYTES IN CURRENT WORD
	ADDI	G1,(T4)		;[362] TOTAL UNUSED BYTES

SETRW6:	DMOVE	T4,DD.HRI(P3)	;[362] GET 1ST 2 WORDS OF INPUT HEADER
	TLNN	G3,DV.DSK	;IS THIS A DSK TYPE DEVICE
	JRST	SETRW4		;NO
	HRRZM	T2,DD.ALC(P3)	;STORE THE CURRENT BLOCK NUMBER
	JSP	P1,RENAM.	;TRUNCATE THE FILE
	JRST	SETRW3		;ERROR
	JSP	P1,LOOKU.	;LOOKUP THE FILE AGAIN
	JRST	SETRW3		;ERROR
	JSP	P1,ENTER.	;GO TO UPDATE MODE
SETRW3:	ERROR	(OPN,0,7,)	;FAILURE TRYING  TO TRUNCATE THE FILE
	HLL	T2,DD.UNT(P3)	;YES, GET THE CHANNEL NUMBER
	TLO	T2,(USETO)	;SET OUTPUT THE THE CURRENT BLOCK NUMBER
	XCT	T2		;SET FILSER TO THE BLOCK FOR A REWRITE
	TLO	P3,IO.RNG	;SET RING CHANGE FLAG
	JRST	SETRW5		;COMMON EXIT
SETRW4:	TLNN	G3,DV.MTA	;IS THIS A MAGE TAPE
	ERROR	(OPN,2,10,)	;BLOCK CAN NOT BE REWRITTEN
	MOVEI	T3,1		;CURRENT BUFFER HAS USE BIT SET
				;GET COUNTED BY "BSRMTA"
	JSP	P1,BSRMTA	;BACK UP THE MAGTAPE

SETRW5:	DMOVEM	T4,DD.HRO(P3)	;SET UP THE OUTPUT RING HEADER
	MOVEM	G1,DD.HRO+2(P3)	;PUT IN THE OUTPUT RING HEADER
	TLO	P3,IO.INO	;SET OUTPUT MODE
SETRW7:	TLZ	P3,IO.EOL	;CLEAR END OF LINE
	POPJ	P,		;RETURN
	SUBTTL BINXX BINARY FORMATED DATA TRANS INIT ROUTINES
BINIO:	SETZB	P2,G4		;CLEAR THE FORMAT REGISTER
	TLZ	P3,IO.EOL!IO.FMT;CLEAR END OF LINE AND FORMAT FLAG
	TLNE	P3,IO.NON	;NON STANDARD I/O MODE
	JRST	[LDB	T1,[POINT 4,DD.BLK(P3),13];GET THE MODE
		CAIN	T1,MOD.DU	;DUMP MODE
		JRST	DMPIO.		;GO TO DUMP MODE ROUTINES
		MOVEI	G4,-1		;SET THE LARGEST RECORD SIZE
		MOVEM	G4,POS.TB(P4)	;STORE IN POSITION TABLE
		JRST	BINXIT]		;EXIT TO I/O LIST
	JUMPI	BINRD.		;JUMP ON INPUT
BINWR.:	MOVSI	T0,(1B8)	;SET UP THE BEGIN OF RECORD CONTROL WORD
	AOS	G4,T0		;COUNT THIS RECORD LSCW=G4
	MOVS	T1,DD.LOG(P3)	;FIXED LENGTH OUTPUT
	JUMPE	T1,BINWR1	;JUMP IF VARIABLE LENGTH
	ADDI	T0,(T1)		;ADD THE USER'S RECORD SIZE
	AOS	POS.TB(P4)	;DO NOT COUNT CONTROL WORDS
BINWR1:	JSP	P1,OBYTE.	;OUTPUT THE LSCW
	HRRZ	P2,DD.HRO+1(P3)	;SAVE THE LSCW POSITION CLEAR FLAGS
	SETZM	POS.TB+2(P4)	;CLEAR THE RECORD COUNTER
	JRST	BINXIT		;TAKE THE COMMON EXIT


BINRD.:	JSP	P1,IBYTE.	;GET A CONTROL WORD
	TLNN	P3,IO.RAN	;[231] TAKE ANY LSCW ON RANDOM ACCESS
	JUMPE	T0,IBYTE.	;FIND AN INPUT RECORD
	MOVEM	T0,POS.TB+2(P4)	;SAVE THE LSCW
	HLRZ	T1,T0		;GET THE HIGH ORDER NINE  BIT
	LSH	T1,-^D9		;POSITION THE RECORD TYPE
	CAIN	T1,1		;FOROTS TYPE 1 LSCW
	SOJA	T0,BINRD1	;YES, COUNT THE LSCW
	TLNE	P3,IO.RAN	;[231] RANDOM ACCESS
	JUMPE	T1,[TLO P3,IO.EOL	;[231] YES - UNINTIALIZED RECORD
		    JRST BINRD1]	;[231] SET END OF LINE
IFN FORSE,<
	JUMPE	T1,BINFSE	;IS IT A FORSE CONTROL WORD
>
	ERROR	(DAT,2,7,)	;NO, ILLEGAL DATA
IFN FORSE,<
BINFSE:	HLRZ	G4,T0		;GENERATE A FOROTS TYPE 1 LSCW
	TLOA	P2,FT.FSE	;SET FORSE BINARY RECORD SEEN
>
BINRD1:	HRRZ	G4,T0		;GET THE SEGMENT COUNT
BINXIT:
IFN CHKSUM,<
	SETZB	G3,POS.TB+1(P4)	;CLEAR THE CHECK SUM COUNTERS
>
;	PJRST	BINCON		;DROP INTO THE BINARY I/O ROUTINES
	SUBTTL BINARY INPUT/OUTPUT ROUTINES SYNC DATA WITH THE I/O LIST

BINCON:			;ENTRY FOR THE NEXT LIST ITEM FROM IOLST%
	JSP	P1,IOLS%%	;GET THE NEXT LIST ITEM
	JUMPI	BINRED		;[301]JUMP ON INPUT
	TLNE	P3,IO.EOL	;END OF RECORD
	JRST	BINCON		;YES IGNORE THE LIST ITEM
	SKIPG	T5,DD.HRO+2(P3)	;IS THE BUFFER FULL/EMPTY
	PUSHJ	P,LSCWW2	;YES, OUTPUT A TYPE 2 LSCW
	TLZE	P2,FT.SLT	;IS THE A SLIST
	CAME	G2,[XWD 1,1]	;IS THE INCREMENT ASSENDING BY 1
	AOJA	G4,BINWRW	;NO DO A WORD TRANSFER


;ROUTINE TO TRANSFER BLOCK OF ARRAYS TO THE OUTPUT BUFFER
		;T0=	I/O DATA ITEM
		;T1=	THE BLT POINTER WORD
		;T2=	NOT USED
		;T3=	NOT USED
		;T4=	THE NUMBER OF WORDS IN THE CURRENT SEGMENT
		;T5=	THE NUMBER OF WORDS LEFT IN THE CURRNT BUFFER
		;G1=	IOWD -SIZE,,ADR
		;G2=	WORDS LEFT TO BE TRANSFERED
		;G3=	CHECK SUM WORD
		;G4=	LSCW
		;P2	ADDRESS OF THE LAST LSCW
		;P3	I/O REGISTER

	HLRE	G2,G1		;GET THE NEGATIVE ARRAY SIZE
	ADDM	G2,POS.TB(P4)	;UPDATE THE COLUMN COUNTER
	SKIPE	DD.LOG(P3)	;FIXED LENGTH OUTPUT
	SKIPLE	POS.TB(P4)	;AND EXCEEDING RECORD SIZE
	JRST	BINSLW		;NO, G2=ARRAY SIZE
	SUB	G2,POS.TB(P4)	;YES, REDUCE THE ARRAY SIZE TO FIT
	TLO	P3,IO.EOL	;LITE THE END OR RECORD FLAG
BINSLW:	MOVE	T5,DD.HRO+2(P3)	;GET THE NUMBER OF REMAINING WORDS
	MOVMS	T4,G2		;CONVERT TO POSITIVE IN T4 AND G2
	CAILE	T4,(T5)		;WILL THE ARRAY FIT IN THE BUFFER
	MOVEI	T4,(T5)		;NO, GET THE  SPACE LEFT IN THE BUFFER
	SUBI	G2,(T4)		;REDUCE THE ARRAY SIZE BY THE BUFFER SPACE
	ADDI	G4,(T4)		;UPDATE THE LSCW WORD COUNT
	MOVE	T1,DD.HRO+1(P3)	;GET THE BYTE POINTER TO THE BUFFER
	HRLI	T1,(G1)		;GET THE ARRAY ADDRESS (BLT POINTER)
	ADDM	T4,DD.HRO+1(P3)	;UPDATE THE BYTE POINTER
	SUBI	T5,(T4)		;REDUCE THE BYTE COUNTER
	MOVEM	T5,DD.HRO+2(P3)	;STORE THE NEXT BYTE POINTER
	ADDI	T1,1		;POINT TO THE FIRST AVAILABLE BUFFER WORD
	BLT	T1,@DD.HRO+1(P3);TRANSFER THE ARRAY BLOCK
IFN CHKSUM,<
	XOR	G3,(G1)		;ACCUMULATE THE CHECK SUM
	ADDI	G1,1		;UPDAT THE ARRAY POINTER
	SOJG	T4,.-2		;CHECK SUM THE NUMBER OF WORD TRANSFERED
>
IFE CHKSUM,<
	ADDI	G1,(T4)		;UPDATE THE ARRAY ADDRESS
>
	JUMPN	T5,.+3		;IS THE BUFFER FULL
	PUSHJ	P,LSCWW2	;YES, OUTPUT THE BUFFER AND A TYPE 2 LSCW
	JUMPN	G2,BINSLW	;IS THE ARRAY DONE
	JRST	BINCON		;YES, GET NEXT IOLST ITEM


;SINGLE WORD DATA TRANSFER ROUTINE (OUTPUT)

BINWRW:	MOVE	T0,(G1)		;GET THE DATA WORD
IFN CHKSUM,<
	XOR	G3,T0		;ACCUMULATE THE CHECK SUM
>
	JSP	P1,OBYTE.	;OUTPUT THE WORD
	SKIPG	T5,DD.HRO+2(P3)	;IS THE OUTPUT BUFFER FULL
	PUSHJ	P,LSCWW2	;YES OUTPUT A CONTROL WORD
	ADD	G1,G2		;COMPUTE THE NEXT VARIABLE ADDRESS
	TLNE	P3,IO.EOL	;CHECK FOR END OF LINE
	JRST	BINCON		;YES, IGNORE THE LIST ITEMS
	JUMPGE	G1,BINCON	;GET THE NEXT IOLST ITEM
	AOJA	G4,BINWRW	;ADD THIS WORD AND CONTIUE

; BINARY READ ROUTINES

BINRED:				;BINARY INPUT ROUTINES
	TLNE	P3,IO.EOL	;[301] EOL SEEN?
	JRST	BINEO2		;[301] YES - FILL WITH NULLS
	JUMPN	G4,BINRE1	;IS THE SEGMENT EMPTY
	PUSHJ	P,LSCWR2	;YES READ A TYPE 2 LSCW
	JRST	BINEO2		;[334] READ TYPE 3 FILL WITH NULLS
BINRE1:	TLZE	P2,FT.SLT	;IS THERE A SLIST CALL
	CAME	G2,[XWD 1,1]	;AND ASSENDING BY 1
	SOJA	G4,BINRDW	;NO, DO A WORD BY WORD TRANSFER

	HLRE	G2,G1		;GET THE NEGATIVE ARRAY SIZE
BINSLR:	SKIPG	DD.HRI+2(P3)	;GET THE BUFFER ITEM COUNT
	PUSHJ	P,IBLOK.	;BUFFER IS EMPTY
	TLNE	P3,IO.EOF	;[201] END OF FILE SEEN
	JRST	[MOVSI	T1,(1B0)	;[334] SET A FLAG
		 TLNN	P3,IO.NON	;[334] IF FORMATTED BINARY
		 HLLM	T1,ALT.PC(P4)	;[334] AS ILLEGAL EOF
		 JRST	BINEO1]		;[334] FILL AND PROCESS EOF
	MOVE	T5,DD.HRI+2(P3)	;GET THE ITEM COUNT
	MOVMS	T4,G2		;GET A POSITIVE COPY IN G2 AND T4
	CAILE	T4,(T5)		;FIND THE SMALLEST VALUE OF
	MOVEI	T4,(T5)		;NUMBER OF WORDS IN THE BUFFER
	CAILE	T4,(G4)		;NUMBER OF WORD IN THE SEGMENT
	MOVEI	T4,(G4)		;AND THE ARRAY SIZE PUT IN T4
	SUBI	G2,(T4)		;REDUCE THE ARRAY SIZE BY THE TRANS.
	SUBI	G4,(T4)		;REDUCE THE LSCW COUNT BY TRANS.
	HRLO	T1,DD.HRI+1(P3)	;GET THE FROM ADDR. (-1)
				;SET RIGHT HALF TO -1 TO FORCE A CARRY
				;ONTO THE LEFT ON THE NEXT INSTRUCTION
				;ADDS 1 TO LEFT
	ADDI	T1,1(G1)	;GET THE TO ADDR (ADD 1 TO THE LEFT HALF)
	SUBI	T5,(T4)		;REDUCE THE BUFFER ITEM COUNT
	ADDM	T4,DD.HRI+1(P3)	;UPDATE THE BYTE POINTER
	MOVEM	T5,DD.HRI+2(P3)	;PUT IN THE RING HEADER
	ADDI	G1,(T4)		;UPDATE THE ARRAY ADDRESS
	BLT	T1,-1(G1)	;MOVE THE ARRAY INTO MEMORY
IFN CHKSUM,<
	MOVNS	T4		;NEGATE THE ARRAY SIZE
	HRLI	T4,-1(T4)	;MAKE AN AOBJN POINTER
	ADDI	T4,(G1)		;GET THE ARRAY ADDRES BACK
BINSL1:	XOR	G3,(T4)		;ACCUMULATE THE CHECK SUM
	AOBJN	T4,BINSL1	;CHECK SUM THE ARRAY
>
	JUMPE	G2,BINCON	;END OF ARRAY GET NEXT LIST ITEM
	JUMPN	G4,BINSLR	;IS THE SEGMENT EMPTY
	PUSHJ	P,LSCWR2	;YES, READ A LSCW TYPE 2
	JRST	BINEO2		;[334] FILL WITH NULLS
	JRST	BINSLR		;CONTINUE THE ARRAY

BINRDW:				;ENTRY TO DO A WORD BY WORD DATA TRANSFER
	JSP	P1,IBYTE.	;GET A DATA ITEM
	TLNE	P3,IO.EOF	;[201] END OF FILE
	JRST	[SETZM	(G1)	;[301] CLEAR THE WORD
		 MOVSI	T1,(1B0);[334] SET A FLAG
		 TLNN	P3,IO.NON	;[334] IF FORMATTED BINARY
		 HLLM	T1,ALT.PC(P4)	;[334] ILLEGAL EOF
		 JRST	BINEOF]	;[301] AND PROCESS EOF
	MOVEM	T0,(G1)		;STORE THE DATA IN MEMORY
IFN CHKSUM,<
	XOR	G3,T0		;ACCUMULATE THE CHECK SUM
>
	ADD	G1,G2		;[261] UPDATE THE MEMORY ADDRESS
	JUMPGE	G1,BINCON	;END OF LIST GET NEXT LIST ITEM
BINRD2:	SOJGE	G4,BINRDW	;IS THE SEGMENT EMPTY
	PUSHJ	P,LSCWR2	;READ A TYPE 2 LSCW
	JRST	BINEO2		;[334] FILL WITH NULLS
	JRST	BINRD2		;MAY BE A NULL SEGMENT

;END OF FILE WHILE READING BINARY DATA

BINEO1:	MOVMS	G2		;[371] MAKE SURE LENGTH IS POSITIVE
	SETZM	(G1)		;[301] CLEAR FIRST WORD
	HRLZI	T1,(G1)		;[301] SOURCE FOR BLT TRANSFER
	HRRI	T1,1(G1)	;[301] DESTINATION
	ADDI	G1,(G2)		;[301] END OF TRANSFER
	BLT	T1,-1(G1)	;[301] CLEAR END OF BLOCK
	JRST	BINEOF		;[301] CONTINUE
BINEO2:	SETZM	(G1)		;[301] CLEAR ALWAYS 1ST WORD
	TLZN	P2,FT.SLT	;[301] LIST IN PROGRESS?
	JRST	BINEOF		;[301] NO
BINEO3:	ADD	G1,G2		;[301] UPDATE ITEM ADDRESS
	JUMPGE	G1,BINEOF	;[301] END OF THIS LIST
	SETZM	(G1)		;[301] CLEAR THIS ONE
	JRST	BINEO3		;[301] SEE IF MORE
BINEOF:	TLNN	P3,IO.NON	;[334] NON FORMATTED BINARY
	TLNN	P3,IO.EOF	;[334] OR NO EOF
	JRST	BINCON		;[334] YES - FINISH I/O LIST
	SKIPL	ALT.PC(P4)	;[334] ILLEGAL EOF
	JRST	BINCON		;[334] NO CONTINUE
	JRST	LSCWNF		;[334] MISSING OR ERRONEOUS LSCW
	SUBTTL LSCWXX ROUTINE TO PROCESS THE LOGICAL SEGMENT CONTROL WORDS
;	ROUTINE TO OUTPUT A TYPE 2 LSCW ON THE CURRENT DEVICE
;	CALL
;	PUSHJ	P,LSCWW2
;	(RETURN)

LSCWW2:
	TLNN	P3,IO.NON	;SKIP CONTOL WORD FOR NON STANDARD
	SKIPE	DD.LOG(P3)	;FIXED LENGTH OUTPUT (RANDOM)
	PJRST	OBLOK.		;YES, DUMP THE BLOCK (DON'T RETURN)
IFN CHKSUM,<
	JSP	P1,CHKSM.	;DO A FOLDED CHECK SUM ON G3 RESULT IN T1
	TLO	G4,(T1)		;INSERT THE CHECK SUM IN THE LSCW
	XORM	G4,POS.TB+1(P4)	;ACCUMULATE THE RECORD CHECKSUM
	SETZ	G3,		;INITIALIZE THE CHECK SUM WORD
>
	MOVEM	G4,(P2)		;STORE THE LSCW IN THE BUFFER
	ADD	G4,POS.TB+2(P4)	;GET THE REOCRD COUNT
	HRRZM	G4,POS.TB+2(P4)	;KEEP THE WORD COUNT FOR THE RECORD
	MOVSI	T0,(2B8)	;SET UP A NEW CONTROL WORD
	AOS	G4,T0		;GET THE CONTINUE LSCW IN G4
	JSP	P1,OBYTE.	;OUTPUT THE LSCW
	HRR	P2,DD.HRO+1(P3)	;SAVE THE POSITION OF THE LSCW
	POPJ	P,		;RETURN

;	ROUTINE TO READ THE NEXT LSCW TYE 2
;	CALL
;	PUSHJ	P,LSCWR2
;	(RETURN)		;TYPE 3 LSCW FOUND
	;	(RETURN)	;TYPE 2 LSCW FOUND
;				;CALLS THE ERROR MACRO ON ERROR

LSCWR2:			;READ A TYPE 2 LSCW
IFN FORSE,<
	TLNN	P2,FT.FSE	;IS THIS A FORSE RECORD
	JRST	LSCWFSE		;NO, GO TO FOROTS ROUTINE
	SETZM	DD.HRI+2(P3)	;CLEAR THE ITEM COUNT(FORSES NEXT BLOCK)
	HRRZ	T0,POS.TB+2(P4)	;GET THE CURRENT CONTROL WORD COUNT
	JUMPE	T0,.+3		;IS IT A CONTINUE LSCW
	ERROR	(DAT,4,2,)	;NO, I/O LIST GREATER THAN RECORD
	JSP	P1,IBYTE.	;GET THE CONTROL WORD
	HLRZ	G4,T0		;SIMULATE A FOROTS CONTROL WORD
	MOVEM	T0,POS.TB+2(P4)	;SAVE THE FORSE CONTROL WORD
	AOS	(P)		;SKIP
	POPJ	P,		;RETURN
LSCWFSE:>

IFN CHKSUM,<
	JSP	P1,CHKSM.	;COMPUTE THE CHECK SUM ON G3
	HLRZ	T0,POS.TB+2(P4)	;MATCH UP THE CHECK SUMS
	ANDI	T0,777		;ONLY NINE BITS
	JUMPE	T0,.+5		;NO CHECK SUM ON INPUT
	XORI	T0,(T1)		;XOR THE CHECK SUMS
	JUMPE	T0,.+3		;YES MATCHING CHECK SUMS
	ERROR	(DAT,3,7,)	;NO SEGMENT ERROR
	MOVE	T1,POS.TB+2(P4)	;INSERT THE CONTROL INFO
	DPB	T0,[POINT 9,T1,17] ;PUT THE CHECK SUM IN THE RECORD
	XORM	T1,POS.TB+1(P4)	;ACCUMULATE THE REOCRD CHECK SUM
	SETZ	G3,		;CLEAR THE CHECKSUM
>
LSCWRN:	JSP	P1,IBYTE.	;GET THE NEXT CONTROL WORD
	MOVEM	T0,POS.TB+2(P4)	;SAVE THE LSCW
	HLRZ	T1,T0		;GET THE CONTROL BITS + CHKSUM
	LSH	T1,-^D9		;POSITION THE CONTROL BITS
	CAIE	T1,2		;IS THIS A TYPE 2 LSCW
	JRST	LSCWR3		;NO, CKECK ON TYPE 3
	ANDI	T0,-1		;CLEAR THE LEFT HALF
	SOSG	G4,T0		;COUNT THE LSCW IN THE SEGMENT COUNT
	JRST	LSCWRN		;READ A NULL SUGMENT
	AOS	(P)		;SKIP RETURN
	POPJ	P,		;RETURN

LSCWR3:				;CHECK ON TYPE 3 LSCW
	CAIE	T1,3		;IS THIS A TYPE 3 CONTROL WORD
LSCWNF:	ERROR	(DAT,2,7,)	;[201] NO, ERROR IN THE DATA RECORD
IFN CHKSUM,<
	JSP	P1,CHKSM.	;FOLD THE CHECK SUMB
	HLRZ	T0,POS.TB+1(P4)	;GET THE REOCRD CHECK SUM WORD
	ANDI	T0,777		;ONLY NINE BITS
	JUMPE	T0,.+5		;SKIP IF NO INPUT CHECK SUM
	XORI	T0,(T1)		;COMPARE THE CHECK SUMS
	JUMPE	T0,.+3		;EQUAL IF ZERO
	ERROR	(DAT,3,7,)	;NO CHECK SUM ERROR
>
	TLO	P3,IO.EOL	;SET END OF LINE FLAG
	POPJ	P,		;RETURN FOR TYPE 3 LSCW FOUND
	SUBTTL DUMPIO DUMP MODE I/O ROUTINES
DMPCNK==^D20			;CHUNK SIZE FOR IOWD'S
DMPIO.:
	TLO	P3,IO.RNG!IO.NON	;SET DUMP MODE AS NONSTANDARD
	MOVEI	T0,DMPCNK	;ALLOCATE A CHUNK FOR THE IOWD LIST
	PUSHJ	P,GMEM%%	;ALLOCATE
	MOVEM	T1,DD.HRI(P3)	;STORE IN THE RING HEADER
	MOVEM	T1,DD.HRO(P3)	;DON'T CARE IF INPUT/OUTPUT
DMPIO1:	MOVEI	G4,(T1)		;BUILD AN AOBX POINTER
	HRLI	G4,-<DMPCNK-1>	;ALLOCATE ALL BUT LAST WORD TO TERMINATE
DMPIO2:	JSP	P1,IOLS%%	;GET THE I/O LIST
	TLZ	P2,FT.SLT	;CLEAR THE SLIST FLAG
	TLNN	G1,-1		;CHECK FOR A SINGLE VARIABLE
	TLO	G1,-1		;SET THE COUNT
	SOS	G1		;IOWD -N,,LOC-1
	MOVEM	G1,(G4)		;STORE IN THE IOWD LIST
	AOBJN	G4,DMPIO2	;CONTINUE
	MOVE	T1,DD.HRI(P3)	;END OF IOWD ALLOCATION GET THE START
	PUSHJ	P,LMEM%%	;LINK A NEW CHUNK ON THE END
	HRRZM	T1,DMPCNK-1(G4)	;STORE A JUMP WORD  IOWD 0,,ADR
	JRST	DMPIO1		;GO AGAIN
	SUBTTL IOLST% INPUT/OUTPUT LIST PROCESSING ROUTINE

	SIXBIT	/IOLST./	;NAME FOR TRACE
IOLST%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	SKIPN	P3,IOL.P3(P4)	;RELOAD THE I/O REG
	POPJ	P,		;I/O NOT ACTIVE
	MOVSI	T1,IOL.SV(P4)	;GET THE ADRESS OF THE STATE TABLE
	HRRI	T1,G3		;AND BLT INTO THE AC'S
	BLT	T1,P2		;RESTORE
	TLO	P2,FT.LST	;SET IOLIST SEEN FLAG
IOLST1:	SKIPN	G1,(L)		;GET THE NEXT IOLIST ARGUMENT
	PJRST	IOLSAV		;SAVE THE I/O LIST STATE
	MOVEM	P1,IOL.P1(P4)	;SAVE THE CALLER'S ADDRESS
	HLRZ	G2,(L)		;GET THE IO LIST ARG TYPE
	LSH	G2,-^D9		;LEFT 9 BITS ONLY
	CAIGE	G2,IOL.MX	;CHECK FOR AN IMPLIED FIN CALL
	JRST	@IOLST(G2)	;GO TO THE CORRECT ROUTINE
IOLST2:	ERROR	(SYS,2,10,FIN%%)	;NO,IOLST ARGUMENT ERROR
IOLST:	JRST	IOLST2		;(0) ERROR, ZERO NOT ALLOWD
	JRST	DATA%		;(1) DATA ARGUMENT
	JRST	SLIST%		;(2) SLIST ARUMNET
	JRST	ELIST%		;(3) ELIST ARGUMENT
	JRST	FIN%%		;(4) IO FINISHED
IOL.MX==.-IOLST		;IOLST TABLE SIZE

;REENTRY POINT TO THE IOLST% ROUTINE FOR NEXT VARIABLE

IOLS%%::TLNN	P2,FT.LST	;HAS AN I/O LIST BEN SEEN
	PJRST	IOLSAV		;NO, SAVE THE STATE TABLES
	TLNN	P2,FT.SLT!FT.EXT	;[260] IS A LIST IN PROGRESS
	AOJA	L,IOLST1	;NO, GET NEXT ARGUMENT
	TLNE	P2,FT.SLT	;[247] YES, GO TO CORRECT LIST ROUTINE
	JRST	SLISTX		;SLIST LIST IN PROCESS
	JRST	ELISTX		;ELIST LIST IN PROCESS


;	ROUTINE TO SAVE THE STATE OF THE I/O LIST
IOLSAV:
	MOVEI	T1,IOL.SV(P4)	;GET THE SAVE AREA ADDRESS
	HRLI	T1,G3		;BLT TO SAVE THE AC'S FOR A USER'S RETURN
	BLT	T1,IOL.P3(P4)	;SAVE AC'S G3-P3
	POPJ	P,		;RETURN FOR THE NEXT LIST ITEM
	SUBTTL	DATA/SLIST/ELIST INPUT/OUTPUT ROUTINES

SLIST%:	TLOA	P2,FT.SLT	;[247] SET SLIST FLAG
ELIST%:	TLO	P2,FT.ELT	;[247] SET ELIST FLAG
	TLZ	P2,FT.EXT	;[247] CLEAR EXTENDED LIST
	JSP	P1,EFCTV.	;[265] COMPUTE # OF ELEMENTS
	MOVSI	T2,740		;[247] IMMEDIATE MODE
	TDNE	T2,0(L)		;[247] CONSTANT?
	JSP	P1,RELOC%	;[247] NO - LOAD ACTUAL VALUE
	MOVNM	G1,DAT.TP(P4)	;[247] SAVE THE COUNT
	HRRI	L,2(L)		;[247] POINT TO THE FIRST ARRAY ADDRESS
DATA%:
	JSP	P1,EFCTV.	;[265] GET THE ADDRESS
	TRNN	G1,-20		;IN THE AC SAVE AREA
	ADDI	G1,ACC.SV(P4)	;YES, RELOCATE TO THE SAVE AREA
	HLRZ	T5,(L)		;GET THE ARG TYPE CODE
	LSH	T5,-5		;POSITION
	ANDI	T5,17		;FOUR BITS ONLY
	TLNN	P2,FT.SLT!FT.ELT	;[247] SLIST OR ELIST I/O
	JRST	DATA0		;NO, GO TO THE DATA ROUTINE
	HRLZ	G2,DAT.TP(P4)	;[247] SET ARRAY SIZE
	CAIE	T5,TP%DOR	;[247] DOUBLE PRECISION
	CAIN	T5,TP%COM	;[247] OR COMPLEX?
	ASH	G2,1		;[247] YES - DOUBLE THE ARRAY SIZE
	HRRI	G2,(G1)		;[247] BUILD A IOWD WORD - SIZE,,ARRAY
	TLNE	P2,FT.EXT	;[247] EXTENDED LIST
	TLNN	P2,FT.SLT	;[247] EXTENDED SLIST
	SKIPA	G1,-1(L)	;[247] LOCATE INCREMENT
	JRST	SLIST0		;[247] USE PREVIOUS INCREMENT
	JSP	P1,EFCTV1	;[247] LOCATE INCREMENT
	MOVSI	T2,740		;[247] IMMEDIATE MODE
	TDNE	T2,-1(L)	;[247] CONSTANT?
	JSP	P1,RELOC%	;[247] NO - LOAD ACTUAL VALUE
	TRNN	G1,400000	;CHECK FOR A NEGATIVE INCREMENT
				;IF THE INCREMENT IS <0 WE GET A FREE
				;CARRY IN BIT 17. THEREFORE DO NOT ADD
				;IN THE DECREMENT CONSTANT 1. THE HARDWARE
				;DOES IT FREE.
	HRLI	G1,1		;ADD IN A 1 FOR THE DECREMENT CONSTANT
				;ON A POSITIVE OR ZERO INCREMENT
	MOVEM	G1,DAT.TP+1(P4)	;[247] SAVE THE INCREMENT
SLIST0:	MOVE	G1,DAT.TP+1(P4)	;[247] RESTORE THE INCREMENT
	EXCH	G1,G2		;[247] EXCHANGE THE ITEM COUNT AND INCREMENT
	CAIE	T5,TP%COM	;[275] DOUBLE WORD
	CAIN	T5,TP%DOR	;[275] TRANSFER
	ASH	G2,1		;[275] YES - DOUBLE INCREMENT
	TLNE	P2,FT.EXT	;[275] EXTENDED LIST
	JRST	SLIST1		;[275] YES - LINK NEW VARIABLE
	SKIPE	T2,1(L)		;[275] LOOK AHEAD ON ARGBLK
	TLNE	T2,777000	;[275] EXTENDED LIST?
	JRST	SLIST3		;[275] POST PROCESS SLIST ARGUMENT
SLIST1:	MOVEI	T0,3		;[275] NEED A 3 WORD BLOCK
	PUSH	P,T5		;[247] REMEMBER ARG TYPE
	PUSHJ	P,GMEM%%	;[247] ALLOCATE THE BLOCK
	DMOVEM	G1,0(T1)	;[247] STORE THE INFORMATION
	POP	P,2(T1)		;[247] STORE THE ARGTYPE
	TLON	P2,FT.EXT	;[275] FIRST LINK?
	JRST	[HRLM	T1,LST.TP(P4)	;[275] REMEMBER LIST ORIGIN
		 JRST	SLIST2]		;[275] CONTINUE
	MOVE	T5,LST.TP(P4)	;[275] LOAD LIST POINTER
	MOVEI	T2,-1(T1)	;[341] GET ADDRESS OF LINK
	HRRM	T2,-1(T5)	;[341] CREATE FORWARD LINK
SLIST2:	HRRM	T1,LST.TP(P4)	;[275] REMEMBER CURRENT LIST ELEMENT
	HLLZS	-1(T1)		;[275] CLEAR LINK
	SKIPE	T2,1(L)		;[275] ANOTHER LINK
	TLNE	T2,777000	;[275] ANOTHER LINK
	JRST	ELISTC		;[275] NO - START UP ELIST
	TLNE	P2,FT.ELT	;[275] EXTENDED ELIST?
	HRRI	L,1(L)		;[275] YES - PUSH ARGBLK POINTER
	AOJA	L,DATA%		;[275] REPEAT FOR NEXT ITEM

;POST PROCESSING FOR DOUBLE WORD ARGUMENTS

SLIST3:	CAIE	T5,TP%COM	;[275] COMPLEX
	CAIN	T5,TP%DOR	;[275] OR DOUBLE PRECISION
	CAIA			;[275] YES
	JRST	DATA2		;[275] NO
	CAME	G2,[2,,2]	;[275] SLISTABLE
	JRST	SLIST1		;[275] NO - GENERATE ELIST
	CAIN	T5,TP%DOR	;[275] FORMATTED
	TLNN	P3,IO.FMT	;[275] DOUBLE PRECISION
	JRST	DATA4		;[275] NO - CHANGE INCR TO 1,,1
	JRST	DATA2		;[275] YES - LEAVE INCR AS 2,,2

SLISTX:				;ENTRY FOR THE NEXT ITEM FROM SLIST
	MOVE	G1,DAT.TP+1(P4)	;GET THE INCREMENT
	ADDB	G1,DAT.TP(P4)	;GET THE NEXT ADDRESS IN G1/DAT.TP
	JUMPL	G1,(P1)		;YES, RETURN TO FORMAT STATEMENT
	TLZ	P2,FT.SLT	;CLEAR SLIST FLAG
	TLNN	P2,FT.EXT	;[256] EXTENDED IN PROGRESS?
	AOJA	L,IOLST1	;END OF SLIST GET NEXT ARG

ELISTX:	MOVEM	P1,IOL.P1(P4)	;[247] SAVE RETURN ADR
	MOVE	T1,LST.TP(P4)	;[247] LOCATE CURRENT ITEM
	MOVE	G1,1(T1)	;[247] LOAD THE INCREMENT
	ADDB	G1,0(T1)	;[247] GET THE NEXT ADDRESS READY
	HRRZ	T2,-1(T1)	;[247] FIND NEXT ELEMENT
	SKIPE	T2		;[341] SKIP IF END OF CHAIN
	AOJA	T2,ELISTG	;[341] GO ON NEXT ITEM
	JUMPL	G1,ELISTB	;[247] ANOTHER ROUND
	TLZ	P2,FT.SLT!FT.ELT!FT.EXT
	HLRZ	T1,LST.TP(P4)	;[247] LOCATE LIST
	PUSHJ	P,PMEM%%	;[247] RETURN THE CORE
	AOJA	L,IOLST1	;[247] DONE WITH ELIST

;DATA INPUT/OUTPUT LIST ROUTINE

ELISTC:	TLZ	P2,FT.SLT!FT.ELT;[275] CLEAR SLIST AND ELIST FLAGS
ELISTB:	HLRZ	T2,LST.TP(P4)	;[247] START AT BEGINNING OF LIST
ELISTG:	HRRM	T2,LST.TP(P4)	;[247] RESET POINTER
	MOVE	T5,2(T2)	;[247] LOAD ARG TYPE
	HRRO	G1,0(T2)	;[247] LOAD ADDRESS
	CAIN	T5,TP%DOR	;[247] DOUBLE WORD
	SKIPA	G2,[2,,2]	;[247] FILL IN INCREMENT
	SKIPA	G2,[1,,1]	;[247] FILL IN INCREMENT
	HRLI	G1,-2		;[247] TWO WORD ARGUMENT
DATA0:	CAIN	T5,TP%COM	;IS THE VARIABLE COMPLEX
	JRST	DATA1		;YES, ALWAYS "SLIST"
	CAIN	T5,TP%DOR	;IS VARIABLE DOUBLE REAL
	TLNE	P3,IO.FMT	;AND FORMATED
				;OR SINGLE PRECISION
	JRST	DATA3		;YES, EXIT I/O PROCESSIN ROUTINE
DATA1:	HRLI	G1,-2		;BUILD AN SLIST CONTROL WORD
DATA4:	MOVE	G2,[1,,1]	;[275] SET INCR TO 1,,1
DATA2:	TLO	P2,FT.SLT	;SET THE SLIST FLAG
DATA3:	DMOVEM	G1,DAT.TP(P4)	;SAVE THE SLIST CONTROL WORDS
	MOVEM	T5,DAT.TP+2(P4)	;SAVE THE VARIABLE TYPE FOR G FORMAT
	MOVE	P1,IOL.P1(P4)	;GET THE RETURN ADDRESS
	JRST	(P1)		;RETURN TO THE CALLER

;RELOC% - CONVERT IMMEDIATE MODE CONSTANT TO VALUE

RELOC%:	TRNN	G1,-20		;[247] IN AC SAVE AREA
	ADDI	G1,ACC.SV(P4)	;[247] YES, RELOCATE
	HRRZ	G1,0(G1)	;[276] LOAD VALUE
	JRST	0(P1)		;[247] RETURN VALUE
	SUBTTL FIN INPUT/OUTPUT LIST TERMINATION ROUTINE
	SIXBIT	/FIN./		;NAME FOR TRACE
FIN%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	SKIPN	P3,IOL.P3(P4)	;GET THE SYSTEM AC'S
	POPJ	P,		;NO, I/O IN PROCESS (RETURN)
	MOVE	P2,IOL.P2(P4)	;GET THE OTHER AC
	DMOVE	G3,IOL.G3(P4)	;RELOAD THE SYSTEM G REG'S (G3,G4)

FIN%%:			;ENTRY FROM THE IO LIST ROUTINE (FIN IMPLIED)

	TLO	P2,FT.FIN	;SET THE FIN FLAG FOR ENDLN.
	TLNN	P3,IO.FMT	;IS THIS FORMATED I/O
	JRST	FINBIN		;NO, BINARY I/O
	TLNE	P2,FT.LSD	;LIST DIRECTED I/O
	JRST	FINF1		;YES, SKIP THE FORMAT STATEMENT CLEAN UP
	MOVE	T1,FST.DY(P4)	;PICK UP THE FORMAT STATMENT POINTER
	HRRZI	T1,-1(T1)	;GET THE POINTER TO THE ENCODED FMT STACK
	SKIPGE	(T1)		;CHECK FOR DELETION OF ENCODED STACK
	PUSHJ	P,PMEM%%		;YES, DEALLOCATE THE ENCODED STACK
	TLNE	P3,IO.EDC	;ENCODE/DECODE REQUEST
	JRST	FINXI1		;EXIT ON ENCODE/DECODE
FINF1:	PUSHJ	P,ENDLN.	;FINISH UP THIS LINE
	TLZ	P3,IO.STR	;CLEAT THE STRING BIT
	JUMPO	FINXIT		;JUMP ON OUTPUT
	MOVEM	P3,RER.SV(P4)	;SAVE THE REREAD DEVICE
	TLNE	P3,IO.TTA	;[307] USER TERMINAL?
	TLZ	P3,IO.EOF	;[307] YES-CLEAR EFFECT OF CONTROL-Z
FINXIT:	PUSHJ	P,UPDASC	;[330] UPDATE ASSOCIATE VARIABLE
FINXI0:	PUSHJ	P,UPDCHN	;[240] UPDATE THE CHANNEL TABLE
FINXI1:	SETZM	IOL.P3(P4)	;CLEAR THE I/O REGISTER
	SKIPE	T1,ALT.PC(P4)	;[225] END OR ERR RETURN
	MOVEM	T1,USR.PC(P4)	;[225] YES - SET ALTERNATE RETURN
	SETZM	ALT.PC(P4)	;[225] CLEAR ALT RETURN PC
	POPJ	P,		;RETURN TO THE USER


UPDASC:	TLNN	P3,IO.EDC	;[330] ENCODE/DECODE IN PROGRESS
	TLNN	P3,IO.RAN	;[330] OR NOT RANDOM ACCESS
	POPJ	P,		;[330] YES - RETURN
	SKIPE	T1,DD.ASC(P3)	;[330] IS THERE AN ASSOCIATE VARIABLE
	AOS	(T1)		;[330] YES UPDATE IT
	AOS	DD.LIM(P3)	;[330] UPDATE RECORD NUMBER
	POPJ	P,		;[330] RETURN
FINBIN:	TLNE	P3,IO.NON	;NON-STANDARD I/O
	JRST	FINNON		;DO NON-STANDARD FIN
	JUMPI	FINBI1		;JUMP ON INPUT
	SKIPN	DD.LOG(P3)	;CHECK FOR FIXED LENGTH RECORD
	JRST	.+5		;NO, JUMP
	SETZ	T0,		;CLEAR THE OUTPUT WORD
	MOVEI	P1,.+1		;SET UP A RETURN FROM OBYTE.
	TLNN	P3,IO.EOL	;AT END OF LINE
	AOJA	G4,OBYTE.	;NO, OUTPUT A PADDING WORD
IFN CHKSUM,<
	JSP	P1,CHKSM.	;DO A FOLDED CHECK SUM ON G3
	TLO	G4,(T1)		;INSERT IN THE CONTROL WORD
>
	SKIPN	DD.LOG(P3)	;NO TYPE CONTROL WORD FOR FIXED LENGTH
	MOVEM	G4,(P2)		;INSERT THE LSCW IN THE BUFFER
IFN CHKSUM,<
	XORM	G4,POS.TB+1(P4)	;ACCUMULATE THE TOTAL RECORD CHECK SUM
	MOVE	G3,POS.TB+1(P4)	;GET THE TOTAL CHECK SUM
	JSP	P1,CHKSM.	;COMPUTE THE RECORD CHECK SUM
>
	MOVSI	T0,(3B8)	;SET UP THE END OF RECORD LSCW
	HRR	T0,POS.TB+2(P4)	;GET THE TOTAL RECORD COUNT (WORDS)
	ADDI	T0,1(G4)	;SET WORD COUNT TO PREVIOUS RECORD OF BOF
IFN CHKSUM,<
	TLO	T0,(T1)		;INSERT THE RECORD CHECKSUM
>
	TLZ	P3,IO.EOL	;CLEAR END OF LINE FLAG
	JSP	P1,OBYTE.	;OUTPUT THE TERMINING LSCW
	PJRST	FINXIT		;RETURN
FINBI1:	TLZE	P3,IO.EOL	;END OF LOGICAL RECORD
	JRST	FINXIT		;YES, EXIT(NEXT RECORD READ LATER)
IFN FORSE,<
	TLNN	P2,FT.FSE	;PROCESSING FORSE RECORD
	JRST	FINFS1		;NO, GO TO FOROTS
	SETZM	DD.HRI+2(P3)	;CLEAR THE ITEM COUNT
	MOVE	T1,DD.HRI(P3)	;GET THE ADDRESS OF THE BUFFER
	HRRZ	T0,2(T1)	;GET THE FORSE CONTROL WORD
	JUMPN	T0,FINXIT	;POSTIONED AT NEXT RECORD
	PUSHJ	P,IBLOK.	;NO GET THE NEXT INPUT BLOCK
	JRST	.-4		;CHECK THIS RECORD
FINFS1:>

	JUMPE	G4,FINBI4	;IS THE CURRENT SEGMENT DEPLEATED
FINBI2:	JSP	P1,IBYTE.	;NO, GET THE NEXT WORD
IFN CHKSUM,<
	XOR	G3,T0		;ACCUMULATE THE CHECKSUM
>
FINBI3:	SOJG	G4,FINBI2	;CONTINUE THIS SEGMENT
FINBI4:	PUSHJ	P,LSCWR2	;READ ANOTHER LSCW TYPE 2
	JRST	FINBI1		;EXIT, "LSCWR2" CLEANS UP THE RECORD
	AOJA	G4,FINBI3	;CONTINUE SCANNING TYPE 2 FOUND
				;PROTECT AGAINST A NULL SEGMENT BY ADDING 1
FINNON:				;NON-STANDARD FIN ROUTINE
	LDB	T1,[POINT 4,DD.BLK(P3),13];GET THE MODE
	CAIE	T1,MOD.DU	;DUMP MODE
	JRST	FINXIT		;NO, EXIT
	JUMPI	.+2		;SKIP IF INPUT
	PUSHJ	P,OBLOK.	;DUMP THE OUTPUT BLOCK
	JUMPO	.+2		;SKIP IF OUTPUT
	PUSHJ	P,IBLOK.	;READ THE INPUT BLOCK
	MOVE	T1,DD.HRI(P3)	;GET THE I/O LIST ADDRESS
	PUSHJ	P,PMEM%%	;PLACE BACK IN THE HEAP
	JRST	FINXIT		;EXIT
	SUBTTL	FMTXXX ROUTINE TO INITIALIZE THE FORMAT SCANNER

	INTERNAL	O.PNTR,W.PNTR,D.PNTR	;[265]
	INTERNAL	O.MASK,W.MASK,D.MASK	;[266]

O.PNTR:	POINT	5,G4,4	;[265] BYTE POINTER TO THE OP CODE IN THE FS STACK
D.PNTR:	POINT	6,G4,10	;[265] BYTE POINTER TO THE D FIELD IN THE FS STACK
W.PNTR:	POINT	7,G4,17	;[265] BYTE POINTER TO THE W FIELD IN THE FS STACK
O.MASK==37B22		;[266] RIGHT HALF MASK FOR OPCODE FIELD
D.MASK==77B28		;[266] RIGHT HALF MASK FOR DECIMAL FIELD
W.MASK==177B35		;[266] RIGHT HALF MASK FOR WIDTH FIELD

FMTSRC:	SKIPN	G4,1(L)		;LIST DIRECT I/O
	PJRST	LSTDR%%##	;YES, PROCESS THE LIST DIRECTED I/O
IFN %V1,<
	JUMPG	L,FMTSR2	;JUMP IF OLD CALL SEQUENCE
>
	AOBJP	L,[ERROR (SYS,2,10)]	;ILLEGAL ARGUMENT BLOCK
	JSP	P1,EFCTV.	;[265] GET THE ADDRESS
	MOVEI	G4,(G1)		;SAVE THE FORMAT ADDRESS
	HLRZ	T1,(L)		;GET THE TYPE CODE
	ANDI	T1,(17B12)	;ISOLATE IT
	CAIE	T1,(<TP%LBL>B12);IS IT A LABEL FIELD
	TLO	G4,400000	;SET THE DECODE FLAG
	AOBJP	L,[ERROR (SYS,2,10)]	;ILLEGAL ARGUMENT BLOCK
	JSP	P1,EFCTV.	;[265] GET THE SIZE
	TLO	G4,(G1)		;SAVE THE SIZE IN THE LEFT HALT
FMTSR2:	SKIPGE	G1,G4		;STATEMENT NOT TO BE RETAINED
	JRST	FMTSR0		;DO NOT RETAIN THE ENCODED LIST
	MOVEI	G3,FMT.DY(P4)	;GET THE START OF THE ENCODED LIST
	HRRZ	T1,(G3)		;LOAD POSSIBLE FMT POINTER TO LIST
	JUMPE	T1,FMTSR0	;CHAIN DOES NOT EXIST
FMTSR3:	CAMN	G1,1(T1)	;SEARCH FOR A MATCHING ENCODED FMT
	JRST	[ADDI	T1,2		;STEP PAST THE CONTROL INFO.
		 HRRZM	T1,FST.DY(P4)	;STORE THE CURRENT ENCODED LIST
		 JRST	FSXXEQ]		;DISPATCH ON THE LIST
	HRRZ	G3,T1		;NO - STEP POINTER TO NEXT ENTRY
	HRRZ	T1,(T1)		;LOAD NEXT FMT POINTER IN LIST
	JUMPN	T1,FMTSR3	;IF NOT AT THE ENTRY, GET NEXT POINTER
FMTSR0:	HRRZI	G2,-1(G1)	;GET THE LOCATION OF THE FORMAT STAT.
	HRLI	G2,(POINT 7,0,34)	;BUILD AN ASCII BYTE POINTER
	MOVEM	G2,FBG.BP(P4)	;SAVE THE BYTE POINTER TOT THE FORMAT STATEMENT
	HLRZ	T0,G1		;FETCH THE SIZE OF THE FORMAT STATEMENT
	ANDI	T0,377777	;CLEAR THE ENCODING FLAG
	MOVEM	G2,FEN.BP(P4)	;STORE THE BEGINNING OF THE FMT
	ADDM	T0,FEN.BP(P4)	;UPDATE TO THE END OF THE FMT
	IMULI	T0,3		;[212] AT MOST ENCODING EXPANDS
	CAIN	T0,1*3		;[303] IF SIZE OF FORMAT IS 1 WORD THEN
	ADDI	T0,1		;[303] ADD ONE MORE WORD
	ADDI	T0,2		;[212] FORMAT BY 2.5
	PUSHJ	P,GMEM%%	;GET MEMORY FOR THE ENCODING
	MOVEI	T1,-1(T1)	;SET THE POINTER TO THE LINK WORD
	JUMPL	G1,FMTSR1	;DO NOT LINK UNWANTED ENCODED BLOCKS
	HRRZ	T2,FMT.DY(P4)	;LOAD THE START OF THE LIST
	HRRM	T1,FMT.DY(P4)	;STORE THIS LIST FIRST
	HRRM	T2,(T1)		;LINK THE REST OF THE LIST
FMTSR1:	SETCM	P2,(T1)		;GET THE STACK SIZE
	HRRI	P2,(T1)		;AND THE ADDRESS
	ADD	P2,[XWD 2,2]	;SKIP THE CONTROL INFORMATION
	MOVEM	G1,1(T1)	;STORE THE FORMAT STATEMENT ADDRESS
	HRRZM	P2,FST.DY(P4)	;SAVE THE ENCODED LIST ADDRESS
	MOVSI	G1,1		;SET INITIAL LEFT PAREN POINTER
	MOVEM	G1,LPN.BP(P4)	;SAVE THE INITIAL LEFT PAREN POINTER
	SETZB	G1,G3		;CLEAR THE PAREN COUNTERS
;	JRST	FMTINE		;CONVERT ASCII FORMAT TO ENCODED LIST
	SUBTTL FMTXXX JUMP TABLES FOR THE FORMAT SCANNER
FMTINE:	SETZB	G4,T5		;ZERO THE FORMAT DESCRIPTOR WORD
FMTRIN:	SETZ	T1,		;ZERO THE DIGIT COUNTER
FMTIN:	ILDB	T2,G2		;NEXT FORMAT CHARACTER
	CAIN	T2,11		;CHECK FOR A <TAB>
	JRST	FMTIN		;IGNORE ALL TABS AS DESCRIPTORS
	TRZ	T2,100		;CLEAR THE HIGH ORDER BIT OF THE ASCII
	TRC	T2,40		;CONVERT THE ASCII TO SIXBIT
	MOVE	T3,T2		;SAVE THE CHARACTER IN B
	IDIVI	T3,6		;SET UP FOR A TABLE INDEX
	LDB	T3,FMTPTR(T4)	;LOAD TABLE INDEX
	HRRZ	T4,FMTDIS(T3)	;LOAD DISPATCH ADDRESS
	JRST	(T4)		;GO TO THE ROUTINE
FMTPTR:	REPEAT 6,<POINT 6,FMTDIR(T3),35-<.-FMTPTR>*6> ;INDEX POINTER
FMTDIR:
;				 %,  $, #, ", !,SPACE
	BYTE	(6)		EE,%DL,EE,EE,EE,%S

;				 +, *, ) , ( , ', &
	BYTE	(6)		%S,EE,%RP,%LP,%Q,EE

;				 1, 0, /, ., -, ,,
	BYTE	(6)		%N,%N,%Z,%W,%M,%C

;				 7, 6, 5, 4, 3, 2
	BYTE	(6)		%N,%N,%N,%N,%N,%N

;				 =, <, ;, :, 9, 8
	BYTE	(6)		EE,EE,EE,EE,%N,%N

;				 C, B, A, @, ?, >
	BYTE	(6)		EE,%B,%A,EE,EE,EE

;				 I, H, G, F, E, D
	BYTE	(6)		%I,%H,%G,%F,%E,%D

;				 O, N, M, L, K, J
	BYTE	(6)		%O,EE,EE,%L,EE,EE

;				 U, T, S, R, Q, P
	BYTE	(6)		EE,%T,EE,%R,EE,%P

;				 [, Z, Y, X, W, V
	BYTE	(6)		EE,EE,EE,%X,EE,EE

;				       _, ^, ], \
	BYTE	(6)		EE,EE,EE,EE,EE,EE

FMTDIS:
	PHASE	0		;SET TABLE ORGIN TO 0
EE:!	XWD	0,FMTERR	; ; ILLEGAL CHARACTER IN FORMAT STATEMENT
%B:!	XWD	FSXI,FMTERR	;I; INTEGER I/O(DEFAULT FOR UNDEFINED)
%L:!	XWD	FSXL,FMTOPS	;L; LOGICAL VARIABLE I/O
%I:!	XWD	FSXI,FMTOPS	;I; INTEGER VARIABLE
%A:!	XWD	FSXA,FMTOPS	;A; ALPHA I/O
%F:!	XWD	FSXF,FMTOPS	;F; FLOATING POINT I/O
%E:!	XWD	FSXE,FMTOPS	;E; POWERS OF 10 FLOATING POINT I/O
%O:!	XWD	FSXO,FMTOPS	;O; OCTAL I/O
%G:!	XWD	FSXG,FMTOPS	;G; VARIABLE OUTPUT FORMAT I/O
%D:!	XWD	FSXD,FMTOPS	;D; DOUBLE PRECISION FLOATING POINT I/O
%R:!	XWD	FSXR,FMTOPS	;R; ALPHA RIGHT JUSTIFIED
%DAT:!				;   THE ABOVE DESCRIPTORS REQUIRE DATA
%T:!	XWD	FSXT,FMTT	;T; TABBING TO COLUMNS
%Z:!	XWD	FSXZ,FMTZ	;/; END OF LINE
%DL:!	XWD	FSXDL,FMTDL	;$; C-R CONTROL FUNCTION
%IC:!				;   FOLLOWING DESCRIPTOR DO NOT HAVE AN
				;   INTERATION COUNT IN THE RIGHT HALF
%LP:!	XWD	FSXLRP,FMTLP	;(; LEFT PAREN GROUP START
%RP:!	XWD	FSXRP,FMTRP	;); RIGHT PAREN GROUP END
%X:!	XWD	FSXX,FMTX	;X; SPACING OF COLUMNS
%H:!	XWD	FSXH,FMTH	;H; HOLLERITH STRING I/O
%Q:!	XWD	FSXQ,FMTQ	;'; QUOTE STRING I/O
%P:!	XWD	FSXP,FMTP	;P; FLOATING POINT SCALLING
%V:!	XWD	0,FMTV		; ; DYNAMIC VARIABLE
				;   FOLLOWING DESCRIPTORS DO NOT
				;   GENERATE FS STACK CODES.
%S:!	XWD	0,FMTIN		;+; SPACE OF PLUS IGNORE
%M:!	XWD	0,FMTM		;-; NEGATIVE SCALE FACTOR
%N:!	XWD	0,FMTN		;0-9; ASCII DIGITS
%W:!	XWD	0,FMTW		;.; SEPERATE W AND D FIELD FOR FLOATING 
%C:!	XWD	0,FMTC		;,; BASIC FIELD SEPERATOR
	DEPHASE			;RETURN TO RELOCATABLE ADDRESSING
FMTERR:	HRLS	G1		;REMOVE ( FROM STACK
	SUB	P,G1		;ADJUST STACK POINTER
	ERROR	(DAT,1,5,)	;ILLEGAL CHARACTER IN FORMAT
	SUBTTL FMTXXX CONVERSION ROUNTINES (FS STACK _ ASCII FORMAT)
;CHARACTER IS A DIGIT		0,1,2,3,4,5,6,7,8,9
FMTN:	IMULI	T1,12		;MULT SUMS BY 10
	ADDI	T1,-20(T2)	;CONVERT SIXBIT TO BINAY AND ADD
	JRST	FMTIN		;RETURN TO FORMAT SCAN

;CHARACTER IS A  P		P
FMTP:	TLZE	T5,FT.SCL	;NEGATIVE SCALING FACTOR
	MOVNS	T1		;YES, NEGATE

;CHARACTER IS A	X
FMTX:	MOVEI	G4,(T1)		;SET SCALING FACTOR IN E OR SPACE COUNT
	DPB	T3,O.PNTR	;[265] SET OP CODE IN E
;	JRST	FMTC		;PUSH FS ON THE STACK

;CHARACTER IS A COMMA		,
FMTC:	JSP	P1,FMTPSH	;PUSH DOWN FS IF THERE IS A OP CODE
	JRST	FMTINE		;RETURN TO FORMAT SCAN

;CHARACTER IS A LEFT PAREN	(
FMTLP:	HRLI	T1,1(P2)	;SAVE ABS LOC OF LEFT PAREN ON STACK
	PUSH	P,T1		;SAVE ON SYS STACK FOR RIGHT PAREN
	CAIGE	G3,1(G1)	;HAS NESTING DEPTH INCREASED
	MOVEI	G3,1(G1)	;YES, SAVE THE NEW DEPTH
	AOJA	G1,FMTRIN	;UPDATE () COUNT AND RETURN

;CHARACTER IS A RIGHT PAREN	)
FMTRP:	JUMPE	G1,FMTERR	;[212] NO INITIAL LEFT PAREN
	JSP	P1,FMTPSH	;PUSH DOWN FS STACK IF NECESSARY
	POP	P,G4		;PICK UP LEFT PAREN POINTER AND GROUP
	HLRZ	T4,G4		;LOAD THE ABS LOC OF LEFT PAREN
	SUB	T4,FST.DY(P4)	;CALCUATE THE REL POSITION IN THE FS STACK
	HRL	G4,T4		;BUILD THE RIGHT PAREN STACK WORD
	CAIN	G1,2		;LEVEL 1 PAREN ? COUNTING FROM 1
	MOVEM	G4,LPN.BP(P4)	;LEVEL 1 PAREN SAVE FOR AUTO REPEAT
	SOJLE	G1,FSXEE	;EXIT IF A LEVEL 0 RIGHT PAREN
	DPB	T3,O.PNTR	;[265] INSERT RIGHT PAREN OP CODE
	TRNE	G4,777776	;IS THERE A REPEAT COUNT
	PUSH	P2,G4		;YES SAVE THIS POINTER
	JRST	FMTINE		;RETURN TO FORMAT SCAN

;CHARACTER IS A SLASH		/
FMTZ:

;CHARACTER IS A DOLLAR SIGN	$
FMTDL:	JSP	P1,FMTPSH	;PUSH DOWN FS STACK
	MOVEI	G4,1		;SET THE INTERATION COUNT
	DPB	T3,O.PNTR	;[265] STORE THE OP CODE
	JRST	FMTC		;SIMULATE A FOLLOWING COMMA

;CHARACTER IS A TEE		T
FMTT:	MOVSI	T0,400000	;SET UP A T FLAG
	IORM	T0,@FST.DY(P4)	;SET THE FLAG FOR A LINE BUFFER
	TLO	T5,FT.TXX	;SET T SEEN IN FORMAT

;CHARACTER IS A BASIC FIELD DESCRIPTOR	A,B,D,E,F,G,I,L,O
FMTOPS:	TLNE	G4,O.MASK	;[272] UNBOUND FORMAT ELEMENT?
	JSP	P1,FMTPSH	;[272] YES - PUSH FORMAT STACK
	SKIPN	G4,T1		;IS THE REPEAT COUNT SUPPLIED
	MOVEI	G4,1		;NO, DEFAULT TO 1
	DPB	T3,O.PNTR	;[265] SAVE OPCODE IN E
	JRST	FMTRIN		;RETURN TO FORMAT SCAN

;CHARACTER IS A MINUS		-
FMTM:	TLOA	T5,FT.SCL	;SET NEGATIVE SCALE FACTOR FLAG

;CHARACTER IS A PERIOD		.
FMTW:	DPB	T1,W.PNTR	;[265] PLACE THE W FIELD IN E
	JRST	FMTRIN		;RETURN TO FORMAT SCAN

;CHARACTER IS A SINGLE QUOTE	'
FMTQ:	JSP	P1,FMTPSH	;[271] STORE ELEMENT IF ANY
	HRRZ	T1,FEN.BP(P4)	;LOAD THE END OF FORMAT POINT TO CHECK
	SUBI	T1,-1(G2)	;SUB THE CURRENT POSITION
	IMULI	T1,5		;CONVERT TO CHARACTER
;	JRST	FMTH		;CONTINUE AS A HOLLERITH SCAN

;CHARACTER IS A H		H
FMTH:	PUSH	P2,G2		;SAVE THE BYTE POINTER TO THE FORMAT STRING
FMTH1:	SOJL	T1,FMTH3		;IS THIS THE END
	ILDB	T2,G2		;NO, GET THE NEXT HOLLERITH CHARACTER
	CAIN	T2,"'"		;IS THE CHARACTER A SINGLE QUOTE
	CAIE	T3,%Q		;AND IN SINGLE QUOTE MODE
FMTH2:	AOJA	G4,FMTH1		;NO, COUNT THE CHARACTER
	MOVEM	G2,1(P)		;YES, SAVE POINTER ON THE STACK
	ILDB	T2,G2		;GET LOOK AHEAD CHARACTER
	CAIN	T2,"'"		;DOUBLE SQUOTE CHARACTERS
	AOJA	G4,FMTH2		;YES COUNT BOTH SQUOTES
	MOVE	G2,1(P)		;NO, RELOAD THE CORRECT POINTER
FMTH3:	HRLZS	G4		;PUT THE CHARACTER COUNT IN LEFT
	DPB	T3,O.PNTR	;[265] DEPOSITE THE OP CODE
	HLRZ	T1,(P2)		;GET THE BYTE POINTER TO THE STRING
	IDIVI	T1,70000	;COMPUTE THE CHARACTER POSITIION
	DPB	T1,[POINT 3,G4,7] ;SAVE THE RELATIVE CHARACTER POSITION
	HLLM	G4,(P2)		;PUT THE STRING INFO ON THE STACK
	JRST	FMTINE		;RETURN TO THE FORMAT SCAN

;CHARACTER IS A DYNAMIC POINTER	V
FMTV:	PUSH	P2,(G2)		;SAVE THE ADDRESS OF THE VARIABLE
	HRLI	G2,10700		;FORCE THE POINTER TO THE NEXT WORD
	JRST	FMTRIN		;RETURN TO THE FORMAT SCAN

;ROUTINE TO PUSH THE FS STACK 	;ENTER VIA JSP P1,FMTPSH
FMTPSH:	TLNN	G4,760000	;IS THERE AN OP IN E
	JRST	(P1)		;NO RETURN
	TLZE	T5,FT.TXX	;IS THIS A T FORMAT
	JRST	[TSO	G4,T1	;SET THE COLUMN COUNT IN W AND D
		JRST	FMTPS3]	;STORE THE DESCRIPTOR
	TLNE	G4,177		;IS THERE A W FIELD
	JRST	FMTPS1		;YES, STORE THE D FIELD
	CAILE	T1,^D127	;GREATER THE 127
	SETO	T1,		;SET 127
	DPB	T1,W.PNTR	;[265] STORE THE W FIELD
	JRST	FMTPS3		;CONTINUE
FMTPS1:	CAILE	T1,^D63		;W>63
	SETO	T1,		;SET TO 63
	DPB	T1,D.PNTR	;[265] STORE THE D FIELD
FMTPS3:	HLRZ	T1,(P)		;PICK UP POINTER TO LAST LEFT PAREN
	MOVEM	G4,1(P2)	;ASSUME DESCRIPTOR IS NOT BOUNDED
	XOR	G4,(P2)		;COMPARE OPS,W,E ARE EQUAL
	CAIE	T1,1(P2)	;IS E BOUNDED BY A LEFT PAREN
	TLNE	G4,-1		;ARE THE DESCRIPTORS EQUAL
	AOBJN	P2,.+3		;NO, UPDATE THE STACK POINTER
	HRRZ	G4,1(P2)	;YES, UPDATE THE INTERATION COUNT
	ADDM	G4,(P2)		;INCREMENT THE IC FOR NEW E
	SETZB	G4,T1		;CLEAR THE OPS,W,E AND IC FIELDS
	JRST	(P1)		;RETURN

;ROUTINE TO CLEAN UP THE ENCODED FORMAT LIST AND RETURN TO THE USER

FSXEE:	MOVE	T1,LPN.BP(P4)	;SETUP LAST LEFT PAREN FOR RESCAN
	TLO	T1,(<%LP>B4)	;SET THE OP CODE
	PUSH	P2,T1		;PUT ON THE STACK
	HLRZ	T1,FMT.DY(P4)	;GET THE PAREN STACK ADDRESS
	JUMPE	T1,FSXEE1	;PAREN STACK NOT DEFINED
	HLRZ	T2,-1(T1)	;GET THE SIZE OF THE PAREN STACK
	LSH	G3,1		;TWO WORDS/PAREN DEPTH
	CAIG	G3,-4(T2)	;MUST THE STACK BE EXPANDED
	JRST	FSXEE2		;NO, THE STACK IS OK
	PUSHJ	P,PMEM%%	;YES, REMOVE THE OLD STACK
FSXEE1:	MOVEI	T0,4(G3)	;GET THE NEW STACK SIZE
	PUSHJ	P,GMEM%%	;ALLOCATE A NEW STACK
	HRLM	T1,FMT.DY(P4)	;SAVE THE STACK ADDRESS
FSXEE2:	MOVE	T1,FST.DY(P4)	;GET THE ENCODED LIST ADDRESS BACK
	SKIPGE	-1(T1)		;IS THE FMT ENCODED LIST TO BE RETAINED
	JRST	FSXXEQ		;NO, DON'T RELEASE UNUSED ARRAY SPACE
	ADD	P2,[XWD 2,2]	;BUILD A NEW CONTROL WORD
	HLLZ	T2,P2		;GET THE REMAINING SIZE
	JUMPGE	T2,FSXXEQ	;[370] NO UNUSED CORE SPACE
	ADDM	T2,-2(T1)	;REDUCE THE CORE BLOCK COUNT BY UNUSED SPACE
	MOVNS	T2		;MAKE POSITIVE
	HLLZM	T2,-1(P2)	;BUILD A NEW CORE BLOCK POINTER
	HRRZI	T1,(P2)	;MAKE A POINTER TO THE FREE BLOCK
	PUSHJ	P,PMEM%%	;DELETE THE UNUSED CORE SPACE
FSXXEQ:	HLRZ	T1,FMT.DY(P4)	;GET THE PAREN STACK POINTER ADDRESS
	ADDI	T1,2		;STEP PAST THE POINTER AND BOTTOM
	SETZM	-1(T1)		;SET A ZERO ON THE BOTTOM OF THE STACK
	MOVEM	T1,-2(T1)	;INITIALIZE THE POINTER
	HRRZ	P2,FST.DY(P4)	;SET THE ENCODE LIST POINTER
	AOSL	(P2)		;[223] UPDATE THE ACTIVITY COUNT
				;[223] AND CHECK THE SIGN FOR THE STRING FLAG
	AOJA	P2,FSXNXT	;[223] NO STRING
	TLNN	P3,IO.EDC	;[223] ENCODE/DECODE?
	PUSHJ	P,SETSTR	;NO - SET UP A STRING BUFFER
	ADDI	P2,1		;POINT TO THE FIRST DESCRIPTOR
;	JRST	FSXNXT		;GO DISPATCH ON ENCODED FORMAT
	SUBTTL FSXXXX	ROUTINES TO DISPATCH OF THE ENCODED STACK
FSXNXT:	MOVE	G4,(P2)		;LOAD E WITH STACK ELEMENT FOR DISPAT
	HRRZM	G4,LPN.BP(P4)	;SAVE A POSSIBLE INTERATION COUNT
FSXREP:	LDB	T3,O.PNTR	;[265] GET OP CODE FOR TABLE DISPATCH
	HLRZ	G3,FMTDIS(T3)	;GET DISPATCH ADDRESS
	TLZ	P2,FT.ETP!FT.GTP!FT.PRC!FT.LSD ;YES, CLEAR THE CONVERSION TYPE
	CAIL	T3,%DAT		;IS DATA REQUIRED FOR THIS FIELD DISC.
	JRST	(G3)		;NO, GO TO CONVERSION ROUTINE
	TLZN	P2,FT.LRP	;LAST RIGHT PAREN SEEN
	JSP	P1,IOLS%%	;NO, GET THE NEXT I/O LIST ITEM
	PUSHJ	P,(G3)		;NO, DO THE CONVERSION
FSXRTN:	SOSG	LPN.BP(P4)	;REDUCE INTERATION COUNT
	AOJA	P2,FSXNXT	;GET NEXT DESCRIPTOR FROM FS
	MOVE	G4,(P2)		;RELOAD THE SAVE DESCRIPTOR
	JRST	FSXREP		;REEXECUTE THE SAME DESCRIPTOR

FSXRP:				;ROUTINE TO PROCESS THE RIGHT PAREN
	HLRZ	G3,FMT.DY(P4)	;GET THE PAREN STACK POINTER
	MOVE	P1,(G3)		;GET THE CURRENT STACK ADDRESS
	HRRZ	T4,-1(P1)	;LOAD THE FS POINTER OF THE LAST PAREN
	CAIE	T4,(P2)		;IS THIS THE SAME PAREN OR NESTING
	JRST	FSXRP2		;NESTING OF PARENS
FSXRP0:	SOSLE	(P1)		;SAME PAREN REDUCE THE INTERATION COUNT
	JRST	FSXRP1		;NOT THE END OF INTERATION
	SUB	P1,[XWD 2,2]	;END OF INTERATION, REMOVE POINTERS
	MOVEM	P1,(G3)		;SAVE THE NEW STACK POINTER
	AOJA	P2,FSXNXT	;RETURN FOR NEXT DESCRIPTOR
FSXRP1:	HLR	P2,-1(P1)	;MODIFY FS TO LEFT PAREN POSITION RELAT.
FSXRP3:	TRZ	P2,760000
	ADD	P2,FST.DY(P4)	;ADJUST RELATIVE TO THE ENCODED LIST ORGIN
	JRST	FSXNXT	;RETURN
FSXRP2:	PUSH	P1,G4		;PUT THE RELATIVE POSITION ON THE STACK
	HRRM	P2,(P1)		;PUT THE FS POSITION ON THE STACK
	PUSH	P1,LPN.BP(P4)	;PUT THE INTERATION COUNT ON
	MOVEM	P1,(G3)		;SAVE THE NEW PAREN STACK POINTER
	JRST	FSXRP0		;PROCESS THIS LEFT PAREN

FSXLRP:				;LAST RIGHT PAREN FOR AUTO REPEAT
	TLNN	P2,FT.LST	;I/O LIST SEEN
	JRST	FSXLR1		;GO SEEN IF A LIST EXISTS
	JSP	P1,IOLS%%	;SEE IF ANOTHER LIST ITEM
	TLO	P2,FT.LRP	;YES, SET THE LAST RIGHT PAREN FLAG
	PUSHJ	P,NXTLN.	;MORE IO LIST AND LAST RIGHT PAREN
				; GET THE NEXT RECORD
	PUSHJ	P,UPDASC	;[330] GO UPDATE ASSOCIATE VARIABLE
	HLR	P2,G4		;GET THE REL POS OF THE LAST LEVEL 2 PAREN
	JRST	FSXRP3		;GET THE NEXT DESCRITPOR

FSXLR1:				;LAST RIGHT PAREN WITH OUT AN I/O LIST
	JSP	P1,IOLS%%	;SEE IF A VARIABLE EXISTS IN THE LIST
	ERROR	(DAT,6,2,FIN%%);INPUT OUTPUT WITHOUT DATA CONVERSION
	SUBTTL FSXXXX CONVERSION ROUTINE NOT REQUIRING UUO DATA
FSXX:	MOVEI	T4,OBYTE.	;LOAD OUTPUT ROUTINE ADDRESS
	SKIPL	P3		;INPUT OR OUTPUT
	MOVEI	T4,IBYTE.	;INPUT, LOAD INPUT IO ADDRESS
	HRLI	G4,0		;CLEAR THE OPS FIELD RT= COUNT
	MOVEI	T0," "		;LOAD A BLANK
	JSP	P1,(T4)		;OUTPUT A SPACE OR SKIP AN INPUT COLUMN
	SOJG	G4,.-2		;CONTINUE UNTIL COUNT =0
	AOJA	P2,FSXNXT	;RETURN FOR NEST DESCRIPTOR

FSXP:	HRREM	G4,SCL.SV(P4)	;SAVE THE CURRENT SCALE FACTOR
	AOJA	P2,FSXNXT	;RETURN FOR NEXT DESCRIPTOR

FSXH:				;H CONVERSION
FSXQ:				;SINGLE QUTOE CONVERSION
	HLRZ	T4,(P2)		;LOAD THE NUMBER OF CHARACTER IN THE STR
	ANDI	T4,1777		;CLEAR OUT THE JUNK
	JUMPE	T4,FSXIQ3	;EXIT ON ZERO LENGTH
	LDB	T1,[POINT 3,G4,7];LOAD THE RELATIVE CHARACTER POSITION
	IMULI	T1,70000	;COMPUTE THE NUMBER OF BITS TO THE RIGHT
	HRLI	G4,10700(T1)	;INSERT THE BYTE SIZE AND POSITION
	JUMPO	FSXOQ1		;JUMP ON OUTPUT
FSXIQ1:	JSP	P1,IBYTE.	;GET THE NEXT INPUT BYTE
	CAIE	T3,%Q		;SINGLE QUOTE MODE
	JRST	FSXIQ2		;NO, H CONVERSION
	CAIN	0,"'"		;SINGLE QUOTE MODG4, QUOTE IN INPUT
	MOVEI	0,42;"		;YES, REPLACE WITH DOUBLE QUOTE
FSXIQ2:	IDPB	0,G4		;PUT THE BYTE IN THE FORMAT STATEMENT
	SOJG	T4,FSXIQ1	;REDUCE COUNT AND RETURN FOR NEXT CHAR
FSXIQ3:	AOJA	P2,FSXNXT	;RETURN FOR NEXT DESCRIPTOR
FSXOQ1:	ILDB	0,G4		;LOAD NEXT OUTPUT CHARACTER
	CAIE	T3,%Q		;SINGLE QUOTE MODE
	JRST	FSXOQ2		;NO, H CONVERSION
	CAIE	0,"'"		;SINGLE QUOTE IN OUTPUT
	JRST	FSXOQ2		;NO, CONTINUE
	IBP	G4		;YES, IGNORE
	SUBI	T4,1		;REDUCE COUNT FOR SINGLE QUOTE
FSXOQ2:	JSP	P1,OBYTE.	;OUTPUT THIS STRING CHARACTER
	SOJG	T4,FSXOQ1	;REDUCE COUNT AND CONTINUE
	AOJA	P2,FSXNXT	;RETURN FOR NEXT FIELD DESCRIPTOR

FSXZ:				;END OF LINE ROUTINE
	PUSHJ	P,NXTLN.		;DO END OF LINE STUFF
	PUSHJ	P,UPDASC	;[330] GO UPDATE ASSOCIATE VARIABLE
	SOSLE	LPN.BP(P4)	;COUNT THE INTERATIONS
	JRST	FSXZ		;DO IT AGAIN
	AOJA	P2,FSXNXT	;GET THE NEXT DESCRIPTOR

FSXDL:	JUMPI	FSXDL1		;IGNORE ThE $ ON ONPUT
	TLNE	P3,IO.TTA!IO.TTY;IS THIS THE USER'S TTY
	TLOA	P2,FT.DOL	;[223] YES, TTY DOINT OUTPUT
FSXTC:	TLO	P3,IO.EOL	;[223] SET END OF STRING
FSXDL1:	AOJA	P2,FSXNXT	;GET THE NEXT DESCRIPTOR
	SUBTTL	FSXT T FORMAT ROUTINE
FSXT:
	MOVEI	G3,DD.HRI(P3)	;INPUT HEADER
	JUMPI	FSXT1		;JUMP ON INPUT
	MOVEI	G3,DD.HRO(P3)	;OUTPUT HEADER
FSXT1:	TLNE	P3,IO.EDC	;[223] ENCODE/DECODE?
	JRST	FSXTA		;[223] YES - USE USER STRING
	SETZ	T4,		;FIND THE CURRENT CHUNK NUMBER
	HLRZ	T5,(G3)		;GET THE STARTING CHUNK NUMBER
	HRRZ	T1,(G3)		;AND THE CURRENT CHUNK ADDRESS
FSXT2:	CAIN	T5,(T1)		;IS THIS THE CHUNK
	AOJA	T4,FSXT3	;YES, COUNT AND EXIT
	HRRZ	T5,(T5)		;GET THE NEXT CHUNK ADDRESS
	JUMPE	T5,FSXT3	;END OF CHUNKS EXIT
	AOJA	T4,FSXT2	;COUNT THE CHUNK AND CONTINUE
FSXTA:	SKIPA	T4,POS.TB(P4)	;[223] LOAD LINE WIDTH
FSXT3:	IMULI	T4,STRCNK*5	;#CHUNKS TIMES CHARACTER/CHUNK
	SUB	T4,2(G3)	;MINUS THE UNUSED CHARACTER POS.
	HLRZS	G4		;GET THE T FORMAT COLUMN NUMBER
	ANDI	G4,17777	;ONLY THIRTEEN BITS
	SOSGE	T3,G4		;MAKE RELATIVE TO COLUMN 0
	SETZB	T3,G4		;DON'T ALLOW NEGATIVE COLUMNS
	SUBI	G4,(T4)		;COMPUTE THE RELATIVE OFFSET FROM HERE
	JUMPE	G4,FSXT9	;ON THE COLUMN EXIT
	JUMPL	G4,FSXT6	;GOING BACKWARDS
	JUMPI	FSXX		;GO FORWARD ON INPUT USE X FORMAT
FSXT4:	TLNE	P3,IO.EDC	;[223] ENCODE/DECODE?
	JRST	FSXTC		;[223] END OF STRING SET EOL
	SKIPG	DD.HRO+2(P3)	;STEP THRU THE OUTPUT BUFFER CHUNKS
	PUSHJ	P,OBLOKS	;END OF CHUNK GET THE NEXT CHUNK
	SOS	DD.HRO+2(P3)	;REDUCE THE ITEM COUNT
	ILDB	T0,DD.HRO+1(P3)	;LOOK AT THIS CHARACTER
	JUMPE	T0,FSXT5	;NULL BLANK WITH X FORMAT
	SOJG	G4,FSXT4	;NON-NULL CONTINUE LOOKING
FSXT5:	MOVEI	T0," "		;GET A BLANK
	DPB	T0,DD.HRO+1(P3)	;REPLACE THE NULL
	SOJG	G4,FSXX		;CONTINUE WITH FORMAT X OUTPUT
	AOJA	P2,FSXNXT	;RETURN FOR THE NEXT DESCRIPTOR
FSXT6:	TLZ	P3,IO.EOL	;[273] CLEAR END OF LINE
	TLNE	P3,IO.EDC	;[223] ENCODE/DECODE?
	JRST	[MOVE	T2,0(G3)	;[223] LOAD BUFFER ADDRESS
		 MOVEI	T4,0(T3)	;[223] COPY NEW POSITION
		 MOVE	T3,POS.TB(P4)	;[223] LOAD STRING LENGTH
		 AOJA	T2,FSXTB]	;[223] POINT TO BUFFER
	IDIVI	T3,STRCNK*5	;CONVERT TO CHUNKS AND CHARACTERS
	HLRZ	T1,(G3)		;GET THE STARING CHUNK
	JUMPE	T3,[MOVEI  T2,3(T1)	;FIRST CHUNK SKIP SAVE AREA
		    JRST   FSXT7]	;CONTINUE
	HRRZ	T1,(T1)		;STEP ALONG THE CHUNK LIST
	SOJG	T3,.-1		;LOOK FOR THIS CHUNK
	MOVEI	T2,0(T1)	;GET THE CHUNK ADDRESS
FSXT7:	MOVEI	T3,STRCNK*5	;[223] NON ENCODE/DECODE
FSXTB:	HRLI	T2,(POINT 7,0,34);[223] SET UP AN ASCII BYTE POINTER
	SUBI	T3,(T4)		;REMOVE THE CHARACTERS USED
	IDIVI	T4,5		;FIND THE NUMBER OF WORDS AND CHAR.
	ADDI	T2,(T4)		;UPDATE THE BYTE POINTER BY WORDS
	JUMPE	T5,FSXT8	;ANY EXTRA BYTE
	IBP	T2		;YES, UPDATE THE BYTE POINTER
	SOJG	T5,.-1		;CONTINUE
FSXT8:	TLNN	P3,IO.EDC	;[223] ENCODE/DECODE?
	HRRM	T1,(G3)		;NO - STORE THE CURRENT CHUNK ADDRESS
	DMOVEM	T2,1(G3)	;STORE THE BYTE POINTER AND ITEM COUNT

FSXT9:	AOJA	P2,FSXNXT	;GET THE NEXT DESCRIPTOR
	SUBTTL FSXXXX CONVERSION ROUNTINES REQUIRING MEMORY DATA

FSXR=RIGHT%##			;ALPHA CONVERSION RIGHT JUSTIFIED
FSXA=ALPHA%##			;ALPHA CONVERSION LEFT JUSTIFIED
FSXI=INTEG%##			;INTEGER CONVERSION
FSXL=LOGIC%##			;LOGICAL VARIABLE CONVERSION
FSXO=OCTAL%##			;OCTAL CONVERSION

FSXG:	TLO	P2,FT.GTP	;GET G FORMAT FLAG
	MOVE	T5,DAT.TP+2(P4)	;GET THE VARIABLE TYPE
	CAIGE	T5,TP%DOR	;IS VARIABLE DOUBLE PREC. OR COMPLEX
	JRST	[HLRZ	G3,FMTDIS+1(T5)	;NO, GET DISPATCH ADDRESS
		PJRST	(G3)]	;GO TO CONVERSION ROUTINE
	CAIN	T5,TP%DOR	;DOUBLE PREC REAL=D, COMPLEX =F
FSXD:	TLO	P2,FT.PRC	;SET DOUBLE PRECISION FLAG
FSXF:	TLZA	P2,FT.ETP	;CLEAR E TYPE CONVERSION AND 
FSXE:	TLO	P2,FT.ETP	;SET E TYPE CONVERSION
	PJRST	REAL%##		;GO TO FLOATING POINT CONVERSION
	SUBTTL MTOP MAGE TAPE SIMULATION ROUTINES
;				;FLAGS DEFINED IN P2 FOR MAG TAPE SIM.
MG.CLS==040000	;FILE MUST BE CLOSED
MG.ILL==020000	;FUNCTION IS ILLEGAL FOR AN OUTPUT DEVICE
MG.SIM==010000	;FUNCTION CAN BE SIMULATED FOR DEVICES OTHER THAN MAG TAPE


	SIXBIT	/MTOP./		;NAME FOR TRACE
MTOP%:				;ENTRY POINT
	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
IFN %V1,<
	HLRZ	G1,(L)		;CHECK FOR A VERSION 1 CALL
	LSH	G1,-5		;SHIFT OUT THE INDEX AND INDIRECT
	TRZN	G1,777760	;OLD CALL
>
	MOVE	G1,3(L)		;NO, F10 CALL GET THE FUNCTION CODE
	JSP	P1,EFCTV1	;EVALUATE IT
	CAILE	G1,MAG.SZ	;IS THE FUNCTION DEFINED
	ERROR	(SYS,3,1,CPOPJ)	;NO,IGNORE THE REQUEST
	MOVEI	P2,(G1)		;MOVE THE FUNCTION CODE
	HLL	P2,MAGTBL(G1)	;GET THE FLAGS
	JSP	P1,SRCFLU	;IS THE UNIT DEFINED
	JRST	[MOVEI T1,(G2)	;GET THE FLU
		PUSH	P,G2		;SAVE THE FLU
		PUSHJ	P,GETDV.	;GET THE ASSOCATED DEVICE
		POP	P,G2		;RESTORE THE FLU
		TRNN	P2,777774	;REWIND/UNLOAD/BACKSPACE
		JRST	[TLNE	G3,DV.AVL	;IS THE DEVICE AVAILABLE
			TLNE	G3,DV.DTA!DV.MTA;DECTAPE/MAGTAPE
			JRST	MTOPEN
			POPJ	P,]		;NO, RETURN
		JRST	MTOPEN]	;OPEN THE DEVICE
	TLNE	P3,IO.RAN	;RANDOM ACCESS FILE
	PJRST	RELE%%		;RELEASE THE RANDOM FILE
MTOP%%:	MOVE	G3,DD.STS(P3)	;GET THE DEVICE STATUS
	TLNN	P3,IO.OPN	;CHECK FOR OPEN FILE
	JRST	[PUSHJ	P,SETDIR	;SET UP THE DIRECTORY
		JRST	MTOP1]		;CONTINUE
	JUMPI	MTOP1		;JUMP ON INPUT
	TLNE	P2,MG.ILL	;IS THIS AN ILLEGAL OUTPUT FUNCTION
	ERROR	(DAT,10,10,CPOPJ)	;ILLEGAL FUNCTION
MTOP1:	MOVE	P2,MAGTBL(P2)	;GET THE FLAGS
	TLNE	P2,MG.CLS	;MUST FILE BE CLOSED FIRST
	PUSHJ	P,CLOS%F	;[175] YES CLOSE THE FILE
	TLNN	G3,DV.MTA	;IS THIS A MAG TAPE DEVICE
	TLNE	P2,MG.SIM	;NO, IS PROCESSING REQUIRED FOR OTHER DEVICES
	PJRST	(P2)		;YES, DO THE SPECIAL PROCESSING
	PJRST	FINXIT		;RETURN TO THE USER

MTOPEN:	PUSHJ	P,SETOPN
	JRST	MTOP%%
MAGTBL:
	XWD	MG.CLS!MG.SIM!IO.SIN!IO.SOU,MAGREW	;REWIND
	XWD	MG.CLS!MG.SIM!IO.SIN!IO.SOU,MAGUNL	;REWIND/UNLOAD
	XWD	MG.SIM!       IO.SIN,MAGBSR	;BACKSPACE RECORD
	XWD		       IO.SIN,MAGBSF	;[361] BACKSPACE FILE
	XWD	IO.INO!MG.CLS!IO.SOU,MAGEOF	;ENDFILE
	XWD	MG.ILL!MG.SIM!IO.SIN,MAGSKR	;SKIP RECORD
	XWD	IO.INO!       IO.SOU,MAGBLK	;WRITE 3" BLANK TAPE
	XWD	MG.SIM!MG.ILL!IO.SIN,MAGSKF	;SKIP FILE
MAG.SZ==.-MAGTBL			;FUNCTION TABLE SIZE
	SUBTTL MTOP  DEVICE DEPENDENT FUNCTIONS
MAGEOF:	JUMPO	FINXIT		;JUMP ON OUTPUT
	PUSHJ	P,SETRWR	;INPUT, SWITCH TO OUTPUT
	PUSHJ	P,CLOSO.	;CLOSE THE FILE
	PJRST	FINXIT		;RETURN TO USER
MAGBSR:				;OPEN OUTPUT TO BACKSPACE
	TLNN	G3,DV.MTA!DV.DSK;MUST BE DSK OR MAGTAPE
	ERROR	(DAT,14,10)	;CALL THE ERROR ROUTINE
	JUMPI	MAGBSI		;JUMP ON INPUT
	PUSH	P,DD.HRO+2(P3)	;SAVE THE ITEM COUNT
	PUSH	P,DD.HRO+1(P3)	;SAVE THE BYTE POINTER
	PUSH	P,DD.HRO(P3)	;SAVE THE BUFFER ADDRESS
	PUSH	P,DD.BLK(P3)	;SAVE THE BLOCK NUMBER
	PUSHJ	P,OBLOK.	;DUMP THE BLOCK
	PUSHJ	P,CLOSO.	;CLOSE THE FILE
	MOVSI	P2,IO.SIN	;SET UP INPUT MODE
	PUSHJ	P,SETDIR	;OPEN THE FILE
	POP	P,DD.BLK(P3)	;RESTORE THE BLOCK NUMBER
	POP	P,DD.HRI(P3)	;SETUP THE INPUT BUFFER
	MOVNI	T3,1		;BACKSPACE TWO RECORDS
	PUSHJ	P,BSRMTB	;GET THE BLOCK JUST WRITTEN
MAGBS1:	POP	P,DD.HRI+1(P3)	;RESTORE THE BYTE POINTER
	POP	P,DD.HRI+2(P3)	;AND ITEM COUNT
BSREAD:				;RE-READ ENTRY POINT TO BACK UP
MAGBSI:
	SKIPG	T5,DD.HRI(P3)	;GET THE CURRENT BUFFER ADDRESS
	JRST	FINXIT		;NO, INPUT
	MOVE	T4,DD.HRI+1(P3)	;GET THE BYTE POINTER
	CAIGE	T5,-1(T4)	;AT THE BEGINNING OF THE BUFFER
	JRST	.+3		;NO
	PUSHJ	P,BSRAS3	;BACKSPACE A BLOCK
	JRST	FINXI0		;BEGINNING OF FILE
	MOVE	T1,(T4)		;GET THE LAST WORD OF THE RECORD
	HLRZ	T2,T1		;GET THE LEFT HALF
	LSH	T2,-^D9		;SHIFT OUT THE CHECK SUM (IF BINARY)
	TLZ	P3,IO.FMT!IO.EOL!IO.EOF	;CLEAR THE FORMAT FLAG
	CAIN	T2,3		;TYPE 3 BINARY CONTROL WORD
	JRST	BSRBIN		;YES, BINARY RECORD TO BACKSPACE
	TLNE	T4,3300		;ASCI BYTE POINTER
	JRST	BSRAS0		;YES, AN ASCII BYTE POINTER
	HRLI	T4,(POINT 7,0,34);SET UP AN ASCII BYTE POINTER
	MOVEI	T1,5		;FIVE CHARACTER/WORD
	IMULM	T1,DD.HRI+2(P3)	;CONVERT CHARACTERS TO WORDS
	MOVEM	T4,DD.HRI+1(P3)	;STORE THE BYTE POINTER
	JRST	BSRAS0		;CONT TNE FIRST CHARACTER
BSRASC:	MOVSI	T3,470000	;CONSTANT TO DECREMENT THE BYTE POINTER
	ADD	T4,T3		;STEP BACK ONE CHARACTER
	TLCE	T4,400000	;CHECK FOR OVERFLOW
	JRST	BSRAS0		;SAME WORD
	ADD	T4,[XWD 347777,-1] ;YES , MOVE BACK ONE WORD
	CAIGE	T5,-1(T4)	;BEGINNING OF THE BUFFER
	JRST	BSRAS1		;NO
	PUSHJ	P,BSRAS3	;YES, READ A NEW BLOCK
	JRST	BSRAS2		;BEGINNING OF FILE
BSRAS1:	HLRZ	T1,(T4)		;GET THAT WORD'S LEFT HALF
	LSH	T1,-^D9		;IT COULD BE THE END OF A 
	CAIN	T1,3		;BINARY RECORD LSCW=3
	JRST	BSRAS2		;YES, BINARY EXIT
BSRAS0:	AOS	DD.HRI+2(P3)	;INCREMENT THE ITEM COUNT
	LDB	T0,T4		;GET THIS CHARACTER
	CAIN	T0,12		;A LINE FEED
	TLON	P3,IO.FMT	;FIRST LF SET FMT FLAG
	JRST	BSRASC		;NO, TRY AGAIN
	SOS	DD.HRI+2(P3)	;DONT'T COUNT THE DELIMITER
BSRAS2:	TLO	P3,IO.FMT	;SET THE FORMAT FLAG ON
	MOVEM	T4,DD.HRI+1(P3)	;SAVE THE BYTE POINTER
	JRST	FINXI0		;RETURN
BSRAS3:	TLNE	G3,DV.DSK!DV.MTA;REREAD OF DEVICE
	PUSHJ	P,BSRPHY	;NO, DO A PHYSICAL BACKSPACE
	POPJ	P,		;BEGINNING OF FILE
	MOVE	T5,DD.HRI(P3)	;GET THE RING HEADER
	HRRZ	T4,DD.BUF(P3)	;GET THE BUFFER SIZE
	ADDI	T4,-2(T5)	;POINT THE END OF THE BUFFER
	HRLI	T4,(POINT 7,0,34);SET UP THE BYTE POINTER
	SETZM	DD.HRI+2(P3)	;CLEAR THE ITEM COUNT(BUFF FULL)
	AOS	(P)		;SKIP RETURN
	POPJ	P,		;RETURN
BSRBIN:				;BACKSPACE ONE BINARY RECORD
	ANDI	T4,-1		;CLEAR THE BYTEM POINTER
	SUBI	T4,(T5)	;GET THE WORDS IN THE BUFFER
	SUBI	T4,(T1)		;MINUS THE WORD IN THE RECORD
	JUMPG	T4,BSRBI2	;START OF RECORD IN THE BUFFER
	HRRZ	T2,DD.BUF(P3)	;GET THE BUFFER SIZE
	MOVE	T3,T4		;GET THE WORD TO GO BACK
	IDIVI	T3,-3(T2)	;CONVERT TO BUFFERS
	ADDI	T4,-3(T2)	;WORD FROM THE START OF THE BUFFER
	PUSHJ	P,BSRPH1	;DO A BACKSPACE T3 = THE COUNT
	JFCL			;BOF RETURN (NOT USED)
BSRBI2:	HRRZ	T3,DD.BUF(P3)	;GET THE BUFFER SIZE
	SUBI	T3,2(T4)	;GET THE WORDS LEFT IN THE BUFFER
	MOVEM	T3,DD.HRI+2(P3)	;SAVE THE ITEM COUNT
	ADD	T4,DD.HRI(P3)	;GET THE BUFFER ADDRESS
	HRLI	T4,(POINT 36,0,35);GET A BINARY BYTE POINTER
	MOVEM	T4,DD.HRI+1(P3)	;STORE THE BYTE POINTER
	HLRZ	T1,1(T4)	;GET THE CONTOL WORD
	LSH	T1,-^D9		;SHIFT OUT THE CHECK SUM
	CAIE	T1,1		;TYPE 1 CONTROL WORD
	ERROR	(DAT,2,7,)	;ILLEGAL LSCW
	JRST	FINXI0		;RETURN
	SUBTTL	BSRXXX PHYSICAL BACKSPACE ROUTINES
BSRPHY:			;READ IN A PHYSICAL BLOCK
	SETZ	T3,		;BACKSPACE ONLY ONE BLOCK
BSRPH1:	HRRZ	T1,DD.BLK(P3)	;GET THE CURRENT BLOCK COUNT
	SOJLE	T1,CPOPJ	;BOF
	ADD	T1,T3		;NUMBER OF BLOCK TO GO BACK PLUS 1
	AOS	(P)		;SET SKIP RETURN (NOT BOF)
	HRRM	T1,DD.BLK(P3)	;STORE THE BLOCK NUMBER
BSRMTB:	TLNN	G3,DV.MTA	;IS THIS A MAG TAPE
	PJRST	RBLOK.		;READ A RANDOME ACCESS BLOCK
	JSP	P1,WAIT.	;STOP THE MAGTAPE FROM BUFFERING
	JSP	P1,BSRMTA	;BACK UP THE MAG TAPE
	SOS	DD.BLK(P3)	;RETARD THE BLOCK COUNT (IBLOCK. AOS ES)
	PJRST	IBLOK.		;READ THE RECORD IN
BSRMTA:	TLO	P3,IO.RNG	;SET RING CHANGE FLAG
	MOVSI	T0,400000	;SET UP A USE BIT MASK
	MOVE	T1,DD.HRI(P3)	;GET THE RING HEADER (BUFFER ADDRESS)
	IORM	T0,DD.HRI(P3)	;CHANGING RINGS FLAG
	SKIPL	(T1)		;IS THE USE BIT SET
	JRST	BSRMT1		;NO, THRU THE RING BUFFER
	ANDCAM	T0,(T1)		;YES CLEAR THE USE BIT
	MOVE	T1,(T1)		;GET THE NEXT BUFFER ADDRESS
	SOJA	T3,.-4		;COUNT THIS BUFFER
BSRMT1:	MOVE	T0,-1(T1)	;GET THE STATUS BITS
	SETZM	-1(T1)		;CLEAR THE STATUS (MTASRX) DOES NOT
	TLNE	T0,40		;IS END OF FILE SET ON LOOK AHEAD
	SUBI	T3,1		;YES, MUST BACK OVER EOF ALSO
	HLLZ	T0,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	IOR	T0,[MTAPE 0,7]	;SET UP A PHYSICAL BACKSPACE UUO
	XCT	T0		;BACKSPACE THE TAPE UNIT
	AOJLE	T3,.-1		;AGAIN
	ANDCMI	T0,-1		;SET UP A NO OP
	XCT	T0		;WAIT UNTIL DEVICE STOPS
	JRST	(P1)		;RETURN

MAGBSF:	MOVEI	T3,2		;[361] MAY BE THREE TIMES
	TLNE	P3,IO.INO	;[361] YES IF OUTPUT LAST
	PUSHJ	P,CLOS%F	;[361] CLOSE FILE FIRST
	TLNE	P3,IO.INO!IO.EOF ;[361] EOF FOUND BY USER
	JRST	MAGBF4		;[361] YES
	JSP	P1,WAIT.	;[361] BECAUSE WILL LOOK BUFFERS
	MOVE	T1,DD.HRI(P3)	;[361] CURRENT BUFFER
MAGBF1:	SKIPL	(T1)		;[361] END OF CHAIN
	JRST	MAGBF2		;[361] YES
	MOVE	T1,(T1)		;[361] NEXT BUFFER
	JRST	MAGBF1		;[361] CONTINUE
MAGBF2:	MOVE	T0,-1(T1)	;[361] THE STATUS
	SETZM	-1(T1)		;[361] CLEAR STATUS
	TLNE	T0,40		;[361] EOF SET
	ADDI	T3,1		;[361] YES , ONE MORE TIME
MAGBF4:	MOVEI	T1,17		;[361] GET THE BACKSPACE FILE FUNCTION
	PUSHJ	P,MAGXCT	;DO THE BACKSPACE OPERATION
	ANDCMI	T1,-1		;SET UP A WAIT
	XCT	T1		;WAIT
	SOJG	T3,MAGBF4	;[361] AGAIN
	HLLZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	IOR	T1,[STATZ 0,4000];CHECK FOR BEGINNING OF TAPE
	XCT	T1		;EXECUTE THE UUO
	JRST	MAGBF5		;[361] CLOSE FILE AND RETURN TO USER
	MOVEI	T1,16		;GET A MAGTAPE SKIP RECORD COMMAND
	PUSHJ	P,MAGXCT	;DO IT
MAGBF5:	PUSHJ	P,CLOSI.	;[361]
	PJRST	FINXIT		;RETURN TO THE USER

MAGSKR:	TLNN	P3,IO.OPN	;IS THE FILE OPEN
	PUSHJ	P,SETDIR	;NO, OPEN THE FILE
	JSP	P1,IPEEK.	;LOOK AT THE NEXT ITEM
	MOVE	T1,DD.HRI+1(P3)	;GET THEBYTE POINTER
	TLNN	T1,760000	;END OF A WORD
	SKIPA	T1,1(T1)	;YES, GET THE NEXT WORD
	MOVE	T1,(T1)		;NO, USED THIS WORD
MAGSK2:	TLNN	T1,774000	;IS THIS AN ASCII RECORD
	JRST	MAGSK3	;BINARY SKIP
	TLNN	P3,IO.FMT	;INITED IN ASCII
	PUSHJ	P,SETMOD	;NO, DO A MODE SWITCH
	TLNE	P3,IO.EOL	;AT END OF A LINE
	PUSHJ	P,NXTLNI	;YES, GET THE NEXT INPUT LINE
	PJRST	FINF1		;SCAN TO THE END OF LINE
MAGSK3:	TLNN	P3,IO.FMT	;[361] INITED IN BINARY MODE
	JRST	MAGSK4		;[361] YES, NO CHANGE
	SOS	DD.HRI+1(P3)	;[361] CORRECT ADDR
	AOS	DD.HRI+2(P3)	;[361] CORRECT COUNT
	PUSHJ	P,SETMOD	;[361] GO SET BINARY MODE
MAGSK4:	PUSHJ	P,BINIO		;[361] BINARY, GO TO BINARY I/O ROUTINE
	PJRST	FINBIN		;FINISH UP BINARY I/O

	SUBTTL MAGXXX MAG TAPE UTILITY ROUTINES
MAGBLK:	JRST	FINXIT		;RETURN TO THE USER

MAGSKF:	TLNN	G3,DV.DSK	;IS THIS A DSK TYPE DEVICE
	JRST	.+4		;NO
	HLLO	T1,DD.UNT(P3)	;[361] GET THE CHANNEL NUMBER
	TLO	T1,(USETI)	;A QUICK WAY TO EOF FOR DSK
	XCT	T1		;AT EOF NO GET A BLOCK TO SET EOF FLAG
	HLLZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T1,(IN)		;INPUT UUO
	XCT	T1		;READ A BLOCK
	AOSA	DD.BLK(P3)	;COUNT THIS BLOCK
	JRST	[HRRZ	T1,DD.HRI(P3)	;[361] CURRENT BUFFER
		 SETZM	-1(T1)		;[361] CLEAR STATUS
		 PUSHJ	P,CLOSI.	;[361] CLOSE FILE
		 PJRST	FINXIT]		;[361] RETURN TO USER
	JRST	.-3		;CONTINUE TO EOF OR ERROR


MAGUNL:	SKIPA	T1,[11]		;UNLOAD FUNCTION
MAGREW:	MOVEI	T1,1		;REWIND FUNCTION
	TLNN	G3,DV.MTA!DV.DTA;REWIND/UNLOAD LEGAL FOR MTA/DTA
	PJRST	FINXIT		;RETURN TO THE USER
	PUSHJ	P,MAGXCT	;XCT MAGTAPE OPERATION
	TRNN	T1,10		;[210] UNLOAD REQUEST?
	PUSHJ	P,MAGPAS	;[210] NO - WAIT FOR REQUEST
	PJRST	FINXIT		;RETURN TO USER


MAGPAS:	MOVEI	T1,0		;[210] SET UP WAIT REQUEST
MAGXCT:				;EXECUTE THE MAG TAPE FUNCTION
	HLL	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T1,(MTAPE)	;SET UP THE MTAPE UUO
	XCT	T1		;DO IT
	POPJ	P,		;RETURN
	SUBTTL CLOSE ROUTINE TO CLOSE THE FILE
	SIXBIT	/CLOSE./	;NAME FOR TRACE
CLOSE%:	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	JSP	P1,SRCFLU	;IS THE UNIT DEFINED
	POPJ	P,		;NO, RETURN
	TLNN	P3,IO.RAN!IO.RNG;[336][204] RANDOM ACCESS OR RING CHANGE
	JRST	CLOS%0		;[336] NO
	PUSHJ	P,CLOS%1	;YES CLOSE THE FILE FIRST
	MOVE	G3,DD.STS(P3)	;[336] GET DEV CHAR STATUS
	JSP	P1,LOOKU.	;[336] LOOKUP THE FILE AGAIN BECAUSE
				;[336] RENAME MAY FAIL
	  POPJ	P,		;[336] FILE HAS GONE FORGET IT
CLOS%0:	MOVEI	P2,(P3)		;[336] GET THE DD.BLK POINT FOR AN ARG SCAN
	PUSH	P,P3		;SAVE THE I/O REG
	PUSHJ	P,OPNARG	;USER CHANGED HIS MIND FIND OUT WHY
	POP	P,P3		;RESTORE THE I/O REG
	MOVE	G3,DD.STS(P3)	;GET THE DEV CHAR STATUS
	TLNN	G3,DV.DSK!DV.DTA;[204] DISK OR DECTAPE?
	JRST	CLOS%%		;[204] NO CLOSE VIA CLOSE UUO
	SETZM	DD.ALC(P3)	;CLEAR BLOCKS ALLOCATED
	JSP	P1,RENAM.	;CLOSE VIA RENAME UUO
	JFCL			;FORGET IT
	TLZA	P3,IO.OPN!IO.INO;SET THE FILE CLOSED
CLOS%%:	PUSHJ	P,CLOS%1	;CLOSE VIA CLOSE UUO
	MOVE	G3,DD.STS(P3)	;GET THE DEVICE CHARACTERISTICS
	LDB	G4,[POINT 4,DD.BLK(P3),17];GET THE DISPOSE INDEX
	CAIL	G4,DIS.SZ	;LEGAL ARGUMENT
	PJRST	CLOS%R		;[331] [240] GO RELEASE THE DEVICE
	CAIGE	G4,QUE.DP	;QMANGR REQUIRED
	PJRST	@DIS.DP(G4)	;NO, PROCESS THE DISPOSE ARGUMENT
IFE QUEUER,<
	PJRST	CLOS%R		;[331] [240] GO RELEASE THE DEVICE
>
IFN QUEUER,<
	PUSHJ	P,CLOS.Q	;[331] GO PROCESS THE QUEUE REQUEST
	PJRST	CLOS%R		;[331] AND GO RELEASE THE DEVICE
>

DIS.DP:				;/DISPOSE='STRING' DISPATCH LIST
	XWD	CLSSAV		;/DISPOSE=SAVE
	XWD	CLSDEL		;/DISPOSE=DELETE
	XWD	CLSREN		;/DISPOSE=RENAME
	SUBTTL CLOSE QUEUEING ROUTINES (CALL QMANGR VIA FORQUE)
CLSDEL:				;DELETE THE FILE
	SETZM	DD.NAM(P3)	;CLEAR THE FILE NAME
	TLNN	G3,DV.DTA!DV.DSK;[314] MUST BE A DISK OR DECTAPE
	PJRST	CLOS%R		;[331] NO, GO RELEASE THE DEVICE
	PUSH	P,.+2		;[314] IN CASE OF ERROR
	JSP	P1,RENAM.	;DELETE THE FILE
	  JFCL	.+2		;[314] IGORE IF FILE NOT FOUND
	POP	P,(P)		;[314] CLEAR JUNK OF STACK
	PJRST	CLOS%R		;[331] [240] NO,GO RELEASE THE DEVICE

IFN QUEUER,<
.GTNM1==31			;FIRST HALF OF USER'S NAME
.GTNM2==32			;LAST HALF OF USER'S NAME
CLOS.Q:
	TLNE	G3,DV.DSK	;MUST BE A DISK TO SPOOL
	JSP	P1,LOOKU.	;LOOKUP THE FILE AGAIN
	  POPJ	P,		;FILE IS GONE FORGET IT
	MOVEI	T0,Q.END	;GET THE ARGUMNET BLOCK SIZE
	PUSHJ	P,GMEM%%	;ALLOCATE
	MOVEI	P2,(T1)		;PUT THE POINTER IN A SAVE PLACE
	MOVE	T1,QUE.TB-QUE.DP(G4)	;GET THE QUEUE CODES
	HRRZM	T1,Q.OPR(P2)	;STORE THE QUEUE CODE
	HLLZM	T1,Q.DEV(P2)	;STORE THE DEVICE NAME
	MOVE	T1,[BYTE (9)Q.FF-Q.ZER-1,Q.FLEN(18)1];GET THE QUE SIZE
	MOVEM	T1,Q.LEN(P2)	;SAVE THE LENGTH CODES
	MOVE	T1,DD.SIZ(P3)	;GET THE NUMBER OF WORD IN THE FILE
	HRRM	T2,Q.OSIZ(P2)	;SAVE
	GETPPN	T1,		;GET THE USER'S PPN
	  JFCL			;
	MOVEM	T1,Q.PPN(P2)	;STORE
	MOVEI	T1,12		;STANDARD PRIORITY
	MOVEM	T1,Q.PRI(P2)	;STORE IT
	HRROI	T1,.GTNM1	;GET THE USER'S NAME
	HRROI	T2,.GTNM2	;PART 2
	GETTAB	T1,		;GET IT
	JRST	.+2		;NOT THERE
	GETTAB	T2,		;GET PART 2
	  SETZB	T1,T2		;NO USER NAME
	DMOVEM	T1,Q.USER(P2)	;STORE
	MOVE	T1,DD.SIZ(P3)	;GET THE FILE SIZE IN WORDS
	ADDI	T1,177+^D20B28	;ADD OFFSET AND ROUND TO BLOCKS
	LSH	T1,-^D7		;GET THE BLOCKS + OFFSET IN THE FILE
	HRLZM	T1,Q.OSIZ(P2)	;STORE THE FILE SIZE
	ADDI	T1,-11		;REMOVE OFFSET AND ROUND TO UNITS OF 8
	LSH	T1,-^D3		;FILE SIZE IN UNITS OF 8
	HRRM	T1,Q.OSIZ(P2)	;STORE
	MOVE	T1,DD.STR(P3)	;[240] GET THE FILE DEVICE NAME
	MOVEM	T1,Q.FSTR(P2)	;STORE
	MOVS	T1,DD.PPN(P3)	;PPN
	TRNN	T1,-1		;IS THERE AN SFD
	JUMPN	T1,.+3		;OR NULL
	MOVSM	T1,Q.FDIR(P2)	;STORE THE PPN
	JRST	.+3		;SKIP THE SFD STUFF
	HRRI	T1,Q.FDIR(P2)	;YES, SET UP A BLT POINTER
	BLT	T1,Q.FDIR+6(P2)	;MOVE THE DIRECTORY PATH
	MOVE	T1,DD.NAM(P3)	;GET THE FILE NAME
	MOVEM	T1,Q.FNAM(P2)	;STORE
	MOVEM	T1,Q.JOB(P2)	;USE THE FILE NAME AS A JOB NAME
	HLRZ	T1,DD.EXT(P3)	;GET THE EXTENSION
	HRLZM	T1,Q.FEXT(P2)	;STORE
	AOS	Q.FBIT(P2)	;STARTING POINT IN THE FILE
	CAIN	G4,DIS.LS	;[344] IF /DISPOSE=LIST
	SKIPA	T2,[1B5!1B20!2B29!1B35]	;[344] SET DISPOSE=RENAME
	MOVE	T2,[1B5!1B20!1B29!1B35]	;SET THE SPOOLER FLAGS
	LDB	T3,[POINT 4,DD.BLK(P3),13];GET THE FILE TYPE
	CAIN	T3,3		;SIXBIT COBOL STYLE
	TROA	T2,3B26		;YES, SET COBOL DATA TYPE
	CAIN	T1,(SIXBIT /DAT/) ;EXTENSION DAT  FORTRAN STYLE
	TLNE	P3,IO.CCC	;NAD CARRIAGLE CONTROL CHARACTERS
	TROA	T2,1B26		;YES, SET NORMAL ASCII
	IORI	T2,2B26		;FORTRAN DATA SET MODE
	MOVEM	T2,Q.FMOD(P2)	;STORE THE FILE MODE
	MOVEI	T1,(P2)		;SET THE ARG BLOCK FOR QMANGR
	HRLI	T1,Q.END	;SET UP THE PARAMETER AREA SIZE
	PUSH	P,.JBHRL##	;[346] SAVE HIGH SEGMENT LENGTH
	PUSHJ	P,FORQU%##	;CALL QMANGR VIA FORQUE
	POP	P,.JBHRL	;[346] RESTORE
	PUSHJ	P,PMEM%%	;[240] RETURN THE ARG BLOCK TO THE HEAP
	PJRST	UPDCHN		;[240] UPDATE CHANNEL TABLE

QUE.TB:				;TABLE OF QUEUE CODES
	XWD	'LPT',1B23!10B29!1B35	;[344] /DISPOSE=PRINT
	XWD	'PTP',1B23!10B29!1B35	;[344] /DISPOSE=PUNCH
	XWD	'LPT',1B23!10B29!1B35	;[344] /DISPOSE=LIST
	SUBTTL QMANGR ARG BLOCK DEFNS.
	LOC	0	;DEFINE QUEUE AREA (RELOCATABLE)
Q.ZER:!			;START OF QUEUE PARAMETER AREA
Q.MEM:!	BLOCK	1	;USED FOR CHARACTER TYPER
Q.OPR:!	BLOCK	1	;OPERATION CODE
Q.LEN:!	BLOCK	1	;LENGTHS IN AREA
Q.DEV:!	BLOCK	1	;DESTINATION DEVICE
Q.PPN:!	BLOCK	1	;PPN ORIGINATING REQUEST
Q.JOB:!	BLOCK	1	;JOB NAME
Q.SEQ:!	BLOCK	1	;JOB SEQUENCE NUMBER
Q.PRI:!	BLOCK	1	;EXTERNAL PRIORITY
Q.PDEV:!BLOCK	1	;PROCESSING DEVICE
Q.TIME:!BLOCK	1	;PROCESSING TIME OF DAY  (PPN MASK ON MODIFY)
Q.CREA:!BLOCK	1	;CREATION TIME  (JOB NAME MASK ON MODIFY)
Q.AFTR:!BLOCK	1	;AFTER PARAMETER
Q.DEAD:!BLOCK	1	;DEADLINE TIME
Q.CNO:!	BLOCK	1	;CHARGE NUMBER
Q.USER:!BLOCK	2	;USER'S NAME

Q.O:!			;START OF OUTPUT QUEUE AREA
Q.OFRM:!BLOCK	1	;FORMS REQUEST
Q.OSIZ:!BLOCK	1	;LIMIT WORD
Q.ONOT:!BLOCK	2	;ANNOTATION
Q.FF:!
Q.F:!			;DUPLICATED AREA FOR EACH REQUESTED FILE
Q.FSTR:!BLOCK	1	;FILE STRUCTURE
Q.FDIR:!BLOCK	6	;ORIGINAL DIRECTORY
Q.FNAM:!BLOCK	1	;ORIGINAL NAME
Q.FEXT:!BLOCK	1	;ORIGINAL EXTENSION
Q.FRNM:!BLOCK	1	;RENAMED FILE NAME (0 IF NOT)
Q.FBIT:!BLOCK	1	;BIT 0=PRESERVED BY QUEUE, REST=STARTING BIT
Q.FMOD:!BLOCK	1	;FILE SWITCHES
Q.FLEN==.-Q.F
Q.FRPT:!BLOCK	2	;/REPORT KEY
Q.FRPL==.-Q.F
Q.FDRM:!BLOCK	6	;DIRECTORY MASK
Q.FNMM:!BLOCK	1	;FILE NAME MASK
Q.FEXM:!BLOCK	1	;FILE EXT MASK
Q.FMDM:!BLOCK	1	;MODIFIER MASK
Q.FLNM==.-Q.F
Q.END:!
	RELOC
>;END IFN QUEUER,
CLOS%1:	TLNN	P3,IO.OPN	;[204] IS THE UNIT OPEN?
	POPJ	P,		;UNIT DEFINED BUT NOT OPEN RETURN
CLOS%F:	TLNN	P3,IO.RAN!IO.RNG;[175] RANDOM ACCESS OR RING CHANGE?
	JRST	CLOSB.		;[175] NO, NORMAL CLOSE WILL WORK
	TLNE	P3,IO.INO	;OUTPUT LAST
	SKIPG	DD.HRO(P3)	;YES, IS THE RING BUFFERS SET UP
	JRST	CLOS%2		;NO, OUTPUT RING OR INPUT
	PUSHJ	P,WBLOK.	;DUMP THE BLOCK
CLOS%2:	JSP	P1,WAIT.	;STOP THE DEVICE AFTER THE LAST BLOCK
	MOVSI	T0,400000	;SET UP A USE BIT
	IORM	T0,DD.HRO(P3)	;SET THE RING NOT IN USE
	IORM	T0,DD.HRI(P3)
	JRST	CLOSB.		;CLOSE THE FILE

CLOSO.::MOVEI	T1,2		;CLOSE OUTPUT
	JRST	CLOS..		;[204] COMMON ROUTINE
CLOSB.::TDZA	T1,T1		;CLOSE INPUT/OUTPUT
CLOSI.::MOVEI	T1,1		;CLOSE INPUT ONLY
CLOS..::TLZ	P3,IO.EOF	;[204] CLEAR EOF FLAG
	HLRZ	T2,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLNE	P3,IO.TTA	;[204] USER'S TTY?
	JRST	UPDCHN		;[240] YES - NOOP CLOSE
	TLO	T1,<(CLOSE)>(T2);OTHERWISE SET UP THE UUO
	XCT	T1		;CLOSE THE FILE
	TLZ	P3,IO.OPN	;[204] CLEAR THE OPEN BIT
	SETZM	DD.HRI+2(P3)	;CLEAR THE ITEM COUNTS
	SETZM	DD.HRO+2(P3)	;ETC
UPDCHN:	HLRZ	T1,DD.UNT(P3)	;[240] LOAD CHANNEL NUMBER
	LSH	T1,-5		;[240] POSITION THE CHANNEL NUMBER
	ADDI	T1,CHN.TB(P4)	;[240] POINT TO THE CHANNEL ENTRY
	MOVEM	P3,(T1)		;[240] UPDATE THE CHANNEL TABLE
	POPJ	P,		;EXIT

	SUBTTL RELEASE ROUTINE TO RELEASE A SOFTWARE CHANNEL AND DD.BLK

	SIXBIT	/RELEA./	;NAME FOR TRACE
RELEA%:				;ENTRY TO RELEASE A FORTRAN LOGICAL UNIT
	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
	JSP	P1,SRCFLU	;IS THE UNIT ASSIGNED
	POPJ	P,		;NO, RETURN UNIT IS RELEASED
RELE%%::TLNE	P3,IO.OPN	;[331] IS THE CHANNEL OPEN
	PJRST	CLOS%%		;[331] YES CLOSE AND RELEASE
CLOS%R:	SETZ	T0,		;[331] [204] CLEAR THE CHANNEL POINTER
	DPB	T0,FLU.BP(P4)	;[204] IN THE FLU TABLE
	TLNE	P3,IO.TTA	;[204] USER'S TELETYPE?
	POPJ	P,		;[204] YES RELEASE IS A NOOP
	HLLZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	TLO	T1,(RELEAS)	;SET UP THE RELEASE UUO
	XCT	T1		;RELEAE THE SOFTWARE CHANNEL
	HLRZ	T1,DD.UNT(P3)	;GET THE CHANNEL NUMBER
	LSH	T1,-5		;POSITION
	JSP	P1,PUTCHN	;DEALLOCATE THE CHANNEL
	HRRZ	T1,RER.SV(P4)	;[267] GET REREAD INFO
	CAIN	T1,(P3)		;[267] SAME AS RELEASED?
	SETZM	RER.SV(P4)	;[267] YES, CLEAR REREAD INFO
;				;ENTER HERE TO REMOVE A DDB IN P3
RELE%1:	SKIPE	T1,DD.RLS(P3)	;IS THERE A REELS ARRAY ASSIGNED
	PUSHJ	P,PMEM%%	;YES, DEALLOCATE THE REELS ARRAY
	SKIPN	T1,DD.PPN(P3)	;CHECK FOR A PPN
	JRST	RELE%2		;[204] NO, PPN
	TLNN	T1,-1		;IS THERE A SFD ARRAY
	PUSHJ	P,PMEM%%	;YES, DEALLOCATE THE SFD ARRAY
RELE%2:	HRRZI	T1,(P3)		;[204] GET THE DD.BLK POINTER
	PJRST	PMEM%%		;DEALLOCATE THE DD.BLK (RETURN)

CLSSAV==CLOS%R			;[240] [331] FILE IS SAVED BY DEFAULT
CLSREN==CLOS%R			;[240] [331] FILE ALREADY RENAMED AT CLOS%%-2
	SUBTTL	EXIT CLOSE OUT THE I/O CHANNEL AND EXIT VIA FORERR
	SIXBIT	/EXIT./		;NAME FOR TRACE
EXIT%::	PUSHJ	P,SAVE.		;SAVE THE USER'S ACS
EXIT%%:	MOVEI	P2,CHN.TB+1(P4)	;GET THE CHANNEL TABLE ADDRESS
	HRLI	P2,-17		;SCAN ONLY 15 CHANNELS
EXIT.1:	SETCM	P3,0(P2)	;[214] USER'S CHANNEL
	JUMPE	P3,EXIT.2	;[214] DON'T RELEASE USER CHANNELS
	SKIPE	P3,(P2)		;IS THIS CHANNEL DEFINED
	PUSHJ	P,RELE%%	;YES, RELEASE THE CHANNEL
EXIT.2:	AOBJN	P2,EXIT.1	;CONTINUE THRU ALL CHANNELS
	SKIPE	P3,CHN.TB+20(P4);GET THE TTY CHANNEL
	PUSHJ	P,OBLOK.	;DUMP THE LAST LINE
	ERROR	(SYS,1,0,0)	;EXIT VIA FORERR FOR MESSAGE
SUBTTL GMEM%% PMEM%% SMEM%% MEMORY MANAGEMENT ROUTINES

; ON ENTRY,
; IF T0 < 0, A DEFRAGMENTATION IS PERFORMED, AND THE MAXIMUM
;  CONTIGUOUS AREA RETURNED
; IF T0 = 0, T1 IS THE ADDRESS OF THE SECOND WORD OF A SPACE,
;  OR A CHAIN OF SPACES TO BE RETURNED TO THE INACTIVE HEAP CHAIN
;  (THE FIRST WORD IS THE CONTROL WORD DESCRIBED BELOW)
; IF T0 > 0, T0 IS THE NUMBER OF WORDS OF SPACE REQUIRED
;  IF CORE IS UNAVAILABLE, EXIT VIA FORER
;  IF CORE IS AVAILABLE, RETURN THE ADDRESS OF THE SECOND WORD
;  OF A SPACE ONE WORD GREATER THAN THE SPACE REQUIRED IN T1
;  (THE FIRST WORD IS THE CONTROL WORD DESCRIBED BELOW)

; THE INACTIVE HEAP CHAIN IS ADDRESSED BY FRE.DY, AND CONSISTS
; OF A CHAIN OF SPACES WHOSE FIRST WORD IS FORMATTED AS FOLLOWS:

;	LH: NUMBER OF WORDS IN SPACE (INCLUDING THIS ONE)
;	RH: POINTER TO NEXT SPACE (ZERO IF NONE)

	SIXBIT	/DECOR./	;NAME FOR TRACE
DECOR%:	PUSHJ	P,SAVE.		;SAVE THE USER'S AC'S
	JSP	P1,EFCTV.	;[265] GET THE ARGUMENT ADDRESS
	TRNN	G1,-20		;AC ARGUMENT
	ADDI	G1,ACC.SV(P4)	;YES, RELOCATE
	SKIPGE	T1,(G1)		;GET THE VALUE
	POPJ	P,		;NOT VALID
	PJRST	PMEM%%		;RELEASE THE CORE BLOCK

	SIXBIT	/ALCOR./	;NAME FOR TRACE
ALCOR%:	PUSHJ	P,SAVE.		;ENTRY FROM USER PROGRAMS
	JSP	P1,EFCTV.	;[265] GET THE ARGUMENT ADDRESS
	TRNN	G1,-20		;AC ARGUMENT
	ADDI	G1,ACC.SV(P4)	;YES, RELOCATE
	MOVE	T0,(G1)		;GET THE VALUE
ALCOR1:	PUSHJ	P,GMEM%%	;[351] GET THE CORE BLOCK
				;[351] SKIP RETURN IF FAILS
	HRRZM	T1,ACC.SV+T0(P4);SAVE CORE ADDRESS IN USER'S ACS
	POPJ	P,		;RETURN TO USER

GMEM%%::		;INTERNAL ROUTINE TO GET MEMORY FROM THE HEAP
	JUMPE	T0,PMEM%%	; JUMP IF SPACE TO BE RETURNED

GMEM0:	JUMPL	T0,SMEM%%	; SUPER-GMEM%%

GMEM1:	MOVEI	T2,FRE.DY(P4)	; PREPARE FOR SEARCH
	HRRZ	T1,(T2)		;[234] ANY HEAP LEFT
	JUMPE	T1,GMEM2B	;[234] NO, GET SOME

GMEM2:	HLRZ	T3,(T1)		; GET SIZE OF THIS SPACE
	JUMPE	T3,GMEM8	; DEFENSIVE!
	CAMLE	T3,T0		; BIG ENOUGH?
	AOJA	T0,GMEM9	; YES
	MOVE	T2,T1		; NO -
	HRRZ	T1,(T2)		; SELECT NEXT SPACE
	JUMPN	T1,GMEM2	; AND CONTINUE UNLESS NONE LEFT
GMEM2A:	PUSHJ	P,GMEM3		;TAKE A GARBAGE COLLECTION
	HLRZ	T1,(T2)		;LOAD THE MAXIUM SIZE AVAILABLE
	CAMLE	T1,T0		;IS THIS ENOUGH ROOM
	JRST	GMEM1		;YES, SPACE IS AVAILABLE, GET IT
GMEM2B:	AOS	T3,.JBREL	;SET .JBREL UP 1K (.JBREL/ IS NOT CHANGED)
	CORE	T3,		;ALLOCATE CORE (CORE UUO CHANGES .JBREL)
	JRST	RECLAM		;ATTEMPT TO FIND SOME CORE
	MOVE	T1,.JBFF	;GET THE FIRST UNUSED LOCATION
	HRRM	T1,(T2)		;LINK TO FREE SPACE
	HRRZ	T3,.JBREL	;GET LAST LOCATION ALLOC\TED BY MONITOR
	SUBI	T3,-1(T1)	;GET THE SIZE OF THE NEW FREE CORE BLOCK
	HRLZM	T3,@.JBFF	;SET THE SIZE OF THE FREE BLOCK
	ADDB	T3,.JBFF	;UPDATE JOBFF
	JRST	GMEM2A		;RETURN FOR ADJACENT TEST

DMEM%%::			;[232] INTERNAL ROUTINE TO DEFRAGMENT MEMORY
GMEM3:	MOVEI	T2,FRE.DY(P4)	; NO - DEFRAGMENTATION SCAN
	HRRZ	T1,FRE.DY(P4)	;[246] INITIALIZE LH POINTER
GMEM4:	MOVEI	T3,FRE.DY(P4)	;[246] LOCATE FREE BLOCK
	HRRZ	T4,FRE.DY(P4)	;[246] INITIALIZE RH POINTER
	HLRZ	T5,(T1)		; EXTRACT LENGTH OF LH SPACE
	ADDI	T5,(T1)		; AND ADD TO ORIGIN
GMEM5:	CAME	T1,T4		; SKIP ADJACENCY TEST IF SAME SPACES
	CAME	T5,T4		; ADJACENT SPACES?
	JRST	GMEM7		; NO
	HRRZ	T5,(T1)
	CAMN	T2,T4
	JRST	[
	HRRM	T5,(T3)
	JRST	GMEM6]
	HRRM	T5,(T2)		; REMOVE LH SPACE FROM CHAIN
	HRRZ	T5,(T4)
	CAMN	T1,T3
	JRST	[
	HRRM	T5,(T2)
	JRST	GMEM6]
	HRRM	T5,(T3)		; REMOVE RH SPACE FROM CHAIN

GMEM6:	HLRZ	T5,(T4)
	HLRZ	T3,(T1)
	ADDI	T5,(T3)		; TOTAL LENGTH OF SPACES
	HRLZM	T5,(T1)		; STORE IN AUGMENTED SPACE
	PUSHJ	P,PMEM13	; DELETE AUGMENTED SPACE
	JRST	GMEM3		; AND RECOMMENCE DEFRAGMENTATION SCAN

GMEM7:	MOVE	T3,T4
	HRRZ	T4,(T3)		; MOVE RH POINTER TO NEXT SPACE
	JUMPN	T4,GMEM5	; AND CONTINUE TILL END
	MOVE	T2,T1		; IF SO -
	HRRZ	T1,(T2)		; MOVE LH POINTER TO NEXT SPACE
	JUMPN	T1,GMEM4	; AND CONTINUE TILL END
GMEM8:	POPJ	P,0		;RETURN FROM DEFRAGMENTATION ROUTINE
GMEM9:	HRRZ	T4,(T1)		; SPACE FOUND
	HRRM	T4,(T2)		; REMOVE SPACE FROM CHAIN
	HRLZM	T0,(T1)		; AND FILL IN SIZE
	HRRI	T4,2(T1)	;SET A BLT POINTER TO CLEAR
	HRLI	T4,-1(T4)	;THE REQUEST CORE BLOCK
	HRRZ	T5,T0		;GET THE SIZE OF THE BLOCK
	ADDI	T5,-1(T1)	;GET THE ENDING ADDRESS
	SETZM	1(T1)		;CLEAR THE FIRST WORD
	BLT	T4,(T5)		;CLEAR THE REST OF THE BLOCK
	CAML	T0,T3		; EXACTLY RIGHT?
	AOJA	T1,GMEM8	; YES
	SUB	T3,T0		; NO - COMPUTE REMAINDER
	PUSH	P,T1		; AND SAVE T1
	ADD	T1,T0		; GET ADDRESS OF FRAGMENT
	HRLZM	T3,(T1)		; AND FILL IN ITS LENGTH
	PUSHJ	P,PMEM13	; DELETE IT
	POP	P,T1		; RESTORE T1
	AOJA	T1,GMEM8	;INCREMENT FOR USER


;RECLAIM	ROUTINE TO DELETE ASSIGNED HEAP SPACE TO SATIFY THE
;		CURRENT HEAP REQUEST.

RECLAM:			;ENTRY
 	HRRZ	T1,FMT.DY(P4)	;GET THE ADDRESS OF THE FMT ENCODED LIST
	JUMPE	T1,RECLA1	;[351] NO CORE AVAILABLE
				;[351] LIST ALREADY DELETED (ERROR)
	HLLZS	FMT.DY(P4)	;SET FMT LIST UNASSIGNED
	PUSHJ	P,PMEM13	;DELETE THE LIST
	JRST	GMEM2A		;GARBAGE COLLECT AND TRY AGAIN
RECLA1:	HRRZ	T1,(P)		;[351] GET ADDRESS OF CALLER
	CAIE	T1,ALCOR1+1	;[351] IS IT USER CALL
	ERROR	(SYS,5,17)	;[351] NO
	SETOB	T1,ACC.SV+T0(P4)	;[351] SET ERROR FLAG
	AOS	(P)		;[351] ERROR RETURN
	POPJ	P,		;[351]
PMEM%%::			;INTERNAL ROUTINE TO RETURN MEMORY
GMEM12:
	SUBI	T1,1		; DECREMENT T1
PMEM13:	HRRZ	T2,FRE.DY(P4)	;[234] DELETE SPACE - CHAIN EMPTY?
	JUMPN	T2,PMEM14	;[234] NO
	HRRM	T1,FRE.DY(P4)	;[234] YES - START IT UP
	POPJ	P,0

PMEM14:	HLRZ	T3,(T1)		; GET LENGTH OF SPACE TO BE RETURNED
	JUMPE	T3,GMEM8	; DEFENSIVE!
	MOVEI	T4,FRE.DY(P4)	; AND PREPARE FOR SEARCH

PMEM15:	HLRZ	T5,(T2)		; GET LENGTH OF THIS SPACE
	CAML	T5,T3		; BIGGER THAN ONE TO BE DELETED?
	JRST	PMEM16		; YES
	MOVE	T4,T2		; NO -
	HRRZ	T2,(T4)		; SELECT NEXT SPACE
	JUMPN	T2,PMEM15	; AND CONTINUE UNLESS NONE LEFT

PMEM16:	HRRM	T1,(T4)		; CHAIN FROM LEFT
	HRRZ	T4,(T1)		; EXTRACT RH FIRST
	HRRM	T2,(T1)		; CHAIN TO RIGHT
	JUMPE	T4,GMEM8	; EXIT IF IT WAS A SINGLE SPACE
	MOVE	T1,T4		; NO -
	JRST	PMEM13		;DELETE REMAINDER

SMEM%%::
	HRLZI	T0,000001	; RETURN THE LARGEST AVAILABLE SPACE
	PUSHJ	P,GMEM3		; FORCE DEFRAGMENTATION
	HLRZ	T0,(T2)		; GET SIZE OF LAST AREA IN CHAIN
	SOJA	T0,GMEM0	; AND ASK FOR IT


LMEM%%:				;ROUTINE TO ALLOCATE AND LINK CHUNKS
	;CALL
	;T1=	THE ADDRESS ON A CHUNK IN A LIST
	;RETURN
	;T1=	THE ADDRESS ON A NEW CHUNK LINK TO THE END OF THE LIST
	;T2=	THE PREVIOUS VALUE OF THE LAST CHUNK IN THE LIST

	HLRZ	T0,-1(T1)	;GET THE PREVIOUS CHUNK SIZE
	SOJLE	T0,CPOPJ	;DEFENSIVE
	PUSH	P,T1		;SAVE THE OLD CHUNK ADDRESS
	PUSHJ	P,GMEM%%	;ALLOCATE A NEW CHUNK
	POP	P,T2		;RESTORE THE OLD CHUNK
LMEM20:	HRRZ	T3,-1(T2)	;SEARCH FOR THE END OF THE CHUNK LIST
	JUMPE	T3,LMEM21	;END OF THE LIST
	MOVEI	T2,1(T3)	;GET THE ADDRESS OF THE NEXT BLOCK
	JRST	LMEM20	;CONTINUE THE SEARCH
LMEM21:	HRRM	T1,-1(T2)	;LINK THE NEW CHUNK TO THE OLD ONE
	SOS	-1(T2)		;POINT TO THE CONTROL WORD
	POPJ	P,		;RETURN T1=NEW CHUNK T2=PREVIOUS CHUNK
	SUBTTL DEVTB. DEFAULT DEVICE TABLE FOR FORTRAN IV

	SIXBIT	.REREAD.	;-6;	REREAD
	SIXBIT	.CDR.		;-5;	READ
	SIXBIT	.TTY.		;-4;	ACCEPT
	SIXBIT	.LPT.		;-3;	PRINT
	SIXBIT	.PTP.		;-2;	PUNCH
	SIXBIT	.TTY.		;-1;	TYPE
DEVTB.:	Z			;00;	ILLEGAL DEVICE NUMBER
	SIXBIT	.DSK.		;01;	DISC
	SIXBIT	.CDR.		;02;	CARD READER
	SIXBIT	.LPT.		;03;	LINE PRINTER
	SIXBIT	.CTY.		;04;	CONSOLE TELETYPE
	SIXBIT	.TTY.		;05;	USER'S TELETYPE
	SIXBIT	.PTR.		;06;	PAPER TAPE READER
	SIXBIT	.PTP.		;07;	PAPER TAPE PUNCH
	SIXBIT	.DIS.		;08;	DISPLAY
	SIXBIT	.DTA1.		;09;	DECTAPE
	SIXBIT	.DTA2.		;10;
	SIXBIT	.DTA3.		;11;
	SIXBIT	.DTA4.		;12;
	SIXBIT	.DTA5.		;13;
	SIXBIT	.DTA6.		;14;
	SIXBIT	.DTA7.		;15;
	SIXBIT	.MTA0.		;16;	MAG TAPE
	SIXBIT	.MTA1.		;17;
	SIXBIT	.MTA2.		;18;
	SIXBIT	.FORTR.		;19;
	SIXBIT	.DSK.		;20;
	SIXBIT	.DSK.		;21;
	SIXBIT	.DSK.		;22;
	SIXBIT	.DSK.		;23;
	SIXBIT	.DSK.		;24;
	SIXBIT	.DEV1.		;25;
	SIXBIT	.DEV2.		;26;
	SIXBIT	.DEV3.		;27;
	SIXBIT	.DEV4.		;28;
	SIXBIT	.DEV5.		;29;
DEV.SZ==.-DEVTB.-1
	END
