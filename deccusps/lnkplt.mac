TITLE LNKPLT - INTERFACE TO PLOTTER MODULE
SUBTTL	D.M.NIXON/DMN		23-MAY-74


;***COPYRIGHT 1974  DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

ENTRY	LNKPLT,GETSON
SEARCH	LNKPAR,LNKLOW,C,SCNMAC

CUSTVR==0		;CUSTOMER VERSION
DECVER==2		;DEC VERSION
DECMVR==0		;DEC MINOR VERSION
DECEVR==170		;DEC EDIT VERSION




SALL
SEGMENT

SUBTTL	REVISION HISTORY

;START OF VERSION 2
;137	INITIAL VERSION
;170	INTEGRATE WITH BLISS CODE ETC.
SUBTTL	BLISS CONVENTIONS

FREG==13
VREG==15





;LOCAL DEFINITIONS
PC==17			;REAL PLOTTER CHANNEL

;MAKE THESE SYMBOLS INTERN FOR PLOTTER CODE
INTERN	INCHES,LEAVES,STEPS
SUBTTL	DEFAULTS

P$LEAVES==^D16
L$LEAVES==^D8
P$INCHES==^D29
L$INCHES==^D12
P$STEPS==^D100
L$STEPS==^D20
L$BUFSIZ==^D2160

DEFINE	KEYMAC (A,B)<
 IFIDN <A>,<PLT>,<
   IRP B,<
    EXP P$'B
>>>
PLTTBL:	KEYWORDS
DEFINE	KEYMAC (A,B)<
 IFIDN <A>,<PLT>,<
   IRP B,<
    EXP L$'B
>>>
LPTTBL:	KEYWORDS

SUBTTL	ENTRY

LNKPLT:	JFCL			;IN CASE CCL
	ZAPTMP			;CLEAR TEMP AREA
;NOW REDUCE CORE TO A MINIMUM
	MOVE	T1,DY.AB	;WHAT WE NEED
	ADDI	T1,2000		;PLUS SPACE FOR BUFFERS
	CORE	T1,		;CUT BACK
	  JFCL			;TOO BAD
	MOVE	T1,DY.UB	;PREVIOUS UPPER BOUND
	MOVE	T2,.JBREL##	;CURRENT UPPER BOUND
	CAML	T1,T2		;REDUCED SIZE BUT NOT TOO FAR
	JRST	[CAME	T1,T2		;DID WE DO ANYTHING?
		MOVEM	T2,DY.UB	;YES, CUT BACK
		JRST	LNKPL1]		;AND CLEAR TABLES
	HRL	T1,T1
	ADDI	T1,1		;FORM BLT PTR
	SETZM	-1(T1)
	BLT	T1,(T2)		;CLEAR REST OF CORE
LNKPL1:	ADDI	T2,1		;.JBREL+1
	MOVEM	T2,.JBFF##	;STOPS SCREW UPS
	MOVE	T1,[TAB.LB+1,,TAB.LB+2]
	SETZM	TAB.LB+1	;CLEAR TABLES
	BLT	T1,TAB.LB+HG.TAB
	MOVE	T1,[TAB.AB+1,,TAB.AB+2]
	SETZM	TAB.AB+1
	BLT	T1,TAB.AB+HG.TAB
	MOVE	T1,[TAB.UB+1,,TAB.UB+2]
	SETZM	TAB.UB+1
	BLT	T1,TAB.UB+HG.TAB
	MOVE	T2,BRNMAX	;LONGEST BRANCH
	IMULI	T2,^D20		;20 WORDS PER LEVEL
	ADDI	T2,^D100	;PLUS FUDGE FACTOR
	PUSHJ	P,DY.GET##	;GET SPACE
	MOVN	T2,T2		;- LENGTH
	HRL	T1,T2		;NEW PUSHDOWN STACK
	MOVEM	T1,SAVEP	;WILL USE IT TO CALL PLOT ROUTINES WITH
	MOVEI	T1,PC		;SET REAL CHAN #
	MOVEM	T1,IO.CHN	;AS CHAN TO USE
	MOVE	T1,IO.PTR+%PC	;GET FAKE CHAN
	MOVEM	T1,IO.PTR+PC	;REAL CHAN
	SETZM	IO.PTR+%PC	;JUST IN CASE
;NOW SET THE COMMON DEFAULTS
	MOVE	T2,LODNAM	;DEFAULT NAME
	SKIPN	I.NAM(T1)	;BUT NOT IF ALREADY SETUP
	MOVEM	T2,I.NAM(T1)
	MOVSI	T2,'PLT'	;DEFAULT EXT
	SKIPN	I.EXT(T1)
	HLLZM	T2,I.EXT(T1)
	MOVSI	T2,(Z PC,)	;SET REAL CHAN
	MOVEM	T2,I.CHN(T1)
	MOVSI	T2,POB		;OUTPUT BUFFER HEADER
	MOVEM	T2,I.BUF(T1)
	MOVE	T2,VERNUM	;GET VERSION#
	SKIPN	I.VER(T1)	;ALREADY SET BY SWITCH
	MOVEM	T2,I.VER(T1)
;NOW TO SEE IF WE USE PLT OR LPT SIMULATOR
	PUSHJ	P,DVCHK.##	;GET DEVCHR WORD
	MOVE	T2,IO.CHR	;...
	TXNE	T2,DV.DSK	;TEST FOR NUL:
	JRST	.+3
	TXNE	T2,DV.LPT!DV.TTY	;NEED TO SIMULATE?
	JRST	LPTPLT		;YES
	MOVEI	T2,.IOIBN	;REAL PLOTTER USES MODE 13
	MOVEM	T2,I.MOD(T1)
	DMOVE	T1,PLTTBL	;GET DEFAULTS
	SKIPN	PLTTAB		;AND SETUP IF NOT ALREADY
	MOVEM	T1,PLTTAB	; BY SWITCHES
	SKIPN	PLTTAB+1
	MOVEM	T2,PLTTAB+1
	MOVE	T1,PLTTBL+2
	SKIPN	PLTTAB+2
	MOVEM	T1,PLTTAB+2
PLTOPN:	PUSHJ	P,DVOPN.##	;OPEN DEVICE
	PUSHJ	P,DVENT.##	;ENTER FILE NAME
	EXCH	P,SAVEP		;USE NEW, LARGER PDL
	HRRZI	FREG,1(P)	;SET UP FRAME PTR
	PUSHJ	P,PLTO.F##	;CALL PLOTTER
	EXCH	P,SAVEP		;PUT P BACK
	PUSHJ	P,DVCLS.##	;CLOSE FILE
	JRST	ENDSAV##	;AND GO BACK TO LNKXIT


SUBTTL	LPT SIMULATION SETUP
LPTPLT:	MOVEI	T2,.IOASL	;LPT USES ASCII LINE
	MOVEM	T2,I.MOD(T1)
	DMOVE	T1,LPTTBL	;GET DEFAULTS
	SKIPN	PLTTAB		;AND SETUP IF NOT ALREADY
	MOVEM	T1,PLTTAB	; BY SWITCHES
	SKIPN	PLTTAB+1
	MOVEM	T2,PLTTAB+1
	MOVE	T1,LPTTBL+2
	SKIPN	PLTTAB+2
	MOVEM	T1,PLTTAB+2
	MOVEI	T2,L$BUFSIZ	;NEEDED FOR SIMULATION
	PUSHJ	P,DY.GET##
	MOVEM	T1,LPBUF	;STORE FOR PLOTTER
	JRST	PLTOPN		;JOIN COMMON CODE

SUBTTL	GETSON ROUTINE

;CALLED FROM BLISS WITH 3 ARGS ON STACK
;ARGS ARE
;1	PTR TO NODE TO BE BUILT (RETURNED)
;2	PTR TO CURRENT FATHER (0 FOR ROOT)
;3	INDEX TO WHICH SON

;ARG1 POINTS TO BLOCK OF FOLLOWING FORM

LOC 0
P%HDR:!	BLOCK	1		;LENGTH ,, 0
P%UNU:!	BLOCK	1		;UNUSED
P%SON:!	BLOCK	1		;ADDRESS OF SON ,, UNDEFINED
P%NUM:!	BLOCK	1		;LENGTH OF NAME ,, NUMBER
P%NAM:!	BLOCK	2		;NAME (2 WORDS)
P%ZER:!	BLOCK	1		;SET TO ZERO
RELOC

GETSON:	EXCH	P1,-3(P)	;PICK UP THE ARGS
	EXCH	P2,-2(P)	;...
	EXCH	P3,-1(P)	;...
	SPUSH	<T1,T2,T3,T4>	;GET SOME ACCS
	SETO	VREG,		;ASSUME WE WILL SUCCEED
	JUMPE	P2,GETROO	;WANTS ROOT IF ZERO
	CAIN	P2,-1		;SPECIAL CASE OF NO LEAF?
	AOJA	VREG,RET	;YES, GIVE FALSE RETURN
	HLRE	T1,0(P2)	;GET - LENGTH
	MOVM	T1,T1
	CAIL	P3,-2(T1)	;VALID INDEX?
	AOJA	VREG,RET	;NO, GIVE ERROR RETURN
	MOVE	T1,P2		;PTR TO FATHER
	ADDI	T1,2(P3)	;POINT TO SON WE WANT
	SKIPN	T2,(T1)		;GET NUMBER & PTR
	AOJA	VREG,RET	;HANDLES PATHOL. CASE OF 1 SON
	TRNN	T2,-1		;NO SON LEAF
	IORI	T2,-1		;YES, SET SPECIAL MARKER
	HLRZM	T2,P%NUM(P1)	;STORE NUMBER
	HRLM	T2,P%SON(P1)	;POINT TO ITS SON
	HLRZ	T1,T2		;NUMBER ONLY
GETRST:	MOVS	T2,LNMPTR	;GET START OF NAME TABLE
GETNXT:	HLRZ	T3,1(T2)	;GET NUMBER
	CAMN	T1,T3		;MATCH
	JRST	GETNAM		;YES
	HRRZ	T2,1(T2)	;GET NEXT ONE
	JUMPN	T2,GETNXT	;IF THERE IS ONE
	SETZ	T3,		;CLEAR SIZE
STRNAM:	HRLM	T3,P%NUM(P1)	;LENGTH IN CHARS
	MOVEM	T2,P%NAM(P1)	;STORE NAME
	SETZM	P%NAM+1(P1)	;ZERO SECOND WORD
	SETZM	P%ZER(P1)	;ALWAYS
RET:	SPOP	<T4,T3,T2,T1>	;RESTORE
	EXCH	P1,-3(P)	;RESTORE ARGS
	EXCH	P2,-2(P)	;...
	EXCH	P3,-1(P)
	POPJ	P,		;RETURN
GETNAM:	MOVE	T2,(T2)		;GET NAME
	MOVEI	T3,6		;ASSUME SIX CHARS
	MOVEI	T4,77		;MASK
	TDNE	T2,T4		;SEE IF CHAR EXISTS
	JRST	STRNAM		;YES, COUNT IN T3
	LSH	T4,6		;SHIFT TO NEXT PLACE
	SOJA	T3,.-3		;ONE LESS


GETROO:	MOVE	T1,FSTPTR	;GET START OF TREE
	HRLM	T1,P%SON(P1)	;POINT TO IT
	SETZB	T1,P%NUM(P1)	;SET NUMBER TO ZERO
	JRST	GETRST		;SETUP REST OF DATA
SUBTTL	DATA STORAGE

.ZZ==.TEMP
U	(SAVEP)		;STORE INITIAL PUSHDOWN STACK
U	(LPBUF)			;PTR TO LTP BUFFER IF NEEDED
U	(POB,3)		;PLOT OUTPUT BUFFER HEADER

PLTLIT:
END
