	TITLE	FORTRAN PDP-6/10/10I V27(360)
	SUBTTL	FX1 V27(360)	12-NOV-1974
;COPYRIGHT 1971,1972,1973,1974,  DIGITAL EQUIPMENT CORP., MAYNARD, MASS.

;EDIT HISTORY

;342	IMPROVE PRINTOUT FOR TRACE OPTION, JNT SEP-74, NO SPR.
;	IN FX1.MAC.
;343	CORRECT REGISTER ALLOCATION IN I/O WHEN UNIT# IS INDEXED
;	OR FOR SOME IMPLIED LOOPS, JNT SEP-74, SPR'S 12313, 12376,
;	13691.  IN FX2.MAC.
;344	ALLOW EXCLAMATION POINT COMMENTS, UNDER IFDEF CONTROL
;	JNT SEP-74, NO SPR, NOT COMPLETE.  IN FX1.MAC, FX2.MAC.
;345	CORRECT EDIT 27L TO NOT CLOBBER THE WORKROLL
;	IN ALL OTHER CONDITIONS THAN THE SPECIFIC ONE FIXED BY 27L
;	JNT OCT-74, QAR.  IN FX1.MAC, FX2.MAC.
;346	CORRECT EDIT 27K TO NOT FORCE A DOUBLE PRECISION STORE
;	IN ALL CASES, UNNECESSARILY ALLOCATING EXTRA TEMP. LOCATIONS
;	JNT OCT-74, QAR.  IN FX2.MAC.
;347	CORRECT EDIT 27N TO NOT CLOBBER SYMBOL
;	JNT OCT-74, QAR, SPR 14003.  IN FX2.MAC.
;350	FIX SUBSCRIPTING ON LEFT OF = FOR WHEN EXPRESSION CAME
;	OUT NEGATIVE.
;	JNT OCT-74, SPR 10537.  IN FX2.MAC.
;351	CORRECT START ADDRESS OF MAIN PROGRAM TO JFCL INSTEAD OF
;	RESET.
;	JNT OCT-74, QAR.  IN FX2.MAC.
;352	DATE75 HACK FOR WHEN BOTH .REL AND .LST
;	JNT OCT-74, NO SPR.  IN EXEC.MAC.
;353	CORRECT ARROW POINTER WHEN OPEN/CLOSE PARAMETER IS NOT
;	RECOGNIZED TO POINT AT PARAMETER.
;	JNT OCT-74, QAR.  IN FX2.MAC.
;354	FIX EDIT 27C.  WHEN A BLANK LINE WITH MORE THAN JUST A CRLF
;	FOLLOWS A LINE WITH A STATEMENT NUMBER, ERROR S-24 IS PRINTED.
;	JNT OCT-74, QAR ARL6.  IN FX2.MAC.
;355	FIX ERROR WHEN EXECUTING A RUNUUO THAT FAILS, SINCE EXEC TRIES
;	TO CONTINUE WITH THE NEXT COMMAND STRING.
;	JNT OCT-74, SPR_???.  IN EXEC.MAC.
;356	ADD A FEATURE TEST SWITCH AND CODE TO PRINT THE STARTING
;	ADDRESS OF EACH FORTRAN STATEMENT THAT GENERATES CODE.
;	JNT OCT-74, QAR ARL-2.  IN FX1.MAC.
;357	CHECK FOR A STATEMENT LABEL OF 0 ON THE STATEMENT IN
;	ADDITION TO ITS REFERENCES.
;	JNT 24-OCT-74, FROM SPR 5329.  IN FX1.MAC.
;360	FIX A PROBLEM WITH DOUBLE PRECISION NOT SAVING THE LOW ORDER
;	WORD FROM REGS 0 & 1.  PROBLEM CAUSED BY EDIT 346 WHICH
;	DISCOVERED THAT EDIT 27K DIDN'T REALLY WORK.
;	JNT 04-NOV-74, FROM QAR ARL-9.  IN FX2.MAC.
;
;END OF REVISION HISTORY
VERSION==27
VEDIT==360
	IFDEF	REENTR,	<HISEG>
IFNDEF FTMANT,<FTMANT==0>		;MANTIS DEBUGGER SUPPORT

IFNDEF	FILE0,
<
	INTERNAL	TITLE,SUBTLE
	SIXBIT  /F40I  /	;"25-1"
TITLE:	SIXBIT	/F4    /
	SIXBIT	/F40   /
	DEFINE LEVEL (VCUSTOM,VERSION,VMINOR,VEDIT)<
SUBTLE:	SIXBIT	/V'VERSION'VMINOR/	;"23-AU"
	LOC	<.JBVER=	137>	;"23-AU"
IFDEF	DEBUG,
<	BYTE (3) 7 (9) VERSION (6) "VMINOR"&77 (18) VEDIT> ;"23-AU"
IFNDEF	DEBUG,
<	BYTE (3) VCUSTOM (9) VERSION (6) "VMINOR"&77 (18) VEDIT> ;"23-AU"
	RELOC
>
IFE FTMANT,<
	LEVEL	0,27,,VEDIT	;##### UPDATE IF COMPILER CHANGES ;"27A"
>
IFN FTMANT,<
	LEVEL	0,27,,VEDIT	;##### UPDATE IF COMPILER CHANGES ;"23-AU"
>

	EXTERNAL	.JBERR,	.JBTPC,	.JBCNI, .JBSYM	;"25-1" "27D"

IFDEF	REENTR,<

	EXTERNAL	PINATO,	PDPSW,	PROGN,	ERRMSG,ENDFLG
	EXTERNAL	LBFLG,	FEXADR,	ERRCNT,	LCANUM,IMDFLG
	EXTERNAL	NDISCA,	NUNPOS,	FAICAR,	FSTFLA,	ENDCOD	;"23P"
	EXTERNAL	COPRCT,	FMSBOX,	ERRBOX,	CCAFLA,	LFUTEM	;"23GG"
	EXTERNAL	SYMBOL,	CANCLU,	MAC1,	CON1,	LFUATO	;"23GG"
	EXTERNAL	RPACLU,	DAT1,	MAC2,	DAT2
	EXTERNAL	DAT3,	DAT4,	HITCNT,	ISAFLA
	EXTERNAL	NOPPNT,	BEXPNT,	RPRNAM,	RETPNT,	LSPDEF ;"23-AM"
	EXTERNAL	FARTEM,	ASTFLA,	IIAFLA,	DSTFLA
	EXTERNAL	GSTFLA,	JSTFLA,	BDPFLA,	ERRFLA
	EXTERNAL	PPEFLA,	FORFLA,	CRFSW,	SINFLA
	EXTERNAL	QFACCN,	MSTLOC,	CREPNT,	HOLBUF
	EXTERNAL	HBUIND,	ROLPNT,	ESIBOX,	DDOCNT
	EXTERNAL	DITCNT,	DLICNT,	MCOFLA,	CLBBOX
	EXTERNAL	CBABOX,	DUSCNT,	REGTEM,	EXPA
	EXTERNAL	EXPONE,	DARFLA,	IOLFLA,	JOUFLA
	EXTERNAL	TEMP,	DSPFLA,	SARFLA,	LATPNT
	EXTERNAL	LA1S13,	LA1S14,	PROBRE,	RROFLA
	EXTERNAL	FELFLA,	MINBOX,	ISCBOX,	MAXBOX
	EXTERNAL	VPNBOX,	SMABOX,	IBICNT,	SMIBOX
	EXTERNAL	ABLPNT,	ARGCNT,	ESTFLA,	CARNUM
	EXTERNAL	LACCCN,	TEMCNT,	IIVPNT,	MLBCNT
	EXTERNAL	LOCCNT,	LASACT,	LTEPNT,	STAPSA
	EXTERNAL	STACSA,	STAEXS,	STAWKS,	LAPTMP
	EXTERNAL	LAPEND,	SSATMP,	SSAEND,	STATBS
	EXTERNAL	AFDTPN,	RGRTMP,	PSTCRD,	OARNCL
	EXTERNAL	ARNCLU,	FRNCLU,	OPNCLU,	IMPCLU
	EXTERNAL	AROCLU,	OAROCL,	CPOCLU,	CONTEM
	EXTERNAL	APACLU,	FRAPCL,	TPOBOX,	ACOCNT
	EXTERNAL	BPACLU,	SEXCLU,	WORROL,	TOPS
	EXTERNAL	BOTTOM,	ANCHOR,	FLOORS,	EROADR
	EXTERNAL	AC00,	AC01,	AC02,	AC03
	EXTERNAL	AC04,	AC05,	AC06,	AC07
	EXTERNAL	AC10,	AC11,	AC12,	AC13
	EXTERNAL	AC14,	ROLMEM,	CRDCNT,	PAGCNT
	INTERNAL	ZERCOR,	PDPSET
	EXTERNAL	DCTYPE		;[27P]
	EXTERNAL	ZERA,	MACSW,	AC1SAV,	EXPSAV
	EXTERNAL	TTLERR,	NUMPRO,	PDPSWZ,	EXTSAV
	EXTERNAL	PROGNZ,	ERRCNZ,	PDPSTK,	JOBFFI
	EXTERNAL	XE,	XE1,	XE2,	XE3
	EXTERNAL	CMDBUF,	CMDPNT,	CMDCNT,	TTOBUF
	EXTERNAL	TTOPNT,	TTOCNT,	BINBUF,	BINPNT
	EXTERNAL	BINCNT,	LSTBUF,	LSTPNT,	LSTCNT
	EXTERNAL	SRCBUF,	SRCPNT,	SRCCNT,	LINCNT
	EXTERNAL	CARBUF,	APAEM,	SLPEM,	APAATO
	EXTERNAL	RSIEM,	SIGMAS,	RSITRA,	RSIATO
	EXTERNAL	SLBPNT,	ETYEM,	EOPPNT,	ETYATO
	EXTERNAL	PINEM,	PINATO,	IMPURE,	REGSAV
	EXTERNAL	GALPNT,	APLPNT,	AREPNT,	REGCNT	;"21V"
	EXTERNAL	ASTPNT,	CARPNT,	FREPNT,	OPCPNT
	EXTERNAL	SCAPNT,	SUBPNT,	GDMPNT,	LBLPNT
	EXTERNAL	ITEPNT,	DSTPNT,	NNAPNT,	ARRPNT
	EXTERNAL	CODPNT,	ERRPNT,	GSPPNT,	HCOPNT
	EXTERNAL	APNPNT,	CPOPNT,	UN2PNT,	LAPEND
	EXTERNAL	CEMADR,	PEMADR,	SEQPNT,	FICPNT
	EXTERNAL	DEFINE				;"21U"
	EXTERNAL	SAV15,	SAV16			;"21V"
	EXTERNAL	VIOEXP,SLBXLF,LASEXP	;[27M]FIX EARLIER STUFF
	EXTERNAL	ARGNUM,ARGTLY,NULDIA,ARGMAP,TXLST,ARGKNT  ;[27M]
	EXTERNAL	UNIDEF,SPSW,CLODEF,OPNDEF		;[27M]
	EXTERNAL	MULRET				;"22A"
>
	EXTERNAL	CHAR,	LSTOUT,	LSTTAB,	ERROUT,	BINOUT,	PANIC
	EXTERNAL	LSTFLG,	BINFLG,	CSWFLG,	ESWFLG,	MSWFLG,	TTYFLG
IFNDEF	FILE0,	;"23B"
<	EXTERNAL	HDRBIT,	ERROR	;"23J"
	EXTERNAL	ISWBIT	;"23Q"
>	;"23B"
	EXTERNAL	MOTFLG ;"23Q"
	INTERNAL	F4,	ASCIBL
	INTERNAL	EXIRLI,	LENGTI,	CSTATI
	INTERNAL	CRR,	EOF,	SPACE,	TAB,	N0
IFNDEF	FILE0,			;"23B"
<	INTERNAL	PDLOV	;"23J"
>				;"23B"
	INTERNAL	NCDML

IFNDEF	REENTR,
<	INTERNAL	ZERCOR,	PDPSET,	ROLMEM,	JOBFFI,	SEQPNT
	INTERNAL	PDPSWZ,	PROGNZ,	CARBUF,	EROADR,	CRDCNT,	LINCNT,	PAGCNT
	INTERNAL	ERRCNZ,	TTLERR,	NUMPRO,	BOTTOM,	FLOORS,	CORSIZ
	INTERNAL	XE,	XE1,	XE2,	XE3
	INTERNAL	AC00,	AC01,	AC02,	AC03
	INTERNAL	AC04,	AC05,	AC06,	AC07
	INTERNAL	AC10,	AC11,	AC12,	AC13
	INTERNAL	AC14,	EXTSAV

	INTERNAL	CMDBUF,	CMDPNT,	CMDCNT
	INTERNAL	TTOBUF,	TTOPNT,	TTOCNT
	INTERNAL	BINBUF,	BINPNT,	BINCNT
	INTERNAL	LSTBUF,	LSTPNT,	LSTCNT
	INTERNAL	SRCBUF,	SRCPNT,	SRCCNT
>>

IFN FTMANT,<EXTERNAL	DEBFLAG,REFSTA,	REFSW,	RFPOINT,RFPACK,	REFOUT>
;	IFDEF	$CCONS,	FLUSH COLLAPSE CONSTANTS

;	IFDEF	$FAD,	FLUSH FLOATING POINT INSTRUCTIONS

	IFDEF	$FAD,	<$CCONS=	0>	;$FAD IMPLIES $CCONS

;	IFDEF	$IMPL,	FLUSH IMPLICIT

;	IFDEF	$DATA,	FLUSH DATA STATEMENT

;	IFDEF	$CODE,	FLUSH LISTING OF BINARY (/E)

;	IFDEF	$NAME,	FLUSH NAMELIST

;	IFDEF	$CREF,	SUPPRESS CREF LISTING

;	IFDEF	ERRCO,	DEFINE ERROR MESSAGE QUALIFIER ONLY	;"23O"

;	IFDEF	HALFWD,	ASSEMBLE IN HALF-WORD POPS

;	IFDEF	DEBUG,	ASSEMBLE DEBUG PACKAGE

;	IFDEF	$EXPNT,	ALLOW EXCLAMATION POINTS TO INDICATE COMMENTS

;	IFDEF	$LOCAT, PRINT THE ADDRESS OF THE FIRST INSTRUCTION OF EACH LINE [356]

	SPACE=	" "	-40
	EXPNT=	"!"	-40	;[344]
	DBLQT=	042	-40	;"23F"
	LBSIGN=	"#"	-40
	DOLLAR=	"$"	-40
	PERCNT=	"%"	-40
	AMPSND=	"&"	-40	;"23G"
	SNGLQT=	"'"	-40

	LPAREN=	"("	-40
	RPAREN=	")"	-40
	ASTERI=	"*"	-40
	PLUS=	"+"	-40
	COMMA=	","	-40
	MINUS=	"-"	-40
	PERIOD=	"."	-40
	SLASH=	"/"	-40

	N0=	"0"	-40
	N1=	"1"	-40
	N2=	"2"	-40
	N3=	"3"	-40
	N4=	"4"	-40
	N5=	"5"	-40
	N6=	"6"	-40
	N7=	"7"	-40
	N8=	"8"	-40
	N9=	"9"	-40

	EQUAL=	"="	-40
	INDCHA=	"@"	-40

	A=	"A"	-40
	B=	"B"	-40
	C=	"C"	-40
	D=	"D"	-40
	E=	"E"	-40
	F=	"F"	-40
	G=	"G"	-40
	H=	"H"	-40
	I=	"I"	-40
	L=	"L"	-40
	M=	"M"	-40
	N=	"N"	-40
	O=	"O"	-40
	P=	"P"	-40
	R=	"R"	-40
	S=	"S"	-40
	T=	"T"	-40
	X=	"X"	-40

	TAB=	"["	-40
	EOF=	"]"	-40
	CRR=	"_"	-40
	UARROW=	"^"	-40
	FORM=	"\"	-40
	%00=	00
	%01=	01
	%02=	02
	%03=	03
	%04=	04
	%05=	05
	%06=	06
	%07=	07
	%10=	10
	%11=	11
	%12=	12
	%13=	13
	%14=	14
	%15=	15
	%16=	16
	%17=	17

	D0=	^D0
	D1=	^D1
	D2=	^D2
	D3=	^D3
	D4=	^D4
	D5=	^D5
	D6=	^D6
	D7=	^D7
	D8=	^D8
	D10=	^D10
	D12=	^D12
	D14=	^D14
	D16=	^D16

;7 LINES DELETED	;"23O"
	ZERRUN=	0	;ZERO RUNG
	ONERUN=	1	;ONE RUNG
	OFFRUN=	1	;OFFSET RUNG
	APPRUN=	1	;ARG PLEX PNTR RUNG
	CASRUN=	1	;COMMON AREA SIZE RUNG
	ASIRUN=	2	;ARRAY SIZE RUNG
	TWORUN=	2	;TWO RUNG
	LODKEY=	3	;LETTER OR DIGIT KEY
	SPNRUN=	3	;STATUS PNTR RUNG
	THRRUN=	3	;THREE RUNG
	UCNRUN=	4	;USE CNT RUNG
	MOIEFM=	4	;MAX ONES IN EXPON FOR MPY
	CSIRUN=	4	;CALC SIZE RUNG
	RORBAS=	6	;RUN ON ROLL BASE
	MAEFMP=	200	;MAX ABS EXPON FOR MPY

	LETKEY=	1	;LETTER KEY
	DIGKEY=	2	;DIGIT KEY
	DOEKEY=	10	;D OR E
	POMKEY=	20	;PLUS OR MINUS KEY
	CPAKEY=	40	;COMMA-VIRGULE-R PAREN
	COMKEY=	200	;COMMENT KEY

	CRFSTA= 34	;FLAG FOR CREF STATEMENT NUMBER
	CRFLIN=	35	;FLAG FOR CREF LINE
	CRFSYM=	36	;FLAG FOR CREF SYMBOL

	TSAREG=14	;TOP SINGLE ARITHMETIC REGISTER
IFDEF	FASTDP,
<	TDAREG=7
>
IFNDEF	FASTDP,
<	TDAREG=6	;TOP DOUBLE ARITHMETIC REGISTER
>
			;***CAUTION, TDAREG MUST BE EVEN***

	LBLROL=	0	;LBL ROLL
	OARROL=	1	;OBJECT ARRARY REF ROLL
	UN2ROL=	2	;UNUSED 2 ROLL
	APLROL=	3	;ARG PLEX ROLL
	PCOROL=	4	;PROLOG CODE ROLL
	CODROL=	5	;CODE ROLL
	GSPROL=	6	;GLOBAL SPROG ROLL
	REGROL=	7	;REG ROLL
	ICOROL=	10	;INT CONST ROLL
	ULBROL=	10	;UNDEFINE LBL ROLL
	CPOROL=	11	;CONST POOL ROLL
	MDLROL=	12	;MUL DEFINED LBL ROLL
	AERROL=	13	;ALLOC ERROR ROLL
	DEFROL=	13	;DEFINED GLOBAL DUMMY ROLL
	OCOROL=	14	;OCT CONST ROLL
	HCOROL=	15	;HOLLERITH CONST ROLL
	FCOROL=	16	;FL CONST ROLL ;"23EE"
	RCOROL= 16	;REAL CONST ROLL
	DPCROL=	16	;DOUBLE PREC CONST ROLL
	ENEROL=	16	;EQUIV NEST ROLL
	CCOROL=	17	;COMPLEX CONST ROLL
	CARROL=	17	;COMMON AREA ROLL
	SCAROL=	20	;SCALAR ROLL
	LDMROL=	21	;LOCAL DMY ROLL
	ARRROL=	22	;ARRAY ROLL
	NNAROL=	23	;NAMELIST NAME ROLL
	AREROL=	24	;ARRAY REF ROLL
	GALROL=	25	;GENERAL ALLOC ROLL
	ERRROL=	26	;ERROR ROL
	TEMROL=	27	;TEMP ROLL
	FREROL=	30	;FUNC REF ROLL
	SUBROL=	30	;SUBEXP ROLL
	APNROL=	31	;ARG PNTR ROLL
	SUDROL=	32	;SUBORDS ROLL
	NESROL=	33	;NEST ROLL
	GDMROL=	34	;GLOBAL DMY ROLL
	IMPROL=	35	;IMPLICIT ROLL
	LSPROL=	36	;LOCAL SPROG ROLL
	DLOROL=	37	;DO LOOPS OPEN ROLL
	ITEROL=	40	;ITEM TEMP ROLL
	ATEROL=	41	;ARRAY TEMP ROLL
	CTEROL=	41	;CONST TEMPT ROLL
	DLIROL=	42	;DATA LIST ROLL
	DIMROL=	42	;DIMENS ROLL
	DLCROL=	43	;DATA LIST CONST ROLL
	DARROL=	43	;DIMENS ARG ROLL
	DITROL=	44	;DATA ITEMS ROLL
	LIMROL=	44	;LIMITS ROLL
	DSTROL=	45	;DATA SCRIPT TERM ROLL
	DSVROL=	46	;DATA SCRIPT VAR ROLL
	ETEROL=	46	;EQUIV TEMP ROLL
	NITROL=	47	;NAMELIST ITEMS ROLL
	VARROL= 47	;VARIABLE POINTER ROLL
	IIDROL=	50	;INTEGER ID ROLL
	SIIROL=	51	;SUBSCRIPT INTEGER ID ROLL
	RIDROL=	52	;REAL ID ROLL
	LIDROL=	53	;LOGICAL ID ROLL
	CRFROL= 54	;CREF ROLL
	ASTROL=	55	;ARRAY STAT ROLL
	DPIROL=	56	;DOUBLE PRECISION ID ROLL
	CIDROL=	57	;COMPLEX ID ROLL
	EDAROL=	60	;EQUIV DATA ROLL
	CDAROL=	61	;COMMON DATA ROLL
	LRONUM=	62	;LAST ROLL NUMBER
	CNAROL=	62	;COMMON NAMES ROLL
	FTAROL=	63	;FIRST TABLE ROLL
	OPCROL=	64	;OP ROLL
	LFUROL=	65	;LIB FUNC ROLL
	CAPHEA=	170000		;COMMON AREA PNTR HEAD
	IBIEXP=	306	;INITIAL BINARY EXP 
	MDEEXP=	^D40		;MAX DECIMAL EXPONENT
	NOFREG=	17		;NUMBER OF REGS PLUS 1
	C6PNTR=	206		;COLUMN SIX PNTR

	WPL=	^D15		;WORDS PER BUFFER LINE

IFNDEF	NCC0,	<NCC0=	^D4 >
					;MAX NUMBER OF CARDS PER STATEMENT
IFNDEF	NCC1,	<NCC1=	^D19>

	;FIRST BUFFER CONTAINS 20 WORDS INSTEAD OF 15
	;IN ORDER TO PRINT OUT LONGER ERROR MESSAGES
	CBLEN0=	<NCC0+2>*WPL+5	
	CBLEN1=	<NCC1+2>*WPL+5	
		;AND THE REST ARE CONTINUATION CARDS


IFNDEF	EXLEN0,	<EXLEN0= 60>
					;EXIT ROLL LENGTH
IFNDEF	EXLEN1,	<EXLEN1=201>

IFNDEF	FILE0,	<IFNDEF	WORLEN,	<WORLEN=200>>	;LARGE COMPILER WORK ROLL LENGTH
IFNDEF	WORLEN,	<WORLEN=100>	;WORK ROLL LENGTH
IFNDEF	PDPLEN,	<PDPLEN= 40>	;%17 STACK LENGTH

IFDEF	REENTR,	<ZZ=0>		;NO OFFSET IF REENTRANT COMPILER
;	USE LONG ERROR MESSAGES EVEN IF SMALL COMPILER
;	I.E. HALFWORD MODE FOR BETTER TRACES
;	TO DO THIS, DON'T DEFINE ERRCO
IFDEF	HALFWD,<ERRCO=0>	;SHORT ERRORS FOR SMALL COMPILERS
IFNDEF	HALFWD,
<
	DEFINE	OP	(NAME)	<
	NAME=	.-F4

	OPDEF	NAME	[Z	NAME       ]
	OPDEF	NAME'T	[Z	NAME!400000]
	OPDEF	NAME'F	[Z	NAME!200000]	>
>

IFDEF	HALFWD,
<
	DEFINE	OP	(NAME)	<
	NAME=	OPCNT

	DEFINE	NAME	(ADDR)	<
	HWD	NAME_9!ADDR	>

	DEFINE	NAME'T	(ADDR)	<
	HWD	NAME_9!ADDR!400000>

	DEFINE	NAME'F	(ADDR)	<
	HWD	NAME_9!ADDR!200000>

	OPJSET	NAME
	>

	IF1,	<DEFINE	OPJSET	<OPCNT=	OPCNT+1 ;>>

	IF2,	<DEFINE	OPJSET	(NAME)	<
IFN	<OPCNT=	OPCNT+1>_-7, <PRINTX -NAME- OVERFLOWS OP TABLE>
	IFDEF DEBUG, < 
	RELOC	DEBITB+OPCNT-1
	SIXBIT	/NAME/
	RELOC>
	CODE=	CODE+<.-F4>_<NN=NN-^D12>
	IFE NN,	<
	RELOC	OPJTBL+<OPCNT-1>/3
	+CODE
	RELOC
	NN=^D36+<CODE=0>>>>

	IF1,	<DEFINE	HWD	<BLOCK	1 ;>>

	IF2,	<DEFINE	HWD	(ADDR)	<
	IFE .&1,	<CODE=<ADDR>_^D18>
	IFN .&1,	<CODE=CODE!<ADDR>
	RELOC
XLIST
	+CODE
LIST
	LOC>
	BLOCK	1>>

	OPCNT=0				;OP COUNTER


	IF2,	<
	CODE=	0			;JUMP TABLE ACCUMULATOR
	NN=^D36>			;CODE PACK COUNTER
>

	DEFINE	OPSAVE	(NAME)	<
	SYN	NAME,	NAME'SAV
	PURGE	NAME		>

	DEFINE	OPREST	(NAME)	<
	SYN	NAME'SAV,NAME
	PURGE	NAME'SAV	>
F4:
	MOVSI	%06,10000			;BYTE (3)0,SIGN
	MOVEM	%06,RSITRA+ZZ
	MOVSI	%06,700000			;BYTE (3)MASK
	MOVEM	%06,ETYEM+ZZ
	MOVEM	%06,LFUTEM+ZZ	;"23GG"
	MOVEI	%06,-1			;BYTE (18)0,MASK
	MOVEM	%06,SLPEM+ZZ
	MOVEI	%06,400000			;
	MOVEM	%06,APAEM+ZZ
	MOVEI	%06,-1				;BYTE (18)0,MASK
	MOVEM	%06,PINEM+ZZ
				;LINE DELETED ;"21V"
				;LINE DELETED ;"21V"

	SOS	%00					;JOBREL-1
	HRLI	%06,TOPS+1				;SETUP BLT POINTER
	HRRI	%06,TOPS+2
	HRRZM	%00,TOPS+1				;STORE TOP LOCATION (JOBREL-1)
	BLT	%06,EROADR				;FLOOD AREA WITH TOP LOCATION
	HLRZM	%00,TOPS  				;STORE JOBFF
	HLRZM	%00,BOTTOM				;ALL ROLLS HAVE 0 LENGTH EXCEPT ROLL 0
	HLRZM	%00,ANCHOR				;ROLL 0 HAS ALL FREE SPACE

	MOVSI	%06,-3				;DUMMY UP POINTERS TO MAKE
	SKIPA	%10,TABBAS				;OPTABLE (OPTABL) AND LIB FUNC TABLE (LFUTAB)
COMIN1:	HRRZM	%10,ANCHOR+FTAROL(%06)		;LOOK AND OPERATE LIKE THE REST OF
	HRRZM	%10,TOPS  +FTAROL(%06)		;THE ROLLS
	MOVE	%10,TABBAS+1(%06)
	HRRZM	%10,BOTTOM+FTAROL(%06)
	AOBJN	%06,COMIN1
IFNDEF	FILE0,
<
	TLNE	%16,MSWFLG	;SUPRESS MACRO CODE ?
	SETOM	MACSW+ZZ	;YES,SET UPPER MEMORY FLAG
>
IFDEF	FILE0,
<
	SETZM	MACSW+ZZ				;NO OPTION WITH SMALL COMPILER
>
IFNDEF	$CREF,
<
	TLNN	%16,CSWFLG	;CREF DESIRED?
	SETOM	CRFSW+ZZ	;YES, SET CREF SWITCH
>

	HRLI	%05,-WORLEN
	HRRI	%05,WORROL	;SET UP WORK ROLL
	MOVEI	%01,PRORUN	;FIRST POP LANGUAGE ROUTINE TO BE EXECUTED
IFDEF	DEBUG,
<
	HLLZM	%04,DEBS04	;SAVE ORIGINAL EXIT ROLL SIZE
	HLLZM	%05,DEBS05	;SAVE ORIGINAL WORK ROLL SIZE
>
	JRST	PSEML		;START EXECUTING PRORUN

IFNDEF	HALFWD,
<
	OP	JSB
JSBML:	HRR	%03,%01
	PUSH	%04,%03

	OP	JMP
JMPML:	HRRZ	%01,%02

PSEML:	MOVE	%06,POPMEM(%01)
	HLRZ	%02,%06
PSDISP:

IFDEF	DEBUG, <
	SKIPE	DEBSW
	PUSHJ	%17,DBEML>

	TRNN	%06,600000		;POP SETUP DISPATCH
	JRST	F4(%06)
	TRZE	%06,400000
	JUMPN	%03,F4(%06)
	TRZE	%06,200000
	JUMPE	%03,F4(%06)

NEXML:	AOJA	%01,PSEML		;NEXT ML

	OP	XML

	OP	XIT

	MOVEI	%11,EXIML
	JRST	0(%02)
>
IFDEF	HALFWD,
<
	DEFINE	JSB	(ADDR)	<
	HWD	660000!ADDR	>

	DEFINE	JSBT	(ADDR)	<
	HWD	700000!ADDR	>

	DEFINE	JSBF	(ADDR)	<
	HWD	720000!ADDR	>

JSBML:	HRR	%03,%01
	PUSH	%04,%03

	DEFINE	JMP	(ADDR)	<
	HWD	600000!ADDR	>

	DEFINE	JMPT	(ADDR)	<
	HWD	620000!ADDR	>

	DEFINE	JMPF	(ADDR)	<
	HWD	640000!ADDR	>

JMPML:	HRRZ	%01,%02

PSEML:	LDB	%02,[POINT 17,%01,34]	;GET FULL WORD ADDRESS
	TRNE	%01,1			;TEST HALF
	SKIPA	%02,POPMEM(%02)		;RIGHT HALF
	HLRZ	%02,POPMEM(%02)		;LEFT HALF
PSEML1:

IFDEF	DEBUG, <
	SKIPE	DEBSW
	PUSHJ	%17,DBEML>

	LDB	%06,[POINT  2,%02,19]	;GET FLAGS
	XCT	PSETBL(%06)		;TEST FLAGS
	LDB	%06,[POINT  7,%02,26]	;SET OP-CODE
	ANDI	%02,000777		;MASK ADDRESS
PSDISP:	IDIVI	%06,3
	LDB	%06,PSOTBL(%07)		;GET F4 ADDRESS
	JRST	F4(%06)

PSETBL:	JFCL				;NO FLAGS SET
	JUMPN	%03,NEXML		;FORGET IF TRUE
	JUMPE	%03,NEXML		;FORGET IF FALSE
	JRST	EXTADR			;EXTENDED ADDRESS

PSOTBL:	POINT	12,OPJTBL(%06),11
	POINT	12,OPJTBL(%06),23
	POINT	12,OPJTBL(%06),35
	DEFINE	XML	(ADDR)	<
	HWD	760000!<ADDR-F4>>

	DEFINE	XMLT	(ADDR)	<
	HWD	770000!<ADDR-F4>>

	DEFINE	XMLF	(ADDR)	<
	HWD	764000!<ADDR-F4>>

	SYN	XML,	XIT
	SYN	XMLT,	XITT
	SYN	XMLF,	XITF

EXTADR:					;EXTENDED ADDRESS
	LDB	%06,[POINT 3,%02,22]	;GET OP-CODE
	ANDI	%02,017777		;MASK ADDRESS
	XCT	EXTTBL(%06)		;EXECUTE TABLE
	AOJA	%01,PSEML		;UNSATISFIED CONDITIONAL
	TRNN	%02,014000		;XIT/XML
	JRST	F4(%02)			;UNCONDITIONAL
	TRZE	%02,010000
	JUMPN	%03,F4(%02)		;TRUE
	TRZE	%02,004000
	JUMPE	%03,F4(%02)		;FALSE
NEXML:	AOJA	%01,PSEML		;DIDN'T MAKE IT

EXTTBL:	JRST	    JMPML		;JMP
	JUMPN	%03,JMPML		;JMPT
	JUMPE	%03,JMPML		;JMPF
	JRST	    JSBML		;JSB
	JUMPN	%03,JSBML		;JSBT
	JUMPE	%03,JSBML		;JSBF
	JRST	    JOWML		;JOW
	SKIPA	%11,EXIMLP		;XIT/XML (SET JSP REG)
>
P2EML:					;POW 2 EXIT ML
	POP	%05,%00
P1EML:					;POW 1 EXIT ML
	POP	%05,%00
EXIML:					;EXIT ML
	POP	%04,%01
	HLRE	%03,%01
	AOJA	%01,PSEML		;POP SETUP ML

P1ETML:					;POW 1 EXIT TRUE ML
	POP	%05,%00
	JRST	ETRML			;EXIT TRUE ML
P2EFML:					;POW 2 EXIT FALSE ML
	POP	%05,%00
P1EFML:					;POW 1 EXIT FALSE ML
	POP	%05,%00
EFAML:					;EXIT FALSE ML
	TDZA	%03,%03			;ZERO WORD
ETRML:					;EXIT TRUE ML
	SETO	%03,
EXEQML:					;EXIT EQUAL ML
	POP	%04,%01
	AOJA	%01,PSEML		;POP SETUP ML
IFNDEF	HALFWD,
<
	OP	XNI
	MOVE	%10,ZZ(%02)
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	SUBI	%10,ZZ
	MOVE	%06,POPMEM+1(%01)
	HLRZ	%02,%06
	ADD	%02,%10
	AOJA	%01,PSDISP		;POP SETUP DISPATCH
>

IFDEF	HALFWD,
<
	OP	XNI
	MOVE	%10,ZZ(%02)
	PUSHJ	%17,APTML
	SUBI	%10,ZZ
	LDB	%02,[POINT 17,%01,34]
	TRNN	%01,1
	SKIPA	%02,POPMEM(%02)
	HLRZ	%02,POPMEM+1(%02)
	LDB	%06,[POINT  7,%02,26]	;SET OP-CODE
	ANDI	%02,777
	ADD	%02,%10
	AOJA	%01,PSDISP
>
IFNDEF	HALFWD,
<
	OP	FEX
	HRRZM	%02,FEXADR+ZZ		;FEX ADR
	AOJA	%01,PSEML		;POP SETUP ML
>

IFDEF	HALFWD,
<
	FEX=	OPCNT

	DEFINE	FEX	(ADDR)	<
	HWD	FEX_9!<ADDR-.>
	IF2, <IFN <ADDR-.>_-9, <PRINTX <FEX OVERFLOW - ADDR>>>>

	OPJSET	FEX

	ADD	%02,%01
	HRRZM	%02,FEXADR+ZZ
	AOJA	%01,PSEML
>
IFNDEF	HALFWD,
<
	OP	JOW
>

IFDEF	HALFWD,
<
	DEFINE	JOW	(ADDR)	<
	HWD	740000!ADDR	>
>

JOWML:	POP	%05,%00
	SOJL	%00,JMPML			;JUMP ML
	PUSH	%05,%00
	AOJA	%01,PSEML			;POP SETUP ML

	OP	EAWI
	MOVE	%02,INSTBL(%02)	;REFERENCE TABLE OF DEC10 OPERATION CODES

	OP	EAW
	PUSH	%05,%02
	AOJA	%01,PSEML			;POP SETUP ML
	OP	W5
	MOVEI	%06,-5(%05)
	JRST	WOREXI			;WORK EXIT

	OP	W4
	MOVEI	%06,-4(%05)
	JRST	WOREXI			;WORK EXIT

	OP	W3
	MOVEI	%06,-3(%05)
	JRST	WOREXI			;WORK EXIT

	OP	W2
	MOVEI	%06,-2(%05)
	JRST	WOREXI

	OP	W1
	MOVEI	%06,-1(%05)
	JRST	WOREXI

	OP	W0
	MOVEI	%06,(%05)
WOREXI:					;WORK EXIT
	EXCH	%06,%02
	SUBI	%02,ZZ
	JRST	PSDISP			;POP SETUP DISPATCH


	OP	W3I
	SKIPA	%06,-3(%05)

	OP	W2I
	MOVE	%06,-2(%05)
	JRST	W0IXIT

	OP	W1I
	SKIPA	%06,-1(%05)

	OP	W0I
	MOVE	%06, 0(%05)
W0IXIT:	EXCH	%06,%02
	JRST	PSDISP
	OP	XW2.0
	MOVE	%10,-2(%05)		;  FOO,XW"N"."M"  =
	JRST	XWN.0			;  XNI,W"N"
					;  "M",FOO
	OP	XW1.0
	SKIPA	%10,-1(%05)

	OP	XW0.0
	MOVE	%10,0(%05)
XWN.0:	PUSHJ	%17,APTML		;ADDRESS POINTED TO ML
	MOVE	%06,%10
	JRST	WOREXI			;WORK EXIT

	OP	XW1.1
	SKIPA	%10,-1(%05)

	OP	XW0.1
	MOVE	%10,0(%05)
	PUSHJ	%17,APTML		;ADDRESS POINTED TO ML
	MOVEI	%06,1(%10)
	JRST	WOREXI			;WORK EXIT

	OP	XW1.2
	SKIPA	%10,-1(%05)

	OP	XW0.2
	MOVE	%10,0(%05)
	PUSHJ	%17,APTML		;ADDRESS POINTED TO ML
	MOVEI	%06,2(%10)
	JRST	WOREXI			;WORK EXIT

	OP	XW1.3
	SKIPA	%10,-1(%05)

	OP	XW0.3
	MOVE	%10,0(%05)
	PUSHJ	%17,APTML		;ADDRESS POINTED TO ML
	MOVEI	%06,3(%10)
	JRST	WOREXI			;WORK EXIT

	OP	XW0.4
	MOVE	%10,0(%05)
	PUSHJ	%17,APTML		;ADDRESS POINTED TO ML
	MOVEI	%06,4(%10)
	JRST	WOREXI			;WORK EXIT
	OP	SWT
	MOVE	%00,ZZ(%02)
	EXCH	%00,0(%05)
	MOVEM	%00,ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	DIM
	SOSA	ZZ(%02)

	OP	ZER
	SETZM	ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	NOZ
	SETOM	ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	TLY
	AOSA	ZZ(%02)

	OP	SWH
	MOVSS	ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	CLA
	POP	%05,%00

	OP	FET
	PUSH	%05,ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	STO
	POP	%05,ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	FTM
	SKIPA	%06,%03

	OP	STK
	MOVE	%06,0(%05)
	MOVEM	%06,ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

LSSIML:	POP	%05,%02

	OP	LSS
	MOVE	%00,BCDTBL(%02)
	MOVEM	%00,SYMBOL+ZZ		;SYMBOL
	SETZM	DAT1+ZZ			;DATA 1
	SETZM	DAT2+ZZ			;DATA 2
	SETZM	DAT3+ZZ			;DATA 3
	AOJA	%01,PSEML		;POP SETUP ML

	OP	POW
	POP	%05,%00
	SOJG	%02,.-1
	AOJA	%01,PSEML		;POP SETUP ML

	OP	IPK
	SKIPA	%10,(%05)

	OP	IER
	SKIPA	%10,%05
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	MOVE	%00,ZZ(%02)
	ANDCAM	%00,0(%10)
	AND	%00,ZZ+1(%02)
	ORM	%00,0(%10)
	AOJA	%01,PSEML		;POP SETUP ML
	OP	IOR
	MOVE	%00,ZZ(%02)
	ORM	%00,0(%05)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	IOM
	POP	%05,%00
	ORM	%00,ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	EOR
	MOVE	%00,ZZ(%02)
	XORM	%00,0(%05)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	EOM
	POP	%05,%00
	XORM	%00,ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	AND
	OPSAVE	AND
	MOVE	%00,ZZ(%02)
	ANDM	%00,0(%05)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	NOT
	SETCMM	ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML
	OP	MPY
	MOVE	%00,ZZ(%02)
	IMULM	%00,0(%05)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	MMY
	POP	%05,%00
	IMULM	%00,ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	DIV
	OPSAVE	DIV
	MOVE	%06,0(%05)
	IDIV	%06,ZZ(%02)
	MOVEM	%06,0(%05)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	ADD
	OPSAVE	ADD
	SKIPA	%02,ZZ(%02)

	OP	SUB
	OPSAVE	SUB
	MOVN	%02,ZZ(%02)

	OP	ADDA
	ADDM	%02,0(%05)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	SMY
	MOVNS	0(%05)

	OP	AMY
	POP	%05,%00
	ADDM	%00,ZZ(%02)
	AOJA	%01,PSEML			;POP SETUP ML
	OP	PLD
	MOVE	%06,ZZ(%02)
	MOVEM	%06,MAC1+ZZ		;MP AC1
	MOVE	%07,ZZ+1(%02)
	MOVEM	%07,MAC2+ZZ		;MP AC2
	AOJA	%01,PSEML			;POP SETUP ML

	OP	PST
	MOVE	%06,MAC1+ZZ		;MP AC1
	MOVEM	%06,ZZ(%02)
	MOVE	%07,MAC2+ZZ		;MP AC2
	MOVEM	%07,ZZ+1(%02)
	AOJA	%01,PSEML			;POP SETUP ML

	OP	PAD
	MOVE	%06,ZZ(%02)
	MOVE	%07,ZZ+1(%02)
	PUSHJ	%17,DPADD		;ADD TO MP AC ML
	AOJA	%01,PSEML			;POP SETUP ML
	OP	SNZ
	SKIPE	%03,ZZ(%02)
	SETO	%03,
	AOJA	%01,PSEML			;POP SETUP ML

	OP	SEK
	SKIPA	%03,(%05)

	OP	SEQ
	POP	%05,%03
	EQV	%03,ZZ(%02)
	CAME	%03,AONLOW		;ALL ONES LOWER
	SETZ	%03,
	AOJA	%01,PSEML			;POP SETUP ML

	OP	ART
	HRRZ	%10,ZZ(%02)		;GET RH OF ADRRESS
	TRC	%10,070016		;COMPLEMENT BITS OF REG 15 PNTR
	TRNN	%10,770000		;WAS IT A REG POINTER ?
	TRNN	%10,007777		;YES, NOT POINTING TO DO REG ?
	JRST	SETFAL		;NO, SET FLAG FALSE & RETURN TO POP LANGUAGE
	MOVE	%10,ZZ(%02)		;GET REGISTER POINTER AGAIN
	PUSHJ	%17,APTML		;CALCULATE ACTUAL ADDRESS
	MOVE	%10,0(%10)		;GET CONTENTS OF REG POINTER
	LDB	%07,PHEBYT		;GET ROLL #
	CAIN	%07,27		;POINTS TO TEMP. ROLL ?
	TLZE	%10,020000		;YES, HAS REG CONTENTS CHANGED ? (INITIAL TEMP TRAIT)
	JRST	SETTRU		;NO, SET FLAG TRUE AND RETURN
	MOVEM	%10,ZZ(%02)		;YES, CHANGE REG POINTER TO TEMP. PNTR
	JRST	SETFAL		;SET FALSE AND RETURN
	OP	SGK
	SKIPA	%06,(%05)

	OP	SGT
	POP	%05,%06
	CAMG	%06,ZZ(%02)
SETFAL:	TDZA	%03,%03
SETTRU:	SETO	%03,
	AOJA	%01,PSEML			;POP SETUP ML

	OP	SLK
	SKIPA	%06,(%05)

	OP	SLT
	POP	%05,%06
	CAML	%06,ZZ(%02)
	JRST	SETFAL
	JRST	SETTRU

	OP	SMK
	SKIPA	%03,0(%05)

	OP	SME
	POP	%05,%03
SOMEML:					;SET ON MASKED EQ ML
	EQV	%03,ZZ+1(%02)
	ORCM	%03,ZZ(%02)
	CAME	%03,AONLOW		;ALL ONES LOWER
	SETZ	%03,
	AOJA	%01,PSEML			;POP SETUP ML

	OP	SPK
	SKIPA	%10,(%05)

	OP	SPT
	POP	%05,%10
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	SKIPA	%03,0(%10)

	OP	SON
	MOVE	%03,-1(%05)
	JRST	SOMEML			;SET ON MASKED EQ ML
	OP	SCE
	CAIE	%02,0(%14)
	JRST	SETFAL
	JRST	SETTRU

	OP	CSA
	SETO	%03,
	CAIE	%02,0(%14)
	TDZA	%03,%03
CSAXIT:	PUSHJ	%17,NCHML		;NEXT CHAR ML
	AOJA	%01,PSEML			;POP SETUP ML

	OP	SCK
	TLNN	%14,0(%02)
	JRST	SETFAL
	JRST	SETTRU

	OP	CSF
	CAIN	%02,0(%14)
	JRST	CSAXIT

NFAML:					;NOTE FAIL ML
	MOVEI	%02,S1QT
	JSP	%11,CCEML

FAIML:					;FAIL ML
	JSP	%11,RELML
	MOVE	%01,FEXADR+ZZ
	JRST	PSEML

	OP	QSF
	MOVE	%12,%03
	PUSHJ	%17,QSAML		;QSA ML
	JUMPE	%03,QSF1			;$1
	MOVE	%03,%12
	AOJA	%01,PSEML			;POP SETUP ML

QSF1:	MOVE	%07,QFACCN+ZZ		;QSA FAIL CCNS
	HRRZI	%02,S2QT		;SYNTAX QT	;"23N"
	JSP	%11,LCEML1		;LCE ENTRY
FAIMLP:	JRST	FAIML			;FAIL ML
	OP	QSA
	PUSH	%17,NEXMLP		;NEXT ML
QSAML:					;QSA ML
	JSP	%11,LAPSML		;LOOK AHEAD POSITION SAVE ML
	MOVEI	%07,QTTBL(%02)	;REFERENCE TABLE OF ALL FORTRAN 'RESERVED WORDS'
	HRLI	%07,(POINT 6,,)
	TDZA	%03,%03
QSAML1:	PUSHJ	%17,NCHML
	ILDB	%02,%07
	CAIN	%02,EOF
	SOJA	%03,POPJML
	CAIN	%02,0(%14)
	JRST	QSAML1			;$1
	MOVE	%00,CARNUM+ZZ		;CARD-COL NUMBERS
	CAMN	%14,CSTAT+CRR		;CARRIAGE RETURN WITH KEYS
	MOVE	%00,LACCCN+ZZ		;LAST ACTIVE CCNS
	MOVEM	%00,QFACCN+ZZ		;QSA FAIL CCNS
	JSP	%11,LAPRML		;LOOK AHEAD POSITION RESET ML
	POPJ	%17,
	OP	FPC
	MOVE	%10,ZZ(%02)
	MOVE	%00,LACCCN+ZZ
	DPB	%00,[POINT 7,%10,17]
	HLRZS	%00
	DPB	%00,[POINT 5,%10,10]
	PUSH	%05,%10
	AOJA	%01,PSEML		;POP SETUP ML

PRNML:	TROA	%02,N0			;PRINT NUMERIC
	OP	PRC
	PUSH	%17,NEXMLP		;NEXT ML
PCHML:					;PRINT CHAR ML
IFNDEF	FILE0,			;"23B"
<	MOVE	%15,CARBUF	;"23D"
	TRZE	%15,1		;"23D"
	TRO	%16,HDRBIT	;"23D"
	MOVEM	%15,CARBUF	;"23D"
>				;"23B"
	SKIPE	ERRFLA+ZZ
	JRST	ERROUT
IFNDEF	FILE0,
<
	SKIPN	MACSW+ZZ	;SUPRESS LISTING ?
>
	TLNE	%16,LSTFLG	;IS THERE A LISTING ?
	POPJ	%17,		;NO LISTING,RETURN
	JRST	LSTOUT		;YES,LIST IT OUT

	OP	PRQ
	MOVEI	%07,QTTBL(%02)
	TLOA	%07,(POINT 6,,)
PRQML1:	PUSHJ	%17,PCHML
	ILDB	%02,%07
	CAIE	%02,EOF
	JRST	PRQML1
	AOJA	%01,PSEML

	OP	PCOL
	SKIPLE	REGSAV+ZZ	;A RANDOM UNUSED LOCATION
	JRST	PCOL1
	MOVE	%02,ZZ(%02)	;GET TABLE OFFSET
	HRRZ	%10,CSETBL(%02)	;GET NO. OF COLUMNS FOR NON TTY DEVICE
	TLNE	%16,TTYFLG	;LISTING TO TELETYPE ?
	HLRZ	%10,CSETBL(%02)	;YES, GET NO. OF COLUMNS FOR TTY
	MOVEM	%10,REGSAV+ZZ
PCOL1:	MOVEI	%02,TAB
	SOSG	REGSAV+ZZ
	MOVEI	%02,CRR
	PUSHJ	%17,PCHML
	AOJA	%01,PSEML
CSETBL:	XWD	3,5		;0 - ZER0
	XWD	^D9,^D15	;1 - ONE

	OP	ERK
	SKIPA	%10,(%05)

	OP	ERM
	POP	%05,%10
	PUSH	%17,NEXMLP

ERMML:					;ERK ENTRY
	HLLM	%03,0(%17)
	TLZ	%10,770000
	HRR	%10,%02
	MOVEM	%10,ERRBOX+ZZ		;ERROR BOX
	MOVEI	%02,ESEFIL		;ERROR SEARCH FILE
	PUSHJ	%17,REGML
	SKIPN	%03
	PUSHJ	%17,OERML		;ORDER ERRORS ML
	HLRE	%03,0(%17)
	POPJ	%17,

	OP	LCE
	SKIPA	%11,NEXMLP

	OP	LCF
LCFML:	MOVEI	%11,FAIML
	JRST	LCEML

	OP	CCE
	SKIPA	%11,NEXMLP

	OP	CCF
	MOVEI	%11,FAIML
CCEML:					;CCE ML
	MOVE	%07,CARNUM+ZZ		;CARD-COL NUM
	CAMN	%14,CSTAT+CRR
LCEML:	MOVE	%07,LACCCN+ZZ		;LAST ACTIVE CCN
LCEML1:					;LCE ENTRY
	CAMGE	%07,FAICAR+ZZ		;FAIL CARD-C
	JRST	0(%11)
	MOVEM	%02,ERRMSG+ZZ		;FOR SMALL COMPILER
	MOVEM	%07,FAICAR+ZZ		;FAIL CARD-C
	HRL	%02,%07
	LSH	%07,-^D11
	TLO	%02,0(%07)
	MOVEM	%02,FMSBOX+ZZ		;FAIL MSG BOX
	JRST	0(%11)
	OP	RSV
	MOVE	%10,TOPS(%02)		;TOPS
	SUB	%10,ANCHOR(%02)		;ANCHOR
	PUSHJ	%17,P1ORML		;PUT 10 ON ROLL ML
	MOVE	%10,BOTTOM(%02)		;BOTTOM
	MOVEM	%10,TOPS(%02)		;TOPS
	AOJA	%01,PSEML		;POP SETUP ML

	OP	MON
	POP	%05,%10
	PUSHJ	%17,P1ORML		;PUT 10 ON ROLL ML
	AOJA	%01,PSEML			;POP SETUP ML

	OP	MOA
	MOVE	%06,BOTTOM(%02)		;BOTTOM
	CAMG	%06,TOPS(%02)		;TOPS
	JRST	SETFAL
	PUSH	%05,0(%06)
	SOS	BOTTOM(%02)		;BOTTOM
	JRST	SETTRU

	OP	SRD
	PUSH	%17,NEXMLP
SRDML:					;SRD ML
	MOVE	%03,TOPS(%02)		;TOPS
	SUB	%03,BOTTOM(%02)		;BOTTOM
	ASH	%03,-^D35
	POPJ	%17,

	OP	CNT
	MOVE	%10,BOTTOM(%02)		;BOTTOM
	SUB	%10,TOPS(%02)		;TOPS
	PUSH	%05,%10
	AOJA	%01,PSEML			;POP SETUP ML
	OP	CAR
				;COPY AND RELEASE
	PUSHJ	%17,FROML
	MOVE	%12,BOTTOM(%02)
	SUB	%12,TOPS(%02)
	JUMPE	%12,CAR2
CAR1:	MOVE	%10,@BOTTOM(%02)
	SOS	BOTTOM(%02)
	EXCH	%02,0(%05)
	PUSHJ	%17,P1ORML
	EXCH	%02,0(%05)
	SOJG	%12,CAR1
CAR2:	POP	%05,%00

	OP	REL

	MOVE	%10,TOPS(%02)
	MOVEM	%10,BOTTOM(%02)
	CAMG	%10,ANCHOR(%02)
	AOJA	%01,PSEML
	SOS	BOTTOM(%02)
	MOVE	%10,0(%10)
	ADD	%10,ANCHOR(%02)
	MOVEM	%10,TOPS(%02)
	AOJA	%01,PSEML

IFNDEF	FILE0,			;"23B"
<	;3 JOBDAT DEFINITIONS CHANGED TO EXTERNAL "25-1"
PDLOV:	AOS	.JBERR		;INFORM CCL OF ERROR	;"23J"
	HRRZ	%11,.JBTPC	;GET LOCATION OF ERROR	;"23J"
	MOVE	%10,.JBCNI	;GET JOB STATUS WORD	;"23J"
	TRNN	%10,020000	;WAS THERE AN ILL MEM REF ?	;"23J"
	JRST	PDLOV1		;NO, IT WAS A PDL OV	;"23J"
	JSP	%10,ERROR	;PRINT ERROR AND GET NEXT SOURCE FILE	;"23J"
	SIXBIT /ILLEGAL MEMORY REFERENCE AT 6_COMPILATION TERMINATED]/	;"23J"
PDLOV1:	JUMPL	%17,PDLOV2	;WORK STACK OK ?	;"23J"
	MOVE	%17,PDPSET	;NO, RESET TO ZERO	;"23J"
	JSP	%10,ERROR	;PRINT ERROR AND GET NEXT SOURCE FILE	;"23J"
	SIXBIT /WORK STACK OVERFLOW AT 6_COMPILATION TERMINATED]/	;"23J"
PDLOV2:	MOVEI	%02,LCFML	;SIMULATE AN 'LCF    (M8QT)'	;"23J"
	HRRM	%02,.JBTPC	;"23J"
	MOVEI	%02,M8QT	;WHEN A PDL OV OCCURS	;"23J"
	SKIPL	%00,%04		;WAS IT THE EXIT ROLL ?	;"23J"
	MOVEI	%02,M18QT	;YES, MAKE SPECIFIC ERROR	;"23J"
	JRSTF	@.JBTPC		;"23J"
>				;"23B"
	OP	DNG
	PUSH	%17,NEXMLP

DNGML:				;DOWN TO NEXT GROUP ML
	SKIPE	%10,ROLPNT+ZZ(%02)	;SEE IF ANYTHING ON ROLL
	AOJA	%10,DNGML1		;YES, POINT TO NEXT ATOM IN CURRENT GROUP
	PUSHJ	%17,TPNML		;NO, GO GENERATE BOGUS ONE   ;TYPE POINTER ML

DNGML1:	MOVEM	%10,ROLPNT+ZZ(%02)	;SAVE NEW POINTER
	MOVEM	%10,CREPNT+ZZ
	PUSHJ	%17,APTML		;GO GET ABSOLUTE TOPS+SIZE INTO %10
	CAMG	%10,BOTTOM(%02)		;SEE IF ANYTHING ON ROLL
	TDOA	%03,AONLOW		;NO, TURN ON TRUE
	SETZB	%03,ROLPNT+ZZ(%02)	;YES, SET FALSE
	POPJ	%17,

	OP	FLP
	PUSH	%17,NEXMLP
FROML:				;FLIP ML
	MOVE	%07,BOTTOM(%02)
	MOVE	%10,TOPS(%02)
FROML1:	ADDI	%10,1
	CAMG	%07,%10
	POPJ	%17,
	MOVE	%00,0(%10)
	EXCH	%00,0(%07)
	MOVEM	%00,0(%10)
	SOJA	%07,FROML1
	OP	LGA
				;LOAD GROUP WITH ANSWER
	PUSHJ	%17,SRDML
NEXMLP:	JUMPE	%03,NEXML
	SETZ	%12,
	LDB	%10,RGRPNT	;ROLL GROUP SIZE POINTER
LGA1:	SOS	%06,BOTTOM(%02)
	MOVE	%00,1(%06)
	MOVEM	%00,SYMBOL+ZZ(%12)
	ADDI	%12,1
	SOJG	%10,LGA1
	SKIPN	SYMBOL+ZZ
	SETZ	%03,
	AOJA	%01,PSEML

	OP	NOG
	PUSHJ	%17,NOGML
	PUSH	%05,%10
	AOJA	%01,PSEML

NOGML:				;NUMBER OF GROUPS ML
	MOVE	%10,BOTTOM(%02)
	SUB	%10,TOPS(%02)
	LDB	%06,RGRPNT	;ROLL GROUP SIZE
	IDIV	%10,%06		;RESULT TO %10
	POPJ	%17,

	OP	PNG
	PUSHJ	%17,PNGML
	PUSH	%05,%10
	AOJA	%01,PSEML

PNGML:				;POINTER TO NEW GROUP ML
	PUSHJ	%17,NOGML		;NUMBER OF GROUPS ML

TPNML:				;TYPE POINTER ML
	ADDI	%10,1
	DPB	%02,PHEBYT		;[POINT 6,%10,23] INSERT ROLL # INTO POINTER
	TRNE	%10,100000		;FOR ROLLS 10-17
	TRNE	%10,200000		;AND 50-57 ...
	CAIA
	DPB	%02,[POINT 3,%10,2]	;WE WANT ROLL # AS TYPE BITS
	MOVEM	%10,ROLPNT+ZZ(%02)	;GENERATE CURRENT ROLL POINTER
	POPJ	%17,

	OP	DFA
	PUSHJ	%17,DNGML		;GO GET NEXT ATOM POINTER
	JUMPE	%03,NEXML		;EXIT IF NOTHING ON ROLL
	PUSH	%05,0(%10)		;OTHERWISE PUSH IT ONTO WORK
	AOJA	%01,PSEML
	OP	CFP
	POP	%05,%10
	HRR	%12,%10
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	MOVN	%06,0(%10)
	JUMPE	%06,NEXML			;NEXT ML
	SUB	%10,%06
	SUB	%12,%06
	HRL	%12,%06
CFP2:	MOVE	%10,0(%10)
	PUSHJ	%17,P1ORML		;PUT 10 ON ROLL ML
	SUBI	%12,2
	AOBJP	%12,NEXML		;$1
	HRRZ	%10,%12
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	JRST	CFP2			;$2
	OP	AGF
	MOVE	%11,FILES(%02)
	LDB	%02,UFIMLP
	LDB	%12,RGRPNT
AGF1:	SOJL	%12,NEXML
	MOVE	%10,ZZ(%11)
	PUSHJ	%17,P1ORML
	AOJA	%11,AGF1

	OP	SRA
	PUSHJ	%17,ISEML
	JUMPE	%03,NEXML
	PUSH	%05,CREPNT+ZZ
	AOJA	%01,PSEML

	OP	CSE
	LDB	%10,UFIMLP	;ROLL #
	AOS	%10,ROLPNT+ZZ(%10)
	PUSHJ	%17,APTML
	PUSH	%17,NEXMLP
	SOJA	%10,RSEML

	OP	ISE
	PUSH	%17,NEXMLP
ISEML:	LDB	%12,UFIMLP	;GET ROLL # USING FILE NUMBER IN %02
	MOVE	%10,TOPS(%12)	;GET RELATIVE START OF ROLL

RSEML:				;ROLL SEARCH ML
	LDB	%12,UFIMLP	;GET ROLL # USING FILE NUMBER IN %02
	EXCH	%02,%12		;SWAP FILE # AND ROLL #
	LDB	%06,RGRPNT	;[POINT 3,RGRSIZ(%02),2] GET ROLL GROUP SIZE
	MOVEM	%06,RGRTMP+ZZ
	MOVE	%11,FILES(%12)	;GET COMPARE COUNTS, DATA ADDRESS, AND MASK CONROL
	SETCM	%07,%11		;"23CC" NEGATE COMPARE COUNT
	TLNN	%07,77		;"23CC" SKIP UNLESS NOT 1 WORD COMPARE
	JUMPGE	%11,RSEML2	;"23CC" GO TO SPECIAL ROUTINE FOR SUBROL
	TLOA	%11,777700	;CONVERT LEFT HALF TO -COUNT OF COMPARES

RSEML1:	ADD	%10,RGRTMP+ZZ	;ADD GROUP SIZE BETWEEN GROUPS
	CAML	%10,BOTTOM(%02)	;TEST FOR END
	JRST	SEXML		;END, EXIT
	MOVE	%07,%10		;SET UP TEMP REGS ;ABSOLUTE ADDRESS OF GROUP
	MOVE	%03,%11		;ADDRESS OF COMPARISON WORD
	MOVEI	%06,1(%12)	;ADDRESS OF MASK, IF ANY
RSEML3:	MOVE	%00,1(%07)	;DATA FROM ROLL
	XOR	%00,ZZ(%03)	;DO THE COMPARE SO WE CAN MASK EASILY
	SKIPGE	FILES(%12)	;MASK?
	AND	%00,FILES(%06)	;YES, USE IT
	JUMPN	%00,RSEML1	;BRANCH ON INEQUALITY
	AOBJP	%03,MSRML	;TEST FOR END
	ADDI	%07,1		;BUMP ROLL ADDRESS
	AOJA	%06,RSEML3	;AND MASK ADDRESS
RSEML4:
	ADD	%10,RGRTMP+ZZ	;"23CC"
RSEML2:	CAML	%10,BOTTOM(%02)	;"23CC" COME HERE ONLY IF SUBROL
	JRST	SEXML		;"23CC" FINISHED
	MOVE	%00,1(%10)	;"23CC" COMPARE ONLY 2ND ATOM (A PART)
	CAME	%00,ZZ(%11)	;"23CC"
	JRST	RSEML4		;"23CC"
	JRST	MSRML		;"23CC"

;FOUND WHAT WE'RE LOOKING FOR, SET UP CURRENT POINTERS TO WHERE IT IS ON ROLL
MSRML:				;MAKE SEARCH RESULT ML
	SUB	%10,TOPS(%02)	;RESTORE RELATIVE ADDRESSING
	IDIV	%10,RGRTMP+ZZ	;AND THEN BACK TO GROUP NUMBER
	PUSHJ	%17,TPNML	;SET TYPE POINTER
	MOVEM	%10,CREPNT+ZZ	;CURRENT REG PNTR
	MOVEM	%10,ROLPNT+ZZ(%02)	;ROLL PNTR
	TDOA	%03,AONLOW	;SET TRUE ANSWER

SEXML:	SETZB	%03,ROLPNT+ZZ(%02)	;SET FALSE ANSWER
	POPJ	%17,		;EXIT

	OP	REG
	PUSH	%17,NEXMLP

REGML:				;REGISTER ML
	PUSHJ	%17,ISEML		;ROLL SEARCH ML
	JUMPN	%03,POPJML	;EXIT IF FOUND
	PUSHJ	%17,PNGML		;POINTER TO NEW GROUP ML
	MOVEM	%10,CREPNT+ZZ	;CURRENT RGE PNTR
	MOVE	%11,FILES(%12)
	LDB	%12,RGRPNT

REG1:	SOJL	%12,POPJML
	TLNN	%11,000070
	TDZA	%10,%10
	MOVE	%10,ZZ(%11)
	PUSHJ	%17,P1ORML
	AOBJN	%11,REG1
	JRST	REG1

UFIMLP:	POINT	6,FILES(%02),11
APTML:				;ADR POINTED TO ML
	LDB	%06,PHEBYT	;AC6 _ ROLL # [POINT 6,%10,23]
	ANDI	%10,7777	;AC10 _ ROLL PNTR (DISPLACEMENT)
	MOVEI	%10,-1(%10)	;AC10 _ # PREVIOUS GROUPS ;"21Z"
	HLRZ	%07,RGRSIZ(%06)	;AC7 _ BYTE (18) 0 (3) GROUP SIZE ;"21Z"
	CAIG	%07,177777	;GROUP SIZE > 1 ;"21Z"
	JRST	APTML1		;NO, AC10 = OFFSET ;"21Z"
	LSH	%07,-^D15	;AC7 _ GROUP SIZE ;"21Z"
	IMULI	%10,(%07)	;AC10 _ # PREVIOUS GROUPS * GROUP SIZE ;"21Z"
APTML1:	ADD	%10,TOPS(%06)	;AC10 _ OFFSET + ROLL BASE ADDRESS
	AOJA	%10,POPJML	;AC10 _ ADDRESS POINTED TO ;RETURN 
	OP	RPL

	POP	%05,%11
	MOVE	%00,TOPS(%11)		;TOPS
	SUB	%00,BOTTOM(%11)		;BOTTOM
	MOVN	%06,%00
	HRL	%00,%00
	HRR	%00,TOPS(%11)		;TOPS
	SKIPA	%10,TOPS(%02)		;TOPS
RPLML1:	ADD	%10,0(%10)
	ADDI	%10,1
	CAMLE	%10,BOTTOM(%02)		;BOTTOM
	JRST	RPLML4			;$4
	CAME	%06,0(%10)
	JRST	RPLML1			;$3
	MOVE	%12,%00
	MOVEM	%10,1(%05)
RPLML2:	AOS	%07,1(%05)
	MOVE	%07,0(%07)
	CAME	%07,1(%12)
	JRST	RPLML1			;$3
	AOBJN	%12,RPLML2		;$2
	SUB	%10,TOPS(%02)		;TOPS
	DPB	%02,PHEBYT		;PNTR HEAD BYTE
	PUSH	%05,%10
	AOJA	%01,PSEML

RPLML4:	SUB	%10,TOPS(%02)		;TOPS
	DPB	%02,PHEBYT		;PNTR HEAD BYTE
	PUSH	%05,%10
	HLLZ	%12,%00
	MOVE	%10,%06
	PUSHJ	%17,P1ORML		;PUT 10 ON ROLL ML
RPLML5:	MOVE	%10,TOPS(%11)		;TOPS
	ADDI	%10,1(%12)
	MOVE	%10,0(%10)
	PUSHJ	%17,P1ORML		;PUT 10 ON ROLL ML
	AOBJN	%12,RPLML5		;$5
	AOJA	%01,PSEML
ASBCML:					;ASCII TO BCD
	POP	%05,%00
	MOVSI	%07,(POINT 7,%00,)
ASCBC1:	ILDB	%02,%07
	JUMPE	%02,NEXML
	SUBI	%02,40
	PUSHJ	%17,PCHML
	TLNE	%07,760000
	JRST	ASCBC1
	AOJA	%01,PSEML

LAPSML:					;LOOK AHEAD POSITION SAVE ML
	MOVEM	%13,LA1S13+ZZ		;LOOK AHEAD 13 SAVE
	MOVEM	%14,LA1S14+ZZ		;LOOK AHEAD 14 SAVE
	MOVE	%00,LAPBLT
	BLT	%00,LAPEND+ZZ
	JRST	0(%11)

LAPRML:					;LOOK AHEAD POSITION RESET ML
	MOVE	%13,LA1S13+ZZ		;LOOK AHEAD 13 SAVE
	MOVE	%14,LA1S14+ZZ		;LOOK AHEAD 14 SAVE
	MOVS	%00,LAPBLT
	BLT	%00,LACCCN+ZZ
	JRST	0(%11)

LAPBLT:	XWD	ESTFLA+ZZ,LAPTMP+ZZ
OPSCML:
	HLRS	%10,OPCPNT+ZZ
	PUSHJ	%17,APTML
	LDB	%12,[POINT 6,0(%10),5]
OPSCA1:	SOJL	%12,SETFAL
	AOS	%10,OPCPNT+ZZ
	PUSHJ	%17,APTML
	LDB	%02,[POINT 6,0(%10),17]
	ADDI	%02,OQTTBL
	PUSHJ	%17,QSAML
	JUMPE	%03,OPSCA1
	AOJA	%01,PSEML

DESML:					;DESCEND ML
	HLRZ	%10,OPCPNT+ZZ		;OP PNTR
	JUMPE	%10,SIOPML		;SET INITIAL OP PNTR ML
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	LDB	%10,[POINT 6,0(%10),5]
	ADDI	%10,1
	HLRS	OPCPNT+ZZ		;OP PNTR
	ADDB	%10,OPCPNT+ZZ		;OP PNTR
	HRLM	%10,OPCPNT+ZZ		;OP PNTR
EXIMLP:	JRST	EXIML			;EXIT ML
PHCML:					;PACK HOL CHAR ML
	CAIN	%14,TAB
	MOVEI	%14,-27			;ASCII SPACE(40) - ASCII TAB(11)
	MOVEI	%00," "(%14)
	IDPB	%00,HBUIND+ZZ
	LDB	%03,[POINT 5,HBUIND+ZZ,4]
	JUMPN	%03,SETTRU
	AOJA	%01,PSEML
DPADD:					;ADD TO MP AC FIN ML
	ADDB	%06,MAC1+ZZ		;MP AC 1
DPADD1:	JFCL	17,.+1
	ADDB	%07,MAC2+ZZ		;MP AC 2
	JFCL	02,.+2
	POPJ	%17,
	AOS	%06,MAC1+ZZ		;MP AC 1
	POPJ	%17,

CDAAML:					;CONV DIGIT AND ADV ML
CDAAM1:	MOVEI	%10,^D10		;CONST BASE BOX
	CAIG	%10,-N0(%14)
	JRST	EXIML			;EXIT ML
	AOS	NDISCA+ZZ		;NUM DIGITS SCANN
	MOVE	%06,MAC1+ZZ		;MP AC 1
	TLNE	%06,760000
	JRST	CDAAM3
	AOS	DUSCNT+ZZ		;DIGITS USED CN
	MOVE	%07,MAC2+ZZ		;MP AC 2
	ASHC	%06,3
	MOVEM	%06,MAC1+ZZ		;MP AC 1
	MOVEM	%07,MAC2+ZZ		;MP AC 2
	ASHC	%06,-2
	CAIN	%10,^D10
	PUSHJ	%17,DPADD		;ADD TO MP AC FIN ML
	MOVEI	%07,-N0(%14)
	PUSHJ	%17,DPADD1
CDAAM3:	PUSHJ	%17,NCHML
	JRST	CDAAM1
ASCML:					;ASCEND ML
	HLRZ	%10,OPCPNT+ZZ		;OP PNTR
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	LDB	%10,[POINT 12,0(%10),17]
	JUMPE	%10,SOPML		;SET OP PNTR ML
	TRO	%10,640000
	TLOA	%10,0(%10)
SIOPML:					;SET INITIAL OP PNTR ML
	MOVE	%10,[XWD 640001,640001]	;INITIAL OP PNTR
SOPML:					;SET OP PNTR ML
	MOVEM	%10,OPCPNT+ZZ		;OP PNTR
	JRST	EXIML			;EXIT ML

SSCML:					;SUBORD SCAN ML
	HLRZ	%10,OPCPNT+ZZ		;OP PNTR
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	LDB	%10,[POINT 6,0(%10),35]
	HRRZ	%01,SSATBL(%10)		;SUBORD SCAN ADR TB
	JRST	PSEML			;POP SETUP ML

OSRML:					;ORDER SUBORDS ROLL ML
	POP	%05,%10
	MOVEI	%02,SUDROL		;SUBORDS ROLL
	PUSHJ	%17,P1ORML		;PUT 10 ON ROLL ML
	MOVEI	%07,377777
	MOVSI	%06,(CAMG %10,%00)
	PUSHJ	%17,OROML		;ORDER ROLL ML
	PUSH	%05,@BOTTOM(%02)
	SOS	BOTTOM(%02)		;BOTTOM
	AOJA	%01,PSEML
OER0ML:					;ORDER ERRORS ML
	PUSH	%17,NEXMLP
OERML:	MOVEI	%02,ERRROL		;ERROR ROLL
	MOVSI	%07,7777
	MOVSI	%06,(CAML %10,%00)
OROML:					;ORDER ROLL ML
	MOVE	%11,TOPS(%02)		;TOPS
	SUB	%11,BOTTOM(%02)		;BOTTOM
	MOVE	%12,BOTTOM(%02)		;BOTTOM
	MOVE	%10,0(%12)

OROML1:	AOJGE	%11,POPJML
	MOVE	%00,-1(%12)
	AND	%10,%07
	AND	%00,%07
	XCT	%06
	POPJ	%17,
	MOVE	%10,-1(%12)
	EXCH	%10,0(%12)
	MOVEM	%10,-1(%12)
	SOJA	%12,OROML1

OGRML:					;OP GEN RUN ML
	TDZA	%02,%02
REDIML:					;REL DISP ML
	MOVEI	%02,RELDST-OGATBL-3
	POP	%05,%10
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	ADD	%02,0(%10)
	ANDI	%02,007777		;DISPL MASK
	HRRZ	%01,OGATBL(%02)		;OP GEN ADR TBL
	JRST	PSEML			;POP SETUP ML

GRUML:					;GEN RUN ML
	LDB	%10,[POINT 5,0(%05),23]	;GEN PNTR HD BYTE
	SKIPGE	%10		;IS ROLL OUT OF RANGE "22A"
	JRST	SYSERR
	CAILE	%10,APNROL
	JRST	SYSERR
	HLRZ	%01,PGATBL-RORBAS(%10)	;PNTR GEN ADR TBL
	JRST	PSEML			;POP SETUP ML

SYSERR:				;SYSTEM ERROR
	HRRZI	%02,M17QT	;SYSTEM ERROR - ROLL OUT OF RANGE
	JRST	LCFML		;LAST COLUMN FAIL ML
BOSML:					;BINARY ORDER SELECT ML

	MOVE	%06,-1(%05)
	MOVE	%07,0(%05)
	ANDI	%06,377777
	ANDI	%07,377777
	CAMG	%06,%07
	AOJA	%01,PSEML
	MOVE	%06,-1(%05)
	EXCH	%06,0(%05)
	MOVEM	%06,-1(%05)
	SETCMM	-2(%05)
	AOJA	%01,PSEML
	XWD	RPNGEN,RPNGEN	;"22A"
	XWD	0,0		;"22A"
	XWD	0,0		;"22A"
	XWD	0,0		;"22A"
	XWD	0,0		;"22A"
	XWD	0,0		;"22A"
PGATBL:				;PNTR GEN ADR TBL
	XWD	EXIT,0
OGATBL:					;OP GEN ADR TBL
	XWD	RPNGEN,XORGEN	;REG PNTR GEN,XOR GEN
	XWD	CPNGEN,ORGEN	;CONST PNTR GEN,OR GEN
	XWD	CPNGEN,ANDGEN	;CONST PNTR GEN,AND GEN
	XWD	CPNGEN,RGFNLI	;CONST PNTR GEN,REL GEN FOR
	XWD	CPNGEN,RGFNLI	;CONST PNTR GEN, NOT LOGICAL IF
	XWD	CPNGEN,RGFNLI	;CONST PNTR GEN,(DITTG
	XWD	CPNGEN,ASUGEN	;CONST PNTR GEN,ADD SUB GEN
	XWD	CPNGEN,MPYGEN	;CONST PNTR GEN,MPY GEN
	XWD	CPNGEN,DIVGEN	;CONST PNTR GEN,DIV GEN
	XWD	VPNGEN,EXPGEN	;VAR PNTR GEN,EXPON GEN
SSATBL:					;SUBORD SCAN ADR TBL
	XWD	VPNGEN,SUSCAN	;VAR PNTR GEN,SUBEXP SCAN
	XWD	VPNGEN,LUNSCA	;VAR PNTR GEN,LOGICAL UNARY SCAN
	XWD	VPNGEN,ELESCA	;VAR PNTR GEN,ELEMENT SCAN
	XWD	ARPGEN,EQVGEN	;ARRAY REF PNTR GEN,EQV GEN
	XWD	FRPGEN,0	;FUNC REF PNTR GEN,0
	XWD	TPNGEN,SSUSCA	;TEMP PNTR GEN,SIGNED SUBEXP SCAN
RELDST:					;RELATIONAL DISP TBL
	XWD	TPNGEN,EQNEGE	;TEMP PNTR GEN,EQ NE GEN
	XWD	SUBGEN,GTLTGE	;SUBEXP GEN,GT LT GEN
	XWD	VPNGEN,GELEGE	;VAR PNTR GEN,GE LE GEN
	OP	POC
	MOVE	%10,INSTBL(%02)
	PUSHJ	%17,P1OCML		;PUT 10 ON CODE ROLL ML
	AOJA	%01,PSEML			;POP SETUP ML

	OP	BRI
	MOVE	%12,INSTBL(%02)
	MOVE	%07,0(%05)
	MOVEI	%11,NEXML		;NEXT ML
	JRST	BARFML			;BUILD ABS REF FIN ML

	OP	BAK
	SKIPA	%10,(%05)

	OP	BAI
	POP	%05,%10		;SAVE W0
	LDB	%07,[POINT 4,INSTBL(%02),^L<Z 1,>]	;GET AC# FROM DEC10 INSTRUCTION
	ADD	%07,[7070001]	;GENERATE REGROL POINTER TO THAT ACCUMULATOR
	PUSH	%05,%07		;PUT IT AT W1
	PUSH	%05,%10		;AND PUT W0 BACK
	JRST	BUIML		;BUILD ML  TO NORMAL BUILD ROUTINE

	OP	BLK
BLKML:	HLLZ	%06,INSTBL(%02)
	PUSH	%05,%06
	MOVE	%06,@INSTBL(%02)
	MOVEM	%06,SYMBOL+ZZ		;SYMBOL
	MOVEI	%02,BLKPL			;BLK PL
	JRST	JSBML			;JSB ML
	OP	BTY
	JSP	%11,PTMML		;PNTR TYPE MOD ML

BINIML:	POP	%05,%02

	OP	BIN
	MOVE	%00,-1(%05)
	EXCH	%00,0(%05)
	PUSH	%05,%00
	JRST	BUIML			;BUILD ML

	OP	BTK
	JSP	%11,PTMML		;PNTR TYPE MOD ML

BIKIML:	POP	%05,%02

	OP	BIK
	PUSH	%05,-1(%05)
	PUSH	%05,-1(%05)
	MOVE	%00,0(%05)

BUIML:					;BUILD ML
	MOVE	%02,INSTBL(%02)		;GET ACTUAL DEC10 INSTRUCTION PATTERN
	TLNN	%02,777777		;SKIP IF IT DOESN'T DEPEND ON KA VS KI
	JUMPN	%02,[ADD %02,PDPSWZ	;INDEX AGAIN BY MACHINE TYPE "25-1"
		JRST BUIML ]		;AND GO GET NEW CODE "25-1"
	TRNE	%02,777777		;IF ADDRESS NOT NULL
	JRST	BBSLML			;BUILD BY SR LINK ML
	MOVM	%06,%02		;SAVE PATTERN W/O SIGN BIT
	HRRI	%02,BUIINS		;SET UP POP ADDRESS FOR JSB INTRUSION
	SKIPGE	%02		;SEE IF WILL GEN MORE THAN 1 WORD
	MOVEI	%02,DOUBUI		;YES, ALTER JSB ADDRESS TO DOUBLE
	EXCH	%06,-1(%05)		;END UP WITH PATTERN IN W2
	EXCH	%06,0(%05)		;   AND REGISTER POINTER IN W1
	ANDCMI	%06,400000
	PUSH	%05,%06		;   AND DATA POINTER IN W0
	JRST	JSBML			;JSB ML   GO FUDGE A JSB TO POP 45 OR 32
BBSLML:					;BUILD BY SR LINK ML
	MOVE	%07,INSTBL+.PSHJ1
	EXCH	%07,-1(%05)
	SUBI	%07,1
	ANDI	%07,17
	TRNN	%02,77
	LSH	%07,6
	OR	%07,%02
	MOVEM	%07,SYMBOL+ZZ		;SYMBOL
	MOVEI	%02,BSSLIN		;BUILD SYS SR LINK
	JRST	JSBML			;JSB ML

SGEML:					;SCALE GEN ML
	POP	%05,%12
	POP	%05,%06
	MOVE	%07,-1(%05)
	JRST	BARML			;BUILD ABS REF ML
PTMML:					;PNTR TYPE MOD ML
	HRLOI	%10,%05
PTMML1:	TRC	%10,-1
	LDB	%06,[POINT 3,@%10,2]
	HLLZ	%00,TSEMAT(%06)		;TYPE SELECTION MATRIX
	TLZ	%00,77
	OR	%00,[Z PTTBL+1(%10)]
	LDB	%06,%00
	JUMPE	%06,PTMML1
	ADDI	%02,-1(%06)
	JRST	1(%11)

PTTBL:					;PNTR TYPE TBL
	OCT	000011211122
	OCT	000011200034

BFIML:					;BUILD FINAL ML
	POP	%05,%06			;ADDRESS
	POP	%05,%07			;REGISTER
	POP	%05,%12			;INSTRUCTION
	XORI	%06,070000		;CLEAR ROLL NUMBER FIELD IF REG PNTR
	TRNN	%06,370000		;DOES IT LOOK LIKE A REG PNTR ?
	TLNN	%06,7			;YES,IS IT REALLY A REG OR JUST A CONSTANT
	SOJA	%07,CAMOCM		;NO, NOT A REG - CONSTRUCT AND MOVE ON CODE ROLL
	TRZN	%06,400000		;SECOND INSTRUCTION OF A DOUBLE BUILD ?
	SUBI	%06,1			;NO,CORRECT OFFSET
BARML:					;BUILD ABS REF ML
	HRR	%12,%06			;PUT ADDRESS INTO INSTR. E FIELD
BARFML:					;BUILD ABS REF FIN ML
	SUBI	%07,1			;CORRECT REGISTER OFFSET
	DPB	%07,[POINT 4,%12,12]	;INST AC BYTE
	MOVE	%10,INSTBL+ABSINS	;[-1,,500001]
BARFMX:	PUSHJ	%17,P1OCML
BARFMY:	MOVE	%10,%12
	PUSH	%17,%11		;%11 SET TO JRST EXIML AT EXTTBL+7
P1OCML:	MOVEI	%02,CODROL
	JRST	P1ORML
CAMOCM:					;CONSTRUCT AND MOVE ON CODE ML
	XORI	%06,070000
	HRR	%12,%06
	DPB	%07,[POINT 4,%12,12]	;INST AC BYTE
	JRST	BARFMY

ITDFML:					;ISOLATE TYPE IN DISPL FIELD ML
	LDB	%00,[POINT 3,0(%05),2]
	MOVEM	%00,0(%05)
	AOJA	%01,PSEML

B2RML:					;BUILD 2ND REF ML
	POP	%05,%12
	HLLO	%12,INSTBL(%12)
	TLO	%12,37
	MOVE	%07,@BOTTOM+CODROL	;BOTTOM
	TLZ	%07,777000
	TRNE	%07,400000
	AOJA	%07,B2RML1		;$1
	TRNE	%07,770000
	TROA	%07,400000
	AOJA	%07,B2RML1		;$1
	ADD	%12,%07
	AOJA	%12,BARFMY		;PUT 10 ON ROLL ML

B2RML1:	ADD	%12,%07
	MOVE	%10,INSTBL+ABSINS
	AOJA	%12,BARFMX
MFPML:					;MAKE FL POWER ML
	LDB	%06,[POINT 8,0(%05),8]
	SUBI	%06,201
	MOVEM	%06,0(%05)
	JRST	ETRML			;EXIT TRUE ML
FP2CML:					;FX POWER OF 2 CHECK ML
	MOVE	%06,DAT1+ZZ		;DATA 1
	JUMPE	%06,EFAML			;EXIT FALSE ML
	SETZB	%07,%00
FPO2C1:	LSHC	%06,-1
	CAIL	%07,0
	AOJA	%00,FPO2C1		;$1
	JUMPN	%06,EFAML			;EXIT FALSE ML
	PUSH	%05,%00
	JRST	ETRML			;EXIT TRUE ML
BSLML:					;BUILD SWITCHED LOAD ML
	POP	%05,%06
	MOVE	%06,INSTBL(%06)
	MOVEM	%06,-3(%05)
	HLRZS	0(%05)
BIRML:					;BUILD IMMED REF ML
	POP	%05,%06		;DATA LITERAL
	POP	%05,%00		;DATA POINTER
	POP	%05,%07		;REGISTER POINTER
	POP	%05,%12		;DEC10 PATTERN INSTRUCTION
	JRST	BARML			;BUILD ABS REF ML
IITML:					;INSERT INST TAG ML
	POP	%05,%00
	SUBI	%00,1
	DPB	%00,[POINT 4,-3(%05),17];INST TAG BYTE
	AOJA	%01,PSEML

RREML:					;REGS RESET ML
	HRRZ	%06,TOPS+REGROL		;TOPS
	HRLI	%06,1(%06)
	SETZM	1(%06)
	ADDI	%06,2
	BLT	%06,@BOTTOM+REGROL
	AOJA	%01,PSEML
COCCO0:	LSH	%06,3
	TDOA	%06,%00

COCCML:	TDZA	%06,%06

	PUSHJ	%17,NCHML		;NEXT CHAR ML
	MOVEI	%00,-N0(%14)
	CAIG	%00,7
	JRST	COCCO0			;$0
	SKIPE	MCOFLA+ZZ		;MINUS CONST FLAG
	MOVNS	%06
	MOVEM 	%06,DAT1+ZZ		;DATA 1
	JRST	EFAML			;EXIT FALSE ML


BTSML:					;BINARY TYPE SELECT ML
	LDB	%06,[POINT 3,-1(%05),2]
	LDB	%07,[POINT 3,-2(%05),2]
	CAIL	%06,6
	CAIGE	%07,6
	JRST	BTSML1			;$1
	CAME	%06,%07
	TDZA	%03,%03
BTSML1:	SETO	%03,
	MOVSI	%00,770000
	AND	%00,TSEMAT(%06)		;TYPE SELECTION MA
	OR	%00,[POINT 3,TSEMAT(%07),35]
	POP	%05,%10
	TLZ	%10,700000
	LDB	%06,%00
	LSHC	%06,-3
	OR	%10,%07
	PUSH	%05,%10
	PUSH	%05,%07
	AOJA	%01,PSEML
ITSML:					;INTRINSIC TYPE SET ML
	MOVE	%06,CREPNT+ZZ		;AC6_LFUTAB POINTER
	ANDI	%06,7777		;AC6_DISPLACEMENT OF ENTRY
	LSH	%06,1		;AC6_DISPLACEMENT * GROUP SIZE ;"23AI"
	MOVE	%07,0(%05)		;AC7_W0_GSPROL POINTER ;"23II"
	TLZ	%07,700000		;ASSUME TYPE INTEGER ;"23II"
	CAIL	%06,EOILIB-LFUTAB	;END OF INT LIBS ;"23II"
					;LINE DELETED ;"23II"
	TLO	%07,200000		;IF NOT AN INTEGER TRY REAL ;"23II"
	CAIL	%06,EORLIB-LFUTAB	;END OF REAL LIBS
	TLO	%07,600000		;IF NOT REAL TRY DBL PREC ;"23II"
	CAIL	%06,EODLIB-LFUTAB	;END OF DBL LIBS
	TLO	%07,700000		;IF NOT DBL PREC THEN COMPLEX ;"23II"
	MOVEM	%07,0(%05)		;W0_GSPROL POINTER W/PROPER TYPE ;"23II"
	AOJA	%01,PSEML

PMNML:	MOVE	%07,DAT1+ZZ		;HIGH ORDER WORD IN AC
	DFN	%07,DAT2+ZZ		;NEGATE DOUBLE WORD
	MOVEM	%07,DAT1+ZZ		;STORE HIGH ORDER WORD
	AOJA	%01,PSEML		;RETURN IF NEGATIVE
PMN6ML:	SKIPE	DAT2+ZZ		;LOW ORDER WORD ZERO ?
	AOS	DAT1+ZZ		;NO,INCREMENT HIGH ORDER WORD
PMNCML:	MOVNS	DAT1+ZZ		;NEGATE
	MOVNS	DAT2+ZZ		;NEGATE
	AOJA	%01,PSEML		;RETURN

REGSML:				;REGISTER SEARCH ML
	HLRZ	%10,EOPPNT+ZZ	;GET LH OF OP PNTR
	ANDI	%10,700000	;ISOLATE TYPE
	MOVEI	%07,TSAREG	;ASSUME SINGLE PRECISION
	CAIL	%10,600000	;DOUBLE PRECISION OR COMPLEX?
	HRROI	%07,TDAREG	;YES, SET TOP REGISTER AND FLAG
	MOVE	%06,TOPS+REGROL	;POINT TO TOP OF REGROL
	HRLI	%06,(Z (%02))	;SET FOR INDIRECT THRU %02
	MOVEI	%02,3		;SET TO REGISTER TWO	;"21V"
REGSM1:	SKIPE	@%06		;IS THIS REGISTER AVAILABLE?
	JRST	REGSM2		;NO, TEST FOR END
	JUMPG	%07,REGSM3	;YES, TEST COMPLETED IF SINGLE
IFNDEF	FASTDP,
<	TRNN	%02,1		;DOUBLE, IS IT AN EVEN REG?
	JRST	REGSM2		;NO, DON'T USE IT
>
	ADDI	%02,1		;YES, TAKE A PEEK AT ITS MATE
	SKIPN	@%06		;SKIP IF NOT AVAILABLE
	SOJA	%02,REGSM3	;OK, FINISH UP
REGSM2:	CAIGE	%02,1(%07)	;REGISTER IN USE, TEST FOR END
	AOJA	%02,REGSM1	;NOT THE END, TEST NEXT
	MOVEI	%02,1(%07)	;END, POINT TO TOP ARITH REG
REGSM3:	MOVEI	%06,-2(%02)	;COUNT REGS (REG2=1)	;"21V"
	TRO	%02,<REGROL>B23	;SET POINTER TO REGROL
	HRL	%02,%10		;SET TYPE POINTER
	TLO	%02,7		;MARK IT AS A REGISTER
	PUSH	%05,%02		;PLACE ON TOP OF WORK ROLL
	CAMG	%06,REGCNT+ZZ	;HIGHEST REG SO FAR ?	;"21V"
	AOJA	%01,PSEML	;NO, EXIT
	CAIL	%10,600000	;DOUBLE REGISTER ?	;"21V"
	AOS	%06		;YES, INDICATE HIGHEST REG	;"21V"
	MOVEM	%06,REGCNT+ZZ	;SAVE FOR POSTERITY	;"21V"
	AOJA	%01,PSEML	;EXIT	;"21V"


TSAML:					;TEMP STATUS ADVANCE ML
	MOVEI	%10,WORROL
	SUBI	%10,-1(%05)	;[345] RESTORE TO ORIGINAL
	HRLS	%10
	HRRI	%10,WORROL		;WORK ROLL
	MOVE	%06,0(%05)
TSAML1:	HRRZ	%07,-1(%05)
	XOR	%07,0(%10)
	TRZE	%07,777777
	JRST	TSAML2			;$2
	TLZ	%07,767777
	XOR	%07,%06
	MOVEM	%07,0(%10)
TSAML2:	AOBJN	%10,TSAML1		;$1
	AOJA	%01,PSEML
OCHML:					;OP CHECK ML
	MOVSI	%01,-12
	HRRI	%01,OQTTBL		;OP QT TBL
OCHML1:	MOVE	%02,%01
	PUSHJ	%17,QSAML		;QSA ML
	JUMPN	%03,EFAML			;EXIT FALSE ML
	AOBJN	%01,OCHML1		;$1
	JRST	ETRML			;EXIT TRUE ML

IIAXML:	JSP	%11,RELML
	POP	%04,%00
	AOJA	%01,PSEML

MCAPML:	HLRZ	%00,0(%05)
	TRO	%00,CAPHEA
	MOVEM	%00,0(%05)
	AOJA	%01,PSEML

CBMOML:	POP	%05,%00
	SUB	%00,0(%05)
	HLL	%00,1(%05)
	MOVEM	%00,0(%05)
	AOJA	%01,PSEML

GTOPML:					;GET OP CODE
	LDB	%10,[POINT 9,-3(%05),8]	;GET THE OPCODE BYTE OUT OF THE DEC10
					;PATTERN INSTRUCTION
	PUSH	%05,%10		;AND PUSH IT TO W0
	AOJA	%01,PSEML
RMEML0:					;$3
	SOS	BOTTOM(%02)
RMEML:					;REASSIGN MEMORY ML
				;2 LINES DELETED ;"23CC"
	MOVEI	%00,^D30		;"23CC"
	MOVE	%15,FLOORS		;ANCHOR+1
	SUB	%15,BOTTOM		;BOTTOM
	CAMG	%15,%00			;COMPARE GROUP SIZE
	JRST	PREMEM			;PRESS MEMORY
	MOVE	%07,BOTTOM(%02)		;BOTTOM
	SUB	%07,%00
	MOVE	%06,FLOORS		;ANCHOR+1
	HRL	%06,%06
	SUB	%06,%00
	BLT	%06,@%07
	HRRZ	%06,%02
	MOVNS	%00
RMEML2:	ADDM	%00,TOPS(%06)		;TOPS+1
	ADDM	%00,BOTTOM(%06)		;BOTTOMS+1
	ADDM	%00,ANCHOR(%06)		;ANCHORS+1
	SOJG	%06,RMEML2

P1ORML:					;PUT 10 ON ROLL ML
	AOS	%06,BOTTOM(%02)		;BOTTOM
	CAMLE	%06,FLOORS(%02)		;FLOORS
	JRST	RMEML0			;REASSIGN MEMORY ML $3
	MOVEM	%10,0(%06)
POPJML:	POPJ	%17,
PREMEM:					;PRESS MEMORY
	PUSH	%17,%10
	PUSH	%17,%11
PREME8:	MOVEI	%06,LRONUM		;LAST ROLL NUMBER
PREME1:	HRRZ	%10,FLOORS(%06)		;FLOORS
	HRRZ	%07,BOTTOM(%06)		;BOTTOM
	JUMPLE	%06,PREME4
	CAML	%07,%10
	SOJA	%06,PREME1		;$1
	MOVE	%11,10
	SUB	%11,%07
	ADDM	%11,BOTTOM(%06)		;BOTTOM
	ADDM	%11,TOPS(%06)		;TOPS
	ADD	%11,ANCHOR(%06)		;ANCHOR
	EXCH	%11,ANCHOR(%06)		;ANCHOR
PREME3:	CAMG	%07,%11
	SOJA	%06,PREME1		;$1
	MOVE	%15,0(%07)		;"23CC"
	MOVEM	%15,0(%10)		;"23CC"
	SUBI	%07,1
	SOJA	%10,PREME3		;$3

PREME4:	SUB	%10,%07
	CAMG	%10,%00
	JRST	PREME5			;$5
	POP	%17,%11
	POP	%17,%10
	JRST	P1ORML

PREME5:
IFNDEF	FILE0,
<
	PUSHJ	%17,PANIC		;TRY TO GET 1K MORE CORE
	MOVEI	%10,2000		;ADD 1K TO LAST FLOOR
	ADDM	%10,FLOORS+LRONUM
	JRST	PREME8
>
IFDEF	FILE0,
<
	EXIT
>
		;FLOATING POINT CONSTANT GENERATOR "25-1"
		;CONVERTS AN INTEGER CONSTANT TO A DOUBLE PRECISION
		;FLOATING POINT CONSTANT FOR PDP6, KA10, AND KI10.

FCMML:	MOVEM	%01,AC1SAV+ZZ	;SAVE AC1
	MOVEM	%11,%00		;SAV AC11 IN AC0
	MOVEI	%12,306		;PICKUP MAX BINARY EXPONENT
	MOVE	%07,MAC2+ZZ	;PICKUP CONSTANT
	SKIPLE	%06,MAC1+ZZ	;LOAD  6 AND SKIP IF LESS 0
	JRST	FCMML0		;NOT ZERO
	MOVEI	%12,200		;RESET EXPONENT "25-1"
	JUMPE	%07,FCFML	;JUMP IF BOTH = 0
	MOVE	%06,%07		;PUT LO WORD INTO HI
	MOVEI	%07,0		;ZERO LO HALF
	MOVEI	%12,243		;SET BINARY POINT BETWEEN HALVES
FCMML0:	TLNE	%06,777777	;ONES IN LEFT HALF HI WORD?
	JRST	.+3		;YES
	ASHC	%06,^D17	;NO, NORMALIZE 17 PLACES
	SUBI	%12,^D17	;  AND ADJUST EXPONENT
	TLNE	%06,777000	;ONES IN HI 8 BITS OF FRACTION?
	JRST	FCMML1		;YES
	ASHC	%06,^D8		;NO, NORMALIZE 8 PLACES
	SUBI	%12,^D8		;  AND ADJUST EXPONENT
FCMML1:	TLNE	%06,(1B1)	;BIT 1 A 1?
	JRST	FCMML2		;YES
	ASHC	%06,1
	SOJA	%12,FCMML1	;DECREMENT BINARY EXP
FCMML2:	MOVM	%01,EXPONE+ZZ	;GET MAGNITUDE OF DECIMAL EXP
	CAILE	%01,^D100	;GREATER THAN MAX
	JRST	FCMOVR		;YES, OVERFLOW ERROR
	JUMPE	%01,FCMML6	;EXP = 0?
FCMML3:	SETZM	EXPSAV+ZZ	;ZERO EXTRA EXP QUANTITY
	CAIG	%01,^D38	;EXP GREATER 38
	JRST 	FCMML4		;NO
	SUBI	%01,^D38	;REDUCE EXP BY 38
	MOVEM	%01,EXPSAV+ZZ	;SAVE DIFFERENCE
	MOVEI	%01,^D38	;SET FOR FIRST MULT OR DIV
FCMML4:	LSH	%01,1		;CALC DEC EXP*2 "25-1"
	SKIPGE	EXPA+ZZ		;IS DEC EXP SIGN NEGATIVE?
	MOVNS	%01		;MAKE THE TENS TABLE INDEX NEGATIVE
			;START DOUBLE PRECISION INTEGER MULTIPLY
	MUL	%07,TENS(%01)	;AC7_(7*H)H
	MOVE	%11,%07		; SAVE RESULT IN %11
	MOVE	%07,%06		;GET HI FRACTION INTO %07
	MUL	%07,TENS+1(%01)	;  AND MUL BY LO POWER OF TEN
	ADD	%11,%07		;ADD THE HI PARTS OF CROSS PRODUCTS
	MUL	%06,TENS(%01)	;FORM THE PRODUCT OF 2 HI PARTS
	TLZE	%11,(1B0)	;ADDITION OF 2 CROSS PRODS CAUSE CRY?
	ADDI	%06,1		;YES, PROPOGATE CARRY
	ADD	%07,%11		;ADD CROSS PRODS TO RESULT
	TLZE	%07,(1B0)	; AND PROPOGATE A
	ADDI	%06,1		;   CARRY, IF ANY
	TLNE	%06,(1B1)	;IS RESULT NORMALIZED?
	JRST	.+3		;YES
	ASHC	%06,1		;NO, SHIFT LEFT ONE PLACE
	SUBI	%12,1		;  AND ADJUST THE EXPONENT
FCMML5:	MOVE	%10,%01		;MOVE DECIMAL EXP*2 TO DOUBLE AC
	ASH	%10,-1		;GET EXP BACK
	IDIVI	%10,4		;BYTAB HAS 4 ENTRIES/WORD
	LDB	%10,BYTAB(%11)	;GET BINARY EXP OF POWER OF 10
	ADD	%12,%10		;  AND ADD INTO FINAL BINARY EXP
	SUBI	%12,200		;GET RID OF AN EXCESS 200
			;HERE ENDETH THE D.P. INTEGER MULTIPLY

	SKIPE	%01,EXPSAV+ZZ	;CHECK FOR XTRA MULT OR DIV
	JRST	FCMML3		;GO ONE MORE TIME
				;NONE LEFT
FCMML6:	SKIPL	PDPSWZ		;-1 IS KA10, 0 IS PDP-6, +1 IS KI10
	JRST	[ADDI	%07,200		;PDP-6, OR KI10, ROUND
		JRST	FCMML7 ]
	CAILE	%12,^D26		;KA10, ROUNDABLE IN LOW WORD?
	JRST	[ADDI	%07,100000	;ROUND FOR KA10 IN LOW WORD
		JRST	FCMML7 ]
	ADDI	%06,200		;ROUND IN HIGH HALF OF KA10 FRACTION
	TRZ	%06,377		;ZERO INSIGNIFICANT BITS
	MOVEI	%07,0		; DITTO
FCMML7:	TLZE	%07,(1B0)	;DID ROUNDING CAUSE LO WORD OVERFLOW?
	ADDI	%06,1		;YES, PROPOGATE CARRY
	JUMPGE	%06,FCMML8	;DID THIS OVERFLOW HI WORD?
	ASHC	%06,-1		;YES, RENORMALIZE TO RIGHT
	ADDI	%12,1		;  AND ADJUST THE EXPONENT
	TLZ	%06,(1B0)	;CLEAR SIGN BIT
FCMML8:	TRNE	%12,777400	;IS EXP TOO BIG OR TOO SMALL?
	JRST	FCMOV1		;YES
	ASHC	%06,-8		;MAKE ROOM FOR EXPONENT
	DPB	%12,[POINT 9,%06,8]	;INSERT EXPONENT
	SKIPL	PDPSWZ		;IS CODE FOR KA10?
	JRST	FCMML9		;NO, PDP-6, OR KI10
	ASH	%07,-8		;YES, MAKE ROOM FOR LO EXPONENT
	JUMPE	%07,FCMML9	;NO LOW EXP IF LOW FRAC IS 0
	HRREI	%01,-^D27(%12)		;GET LO EXP AND PUT IN %01
	DPB	%01,[POINT 9,%07,8]	;INSERT EXP IN LO WORD
FCMML9:	MOVEM	%06,MAC1+ZZ	;SAVE HI PART OF ANSWER
	MOVEM	%07,MAC2+ZZ	;DITTO LO PART
FCFML:	HRRZM	%12,EXPONE+ZZ	;SAVE EXPON FOR OVER/UNDER FLOW TESTING
	MOVE	%01,AC1SAV+ZZ	;RESTORE AC1
	MOVE	%11,%00		;RESTORE AC0
	AOJA	%01,PSEML	;RETURN

FCMOVR:	MOVE	%12,EXPA+ZZ	;GET SIGN OF DECIMAL EXPONENT
FCMOV1:	SKIPGE	%12		;IS EXPONENT NEGATIVE
	TDZA	%06,%06		;YES ZERO ON UNDERFLOW
	HRLOI	%06,377777	;NO MAX NUMBER ON OVERFLOW
	MOVE	%07,%06		;  DITTO
	MOVEI	%12,400		;SET EXPONENT FOR OVERFLOW
	JRST	FCMML9
	;POWER OF TEN TABLE IN DOUBLE PRECISION
	;INTEGER FORMAT. EACH ENTRY CONSISTS OF TWO WORDS,
	;EACH WITH 35 BITS OF FRACTION (SIGNS ARE EXCLUDED).
	;THE BINARY POINT IS BETWEEN BITS 0 AND 1 OF THE
	;HI ORDER WORD. THE EXPONENT (EXCESS 200) FOR THE 70 BIT
	;FRACTION IS STORED IN THE SHORT TABLE CALLED "EXPTEN".
DEFINE .TAB. (A)<
	REPEAT 0,<
	NUMBER 732,357347511265,056017357445	;D-50
	NUMBER 736,225520615661,074611525567
	NUMBER 741,273044761235,213754053125
	NUMBER 744,351656155504,356747065752
	NUMBER 750,222114704413,025260341562
	NUMBER 753,266540065515,332534432117
	NUMBER 756,344270103041,121263540543
	NUMBER 762,216563051724,322660234335
	NUMBER 765,262317664312,007434303425
	NUMBER 770,337003641374,211343364332
	NUMBER 774,213302304735,325716130610	;D-40
	NUMBER 777,256162766125,113301556752
	>
	NUMBER 002,331617563552,236162112545	;D-38
	NUMBER 006,210071650242,242707256537
	NUMBER 011,252110222313,113471132267
	NUMBER 014,324532266776,036407360745
	NUMBER 020,204730362276,323044526457
	NUMBER 023,246116456756,207655654173
	NUMBER 026,317542172552,051631227231
	NUMBER 032,201635314542,132077636440
	NUMBER 035,242204577672,360517606150	;D-30
	NUMBER 040,312645737651,254643547602
	NUMBER 043,375417327624,030014501542
	NUMBER 047,236351506674,217007711035
	NUMBER 052,306044030453,262611673245
	NUMBER 055,367455036566,237354252116
	NUMBER 061,232574123152,043523552261
	NUMBER 064,301333150004,254450504735
	NUMBER 067,361622002005,327562626124
	NUMBER 073,227073201203,246647575664
	NUMBER 076,274712041444,220421535242	;D-20
	NUMBER 101,354074451755,264526064512
	NUMBER 105,223445672164,220725640716
	NUMBER 110,270357250621,265113211102
	NUMBER 113,346453122766,042336053323
	NUMBER 117,220072763671,325412633103
	NUMBER 122,264111560650,112715401724
	NUMBER 125,341134115022,135500702312
	NUMBER 131,214571460113,172410431376
	NUMBER 134,257727774136,131112537675
	NUMBER 137,333715773165,357335267655	;D-10
	NUMBER 143,211340575011,265512262714
	NUMBER 146,253630734214,043034737477
	NUMBER 151,326577123257,053644127417
	NUMBER 155,206157364055,173306466551
	NUMBER 160,247613261070,332170204303
	NUMBER 163,321556135307,020626245364
	NUMBER 167,203044672274,152375747331
	NUMBER 172,243656050753,205075341217
	NUMBER 175,314631463146,146314631463	;D-01
A:	NUMBER 201,200000000000,0	;D00
	NUMBER 204,240000000000,0
	NUMBER 207,310000000000,0
	NUMBER 212,372000000000,0
	NUMBER 216,234200000000,0
	NUMBER 221,303240000000,0
	NUMBER 224,364110000000,0
	NUMBER 230,230455000000,0
	NUMBER 233,276570200000,0
	NUMBER 236,356326240000,0
	NUMBER 242,225005744000,0	;D+10
	NUMBER 245,272207335000,0
	NUMBER 250,350651224200,0
	NUMBER 254,221411634520,0
	NUMBER 257,265714203644,0
	NUMBER 262,343277244615,0
	NUMBER 266,216067446770,040000000000
	NUMBER 271,261505360566,050000000000
	NUMBER 274,336026654723,262000000000
	NUMBER 300,212616214044,117200000000
	NUMBER 303,255361657055,143040000000	;D+20
	NUMBER 306,330656232670,273650000000
	NUMBER 312,207414740623,165311000000
	NUMBER 315,251320130770,122573200000
	NUMBER 320,323604157166,147332040000
	NUMBER 324,204262505412,000510224000
	NUMBER 327,245337226714,200632271000
	NUMBER 332,316627074477,241000747200
	NUMBER 336,201176345707,304500460420
	NUMBER 341,241436037271,265620574524
	NUMBER 344,311745447150,043164733651	;D+30
	NUMBER 347,374336761002,054022122623
	NUMBER 353,235613266501,133413263573
	NUMBER 356,305156144221,262316140531
	NUMBER 361,366411575266,037001570657
	NUMBER 365,232046056261,323301053415
	NUMBER 370,300457471736,110161266320
	NUMBER 373,360573410325,332215544004
	NUMBER 377,226355145205,250330436402	;D+38
	REPEAT 0,<
	NUMBER 402,274050376447,022416546102
	NUMBER 405,353062476160,327122277522	;D+40
	NUMBER 411,222737506706,206363367623
	NUMBER 414,267527430470,050060265567
	NUMBER 417,345455336606,062074343124
	NUMBER 423,217374313163,337245615764
	NUMBER 426,263273376020,327117161361
	NUMBER 431,340152275425,014743015655
	NUMBER 435,214102366355,050055710514
	NUMBER 440,257123064050,162071272637
	NUMBER 443,332747701062,216507551406
	NUMBER 447,210660730537,231114641743	;D+50
	NUMBER 452,253035116667,177340012333
	>
>

DEFINE NUMBER (A,B,C)
<  EXP B,C>

TENTAB:	.TAB. TENS

XX=<TENS-TENTAB>/2	;CALCULATE NUMBER OF TABLE ENTRIES BEFORE "TENS"
XX=XX-XX/4*4		;CALC XX=XX MOD 4

BINR1=<BINR2=<BINR3=0>>	;INIT THE BINARY

DEFINE NUMBER (A,B,C)<
IFE XX-1,<	BYTE (9) BINR1,BINR2,BINR3,<A>
	BINR1=<BINR2=<BINR3=0>> >
IFE XX-2,<BINR3=A>
IFE XX-3,<BINR2=A>
IFE XX,<BINR1=A
	XX=4>
XX=XX-1>

	POINT 9,EXPTEN-1(%10),17
	POINT 9,EXPTEN-1(%10),26
	POINT 9,EXPTEN-1(%10),35
BYTAB:	POINT 9,EXPTEN(%10),8
	POINT 9,EXPTEN(%10),17
	POINT 9,EXPTEN(%10),26
	POINT 9,EXPTEN(%10),35

	.TAB. EXPTEN
	IFN BINR1!BINR2!BINR3,<	BYTE (9) BINR1,BINR2,BINR3,0>
ECHML:					;EXPON CHECK ML
	MOVM	%06,0(%05)
	CAILE	%06,MAEFMP		;MAX ABS EXPON FOR MPY
	JRST	SETFAL			;EXIT FALSE ML
	MOVEI	%10,MOIEFM
ECHML1:	LSHC	%06,-1
	TLNE	%07,400000
	SOJL	%10,SETFAL
	JUMPN	%06,ECHML1		;$1
	JRST	SETTRU			;EXIT TRUE ML

IEAML:					;INTEGER EXPON ABSTRACT ML
	POP	%05,%06
	MOVEI	%07,^D34
IEAML1:	LSH	%06,1
	TLZN	%06,400000
	SOJA	%07,IEAML1		;$1
	MOVEM	%06,ISCBOX+ZZ		;INTEGER SCANER
	MOVEM	%07,IBICNT+ZZ		;INTEGER BITS CN
	AOJA	%01,PSEML

IFNDEF	$IMPL,
<
ICFCML:	SKIPA	%06,%14
>
ICFSML:	LDB	%06,[POINT 6,SYMBOL+ZZ,5]
	HRRZM	%06,IMPCLU+ZZ		;IMPLICIT C
	AOJA	%01,PSEML

SYMSML:	MOVE	%07,[POINT 6,SYMBOL+ZZ]
SYMSC2:	TLNE	%07,770000
	IDPB	%14,%07
	PUSHJ	%17,NCHML
	TLNE	%14,LODKEY
	JRST	SYMSC2
	AOJA	%01,PSEML		;GET NEXT POP

IFNDEF	$CREF,
<
CRFML:					;CREF ML
IFNDEF	FILE0,				;"23B"
<	MOVE	%02,CARBUF		;"23D"
	TRZE	%02,1			;"23D"
	TRO	%16,HDRBIT		;"23D"
	MOVEM	%02,CARBUF		;"23D"
>					;"23B"
	POP	%05,%00			;GET TOP OF WORK ROLL
	HRREI	%02,CRFSYM-40		;ASSUME SYMBOL
	JUMPL	%00,CRFML3		;TEST FOR STATEMENT LABEL
CRFML1:	TRNE	%00,007700		;YES, PAD LEADING CHAR.
	JRST	CRFML2
	TRO	%00,N0
	ROT	%00,-6			;PUT "0" IN LEADING POSITION
	JRST	CRFML1
CRFML2:	TRO	%00,P			;APPEND "P"
	HRREI	%02,CRFSTA-40
CRFML3:	PUSHJ	%17,LSTOUT		;LIST IT
	MOVSI	%07,(POINT 6,%00,)	;SET BYTE POINTER
CRFML4:	ILDB	%02,%07			;GET A SIXBIT CHARACTER
	JUMPE	%02,CRFML5		;BRANCH IF END
	PUSHJ	%17,LSTOUT		;LIST IT
	TLNE	%07,770000		;TEST FOR END
	JRST	CRFML4			;NO, GET ANOTHER
CRFML5:	HRREI	%02,CRFSYM-40
	PUSHJ	%17,LSTOUT		;FLAG END
	AOJA	%01,PSEML

>

IFN FTMANT,<ST5AML:	SKIPN	DEBFLAG+ZZ	;MAYBE CONVERT
			AOJA	%01,PSEML>
ST5RAD:
ST5RML:
	SETZ	%10,
	MOVSI	%06,(POINT 6,0(%05),)
ST5RA2:	ILDB	%07,%06
	LDB	%07,[POINT 6,CSTAT(%07),8]
	JUMPE	%07,ST5RA3
	IMULI	%10,50
	ADD	%10,%07
	TLNE	%06,770000
	JRST	ST5RA2
ST5RA3:	MOVEM	%10,0(%05)
	AOJA	%01,PSEML

BTBCML:	POP	%05,%06
	SETZ	%10,
BTOBC2:	IDIVI	%06,^D10
	ADDI	%07,N0
	LSHC	%07,-6
	JUMPN	%06,BTOBC2		;$2
	PUSH	%05,%10
	AOJA	%01,PSEML
PUNCML:	SETZB	%06,%07
	MOVE	%11,TOPS+CODROL		;TOPS
PUNCH2:	CAML	%11,BOTTOM+CODROL
	AOJA	%01,PSEML
	SKIPE	DSTFLA+ZZ		;DATA STA FLAG
	JRST	PUNCH4			;$4
	SKIPE	PPEFLA+ZZ		;PUNCH PEEK FLAG
	SOJL	%06,PUNCH5
PUNCH3:	AOS	LOCCNT+ZZ		;LOC CNTR
PUNCH4:	MOVE	%00,1(%11)

IFNDEF	$CODE,
<
	TLNN	%16,ESWFLG
	PUSHJ	%17,PRICOD
>
	TLNN	%16,BINFLG
	PUSHJ	%17,BINOUT		;OUTBIN
	AOJA	%11,PUNCH2

PUNCH5:	SETZ	%06,
	SKIPE	%07
	SOJA	%07,PUNCH4		;$4
	HLLO	%00,1(%11)
	AOJN	%00,PUNCH3
	HRRZ	%00,1(%11)
	ANDI	%00,770000
	JUMPE	%00,PUNCH6		;$2
	CAIE	%00,600000
	CAIN	%00,310000
PUNCH6:	AOJA	%07,PUNCH4		;$4
	XORI	%00,500000
	JUMPN	%00,PUNCH4		;$4
	MOVE	%06,1(%11)
	ANDI	%06,077777
	JRST	PUNCH4			;$4

IFNDEF	$CODE,
<
PRICOD:					;PRINT CODE
	MOVSI	%10,(POINT 3,%00,)
PRICO1:	ILDB	%02,%10
	PUSHJ	%17,PRNML
	TLNE	%10,770000
	JRST	PRICO1
	MOVEI	%02,CRR
	JRST	PCHML
>
SSAML:					;STATUS SAVE ML
	MOVEM	%13,STAPSA+ZZ		;STATUS PSAV
	MOVEM	%14,STACSA+ZZ		;STATUS CSAV
	MOVE	%00,SSABLT
	BLT	%00,SSAEND+ZZ		;STATUS VARS SAVE EN
	MOVEM	%04,STAEXS+ZZ		;STATUS EXSAV
	MOVEM	%05,STAWKS+ZZ		;STATUS WKSAV
	HRRZI	%06,LRONUM		;LAST ROLL NUMBER
SSAML1:	HRRZ	%00,TOPS(%06)		;TOPS
	SUB	%00,ANCHOR(%06)		;ANCHOR
	HRLM	%00,STATBS+ZZ(%06)		;STATUS TBSAV
	HRRZ	%00,BOTTOM(%06)		;BOTTOM
	SUB	%00,ANCHOR(%06)		;ANCHOR
	HRRM	%00,STATBS+ZZ(%06)		;STATUS TBSAV
	SOJGE	%06,SSAML1		;$1
	AOJA	%01,PSEML

SSABLT:	XWD	ESTFLA+ZZ,SSATMP+ZZ


; FAKE A SYMBOL SCAN FOR THE APPROPRIATE ROUTINE
REGCML:	SKIPA	%07,[SIXBIT/CLS40./]	;[27M]REGISTER A CLOSE
REGOML:	MOVE	%07,[SIXBIT/OPN40./]	;[27M]AN OPEN
	MOVEM	%07,SYMBOL+ZZ		;[27M]STORE IT
	SETZM	ARGKNT+ZZ		;[27M]ZERO SOME STUFF
	SETZM	ARGMAP+ZZ		;[27M]
	SETZM	ARGTLY+ZZ		;[27M]
	SETZM	UNIDEF+ZZ		;[27M]
	AOJA	%01,PSEML		;[27M]AND DO NEXT POP


; STORE AN ARGUMENT NUMBER FOR LATER CODE GENERATION AND
; INSURE AGAINST DUPLICATE STUFF
NXTAML:	MOVE	%10,ARGKNT+ZZ		;[27M]COUNTER OF ARGS
	MOVE	%07,ARGNUM+ZZ		;[27M]THIS ARG IS #
	MOVEM	%07,TXLST-1+ZZ(%10)	;[27M]STORE IT
	MOVEI	%10,1			;[27M]MODIFY BITMAP
	LSH	%10,(%07)		;[27M]IN PROPER POSITION
	EXCH	%10,ARGMAP+ZZ		;[27M]
	TDON	%10,ARGMAP+ZZ		;[27M]	
	TDZA	%03,%03			;[27M]FALSE RETURN
	SETOM	%03			;[27M]TRUE RETURN
	MOVEM	%10,ARGMAP+ZZ		;[27M]STORE MAP
	AOJA	%01,PSEML		;[27M]DO NEXT POP


; ON EACH CALL GET A NUMBER OF AN ARGUMENT AND RETURN TO ARGNUM

FETAML:	AOS	%07,ARGTLY+ZZ		;[27M]UP COUNTER
	MOVE	%07,TXLST-1+ZZ(%07)	;[27M]GET THE NUMBER
	MOVEM	%07,ARGNUM+ZZ		;[27M]STASH IT
	AOJA	%01,PSEML		;[27M]DONE
RELML:					;RELEASE ML
	MOVE	%13,STAPSA+ZZ		;STATUS PSAV
	MOVE	%14,STACSA+ZZ		;STATUS CSAV
	MOVS	%00,SSABLT
	BLT	%00,LTEPNT+ZZ		;LOCAL TEMP PNTR
	MOVE	%04,STAEXS+ZZ		;STATUS EXSAV
	MOVE	%05,STAWKS+ZZ		;STATUS WKSAV
	HRRZI	%06,LRONUM		;LAST ROLL NUMBER
RELML1:	HLRZ	%00,STATBS+ZZ(%06)		;STATUS TBSAV
	CAIN	%06,ERRROL		;ERROR ROLL
	JRST	RELML2			;$2
	ADD	%00,ANCHOR(%06)		;ANCHOR
	HRRZM	%00,TOPS(%06)		;TOPS
	HRRZ	%00,STATBS+ZZ(%06)		;STATUS TBSAV
	ADD	%00,ANCHOR(%06)		;ANCHOR
	HRRZM	%00,BOTTOM(%06)		;BOTTOM
RELML2:	SOJGE	%06,RELML1		;$1
	JRST	0(%11)
ILCHML:	MOVSI	%00,(POINT 6,0(%05),)
	POP	%05,%06
ILACH2:	ILDB	%07,%00
	TLNE	%00,770000
	JUMPN	%07,ILACH2
	DPB	%06,%00
	JRST	EXIML
IFN FTMANT,<		;MANTIS DEBUGGER ML ROUTINES
RFPML:	POP	%05,%06		;OUTPUT PROGRAM NAME
	TLO	%06,(40B5)
	MOVEM	%06,REFSW+ZZ	; BUT NOT RIGHT NOW
	JRST	RFSBML
LIM0ML:	POP	%05,%06		;OUTPUT ARRAY NAME
	TLO	%06,(50B5)
	SKIPE	DARFLAG+ZZ	;WITH DUMMY FLAG
	TLO	%06,(4B5)
	JRST	LIM3ML
LIM1ML:	HRLZ	%06,-1(%05)	;OUTPUT BOUNDS
	HRR	%06,0(%05)
	JRST	LIM3ML
LIM2ML:	MOVE	%06,DAT3+ZZ	;OUTPUT VARIABLE DIMENSIONS FLAG
LIM3ML:	PUSHJ	%17,REFOUT	;OUTPUT WORD TO REL FILE
	AOJA	%01,PSEML	;NEXT POP
REFML:	POP	%05,%06		;OUTPUT OBJECT ARRAY REF NAME
	SKIPN	DEBFLAG+ZZ
	AOJA	%01,PSEML
	MOVSI	%07,16		;INDEXED?
	TDNE	%07,-1(%05)
	JRST	LIM3ML		;YES
	AOJA	%01,PSEML
REFSTML:SKIPG	%07,LOCCNT+ZZ	;GET LOCATION COUNTER
	MOVEM	%07,REFSTA+ZZ	;IF THIS FIRST TIME INITIALIZE LENGTH
	SUB	%07,REFSTA+ZZ	;GET CHANGE FROM PRIOR
	JUMPE	%07,RFSML6	;JUMP IF NO CHANGE
	ADDM	%07,REFSTA+ZZ	;UPDATE PRIOR LOCATION
	MOVE	%06,RFPOINT+ZZ	;PICK UP TEMP POINTER
RFSML1:	CAIG	%07,^D15	;GREATER THAN 4 BITS?
	JRST	RFSML2		;NO, FITS IN 4
	TLCN	%07,1		;PRECEDE 8 BITS BY ZERO BYTE
	LSH	%07,4
RFSML2:	IDPB	%07,%06		;DEPOSIT BYTE IN PACKING WORD
	LSH	%07,-4		;SHIFT FOR NEXT 4 BITES
	TLNE	%06,770000	;END OF PACKING WORD
	JRST	RFSML5		;NO
	MOVNI	%06,2		;YES, OUTPUT BYTES WORD
	PUSHJ	%17,REFOUT
	MOVE	%06,RFPACK+ZZ
	PUSHJ	%17,REFOUT
	SKIPA	%06,[POINT 4,RFPACK+ZZ] ;SETUP POINTER TO PACKING WORD
RFSBML:	SKIPA	%06,[POINT 4,RFPACK+ZZ,3] ;RESERVE BYTE AT START
RFSML5:	JUMPG	%07,RFSML1	;MORE BYTES TO PACK?
	MOVEM	%06,RFPOINT+ZZ	;NO, SAVE POINTER
RFSML6:	AOJA	%01,PSEML		;NEXT POP

RFSFML:	MOVEI	%07,1_<4*4>	;FORCE OUTPUT OF LAST WORD
	JRST	RFSML1-1>

IFN FTMANT,<PW0RML:	SKIPE	MACSW+ZZ	;MAYBE PRINT
		JRST	P1EML		;NO>
PW0ML:					;PRINT W0 ML
	MOVSI	%03,(POINT 6,0(%05),)	;6-BIT POINTER
	MOVEI	%01,6
PW0ML1:	ILDB	%02,%03
;	JUMPE	%02,P1EML
	PUSHJ	%17,PCHML		;PRC ML
	SOJG	%01,PW0ML1		;$1
	JRST	P1EML			;POW 1 EXIT ML

POLML:					;PRINT OCTAL LOC ML

	HRLZ	%03,0(%05)
	MOVEI	%06,6
	MOVEI	%02,0
POLML1:	LSHC	%02,3
	SKIPN	%02
	SOJG	%06,POLML1		;$1
	PUSHJ	%17,PRNML		;PRC ML
POLML2:
	MOVSI	%02,7
	SOJG	%06,POLML1		;$1
	JRST	P1EML			;POW 1 EXIT ML

PWOML:	MOVE	%03,0(%05)
	MOVEI	%06,15
	JRST	POLML2
FINML:					;FL INTEGER ML

IFNDEF	$FAD,
<
	POP	%05,%06			;GET THE ARGUMENT
	IDIVI	%06,400000		;HIGH ORDER IN RH(%06)
	SKIPE	%06			;IMPLIES INT .LT. 18 BITS
	TLC	%06,254000		;SET EXP TO 27+17 DEC
	TLC	%07,233000		;SET EXP TO 27 DEC
	FAD	%06,%07			;NORMALIZE AND ADD
	PUSH	%05,%06			;SAVE RESULTS
	AOJA	%01,PSEML
>

IFDEF	$FAD,
<
	SKIPN	%06,0(%05)
	AOJA	%01,PSEML
	MOVEI	%07,244000
	SUBI	%07,001000
	LSH	%06,1
	JUMPG	%06,.-2
	LSH	%06,-^D9
	TSO	%06,%07
	MOVEM	%06,0(%05)
	AOJA	%01,PSEML
>
IFNDEF	$CCONS,
<

CARML:					;CONST ARITH ML
	JFCL	17,.+1
	POP	%05,%06
	POP	%05,%07
	POP	%05,%10
	XCT	CAOTBL(%10)		;CONST ARITH OPS TBL
	JFCL	10,EFAML		;EXIT FALSE ML
	PUSH	%05,%06
	AOJA	%01,PSEML

CAOTBL:					;CONST ARITH OPS TBL
	ADD	%06,%07
	SUB	%06,%07
	IMUL	%06,%07
	IDIV	%06,%07
	FADR	%06,%07
	FSBR	%06,%07
	FMPR	%06,%07
	FDVR	%06,%07
>
PAFML:					;PRINT AC FIELD ML
	SKIPA	%06,[POINT 4,0(%05),12]
PTAML:					;PRINT TAG ML
	MOVSI	%06,(POINT 4,0(%05),17)
	LDB	%02,%06
	ROT	%02,-3
	TLNN	%06,040000		;DON'T PRINT LEADING ZERO IN INDEX
	TRNE	%02,-1
	PUSHJ	%17,PRNML
	LSH	%02,-^D33
	PUSHJ	%17,PRNML
	AOJA	%01,PSEML

SOFBML:					;SWITCH OCT AND FET BCD ML
	MOVE	%10,CODPNT+ZZ		;CODE PNTR
	PUSHJ	%17,APTML		;ADR POINTED TO ML
	LDB	%06,[POINT 9,0(%10),8]	;CODE INDEX BYTE
	PUSH	%05,IBCTBL(%06)		;INST BCD TBL
	CAIL	%06,NACBRE
	TDZA	%03,%03
	SETO	%03,
	IDIVI	%06,4
	LDB	%07,SOAFBT(%07)
	DPB	%07,[POINT 9,0(%10),8]	;CODE INDEX BYTE
	AOJA	%01,PSEML

SOAFBT:	POINT	9,IOCTBL(%06), 8
	POINT	9,IOCTBL(%06),17
	POINT	9,IOCTBL(%06),26
	POINT	9,IOCTBL(%06),35
SUEML:					;SET UP ERRORS ML
	MOVEI	%02,ERRROL		;ERROR ROLL
	PUSHJ	%17,DNGML		;DNG ML
	HRLI	%10,(POINT 5,,10)
	MOVEM	%10,CEMADR		;CRRNT ERROR MESS ADR
	POPJ	%17,

LFXML:	SETZM	LBFLG+ZZ
					;LABEL FIELD XLATE ML
	HRLZI	%03,1		;[357] SET A BIT SO WE CAN TELL IF ANY #
	CAMN	%14,CSTAT+SPACE
LFXML1:	PUSHJ	%17,NCHML
	HRRZ	%07,CARNUM+ZZ
	SUBI	%07,6
	CAME	%14,CSTAT+CRR
	JUMPLE	%07,LFXML2
	TLZ	%03,1		;[357] CLEAR THE ORIGINAL, IF STILL THERE
	TLZE	%03,777777	;[357] SEE IF THERE WAS A NUMBER
	CAILE	%03,0		;[357] YES, SEE IF IT WAS ZERO
	JRST	LFXML5		;[357] NO
	MOVSI	%10,200+4(%07)	;[357] YES, PRINT ERROR MESSAGE
	MOVEI	%02,M6QT	;[357]
	PUSHJ	%17,ERMML	;[357] GO PRINT
	SETOM	LBFLG+ZZ	;[357] SAY LABEL IS BAD
LFXML5:				;[357]
	PUSH	%05,%03
	MOVEM	%03,MAC2+ZZ
	AOJA	%01,PSEML

LFXML2:	JUMPE	%07,LFXML3
	TLNN	%14,DIGKEY
	JRST	LFXML4
	IMULI	%03,^D10
	ADDI	%03,-N0(%14)
	JRST	LFXML1

LFXML3:	CAMN	%14,CSTAT+N0
	JRST	LFXML1
LFXML4:	SKIPE	LBFLG+ZZ
	JRST	LFXML1
	SETOM	LBFLG+ZZ
	MOVSI	%10,200+6(%07)
	MOVEI	%02,S8QT		;ILLEGAL CHARACTER IN LABEL	;"23L"
	PUSHJ	%17,ERMML
	JRST	LFXML1
NCH0ML:
	PUSH	%17,%11
NCHML:					;NEXT CHARACTER ML
	MOVEM	%13,LASACT+ZZ		;LAST ACTIVE
	MOVE	%00,CARNUM+ZZ
	MOVEM	%00,LACCCN+ZZ
NCHML1:	PUSHJ	%17,NICML		;NEXT INPUT CHAR ML
NCHML3:	CAMN	%14,CSTAT+SPACE		;IF BLANK
	JRST	NCHML1			;GET ANOTHER
IFDEF	$EXPNT,
<					;[344]
	CAMN	%14,CSTAT+EXPNT		;[344] SEE IF !
	JRST	NCHML2			;[344] YES, IGNORE COMMENT
>					;[344]
	CAME	%14,CSTAT+TAB		;IF TAB
	POPJ	%17,			;EXIT
	JRST	NCHML1			;GET ANOTHER CHARACTER	;"21O"

IFDEF	$EXPNT,
<					;[344]
NCHML2:	PUSHJ	%17,NICML1		;[344] ! GO FORCE END OF LINE
	CAME	%14,CSTAT+CRR		;[344] SEE IF ANY MORE TO LINE
	JRST	NCHML3			;[344] YES, GO DO IT
	POPJ	%17,			;[344] NO, RETURN WITH EOL
>					;[344]
NIC0ML:
	PUSH	%17,%11
NICML:					;NEXT INPUT CHAR ML
	AOS	CARNUM+ZZ		;INCREMENT COLUMN COUNT
	ILDB	%14,%13			;GET NEXT CHAR FROM BUFFER
	CAIN	%14,CRR			;TEST FOR CR
	JRST	NICML1
					;LINE DELETED	;"21A"
					;LINE DELETED	;"21A"
	HRRZ	%00,CARNUM+ZZ
	CAIG	%00,^D72		;TEST FOR END OF LINE
	JRST	NICML4			;NO, SET FLAGS AND EXIT
NICML1:	HLRZ	%13,CARNUM+ZZ
	CAML	%13,LCANUM+ZZ		;TEST FOR CONTINUATION
	JRST	NICML3			;NO, SET CR AND EXIT
	IMULI	%13,WPL
					;LINE DELETED ;"21A"
					;LINE DELETED ;"21A"
	ADDI	%13,CARBUF+2
	HRLI	%13,(POINT 6,,)
	HLLOS	CARNUM+ZZ
	MOVEI	%00,7
	ADDM	%00,CARNUM+ZZ
	JRST	NICML

NICML3:	MOVEI	%14,CRR

NICML4:	CAIE	%14,TAB			;[27E]
	JRST	NICML5			;[27E]
	TRZE	%00,7			;[27E]
	ADDI	%00,10			;[27E]
	HRRM	%00,CARNUM+ZZ		;[27E]
NICML5:	MOVE	%14,CSTAT(%14)		;[27E]SET FLAGS
	POPJ	%17,
NLIML:					;NEXT LINE ML
	MOVE	%06,@SEQPNT		;TEST FOR EOF
	JUMPGE	%06,NLIML1
	SETOB	%03,ESTFLA+ZZ		;YES, SET END STATEMENT FLAG
	AOJA	%01,PSEML

NLIML1:	HRL	%06,SEQPNT		;MOVE UP LAST CARD
	HRRI	%06,CARBUF
	BLT	%06,CARBUF+WPL-1
	SETZB	%03,LCANUM+ZZ

NLIML2:	AOS	%06,LCANUM+ZZ		;INCREMENT CARD	NUMBER
	CAMLE	%06,CRDCNT		;TEST OVERFLOW
	AOSA	%07,CCAFLA+ZZ
	PUSHJ	%17,NCDML		;GET NEXT COMPLETE CARD
	JUMPL	%07,NLIML2		;BRANCH	IF CONTINUATION	CARD
	MOVSI	%07,1
	MOVEM	%07,CARNUM+ZZ		;INIT CARD-COLUMN COUNT
	MOVE	%13,[POINT 6,CARBUF+1,]
	PUSHJ	%17,NICML
	AOJA	%01,PSEML
NCDML:					;NEXT CARD ML
	MOVE	%06,LCANUM+ZZ		;LAST CARD NUMBER
	PUSHJ	%17,LINSET		;SETUP NEW LINE & POINTERS
	SETZM	-1(%06)			;CLEAR SEQUENCE NUMBER
	SETZM	0(%06)			;SET SPACES IN LABEL FIELD
	MOVNI	%10,5			;SET # OF CHARACTERS IN LABEL FIELD
	PUSHJ	%17,CHAR		;GET A CHARACTER
	LDB	%07,[POINT 1,CSTAT(%14),^L<<COMKEY>B17>];GET COMMENT FLAG
IFNDEF	FILE0,			;"23Q"
<	TLNN	%16,ISWBIT		;D=SPACE ?	;"23Q"
	JRST	NCDML1+1		;NO, CONTINUE	;"23Q"
	CAIN	%14,"D"-40		;COLUMN 1 = D ?	;"23Q"
	SETZB	%07,%14			;AC7=0 FOR REGULAR LINE	;"23Q"
					;& AC14=SPACE(0 IN SIXBIT)	;"23Q"
>					;"23Q"
	SKIPA				;DON'T GET A NEW CHARACTER

NCDML1:	PUSHJ	%17,CHAR		;GET A CHARACTER
	JUMPG	%10,NCDML2		;IN LABEL FIELD ?
	CAIE	%14,TAB			;YES, TAB SPACING ?
	JRST	NCDML2
	JUMPG	%07,NCDML2		;"23H"
	PUSHJ	%17,CHAR		;YES, GET SPECIAL CONTINUATION CHAR
	HRLI	%06,(POINT 6,,29)	;POINT TO COLUMN 5 +1
	CAIL	%14,N1			;DIGIT FROM ONE TO NINE ?
	CAILE	%14,N9			;(CONTINUATION CHAR W/TAB)
	TLZA	%06,770000		;NO, POINT TO COLUMN 6+1
	TDZA	%10,%10			;COLUMN COUNT = COL 6
	MOVEI	%10,1			;COLUMN COUNT = COL 7
NCDML2:	CAIG	%10,^D80-5		;75 CHARACTER LINE EXCEEDED ?
	IBP	%06			;NO, INCREMENT BYTE POINTER
	DPB	%14,%06			;STORE CHARACTER
	CAIN	%14,CRR			;END OF LINE ?
	POPJ	%17,			;YES, RETURN
	CAIN	%14,TAB			;TAB ?	;"21O"
	JRST	NCDML5			;"21O"
	JUMPG	%07,NCDML3		;SKIP IF COMMENT	;"23L"
	JUMPGE	%10,NCDML4		;OR OUTSIDE THE LABEL FIELD	;"23L"
	CAIN	%14,SPACE		;SPACE OR DIGIT IN LABEL ONLY	;"23L"
	JRST	NCDML3			;"23L"
	LDB	%02,[POINT 1,CSTAT(%14),^L<<DIGKEY>B17>];GET DIGIT KEY	;"23L"
	SKIPG	%02			;IF NON-DIGIT IN LABEL FIELD	;"23L"
	MOVEI	%07,1(%07)		;DISABLE AS CONTINUATION CARD	;"23L"
NCDML4:	JUMPN	%10,NCDML3		;COLUMN 6 WITH OUT TAB ?
	CAIE	%14,SPACE		;SPACE OR ZERO ?
	CAIN	%14,N0			;(ILLEGAL CONTINUATION CHARACTERS)
NCDML3:	AOJA	%10,NCDML1		;YES, GET NEXT CHARACTER
	SOJA	%07,NCDML3
NCDML5:	CAIG	%10,2			;BEFORE FIRST TAB COLUMN ?	;"23H"
	MOVEI	%10,0			;CLEAR POSSIBLE NEGATIVE COUNT	;"23H"
	TRZ	%10,7			;CHANGE COUNT TO NEXT TAB COLUMN-1	;"23H"
	TRO	%10,1			;"23H"
	CAILE	%10,2			;COUNT=2 AT FIRST TAB COLUMN	;"23H"
	MOVEI	%10,^D8(%10)		;COUNT=COUNT+8 W/2= LAST DIGIT	;"23H"
	JRST	NCDML3			;AND CONTINUE	;"21O"
PST0ML:
	PUSH	%17,%11
PSTML:					;PRINT STATEMENT ML
	SETZM	ERRPNT+ZZ		;ERROR ROLL PNTR
	PUSHJ	%17,SUEML		;SET UP ERRORS ML
	MOVEM	%03,ERRFLA+ZZ		;ERROR FLAG
	SETOM	PSTCRD+ZZ		;INIT CARD COUNT
PSTML1:	AOS	%06,PSTCRD+ZZ
	CAML	%06,LCANUM+ZZ		;TEST FOR END
	JRST	PSTML7			;YES
	PUSHJ	%17,LINSET
	PUSHJ	%17,PLIML		;PRINT LINE ML
	JUMPE	%03,PSTML1		;BRANCH IF NO ERRORS
	LDB	%00,CEMADR		;ERROR
	SUB	%00,PSTCRD+ZZ		;THIS CARD?
	SOJN	%00,PSTML1		;NO
IFNDEF	FILE0,
<
	AOS	ERRCNT+ZZ		;TALLY ERROR COUNT
>
	MOVE	%00,CEMADR
	HRLI	%00,(POINT 6,,)		;CHANGE P & S FIELDS
	MOVEM	%00,PEMADR		;PRINT ERROR MSG ADDRESS
	MOVEI	%11,N1			;ERROR CNTR
PSTML2:	ADD	%11,LHAMAS+ZZ		;DECREMENT ERROR COUNT
	MOVE	%06,FICPNT		;FIRST INPUT CHAR PNTR
	LDB	%12,[POINT 7,@CEMADR,17]
PSTML3:	ILDB	%02,%06
	CAIN	%02,CRR			;TEST FOR END
	JRST	PSTML4			;YES
	CAIN	%12,1			;ERRONEOUS COLUMN?
	MOVEI	%02,UARROW		;YES
	CAIE	%02,UARROW		;"^"?
	MOVEI	%02,SPACE		;NO, SUBSTITUTE BLANK
	DPB	%02,%06
	SOJA	%12,PSTML3
PSTML4:	PUSHJ	%17,SUEML		;SET UP ERRORS ML
	LDB	%00,CEMADR
	SUB	%00,PSTCRD+ZZ
	SOSN	%00
	JUMPN	%03,PSTML2
					;LINE DELETED	;"23O"
	MOVE	%06,PSTCRD+ZZ
	PUSHJ	%17,PLIML		;PRINT LINE ML
PSTML5:	SETZM	CARBUF+1
	AOS	%06,PEMADR		;PRINT ERROR MSG ADDRESS
	HRR	%06,-1(%06)		;GET TRUE ADDRESS
	ADDI	%06,QTTBL
	MOVEI	%07,CARBUF+1
	HRLI	%07,(POINT 6,,29)
PSTML6:	ILDB	%00,%06
	IDPB	%00,%07
					;4 LINES DELETED ;"23Q"
	CAIE	%00,EOF			;TEST FOR END OF MESSAGE
	JRST	PSTML6			;NO
	MOVEI	%00,CRR			;YES, SET CR
	DPB	%00,%07
	MOVEI	%06,0
	PUSHJ	%17,LINSET	;ERROR MESSAGE IN 1ST BUFFER
	PUSHJ	%17,PLIML
	AOBJN	%11,PSTML5	
				;34 LINES DELETED	;"23O"
	JRST	PSTML1

PSTML7:	SETZM	ERRFLA+ZZ		;CLEAR ERROR FLAG
LINSET:	IMULI	%06,WPL
				;2 LINES DELETED	;"21A"
	ADDI	%06,CARBUF
	HRLI	%06,(POINT 7,,)
	MOVEM	%06,SEQPNT
	HRLI	%06,(POINT 6,,)
	MOVEM	%06,FICPNT
	AOS	%06,FICPNT
	POPJ	%17,			;EXIT
PLIML:					;PRINT LINE ML
PLIML1:	MOVE	%07,SEQPNT		;SEQNUM POINTER
	HRLI	%07,(POINT 6,,35)	;SET SIXBIT BYTE POINTER
IFNDEF	FILE0,				;"23B"
<	MOVE	%02,(%07)		;GET SEQNUM	;"21A"
	TRNE	%02,1			;HEADER REQUESTED ?	;"21A"
	TRO	%16,HDRBIT		;YES, INFORM EXEC	;"21A"
>					;"23B"
PLIML5:	ILDB	%02,%07			;PICK UP CHARACTER
	CAIN	%02,CRR			;CARRIAGE RETURN?
	JRST	PLIML6			;YES
	CAIE	%02,SPACE		;SPACE?
	MOVEM	%07,1(%05)		;NO, MARK IT
					;2 LINES DELETED	;"21A"
	JRST	PLIML5

PLIML6:	IDPB	%02,1(%05)		;MARK THE END OF LINE
IFNDEF	$CREF,
<
;	SKIPE	PSTCRD+ZZ		;FIRST LINE OF STATEMENT ?;LINE DELETED ;"21X"
;	JRST	.+4			;NO, DON'T OUTPUT CREF LINE;LINE DELETED ;"21X"
	HRREI	%02,CRFLIN-40
	TLNN	%16,CSWFLG
	PUSHJ	%17,LSTOUT
>

IFDEF	$LOCAT,<		;[356] PRINT THE STARTING ADDRESS OF EACH SOURCE LINE
	MOVEI	%02,SPACE	;[356]
	PUSHJ	%17,PLIML8	;[356] PRINT A SPACE IF LISTING
	MOVE	%02,CODROL+ANCHOR	;[356] SEE IF ANYTHING IS ON
	CAMN	%02,CODROL+BOTTOM	;[356]  THE CODE ROLL
	JRST	PLIML0		;[356] NO, DON'T PRINT ADDRESS
	SKIPE	PSTCRD+ZZ	;[356] SEE IF FIRST LINE OF STATEMENT
	JRST	PLIML0		;[356]  NO, DON'T PRINT ADDRESS
	HRRZ	%15,LOCCNT+ZZ	;[356] GET LOCATION COUNTER
	AOJ	%15,		;[356] ZERO ADJUST IT
	MOVE	%07,[POINT 3,%15,17]	;[356] BYTE POINTER FOR PRINTER
	MOVEI	%06,6		;[356] 6 DIGIT PRINTOUT
PLIML9:	ILDB	%02,%07		;[356] GET NEXT DIGIT
	ADDI	%02,20		;[356] MAKE IT SIXBIT
	PUSHJ	%17,PLIML8	;[356] ADD IT TO LIST FILE
	SOJG	%06,PLIML9	;[356] LOOP TILL ALL DONE
PLIML0:	MOVEI	%02,TAB		;[356] AND END WITH A TAB
	PUSHJ	%17,PLIML8	;[356]
>;[356] END OF IFDEF $LOCAT

	SKIPN	ERRFLA+ZZ		;ERROR LINE PRINT ?
	JRST	.+6			;NO, OUTPUT TABS
	MOVEI	%15,^D8			;8 "*" = 1 TAB
	MOVEI	%02,ASTERI		;OUTPUT "*"
	PUSHJ	%17,PLIML7
	SOJG	%15,.-2			;OUTPUT 8 OF THEM
	JRST	.+3
	MOVEI	%02,TAB
	PUSHJ	%17,PLIML7		;PRINT TAB
	TLNE	%16,MOTFLG		;M SWITCH OR TTY LISTING ?
	JRST	PLIML2-1		;YES,NO MORE TABS
	MOVEI	%06,3			;SET TO THREE TABS
	PUSHJ	%17,LSTTAB		;OUTPUT TAB
	SOJG	%06,.-1			;TEST FOR END
	MOVE	%07,SEQPNT		;SEQNUM POINTER
PLIML2:	ILDB	%02,%07			;LIST SEQUENCE NUMBER
	JUMPE	%02,PLIML3
	SUBI	%02,40			;CONVERT TO SIXBIT
	PUSHJ	%17,PLIML7		;OUTPUT CHARACTER
	TLNE	%07,760000		;TEST FOR END
	JRST	PLIML2
PLIML3:	SETZM	@SEQPNT			;INITIALIZE SEQNUM
	HRLI	%07,(POINT 6,,35)	;SET TO SIXBIT
	MOVEI	%02,TAB			;LEAD OFF WITH TAB
PLIML4:	PUSHJ	%17,PLIML7		;LIST CHARACTER
	ILDB	%02,%07			;GET NEXT
					;2 LINES DELETED ;"21A"
	CAIE	%02,CRR			;TEST FOR END
	JRST	PLIML4			;NO, GET ANOTHER

PLIML7:	SKIPE	ERRFLA+ZZ
	JRST	ERROUT

IFDEF $LOCAT,<
PLIML8:
>
	TLNN	%16,LSTFLG
	JRST	LSTOUT
	POPJ	%17,
;PATCH TO DECIDE IF AN INDEX IS ALREADY IN USE BY AN OPEN LOOP
;BY SEARCHING DO LOOP OPEN ROLL, TO PREVENT NESTED LOOPS FROM USING
;THE SAME INDEX VARIABLE, AND TO PREVENT MODIFYING AN ACTIVE INDEX
;VARIABLE WITHIN AN OPEN LOOP.  PATCH LEVEL 26E-14/15.  IMPLEMENTATION
;REPORTED BY SPR 10-9854.  6-APR-73.
DLOSIZ==6+1		;SIX FOR DATA AND ONE FOR RSV
DLOIDX==3+1		;THREE TO POINT TO WORD AND ONE FOR RSV
DLUSML:	MOVEI	%12,DLOROL		;SEARCH DO LOOP OPEN ROLL
	MOVE	%10,ANCHOR(%12)		;STARTING AT ANCHOR
	MOVE	%00,REGTEM+ZZ		;WORD TO CHECK IS STORED IN REGTEM
	TLZ	%00,7777		;CLEAR OUT CARD AND COLUMN COUNTERS
DLUSD1:	CAML	%10,BOTTOM(%12)		;DONE SEARCHING ROLL?
	JRST	DLUSDF			;YES - EXIT FALSE
	MOVE	%03,DLOIDX+1(%10)	;GET POINTER TO INDEX VARIABLE
	TLZ	%03,7777		;CLEAR OUT CARD AND COLUMN POINTERS
	CAMN	%00,%03			;ARE THE TWO THE SAME?
	JRST	DLUSDT			;YES - EXIT TRUE
	MOVEI	%10,DLOSIZ(%10)		;NO - TRY NEXT ENTRY ON ROLL
	JRST	DLUSD1
DLUSDF:	TDZA	%03,%03			;EXIT FALSE
DLUSDT:	SETO	%03,			;EXIT TRUE
	AOJA	%01,PSEML		;GO TO NEXT POP

;PATCH TO DECIDE IF READING INTO A VARIABLE VIOLATES ANY PREVIOUSLY
;BUILT AND STORED SUBEXPRESSIONS.  
A.PRT==2		;POINTER TO A PART OF EXPRESSION
B.PRT==3		;POINTER TO B PART OF EXPRESSION
OP.PNT==1		;OPERATOR POINTER
SXPSIZ=5		;SIZE OF A GROUP ON SUBEXPRESSION ROLL

VIOCML:	MOVEI	%12,SUBROL		;[27J]SEARCH SUBEXPRESSION ROLL
	MOVE	%10,ANCHOR(%12)		;[27J]GET ANCHOR
	MOVE	%00,REGTEM+ZZ		;[27J]VARIABLE POINTER
	TLZ	%00,7777		;[27J]SHUT OFF CARD AND COLUMN NO.S
VICHK1:	CAML	%10,BOTTOM(%12)		;[27J]ARE WE DONE?
	JRST	VIOF			;[27J]YES, DONE W/NO VIOLATIONS
	MOVE	%03,A.PRT(%10)		;[27J]FETCH A PTR
	TLZ	%03,7777		;[27J]GET RID OF CARD AND COLUMN NUMBERS
	CAMN	%00,%03			;[27J]IF THEY ARE EQUAL
	JRST	VIOT			;[27J]SUBEXP VIOLATED
	MOVE	%03,B.PRT(%10)		;[27J]FETCH B PTR
	TLZ	%03,7777		;[27J]GET RID OF EXTRANEOUS STUFF
	CAMN	%00,%03			;[27J]		
	JRST	VIOT			;[27J]VIOLATION
	MOVEI	%10,SXPSIZ(%10)		;[27J]POINT TO NEXT GROUP ON ROLL
	JRST	VICHK1			;[27J]AND CHECK IT

VIOF:	TDZA	%03,%03			;[27J]FALSE RETURN
VIOT:	SETO	%03,			;[27J]TRUE RETURN
	AOJA	%01,PSEML		;[27J]NEXT POP
IFDEF	HALFWD,
<
OPJTBL:					;OP JUMP TABLE

	IF2,	<IFN CODE,	<
	RELOC	OPJTBL+<OPCNT-1>/3
	+CODE
	RELOC>>

	BLOCK	<OPCNT+2>/3
>
IFDEF	DEBUG,
ERRCO=	0	;"23O"
<

IFNDEF	FILE0,
<
	EXTERNAL	DEBSW
	EXTERNAL	DEBSW1,	DEBSW2,	DEBSW3,	DEBSW4,	DEBSW5,	DEBSW6,DEBSW7
>

IFDEF	HALFWD,
<
	INTERNAL	DEBITB

DBEML:
	MOVEM	%02,DEBSAV
	AOS	DEBCNT
	SKIPN	DEBSW7
	JRST	DBCONT
	HLRZ	%10,DEBSW7
	HRRZ	%07,DEBSW7
	CAIN	%07,(%01)
	JRST	BRKR
	CAIN	%10,(%01)
	JRST	BRKL
DBCONT:
	SKIPG	DEBSW
	JRST	DBEMLE
	AOS	DEBNXT
	HLRZ	%10,DEBSW1
	CAIN	%10,0(%01)
	IORM	%10,DEBLSW
	SKIPE	DEBLSW
	JRST	DBEMLE
	HLRZ	%07,DEBSW2
	HRRZ	%10,DEBSW2
	CAIG	%07,0(%01)
	CAIGE	%10,0(%01)
	CAIA
	JUMPN	%10,DBEMLE
	LDB	%10,[POINT 2,DEBSAV,19]
	CAIE	%10,3
	JRST	DBEMLB
	LDB	%10,[POINT 3,DEBSAV,22]
	MOVE	%07,DEBSW3
DBEMLA:	SKIPGE	%07
	JUMPE	%10,DBEMLE
	LSH	%07,1
	SOJGE	%10,DBEMLA
	JRST	DBEMLF

DBEMLB:	SETOM	DEBTMP
	LDB	%02,[POINT 7,DEBSAV,26]
DBEMLC:	AOS	%10,DEBTMP
	CAILE	%10,3
	JRST	DBEMLF
	MOVE	%07,%10
	IMULI	%07,^D36
	MOVE	%00,DEBSW4(%10)
DBEMLD:	JUMPE	%00,DBEMLC
	CAMN	%07,%02
	JUMPL	%00,DBEMLE
	LSH	%00,1
	AOJA	%07,DBEMLD

DBEMLF:
	SKIPE	DEBNXT
	JRST	DBEXIT

DBEMLE:
	PUSHJ	%17,DEBSP		;[342]
	PUSHJ	%17,DEBSP		;[342]
	MOVE	%07,[POINT 3,%01,20]	;SET TO PRINT PC
	PUSHJ	%17,DEBDMP
	SETOM	DDMALG		;27D ALLIGN TAB FIELD
	MOVEI	%07, (%01)	;27D
	PUSHJ	%17, DEBDMS	;27D
	SETZM	DDMALG		;27D
	SETZM	DDMNAK		;[342]
	LDB	%07,[POINT 2,DEBSAV,19]	;GET POP CONDITIONAL BITS
	CAIL	%07,3		;SEE IF EXTENDED ADDRESS INSTRUCTION
	JRST	DBEML1		;YES, GO DO DIFFERENTLY
	LDB	%07,[POINT 7,DEBSAV,26]	;GET POP OP CODE
	MOVE	%10,DEBITB(%07)	;PICK UP MNEMONIC FOR IT
	PUSHJ	%17,DEBSIX		;PRINT MNEMONIC
	LDB	%07,[POINT 2,DEBSAV,19]	;GET POP CONDITIONAL BITS
	XCT	DEBXTB(%07)	;PUT 'T' OR 'F' IN %02 OR SKIP
	PUSHJ	%17,LSTOUT		;PRINT T OR F
	PUSHJ	%17,DEBTAB
	LDB	%07,[POINT 7,DEBSAV,26]	;[342] GET POP OP CODE
	CAIL	%07,W5			;[342] SEE IF IT'S A W5
	CAILE	%07,XW0.4		;[342] THRU XW0.4
	JRST	DBEML3			;[342] NO
	LDB	%07,[POINT 9,DEBSAV,35]	;[342] YES, GET ADDRESS PORTION
	MOVE	%10,DEBITB(%07)		;[342] CONVERT TO OP MNEMONIC
	PUSHJ	%17,DEBSIX		;[342] PRINT MNEMONIC
	PUSHJ	%17,DEBTAB		;[342]
	PUSHJ	%17,DEBTAB		;[342]
	JRST	DBEFIN			;[342] GO PRINT REST

DBEML3:	CAIE	%07,REG		;[342] 2 MORE OF THE BELOW
	CAIN	%07,CFP			;[342]
	JRST	DBEM35			;[342]
	CAIL	%07,RSV			;[342] SEE IF A ROLL REFER-
	CAILE	%07,CFP			;[342]  ENCE INSTRUCTION
	JRST	DBEML4			;[342] NO, SKIP TO NEXT SPECIAL
DBEM35:	LDB	%07,[POINT 9,DEBSAV,35]	;[342] YES, GET ROLL NUMBER
	ROT	%07,-1			;[342] AND CONVERT IT TO
	MOVE	%10,DEBROL(%07)		;[342] A MNEMONIC
	SKIPGE	%07			;[342] IF NEGATIVE,
	HRLZI	%10,(%10)		;[342] USE RIGHT HALF ONE
	HRRI	%10,'ROL'		;[342]
	PUSHJ	%17,DEBSIX		;[342] PRINT IT
	PUSHJ	%17,DEBTAB		;[342]
	PUSHJ	%17,DEBTAB		;[342]
	JRST	DBEFIN			;[342]

DBEML4:	CAIL	%07,POC			;[342] SEE IF POC THRU
	CAILE	%07,BIK			;[342] BIK INSTRUCTION
	AOS	DDMALG			;[342] NO, THEN DON'T ACCEPT .XX ADDRESS
	CAIL	%07,IPK			;[342] SEE IF EARMARK INSTRUCTION
	CAILE	%07,IER			;[342]
	SKIPA				;[342]
	SETOM	DDMNAK			;[342] YES, ONLY ACCEPT EM LABEL
	CAIL	%07,SMK			;[342] SEE IF EARMARK INSTRUCTION
	CAILE	%07,SON			;[342]
	SKIPA				;[342]
	SETOM	DDMNAK			;[342] YES, ONLY ACCEPT EM LABEL

	CAIL	%07,SCE			;[342] SEE IF CHARACTER SCAN
	CAILE	%07,CSF			;[342]  WITH THE SIXBIT CHAR AS
	JRST	DBEML5			;[342]  THE POP ADDRESS
	CAIN	%07,SCK			;[342] NOT THIS GUY
	JRST	DBEML5			;[342]
	PUSHJ	%17,LSTOUT		;[342] CHARACTER ALREADY IN %02
	PUSHJ	%17,DEBTAB		;[342]
	PUSHJ	%17,DEBTAB		;[342]
	JRST	DBEFIN			;[342]

DBEML5:	LDB	%07, [POINT 9,DEBSAV,35]	;27D GET POP ADDRESS
	PUSHJ	%17, DEBDMS	;27D GO PRINT SYMBOLIC
	SETZM	DDMALG			;[342] CLEAR NO . FLAG
	SETZM	DDMNAK			;[342] CLEAR EM OR ML FLAG
	PUSHJ	%17,DEBSP
	PUSHJ	%17,DEBSP
	PUSHJ	%17,DEBSP
	MOVE	%07,[POINT 3,DEBSAV,26]
	PUSHJ	%17,DEBDMP
	JRST	DBEFIN

DBEML1:	LDB	%07,[POINT 3,DEBSAV,22]
	CAIL	%07,7
	JRST	DBEML2
	MOVE	%10,DEBJTB(%07)
	PUSHJ	%17,DEBSIX
	PUSHJ	%17,DEBTAB
	LDB	%07, [POINT 13,DEBSAV,35]	;27D
	PUSHJ	%17, DEBDMS	;27D
	PUSHJ	%17,DEBSP
	MOVE	%07,[POINT 3,%10,20]
	LDB	%10,[POINT 13,DEBSAV,35]
	PUSHJ	%17,DEBDMP
	JRST	DBEFIN

DBEML2:	LDB	%07,[POINT 2,DEBSAV,24]	;XML OR XIT INSTRUCTION (EXACTLY THE SAME)
	MOVE	%10,XITTBL(%07)		;GET MNEMONIC
	LDB	%07,[POINT 11,DEBSAV,35]	;[342] GET ADDRESS
	ADDI	%07,F4				;[342] CONVERT TO ABSOLUTE
	PUSH	%17,%07				;[342] SAVE IT
	CAIL	%07,P2EML			;[342] SEE IF REALLY
	CAIL	%07,EXEQML+2			;[342]  A XIT
	HRLI	%10,'XML'			;[342] NO, MAKE IT XML
	PUSHJ	%17,DEBSIX
	PUSHJ	%17,DEBTAB
	SETZM	DDMNAK			;[342] SET TO +1
	AOS	DDMNAK			;[342] WITHOUT USING A REG
	POP	%17,%07			;[342] GET ABSOLUTE ADDRESS BACK
	PUSHJ	%17,DEBDMS		;[342] ACCEPTING ONLY LABEL ENDING IN 'ML'
	SETZM	DDMNAK			;[342] CLEAR ONLY ML FLAG
	PUSHJ	%17,DEBSP
	PUSHJ	%17,DEBSP
	LDB	%10,[POINT 11,DEBSAV,35]	;GET ACTUAL ADDRESS
	MOVE	%07,[POINT 3,%10,23]	;SET 5 DIGITS COUNT
	PUSHJ	%17,DEBDMP
	JRST	DBEFIN
>
DEBSP:	MOVEI	%02,SPACE
	JRST	LSTOUT

DEBSIX:	SETZ	%07,			;PRINT OUT SIXBIT FROM %10
	LSHC	%07,6
	MOVE	%02,%07
	PUSHJ	%17,LSTOUT
	JUMPN	%10,DEBSIX
	POPJ	%17,

IFDEF HALFWD,<
DEBITB:	BLOCK	OPCNT			;DEBUG INST TABLE

DEBXTB:	CAIA
	MOVEI	%02,F
	MOVEI	%02,T

DEBJTB:	SIXBIT	/JMP/
	SIXBIT	/JMPT/
	SIXBIT	/JMPF/
	SIXBIT	/JSB/
	SIXBIT	/JSBT/
	SIXBIT	/JSBF/
	SIXBIT	/JOW/

XITTBL:	SIXBIT	/XIT/
	SIXBIT	/XITF/
	SIXBIT	/XITT/

DEBTMP:	0
DEBCNT:	0
DEBLSW:	0
DEBNXT:	0

DEBROL:	BYTE	(18)'LBL','OAR','UN2','APL','PCO','COD','GSP','REG'	;[342]
	BYTE	(18)'ICO','CPO','MDL','AER','OCO','HCO','FCO','CCO'	;[342]
	BYTE	(18)'SCA','LDM','ARR','NNA','ARE','GAL','ERR','TEM'	;[342]
	BYTE	(18)'SUB','APN','SUD','NES','CDM','IMP','LSP','DLO'	;[342]
	BYTE	(18)'ITE','ATE','DIM','DAR','LIM','DST','ETE','VAR'	;[342]
	BYTE	(18)'IID','SII','RID','LID','CRF','AST','DPI','CID'	;[342]
	BYTE	(18)'EDA','CDA','LRO','FTA','OPC','LFU',0,0,0,0	;[342]
;[342] TABLE OF ROLL MNEMONICS

>

	DEBSAV:	0

IFNDEF	HALFWD,
<

DBEML:
	MOVEM	%02,DEBSAV
	MOVE	%07,[POINT 3,%01,17]
	PUSHJ	%17,DEBDMP		;DUMP POPMEM ADDRESS
	MOVE	%07,[POINT 3,%06]
	PUSHJ	%17,DEBDMP

>
DBEFIN:

	MOVEI	%02,T
	SKIPN	%03
	MOVEI	%02,F
	PUSHJ	%17,LSTOUT
	PUSHJ	%17,DEBTAB

	MOVE	%07,%04		;GET EXIT ROLL POINTER
	SUB	%07,DEBS04		;COMPUTE PRESENT LEVEL
	PUSHJ	%17,DEBLVL		;PRINT LEVEL & CONTENTS
	MOVE	%07,%05			;GET WORK ROLL POINTER
	SUB	%07,DEBS05		;COMPUTE PRESENT LEVEL
	PUSHJ	%17,DEBLVL		;PRINT LEVEL & CONTENTS
	SKIPN	%07,DEBSW6		;LIST UPPER MEMORY LOCATION?
	JRST	DBEFI3			;NO, CONTINUE
	TLZE	%07,1			;LIST IN SIXBIT?
	JRST	DBEFI1			;YES, SETUP & LIST
	HRRZS	%07			;CLEAR LEFT HALF
	ADD	%07,[POINT 3,ZZ,]		;MAKE BYTE POINTER WITH ADDRES+ZZ
	PUSHJ	%17,DEBDMP		;DUMP IN OCTAL
	JRST	DBEFI2			;CONTINUE
DBEFI1:	MOVE	%10,ZZ(%07)		;GET CONTENTS
	PUSHJ	%17,DEBSIX		;DUMP IN SIXBIT
DBEFI2:	PUSHJ	%17,DEBTAB		;OUTPUT A TAB
DBEFI3:	HRRZ	%02,%14
	CAIL	%02,TAB
	MOVEI	%02,UARROW
	PUSHJ	%17,LSTOUT
	MOVEI	%02,CRR
	PUSHJ	%17,LSTOUT

IFDEF	HALFWD,
<
;DELETE LINE TO ENABLE ROLL DUMPS ON DEBSW=2  REPEAT 0,
;<
	MOVE	%02,DEBSW
	TRNE	%02,2
	PUSHJ	%17,ROLLST

;>
DBEXIT:	HRRZ	%10,DEBSW1
	CAIN	%10,0(%01)
	SETZM	DEBLSW
>
	MOVE	%02,DEBSAV
	POPJ	%17,


DEBDMP:	ILDB	%02,%07
	ADDI	%02,20
	PUSHJ	%17,LSTOUT
	TLNE	%07,770000
	JRST	DEBDMP
DEBTAB:	MOVEI	%02,TAB
	JRST	LSTOUT
	; THIS IS THE BREAK PART ADDED

BRKL:	TTCALL	3,[ASCIZ/
POP ADDR BREAK (LH):
/]
	SKIPA
BRKR:	TTCALL	3,[ASCIZ/
POP ADDR BREAK (RH):
/]
BREAK:	JRST	DBCONT			;SET BREAKPOINT AT THIS LOC
; THIS PAGE WAS CREATED FOR EDIT 27D.  IT IS A SYMBOLIC REPRES-
;ENTATION ROUTINE. (IT PRINTS THE SYMBOLIC REPRESENTATION OF THE
;VALUE SUPPLIED IN AC 7).

DEBDMS:	PUSH	%17, %01	; SAVE AC1
	SETZM	DDMOFS
	HLRE	%02, .JBSYM	; GET -LEN OF SYMBOL TABLE
	ASH	%02, -1		; NEG # OF ENTRIES
	HRRZ	%01, .JBSYM	; PTR TO TABLE

DDMS1:	CAMN	%07, 1(%01)	; VALUE EXACT?
	JRST	DDMS2		; YES
	CAML	%07, 1(%01)	; NO, TOO LOW?
	JRST	DDMS8		; YES
DDMS15:	ADDI	%01, 2
	AOJL	%02, DDMS1	; NO, TRY NEXT ENTRY
	MOVE	%01, DDMSYM	; DONE - USE THE CLOSEST
	MOVEI	%10,DDMSYM	;[342] SET UP %10 FOR SPECIALS
	SETZM	DDMNAK		;[342] CLEAR ANY SPECIAL SEARCHES
	SKIPL	DDMALG		;[342] BUT NOT PC LOC MODE
	SETZM	DDMALG		;[342]
	JRST	DDMS25		;

DDMS2:	MOVEI	%10,(%01)	;[342] SAVE SYMBOL TABLE POINTER
	MOVE	%01, (%01)	;
	SETZM	DDMOFS		; NO OFFSET
DDMS25:	TLZ	%01, 740000	; CLEAR BITS
	SKIPN	DDMNAK		;[342] SEE IF SUPPOSED TO HAVE ML OR EM
	JRST	DDMS27		;[342] NO
	MOVE	%00,%01		;[342] YES, GET LAST 2 CHARACTERS
	IDIVI	%00,50*50	;[342] FROM RADIX50
	MOVEI	%00,(%01)	;[342] SAVE THEM
	MOVE	%01,(%10)	;[342] AND RESTORE SYMBOL
	SKIPL	DDMNAK		;[342] SEE IF NEEDS TO BE EM
	JRST	DDMS26		;[342] NO
	CAIN	%00,1157	;[342] CHECK FOR EM IN RADIX50
	JRST	DDMS29		;[342] IT IS, SO ACCEPT IT
	MOVEI	%01,(%10)	;[342] NO, CONTINUE SEARCH
	JRST	DDMS15		;[342]

DDMS26:	CAIN	%00,1656	;[342] CHECK FOR ML IN RADIX50
	JRST	DDMS29		;[342] IT IS, SO ACCEPT IT
	MOVEI	%01,(%10)	;[342] NO, CONTINUE SEARCH
	JRST	DDMS15		;[342]

DDMS27:	SKIPGE	DDMALG		;[342] SEE IF DOING PC ADDRESS
	JRST	DDMS29		;[342] YES, ACCEPT ANYTHING
	MOVE	%00,%01		;[342]
DDMS28:	IDIVI	%00,50		;[342] PULL OFF FIRST CHARACTER
	CAIL	%00,50		;[342] FROM RADIX50 SYMBOL
	JRST	DDMS28		;[342] BY ITSELF
	MOVE	%01,(%10)	;[342] RESTORE SYMBOL
	SKIPLE	DDMALG		;[342] SEE IF LABEL MUST START WITH .
	CAIE	%00,45		;[342] SEE IF IT IS A .
	CAIN	%00,47		;[342] NOBODY CAN START WITH %
	CAIA			;[342]
	JRST	DDMS29		;[342] YES, ACCEPT SYMBOL
	MOVEI	%01,(%10)	;[342] NO, CONTINUE SEARCH
	JRST	DDMS15		;[342]

DDMS29:	SETZ	%07,		;[342] SET TO PRINT SYMBOL LEFT JUSTIFIED
	TLZ	%01,740000	;[342] CLEAR SYMBOL BITS

DDMS3:	IDIVI	%01, 50		; GET NEXT CHARACTER
	PUSH	%17, %02	; SAVE IT
	AOJ	%07,		;[342] 
	JUMPN	%01,DDMS3	;[342]
	SKIPGE	DDMALG		;[342]
	MOVEM	%07,DDMNAK	;[342] SAVE NUMBER OF CHARACTERS

DDMS4:	POP	%17, %02	; RESTORE CHARACTER
	JUMPE	%02, DDMS5	; NULL, PUT A SPACE
	CAILE	%02, 12		; NUMERAL (0-9)?
	JRST	DDMS6
	ADDI	%02, 17		; YES, FORM SIXBIT

DDMS5:	PUSHJ	%17, LSTOUT	; PUT CHARACTER
	SOJG	%07, DDMS4	;[342] MORE?
	SKIPE	DDMOFS		; NO, ANY OFFSET?
	JRST	DDMS9		; YES, DO IT
DDMS55:	POP	%17, %01	; NO, RESTORE AC 1
	SKIPL	DDMALG		;[342] ALIGN?
	JRST	DEBTAB
	MOVEI	%02,9		;[342] PUT ENOUGH SPACES TO ALIGN TABS
	SUBM	%02,DDMNAK	;[342] LENGTH OF SYMBOL
	PUSHJ	%17,DEBSP	;[342]
	SOSLE	DDMNAK		;[342]
	JRST	.-2		;[342]
	JRST	DEBTAB		; FINISH WITH A TAB

DDMS6:	CAILE	%02, 44		; LETTER?
	JRST	DDMS7
	ADDI	%02, 26	;
	JRST	DDMS5

DDMS7:	CAIN	%02, 45		; PERIOD?
	MOVEI	%02, 16
	CAIN	%02, 46		; DOLLAR SIGN?
	MOVEI	%02, 4
	CAIN	%02, 47		; PERCENT?
	MOVEI	%02, 5
	JRST	DDMS5

DDMS8:	MOVEI	%10, (%07)
	SUB	%10, 1(%01)	; GET THIS OFFSET
	SKIPE	DDMOFS		; ANY OFFSET NOW?
	CAMGE	%10, DDMOFS	; YES, IS THIS CLOSER?
	CAIA			; YES
	JRST	DDMS15		; NO, KEEP GOING
	MOVEM	%10, DDMOFS	; YES, UPDATE OFFSET VALUE
	MOVE	%10, (%01)
	MOVEM	%10, DDMSYM	; AND THAT SYMBOL
	JRST	DDMS15

DDMS9:	MOVEI	%02, "+"-40	; DO OFFSET: FIRST, PLUS
	PUSHJ	%17, LSTOUT
	MOVE	%01, DDMOFS
	MOVE	%07, [POINT 3,DDMOFS]	; PARTIAL PTR TO OFFSET
	JFFO	%01, .+1
	MOVNI	%01, (%02)	; GET NEG # OF ZERO BITS
	ADDI	%01, ^D36+2	; # OF USED BITS (PLUS 2, FOR THE I OF ILDB)
	IDIVI	%01, 3
	IMULI	%01, 3		; POSITION
	DPB	%01, [POINT 6,%07,5]	; FIX PTR TO OFFSET
DDMS95:	ILDB	%02,%07		;[342] DEBDMP WITH OUT TAB AT END
	ADDI	%02,20		;[342] CONVERT TO SIXBIT
	PUSHJ	%17,LSTOUT	;[342]
	TLNE	%07,770000	;[342]
	JRST	DDMS95		;[342]
	JRST	DDMS55		;[342] GO LINE UP TABS

DDMSYM:	BLOCK	1		; STORAGE FOR CLOSEST SYMBOL NAME
DDMOFS:	BLOCK	1		; OFFSET OF THAT SYMBOL
DDMALG:	BLOCK	1		;[342] IF NEGATIVE, PUT SPACES TO ALIGN TAB FIELD FOR PC
				;[342] IF POSITIVE, DON'T ACCEPT LABEL WITH .
DDMNAK:	BLOCK	1		;[342] IF NEGATIVE, ACCEPT ONLY EARMARK LABEL
				;[342] IF POSITIVE, ACCEPT ONLY ML SUBROUTINE LABEL
DEBLVL:					;OUTPUT LEVEL & CONTENTS
	MOVE	%10,[POINT 3,%07,8]	;POINT TO FOURTH BYTE
	ILDB	%02,%10			;GET IT
	TLNE	%07,700			;LEADING ZERO?
	TROA	%02,N0			;NO, CONVERT TO SIXBIT
	MOVEI	%02,SPACE		;YES, SUBSTITUTE SPACE
	PUSHJ	%17,LSTOUT		;LIST IT
	ILDB	%02,%10			;FETCH NEXT BYTE
	TLNE	%07,770			;LEADING ZEROS?
	TROA	%02,N0			;NO, CONVERT TO SIXBIT
	MOVEI	%02,SPACE		;YES, SUBSTITUTE SPACE
	PUSHJ	%17,LSTOUT		;LIST IT
	ILDB	%02,%10			;FETCH LOW ODER BYTE
	TRO	%02,N0			;CONVERT TO SIXBIT
	PUSHJ	%17,LSTOUT		;LIST IT
	PUSHJ	%17,DEBSP		;LIST TWO SPACES
	PUSHJ	%17,DEBSP
	HRLI	%07,(POINT 3,,)		;PREPARE TO LIST CONTENTS
	MOVEI	%10,6			;SET COUNT FOR HALF
DEBLV1:	ILDB	%02,%07			;FETCH NEXT OCTAL CHARACTER
	TRO	%02,N0			;CONVERT TO SIXBIT
	PUSHJ	%17,LSTOUT		;LIST IT
	SOSN	%10			;TIME FOR CENTER SPACE?
	PUSHJ	%17,DEBSP		;YES, LIST IT
	TLNE	%07,770000		;FINISHED?
	JRST	DEBLV1			;NO, CONTINUE OUTPUT
	JRST	DEBTAB			;YES, TAB AND EXIT
DEBS04:	BLOCK	1			;INITIAL EXIT ROLL POINTER
DEBS05:	BLOCK	1			;INITIAL WORK ROLL POINTER


;DELETE LINE TO ENABLE ROLL DUMP ON DEBSW=2  REPEAT 0,
;<
ROLLST:	SKIPN	DEBSW5			;EXIT IF NO ROLLS
RLST1:	POPJ	%17,			;ARE SPECIFIED
	MOVEI	%07,0			;START ROLL COUNT AT 0
	MOVE	%11,%07			;START ENTRY COUNT AT 0
	MOVE	%12,[POINT 6,DEBSW5]	;SET UP BYTE POINTER
DPBYTE:	ILDB	%02,%12			;PICK UP A ROLL NO.
	TLNN	%12,770000		;IS THIS THE LAST ROLL
	JRST	RESET			;NO, GET THE NEXT
	JUMPE	%02,DPBYTE		;THROW IT AWAY IF 0
	CAIN	%02,77			;DO I WANT ROLL 0
	SETZ	%02,			;THEN MAKE IT RIGHT
	MOVEM	%02,ROLL(%07)		;STORE ROLL NO.
	MOVE	%10,BOTTOM(%02)		;FIRST ENTRY ON ROLL
	SUB	%10,ANCHOR(%02)		;LAST ENTRY
	HRLM	%10,ROLL(%07)		;STORE THE ROLL SIZE
	ADD	%11,%10			;TO TELL IF ANY NEED BE LISTED
	AOJA	%07,DPBYTE		;

RESET:	JUMPE	%11,RLST1		;NO ROLL ENTRIES TO BE LISTED
	MOVEI	%10,0			;0 ROLL COUNT
	SOS	%07			;COUNTING FROM ZERO, REMEMBER
	MOVEM	%07,COUNT		;SAVE THE NO. OF ROLLS
BUBSRT:	MOVEI	%11,1(%10)		;AC11=AC10+1
BSRTA:	CAMLE	%11,COUNT		;ARE WE AT THE END
	AOJA	%10,BSRTB		;SEE IF WE ARE FINISHED
	HLR	%12,ROLL(%11)		;SEE WHICH IS GREATER
	HLR	%07,ROLL(%10)		;
	CAML	%07,%12			;
	AOJA	%11,BSRTA		;THE LARGER IS ON TOP
	MOVE	%02,ROLL(%11)		;SWITCH THEM
	MOVE	%12,ROLL(%10)		;IF THEY ARE NOT
	MOVEM	%02,ROLL(%10)		;
	MOVEM	%12,ROLL(%11)		;
	AOJA	%11,BSRTA		;BACK FOR MORE
BSRTB:	CAME	%10,COUNT		;ARE WE DONE YET
	JRST	BUBSRT			;NO
	MOVEI	%10,0			;YES, 0 THE POINTER
	PUSHJ	%17,DEBTAB		;MAKE A TAB
ROPRIN:	PUSHJ	%17,DEBTAB		;ANOTHER
	MOVE	%07,[POINT 3,ROLL(%10),29]	;
	PUSHJ	%17,DEBDMP		;DUMP THE ROLL
	AOJ	%10,			;INCRUMENT THE POINTER
	CAMG	%10,COUNT		;THRU YET
	JRST	ROPRIN			;NO
	PUSHJ	%17,DEBCR		;YES, CARRIAGE RETURN
	MOVEI	%10,0			;0 THE POINTER
	PUSHJ	%17,DEBTAB		;MAKE A TAB
ENPRIN:	PUSHJ	%17,DEBTAB		;AGAIN
	HLR	%11,ROLL(%10)		;PICKUP THE ROLL SIZE
	MOVE	%07,[POINT 3,%11,26]	;
	PUSHJ	%17,DEBDMP		;
	AOJ	%10,			;INCREMENT THE POINTER
	CAMG	%10,COUNT		;ARE WE THRU
	JRST	ENPRIN			;NO

	MOVEI	%10,0			;YES, 0 THE POINTER
ADRSET:	HRR	%11,ROLL(%10)		;EXCHANGE ROLL NO.
	MOVE	%11,BOTTOM(%11)		;
	HRRM	%11,ROLL(%10)		;
	AOJ	%10,			;
	CAMG	%10,COUNT		;THRU?
	JRST	ADRSET			;NO
	SETZM	RUNG			;YES, 0 THE RUNG POINTER
	PUSHJ	%17,DEBCR		;CR

ENTRY:	MOVEI	%10,0			;0 POINTER
	MOVE	%07,RUNG		;EXCEEDED MAX. RUNGS?
	CAILE	%07,77			;
	JRST	RLST1			;YES, EXIT
	PUSHJ	%17,ENDCHK		;ANYTHING TO LIST?
	JUMPE	%12,RLST1		;NO
	PUSHJ	%17,DEBCR	; <CR>
	MOVE	%07,[POINT 3,RUNG,29]	;
	PUSHJ	%17,DEBDMP		;DUMP THE RUNG NO.

RENTRY:	MOVE	%12,ROLL(%10)		;ROLL COUNT, POINTER
	HRRZM	%12,ROLL(%10)		;ONLY RIGHT HALF COUNTS
	MOVE	%07,[POINT 3,@ROLL(%10)]	;
	PUSHJ	%17,DEBDMP		;DUMP ROLL CONTENTS
	SUB	%12,[1000001]		;AND ADDRESS
	TLNN	%12,777777		;SIZE 0 MEANS DO NOT LIST
	SETZ	%12,			;
	MOVEM	%12,ROLL(%10)		;
	AOJ	%10,			;NEXT ROLL
	CAMLE	%10,COUNT		;DONE?
	JRST	NONZ			;
	HLRZ	%12,ROLL(%10)		;NO, IS THERE ANYTHING THERE TO LIST?
	JUMPN	%12,RENTRY		;YES, GO LIST IT
NONZ:	PUSHJ	%17,DEBCR		;NO, OUTPUT A CR
	AOS	RUNG			;MOVE TO NEXT RUNG
	JRST	ENTRY			;AND LIST IT
ENDCHK:	MOVEM	%10,HOLD		;SAVE PRESENT COUNTER
	MOVEI	%12,0			;0 ANY LEFT INDICATOR
	CAIE	%10,0			;0 FOR POINTER IF 0
ENDCH1:	ADDI	%10,1			;LOOK FIRST AT NEXT ROLL
	CAMLE	%10,COUNT		;LAST ROLL
	JRST	ENDCH2			;GET THE NEXT ONE
	HLR	%11,ROLL(%10)		;NO, PICK UP SIZE
	ADD	%12,%11			;KEEP TRACK OF IT
	JRST	ENDCH1			;GET THE NEXT ONE
ENDCH2:	MOVE	%10,HOLD		;RETURN PRESENT COUNT
	POPJ	%17,

DEBCR:	MOVEI	%02,CRR			;SETUP CARRIAGE RETURN
	JRST	LSTOUT			;LIST IT

RUNG:	BLOCK 1
COUNT:	BLOCK 1
HOLD:	BLOCK 1
ROLL:	EXP 0,0,0,0,0,0
;DELETED TO ENABLE ROLL DUMP ON DEBSW=2 >
>
;....EOF1

