TITLE 10S  MACRO PORTION OF FLECS FOR THE PDP-10
	VFLECS==22
	EDIT==36

	.JBVER==137
	LOC	.JBVER
	<VFLECS>B11+EDIT
	RELOC
;
;--------------------------------------------
;
;	MACRO-10 PACKAGE FOR USE WITH
;	FLECS SYSTEM ON THE PDP-10 IN INTERACTIVE MODE
;
;	AUTHOR:		TERRY BEYER
;	ADDRESS:	DEPARTMENT OF COMPUTER SCIENCE
;			UNIVERSITY OF OREGON
;			EUGENE, OREGON 97405
;	TELEPHONE:	(503) 686-4416
;	DATE:		OCTOBER 23,1974
;
;	REWRITE DONE AT SYRACUSE UNIVERSITY
;
;	NAME:		DAVID CARR
;	ADDRESS:	ACADEMIC COMPUTER CENTER
;			SYRACUSE UNIVERSITY
;			SYRACUSE, NEW YORK 13210
;	TELEPHONE:	(315) 423-3995
;	DATE:		JUNE 15,1975
;
;	FURTHER MODIFICATIONS:
;			BEYER	JULY 22,1975
;--------------------------------------------
;
;	ASSEMBLY PARAMETERS
;
;	(ON MEANS NON-ZERO, OFF MEANS ZERO)
;
;	F40	ON MEANS COMPILE FOR F40 (DEFAULT: OFF)
;	F10	ON MEANS COMPILE FOR F10. CAN ONLY BE ON IF
;		F40 IS OFF (DEFAULT: ON)
;	PURE	MAKE TWO SEGMENT CODE IF ON. MUST BE OFF IF F40
;		ON (DEFAULT: ON IF F10 IS ON, OFF OTHERWISE)
;	FOROTS	USE FOROTS IF ON. MUST BE OFF IF PURE IS ON (DEFAULT: OFF)
;	TVER	IF ON VERSION IS TYPED ON FIRST CALL TO OPENF (DEFAULT: OFF)
;	PDLEN	LENGTH OF PUSHDOWN LIST. NO EFFECT IF FOROTS IS ON.
;		DEFAULT IS 16.
;	BUFLEN	LENGTH OF CCL BUFFER. MUST BE LARGE ENOUGH FOR THE
;		WHOLE TMP FILE. DEFAULT IS 127. (635 CHARACHTERS)
;
;	NOTICE!!!!!!!!!!
;
;	THE CALLING SEQUENCES GENERATED BY THE F40 AND FORTRAN-10
;	COMPILERS DIFFER.
;
;	IF THE FLECS TRANSLATOR WITH WHICH THESE SUBROUTINES ARE
;	TO BE LOADED IS COMPILED UNDER THE OLD F40 COMPILER,
;	ASSEMBLE THIS FILE WITH THE SYMBOL "F40" .NE. 0
;
	IFNDEF F40,<	F40==0>
	IFE F40,<	F10==1>
	IFN F40,<	F10==0
			PURE==0>
	IFNDEF PURE,<	PURE==1>
	IFN PURE,<	FOROTS==0
			TWOSEG
			RELOC	400000
		DEFINE	HIGH,<RELOC>>
	IFE PURE,<	IFNDEF FOROTS,<FOROTS==0>
		DEFINE	HIGH,<>>
		SYN	HIGH,LOW
	IFNDEF PDLEN,<PDLEN==20>
	IFNDEF TVER,<TVER==0>
;
;-----------------------------------------------
;
;	EDIT HISTORY
;
;	34	BEYER REVISION OF SYRACUSE MODIFICATIONS
;	35	CHANGE DEVICE DEFAULT TO DSK FROM LPT FOR
;		CCL MODE
;	36	CHANGE BUFLEN DEFAULT TO 127 WORDS.
;
;------------------------------------
;
;	THE ENTRY POINTS ARE FOUND BELOW IN THE FOLLOWING ORDER
;
;	CHARACTER ROUTINES:
;		GETCH
;		PUTCH
;		CHTYP
;
;	STRING MOVING ROUTINES:
;		CPYSTR
;		CPYSUB
;		CATSTR
;		CATSUB
;
;	NUMERICAL STRING ROUTINES:
;		CATNUM
;		PUTNUM
;
;	STRING COMPARISON ROUTINES:
;		STREQ
;		STRLT
;
;	MISCELLANEOUS ROUTINES:
;		HASH
;		NEWNO
;
;	I/O ROUTINES:
;		OPENF
;		GET
;		PUT
;		CLOSEF
;
;
;	MAIN PROGRAM:
;		START
;
;
;	FOR A MORE COMPLETE FUNCTIONAL DEFINITION OF THESE
;	ROUTINES  PLEASE SEE THE FLECS SYSTEM MODIFICATION 
;	GUIDE.
;
;----------------------------------------------------------
;
	ENTRY GETCH
;
;	CALL GETCH(WD,POS,CH)
;	PLACES THE POS-TH CHARACTER FROM WORD WD IN CH
;	RIGHT JUSTIFIED AND LEFT PADDED WITH ZEROS.
;
	CH=1
	POS=2
;
GETCH:
IFN F40<Z>
	MOVE 	POS,@1(16)	; OBTAIN RELATIVE POSITION
	LDB	CH,PTR-1(POS)	; USE AN APPROPRIATE BYTE POINTER
	MOVEM	CH,@2(16)	; STORE IN THIRD ARGUMENT
IFN F40<JRA	16,3(16)	; RETURN>
IFN F10<POPJ	17,0		; RETURN>
;
;------------------------------------------------------------
;
;	POINTER TABLE FOR USE BY GETCH AND PUTCH
;
PTR:	POINT	7,@(16),6	; BYTE POINTERS TO THE FIVE
	POINT	7,@(16),13	; CHARACTERS FOR USE BY
	POINT	7,@(16),20	; GETCH AND PUTCH
	POINT	7,@(16),27
	POINT	7,@(16),34
;
;------------------------------------------------------------
;
	ENTRY PUTCH
;
;	CALL PUTCH(WD,POS,CH)
;	PLACES THE RIGHT MOST  7 BITS OF CH INTO THE
;	POS-TH CHARACTER POSITION IN WD
;
	CH=1
	POS=2
;
;
PUTCH:
IFN F40<Z>
	MOVE	CH,@2(16)	; OBTAIN WORD WITH CHARACTER
	MOVE	POS,@1(16)	; OBTAIN RELATIVE POSITION
	DPB	CH,PTR-1(POS)	; STORE IN FIRST ARGUMENT
IFN F40<JRA	16,3(16)	; RETURN>
IFN F10<POPJ	17,0		; RETURN>
;
;------------------------------------------------------------
;
	ENTRY CHTYP
;
;	I = CHTYP(CH)
;	SETS I TO A CODE VALUE GIVING THE SYNTACTIC TYPE OF 
;	CHARACTER CH
;
;
CHTYP:
IFN F40<Z>
	MOVE	1,@(16)		; OBTAIN CHARACTER CODE
	ROT	1,-1		; DIVIDE VALUE BY 2 AND SAVE PARITY
	JUMPL	1,.+3		; WAS CH ODD?
	HLRZ	0,CHTAB(1)	; NO USE LEFT HALF TABLE
IFN F40<JRA	16,1(16)	;   RETURN>
IFN F10<POPJ	17,0		; RETURN>
	HRRZ	0,CHTAB(1)	; YES,USE RIGHT HALF TABLE
IFN F40<JRA	16,1(16)	;   RETURN>
IFN F10<POPJ	17,0		; RETURN>
;
;	TABLE OF SYNTACTIC CODES FOR USE BY CHTYP
;
;
CHTAB:	BYTE (18)	7,7,7,7,7,7,7,7	;  O-07
	BYTE (18)	7,6,7,7,7,7,7,7	; 10-17
	BYTE (18)	7,7,7,7,7,7,7,7 ; 20-27
	BYTE (18)	7,7,7,7,7,7,7,7 ; 30-37
	BYTE (18)	6,7,7,7,7,7,7,7 ; 40-47
	BYTE (18)	4,5,7,7,7,3,7,7	; 50-57
	BYTE (18)	2,2,2,2,2,2,2,2 ; 60-67
	BYTE (18)	2,2,7,7,7,7,7,7 ; 70-77
	BYTE (18)	7,1,1,1,1,1,1,1 ;100-107
	BYTE (18)	1,1,1,1,1,1,1,1 ;110-117
	BYTE (18)	1,1,1,1,1,1,1,1 ;120-127
	BYTE (18)	1,1,1,7,7,7,7,7 ;130-137
	BYTE (18)	7,1,1,1,1,1,1,1 ;140-147
	BYTE (18)	1,1,1,1,1,1,1,1 ;150-157
	BYTE (18)	1,1,1,1,1,1,1,1 ;160-167
	BYTE (18)	1,1,1,7,7,7,7,7 ;170-177
;
;------------------------------------------------------
;
;	REGISTER ASSIGNMENTS FOR STRING ROUTINES
;
	A=1		; A,B, AND C ARE WORKING REGISTERS
	B=2		; 
	C=3		; 
	SS=4		; SOURCE STRING START INDEX
	SL=5		; SOURCE STRING LENGTH IN CHARACTER
	SA=6		; SOURCE STRING ADDRESS
	DA=7		; DESTINATION ADDRESS
	DL=10		; DESTINATION LENGTH
;
;-------------------------------------------------------
;
	ENTRY CPYSTR
;
;	CALL CPYSTR(DEST,SOURCE)
;	SETS STRING DEST EQUAL TO STRING SOURCE
;
CPYSTR:
IFN F40<Z>	
	;
	; SET UP BLOCK TRANSFER
	;
	MOVEI 	A,@(16)		; GET DESTINATION ADDRESS
	HRLI	A,@1(16)	; GET SOURCE ADDRESS
	;
	; COMPUTE NUMBER OF WORDS TO BE MOVED
	;
	MOVE	B,@1(16)	; GET SOURCE LENGTH
	MOVEI	B,-1(B)		; DECREMENT BY 1
	IDIVI	B,5		; DIVIDE BY NCHWRD
	ADDI	B,1(A)		; COMPUTE ADDR. OF LAST WORD
	;
	; TRANSFER THEM
	;
	BLT	A,(B)		; TRANSFER AND
IFN F40<JRA	16,2(16)	; RETURN>
IFN F10<POPJ	17,0		; RETURN>
;
;------------------------------------------------------
;
	ENTRY CPYSUB
;
;	CALL CPYSUB(DEST,SOURCE,START,LEN)
;	SETS THE DEST STRING EQUAL TO THE SUBSTRING
;	OF SOURCE STARTING AT START AND OF LENGTH LEN
;
CPYSUB:
IFN F40<Z>
	HRRZI	DA,@0(16)	; GET DEST ADDRESS
	HRRZI	SA,@1(16)	; GET SOURCE ADDRESS
	MOVE	SS,@2(16)	; GET START INDEX
	MOVE	SL,@3(16)	; GET SUBSTRING LENGTH
	MOVEM	SL,(DA)		; SET DESTINATION LENGTH
	MOVEI	DL,0		; SET CURRENT LENGTH FOR CON
	PUSHJ	17,CON		; MOVE THE STRING
IFN F40<JRA	16,4(16)	; RETURN>
IFN F10<POPJ	17,0		; RETURN>
;
;--------------------------------------------------
;
	ENTRY CATSTR
;
;	CALL CATSTR(DEST,SOURCE)
;	CONCATENATES THE STRING SOURCE TO THE RIGHT END
;	OF THE STRING DEST
;
CATSTR:
IFN F40<Z>
	HRRZI	DA,@0(16)	; GET DEST ADDRESS
	HRRZI	SA,@1(16)	; GET SOURCE ADDRESS
	MOVEI	SS,1		; SET START INDEX
	MOVE	SL,(SA)		; GET SOURCE LENGTH
	MOVE	DL,(DA)		; GET DEST LENGTH
	ADDM	SL,(DA)		; RESULTING LENGTH IS DL+SL
	PUSHJ	17,CON		; MOVE THE STRING
IFN F40<JRA	16,2(16)	; RETURN>
IFN F10<POPJ	17,0		; RETURN>
;
;----------------------------------------------------
;
	ENTRY CATSUB
;
;	CALL CATSUB(DEST,SOURCE,START,LEN)
;	CONCATENATES THE SPECIFIED SUBSTRING OF SOURCE
;	TO THE STRING DEST
;
CATSUB:
IFN F40<Z>
	HRRZI	DA,@0(16)	; GET DEST ADDR
	HRRZI	SA,@1(16)	; GET SOURCE ADDR
	MOVE 	SS,@2(16)	; GET SUBSTR START INDEX
	MOVE	SL,@3(16)	; GET SUBSTR LENGTH
	MOVE	DL,(DA)		; GET DESTINATION LENGTH
	ADDM	SL,(DA)		; SET RESULTING LENGTH
	PUSHJ	17,CON		; MOVE THE STRING
IFN F40<JRA	16,4(16)	; RETURN>
IFN F10<POPJ	17,0		; RETURN>
;
;-------------------------------------------------------------
;
;	INTERNAL CON (USED BY CPYSUB,CATSTR AND CATSUB)
;
;	CONCATENATES TWO STRINGS
;	USED BY CPYSUB, CATSTR, CATSUB
;	CALLED WITH REGISTERS SS, SL,SA,DA,DL
;	SET AS ABOVE BY A PUSHJ 17,CON
;
CON:
	; PREPARE DESTINATION BYTE POINTER
	;
	MOVEI	A,-1(SS)	; ADDRESS OF FIRST DESTINATION
	IDIVI	A,5		;   BYTE IS
	ADDI	A,1(SA)		;   A = (SS-1)/5 + 1 + SA
	HLL	A,[POINT 7,0]	; SET UP POINTER IN A
	SOJL	B,CON1		; SKIP PTR ADJUSTMENT IF FIRST BYTE
	IBP	A		; OTHERWISE ADJUST POINTER
	SOJGE	B,.-1		; TO APPROPRIATE VALUE
	;
	;
	; PREPARE SOURCE BYTE POINTER
	;
CON1:	MOVE	B,DL		; ADDR OF FIRST DESTINATION
	IDIVI	B,5		;   BYTE IS
	ADDI	B,1(DA)		;   A = DL/5 + 1 + DA
	HLL	B,[POINT 7,0]	; SET UP POINTER IN B
	SOJL	C,CON2		; SKIP PTR ADJUSTMENT IF FIRST BYTE
	IBP	B		; OTHERWISE ADJUST POINTER
	SOJGE	C,.-1		; TO APPROPRIATE VALUE
	;
	; MOVE THE BYTES
	;
CON2:	SOJL	SL,CPOPJ	; RETURN IF NULL STRING
CON2A:	ILDB	C,A		; GET  AND
	IDPB	C,B		; PUT A BYTE
	SOJGE	SL,CON2A	; AND LOOP TILL DONE
	POPJ	17,0
;
;----------------------------------------------------------------
;
	ENTRY CATNUM
;
;	CALL CATNUM(DEST,NUM)
;	CONCATENATES TO THE STRING DEST, THE 5 CHARACTER
;	REPRESENTATION FOR THE NUMBER NUM
;
CATNUM:
IFN F40<Z>
	MOVE	A,@1(16)	; GET NUMBER
	PUSHJ	17,CONVRT	; CONVERT TO ASCII
	MOVEM	C,SNUM+1	; PUT INTO DUMMY STRING
	MOVEI	DA,@0(16)	; SET UP CALL TO CATSTR
IFN F40<HRRM	DA,.+2		; BY SUPPLYING ADDR OF DEST
	JSA	16,CATSTR	; CALL CATSTR
	ARG	DA		;
	ARG	SNUM		;
	JRA	16,2(16)	; RETURN>
IFN F10<HRRM	DA,CATNA	; BY SUPPLYING ADDR OF DEST
	MOVEI	16,CATNA	; SET ADDR OF TRANSFER VECTOR
	PUSHJ	17,CATSTR	; CALL CATSTR
	POPJ	17,0		; RETURN
;
;	TRANSFER VECTOR FOR USE WITH F10
;
	LOW
	XWD	-2,0		; NUMBER OF ARGS
CATNA:	ARG	DA		;
	ARG	SNUM		;
	HIGH>
	;
	; DUMMY STRING
	;
	LOW
SNUM:	DEC	5
	Z
	HIGH
;
;------------------------------------------------------------
;
	ENTRY PUTNUM
;
;	CALL PUTNUM(DEST,NUM)
;	SETS THE FIRST FIVE CHARACTERS OF THE STRING DEST
;	TO THE VALUE OF NUM
;
PUTNUM:
IFN F40<Z>
	HRRZI	DA,@0(16)	; GET DESTINATION ADDRESS
	MOVE	A,@1(16)	; GET NUMBER
	PUSHJ	17,CONVRT	; CONVERT TO ASCII
	MOVEM	C,1(DA)		; PUT IN PLACE
IFN F40<JRA	16,2(16)	; RETURN>
IFN F10<POPJ	17,0		; RETURN>
;
;------------------------------------------------------------
;
;	INTERNAL CONVRT ( USED BY CATNUM AND PUTNUM )
;
;
20000	;	PUSHJ 17,CONVRT
20050	;	CONVERTS VALUE IN A TO 5 DIGIT ASCII
20100	;	USES 0 AND B
20150	;	RETURNS RESULT IN C
20200	;
20250	CONVRT:	SETZ	C,		; CLEAR CHARACTER ACCUMALATOR
20300		MOVEI	0,5		; USE 0 AS LOOP COUNT
20350		IDIVI	A,^D10		; GET NEXT DIGIT
20400		MOVEI	B,60(B)		; CONVERT TO ASCII
20450		LSHC	B,-7		; SHIFT INTO C
20500		SOJG	0,.-3		; LOOP 5 TIMES
20550		POPJ	17,0		; RETURN
20600	;
20650	;--------------------------------------------------------
20700	;
20750	;	REGISTERS FOR STREQ AND STRLT
20800	;
20850		L=1		; NUMBER OF CHARACTERS TO COMPARE
20900		K=2		; WORKING REGISTER
20950		S1A=3		; INDEXES STRING 1
21000		S2A=4		; INDEXES STRING 2
21050		N==4		; HIGHEST REGISTER TO SAVE
21100	;
21150	;--------------------------------------------------------
21200	;
21250		ENTRY STREQ
21300	;
21350	;	L = STREQ(S1,S2)
21400	;	SETS L .TRUE. OR .FALSE. DEPENDING ON
21450	;	WHETHER STRING S1 IS IDENTICAL TO S2
21500	;
21550	STREQ:
21600	IFN F40<Z>
21650		;
21700		; QUICK CHECK ON LENGTH
21750		;
21800		MOVEI	0,0		; SET UP DEFAULT OF .FALSE.
21850		MOVE	L,@0(16)	; GET LENGTH OF S1
21900		CAME	L,@1(16)	; SAME LENGTH AS S2?
21950	IFN F40<JRA	16,2(16)	; NO - RETURN .FALSE.>
22000	IFN F10<POPJ	17,0		; RETURN>
22050		PUSHJ	17,SAVEAC
22100		PUSHJ	17,COMP		; ARE STRINGS SAME?
22150		SETOI			; IF SO, CHANGE TO TRUE
22200		JRST	RSTR4		; RESTORE AND RETURN
22250	;
22300	;---------------------------------------------------------
22350	;
22400		ENTRY	STRLT
22450	;
22500	;	L = STRLT(S1,S2)
22550	;	SETS L .TRUE. OR .FALSE. DEPENDING ON WHETHER
22600	;	STRING S1 IS LESS THEN S2
22650	;
22700	STRLT:
22750	IFN F40<Z>
22800		PUSHJ	17,SAVEAC
22850		; SET DEFAULT IN CASE ONE STRING IS AN INITIAL
22900		; SEGMENT OF THE OTHER
22950		;
23000		MOVEI	0,0		; SET DEFAULT OF .FALSE.
23050		MOVE	L,@0(16)	; GET LENGTH OF S1
23100		CAML	L,@1(16)	; IS S1 SHORTER THAN S2?
23150		SKIPA	L,@1(16)	; NO - SET UP SHORTER LENGTH
23200					; AND SKIP
23250		MOVNI	0,1		; YES - CHANGE DEFAULT TO .TRUE.
23300		;
23350		; COMPARE FIRST L CHARACTERS
23400		;
23450		PUSHJ	17,COMP		; ARE FIRST L CHARS  SAME ?
23500		JRST	RSTR4		; YES - RETURN WITH DEFAULT
23550		;
23600		; COMPARE DIFFERENCE IN STRINGS
23650		;
23700		MOVE	L,(S1A)		; NO - SET UP DIFFERENCE
23750		LSH	L,-1		;   WORD FOR S1
23800		MOVE 	K,(S2A)		; AND CORRESPONDING
23850		LSH	K,-1		;   WORD FOR S2
23900		MOVEI	0,0		; SET DEFAULT OF .FALSE.
23950		CAMGE	L,K		; IS WORD IN S1 .GE.  WORD IN S2?
24000		MOVNI	0,1		; NO - SET RESULT TO .TRUE.
24025		JRST	RSTR4		; RESTORE AND RETURN
24027	;
24029	;------------------------------------------------------
24031	;
24033	;	INTERNAL RSTR4 & RSTR 3
24035	;
24037	;	RESTORE AC'S 4 (OR 3) THROUGH 2 AND POPJ
24039	;
24450		;
24500		;	SAVE AC'S 2-4
24502		;
24550	SAVEAC:	POP	17,SAVE17
24600		PUSH	17,2
24650		PUSH	17,3
24700		PUSH	17,4
24750		PUSH	17,SAVE17
24800		POPJ	17,0
24802		;
24804		; RESTORE AC'S AND EXIT
24806		;
24808	RSTR4:	POP	17,4		; RESTORE REGISTERS 4-2
24810	RSTR3:	POP	17,3		; RESTORE REGISTERS 3-2
24812		POP	17,2
24814	IFN F40<JRA	16,2(16)	; RETURN>
24816	IFN F10<POPJ	17,0		; RETURN>
24900	;
24950	;--------------------------------------------------------
25000	;
25050	;	INTERNAL COMP ( USED BY STREQ AND STRLT )
25100	;
25150	;	THE CODE :
25200	;		MOVEI	L,N
25250	;		PUSHJ	17,COMP
25300	;	WILL DO A NORMAL RETURN IF THE FIRST N CHARACTERS
25350	;	OF S1 AND S2 (BASED ON REGISTER 16) ARE EQUAL
25400	;	OTHERWISE A SKIP RETURN IS MADE AND S1A AND S2A INDEX
25450	;	THE CORRESPONDING WORDS WHICH ARE DIFFERENT.
25500	;
25550	COMP:	JUMPE	L,CPOPJ		; RETURN EQUAL IF LENGTH IS 0
25600		HRRZI	S1A,@0(16)	; GET ADDR OF S1
25650		HRRZI	S2A,@1(16)	; GET ADDR OF S2
25700	COMP1:	MOVEI	S1A,1(S1A)	; INCREMENT ADDRESSES IN
25750		MOVEI	S2A,1(S2A)	;   S1 AND S2
25800		MOVE	K,(S1A)		; SET UP FOR COMPARISON
25850		XOR	K,(S2A)		; SET UP POSITIONS WHERE THEY DIFFER
25900		SUBI	L,5		; DECREMENT LENGTH BY 5
25950		JUMPLE	L,COMP2		; IS THIS LAST WORD ?
26000		TRZ	K,1		; NO- MASK OUT BIT 35
26050		JUMPE	K,COMP1		; IF EQUAL, KEEP LOOPING
26100		JRST	CPOPJ1		; NOT EQUAL - GO TO .NE. EXIT
26150		;
26200		; DEAL WITH LAST WORD
26250		;
26300	COMP2:	AND	K,MASK+4(L)	; MASK OUT RESIDUAL BITS
26350		JUMPE	K,CPOPJ		; IF EQUAL - RETURN EQUAL
26400		;
26450		; EXIT - NOT EQUAL
26500		;
26550	CPOPJ1:	AOS	(17)
26600	CPOPJ:	POPJ	17,0
26650	;
26700	;---------------------------------------------------
26750		;
26800		; MASKS FOR DELETING RESIDUAL BITS ( USED BY COMP AND HASH)
26850		;
26900	MASK:	OCT	774000000000	; 1 CHAR
26950		OCT	777760000000	; 2 CHARS
27000		OCT	777777700000	; 3 CHARS
27050		OCT	777777777400	; 4 CHARS
27100		OCT	777777777776	; 5 CHARS
27150	;
27200	;-------------------------------------------------------------
27250	;
27300		ENTRY HASH
27350	;
27400	;	I = HASH(STRING,PRIME)
27450	;	SETS I EQUAL TO AN INTEGER IN THE RANGE
27500	;	0 ... (PRIME - 1) OBTAINED BY HASHING STRING
27550	;
27600	HASH:
27650	IFN F40<Z>
27700		PUSH	17,2
27750		PUSH	17,3
27800		HRRZI	2,@0(16)	; 2 = (ADDR OF STRING)
27850		MOVE	0,(2)		; 0 = (LENGTH OF STRING)
27900		ADDI	0,4		; ADJUST AND DIVIDE
27950		IDIVI	0,5		; 0 = (# OF WORDS)
28000					; 1 = (# OF CHARS IN LASTWD) -1
28050		MOVE	3,2		;
28100		ADD	3,0		; 3 = (ADDRESS OF LASTWD)
28150		MOVN	0,0		; 0 = -(# OF WORDS)
28200		HRL	2,0		; PLACE COUNT IN LH OF 2
28250		MOVE	0,MASK(1)	; 0 = (MASK FOR LAST WORD)
28300		AND	0,(3)		; SET UP MASKED LAST WORD
28350		AOBJP	2,HASH1		; OMIT LOOP IF ONLY 1 WORD
28400		XOR	0,(2)		; XOR IN NEXT WORD
28450		AOBJN	2,.-1		; LOOP UNTIL DONE
28500	HASH1:	LSH	0,-1		; MAKE > 0 AND DISCARD BIT 35
28550		IDIV	0,@1(16)	; DIVIDE BY PRIME AND
28600		MOVE	0,1		; SET UP REMAINDER
28650		JRST	RSTR3		; RESTORE AND RETURN
28700	;
28750	;----------------------------------------------------------
28800	;
28850		ENTRY NEWNO
28900	;
28950	;	N=NEWNO(K)
29000	;	   WHERE K > 0 SETS THE SEED TO K AND RETURNS K
29050	;	N=NEWNO(0)
29100	;	   DECREMENTS THE SEED AND RETURNS  ITS NEW VALUE
29150	;
29200	NEWNO:
29250	IFN F40<Z>
29300		SKIPN	1,@(16)		; IS THE ARG 0
29350		SOSA	1,NEWNOA	; YES  GET LAST # AND SUB 1 (SKIP)
29400		MOVEM	1,NEWNOA	; NO  STORE THIS ONE
29450		MOVE	1		; RETURN IT REG 0
29500	IFN F40<JRA	16,1(16)	; RETURN NEW SEED>
29550	IFN F10<POPJ	17,0		; RETURN>
29600		LOW
29650	NEWNOA:	Z
29700		HIGH
29750	;
29800	;-----------------------------------------------------------
29850	;
29900		ENTRY OPENF
29950	;
30000	;	CALL OPENF(CALLNO,DONE,SVER)
30050	;	INVOKES OPENF AS DESCRIBED IN THE SYSTEM MODIFICATION
30100	;	GUIDE.
30150	;
30200		;
30250		; WORKING REGISTERS
30300		;
30350		A=1
30400		B=2
30450		C=3
30500		D=4
30550		E=5
30600		R=6
30630		;
30650		; DATA AREA
30670		;
30690	
30700		LOW
30750	SAVE17:	BLOCK	1	;SAVE REG 17 HERE
30800	IFE FOROTS,<STTIME: BLOCK 1>
30850		;
30900		; LOOKUP, ENTER, AND BUFFER HEADERS FOR THE VARIOUS FILES
30950		;
31000	RUNDEV:	BLOCK	1		; DEVICE FOR RUN UUO(MUST BE JUST BEFORE NAME:)
31050	NAME:	BLOCK	5		; FILENAME BLOCK FOR UUO'S
31100	BUFH1:	BLOCK 	3		; BUFFER HEADER FOR CHAN 1(FLX)
31150	BUFH2:	BLOCK	3		; BUFFER HEADER FOR CHAN 2(LST)
31200	BUFH3:	BLOCK	3		; BUFFER HEADER FOR CHAN 3(F4)
31250	EDAT:				; START OF AREA TO BE CLEARED @ START OF SCAN OF FILE SPEC.
31300	NOF4:	BLOCK	1		; NON-ZERO IF NO F4 OUTPUT
31350	DEVF:	BLOCK	1		; DEVICE FOR F4 OUTPUT OR 0 (NONE SPECIFIED) OR 1 (NONE WANTED)
31400	FNAME:	BLOCK	4		; F4 FILENAME
31450	NOLST:	BLOCK	1		; NON-ZERO IF NO LISTING
31500	DEVL:	BLOCK	1		; LISTING DEVICE OR 0 (NONE SPECIFIED) OR 1 (NONE WANTED)
31550	LNAME:	BLOCK	4		; LISTING FILENAME
31570	NOERR:	BLOCK	1		; NON-ZERO IF NO ERROR TO TTY
31600	EEND:				; END OF AREA TO CLEAR
31650		;
31700		; FORM FEED FLAG SET BY GET USED BY PUT
31750		;
31800	FORMF:	BLOCK	1		;
31850		;
31870		;CRLF USED FOR TYPEOUTS
31880		;
31900		HIGH
32000	CRLF:	ASCIZ \
32050	\
32060		;
32100		; INITIAL OPENF LOGIC FOLLOWS
32150		;
32200	OPENF:
32250	IFN F40<Z>
32300		MOVE	A,@0(16)	; GET CALLNO
32350		SETOM	LINENO		; INITIALIZE INTERNAL LINE NUMBER
32400		SETZM	FORMF		; INITIALIZE FORMF
32450		SKIPE	TMPFLG		; ARE WE CCL?
32500		JRST	OPENF2		; NO - SKIP TYPEOUT
32550	IFN TVER,<CAIN	A,1		; IS THIS FIRST CALL?
32600		PUSHJ	17,TYPVER	; YES - TYPE VERSION NUMBER>
32650	OPENF1:	OUTSTR	[ASCIZ /
32700	*/]				; ASK FOR NAME OF FILE
32750	OPENF2:	JRST	GETNXT		; GET NEXT COMMAND STRING (RETURN ONLY IF FURTHER FILES TO BE PROSESSED)
32850	GOTNXT:	SKIPN	TMPFLG		; ARE WE CCL?
32900		JRST	OPENF3		; NO - ONWARD
32950		OUTSTR	[ASCIZ \FLECS: \] ; SHOW WHAT WE ARE DOING
33000		MOVE	A,NAME		; AND TO WHOM WE ARE DOING IT
33050		PUSHJ	17,SIXPRT	; BOTH NAME
33060		OUTCHR	["."]		; AND
33070		MOVE	A,NAME+1	;
33080		PUSHJ	17,SIXPRT	; EXTENSION
33100		OUTSTR	CRLF		; AND MAKE THINGS NEAT
33150	OPENF3:	PUSHJ	17,OPENFX	; OPEN FLECS FILE
33200		SKIPN	NOLST		; SKIP IF NO LISTING
33250		PUSHJ	17,OPENFL	; OPEN LISTING FILE
33300		SKIPN	NOF4		; SKIP IF NO F4 OUTPUT
33350		PUSHJ	17,OPENF4	; OPEN FORTRAN FILE
33400		SETZM	@1(16)		; SET DONE .FALSE.
33450	IFN F40<JRA	16,3(16)	; RETURN>
33500	IFN F10<POPJ	17,0		; RETURN>
33550		;
33600		; TYPE OUT VERSION NUMBER
33620		;
33650	IFN TVER,<
33700	TYPVER:	MOVSI	B,(POINT 7,,35)		; SETUP BYTE POINTER
33750		MOVE	C,@2(16)		; GET  COUNT
33800		HRRI	B,@2(16)		; ADDRESS IN RIGHT
33900		ILDB	A,B			; GET CHR
33950		OUTCHR	A			; TYPE IT
34000		SOJG	C,.-2			; GET ALL
34050		OUTSTR	CRLF			; TYPE CRLF
34100		POPJ	17,0			; AND RETURN>
34150		;
34200		; PROCESS NEST COMMAND STRING
34250		;
34300	GETNXT:	SETZM	EDAT		; PREPARE TO CLEAR DATA AREA
34350		MOVE	A,[EDAT,,EDAT+1]
34400		BLT	A,EEND-1	; AND CLEAR
34420		;
34430		;PROCESS NEXT FILE SPEC
34440		;
34450	GETNB:	SETZM	RUNDEV		; INIT DEVICE
34460		;
34470		;PROCESS NEXT SYMBOL IN FILE SPEC
34480		;
34500	GETN8:	SETZM	NAME		; INIT. SIXBIT NAME TO NULLS
34550		MOVE	A,[SIXBIT /FLX/]; AND EXTENSION
34600		MOVEM	A,NAME+1	; TO "FLX"
34650		SETZM	NAME+3		; CLEAR PPN
34700		PUSHJ	17,INCH		; INPUT A CHARACTER
34750		CAIE	A,12		; IS IT A BREAK?
34800		JRST	GETN1		; NO  GO ASSEMBLE FILENAME
34850		SKIPN	FNAME		; HAVE WE SEEN A F4 FILE NAME?
34900		SKIPE	LNAME		; OR A LAST FILE NAME?
34950		JRST	BADNAM		; YES - FLECS NAME IS MISSING.
35000		JRST	EXDONE		; NO - LINE EMPTY, SIGNAL DONE.
35050		;
35100		; ASSEMBLE NEXT SYMBOL
35150		;
35200	GETN1:	MOVE	D,[POINT 6,NAME]; SET UP SIXBIT POINTER
35250		MOVEI	E,6		; WANT 6 OR FEWER CHARACTERS
35300	GETN2:	PUSHJ	17,CHOK		; CHECK CHAR AND CONVERT
35350		JRST	GETN3		; NOT A LETTER OR DIGIT
35400		IDPB	B,D		; SAVE IN SIXBIT
35450		PUSHJ	17,INCH		; GET NEXT CHAR
35500		SOJG	E,GETN2		; LOOP FOR 6 CHARS
35550		PUSHJ	17,CHOK		; SEVENTH SHOULD NOT BE ALPHA NUM
35600		JRST	GETN3		; NOT ALPHA NUM - GO SEE WHAT IT IS
35650		JRST	GETN6		; ALPHA NUM - HENCE SYNTAX ERROR
35700		;
35750		; ASSEMBLE DEVICE
35800		;
35850	GETN3:	CAIL	E,6		; WERE ANY ALPHA NUM CHARS ENCOUNTERED
35900		JRST	GETN9		; NO - GO DETERMIN DISPOSITION
35950		CAIN	A,":"		; YES - WAS THIS A DEVICE?
36000		JRST	[SKIPE	RUNDEV
36050			JRST	GETN7
36100			MOVE	A,NAME
36150			MOVEM	A,RUNDEV
36200			JRST	GETN8]
36210		;
36220		; ASSEMBLE EXTENSION
36230		;
36250		CAIE	A,"."		; IS EXTENSION SPECIFIED?
36300		JRST	GETN5		; NO - CHECK FOR [PPN]
36350		PUSHJ	17,INCH		; YES -- GET NEXT CHAR
36400		SETZM	NAME+1		; AND SIXBIT EXTENSION
36450		MOVE	D,[POINT 6,NAME+1]	; SIXBIT POINTERS
36500		MOVEI	E,3		; WANT 3 OR FEWER CHARS
36550	GETN4:	PUSHJ	17,CHOK		; CHECK CHAR AND CONVERT
36600		JRST	GETN5		; NOT LETTER OR DIGIT
36650		IDPB	B,D		; AND IN SIX BIT
36700		PUSHJ	17,INCH		; GET NEXT CHAR
36750		SOJG	E,GETN4		; LOOP FOR 3 CHARS
36800		PUSHJ	17,CHOK		; FOURTH SHOULD NOT BE ALPHA
36850		JRST	GETN5		; NOT ALPHA - GO SEE WHAT IT IS
36900		JRST	GETN7		; VALID - HENCE SYNTAX ERROR
36950		;
37050		; ASSEMBLE [PPN]
37070		;
37100	GETN5:	CAIE	A,"["		; PPN?
37150		JRST	GETND		; NO -  CHECK CCL LINK
37200		PUSHJ	17,OCTIN	; GET PROJ
37250		SKIPN	B		; NULL?
37300		HLR	B,MYPPN		; YES USE OURS
37350		CAIE	A,","		; PROPER DELIM?
37400		JRST	GETN6		; NO - BAD SYNTAX
37450		HRLM	B,NAME+3	; STORE IT
37500		PUSHJ	17,OCTIN	; GET PROG
37550		SKIPN	B		; NULL?
37600		HRR	B,MYPPN		; USE OURS
37650		CAIE	A,"]"		; PROPER DELIM?
37700		JRST	GETN6		; NO -  BOMB
37750		HRRM	B,NAME+3	; STORE
37800		PUSHJ	17,INCH		; GET CHR
37810		;
37820		; PROCESS CCL LINK
37830		;
37850	GETND:	CAIE	A,"!"		; CCL LINK?
37900		JRST	GETN9		; NO - JUMP
37910		SKIPE	MAJERF		; ANY MAJOR ERRORS?
37920		JRST	ABORT		; YES - TOO BAD
37950		PUSHJ	17,INCH		; NO FLUSH THE REST OF THE LINE
38000		CAIE	A,12		; DONE YET?
38050		JRST	.-2		; NO -  GO FOR MORE
38100		HLLZ	A,NAME+1	; GET EXT
38150		CAMN	A,['FLX   ']	; OLD DEFAULT?
38200		SETZI	A,		; YES - USE NEW
38250		MOVEM	A,NAME+1	; PUT IT BACK
38300		SKIPN	A,RUNDEV	; GET DEVICE
38350		MOVSI	A,'SYS'		; FOR DEFAULT
38400		MOVEM	A,RUNDEV	; STORE DEVICE
38450		SETZM	NAME+2		; CLEAR THESE
38500		SETZM	NAME+4
38550		MOVE	B,[1,,RUNDEV]	; CCL RUN AND BLOCK
38600	IFE PURE,<MOVEM	17,SAVE17	; RUN UUO KILLS AC'S>
38650		RUN	B,		; RUN IT
38700	IFN PURE,<HALT>			; RUN UUO KILLS HISEG
38750	IFE PURE,<			; IF LOWSEG WE CAN REPORT IT WITHOUT MUCH TROUBLE
38800		SETOM	TMPFLG		; THIS WILL GARANTEE WE DONT GET BACK
38850		MOVE	17,SAVE17
38900		MOVE	A,RUNDEV	; GET DEVICE
38950		OUTSTR	[ASCIZ \
38960	?FLXRUE  Run UUO\]
39000		JRST	NOOPN4>		; REPORT THE TROUBLE
39050		;
39100		; FILE SPECIFICATION HAS BEEN ACCUMULATED
39110		; DETERMINE DISPOSITION BASED ON DELIMETER
39150		;
39160		;
39170		; PROCESS LF
39180		;
39200	GETN9:	CAIN	A,12		; LF?
39250		JRST	[SKIPE	DEVF	; YES - SO NO "," HAS BEEN SEEN
39300			SKIPE	DEVL	; NO - OK IF BOTH "," AND "="
39350			JRST	GOTNXT	; THEN GO!
39400			JRST	BADNAM]	; ELSE BAD SYNTAX!
39410		;
39420		; PROCESS ","
39430		;
39450		CAIE	A,","		; NO LF -  ","?
39500		JRST	GETNA		; NO -  CHECK FOR "="
39550		SKIPE	DEVF		; YES -  DO WE HAVE ONE YET?
39600		JRST	GETN7		; YES -  ONE'S ENOUGH
39650	GETNC:	SKIPN	NAME		; DID HE GIVE A NAME?
39700		SKIPE	RUNDEV		; OR DEVICE?
39750		CAIA
39800		JRST	[SETOM	DEVF	; NO -   SHOW HE DID SOMETHING ABOUT F4
39850			SETOM	NOF4	;      BUT WANTS NO OUTPUT
39900			JRST	GETNB]	;	GET NEXT FILE
39950		MOVE	A,NAME+1	; YES -  GET EXT
40000		CAMN	A,['FLX   ']	; WAS IT DEFAULT?
40050		MOVSI	A,'F4 '		; YES - USE THIS ONE
40100		MOVEM	A,NAME+1	; PUT IT BACK
40150		MOVSI	B,'DSK'		; GET DEFAULT
40200		SKIPN	RUNDEV		; NEED IT?
40250		MOVEM	B,RUNDEV	; USE IT
40300		MOVE	A,[RUNDEV,,DEVF]; SET FOR BLT
40350		BLT	A,FNAME+3	; DO IT
40400		JRST	GETNB		; GET MORE
40450		;
40460		; PROCESS "="
40470		;
40500	GETNA:	CAIE	A,"="		; "="?
40550		JRST	GETN6		; NO - SYNTAX ERR
40600		SKIPN	DEVF		; GOT F4?
40650		JRST	[SETOM	DEVL	; NO - THEN THIS IS IT AND NO LISTING
40700			SETOM	NOLST	;     SHOW NO LISTING
40750			JRST	GETNC]	;     GO STORE AS F4
40800		SKIPE	DEVL		; YES - LISTING ALREADY SPECIFIED
40850		JRST	GETN7		; YES - DON'T GET ANOTHER
40900		SKIPN	NAME		; DOES HE WANT A FILE
40950		SKIPE	RUNDEV		; OR DEVICE
41000		CAIA
41050		JRST	[SETOM	DEVL	; NO -  SHOW HE SAID SOMETHING ABOUT LST
41100			SETOM	NOLST	;    SHOW NO LIST
41150			JRST	GETNB]	; GO GET MORE
41200		MOVE	A,NAME+1	; GET EXT
41250		CAMN	A,['FLX   ']	; WAS IT DEFAULT?
41300		MOVSI	A,'LST'		; YES -USE THIS ONE
41350		MOVEM	A,NAME+1	; PUT IT BACK
41400		SKIPN	B,RUNDEV	; NEED DEFAULT?
41405		MOVSI	B,'DSK'		; YES-GET IT
41410		SKIPE	TMPFLG		; CCL MODE?
41415		CAME	B,[SIXBIT /LPT/]; YES-IS DEVICE LPT?
41420		CAIA			; NO-DEVICE OK
41425		MOVSI	B,'DSK'		; CHANGE LPT TO DSK IF CCL
41430		MOVEM	B,RUNDEV	; USE THIS DEVICE
41550		MOVE	A,[RUNDEV,,DEVL]; READY FOR A BLT
41600		BLT	A,LNAME+3	; DO IT
41650		JRST	GETNB		; GO FOR MORE
41700		;
41710		; FLUSH LINE AND REPORT SYNTAX ERRORS
41720		;
41750	GETN7:	PUSHJ	17,INCH		; SCAN TO <LF>
41800	GETN6:	CAIE	A,12		;
41850		JRST	GETN7
41900		JRST	BADNAM
41950		;
42000		; CONVERT LC TO UC
42050		; CHECK FOR LETTER OR DIGIT
42100		; SET UP SIX BIT
42150		;
42200	CHOK:	CAIL	A,141		; IS IT UPPER CASE LETTER?
42250		CAILE	A,172		; 
42300		CAIA			; NO - CONTINUE
42350		MOVEI	A,-40(A)	; YES - CONVERT TO LOWER CASE
42400		CAIL	A,101		; IS IT A LETTER?
42450		CAILE	A,132		; 
42500		CAIA			; NO - CONTINUE
42550		JRST	CHOK1		; YES - RETURN OK
42600		CAIL	A,60		; IS IT A DIGIT?
42650		CAILE	A,71		;
42700		POPJ	17,0		; NO - NOT OK RETURN
42750	CHOK1:	MOVEI	B,-40(A)	; CONVERT TO SIXBIT
42800		JRST	CPOPJ1		; AND SKIP RETURN
42850		;
42900		; SIGNAL DONE TO CALLING PROGRAM AND RETURN
42950		;
43000	EXDONE:	SETOM	@1(16)		; SET DONE TO .TRUE.
43050	IFN F40<JRA	16,3(16)	; RETURN>
43100	IFN F10<POPJ	17,0		; RETURN>
43150		;
43200		; INFORM USER OF INVALID NAME, TRY AGAIN
43250		;
43300	BADNAM:	OUTSTR	[ASCIZ /?FLXIFS  Improper file specification/]
43350		CAIA
43360		;
43370		; ERROR EXIT
43380		;
43400	ERRRET:	POP	17,A
43450		SKIPN	TMPFLG		; ARE WE CCL?
43500		JRST	OPENF1		; NO - TRY AGAIN
43550		EXIT			; YES - BOMB
43600		;
43650		; ATTEMPT TO OPEN INPUT FILE FOR FLECS SOURCE
43700		;
43750	OPENFX:	SKIPN	A,RUNDEV	; IS THERE A DEVICE?
43800		MOVSI	A,'DSK'		; NO - USE DSK
43850		SETZI			; ASCII MODE
43900		MOVEI	B,BUFH1		; BUFFER
43950		OPEN	1,		; TRY OPEN
44000		JRST	NOINIT		; NO GO
44050		LOOKUP	1,NAME		; CAN WE OPEN FOR INPUT?
44100		JRST	NOOPN1		; NO - TROUBLE
44150		POPJ	17,0
44250		;
44300		; ATTEMPT TO OPEN OUTPUT FILE FOR LISTING
44350		;
44400	OPENFL:	SKIPE	DEVL		; WAS THERE A FILE SPEC.?
44450		JRST	OPENL1		; YES - GO TO L1
44500		MOVSI	B,'LST'		; NO - USE THIS DEFAULT
44550		MOVEM	B,NAME+1	; STORE IT
44600		MOVSI	A,'DSK'		; GET DEVICE
44650		SETZM	NAME+2		; CLEAR FOR DATE75
44700		SETZM	NAME+3		; AND PPN
44750		JRST	OPENL2		; GO DO IT
44800	OPENL1:	SKIPN	A,LNAME		; IF HIS ISN'T THERE
44850		MOVE	A,NAME		; USE DEFAULT
44900		MOVEM	A,LNAME		; BUT USE SOMETHING
44950		MOVE	A,[LNAME,,NAME]	; GET FILE SPEC.
45000		BLT	A,NAME+3	; PUT IT HERE
45050		MOVE	A,DEVL		; GET DEVICE
45070		CAMN	A,[SIXBIT /TTY/]	; LISTING TO TTY?
45080		SETOM	NOERR		; YES - ONLY WANT ERRORS ONCE
45100	OPENL2:	SETZI			; ASCII MODE
45150		MOVSI	B,BUFH2		; HEADER
45200		OPEN	2,		; OPEN IT
45250		JRST	NOINIT		; CAN'T
45300		ENTER	2,NAME		; ATTEMPT TO OPEN FILE
45350		JRST	NOOPN2		; CAN'T - TROUBLE
45400		POPJ	17,0		; RETURN
45500		;
45550		; ATTEMPT TO OPEN OUTPUT FILE FOR FORTRAN OUTPUT
45600		;
45650	OPENF4:	SKIPE	DEVF		; SAME AS FOR OPENFL:
45700		JRST	OPEN41
45750		MOVSI	B,'F4 '
45800		MOVEM	B,NAME+1
45850		MOVSI	A,'DSK'
45900		SETZM	NAME+2
45950		SETZM	NAME+3
46000		JRST	OPEN42
46050	OPEN41:	SKIPN	A,FNAME
46100		MOVE	A,NAME
46150		MOVEM	A,FNAME
46200		MOVE	A,[FNAME,,NAME]
46250		BLT	A,NAME+3
46300		MOVE	A,DEVF
46350	OPEN42:	SETZI
46400		MOVSI	B,BUFH3
46450		OPEN	3,
46500		JRST	NOINIT
46550		ENTER	3,NAME		; ATTEMPT TO OPEN FILE
46600		JRST	NOOPN2		; CAN'T - TROUBLE
46650		POPJ	17,0
46700		;
46750		; VARIOUS UGLY ERROR HANDLERS FOLLOW
46800		;
46850	NOINIT:	OUTSTR	[ASCIZ \?FLXCID  Cannot initialize device \] ; TELL
46900		PUSHJ	17,DEVPRT	; PRINT DEVICE
46950		JRST	ERRRET		; AND RETURN
47000	
47050	NOOPN1:	HRRZ	B,NAME+1	; ERROR CODE
47100		JUMPN	B,NOOPN3	; JUMP IF OTHER THAN ZERO
47150		OUTSTR	[ASCIZ \?FLXNSF  No such file as \] ; NOT THERE
47200		JRST	FILPRT		; TELL WHAT
47250	
47300	NOOPN3:	OUTSTR	[ASCIZ \?FLXLEF  Lookup\]	; LOOKUP PROBS
47350		JRST	NOOPN4		; CONTINUE
47400	
47450	NOOPN2:	OUTSTR	[ASCIZ \?FLXEEF  Enter\]	; ENTER PROBS
47500		HRRZ	B,NAME+1	; GET ERROR CODE
47550	NOOPN4:	OUTSTR	[ASCIZ \ error (\] ; SAY ERROR
47600		PUSHJ	17,OCTPRT	; SAY WHICH
47650		OUTSTR	[ASCIZ \) for file \]
47660		;
47670		; TYPE FILE SPECIFICATIONS PART OF ERROR MESSAGE
47680		;
47700	FILPRT:	PUSHJ	17,DEVPRT	; PRINT DEVICE
47750		MOVE	A,NAME		; GET FILENAME
47800		PUSHJ	17,SIXPRT	; PRINT IT
47850		HLLZ	A,NAME+1	; GET EXT
47860		OUTCHR	["."]		; SAY DOT
47900		SKIPE	A		; SKIP IF NULL
48000		PUSHJ	17,SIXPRT	; PRINT EXT
48050		HLRZ	B,NAME+3	; GET PROJ
48100		JUMPE	B,ERRRET	; RETURN IF NONE
48150		OUTCHR	[133]		; PRINT [
48200		PUSHJ	17,OCTPRT	; PRINT PROJ
48250		OUTCHR	[","]		; PRINT ,
48300		HRRZ	B,NAME+3	; GET PROG
48350		PUSHJ	17,OCTPRT	; PRINT IT
48400		OUTCHR	[135]		; PRINT ]
48450		JRST	ERRRET		; RETURN
48500		;
48510		; TYPE DEVICE MNEMONIC IN REG A
48520		;
48550	DEVPRT:	PUSHJ	17,SIXPRT	; PRINT IT
48600		OUTCHR	[":"]		; AND :
48650		POPJ	17,0
48700		;
48710		; SCAN OCTAL NUMBER FROM INPUT
48720		;
48750	OCTIN:	SETZI	B,		; INIT AC
48800		PUSH	17,B		; SAVE B
48850		PUSHJ	17,INCH		; GET CHR
48900		POP	17,B		; RESTORE B
48950		SUBI	A,"0"		; MAKE NUMERIC
49000		JUMPL	A,OCTRET	; LESS THAN "0"?
49050		CAIL	A,10		; GREATER THAN "7"
49100		JRST	OCTRET		; YES - RETURN
49150		IMULI	B,10		; SHIFT
49200		ADD	B,A		; AND ADD
49250		JRST	OCTIN+1		; GET NEXT DIGIT
49300	OCTRET:	ADDI	A,"0"		; RESTORE A
49350		POPJ	17,0		; RETURN
49400		;
49410		; TYPE NUMBER IN REG B
49420		;
49450	DECPRT:	SKIPA	D,[^D10]	; DECIMAL PRINT
49500	OCTPRT:	MOVEI	D,^D8		; OCTAL PRINT
49550	RDXPRT:	IDIVI	B,(D)		; SHAVE OFF DIGIT
49600		HRLM	C,(17)		; STORE IT
49650		SKIPE	B		; ANY MORE?
49700		PUSHJ	17,RDXPRT	; YES  GET MORE
49750		HLRZ	B,(17)		; GET DIGIT
49800		ADDI	B,"0"		; MAKE IT A CHR
49850		OUTCHR	B		; PRINT IT
49900		POPJ	17,0		; GO FOR MORE AND RETURN
49950		;
49960		; TYPE CONTENTS OF REG A IN SIXBIT
49970		;
50000	SIXPRT:	MOVE	B,[440600,,A]	; SETUP POINTER
50050		ILDB	C,B		; GET A CHR
50100		JUMPE	C,CPOPJ		; JUMP IF DONE
50150		ADDI	C," "		; MAKE IT ASCII
50200		OUTCHR	C		; PRINT IT
50250		TLNE	B,770000	; DONE?
50300		JRST	SIXPRT+1	; NO  GO FOR MORE
50350		POPJ	17,0
50360		;
50370		; ABORT CCL RUN UUO IF MAJOR ERRORS
50380		;
50385	ABORT:	OUTSTR	[ASCIZ \
50390	?FLXFEA  Further execution aborted DUE TO MAJOR ERRORS\];DON'T CONTINUE
50395		EXIT			; BYE BYE
50400	;
50450	;
50500	;-----------------------------------------------------------
50550	;
50600	;	REGISTERS FOR GET AND PUT
50650	;
50700		A=1		; WORKING REGISTERS
50750		B=2		;
50800		C=3		;
50850		D=4		;
50900		LN=5		; LINE NUMBER FOR PUT
50950		PT=6		; LOCAL BYTE POINTER TO BUFFER
51000		COUNT=7		; LOCAL COUNT FOR BUFFER
51050		BUF=10		; ADDRESS OF BUFFER IN USE
51100		SCOUNT=11	; COUNT OF CHARS FOUND  BY GET
51150	;
51200	;	FLAGS FOR PUT
51250	;
51300		NEGFLG=1B35		; LINE NO NEGATIVE
51350		ERRFLG=1B34		; ERROR CLASS
51400		FORTF=1B33		; OUTPUT CLASS FLAGS
51450		LISTF=1B32		;
51500		ERRF=1B31		;
51550		VALID=FORTF!LISTF!ERRF	; VALID NUMBER SEEN
51600	;
51650		LOW
51700	;
51750	;  LAST BLANK SEEN
51800	;
51850	LAST:	BLOCK	1
51900	;
51950	;  LAST LINE NUMBER PUT TO FORTOUT
52000	;
52050	LINENO:	BLOCK	1
52100	;
52150		HIGH
52200	;
52250	;----------------------------------------------------------
52300	;
52350		ENTRY GET
52400	;
52450	;	CALL GET(LINENO,STRING,ENDFIL)
52500	;	INVOKES GET AS DESCRIBED IN THE SYSTEM MODIFICATION
52550	;	GUIDE
52600	;
52650	GET:
52700	IFN F40<Z>
52750		;
52800		;	SET UP POINTERS AND COUNT
52850		;
52900		MOVE	PT,BUFH1+1	; GET BUFFER POINTER AND
52950		MOVE	COUNT,BUFH1+2	; BYTES REMAINING COUNT
53000		HRRZI	A,@1(16)        ; OBTAIN ADDRESS OF STRING
53050		MOVEI	A,1(A)		; CONVERT TO ADDR OF FIRST CHAR
53100		HLL	A,[POINT 7,0]	; MAKE A BYTE POINTER
53150		SETZB	SCOUNT,LAST	; TALLIES OF STRING LENGTH
53200		;
53250		;	LOCATE FIRST BYTE
53300		;
53350	GET1:	SOSGE	COUNT		; IS THERE A NEXT BYTE IN BUFFER ?
53400		JSP	D,FILBUF	; NO - GET NEXT BUFFER
53450		ILDB	C,PT		; YES - GET IT
53500		JUMPE	C,GET1		; LOOP PAST NULLS
53550		LDB	B,[POINT 6,PT,5]; GET LOCATION OF BYTE
53600		CAIE	B,^D29		; IS THIS FIRST BYTE OF WORD
53650		JRST	GET1A		; NO - CHECK FORM FEED
53700		MOVE	B,0(PT)		; YES - GET COMPLETE WORD
53750		TRNE	B,1		; IS BIT 35 ON?
53800		JRST	GET2		; YES - FILE IS LINE-NUMBERED.
53850	GET1A:	CAIE	C,14		; IS IT A FORM FEED?
53900		JRST	GET3		; NO - INVENT LINE NUMBER
53950		SETOM	FORMF		; YES - SET FORM FEED FLAG
54000		JRST	GET1		; TRY NEXT BYTE
54050		;
54100		;
54150		;  ASSEMBLE LINE NUMBER AND STORE
54200		;
54250	GET2:	MOVEI	D,-60(C)	; SET UP VALUE OF FIRST DIGIT
54300		MOVEI	B,4		; LOOP ON NEXT 4 CHARS.
54350	GET2A:	ILDB	C,PT		; GET NEXT CHAR
54400		IMULI	D,^D10		; LEFT SHIFT 1 DECIMAL PLACE
54450		ADDI	D,-60(C)	; ADD IN NEW DIGIT
54500		SOJG	B,GET2A		; LOOP FOR NEXT DIGIT
54550		MOVEM	D,@0(16)        ; SET LINENO.
54600		MOVEI	COUNT,-4(COUNT)	; ADJUST COUNT TO PROPER VALUE
54650		;
54700		;  DEAL WITH FORM FEEDS AND TABS IN LINE NUMBERED FILES
54750		;
54800		SOSGE	COUNT		; ANY MORE CHARACTERS?
54850		JSP	D,FILBUF	; NO - FILL BUFFER
54900		ILDB	C,PT		; PICK UP NEXT CHAR
54950		CAIE	C,15		; IS IT A <CR>?
55000		JRST	GET4		; NO - ONWARD
55050		SOSGE	COUNT		; YES - ANY MORE CHARACTERS?
55100		JSP	D,FILBUF	; NO - FILL BUFFER
55150		MOVE	D,PT		; YES - COPY BYTE POINTER
55200		ILDB	C,D 		; GET NEXT CHARACTER
55250		CAIE	C,14		; IS IT <FORM FEED>?
55300		JRST	GET4		; NO - ONWARD
55350		SETOM	FORMF		; YES - SET FORM FEED FLAG
55400		IBP	PT		; IGNORE FORM FEED
55450		JRST	GET1		; TRY NEXT BYTE
55500		;
55550		;   INVENT OWN LINE NUMBER
55600		;
55650	GET3:	MOVEI	B,^D10		; SET INCREMENT OF 10 DECIMAL
55700		ADDM	B,@0(16)	; GIVE NEW VALUE TO USER
55750		MOVEI	B,6		; INITIALIZE LOOP OVER COL 1 - 6
55800		JRST	GET5A		; ENTER LOOP
55850		;
55900		;   DEAL WITH FIRST 6 COLUMNS
55950		;
56000	GET4:	MOVEI	B,6		; INITIALIZE LOOP OVER COL 1 - 6
56050	GET5:	SOSGE	COUNT		; ANY MORE CHARS?
56100		JSP	D,FILBUF	; NO - GO TO NEXT BUFFER
56150		ILDB	C,PT		; GET NEXT CHAR
56200	GET5A:	CAIN	C,15		; IS IT <CR> ?
56250		JRST	GET8		; YES - TERMINATE
56300		CAIN	C,11		; IS IT <TAB> ?
56350		JRST	GET6		; YES - SUBSTITUTE BLANKS
56400		IDPB	C,A		; NO - TUCK IT AWAY IN STRING
56450		MOVEI	SCOUNT,1(SCOUNT); UPDATE COUNT
56500		CAIE	C,40		; IS IT <SP>?
56550		MOVEM	SCOUNT,LAST	; NO - UPDATE LAST COUNT
56600		SOJG	B,GET5		; LOOP FOR NEXT CHAR
56650		JRST	GET7		; ONWARD
56700		;
56750		;   DEAL WITH TAB IN FIRST 6 PLACES
56800		;
56850	GET6:	MOVEI	D,40		; SET UP <SP>
56900	GET6A:	IDPB	D,A		; TUCK IT AWAY IN STRING
56950		MOVEI	SCOUNT,1(SCOUNT); INCREMENT COUNT
57000		SOJG	B,GET6A		; LOOP TO COL 7
57050		SOSGE	COUNT		; ANY MORE CHARS ?
57100		JSP	D,FILBUF	; NO - GET NEXT BUFFER
57150		ILDB	C,PT		; GET NEXT CHARACTER
57200		CAIL	C,60		; IS IT A DIGIT ?
57250		CAILE	C,71		;
57300		JRST	GET7A		; NO - GET ON WITH IT
57350		DPB	C,A		; YES - DEPOSIT CONTINUATION NUMBER
57400		MOVEM	SCOUNT,LAST	; UPDATE LAST NON-BLANK COUNT
57450		;
57500		;   MAIN LOOP TO MOVE CHARACTERS
57550		;
57600	GET7:	SOSGE	COUNT		; ANY MORE CHARS ?
57650		JSP	D,FILBUF	; NO - GET NEXT BUFFER
57700		ILDB	C,PT		; GET NEXT CHAR
57750	GET7A:	CAIN	C,15		; IS IT <CR> ?
57800		JRST	GET8		; YES - TERMINATE
57850		IDPB	C,A		; NO - TUCK IT AWAY IN STRING
57900		MOVEI	SCOUNT,1(SCOUNT); UPDATE COUNT
57950		CAIE	C,40		; WAS IT A <SP> ?
58000		MOVEM	SCOUNT,LAST	; NO - UPDATE LAST COUNT
58050		CAIGE	SCOUNT,^D72	; HAVE WE REACHED THE END ?
58100		JRST	GET7		; NO - LOOP
58150	GET7B:	SOSGE	COUNT		; ANY MORE CHARS?
58200		JSP	D,FILBUF	; NO - GET NEXT BUFFER
58250		ILDB	C,PT		; GET NEXT CHAR
58300		CAIE	C,15		; IS IT <CR> ?
58350		JRST	GET7B		; NO - LOOP
58400		;
58450		;   RETURN STRING LENGTH TO USER
58500		;
58550	GET8:	MOVE	A,LAST		; GET # OF NON BLANKS
58600		MOVEM	A,@1(16)	; AND RETURN IT
58650		;
58700		;   SKIP <LF> AND RESTORE BUFFER HEADER
58750		;
58800		SOSGE	COUNT		; ANY MORE CHARS?
58850		JSP	D,FILBUF	; NO - GET NEXT BUFFER
58900		IBP	PT		; IGNORE <LF>
58950		MOVEM	PT,BUFH1+1	; RESTORE POINTER
59000		MOVEM	COUNT,BUFH1+2	;   AND COUNT
59050	IFN F40<JRA	16,3(16)	; RETURN>
59100	IFN F10<POPJ	17,0		; RETURN>
59150		;
59200		;   FILL BUFFER INTERNAL SUBROUTINE
59250		;
59300	FILBUF:	IN	1,		; INPUT NEXT BUFFER
59350		JRST	FIL2		; SUCCESS - ONWARD
59400		GETSTS	1,C		; FAIL - GET STAUS
59450		TRNE	C,1B22		; WAS IT  END OF FILE?
59500		JRST	FIL1		;  YES - GO HANDLE IT
59550					; NO - OTHER ERROR
59600		OUTSTR	[ASCIZ/?FLXREI  Read error on input file/]
59650		EXIT
59700	FIL1:	SETOM	@2(16)		; ENDFIL = .TRUE.
59750	IFN F40<JRA	16,3(16)	; RETURN TO USER>
59800	IFN F10<POPJ	17,0		; RETURN>
59850	FIL2:	MOVE	PT,BUFH1+1	; CAPTURE LOCAL COPIES OF
59900		MOVE	COUNT,BUFH1+2	;   POINTER AND COUNT
59950		JRST	-2(D)		; RETURN FOR RETRY
60000	;
60050	;-----------------------------------------------------------
60100	;
60150		ENTRY PUT
60200	;
60250	;	CALL PUT(LINENO,STRING,IOCLASS)
60300	;	INVOKES PUT AS DESCRIBED IN THE SYSTEM MODIFICATION
60350	;	GUIDE.
60400	;
60450	PUT:
60500	IFN F40<Z>
60550		;
60600		;   SET FLAGS TO INDICATE  CLASS
60650		;
60700	PUT1:	SETZ	0,		; ZERO THE FLAGS
60750		MOVE	A,@2(16)	; GET IO CLASS
60800		MOVEI	BUF,0		; ZERO BUFFER ADDRESS
60850		CAIN	A,1		; IS IT FORT?
61000		TRO	0,FORTF		; YES - SET FLAG
61050		CAIN	A,2		; NO - IS IT LIST?
61200		TRO	0,LISTF		; YES - SET FLAG
61250		CAIN	A,3		; NO - IS IT ERR ?
61300		TRO	0,LISTF!ERRF		; YES - SET FLAG
61310		SKIPE	NOF4		; IF FORTRAN NOT DESIRED
61320		TRZ	0,FORTF		; LOWER FLAG
61330		SKIPE	NOLST		; IF LISTING NOT DESIRED
61340		TRZ	0,LISTF		; LOWER FLAG
61342		SKIPE	NOERR		; IF ERRORS NOT TO TTY
61344		TRZ	0,ERRF		; LOWER FLAG
61350		TRNN	0,VALID		; DID A FLAG GET SET?
61400	IFN F40<JRA	16,3(16)>
61450	IFN F10<POPJ	17,0>
61500		;
61550		;   SET UP LINE NUMBER INFO
61600		;
61650	PUT1A:	MOVE	A,@0(16)	; GET LINE NO
61700		JUMPG	A,PUT3		; IS IT POSITIVE ?
61750		JUMPL	A,PUT2		; IS IT NEGATIVE ?
61800		MOVE	LN,[ASCII/     /]	; IT'S ZERO - SET UP 5 BLANKS
61850		JRST	PUT5		; ONWARD
61900	PUT2:	TRO	0,NEGFLG	; IT'S NEGATIVE -- SET NEGFLAG .TRUE.
61950		MOVM	A,A		; TAKE ABSOLUTE VALUE
62000	PUT3:	TRNN	0,FORTF		; IS THIS FOR FORTOUT?
62050		JRST	PUT3B		; NO - ONWARD
62100		CAMLE	A,LINENO	; YES - WILL NEW NUMBER BE LARGER THAN LAST?
62150		JRST	PUT3A		; YES - ONWARD
62200		MOVEI	A,1		; NO - SET UP AND
62250		ADD	A,LINENO	; INCREMENT
62300	PUT3A:	MOVEM	A,LINENO	; SAVE FOR FUTURE REFERENCE
62350		;
62400		;   CONVERT LINENO TO CHARACTERS
62450		;
62500	PUT3B:	SETZI	C,		; INITIALIZE ACCUMALATOR
62550		MOVEI	D,5		; CONSTRUCT 5 CHARACTERS
62600	PUT4:	IDIVI	A,^D10		; GET FIRST DIGIT
62650		MOVEI	B,60(B)		; CONVERT TO ASCII
62700		LSHC	B,-7		; SHIFT INTO C
62750		SOJG	D,PUT4		; LOOP BACK
62800		MOVE	LN,C		; SAVE IT IN LN
62850		;
62900		;   SET UP BUF AND  LOCAL INFO
62950		;
63000	PUT5::	TRNE	0,FORTF		; WAS IT  FORT ?
63050		MOVEI	BUF,BUFH3	; YES - SET ADDR
63100		TRNE	0,LISTF		; WAS IT LIST OR ERROR ?
63150		MOVEI	BUF,BUFH2	; YES - SET ADDR
63160		TRNN	0,FORTF!LISTF	; OUTPUT TO FORTOUT OR LISTOUT?
63170		JRST	PUT6		; NO - ONWARD
63200		MOVE 	PT,1(BUF)	; MAKE LOCAL POINTER
63250		MOVE	COUNT,2(BUF)	; AND COUNT
63300		;
63350		;   MOVE TO FIRST WORD IF FORT
63400		;
63450	PUT6:	TRNN	0,FORTF		; WAS IT FORT?
63500		JRST	PUT10		; NO - ONWARD
63550	PUT7:	SOSGE	COUNT		; YES - ANY MORE POSITIONS?
63600	PUT7A:	JSP	D,NXTBUF	; NO - GET NEW BUFFER
63650		IBP	PT		; YES - BUMP POINTER
63700		LDB	A,[POINT 6,PT,5]	; GET  BYTE POSITION
63750		CAIE	A,^D29		; IS IT FIRST BYTE?
63800		JRST	PUT7		; NO - LOOP
63850		;
63900		;   WILL THE ENTIRE LINE FIT?
63950		;
64000	PUT7B:	MOVE	A,@1(16)	; GET LINE LENGTH
64050		MOVEI	A,^D8(A)	; ADJUST FOR LINE# <TAB><CR><LF>
64100		CAMG	A,COUNT		; ENOUGH ROOM?
64150		JRST	PUT8		; YES - ONWARD
64200		MOVEI	D,PUT7A+1	; NO - GET NEXT BUFFEP
64250		JRST	NXTBUF
64300		;
64350		;   MOVE IN LINE NUMBER IF FORT
64400		;
64450	PUT8:	TRO	LN,1		; SET LINE NUMBER BIT
64500		MOVEM	LN,(PT)		; PLACE IN BUFFER
64550		TLZ	PT,770000	; ADVANCE BYTE POINTER
64600		SUBI	COUNT,5		; DECREASE COUNT
64650		;
64700		;   MOVE IN <TAB> FOLLLOWING LINE NUMBER
64750		;
64800	PUT9:	MOVEI	A,11		; SET UP <TAB>
64850		PUSHJ	17,OUTCH	; PUT IT OUT
64900		JRST	PUT15		; GO MOVE STRING
64950		;
65000		;   GENERATE <FF> IN LISTING IF NECESSARY
65050		;
65120	PUT10:	AOSN	FORMF		; GENERATE A <FF> ?
65130		TRNN	LISTF		; YES - ARE WE LISTING?
65150		JRST	PUT11		; NO - ONWARD
65200		MOVEI	A,14		; SET UP FORM FEED
65250		PUSHJ	17,OUTCH1	; PUT IT OUT TO LIST ONLY
65300		;
65350		;   OUTPUT HYPHENS IF NECESSARY
65400		;
65450	PUT11:	TRNN	NEGFLG		; WAS LINE NO NEGATIVE ?
65500		JRST	PUT13		; NO - ONWARD
65550		MOVEI	A,55		; YES -  SET UP "-"
65600		MOVEI	B,5		; WANT 5 OF THEM
65650	PUT12:	PUSHJ	17,OUTCH	; PUT IT OUT
65700		SOJG	B,PUT12		; LOOP UNTIL DONE
65750		MOVEI	A,15		; SET UP <CR>
65800		PUSHJ	17,OUTCH	; PUT IT OUT
65850		;
65900		;   OUTPUT FIRST 6 COLUMNS OF LISTING
65950		;
66000	PUT13:	MOVEI	B,5		; PUT OUT 5 COLUMNS
66050		MOVE	C,[POINT 7,LN]	; FROM CHARS IN LN
66100	PUT14:	ILDB	A,C		; GET NEXT CHAR
66150		PUSHJ	17,OUTCH	; PUT IT OUT
66200		SOJG	B,PUT14		; LOOP UNTIL DONE
66250		MOVEI	A,40		; SET UP <SP>
66300		PUSHJ	17,OUTCH	; PUT IT OUT
66350		;
66400		;   COME HERE TO OUTPUT STRING ITSELF
66450		;
66500	PUT15:	HRRZI	C,@1(16)	; GET ADDR OF STRING
66550		MOVE	B,(C)		; GET LENGTH
66600		JUMPLE	B,PUT17		; TERMINATE IF NOT POSITIVE
66650		MOVEI	C,1(C)		; SET UP BYTE
66700		HLL	C,[POINT 7,0]	; POINTER TO STRING
66750		ILDB	A,C		; YES - SET UP BYTE
66800		PUSHJ	17,OUTCH
66850		SOJG	B,.-2		; LOOP TIL DONE
66900	PUT17:	MOVEI	A,15		; SET UP <CR>
66950		PUSHJ	17,OUTCH	; PUT IT OUT
67000		MOVEI	A,12		; SET UP <LF>
67050		PUSHJ	17,OUTCH	; PUT IT OUT
67100		;
67150		;   UPDATE BUFFER HEADER
67200		;
67250		MOVEM	PT,1(BUF)	; SET UP PT
67300		MOVEM	COUNT,2(BUF)	; SET COUNT
67350		;
67400		;  RETURN
67450		;
67500	IFN F40<JRA	16,3(16)	>
67550	IFN F10<POPJ	17,0		; RETURN>
67600	;
67650	;--------------------------------------------------------------
67700	;
67750	;	INTERNAL OUTCH (USED BY PUT)
67800	;
67850	;	MOVEI	A,X
67900	;	PUSHJ	17,OUTCH
67950	;
68000	;	WILL OUTPUT THE CHARACTER X TO THE BUFFER AND TO THE
68050	;	TTY IN CASE OF ERR CLASS
68100	;
68250	OUTCH:	TRNE	0,ERRF		; IS THIS CLASS ERROR ?
68300		OUTCHR	A		; YES - PUT OUT CHAR
68320		TRNN	0,LISTF!FORTF	; ANY OUTPUT OTHER TNAN ERRORS?
68340		POPJ	17,0		; NO - RETURN
68350	OUTCH1:	SOSGE	COUNT		; ANY MORE ROOM?
68400		JSP	D,NXTBUF	; NO - GET NEXT BUFFER
68450		IDPB	A,PT		; YES - PUT BYTE IN BUFFER
68500		POPJ	17,0
68550	;
68600	;------------------------------------------------------------
68650	;
68700	;	INTERNAL NXTBUF
68750	;
68800	;	JSP	D,NXTBUF
68850	;
68900	;	WILL OUTPUT THE CURRENT BUFFER AND SET UP A NEW ONE
68950	;	AND RETURN TO THE PREVIOUS INSTRUCTION !!!!!!!
69000	;
69050	NXTBUF:	MOVEM	PT,1(BUF)	; SAVE CURRENT PT
69100		MOVEM	COUNT,2(BUF)	; AND COUNT
69150		TRNN	FORTF		; IS IT FORT ?
69200		JRST	NXT1		; NO - ONWARD
69250		OUT	3,		; YES - OUTPUT ON CHAN 3
69300		JRST	NXT2		; SUCCESS - ONWARD
69350		OUTSTR	[ASCIZ /?FLXOEF  Output failure to Fortran source file/]
69400		EXIT
69450	NXT1:	OUT	2,		; OUTPUT ON CHAN 2
69500		JRST	NXT2		; SUCCESS - ONWARD
69550		OUTSTR	[ASCIZ /?FLXOEL  Output failure to Flecs listing file/]
69600		EXIT
69650	NXT2:	MOVE	PT,1(BUF)	; RESET PT AND
69700		MOVE	COUNT,2(BUF) 	;   COUNT
69750		JRST	-2(D)		; REVERSE SKIP RETURN   (UGH!)
69800	;
69850	;----------------------------------------------------------
69900	;
69950		ENTRY CLOSEF
70000	;	CALL CLOSEF(MINCNT,MAJCNT)
70050	;	WILL INVOKE CLOSEF AS DESCRIBED IN THE FLECS SYSTEM
70100	;	MODIFICATION GUIDE.
70150	;
70200	;
70250	CLOSEF:
70300	IFN F40<Z>
70350		CLOSE	1,0
70400		RELEASE	1,
70450		CLOSE	2,0
70500		RELEASE	2,
70550		CLOSE	3,0
70600		RELEASE	3,
70650		MOVE	B,@(16)		; GET MINOR ERROR CNT
70700		JUMPE	B,CLOSE1	; NONE  CHECK MAJOR
70750		OUTSTR	[ASCIZ \%FLXMNE  \]		; TELL USER
70850		PUSHJ	17,DECPRT	; HOW MANY
70900		OUTSTR	[ASCIZ \ minor error(s) detected
70925	\] ; OF WHAT
70950	CLOSE1:	MOVE	B,@1(16)	; GET MAJOR ERROR CNT
71000		JUMPE	B,CLOSER	; NONE  RETURN
71010		SETOM	MAJERF		; INDICATE MAJOR ERRORS WERE SEEN
71050		OUTSTR	[ASCIZ \?FLXMJE  \]		; TELL HIM
71150		PUSHJ	17,DECPRT	; HOW MANY
71200		OUTSTR	[ASCIZ \ major error(s) detected
71300	\] ;AND WHAT
71500	CLOSER:				; RETURN
71550	IFN F40<JRA	16,2(16)>
71600	IFN F10<POPJ	17,0		; RETURN>
71650	;
71700	;--------------------------------------------------------------
71750	;
71800	;	SUBROUTINE INCH
71850	;	INPUT ONE CHARACHTER FROM TMPCOR,TMPFILE,OR TTY
71900	;	DESTROYS B, FLUSHES CARRIAGE RETURNS, TABS, AND SPACES,
71950	;	AND CHANGES ALL BREAK CHRS TO LINEFEEDS
72000	;
72050	INCH:	SKIPN	A,TMPFLG	; IS THIS CCL?
72100		JRST   [INCHWL	A	; NO - GET FROM TTY
72150			JRST	INCH1]	;      AND SKIP THIS
72200		TLNN	A,-1		; YES - HAVE WE REACH THE END YET?
72250		JRST	INCH1		; YES - LF IN A, SO JUMP
72300		ILDB	A,TMPFLG	; NO - GET A CHR
72350		JUMPN	A,INCH1		; DID WE REACH THE END?
72400		MOVEI	A,12		; YES - SET UP LF AS BREAK
72450		MOVEM	A,TMPFLG	; STORE A LF
72500	INCH1:	CAIN	A,11		; A TAB?
72550		JRST	INCH		; YES - FLUSH
72600		CAIE	A," "		; A SPACE,
72650		CAIN	A,15		; OR A CR?
72700		JRST	INCH		; YES - EAT IT
72750		MOVSI	B,-BRKLEN	; SET UP IOWD
72800		CAIN	A,BRKTAB(B)	; IS IT A BREAK?
72850		SKIPA	A,[12]		; YES - STORE A LF
72900		AOBJN	B,.-2		; LOOP TO CHECK AGAINST ALL
72950		POPJ	17,0
73000	;
73050	BRKTAB:	EXP	7,13,14,32,33,175,176	;TABLE OF BREAK CHRS
73100	BRKLEN==.-BRKTAB			;TABLE LENGTH
73150	;
73200	;--------------------------------------------------------------
73250	;
73260	;	 MAIN PROGRAM
73270	;	
73300	;	ACTUAL STARTING ADDRESS OF FLECS IS BELOW AT START
73350	;	THIS IS TO DETERMINE CCL ENTRY
73400	;
73450		LOW
73500	TMPFLG:	BLOCK	1		; ZERO IF NOT CCL OTHERWISE BYTE PNTR
73550	MYPPN:	BLOCK	1		; OUR PPN
73600	IFNDEF BUFLEN,<BUFLEN==^D127>	; LENGTH OF BUFFER FOR CCL
73650	TBUF:	BLOCK	BUFLEN		; CCL BUFFER
73700		Z			; MAKE SURE ENDS WITH NULL
73710	MAJERF:	Z			; NON-ZERO IF MAJOR ERRORS WERE SEEN
73750	IFE FOROTS,<PDLST:	BLOCK	PDLEN>
73800		HIGH
73850	IFN F40,<OPDEF GO[JRST FLECS##+1]>
73900	IFN F10,<OPDEF GO[JRST FLECS##]>
73950	;
73960		; ENTER AND DETERMINE CCL
73970		;
74000	START:	TDZA			; IF NOT CCL, SKIP
74050		MOVE	[POINT	7,TBUF]	; CCL  SET UP BYTE POINTER
74100		MOVEM	TMPFLG		; SETUP TMPFLG
74110		;
74120		; INITIALIZE SYSTEM
74130		;
74150	IFE FOROTS,<
74200		RESET
74250		SETZI
74300		RUNTIME
74350		MOVEM	STTIME
74400		MOVE	17,[IOWD PDLEN,PDLST]>
74450	IFN FOROTS,<
74500		JSP	16,RESET.##	;INIT FOROTS
74550		Z>
74560		;
74570		; OBTAIN PPN
74580		;
74600		GETPPN			; GET OUR PPN
74650		JFCL			; JUST IN CASE
74700		MOVEM	MYPPN		; STORE IT
74725		SKIPN	0,TMPFLG
74750		JRST	NOTCCL		; START IF NOT CCL
74760		;
74770		; INITIALIZE CCL MODE
74780		;
74790	CCL:	SETZM	MAJERF		; CLEAR MAJOR ERRORS FLAG
74800		MOVE	[2,,1]		; TMPCOR READ AND DELETE
74850		MOVSI	1,'FLE'		; OUR NAME
74900		MOVE	2,[IOWD BUFLEN,TBUF]; AND WHERE IT GOES
74950		TMPCOR			; TRY TO GET IT
75000		CAIA			; NOT THERE  SKIP
75050		GO			; GOT IT, SO GO
75100		INIT	17		; INIT FOR TMP FILE READ
75150		'DSK   '		; FROM DSK
75200		Z			; NO BUFFERS (DUMP MODE)
75250		JRST	NOTCCL		; CAN'T, SO ASSUME NOT CCL
75300		PJOB			; GET OUR JOB #
75350		MOVEI	3,3		; # OF CHRS
75400		IDIVI	12		; MAKE IT SIXBIT IN LEFT OF 2
75450		ADDI	1,20
75500		LSHC	1,-6
75550		SOJG	3,.-3		; LOOP FOR ALL
75600		HRRI	2,'FLE'		; OUR NAME
75650		MOVSI	3,'TMP'		; EXTENSION
75700		SETZB	4,5		; CLEAR THIS FOR DATE75
75750		LOOKUP	2		; TRY TO GET THE FILE
75800		JRST	NOTCCL		; CAN'T, SO ASSUME NOT CCL
75850		MOVE	[IOWD BUFLEN,TBUF]; DUMP COMMAND LIST TO AC'S
75900		SETZI	1,		; END COMMAND LIST
75950		IN			; GET FILE
76000		CAIA			; GOT IT
76050		SETZM	TMPFLG		; CAN'T READ FILE
76100		RENAME	1		; DELETE IT
76150		JFCL			; DON'T CARE IF CAN'T
76200		CLOSE
76250		GO			; AND GO
76300		;
76310		; INITIATE NON CCL MODE
76320		;
76350	NOTCCL:	SETZM	TMPFLG		; CLEAR FLG
76400		GO			; AND GO
76450	;
76460	;----------------------------------------------------------
76470	;
76480	; SUBROUTINE EXIT IF NOT USING FOROTS
76490	;
76500	IFE FOROTS,<
76600	
76650		ENTRY	EXIT
76700	
76750	EXIT: IFN F40,<Z>
76800		OUTSTR	[ASCIZ \
76850	Runtime:  \]
76900		SETZI	A,
76950		RUNTIME	A,
77000		SUB	A,STTIME
77050		IDIVI	A,^D1000
77100		CAILE	B,^D500
77150		MOVEI	A,1(A)
77200		IDIVI	A,^D60
77250		JUMPN	A,[EXCH A,B
77300			PUSH	17,B
77350			PUSHJ	17,DECPRT
77400			OUTSTR	[ASCIZ \ minute\]
77450			POP	17,B
77500			CAIN	B,1
77550			OUTCHR	["s"]
77600			OUTSTR	[ASCIZ \, \]
77650			MOVE	B,A
77700			JRST	.+1]
77750		PUSHJ	17,DECPRT
77800		OUTSTR	[ASCIZ \ seconds
77850	\]
77900		EXIT>
77950	
78000		END	START
