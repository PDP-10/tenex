!COPYRIGHT 1972,1973,1974 DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS. 01754
!FILENAME:	H3DRIV.BLI
!DATE:		10 SEPTEMBER 1974	MGM/FLD/KR/GJB

%3.43,4.01,4.02,4.11%	GLOBAL BIND H3DRV=18;	!MODULE VERSION NUMBER






%3.19%	ROUTINE CONCAT(A,B)=
%3.19%	BEGIN	REGISTER IN, OUT;	LABEL L1, L2;

%3.19%	IN_ (A)<36,7>;  OUT_ (MMC)<36,7>;

%3.19%	L1: DECR I FROM 9 TO 0 DO
%3.19%		IF SCANI(IN) GTR " " THEN COPYNI(IN, OUT);

%3.19%	END;
%3.1%	GLOBAL ROUTINE MACHINECODE(IOX,OP,TOG)=
  BEGIN  LOCAL J,X; MACHOP IDPB=#136; 

  !    THIS ROUTINE GENERATES THE MNEMONIC FOR A MACHINE
  !    OP-CODE IN THE GLOBAL VARIABLE 'MMC' AND ITS SUCCESSOR.



%2.25%	STRUCTURE UUONAME[I,J]=(.UUONAME+.I*2+.J)<0,36>;
%2.25%	
%2.25%	!NOTE:	EACH UUO NAME IN THIS PLIT MUST BE >= 6 CHARS AND <= 10 CHARS SO THAT IT WILL OCCUPY
%2.25%	!EXACTLY TWO WORDS IN THE PLIT


%2.25%	BIND UUONAME UUOOP=PLIT(
%2.25%	'CALL  ',
%2.25%	'INIT  ',
%2.25%	'UUO   ',
%2.25%	'UUO   ',
%2.25%	'UUO   ',
%2.25%	'UUO   ',
%2.25%	'UUO   ',
%2.25%	'CALLI ',
%2.25%	'OPEN  ',
%2.25%	'TTCALL',
%2.25%	'UUO   ',
%2.25%	'UUO   ',
%2.25%	'UUO   ',
%2.25%	'RENAME',
%2.25%	'IN    ',
%2.25%	'OUT   ',
%2.25%	'SETSTS',
%2.25%	'STATO ',
%2.25%	'GETSTS',
%2.25%	'STATZ ',
%2.25%	'INBUF ',
%2.25%	'OUTBUF',
%2.25%	'INPUT ',
%2.25%	'OUTPUT',
%2.25%	'CLOSE ',
%2.25%	'RELEAS',
%2.25%	'MTAPE ',
%2.25%	'UGETF ',
%2.25%	'USETI ',
%2.25%	'USETO ',
%2.25%	'LOOKUP',
%2.25%	'ENTER ');
  MMC_(MMC+1)_0;
  CASE .OP<6,3> OF
    SET

        IF .OP LSS #040 THEN		! CASE 0
	    (MMC_IF .OP EQL DEBUGUUO THEN 'DEBUG' ELSE 'UUO')
%2.25%	ELSE
%2.25%	    (MMC_.UUOOP[(.OP-#040),0];
%2.25%	    (MMC+1)<0,36>_.UUOOP[(.OP-#040),1]);

    IF .OP<5,1>			! CASE 1
      THEN CONCAT(.POC[1,.OP<2,3>], .OCE[1,.OP<0,2>])
      ELSE MMC_.POC[0,.OP<0,3>];

    IF .OP<5,1>			! CASE 2
      THEN MMC_.POC[3,.OP<0,5>]
      ELSE CONCAT(.POC[2,.OP<2,3>], .OCE[.OP<4,1>,.OP<0,2>]);

    CONCAT(.POC[4,.OP<3,3>], .OCE[5,.OP<0,3>]);	! CASE 3

    CONCAT(.POC[5,.OP<2,4>], .OCE[1,.OP<0,2>]);	! CASE 4

    BEGIN			! CASE 5
	MMC_ CASE (.OP<5,1>^1 OR .OP<2,1>) OF
	   SET 'HLL'; 'HRL'; 'HRR'; 'HLR' TES;
	CONCAT( .MMC, .OCE[2,.OP<3,2>] );
	CONCAT( .MMC, .OCE[0,.OP<0,2>]);
    END;

    BEGIN			! CASE 6
	MMC_ CASE (.OP<3,1>^1 OR .OP<0,1>) OF
	   SET 'TR'; 'TL'; 'TD'; 'TS' TES;
	CONCAT(.MMC, .OCE[3,.OP<4,2>] );
	CONCAT(.MMC, .OCE[4,.OP<1,2>] );
    END;

%3.19%	BEGIN
%3.19%	   MMC_ .(PLIT ('BLKI',   'DATAI',  'BLKO',   'DATAO',	!CASE 7
%3.19%		     'CONO',   'CONI',   'CONSZ',  'CONSO'))[.IOX];
%3.19%	   MMC[1]_ 0;
%3.19%	END

    TES;


%3.19%	OP_ MMC<36,7>;

%3.19%	IF .TOG
%3.19%	   THEN	(ACCUM_ ACCUM[1]_ -2;
%3.19%		 PACCUM_ ACCUM<36,7>;
%3.19%		 UNTIL COPYII(OP, PACCUM) EQL 0 DO 0;
%3.19%		 REPLACEN(PACCUM, #177))	!PUT #177 OVER NULL
%3.19%	   ELSE	(OUTPSTRING(.OP);
%3.19%		 OCHAR(#11))

%3.19%	END;	! OF MACHINECODE
ROUTINE LTUSED =

  !COUNT THE NUMBER OF ENTRIES USED IN THE LITERAL TABLE
  !THE VALUE OF THE ROUTINE IS THE NUMBER OF ENTRIES USED.

    BEGIN

%2.9%	REGISTER R,		!POINTER TO LT ENTRIES
%2.9%		COUNT;		!COUNT OF ENTRIES USED IN LT

	COUNT_0;
%2.27%	INCR J FROM 0 TO LTNUM-1 DO
%2.9%	    COUNT_.LTBASE[.J]<LEFTHALF>+.COUNT;
%2.9%	  RETURN .COUNT;

    END;



ROUTINE STACKFREE =

  !DETERMINE HOW MUCH STACK SPACE WAS NOT USED AND RETURN
  !THE NUMBER OF UNUSED STACK LOCATIONS AS THE VALUE OF THE ROUTINE

    DECR I FROM DEPTH-1 TO 0 DO
	IF .STACK[.I] NEQ 0 THEN RETURN DEPTH -.I -1;



%3.9-1%	GLOBAL ROUTINE OUTOFFSET(A)=		! HANDLE OFFSETS PROPERLY
%3.23%	   6+(IF .A<15,3> NEQ 7
		THEN OCHAR("+")+OUTMOC(.A)	! POSITIVE - PUT "+"
		ELSE OUTCONOC(.A));		! NEGATIVE - CONOC PUTS "-"
ROUTINE WRITEFINAL=
%2.9%    BEGIN
    ! THIS ROUTINE WRITES THE FINAL GOOD-BYE TO THE USER

%3.26%	IF .CCLCTL NEQ 0 THEN CCLCTL<2,1>_ 1;	!'SUPPRESS CRAP'

    ERRBIT_0;    ENEWLINE(); NEWLINE(); NEWLINE();
    EMESSAGE("Modul","e len","gth: ",3);
%3.20%    OUTNUM(.MODLENGTH
%2.30%	+ (IF .LSTART THEN !ADD LENGTH OF PROLOGS AND EPILOGS
%2.30%		(((9+.NOSVR)*(.NOSVR)+10)/2)),10,0,1);
%3.20%    IF .LUNDEFLG THEN (EOCHAR("+");OUTNUM(.NODISC,10,0,1));
%2.9%    EOCHAR("+"); OUTNUM(.PTREFNO + 1 + 	!PTREFNO = # PTRS - 1
%2.9%	!ADD THE NUMBER OF LITERALS
%2.9%	BEGIN
%2.9%	  REGISTER R;
%2.9%	  R_0;
%2.27%		INCR I FROM 0 TO LTNUM-1 DO
%2.9%	  R_.LTTBASE[.I]<LEFTHALF> + .R;
%2.9%	  .R
%2.9%	END
%3.20% + .PLNEXT, 10,0,1);ENEWLINE();

   IF .STATFLG THEN		!OUTPUT ADDITIONAL STATISTICS ON /S
	BEGIN

	EMESSAGE("Liter","al ta","ble u","sed: "," ",5);
%3.20%	OUTNUM (LTUSED(),10,0,1);
	EOUTSTR (" of ",4);
%3.20%	OUTNUM (
%2.9%		BEGIN
%2.9%		  REGISTER R;
%2.9%		  R_0;
%2.27%		  INCR I FROM 0 TO LTNUM - 1 DO
%2.9%		    IF .LTBASE[.I] EQL 0 THEN EXITLOOP
%2.9%		      ELSE R_.R+1;
%2.9%		  .R*LTSIZE
%2.9%		END
%3.20%		,10,0,1);
	EMESSAGE (" Entr","ies",2);
	ENEWLINE();

	!AMOUNT OF STACK USED

	EMESSAGE ("Stack"," used",": ",3);
%3.20%	OUTNUM (DEPTH<0,0>-(STACKFREE()),10,0,1);
	EOUTSTR (" of ",4);
%3.20%	OUTNUM (DEPTH<0,0>,10,0,1);
	EMESSAGE (" Word","s",2);
	ENEWLINE();

	!MAX AMOUNT OF CORE USED

	EMESSAGE ("Max c","ore u","sed: ",3);
%3.20%	OUTNUM ((.?.JBREL<RIGHTHALF>+1)^(-10),10,0,1);
	EOUTSTR (" + ",3);
%3.20%	OUTNUM (((.?.JBHRL<RIGHTHALF> AND #377777) + 1)^(-10),10,0,1);
	EOUTSTR (" K",2);
	ENEWLINE()
      END;
    ENEWLINE();


%3.18%	IF .WARNINGFOUND NEQ 0 THEN
%3.18%		(EMESSAGE("%BLSW","RN ",2); OUTNUM(.WARNINGFOUND, 10, 0, 1);
%3.18%		 EMESSAGE(" Warn","ing",2);
%3.18%		 IF .WARNINGFOUND GTR 1 THEN EOCHAR("s");
%3.18%		 ENEWLINE());
%3.18%
%3.18%	IF .ERRORFOUND NEQ 0 THEN
%3.18%		(EMESSAGE("??BLSE","RR ",2);  OUTNUM(.ERRORFOUND,10,0,1);
%3.18%		 EMESSAGE(" erro","r",2);
%3.18%		 IF .ERRORFOUND GTR 1 THEN EOCHAR("s");
%3.18%		 EMESSAGE(" dete","cted",2))
%3.18%	   ELSE (EMESSAGE("[BLSN","ED No"," erro","rs de","tecte","d]",6));
%3.18%
%3.18%	ENEWLINE();  ENEWLINE();


   CCLCTL<2,1>_0; % DONE SUPPRESSING %
    IF NOT.LSTFLG THEN FORCE(2);
    IF NOT.BINFLG THEN ( FORCE(1));
    END;
%2.25%	ROUTINE DELFLINK(IND)=
%2.25%		!AT THIS POINT THE STRUCTURE OF THE TREE IN WHICH IND RESIDES
%2.25%		!HAS BEEN ALTERED A GREAT DEAL FROM THE STANDARD:
%2.25%		!CELLS ASSOCIATED WITH LABELS WILL HAVE THEIR HEADER BITS
%2.25%		!ON EVEN THO THEY AREN'T HEADERS.
%2.25%		!BACKWARD LINKS ARE NO LONGER VALID EXCEPT FOR LINE # REFERENCE
%2.25%		!CELLS WHICH MUST HAVE VALID BACKWARD LINKS.
%2.25%		!.IND IS THE INDEX OF THE CELL WE WISH TO DELETE FROM THIS
%2.25%		!NON-STANDARD TREE.
%2.25%	
%2.25%		BEGIN
%2.25%	
%2.25%		  !IF THE CELL FOLLOWING .IND IS A LINE # CELL, WE MUST FIX
%2.25%		  !UP ITS PREVF.
%2.25%	
%2.25%		  IF .CT[.CT[.IND,0]<NEXTF>,1]<OPLEFTF> EQL 0
%2.25%			THEN CT[.CT[.IND,0]<NEXTF>,0]<PREVF> _ .CT[.IND,0]<PREVF>;
%2.25%
%2.25%
%2.25%		  !LINK THE CELL BEFORE .IND TO POINT TO THE GUY .IND POINTS TO
%2.25%		  !IF THE GUY BEFORE .IND IS A HEADER, UPDATE THE NEXTF OF WORD 1
%2.25%		  !OTHERWISE WORD 0.  IT TURNS OUT THAT BY THE TIME WE REACH
%2.25%		  !.IND AT THIS POINT, HEADER BITS FOR CELLS BEFORE .IND IN THE
%2.25%		  !TREE VALIDLY INDICATE A TRUE LIST HEADER CONDITION WHEREAS
%2.25%		  !HEADER BITS FOR CELLS WHICH FOLLOW .IND MAY OR MAY NOT INDICATE
%2.25%		  !TRUE HEADERS
%2.25%	
%2.25%			  CT[.CT[.IND,0]<PREVF>,.CT[.CT[.IND,0]<PREVF>,0]<HDRF>]<NEXTF>_.CT[.IND,0]<NEXTF>;
%2.25%		  DELCELL(.IND);
%2.25%	
%2.25%		END;	!OF ROUTINE DELFLINK
%3.1%	GLOBAL ROUTINE WRITECODE(H)=
%2.25%  BEGIN LOCAL OFSET,N,M,A,I,R,T,P; BIND LUNDEWORD=(.FCNSTATE NEQ 0) AND .LUNDEFLG; 
%2.25%	MACRO	LABF(I)=CT[I,0]<PREVF>$;	!LABEL NUM OF LABEL CELL
%2.25%		!IF NO LABEL # ASSIGNED, BUMP NEXTLAB AND
%2.25%		!ASSIGN ITS VALUE TO THE LABEL #.
%2.25%		!IN ANY CASE, RETURN THE LABEL NUMBER.
%2.25%	MACRO	LABNUM(I)=IF .LABF(I) EQL 0
				THEN (LABF(I)_(NEXTLAB_.NEXTLAB+1))
				ELSE .LABF(I)$;
%2.25%	LOCAL LNSEEN;	!0 => NO BLISS-10 LINE REFS
			!OTHERWISE LINE #
%2.25%	EXTERNAL OUTDEC, EOUTPSTRING, OUTPSTRING, RLTTRANS, R50TOASCIZ;


%3.38%	GLOBAL ROUTINE OUTCTREF(IND) =
%3.19%	  IF .CT[.IND]<30,6> EQL #76
%3.19%	    THEN OUTSTN(.CT[.IND,2]) ELSE (OUTSTR("L.",2) + OUTMOC(LABNUM(.IND)));


%2.25%	!ZEROLABF FOR EACH CELL SO WE CAN USE IT TO HOLD THE
%2.25%	!CONVERTED  LABEL NO.  IN ORDER TO MAKE ALL LABEL NAMES
%2.25%	!WITHIN A MODULE UNIQUE, WE'LL ASSIGN THEM STARTING WITH
%2.25%	!L.1 IN CONSEQUTIVE ORDER.  THE LABF WILL CONTAIN THE LABEL NO.
%2.25%	!CORRESPONDING TO THE PARTICULAR LABEL CELL.

%2.25%	N_.CT[.H,1]<NEXTF>;	!GET START OF TREE
%4.01%	PSTKPTR_0;		!INIT THE PEEP STACK POINTER
%4.01%	PEEPOK_-1;		!PEEPING AT START
%4.01%	PSTOP_PEEPHDR_.H;
%4.01%	PX_.N;

%4.11%	IF NOT (.NPTFLG) THEN
%4.11% BEGIN

%4.01%	UNTIL .PX EQL .PEEPHDR
%4.01%	  DO
%4.01%	  BEGIN
%4.01%	    PX_NXTINSTR(.PX);
%4.01%	    PEEPER();
%4.01%	  END;
%4.01%	PX_.N;
%4.01%	UNTIL .PX EQL .PEEPHDR
%4.01%		DO
%4.01%		BEGIN
%4.01%		  IF (.POPCODE(.PX) EQL PEEPHOLE)
%4.01%		  THEN IF .PLABEL(.PX)
%4.01%			THEN
%4.01%			BEGIN
			%(******SPECIAL KLUDGE FOR #777 OPCODE , SEE
				NEXT PAGE IN MACRO LISTER*****)%
%4.01%			  M _ .CT[.PX,0]<NEXTF>;
%4.01%			  IF .PLABEL(.M)
%4.01%				 OR .POPCODE(.M) EQL #777
%4.01%				 OR .POPCODE(.M) EQL 0
%4.01%			  THEN POPCODE(.PX)_CAI
%4.01%			  ELSE
%4.01%			  BEGIN
%4.01%				PRELOC(.PX)_.PRELOC(.M);
%4.01%				PCODEWD(.PX)_.PCODEWD(.M);
%4.01%				CT[.PX,0]<NEXTF>_.CT[.M,0]<NEXTF>;
%4.01%				CT[.CT[.M,0]<NEXTF>,0]<PREVF>_.PX;
%4.01%				DELCELL(.M);
%4.01%				PX_.CT[.PX,0]<PREVF>
%4.01%			  END
%4.01%			END
%4.01%			ELSE BEGIN
%4.01%				M_.CT[.PX,0]<PREVF>;
%4.01%				CT[.CT[.PX,0]<NEXTF>,0]<PREVF>_.CT[.PX,0]<PREVF>;
%4.01%				CT[.CT[.PX,0]<PREVF>,0]<NEXTF>_.CT[.PX,0]<NEXTF>;
%4.01%				DELCELL(.PX);
%4.01%				PX_.M
%4.01%			     END;
%4.01%		PX_.CT[.PX,0]<NEXTF>
%4.01%		END;

%4.11% END;		!OF OPTIMIZATION TEST BEGIN BLOCK


%2.25%	UNTIL .N EQL .H
%2.25%	  DO
%2.25%	    BEGIN
%2.25%	      IF .CT[.N,1]<OPLEFTF> NEQ 0 THEN !WE CAN ZERO PREVF
%2.25%	      LABF(.N)_0;	!TO INDICATE NO NUM ASSIGNED YET
%2.25%	    N_.CT[.N,0]<NEXTF>;
%2.25%	    END;

    N_.CT[.H,1]<NEXTF>;
    IF .FCNSTATE NEQ 0 THEN NODISC_.NODISC+1;
%3.19% OFSET_0; LNSEEN_0;
    IF NOT .MLFLG THEN
      UNTIL .N EQL .H DO
        IF .CT[.N,1]<FUNCF> EQL 0 THEN
          BEGIN
            M_.CT[.N,0]<NEXTF>;
%2.25%%3.19%       IF NOT (.OFSET EQL 0 AND LUNDEWORD)
%2.25%		!BECAUSE WE HAVE REMOVED BACK LINKS, WE MUST NOT
%2.25%		!DO A STANDARD ERASE OF LINE # CELLS, SO WE LINK FORWARD
%2.25%		!ONLY ACROSS THIS CELL AND THEN SIMPLY RETURN IT.
%2.25%	      THEN DELFLINK(.N)
	      ELSE OFSET_ .OFSET + 1;
            N_.M
          END
        ELSE
          BEGIN
%3.19%      CT[.N,0]<HDRF>_0;
%3.19%      N_.CT[.N,0]<NEXTF>;
%3.19%	    OFSET_ .OFSET + 1;
          END
    ELSE
      BEGIN
	NEWLINE();
%2.25%	!NOW OUTPUT MODULE OR ROUTINE OR FUNCTION NAME AS 
%2.25%	!ADDRESS TAG.  OUTPUT THE APPROPRIATE NAME TO THE LISTING DEVICE.

%2.25%	IF .FCNSTATE EQL 0
%2.25%	  THEN
%3.19%	    (IF .STATFLG
%3.19%	      THEN EOUTPSTRING
%3.19%	      ELSE OUTPSTRING)(FNAME)
%2.25%	  ELSE
%3.19%	    (IF .STATFLG
%3.19%	      THEN EOSTN
%3.19%	      ELSE OUTSTN)(.CT[.H,2]);
%2.25%	!OUTPUT TAG DELIMITER FOR MACRO
%2.25%	OCHAR(":");
%2.25%	!MAKE IT INTERNAL IF MODULE START ADDRESS OR GLOBAL ROUTINE
%2.25%	IF .FCNSTATE EQL 0
%2.25%	  THEN OCHAR(":")
%2.25%	  ELSE
%2.25%	    IF .ST[.CT[.H,2],0]<TYPEF> EQL GROUTINET
%2.25%	      THEN OCHAR(":");
%2.25%	!NOW END THE LINE
%3.19%	(IF .STATFLG THEN ENEWLINE ELSE NEWLINE)();
        NEWLINE();
	IF LUNDEWORD THEN
	  BEGIN
            OUTSTR(#11^28 OR "  -1",5);
	    OUTSTR(#11^7 OR #11,2);
%3.20%	    OUTNUM(.CT[.N,1],8,12,0);
	    NEWLINE();
	    N_.CT[.N,0]<NEXTF>
	  END;
        UNTIL .N EQL .H DO
          BEGIN
            IF .CT[.N,1]<FUNCF> EQL 0 THEN
              BEGIN
%2.25%		IF (.LNSEEN EQL 0) THEN
%2.25%	        LNSEEN_.CT[.N,1]^(-4);	!LINE NUMBER
                M_.CT[.N,0]<NEXTF>;
%2.25%	        DELFLINK(.N);
                N_.M
              END
            ELSE
              BEGIN
                IF .(M_CT[.N,0]<HDRF>) THEN
                  BEGIN
%2.25%		    OUTSTR("L.",2);
%2.25%		    OUTMOC(LABNUM(.N));	!WRITE OUT THE LABEL #
%2.25%		    OCHAR(":");	!LABEL DELIMITER
                    .M_0
                  END;
		IF .CT[.N,1]<FUNCF> EQL #777 THEN CT[.N,1]<FUNCF> _ 0;
                M_.CT[.N,1];
%2.25%	!OUTPUT A TAB AFTER TAG FIELD
%2.25%	OCHAR(#11);

%2.25%	!OUTPUT OPCODE MNEMONIC
%3.19%          MACHINECODE(.M<23,3>,.M<FUNCF>,0);

%2.25%	!OUTPUT AC FIELD
		A_.M<ACCF>;
%3.19%		IF .M<FUNCF> GEQ #700
%3.20%		   THEN OUTNUM((.M<24,9> AND NOT 3),8,3,0)	! DEVICE CODE
%3.19%		   ELSE MACOUT(.A);			! ACCUMULATOR
                OCHAR(",");

%2.25%	!OUTPUT INDIRECT SIGN
                IF .M<INDRF> THEN OCHAR("@");

%2.25%	!OUTPUT ADDRESS IN CORRECT FORMAT
%3.19%          A_.M<ADDRESSF>; I_.M<INDXF>; T_-1;
                IF (R_.CT[.N,0]<RELOCF>) LEQ 9 THEN

                  CASE .R OF SET

                    IF .I EQL .FREG THEN		!CASE 0
                      (T_0; P_OUTCONOC(.A))
                    ELSE P_OUTCONOC(.A);

                    (T_1; P_OUTSTN(.A));		!CASE 1

%3.19%		BEGIN					!CASE 2
                    P _ OUTCTREF(.A);
%3.19%		    IF NOT HEADERP(.A)			!IF LABEL AND PASSED
%3.19%		       THEN IF .CT[.A,0]<HDRCLASSF> NEQ FRC	!HEADER BIT IS OFF
%3.19%			       THEN T_ 3;		!IF ROUTINE NAME IS LABEL
%3.19%		END;

%3.9-1%		(OUTPSTRING(ONAME);  P_OUTOFFSET(.A));	!CASE 3

%3.9-1%		(OUTPSTRING(GNAME);  P_OUTOFFSET(.A));	!CASE 4

		    BEGIN T_1;				!CASE 5
		      P_
			OUTSTN(.ST[.A,1]<LEFTF>)+
%3.23%			  OUTOFFSET(.ST[.A,1]<OFFSETF>)-6
		    END;

%2.25%		!ADDRESS OF CONSTANT			!CASE 6
%2.25%		!IF THIS CAN BE A LITERAL, MAKE IT ONE AND OUTPUT AS LITERAL ADDRESS
%2.25%
%2.25%		IF .PT[.A,0]<RELOCF> EQL LOCRELOC	!MAKE IT A LITERAL
%2.25%		  THEN
%2.25%		    BEGIN
%2.25%		      R_CT[.N,0]<RELOCF>_LTRELOC;
%2.25%		      A_CT[.N,1]<ADDRESSF>_LTINSERT(OFFST(.PT[.A,1]));
%2.25%%3.9-1%	      OUTPSTRING(LNAME);
%2.25%%3.9-1%  	      P_OUTOFFSET(RLTTRANS(.A));
%3.19%		      T_ 2;			!NOTE LITERAL IS ACTUALLY A LOCAL
%2.25%		    END
%2.25%		  ELSE
%2.25%		BEGIN !ADDRESS OF CONSTANT POINTER
%3.23%		  OUTPSTRING(CNAME);
%3.23%		  P_OUTOFFSET(RPTTRANS(.A));	!CHANGE PT IND TO OFFSET
%3.19%	  	  IF .PTREL[.A] EQL EXTRELOC
%3.19%		     THEN T_ 1			!PT REFERENCES A LITERAL
%3.19%		     ELSE IF .PTREL[.1] EQL CTRELOC	!SEE IF LABEL
%3.19%		        THEN IF NOT .HEADERP(.PTOPAD[.A])
%3.19%			   THEN IF .CT[.PTOPAD[.1],0]<HDRCLASSF> NEQ FRC
%3.19%				 THEN T_ 3;
%2.25%		END;

                    BEGIN				!CASE 7
%2.25%		      !ADDRESS OF LITERAL
%2.25%%3.9-1%         OUTPSTRING(LNAME);
%2.25%%3.9-1%	      P_OUTOFFSET(RLTTRANS(.A));	!CHANGE LT INDEX TO LTT OFFSET
                    END;

		(T_2; P_OUTCONOC((.A-.FNSTAT) AND 1^18-1));	!CASE 8

%2.25%%3.9-1%	(OUTPSTRING(PNAME);  P_OUTOFFSET(.A))		!CASE 9


                  TES;


%2.25%	!NOW OUTPUT INDEX REG
                IF .I NEQ 0 THEN
                  BEGIN
                    P_.P+4;
%3.19%              OCHAR("(");  MACOUT(.I);  OCHAR(")")
                  END;

%2.25%	!NOW OUTPUT COMMENT FIELD
                  BEGIN P_(.P+.M<INDRF>+3)^(-3);
!		    IF .TTYLST THEN OCHAR(#11) ELSE
                    OUTSTR(#11^21 OR #11^14 OR #11^7 OR #11,4-.P);
		    OCHAR(";");
%2.25%		!OUTPUT CODE LINE OFFSET
%3.20%		OUTNUM(.OFSET,8,5,0);
%2.25%		!THEN BLISS-10 LINE REF #, IF ANY
%2.25%			OCHAR(#11);	!TAB
%2.25%			IF .LNSEEN NEQ 0
%2.25%			  THEN
%2.25%			    BEGIN
%3.20%			      OUTNUM(.LNSEEN,10,4,0);	!LINE # IN DECIMAL
%2.25%			      LNSEEN_0;	!SO WE CAN GET NEXT ONE
%2.25%			    END;
%2.25%			!THEN ADDRESS PARAMETER TYPE
%3.19%			IF .T GEQ 0
%2.25%			  THEN
%2.25%			    BEGIN
%2.25%			      OCHAR(#11);
%2.25%			      OUTPSTRING (CASE .T OF SET
%2.25%					PLIT (ASCIZ 'Formal');
%2.25%					PLIT (ASCIZ 'External');
%2.25%					PLIT (ASCIZ 'Local');
%3.19%					PLIT (ASCIZ '^^^')
%2.25%					TES)
%2.25%			    END;
                  END;
		NEWLINE();
%3.19%		OFSET_ .OFSET + 1;
                N_.CT[.N,0]<NEXTF>
              END;
          END;
	NEWLINE();  NEWLINE();
      END;
%3.19% MODLENGTH_  .MODLENGTH + .OFSET
  END;
! INITIALIZATION ROUTINE
!------------------------


ROUTINE REINIT=
    BEGIN
    ! THIS ROUTINE IS THE PRIMARY INITIALIZATION OF THE COMPILER.
    ! IT IS CALLED TO RE-INIT THE SYSTEM FOR EACH COMPILATION.

	LOCAL C,J;
        REALFS_0;     !CURRENT KLUGE
%V2H%	LABIND_0;	!ZERO INDEX OF LABEL CHAIN
	ACCUM_(ACCUM+1)_-2;
	PACCUM_(ACCUM)<36,7>;
	TIMSTAT_0;	!INITIALIZE TIMER DATA WORD
	CODETOG_1;
	BLOCKPURGE(0); TOPOFTABLE_.RETOT<RIGHTHALF>;
	ENDOFSPACE_.RETOT<LEFTHALF>;
	FREEHEAD_AMNTFREE_ENDLK_0;
	CCLINIT();

	!NOW SHRINK CORE BACK DOWN TO ORIGINAL SIZE

	IF .?.JBREL NEQ .SAVJBREL THEN
	  BEGIN
	    IF (.?.JBSYM<RIGHTHALF> GTR 0) AND (.?.JBSYM<RIGHTHALF> LSS #400000)
	     THEN	!SAVE SYMBOL TABLE IF IN LOW SEG
		BEGIN
		  REGISTER R;
		  MACHOP HLRO = #564;
		  BIND L= (NOT HLRO (R,?.JBSYM)),
		  NEWSYM= (.SAVJBREL<0,18>-L),
		  OLDSYM= (.?.JBSYM<0,18>);

		  INCR I FROM 0 TO L DO
			NEWSYM[.I]_.OLDSYM[.I];
		  ?.JBSYM<0,18> _ NEWSYM;
		END;

	    !NOW LET'S TRY TO GET RID OF THE EXCESS CORE IN THE LOWSEG
	    IF DOCOREUUO (.SAVJBREL<RIGHTHALF>) THEN WARNEM (0,ERCANTSHRINK)
	END;

%2.25%	EXTCOUNT_-1;	!COUNT OF EXTERNS OUT TO MACRO LISTING
%2.25%	TEXTHD_0;	!POINTS TO TEMP EXT LIST FROM EXPHT
%2.34%	GLLIST_0;	!CLEAR GLOBAL SYMBOL TABLE
%2.19%	DECR I FROM HTSIZE-1 TO 0 DO XHT[.I]_0;
	INITIO();
	GTP_CODEPROP_0;
%2.32%	!SET UP DEFAULT MODULE NAME MAIN
%2.32%	MNAM_'MAIN'+#177^1;  MNAM+1_-2;
	BUFPT1_BUF1<0,2>; BUFPT2_BUF2<0,2>;
	BUF1_1^18; BUF2_2^18;
	ERRORFOUND_WARNINGFOUND_ERRLEVEL_0;
	LINCNT_NLINES_PGSL_0;
%2.25%	NEXTLAB_0;	!INITIALIZE NEXT ADDRESS LABEL NUMBER
%2.9%	!CLEAR LIT TABLE BASE TABLE AND
%2.9%	!LTTRANS BASE TABLE
%2.9%	  DECR I FROM LTNUM-1 TO 0 DO
%2.9%	    LTBASE[.I]_LTTBASE[.I]_0;
	DECR I FROM  PTMASK+1 TO 0 DO PT[.I,0]_PT[.I,1]_0;
        DECR I FROM 31 TO 0 DO GRAPHHEAD[.I]_0;
	DECR I FROM EXPHTSIZE-1 TO 0 DO EXPHT[.I]_0;
        TGRBLEVEL_0;
	MUSTDU_TRBLEVEL_STRDEF_MAPTB_SSTREX_STREXP_INDECS_0;
	VAL_ACCUMLENGTH_MACRODEF_0;
        CHAR_EOL;
	SYM_DEL_FUTSYM_FUTDEL_STRHED_FSTRHED_0;
	UNDECLEX_#300000;
	ENLEX_0;LOC2_0; ETP_-1; ETL_0;
        GTL_OTL_0;
	FREEVHEADER_0;
	LOADECREG_-1;
	OPTTOREGADDR_-1;
	MODLENGTH_0;
	BLOCKLEVEL_1; FCNSTATE_0;
        FUNCTIONLEVEL_NEEDDISP_0;
	NEXTOWN_NEXTGLOBAL_0;
	NOCSAV_0;
	NOPSAV_0;
	STARTBLOCK_ ERROPEN_ NOENGLISH_ 0;	! VARIOUS SWITCHES
	NOGBGCOL_NORECVAL_0;
	CURST_CURSTI_STRDEF_0;
	PGM_HEADER(0,0,0);
	PROGRAM_HEADER(0,0,0); PUSHBOT(.PGM,.PROGRAM);
	CODEPTR_HEADER(0,0,0); PUSHBOT(.PROGRAM,.CODEPTR);
	FCNLIST_HEADER(0,0,0);
        PLNEXT_PLBOOL_0;
        PLHEAD_HEADER(2,0,1);
        CT[.PLHEAD,2]<RIGHTHALF>_1;
        ENTHED_LSTART_NUMENT_0;
	VALIDBUF_0;
	PAGE();
	SKAN(1);
	INITSYNTAX();
BEGIN
  MAP MNAM, ACCUM;
  MACRO SYNER(X,Y)=(WARNEM(X,Y); RETURN 1)$,
        LDEL=DEL<LEFTHALF>$;

  LOCAL AVLREG, VALREG, CONTIG;

  MODREGM_RESREGM_0;
  NOSVR_5;
%3.36%  SREG_FREG_VREG_-1; %INDICATES NOT YET ALLOCATED%
  STKLEN(0)_STKLEN(1)_0;

  IF .LDEL EQL HMODULE THEN %PROCESS MODULE DECLARATION%
    BEGIN
	MHTIME_1;
      IF (IF .REALFS NEQ 0
            THEN (MNAM[0]_.ST[.REALFS,2];
                  MNAM[1]_.ST[.REALFS,3];
                  HPAROPEN)
            ELSE HROPEN) EQL .FUTDEL<LEFTHALF>
        THEN (HRUND();
              VALREG_SWITCHER(ALLSWL))
        ELSE VALREG_2;
     MHTIME_.TTFLAG;
      IF 0 NEQ (VALREG_
               (CASE .VALREG OF
        SET
           IF .LDEL NEQ HROCLO THEN .NDEL ELSE
           IF .FUTSYM NEQ HEMPTY THEN .NFUTSYM ELSE
           IF .FUTDEL<LEFTHALF> NEQ HEQL THEN .NFUTDEL ELSE 0;
           (-1);
           IF .FUTDEL<LEFTHALF> NEQ HEQL THEN .NFUTDEL ELSE 0;
           .NSYM
        TES))
          THEN %LOOK FOR A BEGIN OR END OF FILE, THE LATTER BEING
                A TRIVIAL PROGRAM AND THEREFORE RECOMPILABLE%
            (IF .VALREG NEQ -1 THEN WARNEM(.VALREG,ERSYMODBEG);
            WHILE .LDEL NEQ HBEGIN
               DO (HRUND();
                   IF .LDEL EQL HELUDOM OR .FINFLG
                     THEN (ERROR(.NDEL,ERSMNOPROG);
                           RETURN 1));
             WARNEM(.NSYM,ERSYMODBEG))
          ELSE (HRUND(); HRUND());
    END; %MODULE DECLARATION PROCESSING%

  % INITIALIZE REGISTER, LOADER, AND CONTROL IN THAT (CRITICAL) ORDER %

  RGINIT();    LIINIT();    CNINIT();

END;  % END OF REGISTER/STACK INITIALIZATION BLOCK %
  NEXTLOCAL_2+.NOSVR;
	0 END;
!    PROCESS THE "ENTRIES" SWITCH BY LEAVING STE POINTERS IN
!  THE LIST "ENTHED".  WRNENT CALLED BY DRIVER TO WARN USER OF
!  UNDECLARED ENTRIES.



GLOBAL ROUTINE PSWENT=
  BEGIN
    LOCAL STVEC NEWCELL;
    MACRO SYNER(A)=(WARNEM(A,ERSYENTINV); RETURN 1)$;
    
    IF .DEL<LEFTHALF> NEQ HEQL OR
       .FUTSYM NEQ HEMPTY OR
       .FUTDEL<LEFTHALF> NEQ HROPEN
      THEN SYNER(.NDEL);

    HRUND(); ENTHED_HEADER(0,0,0);
    
    DO
      (HRUND();
       IF .SYM<LSF> THEN
         (NEWCELL_GETSPACE(1);
          NEWCELL[0]_.NEWCELL^15+.NEWCELL;
          NEWCELL[1]_.SYM<STEF>;
          NUMENT_.NUMENT+1;
          PUSHBOT(.ENTHED,.NEWCELL))
                    ELSE SYNER(.NSYM))
      WHILE .DEL<LEFTHALF> EQL HCOMMA;

    IF .DEL<LEFTHALF> NEQ HROCLO OR
       .FUTSYM NEQ HEMPTY 
      THEN SYNER(.NDEL);
    HRUND();
    0
  END;


ROUTINE WRNENT=
  BEGIN
    LOCAL STVEC CDR;
    CDR_.CT[.ENTHED,1]<NEXTF>;
    WHILE .CDR NEQ .ENTHED DO 
     (IDERROR(ERSMNOENT,.CDR[1]);
      CDR_.CDR[0]<NEXTF>);
    ERASE(.ENTHED)
  END;
!--------------------------HERE IT IS FOLKS-------------------------

!
!
!              BLISS COMPILER MAIN DRIVER CODE
!             ----------------------------------
!
!




GLOBAL ROUTINE DRIVER=
BEGIN
%2.29%	IF .BIO EQL 0 THEN ONCEONLY();
WHILE 1 DO
    BEGIN
    0<0,36>_STACK; 0<18,18>_-#1400; 2<0,36>_.0<0,18>;
    IF NOT REINIT() THEN (EXPRESSION(2);
    WHILE .DEL<LEFTHALF> NEQ HELUDOM AND NOT.FINFLG DO
	( HRUND(); IF .DEL<LEFTHALF> EQL HSEMCOL AND .FUTDEL<LEFTHALF> EQL HELUDOM
		THEN WARNEM(.NDEL,35) ELSE RECOVER(.NDEL,34));
  IF .ERRORFOUND EQL 0 THEN
	BEGIN
        IF (.TTFLAG AND (.STKLEN(0) NEQ 0)) THEN MPTIMOUT();  !MAIN PROGRAM TIMEOUT ROUTINE
	CONVEY(.SYM);CODE(#47,0,#12,0); CODEPTR_.PROGRAM;
        FNSTAT_(IF .NEEDDISP THEN
          BEGIN
            ACPDT();  %SET UP DISPLAY AND FAKE REGISTERS %
            CODE(PUSH,.SREG,.FREG,0);
            CODE(ADD,.SREG,LITA(LITLEXEME((.NOSVR+1)*#1000001)),0);
            CODEPTR_.PROGRAM;
            0
          END ELSE .NOSVR+1);
          PROMOTE(1^RELC OR 1^CNVEYC); CODEPTR _ .PGM;  FLATFUNC();
	WRITECODE(.PGM);
	LDINT(.PGM);
        IF .ENTHED NEQ 0 THEN WRNENT();
	END;);


    IF .XREFLG THEN XREFWRITE();
    WRITEFINAL();
!    FORCE(0); IF NOT .BINFLG THEN FORCE(1); IF NOT .LSTFLG THEN FORCE(2);
    FINIO();
END;
END;
!  START IT UP HERE
!  ================



CCLCTL_.(3<0,36>);
DRIVER()







!END OF H3DRIV.BLI
