	TITLE	OPGNTA - CODE GENERATION TABLES FOR FORTRAN-10
	SUBTTL	S. MURPHY/SRM/HPW		21-MAR-74

;COPYRIGHT 1972,1973, DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS

	INTERN	OPGNV
	OPGNV= BYTE (3)0(9)2(6)2(18)^D120		;VERSIONDATE: MAY 30,1974

	SUBTTL	REVISION HISTORY

;113	-----	-----	ADD GENERATORS FOR DABS IN LINE
;114	-----	-----	ADD GENERATORS FOR EXPONENTATION IN LINE
;115	-----	-----	TREAT "NEG-SAME-IMMED" (UNDER OPGETA,OPGETI)
;			THE SAME AS "NEG-IMMED"
;116	-----	-----	ADD GENERATORS FOR EXPONEN TO MEMORY IN LINE
;117	-----	-----	REMOVE GENERATORS FOR SQUARE,CUBE,P4 (THEY
;			ARE NOW PART OF "EXPCIOP")
;117	-----	-----	ADD GENERATORS FOR IN LINE DP EXPONEN AND
;			FOR IN LINE EXPONEN OF AN IMMEDIATE LOOP INDEX

	SUBTTL	CODE GENERATORS
;
	HISEG
	INTERN	OPGETA
	INTERN	OPGETI
	INTERN	OPGSET		;BASE OF TABLE FOR INITIALIZATION
				; OF LOGICAL VALS
	INTERN	OPGARA		;BASE OF TABLE FOR ARITH OPS, KA10
	INTERN	OPGARI		;BASE OF TABLE FOR ARITH OPS, KI10
	INTERN	OPGTCA		;BASE OF TABLE FOR TYPE-CONVERSIONS ON KA10
	INTERN	OPGTCI		;BASE OF TABLE FOR TYPE-CONVERSIONS ON KI10
	INTERN	OPGSTA		;BASE OF TABLE FOR "STORE"- KA10
	INTERN	OPGSTI		;BASE OF TABLE FOR "STORE" - KI10
	INTERN	OPGASA		;BASE OF TABLE FOR ASSIGNMENT STMNT-KA10
	INTERN	OPGASI		;BASE OF TABLE FOR ASSIGNMENT STMNT-KI10
	INTERN	OPGASR		; SPECIAL CASE FOR ASSIGNMENT OF RIGHT HALF
				; OF AOBJN WD
	INTERN	OPASIN		;TABLE FOR ASSIGN STMNT
	INTERN	OPGBOO		;BASE OF TABLE FOR BOOLEAN OPS
	INTERN	OPGREL		;BASE OF TABLE FOR RELATIONALS
	INTERN	OPGSPA		;BASE OF TABLE FOR P2MUL,P2PL1MUL -
				; KA10
	INTERN	OPGILF		;BASE OF TABLE FOR IN-LINE-FNS (WHEN
				; THE ARG IS ALREADY IN REGFORCOMP)
	INTERN	OPGILI		; (WHEN ARG1 IS REGFORCOMP,ARG2 IS IMMED)
	INTERN	OPGIL1		;BASE OF TABLES FOR IN-LINE-FNS WHEN
				; ARG IS NOT IN REGFORCOMP: ABS AND SIGN
	INTERN	OPGN1A		;BASE OF TABLE FOR NEG (WHEN ARG ALREADY IN RFC)
				; KA10
	INTERN	OPGN1I		; KI10
	INTERN	OPGN2A		;BASE OF TABLE FOR NEG WHEN ARG NOT IN RFC
				; KA10
	INTERN	OPGN2I		; KI10
	INTERN	OPGSPI		;BASE OF TABLE FOR P2MUL,P2PL1MUL -
				; KI10
	INTERN	OPGSPM		;BASE OF TABLE FOR P2MUL ETC DONE TO MEMORY
	INTERN	OPGSTC		;BASE OF TABLE FOR A "STORECLS" NODE
	INTERN	OPGSTD		;BASE OF TABLE FOR "STORECLS"- DOUBL-P
	INTERN	OPGVTS		;BASE OF TABLE FOR TRANSFER OF CONTROL
				; ON A GIVEN VAL OF A GIVEN VAR
	INTERN	OPGALT		;BASE OF TABLE FOR TRANSFER OF CONTROL
				; TO ONE LABEL IF A GIVEN VAR IS TRUE
				; AND TO ANOTHER IF IT IS FALSE
	INTERN	OPGAIF		;BASE OF TABLE FOR ARITH-IF STMNTS IN WHICH
				; THE VAL MUST BE COMPUTED AND TESTED
	INTERN	OPGCGO		;BASE OF TABLE FOR COMPUTED GOTO
	INTERN	OPGCGI		; FOR COMPUTED GOTO WHEN THE VAR IS IN THE
				; RIGHT HALF OF A REG CONTAINING DO-LOOP CTL
	INTERN	OPGIOL		;TO GENERATE A CALL TO IOLST.
	INTERN	OPGMTO		;		TO MTOP.
	INTERN	OPGIN		;		TO IN.
	INTERN	OPGENC		;		TO ENC.
	INTERN	OPGDEC		;		TO DEC.
	INTERN	OPGOUT		;		TO OUT.
	INTERN	OPGWTB		;		TO WTB.
	INTERN	OPGRTB		;		TO RTB.
	INTERN	OPGNLI		;		TO NLI.
	INTERN	OPGNLO		;		TO NLO.
	INTERN	OPGOPE		;		TO OPEN.
	INTERN	OPGFND		;		TO FIND.
	INTERN	OPGRLS		;		TO RELEAS.
	INTERN	OPGCLO		;		TO CLOS.
	INTERN	OPGLIB		;		TO MATH LIBRARY FUNCTION
	INTERN	OPGADJ		;		TO ADJ.
	INTERN	OPGPAU		;ENTRY TO GENERATE CODE FOR PAUSE
	INTERN	OPGSTP		;ENTRY TO GENERATE CODE FOR STOP
	INTERN	OPGEXI		;ENTRY TO GENERATE CODE FOR THE EXIT AT END
				; OF A MAIN PROGRAM
	INTERN	OPGRES		; TO GENERATE CODE FOR CALL TO RESET
	INTERN	OPGFIN		; TO GENERATE CALL TO FOROTS FIN.
	INTERN	OPP21I		; MULTIPLY IMMED MODE BY POWER OF 2+1
	INTERN	OPGPHR		; TO PUSH REGS FOR REG SAVE FOR SFN
	INTERN	OPGPPR		; TO POP REGS FOR REG RESTORE FOR SFN

	INTERN	OPGDBF		; TO GENERATE DABS IN LINE WHEN ARG IN
				; REGFORCOMP
	INTERN	OPGDB1		; TO GENERATE DABS IN LINE WHEN ARG NOT
				; IN REGFORCOMP
	INTERN	OPGEX		; TO GENERATE EXPONENTATION IN LINE
	INTERN OPGEXS
	INTERN OPGEXM
	INTERN OPGXPI

;
;DEFINE THE CODE GENERATION TABLES AND DISPATCH TABLE
;
;ELEMENTS IN THE DISPATCH TABLE ARE AOBJN PTRS TO THE PIECE OF CODE 
; TO BE GENERATED OR EITHER OF THE FLAGS
;	ILG -  FOR ILLEGAL ENTRY (EG THE ENTRY FOR A1SAMEFLG AND 
;		A1IMMEDFLG BOTH SET
;	IGN - FOR NO CODE NEED BE GENERATED FOR THIS NODE
;
	IGN=0
	ILG=1
;
;DEFINE CODE GENERATORS FOR EACH OPERATION
;EACH WORD OF CODE TO BE GENERATED IS REPRESENTED BY A 2 WD ENTRY
;	L.H. OF WD 0 - SPECIFIES WHETHER TO ADD A SPECIFIED "REG FOR
;			COMP" INTO THE REG FIELD OF THE PATTERN WD
;	R.H. OF WD 0 - SPECIFIES WHERE TO GET THE "MEMREF" FIELD (BITS
;		13-36) OF THE INSTRUCTION FROM
;	WD 1 - PATTERN FOR INSTRUCTION TO BE GENERATED
;
;DEFINE POSSIBLE VALS FOR LEFT AND  RIGHT HALVES OF WD 0
	FRPTN=0			;FROM PATTERN WD
	FRRFC=1			;FROM "REGFORCOMP"
	IMFN=2			;USE THE IMPLICIT-FN-NAME PTED TO BY TREEPTR
	WD1IMF=3		;USE THE IMPLICIT-FN NAME POINTED TO
				; BY THE RH OF THE PATTERN WD
	RGIMFN=4		;USE THE IMPLICIT FN NAME POINTED TO BY
				; THE RH OF THE PATTERN WD INDEXED BY
				; THE "REGFORCOMP" (IE DIFFERENT
				; LIBRARY ROUTINES ARE CALLED DEPENDING
				; ON WHICH REG THE ARG IS IN)
	A1CNST=5		;ARG1 IMMED CNST
	A2CNST=6		;ARG2 IMMED CNST
	A1CNNG=7		;USE NEG OF IMMED CNST ARG1
	A2CNNG=10		;USE NEG OF IMMED CNST ARG2
	PTRA2=11			;USE ARG2PTR FIELD OF PARENT
	NGPTR2=12		;USE THE NEGATIVE OF THE ARG2PTR FIELD OF
				; PARENT
	P2PTR2=13		;USE 2**(VAL OF ARG2PTR)-1 (USED FOR
				; P2DIV)
	A1LAB=14		;USE THE LABEL INDICATED BY A1LABEL
	A2LAB=15		;USE THE LABEL INDICATEC BY A2LABEL
	A3LAB=16		;USE THE LABEL INDICATED BY A3LABEL
	FROMC1=17		;USE THE CONTENTS OF THE GLOBAL C1H, 
				; THIS ADDRESS FIELD WILL HAVE NO
				; SYMBOLIC REPRESENTATION
	PARTMP=20		;USE THE TMP INDICATED BY THE TARGET
				; OF PARENT (IGNORE INDIRECT AND INDEX
				; BITS IN THE TARGET)
	FROMA1=21		;USE TARGET FIELD OF ARG1
	FROMA2=22		;USE TARGET FIELD OF ARG2
	FROMPA=23		;USE TARGET FIELD OF PARENT (TREEPTR)
;
;
;
;DISPATCH TABLE FOR 'GET ARG INTO A REG' - 
;TO GENERATE CODE FOR THE KI10
OPGETI:	-1,,GA		;NO FLAGS, SINGLE PREC
	-1,,GA
	-1,,GA2KI		;NO FLAGS, DOUBLEPREC, 
	-1,,GA2KI		;NO FLAGS, COMPLEX
	-1,,GAIMI		;IMMED - INTEGER 
	-1,,GAIMRL		;IMMED - REAL
	-2,,GAIM2		;IMMED, DOUBL-PREC - RARELY GENERATED
	-2,,GAIM2		;IMMED COMPLEX
	IGN			;IGNORE (ARG SAMEFLG SET)
	IGN
	IGN
	IGN
	IGN			;ARG SAME AND ARG IMMED FLAGS WILL BOTH BE
				; SET WHEN A REGCONTENTS WHICH IS LOOP CTL VAR
				; IS AN ARG UNDER A RELATIONAL (IGNORE)
	IGN
	IGN
	IGN
	-1,,GANG		;NEG OF ARG
	-1,,GANG
	-1,,GANG2I		;NEG OF DOUBLE-WD ARG - 
	-2,,GNGCM		;NEG OF COMPLEX ARG
	-1,,GNGIMI		;NEG OF IMMED CNST - INTEGER
	-1,,GNGIMR		;NEG OF IMMED CNST - REAL
	-2,,GNGIM2		;NEG OF IMMED DOUBLE-WD
	-2,,GNGIM2
	-1,,GANGSM		;NEG OF VAL ALREADY IN DESIRED REG
	-1,,GANGSM
	-1,,GNGS2I		;NEG OF DOUBLE-WD ARG ALREADY IN DESIRED
				; REG
	-2,,GNGSCM		;NEG OF COMPLEX ARG ALREADY IN DESIRED 
				; REG
		;SAME-IMMED NEGATED - TREAT AS IMMED NEGATED (IGNORE
		; THE "SAMEFLG") - OCCURS WHEN BB ALLOCATOR HAS FOUND
		; AN IMMED CNST THAT WAS LEFT IN A REG AND THEN
		; LATER A NEGFLG WAS MOVED OVER THAT CNST IN CGETVAL
	-1,,GNGIMI		;NEG OF IMMED CNST - INTEGER
	-1,,GNGIMR		;NEG OF IMMED CNST - REAL
	-2,,GNGIM2		;NEG OF IMMED DOUBLE-WD
	-2,,GNGIM2


	-1,,GANT		;NOT OF ARG 
	-1,,GANT
	-2,,GANT2		;NOT OF DOUBLE-WD ARG 
	-2,,GANT2
	-1,,GNTIMI		;NOT OF IMMED CNST - INTEGER
	ILG			;NOT OF IMMED CNST - REAL
	ILG			;NOT OF IMMED, DOUBLE-WD
	ILG	
	-1,,GANTSM		;NOT OF VAL ALREADY IN THE DESIRED REG
	-1,,GANTSM
	-2,,GNTS2		;NOT OF DOUBLE-WD ARG - 
	-2,,GNTS2
;NOTE THAT ALL "GETA1OPIX" VALS ABOVE THIS PT ARE ILLEGAL
; (INVOLVING EITHER BOTH NEG AND NOT OR SAME AND IMMED)
;
;DISPATCH TABLE FOR 'GET ARG INTO A REG' - 
;TO GENERATE CODE FOR THE KA10
OPGETA:	-1,,GA		;NO FLAGS, SINGLE PREC
	-1,,GA
	-2,,GA2KA		;NO FLAGS, DOUBLEPREC, 
	-2,,GA2KA		;NO FLAGS, COMPLEX
	-1,,GAIMI		;IMMED - INTEGER 
	-1,,GAIMRL		;IMMED - REAL
	-2,,GAIM2		;IMMED, DOUBLE-WD - 
	-2,,GAIM2
	IGN			;IGNORE (ARG SAMEFLG SET)
	IGN
	IGN
	IGN
	IGN			;ARG SAME AND ARG IMMED FLAGS (OCCURS WHEN
				; HAVE REGCONTENTS UNDER A RELATIONAL
	IGN
	IGN
	IGN
	-1,,GANG		;NEG OF ARG
	-1,,GANG
	-3,,GANG2A		;NEG OF DOUBLE-WD ARG - 
	-2,,GNGCM		;NEG OF COMPLEX ARG
	-1,,GNGIMI		;NEG OF IMMED CNST - INTEGER
	-1,,GNGIMR		;NEG OF IMMED CNST - REAL
	-2,,GNGIM2		;NEG OF IMMED DOUBLE-WD
	-2,,GNGIM2
	-1,,GANGSM		;NEG OF VAL ALREADY IN DESIRED REG
	-1,,GANGSM
	-1,,GNGS2A		;NEG OF DOUBLE-WD ARG ALREADY IN DESIRED
				; REG
	-2,,GNGSCM		;NEG OF COMPLEX ARG ALREADY IN DESIRED 
				; REG
		;SAME-IMMED NEGATED - TREAT AS IMMED NEGATED (IGNORE
		; THE "SAMEFLG") - OCCURS WHEN BB ALLOCATOR HAS FOUND
		; AN IMMED CNST THAT WAS LEFT IN A REG AND THEN
		; LATER A NEGFLG WAS MOVED OVER THAT CNST IN CGETVAL
	-1,,GNGIMI		;NEG OF IMMED CNST - INTEGER
	-1,,GNGIMR		;NEG OF IMMED CNST - REAL
	-2,,GNGIM2		;NEG OF IMMED DOUBLE-WD
	-2,,GNGIM2


	-1,,GANT		;NOT OF ARG 
	-1,,GANT
	-2,,GANT2		;NOT OF DOUBLE-WD ARG 
	-2,,GANT2
	-1,,GNTIMI		;NOT OF IMMED CNST - INTEGER
	ILG			;NOT OF IMMED CNST - REAL
	ILG			;NOT OF IMMED, DOUBLE-WD
	ILG
	-1,,GANTSM		;NOT OF VAL ALREADY IN THE DESIRED REG
	-1,,GANTSM
	-2,,GNTS2		;NOT OF DOUBLE-WD ARG - 
	-2,,GNTS2
;NOTE THAT ALL "GETA1OPIX" VALS ABOVE THIS PT ARE ILLEGAL
; (INVOLVING EITHER BOTH NEG AND NOT OR SAME AND IMMED)
;

;
;
;DEFINE CODE GENERATORS FOR GETTING ARG1 INTO A REG
;
;
	GA=.		;GET ARG INTO REG
	GA2KA=.		;GET DOUBLE-PREC ARG (ON KA10 )
	GANG2A=.	;GET DOUBLE-PREC NEG (ON KA10)
;
	FRRFC,,FROMA1
	MOVE	0,0
;
	FRRFC,,FROMA1
	MOVE	1,1
;
	FRRFC,,FRRFC
	DFN	0,1
;
;
;
	GA2KI=.		;DOUBLE-PREC KI
	FRRFC,,FROMA1
	DMOVE	0,0
;
;GET IMMED ARGS
	GAIMI=.		;IMMED - INTEGER
	FRRFC,,A1CNST
	MOVEI	0,0
;
	GAIMRL=.	;IMMED - REAL
	GAIM2=.		;IMMED DOUBLE-WD
	FRRFC,,A1CNST
	MOVSI	0,0
;
	FRRFC,,FRPTN
	MOVEI	1,0
;
;
; GET NOT OF ARG
;
	GANT=.			;GET NOT OF ARG
	FRRFC,,FROMA1
	SETCM	0,0
;
	GANT2=.		;GET NOT OF DOUBLE-PREC ARG
	FRRFC,,FROMA1
	SETCM	0,0
	FRRFC,,FROMA1
	SETCM	1,1
;
	GNTIMI=.		;NOT OF AN IMMED CNST - INTEGER
	FRRFC,,A1CNST
	SETCMI	0,0
;
;
;
	GANTSM=.			;NOT OF AN ARG ALREADY IN DESIRED REG
	GNTS2=.			; NOT OF A DOUBLE-WD ARG ALREADY IN 
				; DESIRED REG
	FRRFC,,FRPTN
	SETCA	0,0
;
	FRRFC,,FRPTN
	SETCA	1,0
;
;
;GET NEG ARG
;
	GANG=.			;NEG OF ARG
	GNGCM=.			;NEG OF A COMPLEX ARG
	FRRFC,,FROMA1
	MOVN	0,0
;
	FRRFC,,FROMA1
	MOVN	1,1
;
;
	GANG2I=.		;NEG OF DOUBLE-WD ARG FOR KI10
	FRRFC,,FROMA1
	DMOVN	0,0
;
;
	GNGIMI=.		;NEG OF AN IMMED ARG - INTEGER
	FRRFC,,A1CNST
	MOVNI	0,0
;
	GNGIMR=.		;NEG OF AN IMMED ARG - REAL
	GNGIM2=.		;NEG OF AN IMMED ARG - DOUBLE-WD
	FRRFC,,A1CNNG
	MOVSI	0,0
;
	FRRFC,,FRPTN
	MOVEI	1,0
;
;
;
	GANGSM=.		;NEG OF ARG ALREADY IN DESIRED REG
	GNGSCM=.		;NEG OF COMPLEX ARG ALREADY IN SAME REG
	FRRFC,,FRRFC
	MOVN	0,0
;
	FRRFC,,FRRFC
	MOVN	1,1
;
;
	GNGS2A=.		;NEG OF DOUBLE-WD ARG ALREADY IN REG-
				; FOR KA10
	FRRFC,,FRRFC
	DFN	0,1
;
;
	GNGS2I=.		;NEG OD DOUBLE-WD ARG ALREADY IN REG 
				; FOR KI10
	FRRFC,,FRRFC
	DMOVN	0,0
;
;


;
;TABLE FOR CODE GENERATION FOR INITIALIZATION OF LOGICAL VALUES
;
OPGSET:	-1,,FLSMEM		;SET MEM LOC FALSE
	-1,,FLSREG		;SET REG FALSE
	-1,,TRMEM		;SET MEM LOC TRUE
	-1,,TRREG		;SET REG TRUE
;
;	CODE GENERATORS FOR LOGICAL INIT
	FLSMEM=.
	FRPTN,,FROMPA
	SETZM	0,0
;
	FLSREG=.
	FRRFC,,FRPTN
	SETZ	0,0
;
	TRMEM=.
	FRPTN,,FROMPA
	SETOM	0,0
;
	TRREG=.
	FRRFC,,FRPTN
	SETO	0,0
;


;
;TABLE FOR CODE GENERATORS FOR EXPONENTIATION IN LINE
;
OPGEX:	-1,,OPGEX1		;INTEGER MULTIPLY BY MEMORY
	-1,,OPGEX2		;REAL MULTIPLY BY MEMORY
	-1,,OPGEX7		;DP MULTIIPLY BY MEMORY
	ILG			;(COMPLEX EXPONEN NOT DONE IN LINE)
OPGEXS:	-1,,OPGEX3		;INTEGER MULTIPLY BY SELF
	-1,,OPGEX4		;REAL MULTIPLY BY SELF
	-1,,OPGEX8		;DP MULTIPLY BY SELF
	ILG			;(COMPLEX EXPONEN NOT DONE IN LINE)
OPGEXM:	-1,,OPGEX5		;INTEGER MUL TO MEMORY
	-1,,OPGEX6		;REAL MULTIPLY TO MEMORY
	ILG			;DP IS NEVER DONE TO MEMORY
	ILG			;COMPLEX EXPONEN NOT DONE IN LINE

;
	OPGEX1=.

	FRRFC,,FROMA1
	IMUL	0,0
;
	OPGEX2=.

	FRRFC,,FROMA1
	FMPR	0,0
;
	OPGEX3=.

	FRRFC,,FRRFC
	IMUL	0,0
;
	OPGEX4=.

	FRRFC,,FRRFC
	FMPR	0,0
;
	OPGEX5=.
	FRRFC,,FROMA1
	IMULM	0,0
;
	OPGEX6=.
	FRRFC,,FROMA1
	FMPRM	0,0
;
	OPGEX7=.
	FRRFC,,FROMA1
	DFMP	0,0		;DP IS DONE IN LINE FOR KI ONLY
;
	OPGEX8=.
	FRRFC,,FRRFC
	DFMP	0,0
;
;
; FOR EXPONEN OF AN IMMED LOOP INDEX(IE RIGHT HALF OF AOBJN)
;
OPGXPI:	-1,,OPGEX9
;
	OPGEX9=.
	FRRFC,,A1CNST
	IMULI	0,0
;
;TABLE FOR CODE GENERATION FOR ARITH OPERATIONS
;
;FOR KA10
OPGARA:	-1,,ADFX
	-1,,ADFL
	-2,,ADDPKA
	-2,,ADCM
	-1,,SBFX
	-1,,SBFL
	-2,,SBDPKA
	-2,,SBCM
	-1,,MLFX
	-1,,MLFL
	-2,,MLDPKA
	-2,,MLCM
	-1,,DVFX
	-1,,DVFL
	-2,,DVDPKA
	-2,,DVCM
;  FOR OPERATIONS TO MEMORY
	-1,,ADFXM
	-1,,ADFLM
	-2,,ADDPMA
	-2,,ADCMM
	-1,,SBFXM
	-1,,SBFLM
	-2,,SBDPMA
	-2,,SBCMM
	-1,,MLFXM
	-1,,MLFLM
	-2,,MLDPMA
	-2,,MLCMM
	-1,,DVFXM
	-1,,DVFLM
	-2,,DVDPMA
	-2,,DVCMM
;  FOR OPERATIONS PERFORMED IMMEDIATE
	-1,,ADFXI
	-1,,ADFLI
	ILG			;DOUBLE-PREC IMMED IS ILLEGAL
	-1,,ADCMI
	-1,,SBFXI
	-1,,SBFLI
	ILG			;DOUBLE-PREC IMMED IS ILLEGAL
	-1,,SBCMI
	-1,,MLFXI
	-1,,MLFLI
	ILG			;DOUBLE-PREC IMMED IS ILLEGAL
	-2,,MLCMI
	-1,,DVFXI
	-1,,DVFLI
	ILG			;DOUBLE-PREC IMMED IS ILLEGAL
	-2,,DVCMI
;FOR OPERATIONS TO BOTH (NOTE THAT WE DESIGNATE OP TO BOTH BY SETTING
; BOTH THE "OP TO MEMORY" AND "IMMEDIATE" FLAGS)
	-1,,ADFXB	;INTEGER ADD TO BOTH
	-1,,ADFLB	;REAL ADD TO BOTH
	ILG		;DP OPS TO BOTH ON KA10 NOT IMPLEMENTED
	-2,,ADCMB	;COMPLEX ADD TO BOTH
	-1,,SBFXB	;INTEGER SUBTRACT TO BOTH
	-1,,SBFLB	;REAL SUBTRACTB TO BOTH
	ILG		;DP OPS TO BOTH NOT IMPLEMENTED ON KA10
	-2,,SBCMB	;COMPLEX SUBTRACT TO BOTH
	-1,,MLFXB	;INTEGER MULTIPLY TO BOTH
	-1,,MLFLB	;REAL MULTIPLY TO BOTH
	ILG		;DOUBLE PREC OPS TO BOTH ON KA10 NOT IMPLEMENTED
	ILG		;COMPLEX MULTIPLY TO BOTH NOT IMPLEMENTED
	-1,,DVFXB	;INTEGER DIVIDE TO BOTH
	-1,,DVFLB	;REAL DIVIDE TO BOTH
	ILG		;DP OPS TO BOTH ON KA10 NOT IMPLEMENTED
	ILG		;COMPLEX DIVIDE TO BOTH NOT IMPLEMENTED
;
;FOR KI10
OPGARI:	-1,,ADFX
	-1,,ADFL
	-1,,ADDPKI
	-2,,ADCM
	-1,,SBFX
	-1,,SBFL
	-1,,SBDPKI
	-2,,SBCM
	-1,,MLFX
	-1,,MLFL
	-1,,MLDPKI
	-2,,MLCM
	-1,,DVFX
	-1,,DVFL
	-1,,DVDPKI
	-2,,DVCM
;  FOR OPERATIONS TO MEMORY
	-1,,ADFXM
	-1,,ADFLM
	-2,,ADDPMI
	-2,,ADCMM
	-1,,SBFXM
	-1,,SBFLM
	-2,,SBDPMI
	-2,,SBCMM
	-1,,MLFXM
	-1,,MLFLM
	-2,,MLDPMI
	-2,,MLCMM
	-1,,DVFXM
	-1,,DVFLM
	-2,,DVDPMI
	DVCMM
;  FOR OPERATIONS PERFORMED IMMEDIATE
	-1,,ADFXI
	-1,,ADFLI
	ILG			;DOUBLE-PREC IMMED IS ILLEGAL
	-1,,ADCMI
	-1,,SBFXI
	-1,,SBFLI
	ILG			;DOUBLE-PREC IMMED IS ILLEGAL
	-1,,SBCMI
	-1,,MLFXI
	-1,,MLFLI
	ILG			;DOUBLE-PREC IMMED IS ILLEGAL
	-2,,MLCMI
	-1,,DVFXI
	-1,,DVFLI
	ILG			;DOUBLE-PREC IMMED IS ILLEGAL
	-2,,DVCMI
;FOR OPERATIONS TO BOTH (NOTE THAT WE DESIGNATE OP TO BOTH BY SETTING
; BOTH THE "OP TO MEMORY" AND "IMMEDIATE" FLAGS)
	-1,,ADFXB	;INTEGER ADD TO BOTH
	-1,,ADFLB	;REAL ADD TO BOTH
	-2,,ADDPMI	;DP ADD TO BOTH ON KI10 SAME AS DP ADD TO MEM
	-2,,ADCMB	;COMPLEX ADD TO BOTH
	-1,,SBFXB	;INTEGER SUBTRACT TO BOTH
	-1,,SBFLB	;REAL SUBTRACTB TO BOTH
	-2,,SBDPMI	;DP SUB TO BOTH ON KI10 SAME AS DP SUB TO MEM
	-2,,SBCMB	;COMPLEX SUBTRACT TO BOTH
	-1,,MLFXB	;INTEGER MULTIPLY TO BOTH
	-1,,MLFLB	;REAL MULTIPLY TO BOTH
	-2,,MLDPMI	;DP MUL TO BOTH ON KI10 SAME AS DP MUL TO MEM
	ILG		;COMPLEX MULTIPLY TO BOTH NOT IMPLEMENTED
	-1,,DVFXB	;INTEGER DIVIDE TO BOTH
	-1,,DVFLB	;REAL DIVIDE TO BOTH
	-2,,DVDPMI	;DP DIV TO BOTH ON KI10 SAME AS DP DIV TO MEM
	ILG		;COMPLEX DIVIDE TO BOTH NOT IMPLEMENTED
;
;
;DEFINE CODE GENERATORS FOR THE ARITHMETIC OPERATIONS
;
;FOR INTEGER, REAL, AND COMPLEX OPERATIONS
	ADFX=.			;ADD INTEGER
	FRRFC,,FROMA2
	ADD	0,0
;
	ADFL=.			;ADD FLOATING PT
	ADCM=.				;ADD COMPLEX
	FRRFC,,FROMA2
	FADR	0,0
;
	FRRFC,,FROMA2
	FADR	1,1
;
;
	SBFX=.			;SUBTRACT INTEGER
	FRRFC,,FROMA2
	SUB	0,0
;
	SBFL=.			;SUBTRACT FLOATING PT
	SBCM=.			;SUBTRACT COMPLEX
	FRRFC,,FROMA2
	FSBR	0,0
;
	FRRFC,,FROMA2
	FSBR	1,1
;
;
	MLFX=.			;MULTIPLY INTEGER
	FRRFC,,FROMA2
	IMUL	0,0
;
	MLFL=.			;MULTIPLY REAL
	FRRFC,,FROMA2
	FMPR	0,0
;
	MLCM=.			;MULTIPLY COMPLEX
	FRPTN,,FROMA2
	MOVEI	16,0
;
	FRPTN,,RGIMFN
	PUSHJ	17,CMMLTB
;
;
	DVFX=.			;INTEGER DIVIDE
	FRRFC,,FROMA2
	IDIV	0,0
;
	DVFL=.			;REAL DIVIDE
	FRRFC,,FROMA2
	FDVR	0,0
;
	DVCM=.			;COMPLEX DIVIDE
	FRPTN,,FROMA2
	MOVEI	16,0
;
	FRPTN,,RGIMFN
	PUSHJ	17,CMDVTB
;
;
;FOR INTEGER,REAL AND COMPLEX OPERATIONS PERFORMED TO MEMORY
	ADFXM=.			;INTEGER ADD TO MEMORY
	FRRFC,,FROMA2
	ADDM	0,0
;
	ADFLM=.			;ADD FLOATING PT TO MEMORY
	ADCMM=.				;ADD COMPLEX TO MEMORY
	FRRFC,,FROMA2
	FADRM	0,0
;
	FRRFC,,FROMA2
	FADRM	1,1
;
;
	SBFXM=.
	FRRFC,,FROMA2
	SUBM	0,0
;
	SBFLM=.			;SUBTRACT FLOATING PT TO MEMORY
	SBCMM=.				;SUBTRACT COMPLEX TO MEMORY
	FRRFC,,FROMA2
	FSBRM	0,0
;
	FRRFC,,FROMA2
	FSBRM	1,1
;
;
	MLFXM=.			;INTEGER MULTIPLY TO MEMORY
	FRRFC,,FROMA2
	IMULM	0,0
;
	MLFLM=.			;REAL MULTIPLY TO MEMORY
	FRRFC,,FROMA2
	FMPRM	0,0
;
	MLCMM=.			;COMPLEX MULTIPLY TO MEMORY
	FRPTN,,FROMA2
	MOVEI	16,0
;
	FRPTN,,RGIMFN
	PUSHJ	17,CMMLMT
;
	DVFXM=.			;INTEGER DIVIDE TO MEMORY
	FRRFC,,FROMA2
	IDIVM	0,0
;
	DVFLM=.			;REAL DIVIDE TO MEMORY
	FRRFC,,FROMA2
	FDVRM	0,0
;
	DVCMM=.			;COMPLEX DIVIDE TO MEMORY
	FRPTN,,FROMA2
	MOVEI	16,0
;
	FRPTN,,RGIMFN
	PUSHJ	17,CMDVMT
;
;
;	INTEGER,REAL AND COMPLEX OPERATIONS PERFORMED IMMEDIATE
	ADFXI=.
	FRRFC,,A2CNST
	ADDI	0,0
;
	ADFLI=.			;ADD FLOATING IMMEDIATE
	ADCMI=.			;ADD IMMED TO COMPLEX
	FRRFC,,A2CNST
	FADRI	0,0
;
	SBFXI=.
	FRRFC,,A2CNST
	SUBI	0,0
;
	SBFLI=.				;SUB FLOATING IMMED
	SBCMI=.				;SUB IMMED FROM COMPLEX
	FRRFC,,A2CNST
	FSBRI	0,0
;
	MLFXI=.			;INTEGER MULTIPLY IMMEDIATE
	FRRFC,,A2CNST
	IMULI	0,0
;
	MLFLI=.			;REAL MULTIPLY IMMEDIATE
	FRRFC,,A2CNST
	FMPRI	0,0
;
	MLCMI=.			;COMPLEX VAR MULTIPLIED BY AN IMMED CONST
	FRRFC,,A2CNST
	FMPRI	0,0
;
	FRRFC,,A2CNST
	FMPRI	1,0
;
	DVFXI=.			;INTEGER DIVIDE IMMED
	FRRFC,,A2CNST
	IDIVI	0,0
;
	DVFLI=.			;REAL DIVIDE IMMED
	FRRFC,,A2CNST
	FDVRI	0,0
;
	DVCMI=.			;COMPLEX VAR DIVIDED BY AN IMMED CNST
	FRRFC,,A2CNST
	FDVRI	0,0
;
	FRRFC,,A2CNST
	FDVRI	1,0
;
;
;
;
;FOR INTEGER,REAL, AND COMPLEX OPERATIONS TO BOTH
;
	ADFXB=.		;INTEGER ADD TO BOTH
	FRRFC,,FROMA2
	ADDB	0,0
;
	ADFLB=.		;REAL ADD TO BOTH
	ADCMB=.		;COMPLEX ADD TO BOTH (NEXT 2 INSTRS)
	FRRFC,,FROMA2
	FADRB	0,0
;
	FRRFC,,FROMA2
	FADRB	1,1
;
	SBFXB=.		;INTEGER SUBTRACT TO BOTH
	FRRFC,,FROMA2
	SUBB	0,0
;
	SBFLB=.		;REAL SUBTRACT TO BOTH
	SBCMB=.		;COMPLEX SUBTRACT TO BOTH
	FRRFC,,FROMA2
	FSBRB	0,0
;
	FRRFC,,FROMA2
	FSBRB	1,1
;
	MLFXB=.		;INTEGER MULTIPLY TO BOTH
	FRRFC,,FROMA2
	IMULB	0,0
;
	MLFLB=.		;REAL MULTIPLY TO BOTH
	FRRFC,,FROMA2
	FMPRB	0,0
;
;	(COMPLEX MULTIPLY TO BOTH NOT IMPLEMENTED)
;
	DVFXB=.	;INTEGER DIVIDE TO BOTH
	FRRFC,,FROMA2
	IDIVB	0,0
;
	DVFLB=.	;REAL DIVIDE TO BOTH
	FRRFC,,FROMA2
	FDVRB	0,0
;
;	(COMPLEX DIVIDE TO BOTH NOT IMPLEMENTED)
;
;
;
;FOR DOUBLE-PREC OPS ON KI10
;
	ADDPKI=.
	ADDPMI=.		;ADD TO MEMORY - DOUBLE-PREC
	FRRFC,,FROMA2
	DFAD	0,0
;
	FRRFC,,FROMA2
	DMOVEM	0,0
;
;
	SBDPKI=.		;SUB DOUBLE-PREC
	SBDPMI=.		; (TO MEMORY)
	FRRFC,,FROMA2
	DFSB	0,0
;
	FRRFC,,FROMA2
	DMOVEM	0,0
;
;
	MLDPKI=.		;MUL DOUBLE-PREC
	MLDPMI=.		; (TO MEMORY)
	FRRFC,,FROMA2
	DFMP	0,0
;
	FRRFC,,FROMA2
	DMOVEM	0,0
;
;
	DVDPKI=.		;DIV DOUBLE-PREC
	DVDPMI=.		; (TO MEMORY)
	FRRFC,,FROMA2
	DFDV	0,0
;
	FRRFC,,FROMA2
	DMOVEM	0,0
;
;
;FOR DOUBLE PRECISION OPS ON THE KA10
;
	ADDPKA=.
	FRPTN,,FROMA2
	MOVEI	16,0
;
	FRPTN,,RGIMFN
	PUSHJ	17,DPADTB
;
	SBDPKA=.
	FRPTN,,FROMA2
	MOVEI	16,0
;
	FRPTN,,RGIMFN
	PUSHJ	17,DPSBTB
;
	MLDPKA=.
	FRPTN,,FROMA2
	MOVEI	16,0
;
	FRPTN,,RGIMFN
	PUSHJ	17,DPMLTB
;
	DVDPKA=.
	FRPTN,,FROMA2
	MOVEI	16,0
;
	FRPTN,,RGIMFN
	PUSHJ	17,DPDVTB
;
;	DOUBLE PRECISION OPS PERFORMED TO MEMORY
	ADDPMA=.
	FRPTN,,FROMA2
	MOVEI	16,0
;
	FRPTN,,RGIMFN
	PUSHJ	17,DPADMT
;
	SBDPMA=.
	FRPTN,,FROMA2
	MOVEI	16,0
;
	FRPTN,,RGIMFN
	PUSHJ	17,DPSBMT
;
	MLDPMA=.
	FRPTN,,FROMA2
	MOVEI	16,0
;
	FRPTN,,RGIMFN
	PUSHJ	17,DPMLMT
;
	DVDPMA=.
	FRPTN,,FROMA2
	MOVEI	16,0
;
	FRPTN,,RGIMFN
	PUSHJ	17,DPDVMT
;

;
;SET UP TABLES OF IMPLICIT FUNCTION NAMES
; FOR EACH OPERATION HAVE A DIFFERENT FN CORRESPONDING
; TO EACH REGISTER BETWEEN 2 AND 14
;
;	COMPLEX MULTIPLY
CMMLTB:	SIXBIT "CFM.0"
	SIXBIT "CFM.1"
	SIXBIT "CFM.2"
	SIXBIT "CFM.3"
	SIXBIT "CFM.4"
	SIXBIT "CFM.5"
	SIXBIT "CFM.6"
	SIXBIT "CFM.7"
	SIXBIT "CFM.10"
	SIXBIT "CFM.11"
	SIXBIT "CFM.12"
	SIXBIT "CFM.13"
	SIXBIT "CFM.14"
;	COMPLEX DIVIDE
CMDVTB:	SIXBIT "CFD.0"
	SIXBIT "CFD.1"
	SIXBIT "CFD.2"
	SIXBIT "CFD.3"
	SIXBIT "CFD.4"
	SIXBIT "CFD.5"
	SIXBIT "CFD.6"
	SIXBIT "CFD.7"
	SIXBIT "CFD.10"
	SIXBIT "CFD.11"
	SIXBIT "CFD.12"
	SIXBIT "CFD.13"
	SIXBIT "CFD.14"
;	COMPLEX MULTIPLY TO MEMORY
CMMLMT:	SIXBIT "CMM.0"
	SIXBIT "CMM.1"
	SIXBIT "CMM.2"
	SIXBIT "CMM.3"
	SIXBIT "CMM.4"
	SIXBIT "CMM.5"
	SIXBIT "CMM.6"
	SIXBIT "CMM.7"
	SIXBIT "CMM.10"
	SIXBIT "CMM.11"
	SIXBIT "CMM.12"
	SIXBIT "CMM.13"
	SIXBIT "CMM.14"
;	COMPLEX DIVIDE TO MEMORY
CMDVMT:	SIXBIT "CDM.0"
	SIXBIT "CDM.1"
	SIXBIT "CDM.2"
	SIXBIT "CDM.3"
	SIXBIT "CDM.4"
	SIXBIT "CDM.5"
	SIXBIT "CDM.6"
	SIXBIT "CDM.7"
	SIXBIT "CDM.10"
	SIXBIT "CDM.11"
	SIXBIT "CDM.12"
	SIXBIT "CDM.13"
	SIXBIT "CDM.14"
;	DOUBLE-PREC ADD ON KA10
DPADTB:	SIXBIT "DFA.0"
	SIXBIT "DFA.1"
	SIXBIT "DFA.2"
	SIXBIT "DFA.3"
	SIXBIT "DFA.4"
	SIXBIT "DFA.5"
	SIXBIT "DFA.6"
	SIXBIT "DFA.7"
	SIXBIT "DFA.10"
	SIXBIT "DFA.11"
	SIXBIT "DFA.12"
	SIXBIT "DFA.13"
	SIXBIT "DFA.14"
;
;	DOUBLE-PREC SUB ON KA10
DPSBTB:	SIXBIT "DFS.0"
	SIXBIT "DFS.1"
	SIXBIT "DFS.2"
	SIXBIT "DFS.3"
	SIXBIT "DFS.4"
	SIXBIT "DFS.5"
	SIXBIT "DFS.6"
	SIXBIT "DFS.7"
	SIXBIT "DFS.10"
	SIXBIT "DFS.11"
	SIXBIT "DFS.12"
	SIXBIT "DFS.13"
	SIXBIT "DFS.14"
;
;	DOUBLE-PREC MUL ON KA10
DPMLTB:	SIXBIT "DFM.0"
	SIXBIT "DFM.1"
	SIXBIT "DFM.2"
	SIXBIT "DFM.3"
	SIXBIT "DFM.4"
	SIXBIT "DFM.5"
	SIXBIT "DFM.6"
	SIXBIT "DFM.7"
	SIXBIT "DFM.10"
	SIXBIT "DFM.11"
	SIXBIT "DFM.12"
	SIXBIT "DFM.13"
	SIXBIT "DFM.14"
;
;	DOUBLE-PREC DIV ON KA10
DPDVTB:	SIXBIT "DFD.0"
	SIXBIT "DFD.1"
	SIXBIT "DFD.2"
	SIXBIT "DFD.3"
	SIXBIT "DFD.4"
	SIXBIT "DFD.5"
	SIXBIT "DFD.6"
	SIXBIT "DFD.7"
	SIXBIT "DFD.10"
	SIXBIT "DFD.11"
	SIXBIT "DFD.12"
	SIXBIT "DFD.13"
	SIXBIT "DFD.14"
;
;	FOR DOUBLE-PREC OPS TO MEMORY
;
;	DOUBLE-PREC ADD TO MEMORY ON KA10
DPADMT:	SIXBIT "DAM.0"
	SIXBIT "DAM.1"
	SIXBIT "DAM.2"
	SIXBIT "DAM.3"
	SIXBIT "DAM.4"
	SIXBIT "DAM.5"
	SIXBIT "DAM.6"
	SIXBIT "DAM.7"
	SIXBIT "DAM.10"
	SIXBIT "DAM.11"
	SIXBIT "DAM.12"
	SIXBIT "DAM.13"
	SIXBIT "DAM.14"
;
;	DOUBLE-PREC SUB TO MEMORY FOR KA10
DPSBMT:	SIXBIT "DSM.0"
	SIXBIT "DSM.1"
	SIXBIT "DSM.2"
	SIXBIT "DSM.3"
	SIXBIT "DSM.4"
	SIXBIT "DSM.5"
	SIXBIT "DSM.6"
	SIXBIT "DSM.7"
	SIXBIT "DSM.10"
	SIXBIT "DSM.11"
	SIXBIT "DSM.12"
	SIXBIT "DSM.13"
	SIXBIT "DSM.14"
;
;	DOUBLE-PREC MUL TO MEMORY FOR KA10
DPMLMT:	SIXBIT "DMM.0"
	SIXBIT "DMM.1"
	SIXBIT "DMM.2"
	SIXBIT "DMM.3"
	SIXBIT "DMM.4"
	SIXBIT "DMM.5"
	SIXBIT "DMM.6"
	SIXBIT "DMM.7"
	SIXBIT "DMM.10"
	SIXBIT "DMM.11"
	SIXBIT "DMM.12"
	SIXBIT "DMM.13"
	SIXBIT "DMM.14"
;
;	DOUBLE-PREC DIV TO MEMORY FOR KA10
DPDVMT:	SIXBIT "DDM.0"
	SIXBIT "DDM.1"
	SIXBIT "DDM.2"
	SIXBIT "DDM.3"
	SIXBIT "DDM.4"
	SIXBIT "DDM.5"
	SIXBIT "DDM.6"
	SIXBIT "DDM.7"
	SIXBIT "DDM.10"
	SIXBIT "DDM.11"
	SIXBIT "DDM.12"
	SIXBIT "DDM.13"
	SIXBIT "DDM.14"


;
;DISPATCH TABLE FOR TYPE-CONVERSION OPERATIONS
;
;FOR KA10
OPGTCA:	IGN		;FROM LOGICAL,	TO INTEG
	IGN		;		TO REAL
	-1,,RLDP	;		TO DOUBLE-PREC
	-1,,RLCMP	;		TO COMPLEX
	IGN		;FROM CONTROL,	TO INTEG
	IGN		;		TO REAL
	-1,,RLDP	;		TO DOUBLE-PREC
	-1,,RLCMP	;		TO COMPLEX
	IGN		;FROM DOUBLE-OCTAL,	TO INTEG
	IGN		;			TO REAL
	IGN		;			TO DOUBLE-PREC
	IGN		;			TO COMPLEX
	IGN		;FROM LITERAL
	IGN
	IGN
	IGN
	IGN		;FROM INTEG,	TO INTEG
	-1,,INRLA	;		TO REAL
	-1,,INDP	;		TO DOUBLE-PREC
	-2,,INCMA	;		TO COMPLEX
	-1,,RLINA	;FROM REAL,	TO INTEGER
	IGN		;		TO REAL
	-1,,RLDP	;		TO DOUBLE PREC
	-1,,RLCMP	;		TO COMPLEX
	-1,,DPIN	;FROM DOUBLE-PREC,	TO INTEGER
	-1,,DPRL	;			TO REAL
	IGN		;			TO DOUBLE-PREC
	-1,,DPCMP	;			TO COMPLEX
	-2,,RLINA	;FROM COMPLEX,		TO INTEGER
	IGN		;			TO REAL
	-1,,CMPDP	;			TO DOUBLE-PREC
	IGN		;			TO COMPLEX
;
;
;FOR KI10
OPGTCI:	IGN		;FROM LOGICAL,	TO INTEG
	IGN		;		TO REAL
	-1,,RLDP	;		TO DOUBLE-PREC
	-1,,RLCMP	;		TO COMPLEX
	IGN		;FROM CONTROL,	TO INTEG
	IGN		;		TO REAL
	-1,,RLDP	;		TO DOUBLE-PREC
	-1,,RLCMP	;		TO COMPLEX
	IGN		;FROM DOUBLE-OCTAL,	TO INTEG
	IGN		;			TO REAL
	IGN		;			TO DOUBLE-PREC
	IGN		;			TO COMPLEX
	IGN		;FROM LITERAL
	IGN
	IGN
	IGN
	IGN		;FROM INTEG,	TO INTEG
	-1,,INRLI	;		TO REAL
	-1,,INDP	;		TO DOUBLE-PREC
	-2,,INCMI	;		TO COMPLEX
	-1,,RLINI	;FROM REAL,	TO INTEGER
	IGN		;		TO REAL
	-1,,RLDP	;		TO DOUBLE PREC
	-1,,RLCMP	;		TO COMPLEX
	-1,,DPIN	;FROM DOUBLE-PREC,	TO INTEGER
	-1,,DPRLI	;			TO REAL
	IGN		;			TO DOUBLE-PREC
	-1,,DPCMP	;			TO COMPLEX
	-1,,RLINI	;FROM COMPLEX,		TO INTEGER
	IGN		;			TO REAL
	-1,,CMPDP	;			TO DOUBLE-PREC
	IGN		;			TO COMPLEX
;
;CODE GENERATORS FOR TYPE CONVERSIONS
;
;FOR KA10
	INRLA=.		;INTEGER TO REAL (USE NEXT 1 INSTRS)
	INCMA=.		;INTEGER TO COMPLEX (USE NEXT 2 INSTRS)
	FRPTN,,RGIMFN
	PUSHJ	17,FLOATT
;
	FRRFC,,FRPTN
	SETZ	1,0
;
;
;
;
	INDP=.		;INTEGER TO DOUBLE-PREC
	FRPTN,,RGIMFN
	PUSHJ	17,DFLTT
;
;
	RLINA=.		;REAL TO INTEGER
	FRPTN,,RGIMFN
	PUSHJ	17,IFIXT
;
;
	RLCMP=.		;REAL TO COMPLEX
	RLDP=.		;REAL TO DOUBLE-PREC
	CMPDP=.		;COMPLEX TO DOUBLE PREC (ACROSS ASSIGNMENT)
	DPCMP=.		;DOUBLE PREC TO COMPLEX (ACROSS ASSIGNMENT)
	FRRFC,,FRPTN
	MOVEI	1,0
;
	DPIN=.		;FROM DOUBLE-PREC TO INTEGER
	FRPTN,,RGIMFN
	PUSHJ	17,IDFIXT
;
;
	DPRL=.		;FROM DOUBLE-PREC TO REAL ON KA10 (USE NEXT 1 INSTR)
	FRRFC,,FRRFC
	FADR	0,1
;
;
	DPRLI=.		;FROM DOUBLE PREC TO REAL ON KI10 (USE NEXT 1 INSTR)
	FRPTN,,RGIMFN
	PUSHJ	17,SNGLT
;
;
	INRLI=.		;FROM INTEGER TO REAL ON KI10 (NEXT 1 INSTR)
	INCMI=.		;FROM INTEGER TO COMPLEX ON KI10 (NEXT 2 INSTRS)
	FRRFC,,FRRFC
	FLTR	0,0
;
	FRRFC,,FRPTN
	SETZ	1,0
;
;
	RLINI=.		;FROM REAL TO INTEGER ON KI10
	FRRFC,,FRRFC
	FIX	0,0
;
;
;
;SET UP SIXBIT FN NAMES FOR THE LIBRARY FNS USED FOR TYPE-CONVERSIONS - 
; THE OUTPUT MODULE EXPECTS
; TO BE GIVEN A PTR TO THE SIXBIT FOR A FUNCTION NAME
FLOATT:	SIXBIT	"FLT.0"
	SIXBIT	"FLT.1"
	SIXBIT	"FLT.2"
	SIXBIT	"FLT.3"
	SIXBIT	"FLT.4"
	SIXBIT	"FLT.5"
	SIXBIT	"FLT.6"
	SIXBIT	"FLT.7"
	SIXBIT	"FLT.10"
	SIXBIT	"FLT.11"
	SIXBIT	"FLT.12"
	SIXBIT	"FLT.13"
	SIXBIT	"FLT.14"
;
DFLTT:	SIXBIT	"DFL.0"
	SIXBIT	"DFL.1"
	SIXBIT	"DFL.2"
	SIXBIT	"DFL.3"
	SIXBIT	"DFL.4"
	SIXBIT	"DFL.5"
	SIXBIT	"DFL.6"
	SIXBIT	"DFL.7"
	SIXBIT	"DFL.10"
	SIXBIT	"DFL.11"
	SIXBIT	"DFL.12"
	SIXBIT	"DFL.13"
	SIXBIT	"DFL.14"
;
IFIXT:	SIXBIT	"IFX.0"
	SIXBIT	"IFX.1"
	SIXBIT	"IFX.2"
	SIXBIT	"IFX.3"
	SIXBIT	"IFX.4"
	SIXBIT	"IFX.5"
	SIXBIT	"IFX.6"
	SIXBIT	"IFX.7"
	SIXBIT	"IFX.10"
	SIXBIT	"IFX.11"
	SIXBIT	"IFX.12"
	SIXBIT	"IFX.13"
	SIXBIT	"IFX.14"
;
IDFIXT:	SIXBIT	"IDF.0"
	SIXBIT	"IDF.1"
	SIXBIT	"IDF.2"
	SIXBIT	"IDF.3"
	SIXBIT	"IDF.4"
	SIXBIT	"IDF.5"
	SIXBIT	"IDF.6"
	SIXBIT	"IDF.7"
	SIXBIT	"IDF.10"
	SIXBIT	"IDF.11"
	SIXBIT	"IDF.12"
	SIXBIT	"IDF.13"
	SIXBIT	"IDF.14"
SNGLT:	SIXBIT	"SNG.0"
	SIXBIT	"SNG.1"
	SIXBIT	"SNG.2"
	SIXBIT	"SNG.3"
	SIXBIT	"SNG.4"
	SIXBIT	"SNG.5"
	SIXBIT	"SNG.6"
	SIXBIT	"SNG.7"
	SIXBIT	"SNG.10"
	SIXBIT	"SNG.11"
	SIXBIT	"SNG.12"
	SIXBIT	"SNG.13"
	SIXBIT	"SNG.14"

;
;DISPATCH TABLE FOR STORE VALUE
;
;FOR KA10
OPGSTA:	-1,,ST
	-2,,ST2A		;DBL WD
;
;FOR KI10
OPGSTI:	-1,,ST
	-1,,ST2I
;
;CODE GENERATORS TO STORE A VAL
	ST=.
	ST2A=.
	FRRFC,,FROMPA
	MOVEM	0,0
;
	FRRFC,,FROMPA
	MOVEM	1,1
;
;
	ST2I=.
	FRRFC,,FROMPA
	DMOVEM	0,0
;
;
;
;
;DISPATCH TABLE FOR "ASSIGNMENT STMNT STORE VALUE"
;
;FOR KA10
;
;	WHEN NEITHER NEG NOR NOT
OPGASA:	-1,,ST
	-1,,ST
	-2,,ST2A
	-2,,ST2A
;	WHEN NEG
	-1,,STNG
	-1,,STNG
	-3,,STNG2A		;STORE NEG OF DOUBLE-PREC
	-2,,STNCPX	;NEG OF COMPLEX
;	WHEN NOT
	-1,,STNT
	-1,,STNT
	-2,,STNT2		;STORE NOT OF DOUBLE-PREC
	-2,,STNT2
;
;FOR KI10
OPGASI:	-1,,ST
	-1,,ST
	-1,,ST2I
	-1,,ST2I
;	FOR NEG OF ARG
	-1,,STNG
	-1,,STNG
	-1,,STNG2I		;STORE NEG OF DOUBLE-PREC
	-2,,STNCPX		; NEG OF COMPLEX
;	FOR NOT OF ARG
	-1,,STNT
	-1,,STNT
	-2,,STNT2
	-2,,STNT2
; 
;WHEN STORING THE RIGHT HALF OF A REGCONTENTS WHICH WAS USED AS AN AOBJN WD
OPGASR:	-1,,STAOBJ
;
;
;CODE GENERATORS TO STORE NEG OR NOT OF A VALUE
	STNG=.
	STNCPX=.		;STORE NEG OF COMPLEX (NEXT 2 INSTRS)
	FRRFC,,FROMPA
	MOVNM	0,0
;
	FRRFC,,FROMPA
	MOVNM	1,1
;
	STNT=.			;STORE NOT OF ARG
	FRRFC,,FROMPA
	SETCAM	0,0
;
	STNG2A=.		;STORE NEG OF ARG - DOUBLE-PREC, KA10
	FRRFC,,FRRFC
	DFN	0,1
;
	FRRFC,,FROMPA
	MOVEM	0,0
;
	FRRFC,,FROMPA
	MOVEM	1,1
;
;
	STNG2I=.		;STORE NEG OF ARG - DOUBLE-PREC KI10
	FRRFC,,FROMPA
	DMOVNM	0,0
;
	STNT2=.			;STORE NOT OF DOUBLE-WD ARG
	FRRFC,,FROMPA
	SETCAM	0,0
;
	FRRFC,,FROMPA
	SETCAM	1,1
;
;
;CODE GENERATOR FOR THE SPECIAL CASE OF STORING THE RIGHT HALF OF AN AOBJN WD
; (WHICH CONTAINS A LOOP INDEX)
STAOBJ:	FRRFC,,FROMPA
	HRRZM	0,0


;
;FOR ASSIGN STATEMENT
;
OPASIN:	-2,,ASSIGN
;
	ASSIGN=.		;ALWAYS USE REG 1
	FRPTN,,A1LAB
	MOVEI	1,0
;
	FRPTN,,FROMA1
	MOVEM	1,0
;

;
;DISPATCH TABLE FOR BOOLEAN OPERATIONS
;
;	COMPUTED IN A REG
OPGBOO:	-1,,ANDRG
	-1,,ORRG
	-1,,EQVRG
	-1,,XORRG
;	COMPUTED TO MEMORY
	-1,,ANDMEM
	-1,,ORMEM
	-1,,EQVMEM
	-1,,XORMEM
;	COMPUTED IMMEDIATE
	-1,,ANDIMM
	-1,,ORIMM
	-1,,EQVIMM
	-1,,XORIMM
;	OPERATIONS TO BOTH REG AND MEMORY
	-1,,ANDBO
	-1,,ORBO
	-1,,EQVBO
	-1,,XORBO
;	OPERATIONS INCLUDING NOT OF 2ND ARG
	-1,,ANDNOT
	-1,,ORNOT
	-1,,XORRG		;EQV WITH NOT X IS SAME AS XOR X
	-1,,EQVRG		;XOR WITH NOT X = EQV WITH X
;	OPERATIONS TO MEMORY INCLUDING NOT OF 2ND ARG
	-1,,ANDNTM
	-1,,ORNTM
	-1,,XORMEM
	-1,,EQVMEM
;	COMPUTED IMMEDIATE WITH NOT OF THE 2ND ARG
	-1,,ANDNTI
	-1,,ORNTI
	-1,,XORIMM	;XOR WITH NOT OF ARG IS SAME AS EQV WITH ARG
	-1,,EQVIMM
;	OPERATIONS TO "BOTH" WITH NOT OF 2ND ARG
	-1,,ANDNTB
	-1,,ORNTB
	-1,,XORBO	;EQV WITH NOT IS SAME AS XOR
	-1,,EQVBO	;XOR WITH NOT IS SAME AS EQV
;
;
;
;DEFINE CODE GENERATORS FOR BOOLEAN OPS
;
	ANDRG=.
	FRRFC,,FROMA2
	AND	0,0
;
	ORRG=.
	FRRFC,,FROMA2
	IOR	0,0
;
	EQVRG=.
	FRRFC,,FROMA2
	EQV	0,0
;
	XORRG=.
	FRRFC,,FROMA2
	XOR	0,0
;
	ANDMEM=.
	FRRFC,,FROMA2
	ANDM	0,0
;
	ORMEM=.
	FRRFC,,FROMA2
	IORM	0,0
;
	EQVMEM=.
	FRRFC,,FROMA2
	EQVM	0,0
;
	XORMEM=.
	FRRFC,,FROMA2
	XORM	0,0
;
	ANDBO=.		;AND TO BOTH
	FRRFC,,FROMA2
	ANDB	0,0
;
	ORBO=.		;OR TO BOTH
	FRRFC,,FROMA2
	IORB	0,0
;
	EQVBO=.		;EQV TO BOTH
	FRRFC,,FROMA2
	EQVB	0,0
;
	XORBO=.
	FRRFC,,FROMA2
	XORB	0,0
;
	ANDIMM=.
	FRRFC,,A2CNST
	ANDI	0,0
;
	ORIMM=.
	FRRFC,,A2CNST
	IORI	0,0
;
	EQVIMM=.
	FRRFC,,A2CNST
	EQVI	0,0
;
	XORIMM=.
	FRRFC,,A2CNST
	XORI	0,0
;
	ANDNOT=.
	FRRFC,,FROMA2
	ANDCM	0,0
;
	ORNOT=.
	FRRFC,,FROMA2
	ORCM	0,0
;
	ANDNTM=.
	FRRFC,,FROMA2
	ANDCMM	0,0
;
	ORNTM=.
	FRRFC,,FROMA2
	ORCMM	0,0
;
	ANDNTI=.	;AND WITH NOT OF AN IMMED
	FRRFC,,A2CNST
	ANDCMI	0,0
;
	ORNTI=.		;OR WITH NOT OF AN IMMED
	FRRFC,,A2CNST
	ORCMI	0,0
;
	ANDNTB=.	;AND WITH NOT OF ARG TO BOTH
	FRRFC,,FROMA2
	ANDCMB	0,0
;
	ORNTB=.		;OR WITH NOT OF ARG TO BOTH
	FRRFC,,FROMA2
	ORCMB	0,0

;
;DISPATCH TABLE FOR RELATIONALS
;
;	WHERE ARGS ARE SINGLE-WD - AND ARG2 NOT IMMED
OPGREL:	ILG		;MODE 0 ILLEGAL
	-1,,CMSPL
	-1,,CMSPE
	-1,,CMSPLE
	ILG		;MODE 4 IS ILLEGAL
	-1,,CMSPGE
	-1,,CMSPN
	-1,,CMSPG
;	FOR ARG2 IMMED
	ILG		;MODE 0 IS ILLEGAL
	-1,,CMIML
	-1,,CMIME
	-1,,CMIMLE
	ILG		;MODE 4 IS ILLEGAL
	-1,,CMIMGE
	-1,,CMIMN
	-1,,CMIMG
;	FOR ARGS DOUBLE-WD
	ILG		;MODE 0 IS ILLEGAL
	-3,,CMDPL
	-2,,CMDPE
	-3,,CMDPLE
	ILG		;MODE 4 IS ILLEGAL
	-3,,CMDPGE
	-3,,CMDPN
	-3,,CMDPG
;	ARG2 IMMED AND DOUBLE-WD BOTH
	ILG	;MODE 0 IS ILLEGAL
	-3,,CDPIL
	-2,,CDPIE
	-3,,CDPILE
	ILG	;MODE 4 IS ILLEGAL
	-3,,CDPIGE
	-3,,CDPIN
	-3,,CDPIG
;
;
;CODE GENERATORS FOR RELATIONALS
;
;	TO COMPARE SINGLE-WD ARGS
	CMSPL=.
	FRRFC,,FROMA2
	CAML	0,0
;
	CMSPE=.
	FRRFC,,FROMA2
	CAME	0,0
;
	CMSPLE=.
	FRRFC,,FROMA2
	CAMLE	0,0
;
	CMSPGE=.
	FRRFC,,FROMA2
	CAMGE	0,0
;
	CMSPN=.
	FRRFC,,FROMA2
	CAMN	0,0
;
	CMSPG=.
	FRRFC,,FROMA2
	CAMG	0,0
;
;	TO COMPARE WITH AN IMMED CNST SPECIFIED BY ARG2
	CMIML=.
	FRRFC,,A2CNST
	CAIL	0,0
;
	CMIME=.
	FRRFC,,A2CNST
	CAIE	0,0
;
	CMIMLE=.
	FRRFC,,A2CNST
	CAILE	0,0
;
	CMIMGE=.
	FRRFC,,A2CNST
	CAIGE	0,0
;
	CMIMN=.
	FRRFC,,A2CNST
	CAIN	0,0
;
	CMIMG=.
	FRRFC,,A2CNST
	CAIG	0,0
;
;	TO COMPARE DOUBLE-WD ARGS
	CMDPL=.
	FRRFC,,FROMA2
	CAMN	0,0
;
	FRRFC,,FROMA2
	CAMGE	1,1
;
	FRRFC,,FROMA2
	CAMLE	0,0
;
	CMDPE=.
	FRRFC,,FROMA2
	CAMN	0,0
;
	FRRFC,,FROMA2
	CAME	1,1
;
	CMDPLE=.
	FRRFC,,FROMA2
	CAMN	0,0
;
	FRRFC,,FROMA2
	CAMG	1,1
;
	FRRFC,,FROMA2
	CAMLE	0,0
;
	CMDPGE=.
	FRRFC,,FROMA2
	CAMN	0,0
;
	FRRFC,,FROMA2
	CAML	1,1
;
	FRRFC,,FROMA2
	CAMGE	0,0
;
	CMDPN=.
	FRRFC,,FROMA2
	CAMN	0,0
;
	FRRFC,,FROMA2
	CAME	1,1
;
	FRPTN,,FRPTN
	SKIPA
;
	CMDPG=.
	FRRFC,,FROMA2
	CAMN	0,0
;
	FRRFC,,FROMA2
	CAMLE	1,1
;
	FRRFC,,FROMA2
	CAMGE	0,0
;
;
;	TO COMPARE DOUBLE-WD IMMED - THIS IS USED ONLY FOR THE CASE
;   	  OF A COMPLEX BEING COMPARED TO 0 , BUT ITS EASIER TO HAVE THE ENTRIES
;		IN THE TABLE THAN TO DIFFERENTIATE COMPLEX-IMMED FROM 
;		REAL-IMMED
	CDPIL=.
	FRRFC,,A2CNST
	CAIN	0,0
;
	FRRFC,,FRPTN
	CAIGE	1,0
;
	FRRFC,,A2CNST
	CAILE	0,0
;
	CDPIE=.
	FRRFC,,A2CNST
	CAIN	0,0
;
	FRRFC,,FRPTN
	CAIE	1,0
;
	CDPILE=.
	FRRFC,,A2CNST
	CAIN	0,0
;
	FRRFC,,FRPTN
	CAIG	1,0
;
	FRRFC,,A2CNST
	CAILE	0,0
;
	CDPIGE=.
	FRRFC,,A2CNST
	CAIN	0,0
;
	FRRFC,,FRPTN
	CAIL	1,0
;
	FRRFC,,A2CNST
	CAIGE	0,0
;
	CDPIN=.
	FRRFC,,A2CNST
	CAIN	0,0
;
	FRRFC,,FRPTN
	CAIE	1,0
;
	FRPTN,,FRPTN
	SKIPA
;
	CDPIG=.
	FRRFC,,A2CNST
	CAIN	0,0
;
	FRRFC,,FRPTN
	CAILE	1,0
;
	FRRFC,,A2CNST
	CAIGE	0,0
;



;
;DISPATCH TABLE FOR NEGNOT NODES
; HAVE 2 TABLES - ONE FOR THE CASE WHERE THE VAL HAS BEEN FETCHED
; INTO THE RFC BY GETA2OPIX, THE OTHER FOR THE CASE WHERE IT HAS NOT
;
;NOTE THAT MANY OF THE CODE GENERATORS REFERRED TO ARE ALSO USED FOR
; THE 'OPGETA'/'OPGETI' ENTRIES AND MAY BE FOUND IN THAT PART OF THE
; LISTING (APPROX LOCS 160-205)
; ALSO, SOME OF THE CODE GENERATORS FOR OPS 'TO MEMORY' ARE ALSO
; USED FOR THE 'OPGASA'/'OPGASI' ENTRIES AND MAY BE FOUND WITH THEM
; (APPROX LOCS 1244-1263)
;
;IF VAL IS ALREADY IN RFC
; KA10
OPGN1A:	-1,,GANGSM		;NEG OF INTEGER/REAL
	-1,,GANGSM
	-1,,GNGS2A		; DOUBLE-PREC
	-2,,GNGSCM		; COMPLEX
;
	-1,,GANTSM		;NOT OF INTEGER
	-1,,GANTSM		; REAL
	-2,,GNTS2		; DOUBLE-PREC
	-2,,GNTS2		; COMPLEX
;
;		TO MEMORY
	-1,,STNG		;NEG OF INTEGER
	-1,,STNG		; REAL
	-3,,STNG2A		; DOUBLE-PREC
	-2,,STNCPX		; COMPLEX
;
	-1,,STNT		;NOT OF INTEGER
	-1,,STNT		; REAL
	-2,,STNT2		; DOUBLE-PREC
	-2,,STNT2		; COMPLEX
;
; KI10
OPGN1I:	-1,,GANGSM		;NEG OF INTEGER
	-1,,GANGSM		; REAL
	-1,,GNGS2I		; DOUBLE-PREC
	-2,,GNGSCM		; COMPLEX
;
	-1,,GANTSM		;NOT OF INTEGER
	-1,,GANTSM		; REAL
	-2,,GNTS2		; DOUBLE-PREC
	-2,,GNTS2		; COMPLEX
;
;		TO MEMORY
	-1,,STNG		;NEG OF INTEGER
	-1,,STNG		; REAL
	-3,,STNG2I		; DOUBLE-PREC
	-2,,STNCPX		; COMPLEX
;
	-1,,STNT		;NOT OF INTEGER
	-1,,STNT		; REAL
	-2,,STNT2		; DOUBLE-PREC
	-2,,STNT2		; COMPLEX
;
;
;WHEN THE ARG IS NOT YET IN RFC
; KA10
OPGN2A:	-1,,GANG		;NEG OF INTEGER
	-1,,GANG		; REAL
	-3,,GANG2A		; DOUBLE-PREC
	-2,,GNGCM		; COMPLEX
;
	-1,,GANT		;NOT OF INTEGER
	-1,,GANT		; REAL
	-2,,GANT2		; DOUBLE-PREC
	-2,,GANT2		; COMPLEX
;
;	 TO MEMORY
	-1,,NEGM		;NEG OF INTEGER
	-1,,NEGM		; REAL
	-5,,NEG2AM		; DOUBLE-PREC
	-2,,NEGCMM		; COMPLEX
;
	-1,,NOTM		;NOT OF INTEGER
	-1,,NOTM		; REAL
	-2,,NOT2M		; DOUBLE-PREC
	-2,,NOT2M		; COMPLEX
;
;	 IMMEDIATE
	-1,,GNGIMI		;NEG OF INTEGER
	-1,,GNGIMR		;REAL
	ILG			;DOUBLE-PREC (ILLEGAL)
	-2,,GNGIM2		;COMPLEX
;
	-1,,GNTIMI		;NOT OF IMMED CNST INTEGER
	ILG			; REAL
	ILG			; DOUBLE-PREC
	ILG			; COMPLEX
;
;
; KI10
OPGN2I:	-1,,GANG		;NEG OF INTEGER
	-1,,GANG		; REAL
	-1,,GANG2I		; DOUBLE-PREC
	-2,,GNGCM		; COMPLEX
;
	-1,,GANT		;NOT OF INTEGER
	-1,,GANT		; REAL
	-2,,GANT2		; DOUBLE-PREC
	-2,,GANT2		; COMPLEX
;
;	 TO MEMORY
	-1,,NEGM		;NEG OF INTEGER
	-1,,NEGM		; REAL
	-2,,NEG2IM		; DOUBLE-PREC
	-2,,NEGCMM		; COMPLEX
;
	-1,,NOTM		;NOT OF INTEGER
	-1,,NOTM		; REAL
	-2,,NOT2M		; DOUBLE-PREC
	-2,,NOT2M		; COMPLEX
;
;	 IMMEDIATE
	-1,,GNGIMI		;NEG OF INTEGER
	-1,,GNGIMR		;REAL
	ILG			;DOUBLE-PREC (ILLEGAL)
	-2,,GNGIM2		;COMPLEX
;
	-1,,GNTIMI		;NOT OF IMMED CNST INTEGER
	ILG			; REAL
	ILG			; DOUBLE-PREC
	ILG			; COMPLEX
;
;
;
;NOTE THAT MOST OF THE CODE GENERATORS REFERENCED ABOVE  ARE EITHER WITH
; "OPGETA"/"OPGETI" OR WITH  "OPGASA"/"OPGASI"
;THE FOLLOWING CODE GENERATORS ARE FOR NEG/NOT PERFORMED FROM MEMORY TO 
; MEMORY
;
	NEGM=.			;NEG OF INTEGER/REAL
	NEGCMM=.		;NEG OF COMPLEX (NEXT 2 INSTRS)
	FRPTN,,FROMA2
	MOVNS	0,0
;
	FRPTN,,FROMA2
	MOVNS	0,1
;
	NEG2AM=.		;NEG OF DOUBLE-PREC - KA10
	FRRFC,,FROMA2
	MOVE	0,0
;
	FRRFC,,FROMA2
	MOVE	1,1
;
	FRRFC,,FRRFC
	DFN	0,1
;
	FRRFC,,FROMA2
	MOVEM	0,0
;
	FRRFC,,FROMA2
	MOVEM	1,1
;
	NEG2IM=.		;NEG OF DOUBLE-PREC (KI10
	FRRFC,,FROMA2
	DMOVN	0,0
;
	FRRFC,,FROMA2
	DMOVEM	0,0
;
;
	NOTM=.			;NOT OF INTEGER/REAL
	NOT2M=.			;NOT OF DOUBLE-PREC/COMPLEX (NEXT 2 INSTRS)
	FRPTN,,FROMA2
	SETCMM	0,0
;
	FRPTN,,FROMA2
	SETCMM	0,1
;

;
;DISPATCH TABLE FOR COMPUTATION OF P2MUL,P2DIV  AND P2PL1MUL
;
;FOR KA10
	;MULTIPLY BY POWER OF 2
OPGSPA:	-1,,P2MFX
	-1,,P2MFL
	-3,,P2MDPA
	-2,,P2MCM
	; WHEN ARG WAS NEGATED
	-1,,P2MFX
	-1,,P2MFL
	-3,,P2MDPA
	-2,,P2MCM
	;DIVIDE BY  POWER OF 2
	-3,,P2DFX
	-1,,P2DFL
	-3,,P2DDPA
	-2,,P2DCM
	; WHEN ARG WAS NEGATED
	-3,,P2DFX
	-1,,P2DFL
	-3,,P2DDPA
	-2,,P2DCM
	;FOR MULTIPLY BY POWER OF 2 PLUS 1
	-2,,P21FX
	-2,,P21FL
	-5,,P21DPA
	-4,,P21CM
	; WHEN ARG WAS NEGATED
	-2,,P21NFX
	-2,,P21NFL
	-5,,P21NDA
	-4,,P21NCM
;FOR KI10
	;MULTIPLY BY POWER OF 2
OPGSPI:	-1,,P2MFX
	-1,,P2MFL
	-2,,P2MDPI
	-2,,P2MCM
	; WHEN ARG WAS NEGATED
	-1,,P2MFX
	-1,,P2MFL
	-2,,P2MDPI
	-2,,P2MCM
	;DIVIDE BY A POWER OF 2
	-3,,P2DFX
	-1,,P2DFL
	-2,,P2DDPI
	-2,,P2DCM
	; WHEN ARG WAS NEGATED
	-3,,P2DFX
	-1,,P2DFL
	-2,,P2DDPI
	-2,,P2DCM
	;FOR MULTIPLY BY POWER OF 2 PLUS 1
	-2,,P21FX
	-2,,P21FL
	-3,,P21DPI
	-4,,P21CM
	; WHEN ARG WAS NEGATED
	-2,,P21NFX
	-2,,P21NFL
	-3,,P21NDI
	-4,,P21NCM
;
;DISPATCH TABLE FOR MULT BY A POWER OF 2 PLUS 1  WHEN "A1IMMEDFLG" WAS
; SET (THIS IS THE ONLY OPERATOR FOR WHICH IMMEDFLG IS SIGNIFICANT)
OPP21I:	-2,,P21IFX	;IMMED, FIXED POINT
	-2,,P21IFL	;IMMED, FLOATING POINT
	ILG		;IMMED DOUBLE-PREC SHOULD NEVER OCCUR
	ILG		;IMMED COMPLEX SHOULD NEVER OCCUR
;	  (P2PL1MUL NEGATED)
	-2,,P21INX	;IMMED,NEGATED,FIXED PT
	-2,,P21INL	;IMMED,NEGATED,FLOATING PT
	ILG		;IMMED, DOUBLE-PREC IS ILLEGAL
	ILG		;IMMED, COMPLEX IS ILLEGAL
;
;
;
;DISPATCH TABLE FOR SPECIAL OPS DONE TO MEMORY.
;
;	P2MUL SHOULD NEVER BE DONE TO MEMORY
OPGSPM:	ILG
	ILG
	ILG
	ILG
;	(P2MUL NEGATED - SHOULD NEVER BE DONE TO MEMORY)
	ILG
	ILG
	ILG
	ILG
;	P2DIV SHOULD NEVER BE DONE TO MEMORY
	ILG
	ILG
	ILG
	ILG
;	(P2DIV NEGATED)
	ILG
	ILG
	ILG
	ILG
;	MULTIPLY BY A POWER OF 2 PLUS ONE
	-2,,P21MFX
	-2,,P21MFL
	ILG		;DOUBLE PREC OPS ARE NEVER DONE TO MEMORY
	-4,,P21MCM
;	MULTIPLY THE NEG OF A NUMBER BY A POWER OF TWO PLUS ONE
	-2,,P21MNX
	-2,,P21MNL
	ILG		;DOUBLE PREC OPS ARE NEVER DONE TO MEMORY
	-4,,P21MNC
;
;
;
;
;CODE GENERATORS FOR MULTIPLICATION BY A POWER OF 2
;
	P2MFX=.			;FIXED POINT MULTIPLY BY A POWER OF 2
	P21FX=.			;FIXED POINT MULTIPLY BY A POWER OF 2
				; PLUS 1 (USE NEXT 2 INSTRS)
	FRRFC,,PTRA2
	ASH	0,0
;
	FRRFC,,FROMA1
	ADD	0,0
;
;
;
	P21NFX=.		;FIXED PT MULTIPLY BY POWER OF 2 PLUS
				; 1 WHEN ARG WAS NEGATED
	FRRFC,,PTRA2
	ASH	0,0
;
	FRRFC,,FROMA1
	SUB	0,0
;
;
;
	P2MFL=.			;FLOATING MULTIPLY BY A POWER OF 2
				; (USE THE 1 NEXT INSTR)
	P21FL=.			;FLOATING POINT MULTIPLY BY A POWER OF 2
				; PLUS 1 (USE NEXT 2 INSTRS)
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,FROMA1
	FADR	0,0
;
;
	P21NFL=.		;FLOATING PT MULTIPLY BY POWER OF 2 PLUS
				; ONE WHEN ARG WAS NEGATED
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,FROMA1
	FSBR	0,0
;
;
;
	P2MDPA=.		;DOUBLE-PREC MULT BY POWER OF 2 FOR KA10
				; (USE NEXT 3 INSTRS)
	P21DPA=.		;DOUBLE-PREC MULT BY POWER OF 2 PLUS 1
				; FOR KA10 (USE NEXT 5 INSTRS)
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,PTRA2
	FSC	1,0
;
	FRRFC,,FRRFC
	FADL	0,1
;
	FRPTN,,FROMA1		;(TO ADD ARG1 TO THE QUANTITY ARG1*2**N)
	MOVEI	16,0
;
	FRPTN,,RGIMFN
	PUSHJ	17,DPADTB
;
;
	P21NDA=.		;DOUBLE-PREC MULT BY POWER OF 2 PLUS ONE
				; FOR KA10 WHEN THE ARG WAS NEGATED
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,PTRA2
	FSC	1,0
;
	FRRFC,,FRRFC
	FADL	0,1
;
	FRPTN,,FROMA1		;(TO ADD ARG1 TO THE QUANTITY ARG1*2**N)
	MOVEI	16,0
;
	FRPTN,,RGIMFN
	PUSHJ	17,DPSBTB
;
;
	P2MCM=.			;MULTIPLY A COMPLEX BY POWER OF 2
				; (USE NEXT 2 INSTRS)
	P21CM=.			;MULTIPLY A COMPLEX BY A POWER OF 2 PLUS
				; 1 (USE NEXT 4 INSTRS)
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,PTRA2
	FSC	1,0
;
	FRRFC,,FROMA1
	FADR	0,0
;
	FRRFC,,FROMA1
	FADR	1,1
;
;
	P21NCM=.		;COMPLEX MULTIPLIED BY POWER OF 2 PLUS 1
				; WHEN ARG WAS NEGATED
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,PTRA2
	FSC	1,0
;
	FRRFC,,FROMA1
	FSBR	0,0
;
	FRRFC,,FROMA1
	FSBR	1,1
;
;
	P2DFX=.			;FIXED PT DIVIDE BY A POWER OF 2
				; (USE NEXT 3 INSTRS)
	FRPTN,,FRRFC
	SKIPGE	0
;
	FRRFC,,P2PTR2
	ADDI	0,0
;
	FRRFC,,NGPTR2
	ASH	0
;
;
	P2DFL=.			;FLOATING PT DIVIDE BY A POWER OF 2
	P2DDPI=.		;DOUBLE-PREC DIVIDE BY A POWER OF 2
				; ON THE KI10
	FRRFC,,NGPTR2
	FSC	0,0
;
	FRPTN,,FRPTN
	JFCL	(5)
;
;
	P2DDPA=.		;DOUBLE-PREC DIVIDE ON THE KA10 (USE
				; THE NEXT 3 INSTRS)
	P2DCM=.			;COMPLEX DIVIDE  BY A POWER OF 2 
				; (USE THE NEXT 2 INSTRS)
	FRRFC,,NGPTR2
	FSC	0,0
;
	FRRFC,,NGPTR2
	FSC	1,0
;
	FRRFC,,FRRFC
	FADL	0,1
;
;
	P2MDPI=.		;DOUBLE-PREC MULTIPLY BY A POWER OF 2 FOR
				; THE KI10 (USE THE 2 NEXT INSTR)
	P21DPI=.		;DOUBLE-PREC MULTIPLY BY A POWER OF 2 PLUS 
				; 1 FOR KI10 (USE NEXT 3 INSTRS)
	FRRFC,,PTRA2
	FSC	0,0
;
	FRPTN,,FRPTN
	JFCL	(5)
;
	FRRFC,,FROMA1
	DFAD	0,0
;
;
	P21NDI=.		;DOUBLE-PREC MULTP BY POWER OF 2 PLUS 1
				; ON KI10 WHEN ARG WAS NEGATED
	FRRFC,,PTRA2
	FSC	0,0
;
	FRPTN,,FRPTN
	JFCL	(5)
;
	FRRFC,,FROMA1
	DFSB	0,0
;
;
;
;CODE GENERATORS FOR MULTIPLY OF AN IMMED MODE ITEM BY A POWER OF 2 PLUS 1
;
	P21IFX=.	;FIXED PT IMMED CNST MULTIPLIED BY A POWER OF
			; 2 PLUS 1
	FRRFC,,PTRA2
	ASH	0,0
;
	FRRFC,,A1CNST
	ADDI	0,0
;
;
	P21IFL=.	;FLOATING PT IMMED MULTIPLIED BY POWER OF 2 PLUS 1
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,A1CNST
	FADRI	0,0
;
;
	P21INX=.	;FIXED PT IMMED, NEGATED AND MULTIPLIED
	FRRFC,,PTRA2
	ASH	0,0
;
	FRRFC,,A1CNST
	SUBI	0,0
;
;
	P21INL=.	;FLOATING PT IMMED NEGATED AND MULTIPLIED
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,A1CNST
	FSBRI	0,0
;
;
;
;CODE GENERATORS FOR MULT BY A POWER OF 2 PLUS 1 DONE TO MEMORY
;
	P21MFX=.	;MULTIPLY FIXED PT BY A POWER OF 2 PLUS 1 TO MEMORY
	FRRFC,,PTRA2
	ASH	0,0
;
	FRRFC,,FROMA1
	ADDM	0,0
;
	P21MNX=.	;MULTIPLY A FIXED PT WHICH IS NEGATED BY A POWER OF
			; 2 PLUS 1 LEAVING RESULT IN MEMORY
	FRRFC,,PTRA2
	ASH	0,0
;
	FRRFC,,FROMA1
	SUBM	0,0
;
;
	P21MFL=.	;MULTIPLY FLOATING PT BY A POWER OF 2 PLUS 1 TO MEMORY
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,FROMA1
	FADRM	0,0
;
	P21MNL=.	;MULTIPLY A FLOATING PT WHICH IS NEGATED BY A POWER OF
			; 2 PLUS 1 LEAVING RESULT IN MEMORY
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,FROMA1
	FSBRM	0,0
;
;
	P21MCM=.	;MULTIPLY A COMPLEX BY A POWER OF 2 PLUS 1 TO MEMORY
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,PTRA2
	FSC	1,0
;
	FRRFC,,FROMA1
	FADRM	0,0
;
	FRRFC,,FROMA1
	FADRM	1,1
;
	P21MNC=.	;MULTIPLY A NEGATED COMPLEX BY A POWEROF 2 PLUS
			; ONE TO MEMORY
	FRRFC,,PTRA2
	FSC	0,0
;
	FRRFC,,PTRA2
	FSC	1,0
;
	FRRFC,,FROMA1
	FSBRM	0,0
;
	FRRFC,,FROMA1
	FSBRM	1,1
;


;
;TABLES FOR FUNCTIONS FOR WHICH CODE IS GENERATED IN LINE (ABS,SIGN,
; DIM,MOD,MAX,MIN)
;
;
;WHEN THE VAL FOR ARG1 IS ALREADY IN THE REG FOR COMPUTATION
OPGILF:	-1,,ABS
	ILG		;RESERVE THIS SLOT FOR IABS IN A LATER RELEASE
			; (NEED TO BE ABLE TO GENERATE LABELS TO HANDLE)
	-3,,SIGN
	-3,,DIM
	-2,,MOD		;IN RELEASE 1, MOD MUST MOVE THE VAL FROM REG+1 TO REG
	-2,,MAX
	-2,,MIN

OPGDBF:	-2,,IDABS		;DABS WHEN ARG IN REGFORCOMP ON KI
	-2,,ADABS		;DABS WHEN ARG IN REGFORCOMP ON KA
;
;FOR DIM,MOD,MAX,MIN WHEN ARG2 IS IMMEDIATE
OPGILI:	ILG			;SHOULD NEVER SEE ABS WITH A2IMMED
	ILG			;SHOULD NEVER SEE IABS WITH A2IMMED
	ILG			;SHOULD NEVER SEE SIGN WITH A2IMMED
	-3,,DIMI
	-2,,MODI
	-2,,MAXI
	-2,,MINI
;FOR ABS,IABS, AND SIGN - WHEN THE VAL IS NOT YET IN REGFORCOMP
OPGIL1:	-1,,ABS1
	ILG		;IABS NOT HANDLED IN RELEASE 1
	-3,,SIGN1

OPGDB1:	-3,,IDABS1		;DABS WHEN VAL NOT IN REGFORCOMP ON KI
	-4,,ADABS1		;DABS WHEN VAL NOT IN REGFORCOMP ON KA

;
;CODE GENERATORS FOR IN LINE FNS
	ABS=.			;FOR ABS, USE NEXT 1 INSTR
	SIGN=.			;FOR SIGN, USE NEXT 3 INSTRS
	FRRFC,,FRRFC
	MOVM	0,0
;
	FRPTN,,FROMA2
	SKIPGE	0,0
;
	FRRFC,,FRRFC
	MOVNS	0,0
;
;
	DIM=.			;FOR DIM, USE NEXT 3 INSTRS
	FRRFC,,FROMA2
	CAMG	0,0
;
	FRRFC,,FRRFC
	TDZA	0,0
;
	FRRFC,,FROMA2
	FSBR	0,0
;
;
	MOD=.			;FOR MOD, USE NEXT 2 INSTRS
	FRRFC,,FROMA2
	IDIV	0,0
;
	FRRFC,,FRRFC
	MOVE	0,1
;
;
	MAX=.			;FOR MAX, USE NEXT 2 INSTRS
	FRRFC,,FROMA2
	CAMGE	0,0
;
	FRRFC,,FROMA2
	MOVE	0,0
;
;
	MIN=.			;FOR MIN, USE NEXT 2 INSTRS
	FRRFC,,FROMA2
	CAMLE	0,0
;
	FRRFC,,FROMA2
	MOVE	0,0
;
;
	DIMI=.			;DIM FOR ARG2 IMMED CNST
	FRRFC,,A2CNST
	CAIG	0,0
;
	FRRFC,,FRRFC
	TDZA	0,0
;
	FRRFC,,A2CNST
	FSBRI	0,0
;
;
	MODI=.			;MOD WITH ARG2 IMMED (NEXT 2 INSTRS)
	FRRFC,,A2CNST
	IDIVI	0,0
;
	FRRFC,,FRRFC
	MOVE	0,1
;
;
	MAXI=.			;MAX WITH ARG2 IMMED
	FRRFC,,A2CNST
	CAIGE	0,0
;
	FRRFC,,A2CNST
	MOVEI	0,0
;
;
	MINI=.			;MIN WITH ARG2 IMMED
	FRRFC,,A2CNST
	CAILE	0,0
;
	FRRFC,,A2CNST
	MOVEI	0,0
;
;
;
	ABS1=.			;FOR ABS WHEN ARG IS NOT IN REG (1 INST)
	SIGN1=.			; SIGN WHEN ARG IS NOT IN REG (3 INSTRS)
	FRRFC,,FROMA1
	MOVM	0,0
;
	FRPTN,,FROMA2
	SKIPGE	0
;
	FRRFC,,FRRFC
	MOVNS	0,0

;
; FOR DABS IN LINE
;
	IDABS=.			; FOR DABS WHEN ARG IN REGFORCOMP
				; ON KI

	FRPTN,,FRRFC
	SKIPGE	0,0
;
	FRRFC,,FRRFC
	DMOVN	0,0
;
	ADABS=.			;FOR DABS WHEN ARG IN REGFORCOMP 
				; ON KA
	FRPTN,,FRRFC
	SKIPGE	0,0
;
	FRRFC,,FRRFC
	DFN	0,1
;
;
;
	IDABS1=.		;FOR DABS WHEN ARG NOT IN
				;REGFORCOMP ON KI
	FRRFC,,FROMA1
	DMOVE	0,0
;
	FRPTN,FRRFC
	SKIPGE	0,0
;
	FRRFC,,FRRFC
	DMOVN	0,0
;
	ADABS1=.		;FOR DABS WHEN ARG NOT IN
				;REGFORCOMP ON KA
;
	FRRFC,,FROMA1
	MOVE	1,1
;
	FRRFC,,FROMA1
	MOVE	0,0
;
	FRPTN,,FRRFC
	SKIPGE	0,0
;
	FRRFC,,FRRFC
	DFN	0,1

;
;TABLES FOR GENERATION OF CODE FOR A "STORECLS" NODE (IE A NODE WHICH
;SPECIFIES THAT SOME VAL IS TO BE STORED IN A TEMPORARY)
;
;
;DISPATCH TABLE
OPGSTC:	-2,,STARVL		;STORE VAL OF AN ARRAY ELEMENT
	-1,,STRRFC		; STORE VAL OF AN ARRAY ELEM WHEN ITS ALREADY
				; IN THE "REG-FOR-COMP"
	-2,,STARAD		;STORE PTR TO AN ARRAY ELEM
	-1,,STRRFC		; STORE PTR TO AN ARRAY ELEM WHEN THAT
				; PTR IS ALREADY IN A REG
;    FOR STORING THE VALUE OF AN ELEMENT IN A DOUBLE-WD ARRAY
OPGSTD:	-2,,STDI		;TO STORE DOUBLE-WD ON KI10
	-1,,STDIS		; DOUBLE-WD, KI10, WHEN VAL IS ALREADY IN 
				; REG-FOR-COMP
	-4,,STDA		;TO STORE DOUBLE-WD ON KA10
	-2,,STDAS		;DOUBLE-WD, KA10, VAL ALREADY IN REG
;
;
;
;
;CODE GENERATORS
;
	STARVL=.		;TO STORE THE CONTENTS OF AN ARRAY ELEM
	FRRFC,,FROMA2
	MOVE	0,0
;
	STRRFC=.		; (TO STORE A VAL ALREADY IN REGFORCOMP)
	FRRFC,,PARTMP
	MOVEM	0,0
;
;
	STARAD=.		;TO STORE A PTR TO AN ARRAY ELEM
	FRRFC,,FROMA2
	MOVEI	0,0
;
	FRRFC,,PARTMP
	MOVEM	0,0
;
;
;    CODE GENERATORS FOR STORING DOUBLE-WD VALS
	STDI=.		;KI-10
	FRRFC,,FROMA2
	DMOVE	0,0
;
	STDIS=.		; KI10 WHEN VAL ALREADY IN REG
	FRRFC,,PARTMP
	DMOVEM	0,0
;
;
	STDA=.		;KA10 (USE NEXT 4 INSTRS)
	FRRFC,,FROMA2
	MOVE	0,0
;
	FRRFC,,FROMA2
	MOVE	1,1
;
	STDAS=.		;KA10 WHEN VAL ALREADY IN REG (USE NEXT 2 INSTRS)
	FRRFC,,PARTMP
	MOVEM	0,0
;
	FRRFC,,PARTMP
	MOVEM	1,1



;
;DISPATCH TABLES FOR GENERATION OF INSTRUCTIONS FOR TRANSFERS OF CONTROL
;
;
;DISPATCH TABLE  FOR TRANSFER OF CONTROL WHEN A SPECIFIED
; VARIABLE HAS THE SPECIFIED VALUE TRUE OR FALSE
OPGVTS:		-2,,TSTMFL		;TRANSFER ON A MEMLOC FALSE
		-1,,TSTRFL		;TRANSFER ON A REG CONTENTS FALSE
		-2,,TSTMTR		;TRANSFER ON A MEMLOC TRUE
		-1,,TSTRTR		;TRANSFER ON A REG TRUE
;
;DISPATCH TABLE FOR TRANSFER TO THE LABEL INDICATED BY A1NODE IF
;  A SPECIFIED VARIABLE IS TRUE, TO THE LABEL INDICATED BY A2NODE IF
; IT IS FALSE
OPGALT:		-3,,ALTMEM		;TRANSFER DEPENDS ON A VAL IN MEM
		-2,,ALTREG		; ON A VAL IN A REG
;
;CODE GENERATORS FOR TRANSFERS OF CONTROL
;
	TSTMFL=.		;TRANSFER ON A MEMLOC FALSE
	FRPTN,,FROMPA
	SKIPL	0,0
;
	FRPTN,,A1LAB
	JRST	0
;
	TSTRFL=.		;TRANSFER ON A REG CONTENTS FALSE
	FRRFC,,A1LAB
	JUMPGE	0,0
;
	TSTMTR=.		;TRANSFER ON A MEMLOC TRU
	FRPTN,,FROMPA
	SKIPGE	0,0
;
	FRPTN,,A1LAB
	JRST	0
;
	TSTRTR=.		;TRANSFER ON A REG TRUE
	FRRFC,,A1LAB
	JUMPL	0,0
;
	ALTMEM=.		;TRANSFER TO A1LAB IF MEMLOC IS TRUE,
				; TO A2LAB IF FALSE
	FRPTN,,FROMPA
	SKIPGE	0,0
;
	FRPTN,,A1LAB
	JRST	0,0
;
	FRPTN,,A2LAB
	JRST	0,0
;
	ALTREG=.		;TRANSFER TO A1LAB IF REG IS TRUE, TO
				; A2LAB IF FALSE
	FRRFC,,A1LAB
	JUMPL	0,0
;
	FRPTN,,A2LAB
	JRST	0,0

	INTERN DOSTC		;STORE THE CONTROL WORD
	INTERN	OPGDOS
	INTERN	OPGDOE
	INTERN DOSTI

DOSTI:	-1,,DOSTH

DOSTC:	-1,,STCDO	;TO STORE THE CT WHEN IT IS IN A REG
	-1,,STCDO1	;TO STORE THE CT WHEN IT IS IN THE LEFT HALF OF
			; A REG (IN AOBJN FORM)

STCDO=.
	FRRFC,,FROMA1
	MOVEM 0,0

STCDO1=.
	FRRFC,,FROMA1
	HLREM	0,0
;


OPGDOS:	-1,,DOENS


OPGDOE:	-1,,DOEN11
	ILG
	-1,,RDOEND
	-2,,CDOEND


DOEN11=.
	FRRFC,,A1LAB
	AOBJN 0,0

DOSTH=.
	FRRFC,,FROMA1
	HRRZM 0,0

RDOEND=.
	FRRFC,,A1LAB
	AOJL 0,0

DOENS=.
	FRRFC,,FROMA1
	AOS 0,0

CDOEND=.
	FRPTN,,FROMA1
	AOSGE 0

	FRPTN,,A1LAB
	JRST 0





;
;
;TABLES FOR CODE GENERATION OF CODE FOR ARITHMETIC IF STATEMENTS
;
;
;DISPATCH TABLE FOR GENERATION OF CODE FOR ARITHMETIC-IF STMNTS IN WHICH
; THE VAL OF THE EXPRESSION MUST BE ENTIRELY COMPUTED AND THEN TESTED
;
;	IF NO 2 OF THE LABELS ARE EQUAL TO EACHOTHER
OPGAIF:	-4,,AI2NN	;NONE OF THE 3 LABELS IS THE NEXT STMNT, VAL IS NOT IN REG
	-3,,AI2NNR	;NONE OF THE LABELS IS NXT, VAL IS IN A REG
	-3,,AI2NL	;LESS LABEL IS ON NEXT STMNT (VAL NOT IN REG)
	-2,,AI2NLR	;LESS LABEL IS ON NEXT STMNT (VAL IS IN A REG)
	-3,,AI2NE	;EQL LABEL IS NEXT (VAL IS NOT IN A REG)
	-2,,AI2NER	;EQL LABEL IS NEXT (VAL IS IN A REG)
	-3,,AI2NG	;GTR LABEL IS NEXT (VAL IS NOT IN A REG)
	-2,,AI2NGR	;GTR LABEL IS NEXT (VAL IS IN A REG)
;
;	IF LESS LABEL IS EQUAL TO EQL LABEL
	-3,,I2LEN	;NONE OF THE LABELS IS NEXT (VAL IS NOT ON REG)
	-2,,I2LENR	;NONE OF THE LABELS IS NEXT (VAL IS IN A REG)
	-2,,I2LEL	;LESS (AND EQL) LABEL IS NEXT (VAL NOT IN A REG)
	-1,,I2LELR	;LESS (AND EQL) LABEL IS NEXT (VAL IS IN A REG)
	-2,,I2LEL	;EQL (AND LESS) LABEL IS NEXT (VAL NOT IN REG)
	-1,,I2LELR	;EQL (AND LESS) LABEL IS NEXT (VAL IS IN REG)
	-2,,I2LEG	;GTR LABEL IS NEXT (VAL NOT IN REG)
	-1,,I2LEGR	;GTR LABEL IS NEXT (VAL IS IN REG)
;
;	IF LESS LABEL IS EQUAL TO GTR LABEL
	-3,,I2LGN	;NONE OF THE LABELS IS NEXT (VAL IS NOT ON REG)
	-2,,I2LGNR	;NONE OF THE LABELS IS NEXT (VAL IS IN A REG)
	-2,,I2LGL	;LESS (AND GTR)  LABEL IS NEXT (VAL NOT IN A REG)
	-1,,I2LGLR	;LESS (AND GTR)  LABEL IS NEXT (VAL IS IN A REG)
	-2,,I2LGE	;EQL  LABEL IS NEXT (VAL NOT IN REG)
	-1,,I2LGER	;EQL  LABEL IS NEXT (VAL IS IN REG)
	-2,,I2LGL	;GTR (AND LESS) LABEL IS NEXT (VAL NOT IN REG)
	-1,,I2LGLR	;GTR (AND LESS) LABEL IS NEXT (VAL IS IN REG)
;
;	IF GTR LABEL IS EQUAL TO EQL LABEL
	-3,,I2GEN	;NONE OF THE LABELS IS NEXT (VAL IS NOT ON REG)
	-2,,I2GENR	;NONE OF THE LABELS IS NEXT (VAL IS IN A REG)
	-2,,I2GEL	;LESS  LABEL IS NEXT (VAL NOT IN A REG)
	-1,,I2GELR	;LESS  LABEL IS NEXT (VAL IS IN A REG)
	-2,,I2GEG	;EQL (AND GTR)  LABEL IS NEXT (VAL NOT IN REG)
	-1,,I2GEGR	;EQL (AND GTR)  LABEL IS NEXT (VAL IS IN REG)
	-2,,I2GEG	;GTR (AND EQL) LABEL IS NEXT (VAL NOT IN REG)
	-1,,I2GEGR	;GTR (AND EQL) LABEL IS NEXT (VAL IS IN REG)
;
;
;CODE GENERATORS FOR ARITHMETIC-IF STMNTS IN WHICH THE VAL OF THE EXPRESSION
; MUST BE COMPUTED AND TESTED
;
;	IF NO 2 OF THE LABELS ARE EQUAL TO EACHOTHER
;
	AI2NN=.		;NONE OF THE LABELS IS NEXT, VAL NOT IN REG
	AI2NG=.		;GTR LABEL NXT, VAL NOT IN REG (NEXT 3 INSTRS ONLY)
	FRRFC,,FROMA1
	SKIPGE	0,0
;
	FRPTN,,A1LAB
	JRST	0
;
	FRRFC,,A2LAB
	JUMPE	0,0
;
	FRPTN,,A3LAB
	JRST	0
;
;
	AI2NNR=.	;NONE OF THE LABELS IS NEXT, VAL IS IN REG
	AI2NGR=.	;GTR LABEL NEXT, VAL IN REG (USE NEXT 2 INSTRS ONLY)
	FRRFC,,A1LAB
	JUMPL	0,0
;
	FRRFC,,A2LAB
	JUMPE	0,0
;
	FRPTN,,A3LAB
	JRST	0
;
;
	AI2NL=.		;LESS LABEL IS NEXT, VAL NOT IN REG
	FRRFC,,FROMA1
	SKIPN	0,0
;
	FRPTN,,A2LAB
	JRST	0
;
	FRRFC,,A3LAB
	JUMPG	0,0
;
;
	AI2NLR=.	;LESS LABEL IS NEXT, VAL IS IN REG
	FRRFC,,A2LAB
	JUMPE	0,0
;
	FRRFC,,A3LAB
	JUMPG	0,0
;
;
	AI2NE=.		;EQL LABEL IS NEXT, VAL NOT IN REG
	FRRFC,,FROMA1
	SKIPGE	0,0
;
	FRPTN,,A1LAB
	JRST	0
;
	FRRFC,,A3LAB
	JUMPG	0,0
;
;
	AI2NER=.	;EQL LABEL IS NEXT VAL IS IN REG
	FRRFC,,A1LAB
	JUMPL	0,0
;
	FRRFC,,A3LAB
	JUMPG	0,0
;
;
;	IF LESS AND EQL LABELS ARE EQUAL TO EACHOTHER
;
	I2LEN=.		;NONE OF THE LABELS IS NEXT , VAL NOT IN REG
	I2LEG=.		;GTR LABEL NEXT, VAL NOT IN REG (USE THE NEXT 2 INSTRS ONLY)
	FRPTN,,FROMA1
	SKIPG	0,0
;
	FRPTN,,A1LAB
	JRST	0
;
	FRPTN,,A3LAB
	JRST	0
;
;
	I2LENR=.	;NONE OF THE LABELS IS NEXT, VAL IS IN A REG
	I2LEGR=.	;GTR LABEL NEXT, VAL IN REG (USE THE NEXT INSTR ONLY)
	FRRFC,,A1LAB
	JUMPLE	0,0
;
	FRPTN,,A3LAB
	JRST	0
;
;
	I2LEL=.		;LESS (AND EQL) LABEL IS NEXT, VAL NOT IN REG
	FRPTN,,FROMA1
	SKIPLE	0,0
;
	FRPTN,,A3LAB
	JRST	0
;
;
	I2LELR=.	;LESS (AND EQL) LABEL IS NEXT, VAL IS IN REG
	FRRFC,,A3LAB
	JUMPG	0,0
;
;
;	IF GTR LABEL IS EQUAL TO EQL LABEL
;
	I2GEN=.		;NONE OF THE LABELS IS NEXT, VAL NOT IN REG
	I2GEL=.		;LESS LABEL IS NEXT, VAL NOT IN REG (USE NEXT 2 INSTS ONLY)
	FRPTN,,FROMA1
	SKIPL	0,0
;
	FRPTN,,A3LAB
	JRST	0
;
	FRPTN,,A1LAB
	JRST	0
;
;
	I2GENR=.	;NONE OF THE LABELS IS NEXT,VAL IS IN REG
	I2GELR=.	;LESS LABEL IS NEXT, VAL IS IN REG (USE NEXT INSTR ONLY)
	FRRFC,,A3LAB
	JUMPGE	0,0
;
	FRPTN,,A1LAB
	JRST	0
;
;
	I2GEG=.		;GTR (AND EQL) LABEL IS NEXT
	FRPTN,,FROMA1
	SKIPGE	0,0
;
	FRPTN,,A1LAB
	JRST	0
;
;
	I2GEGR=.	;GTR (AND EQL) LABEL IS NEXT, VAL IS IN REG
	FRRFC,,A1LAB
	JUMPL	0,0
;
;
;	IF LESS LABEL IS EQUAL TO GTR LABEL
;
	I2LGN=.		;NONE OF THE LABELS IS NEXT, VAL NOT IN REG
	I2LGE=.		;EQL LABEL NEXT, VAL NOT IN REG (USE NEXT 2 INSTRS ONLY)
	FRPTN,,FROMA1
	SKIPE	0,0
;
	FRPTN,,A1LAB
	JRST	0
;
	FRPTN,,A2LAB
	JRST	0
;
;
	I2LGNR=.	;NONE OF THE LABELS IS NEXT, VAL IS IN REG
	I2LGER=.	;EQL LABEL NEXT, VAL IN REG (USE NEXT INSTR ONLY)
	FRRFC,,A1LAB
	JUMPN	0,0
;
	FRPTN,,A2LAB
	JRST	0
;
;
	I2LGL=.		;LESS (AND GTR) LABEL IS NEXT, VAL NOT IN REG
	FRPTN,,FROMA1
	SKIPN	0,0
;
	FRPTN,,A2LAB
	JRST	0
;
;
	I2LGLR=.	;LESS (AND GTR) LABEL IS NEXT, VAL IS IN REG
	FRRFC,,A2LAB
	JUMPE	0,0
;

;
;FOR COMPUTED GOTO - TO TEST THE RANGE OF THE VAL COMPUTED
; ALWAYS USE REGISTER 1
OPGCGO:	-3,,CGOTS
;
	CGOTS=.
	FRPTN,,FROMA1
	SKIPLE	01,0
;
	FRPTN,,FROMC1
	CAILE	01,0
;
	FRPTN,,A1LAB
	JRST	0,0
;
;  FOR COMPUTED GOTO WHEN THE VAR IS IN THE RH OF  A REG CONTAINING
;  THE DO LOOP CONTROL
OPGCGI:	-4,,CGOITS
;
	CGOITS=.
	FRPTN,,A1CNST		;GENERATE "MOVEI 1,0(LOOPREG)
	MOVEI	1,0
;
	FRPTN,,A1LAB
	JUMPLE	1,0
;
	FRPTN,,FROMC1
	CAILE	1,0
;
	FRPTN,,A1LAB
	JRST	0,0
;
;


	INTERN 	OPGIIN
	INTERN	OPGMVL
	INTERN	OPINDA
	INTERN	OPINDI
	INTERN	DVALU
	INTERN	OPINSA
	INTERN	OPDSTG
	INTERN	OPINSI
	INTERN	CRETN
	INTERN	MOVRET
	INTERN	POPRET

;FOR PROLOGUE , EPILOGUE AND SUBROUTINE RETURN

	;TO SAVE THE EPILOGUE ADDRESS

OPGIIN:	-1,,MOVIIA

OPGMVL:	-2,,MVLAB

	;MOVE INDIRECT THROUGH 16

OPINDA:	-1,,GAI
	-1,,GAI
	-3,,GA2KAI
	-3,,GA2KAI

	;FOR THE KI 10 

OPINDI:	-1,,GAI
	-1,,GAI
	-1,,GA2KII
	-1,,GA2KII

	;MAKE VALUES TO ADD FOR MULTIPLE RETURNS

DVALU:	-1,,DATER

	;SIMPLE RETURN

POPRET:	-1,,POPIT

	;MOVE THE RETURN I VALUE TO AC 1

MOVRET:	-1,,MOVRTN

	;STORE INDIRECT THROUGH 16

OPINSA:	-1,,STI
	-3,,ST2AI

	;FOR THE KI 10

OPINSI:	-1,,STI
	-1,,ST2II

	;FOR A GLOBALLY ALLOCATED PARM
	;FOR THE KA10 ONLY

OPDSTG:	-3,,STGA

	;FOR A RETURN I

CRETN:	-5,,LGRET

MOVIIA=.
	FRRFC,,FROMC1
	MOVEI 0,0(16)

MVLAB=.
	FRPTN,,A1LAB
	MOVEI 1,0

	FRPTN,,FROMA1
	MOVEM 1,0

GAI=.
	FRRFC,,FROMC1
	MOVE 0,0(16)
GA2KAI=.

	FRPTN,,FROMC1
	MOVEI 1,@0(16)

	FRRFC,,FRPTN
	MOVE 0,0(1)

	FRRFC,,FRPTN
	MOVE 1,1(1)


GA2KII=.
	FRRFC,,FROMC1
	DMOVE 0,(16)

DATER=.
	FRPTN,,FROMC1
	0

STI=.
	FRRFC,,FROMC1
	MOVEM 0,0(16)

ST2AI=.
	FRPTN,,FRPTN
	MOVE 0,1

	FRPTN,,FROMC1
	MOVEI 1,@0(16)

	FRPTN,,FRPTN
	MOVEM 0,1(1)

ST2II=.
	FRRFC,,FROMC1
	DMOVEM 0,(16)

STGA=.
	FRPTN,,FROMC1
	MOVEI 1,0(16)

	FRRFC,,FRPTN
	MOVEM 0,0(1)

	FRRFC,,FRPTN
	MOVEM 1,1(1)

LGRET=.
	FRPTN,,A1LAB
	JUMPLE 1,0

	FRPTN,,FROMC1
	CAILE 1,0

	FRPTN,,A1LAB
	JRST

	FRPTN,,A2LAB
	MOVE 1,@0(1)

	FRPTN,,FRPTN
	HRRM 1,0(17)

POPIT=.
	FRPTN,,FRPTN

	POPJ 17,0

MOVRTN=.
	FRPTN,,FROMC1
	MOVE 1,0

	;FOR SUBROUTINE OR FUNCTION CALL

	INTERN CALLER
	INTERN OPGSFN

CALLER:	-2,,CALLIT
	-1,,CNOARG

OPGSFN:	-2,,CALLAB	;FOR STATEMENT FUNCTION REF

CALLIT=.
	FRPTN,,A1LAB
	MOVEI 16,0

CNOARG=.
	FRPTN,,FROMA1
	PUSHJ 17,0

CALLAB=.
	FRPTN,,A1LAB
	MOVEI 16,0

	FRPTN,,A2LAB
	PUSHJ 17,0



;
;TO GENERATE CODE TO CALL FOROTS ROUTINES
;
;DISPATCH ENTRIES
OPGIOL:	-2,,IOLSTC
OPGMTO:	-2,,MTOPC
OPGIN:	-2,,INC
OPGENC:	-2,,ENCC
OPGDEC:	-2,,DECC
OPGOUT:	-2,,OUTC
OPGWTB:	-2,,WTBC
OPGRTB:	-2,,RTBC
OPGNLI:	-2,,NLIC
OPGNLO:	-2,,NLOC
OPGADJ:	-2,,ADJOP
OPGLIB:	-2,,LIBCAL
OPGOPE:	-2,,OPENC
OPGFND:	-2,,FINDC
OPGRLS:	-2,,RELSC
OPGCLO:	-2,,CLOC
OPGFIN:	-1,,FINC
;
;   CODE GENERATORS
	IOLSTC=.
	FRPTN,,A1LAB
	MOVEI	16,0
;
	FRPTN,,WD1IMF
	PUSHJ	17,IOLSTT
;
MTOPC=.
	FRPTN,,A1LAB
	MOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,MTOPT

INC=.
	FRPTN,,A1LAB
	MOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,INT

ENCC=.
	FRPTN,,A1LAB
	MOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,ENCT

DECC=.
	FRPTN,,A1LAB
	MOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,DECT

OUTC=.
	FRPTN,,A1LAB
	MOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,OUTT

WTBC=.
	FRPTN,,A1LAB
	MOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,WTBT

RTBC=.
	FRPTN,,A1LAB
	MOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,RTBT

NLIC=.
	FRPTN,,A1LAB
	MOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,NLIT

NLOC=.
	FRPTN,,A1LAB
	MOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,NLOT

ADJOP=.
	FRPTN,,A1LAB
	MOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,ADJT

LIBCAL=.
	FRPTN,,A1LAB
	MOVE 16,0

	FRPTN,,IMFN
	PUSHJ 17,0

OPENC=.
	FRPTN,,A1LAB
	MOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,OPENT


FINDC=.
	FRPTN,,A1LAB
	MOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,FINDT

RELSC=.
	FRPTN,,A1LAB
	MOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,RELST

CLOC=.
	FRPTN,,A1LAB
	MOVEI 16,0

	FRPTN,,WD1IMF
	PUSHJ 17,CLOST

FINC=.
	FRPTN,,WD1IMF
	PUSHJ 17,FINT


;
;SET UP THE SIXBIT FOR THE NAMES OF THE FOROTS ROUTINES
;
IOLSTT:	SIXBIT	"IOLST."
MTOPT:	SIXBIT	"MTOP."
INT:	SIXBIT	"IN."
OUTT:	SIXBIT	"OUT."
ENCT:	SIXBIT	"ENC."
DECT:	SIXBIT	"DEC."
NLIT:	SIXBIT	"NLI."
NLOT:	SIXBIT	"NLO."
WTBT:	SIXBIT	"WTB."
RTBT:	SIXBIT	"RTB."
ADJT:	SIXBIT	"ADJ."
OPENT:	SIXBIT	"OPEN."
FINDT:	SIXBIT	"FIND."
CLOST:	SIXBIT	"CLOSE."
RELST:	SIXBIT	"RELEA."
FINT:	SIXBIT	"FIN."




;TO GENERATE CODE FOR A PAUSE STATEMENT
OPGPAU:	-2,,PAUSEC
	PAUSEC=.
	FRPTN,,A1LAB
	MOVEI	16,0
;
	FRPTN,,WD1IMF
	PUSHJ	17,PAUSET
;
PAUSET:	SIXBIT	"PAUS."
;
;
;
;
;FOR STOP
;
OPGSTP:	-2,,STOPCD
	STOPCD=.
	FRPTN,,A1LAB
	MOVEI	16,0
;
	FRPTN,,WD1IMF
	PUSHJ	17,STOPT
;
STOPT:	SIXBIT	"STOP."
;
;FOR THE EXIT AT THE END OF THE PROGRAM
;
OPGEXI:	-2,,EXITCD
EXITCD=.
	FRPTN,,A1LAB
	MOVEI	16,0
;
	FRPTN,,WD1IMF
	PUSHJ	17,EXITT
;
;
EXITT:	SIXBIT	"EXIT."
;
;
;
;TO GENERATE CODE FOR THE INITIAL CALL TO RESET.
OPGRES:	-3,,RESCD
;
	RESCD=.
	FRPTN,,FRPTN
	JFCL	0
;
	FRPTN,,WD1IMF
	JSP	16,RESETT
;
	FRPTN,,FRPTN
	0
;
RESETT:	SIXBIT	"RESET."


;
;TO GENERATE PUSH AND POP REGISTER SAVE AND RESTORES
;FOR STATEMENT FUNCTIONS
OPGPPR:	-1,,POPRG

	POPRG=.
	FRPTN,,FRRFC
	POP 17,0

OPGPHR:	-1,,PSHR

	PSHR=.
	FRPTN,,FRRFC
	PUSH 17,0

	END
