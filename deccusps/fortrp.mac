TITLE FORTRP %4.(152) OVER/UNDERFLOW TRAP ROUTINE
	SUBTTL	D. TODD /DRT/     08-MAR-1972 T. EGGERS/DMN/TWE/DRT
;***COPYRIGHT 1972,1973,1974 DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***

;MODIFIED FROM LIB40 TRAPS VERSION 32A(444)


	SEARCH	FORPRM		;GET THE FOROTS GLOBAL SYMBOL TABLE

T==P3	;WORKING ACCUMULATOR
TT==T1

	SEGMEN	;GET THE LOADING CONTROL MACRO


FXU==1B11	;FLOATING EXPONENT UNDERFLOW FLAG
FOV==1B3		;FLOATING OVERFLOW BIT
NDV==1B12	;NO DIVIDE BIT

OPDEF APRENB [CALLI 16]	;TO SET UP APR TRAPPING
OVE==10		;ENABLE INTEGER OVERFLOW TRAPS
FVE==100	;ENABLE FOR FLOATING POINT TRAPS


ENTRY	TRPIN.
EXTERN	.JBTPC,.JBAPR,.JBREL

			;PUSHJ P,TRPINI	TO INITIALIZE ALL TRAPPING
TRPIN.:	MOVEI TT,OVTRAP
	HRRZM TT,.JBAPR		;INIT OVERFLOW TRAP ADDRESS
	MOVEI TT,OVE!FVE+400000
	JRSTF @[XWD 004000,.+1]		;CLEAR APR FLAGS
	APRENB TT,		;INIT OVERFLOW TRAPPING
	POPJ	P,		;RETURN

;VARIABLES ARE PUSHED ONTO THE STACK IN THE FOLLOWING ORDER:
TSAVE=1		;TEMP FOR AC T
ACFLD=2		;USUALLY ACCUMULATOR FIELD OF TRAPPING INSTRUCTION
INST=3		;TRAPPING INSTRUCTION OR ITS EFFECTIVE ADDRESS
ACDATA=4	;THE RESULT OF THE TRAPPING INSTRUCTION
FIXUP1=5	;THE SINGLE  (OR LOW WORD IF D.P.) WORD FIX UP
FIXUP2=6	;THE HIGH ORDER WORD FIX UP OF A D.P. RESULT
N=0		;A COUNTER, WHOSE VALUE IS THE NUMBER OF ITEMS
		;THAT THIS TRAP ROUTINE HAS ON THE STACK.

OVTRAP:	PUSH P,T		;SAVE AC T AS "TSAVE"
	N=1
	SOS T,.JBTPC		;MAKE .JBTPC POINT TO INSTRUCTION
	TLNN T,(FXU)		;FLOATING POINT UNDERFLOW?
	JRST OVTRP1		;NO

	HLL T,1(T)		;YES
	TLC T,(JFCL (2))	; IS NEXT INSTRUCTION
	TLNN T,777002		;   A JFCL (2) ?
	JRST OVTRP2		;YES

	LDB T,[POINT 9,(T),8]	;GET INSTRUCTION
	CAILE T,177		;POSSIBLE FLOATING POINT?
	JRST TJFCL1		;NO
	CAIGE T,140		;BETWEEN 140 AND 177?
	JRST	[CAIN T,(<FSC>_-9)	;NO, FSC?
		JRST	UFSC		;FSC UNDERFLOW
					;(UFA AND DFN CAN'T CAUSE UNDERFLOW)
	IFE CPU-KI10,<TRZ T,003		;CHANGE ALL KI10 D.P. ARITH TO DFAD
		CAIN T,(<DFAD>_-9)
		JRST UACLNG >		;DFAD, DFSB, DFMP, DFDV
		JRST TJFCL1]		;NO, PRINT ERROR MESSAGE
	ANDI T,7		;MASK TO MODE BITS
	JRST UTBL(T)		;DISPATCH ON INSTRUCTION TYPE

	;THE STACK HAS 1 ITEM, N=1
OVTRP1:	N=1
	TLNN T,(FOV)		;FLOATING OVERFLOW OR FLOATING DIVIDE CHECK?
	JRST TJFCL1		;NO, INTEGER OVERFLOW OR DIVIDE CHECK
OVTRP2:	LDB T,[POINT 4,@.JBTPC,12]	;GET AC FIELD
	PUSH P,T		;SAVE AC FIELD AS "ACFLD"
	N=N+1
	MOVE T,@.JBTPC		;GET INSTRUCTION
	PUSH P,T		;SAVE INSTRUCTION AS "INST"
	N=N+1
	MOVE T,TSAVE-N(P)	;RESTORE AC T
	MOVEI T,@INST-N(P)	;GET EFFECTIVE ADDRESS
	EXCH T,INST-N(P)	; AND SAVE. PICK UP INSTRUCTION
	TLC T,(042B8)		;CHANGE "MODE 2" TO "MODE 0"
				; AND CHANGE 140-177
				;   TO 100-137
	HLR T,.JBTPC		;GET FLAGS IN RIGHT HALF
	TDNE T,[643B8+<NDV_-^D18>]	;SKIP FOR "TO MEMORY" AND NO NDV
				; NO SKIP FOR INSTRUCTIONS OUTSIDE 140-177
				;  (E.G. FSC,XCT,UFA,DFAD,DFSB,DFMP,DFDV)
	SKIPA T,ACFLD-N(P)	;GET CORRECT SIGN FROM AC
	MOVE T,INST-N(P)	;GET CORRECT SIGN FROM MEMORY
	PUSH P,T	;SAVE ADDRESS FOR SIGN OF CORRECT RESULT AS "ACDATA"
	N=N+1
	MOVE T,.JBTPC		;IS THIS AN UNDERFLOW THAT
	TLNE T,(FXU)		;  NEEDS TO BE UNNORMALIZED?
	JRST	[MOVE T,TSAVE-N(P)	;YES, RESTORE T AND
		MOVE T,@ACDATA-N(P)	;  GET ANSWER THAT NEEDS UN-NORMALIZING
		PUSH P,TT		;SAVE ANOTHER AC
		N=N+1
		HLRE TT,T	;GET EXPONENT WITH EXTENDED SIGN INTO
		ASH TT,-9	;  RIGHT 8 BITS
		TSCE TT,TT	;FOR NEGATIVE ARG, GET 1'S COMPLEMENT
				;OF EXPONENT AND DON'T SKIP
		TLOA T,777000	;FOR NEG. ARG, SET EXP TO ALL ONES
		TLZ T,777000	;FOR POS. ARG, SET EXP TO ALL 0'S
		CAMGE TT,[346,,346]	;WILL ALL FRACTION BITS GO AWAY?
		TDZA T,T		;YES, FRACTION SHOULD BE ZERO
		ASH T,400000(TT)	;UN-NORMALIZE FRACTION TO BRING EXP
				;BACK INTO RANGE
		POP P,TT	;RESTORE THE AC
		N=N-1
		JRST OVTRP3]	;GO STORE RESULT
	MOVE T,TSAVE-N(P)
	SKIPGE @ACDATA-N(P)	;SKIP IF CORRECT RESULT IS POSITIVE
	SKIPA T,[XWD 400000,1]	;NO, NEGATIVE
	HRLOI T,377777		;YES
OVTRP3:	PUSH P,T		;SAVE FIX UP AS "FIXUP1"
	N=N+1
	LDB T,[POINT 9,@.JBTPC,8]	;GET INSTRUCTION
	CAIG T,177
	CAIGE T,140		;NORMAL FLOATING POINT INSTRUCTION
	JRST	[CAIN T,(<FSC>_-9)	;NO, FSC?
		JRST	OVFSC		;FSC OVERFLOW OR DIVIDE CHECK
		CAIN T,(<UFA>_-9)	;UFA?
		JRST AC1
	IFE CPU-KI10,<TRZ T,003	;CHANGE ALL KI10 D.P. ARITHMETIC TO DFAD
		CAIN T,(<DFAD>_-9)
		JRST ACDOUB >	;KI10 DFAD, DFSB, DFMP, OR DFDV
		SUB P,[N-1,,N-1]	;LEAVE 1 ITEM ON STACK
		JRST TJFCL1]	;PROBABLY AN XCT
	ANDI T,7
	JRST TBL(T)

	;THERE ARE 5 ITEMS ON THE STACK, N=5
;THIS PAGE FOR OVERFLOWS, DIVIDE CHECKS, AND UN-NORMALIZING UNDERFLOWS

TBL:	JRST AC
	JRST ACLONG
	JRST MEMORY
	JRST BOTH
	JRST AC
	JRST AC
	JRST MEMORY
	;JRST BOTH

BOTH:	PUSH P,(P)		;SAVE ANOTHER COPY
BOTH1:	N=6
	MOVE T,TSAVE-N(P)
	POP P,@ACFLD-N(P)	;LOAD AC (WITH HI PART IF D.P.)
	N=N-1
	POP P,@INST-N(P)	;LOAD MEMORY (OR AC+1 WITH LO PART IF D.P.)
	N=N-1
	SUB P,[N-1,,N-1]	;LEAVE 1 ITEM ON STACK
	JRST TJFCL

OVFSC:
IFE CPU-KI10,<
	MOVE	T,.JBTPC
	MOVE	T,1(T)		;GET THE INSTRUCTION FOLLOWING
	TLC	T,(JFCL (4))	;JFCL (4)
	TLNN	T,777004	;WAS FSC FOLLOWD BY JFCL (4)
	JRST	ACDOUB>		;YES
	JRST	AC		;NO

AC1:	N=5
	AOS T,ACFLD-N(P)
	ANDI T,17		;MASK AC+1 TO 4 BITS
	MOVEM T,ACFLD-N(P)
AC:	MOVE T,TSAVE-N(P)
	POP P,@ACFLD-N(P)	;LOAD AC
	N=N-1
	SUB P,[N-1,,N-1]	;LEAVE 1 ITEM ON STACK
	JRST TJFCL

ACLONG:	N=5
	MOVE T,ACFLD-N(P)	;GET AC
	ADDI T,1
	ANDI T,17
	MOVEM T,INST-N(P)	;PUT AC+1 INTO MEMORY ADDRESS
	POP P,ACDATA-N(P)	;GET SIGN OF ANSWER INTO BETTER PLACE
	N=N-1
	PUSH P,[XWD 344777,-1]	;SAVE A POS LOW WORD
	N=N+1
	HRLOI T,377777		;ASSUME A POSITIVE HIGH WORD
	SKIPGE ACDATA-N(P)	;SHOULD RESULT BE POSITIVE?
	KADFN T,FIXUP1-N(P)	;NO, NEGATE IT WITH KA10 DFN
	PUSH P,T		;PUT "FIXUP2" ON PDL
	N=N+1
	JRST BOTH1

MEMORY:	N=5
	MOVE T,TSAVE-N(P)
	POP P,@INST-N(P)
	N=N-1
	SUB P,[N-1,,N-1]	;LEAVE 1 ITEM ON STACK
	JRST TJFCL

IFE CPU-KI10,<
ACDOUB:	N=5
	MOVSI T,(Z 17,)		;GET ONES IN AC FIELD
	AND T,@.JBTPC		;EXTRACT AC FIELD FROM FAULTING D.P. INST
	IOR T,[DMOVE 0,[EXP <377777,,777777>,<377777,,777777>]]
	SKIPGE ACDATA-N(P)	;WAS OVERFLOW RESULT POSITIVE?
	TLC T,1000		;NO, CHANGE THE DMOVE TO DMOVN
	SUB P,[N-1,,N-1]	;LEAVE 1 ITEM ON STACK
	JRST UAC2 >		;GO FIXUP THE TWO AC'S
;THIS PAGE ONLY FOR ZEROING UNDERFLOWS

UTBL:	N=1
	JRST UAC		;ZERO AC
	JRST UACLNG		;ZERO AC, AC+1
	JRST UMEMRY		;ZERO E
	JRST UBOTH		;ZERO AC,E
	JRST UAC
	JRST UAC
	JRST UMEMRY
	;JRST UBOTH

UBOTH:	MOVE T,@.JBTPC		;GET OFFENDING INSTRUCTION
	TLZ T,777000		;ZERO OP CODE
	TLO T,(SETZB)		;CHANGE TO "SETZB AC,E"
	JRST UAC2

UMEMRY:	MOVE T,@.JBTPC
	TLZ T,777740		;ZERO OP CODE, AC FIELD
	TLO T,(SETZM)		;CHANGE TO "SETZM E"
	JRST UAC2

UACLNG:
IFE CPU-KA10,<LDB T,[POINT 4,@.JBTPC,12]	;GET AC FIELD
	DPB T,[POINT 4,T,12]	;COPY INTO AC FIELD
	ADDI T,1		;CHANGE AC TO AC+1
	TRZ T,20		;MASK TO 4 BITS
	TLO T,(SETZB) >		;CHANGE TO "SETZB AC,AC+1"
IFE CPU-KI10,<MOVSI T,(Z 17,)	;GET ONES IN AC FIELD
	AND T,@.JBTPC		;EXTRACT AC FIELD FROM FAULTING INST
	IOR T,[DMOVE 0,[EXP 0,0]] >	;SET UP A DMOVE TO CLEAR 2 AC'S
	JRST UAC2

UFSC:	MOVE	T,.JBTPC	;GET THE TRAP ADDRESS
	MOVE	T,1(T)		;GET THE INSTRUCTION FOLLOWING
	TLC	T,(JFCL (4))
	TLNN	T,777004	;JFCL (4) FOLLOWING
	JRST	UACLNG		;YES
UAC:	HLLZ T,@.JBTPC		;GET OFFENDING INSTRUCTION
	TLZ T,777037		;ZERO OP CODE, XR,@, LEAVE AC
	TLO T,(SETZ)		;CHANGE TO "SETZ AC,"
UAC2:	EXCH T,TSAVE-N(P)	;SAVE INSTRUCTION, RESTORE T
	XCT TSAVE-N(P)		;CLEAR THE REQUIRED REGISTERS

TJFCL:	N=1
	MOVEM T,TSAVE-N(P)	;SAVE T AGAIN
TJFCL1:	AOS	T,.JBTPC	;.JBTPC POINTS TO NEXT INSTRUCTION
	PUSH	P,T		;SAVE THE INSTRUCTION AFTER THE TRAP
	N=N+1
	MOVE T,(T)		;GET NEXT INSTRUCTION
	TLC T,(<JFCL>)		;COMPLEMENT "JFCL" BITS
	TLNE T,777000		;JFCL INSTRUCTION?
	JRST ERRPNT		;NO, PRINT ERROR MESSAGE
	TRNE T,-1		;ADDRESS SPECIFIED ON JFCL?
	HRRM T,(P)		;YES, GO THERE
	TLNE T,(<Z 10,(1)>)	;IS OVERFLOW BIT (OR XR1) SET IN JFCL?
	JRST ERRPNT		;YES, TYPE ERROR MESSAGE
RETURN:	MOVSI	T,337600	;MASK OUT THE FLAGS BUT LEAVE
	AND	T,.JBTPC	;CRY0, CRY1, AND USER'S IOT SET
	JRSTF	.+1(T)		;RESTORE THE HARDWARE FLAGS
	POP	P,T		;GET THE RETURN ADDRESS
	N=N-1
	EXCH	T,(P)		;RESTORE T AND SET RETURN ON THE STACK
	POPJ	P,		;RETURN TO USER
	N=N-1
ERRPNT:	ERROR	(APR,,,RETURN)		;CALL FORERR ROUTINE
REPEAT 0,<

DESCRIPTION OF "TRAPS" PROGRAM FOR LIB40-

I. THE PURPOSE OF THE TRAPS PROGRAM IS DO ERROR DETECTION,
   CORRECTION, AND REPORTING WHEN ARITHMETIC FAULTS OCCUR
   DURING THE EXECUTION OF FORTRAN PROGRAMS.

II. THE TRAPS PROGRAM CONSISTS OF THREE DISTINCT PARTS:

	A. TRPINI
		1. CALLING SEQUENCE- PUSHJ P,TRPINI
						;RETURN
		2. THE OVERFLOW COUNTER, OVCNT, (USED BY THE OVERFL
		      FUNCTION) AND THE PC WORD FLAGS ARE CLEARED
		3. PROCESSOR AND MONITOR TRAPPING ON OVERFLOW (PC WORD
		      BIT 0) IS ENNABLED

	B. "OVERFL" IS THE STANDARD FORTRAN OVERFLOW FUNCTION
	   (BUT EXISTS AS A SEPARATE FORTRAN PROGRAM ELSEWHERE
	    IN THE FORTRAN LIBRARY).
		1. CALLING SEQUENCE-	JSA 16,OVERFL
					ARG	J
						;RETURN
		2. IF OVCNT. .EQ. 0 , THEN J_1
		3. IF OVCNT. .NE. 0, THEN J_2
		4. THE OVERFLOW COUNTER, OVCNT., IS CLEARED TO 0

	C. OVTRAP IS A USER-MODE INTERRUPT ROUTINE WHICH IS STARTED
	  BY THE MONITOR WHEN AN ARITHMETIC FAULT OCCURS
		1. THE PC WORD (WITH THE ADDRESS+1 OF THE INSTRUCTION
		      CAUSING THE TRAP) REMAINS IN THE .JBTPC WORD
		2. FOR FLOATING POINT INSTRUCTIONS
			A. FOR OVERFLOWS AND DIVIDE CHECKS,
			    THE FAULTY ANSWER IS PATCHED
			   TO BE PLUS OR MINUS (THE SIGN WILL BE THAT
			   OF THE CORRECT ANSWER)THE LARGEST POSSIBLE
			   NUMBER.
			B. FOR UNDERFLOWS, THE FAULTY ANSWER IS NORMALLY
			   PATCHED TO BE 0. HOWEVER, IF THE INSTRUCTION
			   FOLLOWING THE TRAPPING INSTRUCTION IS A JFCL
			   WITH BIT 16 (XR2) SET, THE ANSWER WILL BE
			   UN-NORMALIZED ENOUGH TO BRING THE EXPONENT
			   BACK INTO RANGE.
		3. (FOR INTEGER INSTRUCTIONS, NO PATCHING OF ANSWERS
		      IS DONE.)
		4. IF THE INSTRUCTION AFTER THE TRAPPING INSTRUCTION
		      IS JFCL
		      A. DO NOT TYPE AN ERROR MESSAGE
			 UNLESS BIT 9 (AR OV TEST BIT) OR 17 (XR1) IS 1
		      B. DO NOT INDEX THE OVERFLOW COUNTER OVCNT.
		      C. IF THE ADDRESS (BITS 18-35) OF THE JFCL
			 ARE NON-ZERO, THE INTERRUPTED PROGRAM WILL
			 BE RESTARTED AT THE ADDRESS OF THE JFCL
			  (THE @ AND INDEX FIELDS ARE IGNORED).
		      D. IF THE ADDRESS OF THE JFCL IS ZERO, THE
			 INTERRUPTED PROGRAM WILL BE RESTARTED AT
			 THE JFCL
			E. IF BIT 16 (XR2) IS A 1, UN-NORMALIZE THE
			   FRACTION BITS FOR UNDERFLOWS IN ORDER TO
			   BRING THE EXPONENT BACK INTO RANGE.
			F. IF BIT 15(XR4) IS A 1, TREAT THE RESULT AS
			   D.P. (WORKS FOR FSC ONLY) (KI-10 ONLY)
		5. IF THE INSTRUCTION AFTER THE TRAPPING INSTRUCTION
		      IS NOT JFCL
		      A. INDEX THE OVERFLOW COUNTER, OVCNT
		      B. TYPE AN ERROR MESSAGE, USING SUBROUTINE "ERRMSG",
			 WITH THE FOLLOWING INFORMATION:
				FLOATING OR INTEGER FAULT
				OVERFLOW, UNDERFLOW, OR DIVIDE CHECK
				ADDRESS OF FAULTING INSTRUCTION

		      C. THE INTERRUPTED PROGRAM WILL BE RESTARTED AT
			 THE INSTRUCTION AFTER THE TRAPPING INSTRUCTION
		6. THE PROCESSOR FLAGS (PC WORD FLAGS) ARE CLEARED
			EXCEPT FOR CRY0, CRY1, AND USER IOT.
		7. THE INTERRUPTED PROGRAM IS RESTARTED

III. LIMITATIONS

	A. OVTRAP FIXUPS WILL NOT WORK ON THE PDP-6 FOR-
		1. THE LOW ORDER WORD OF FXXRL OR FXXL INSTRUCTIONS
		2. EXPONENT UNDERFLOW OR DIVIDE CHECK TRAPS

	B. FLOATING POINT FIX UPS WILL NOT OCCUR FOR INSTRUCTIONS
	   THAT ARE EXECUTED BY AN XCT OR A UUO, OR FOR INSTRUCTIONS
	   THAT ARE IN ACCUMULATOR T=14


	C. THE MEMORY FIX UPS FOR THE FLOATING POINT INSTRUCTIONS
	   WILL NOT WORK PROPERLY IF THE ANSWER IS STORED INDEXED
	   BY 17 (THE PUSH DOWN POINTER). EXAMPLES:

			FADRM AC,(17)
			FMPRB AC,-2(17)
			FDVM  AC,+1(17)

	D. THERE ARE NO FIXUPS FOR INTEGER FAULTS.
	   MOVNX AND MOVMX ARE CONSIDERED INTEGER INSTRUCTIONS AND WILL
	   HAVE NO FLOATING POINT FIX UPS IF THEY CAUSE OVERFLOW

	E. TRAPPING INSTRUCTION MUST NOT BE IN ACCUMULATOR T=14

	F. THE SIGN OF F.P. DIVIDE CHECK FIX UPS WILL BE CORRECT
	    ONLY WHEN DIVIDING BY ZERO. (THIS IMPLIES THAT THE
	    ARGUMENTS FOR DIVIDE CHECKS SHOULD BE NORMALIZED.)

	G. THE UN-NORMALIZING OF UNDERFLOWS WILL NOT WORK FOR THE
	   FLOATING "LONG" MODE OR FOR KI10 D.P. INSTRUCTIONS.

>	;END REPEAT 0

END
