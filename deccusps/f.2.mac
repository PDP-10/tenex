	SUBTTL	FX2 V.27	12-NOV-74

	;UPDATE IF COMPILER IS CHANGED

;COPYRIGHT 1971,1972,1973,1974, DIGITAL EQUIPMENT CORP., MAYNARD, MASS.
	.HWFRM		;CHANGE TO HALF WORD LISTING FORMAT "25-1"

				;REINSTATE CONFLICTING OP-CODES
	OPREST	ADD
	OPREST	SUB
	OPREST	DIV
	OPREST	AND

POPMEM:

IFNDEF	HALFWD,
<
	PHASE	0
>

IFDEF	HALFWD,
<
	LOC	0
>
LAPSAV:					;LOOK AHEAD POSITION SAVE
	XML	(LAPSML)
LAPRES:					;LOOK AHEAD POSITION RESET
	XML	(LAPRML)
DESCEN:					;DESCEND
	XIT	(DESML)
SUBSCA:					;SUBORD SCAN
	XIT	(SSCML)
OGERUN:					;OP GEN RUN
	XIT	(OGRML)
RELDIS:					;RELATIONAL OP DISPATCH
	XIT	(REDIML)
GENRUN:					;GEN RUN
	XIT	(GRUML)
SCAGEN:					;SCALE GEN
	XML	(SGEML)
BSHREF:					;BUILD SECOND HALF REF
	XML	(B2RML)
OPCHEC:					;OP CHECK
	XIT	(OCHML)
PW0OCT:				;PRINT W0 OCTAL
	XML	(PWOML)
NEXCHA:					;NEXT CHAR
	XML	(NCH0ML)
NINCHA:					;NEXT INPUT CHAR
	XML	(NIC0ML)
COCNPL:
	XML	(COCCML)	;CONVERT OCTAL CONSTANT
PRISTA:					;PRINT STATEMENT
IFNDEF	$CREF,
<
	MOA	(CRFROL)
	XMLT	(CRFML)
	JMPT	(PRISTA)
>
	XIT	(PST0ML)
BSSLIN:					;BUILD SYS SR LINK
	FET	(SYMBOL)
	NOZ	(SAV16)		;SAVE REG 16 ONLY IF SYS SUB ;"21V"
	W1	(SWT)
	BAI	(.MEI2)	;MOVEI 16 INST
			;8 LINES DELETED "25-1"
	STO	(SYMBOL)
BLKPL:					;BLK PL
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	IOR	(GSPPNT)	;GLOBAL SPROG PNTR
	JMP	(MOCOEX)	;MOVE ON CODE EXIT
DOUBUI:					;DOUBLE BUILD
	JSB	(BUIINS)	;BUILD INSTRUCTION
	MOA	(CODROL)	;CODE ROLL
	W0	(FET)		;W0
	MON	(CODROL)	;CODE ROLL
	SMK	(LBLEM)	;LBL EM
	SMKF	(APOEM)	;ADR PLUS ONE EM
	ADD	(APOSTA)	;ADR PLUS ONE STAMP
	SUBT	(RCOMAS)	;REG CORR MASK
	POCT	(ABSINS)	;ABS INST
MOCOEX:					;MOVE ON CODE EXIT
	MON	(CODROL)	;CODE ROLL
EXIT:
	XIT	(EXIML)
BUIINS:					;BUILD INSTRUCTION
	SMK	(AREEM)	;ARRAY REF EM
	JMPT	(BARREF)	;BUILD ARRAY REF
	SMK	(CONEM)	;CONST PNTR EM
	JMPT	(BCOREF)	;BUILD CONST REF
	SMK	(LDMEM)	;LOCAL DMY EM
	XITF	(BFIML)		;BUILD FINAL	;"21D"
	STK	(APAATO)	;ADR PARITY ATOM
	XW0.1	(CLA)		;LOCAL DMY TEMP RUNG
	IER	(APAEM)	;ADR PARITY EM
	XIT	(BFIML)		;BUILD FINAL	;"21D"
BHOREF:					;BUILD HOLLERITH REF
	STK	(HCOPNT)	;HOLLERITH CONST PNTR
	FET	(APNPNT)	;ARG PNTR PNTR
	W1	(SWT)		;W1
	RSV	(APNROL)	;ARG PNTR ROLL
	CFP	(APNROL)	;ARG PNTR ROLL
	FLP	(APNROL)	;ARG PNTR ROLL
	DFA	(HCOROL)	;HOLLERITH CONST ROLL
	STO	(CPOCLU)	;CONST POOL CLUE
	ISE	(CPOFIL)	;CONST POOL FILE
	JMPF	(BHORE2)	;$2
BHORE4:
	FET	(CPOPNT)	;CONST POOL PNTR
	STO	(UN2PNT)	;UNUSED 2 PNTR
	ZER	(APNPNT)	;ARG PNTR PNTR
	DNG	(APNROL)	;ARG PNTR ROLL
BHORE1:
	DFA	(APNROL)	;ARG PNTR ROLL
	FETF	(UN2PNT)	;UNUSED 2 PNTR
	RELF	(APNROL)	;ARG PNTR ROLL
	JMPF	(BHORE3)	;$3
	DNG	(CPOROL)	;CONST POOL ROLL
	POWF	(D1)		;PRUNE UNMATCHED LITERAL ;"23Z"
	JMPF	(BHORE2)
	XNIT	(CPOPNT)	;CONST POOL PNTR
	SEKT	(ZERRUN)	;ZERO RUNG
	POW	(D1)
	JMPT	(BHORE1)	;$1
	CSE	(CPOFIL)	;CONTINUE SEARCH FOR EQUALITY
	JMPT	(BHORE4)	;TRY AGAIN IF ANOTHER MATCH IS FOUND
BHORE2:
	PNG	(CPOROL)	;CONST POOL ROLL
	EAW	(CPOROL)	;CONST POOL ROLL
	CAR	(APNROL)	;ARG PNTR ROLL
BHORE3:
	W1	(SWT)		;W1
	STO	(APNPNT)	;ARG PNTR PNTR
	XIT	(BFIML)		;BUILD FINAL	;"21D"
BARREF:					;BUILD ARRAY REF
	W1	(FET)		;W1
	EOR	(REGSTA)	;REG STAMP
	W2	(SWT)		;W2
	W1	(SWT)		;W1
	JSB	(SCRGEN)	;SCRIPT GEN
	JMPF	(BARRE2)	;$2
	XW1.2	(FET)		;SCRIPT EXP RUNG
	JSB	(RSATE1)	;REG SAVE TEST $1
	XW0.0F	(ZER)		;ZERO RUNG
	W2	(FET)		;W2
	SME	(TEMEM)	;TEMP EM
	XMLF	(IITML)	;INSERT INST TAG
BARRE2:
	W1F	(SWT)		;W1
	JMPF	(BARRE3)	;$3
	W0	(FET)		;W0
	W4	(EOR)		;W4
	AND	(DISMAS)	;DISPL MASK
	SEQ	(ZERO)	;ZERO
	JSBT	(SRITGE)	;STORE REG IN TEMP GEN
	FETT	(R16PNT)	;REG 16 PNTR
	W1T	(SWT)		;W1
	BINT	(.ME0)	;MOVE INST
	XML	(IITML)	;INSERT INST TAG
	W1	(SWT)		;W1
	W2	(FET)		;W2
	IER	(REGEM)	;REG EM
	XML	(TSAML)	;TEMP STATUS ADVANCE
	JSB	(RLOGEN)	;REG LOAD GEN
BARRE3:
	W2	(STO)		;W2
	XW0.1	(FET)		;ARRAY REF OFFSET RUNG
	STO	(OAROCL)	;OBJECT ARRAY REF OFFSET CLUE
	SMK	(APOEM)	;ADR PLUS ONE EM
	DIMT	(OAROCL)	;OBJECT ARRAY REF OFFSET CLUE
	XW0.0	(CLA)		;ARRAY REF NAME RUNG
	SMK	(DMYEM)	;DMY EM
	FETT	(ZERO)	;ZERO
	SUBT	(OAROCL)	;OBJECT ARRAY REF OFFSET CLUE
	XMLT	(BIRML)	;BUILD IMMED REF ML
	SNZ	(OAROCL)	;OBJECT ARRAY REF OFFSET CLUE
	XITF	(BFIML)		;BUILD FINAL	;"21D"
	STO	(OARNCL)	;OBJECT ARRAY REF NAME CLUE
	REG	(OARFIL)	;OBJECT ARRAY REF FILE
	FET	(CREPNT)	;CRRNT REG PNTR
	XIT	(BFIML)	;BUILD FINAL
SCRGEN:					;SCRIPT GEN
	XW0.2	(FET)		;SCRIPT EXP RUNG
	SEK	(ZERO)	;ZERO
	XMLT	(P1EFML)	;POW ONE EXIT FALSE
	SMK	(DREEM)	;DO REG EM
	SMKT	(PLUEM)	;PLUS EM
	XMLT	(ETRML)	;EXIT TRUE
	ZER	(RROFLA)	;RESET REG ONE FLAG
	SON	(DITEM)	;DOUBLE ITEM EM
	FET	(RZEPNT)	;REG ZERO PNTR
	JMPF	(SCRGE1)	;$1
	XW0.1	(SNZ)		;REG ONE PNTR
	XW0.1F	(NOZ)		;ZERO RUNG
	NOZF	(RROFLA)	;RESET REG ONE FLAG
SCRGE1:
	XW0.0	(SNZ)		;ZERO RUNG
	XW0.0F	(NOZ)		;ZERO RUNG
	CLA	(EOPPNT)	;EXP OP PNTR
	W1	(SWT)		;W1
	STK	(EOPPNT)	;EXP OP PNTR
	JSB	(GENRUN)	;GEN RUN
	JSB	(GNIR0G)	;GRNTEE NOT IN REG 0 GEN
	JSB	(GIRGEN)	;GRNTEE IN REG GEN
	JSB	(GPRGEN)		;GRNTEE POS REG GEN
	W1	(SWT)		;W1
	STO	(EOPPNT)	;EXP OP PNTR
	FET	(RZEPNT)	;REG ZERO PNTR
	XW0.0F	(ZER)		;ZERO RUNG
	SNZ	(RROFLA)	;RESET REG ONE FLAG
	XW0.1T	(ZER)		;ZERO RUNG
	XML	(P1ETML)	;POW 1 EXIT TRUE
BCOREF:					;BUILD CONST REF
	SMK	(HCOEM)	;HOLLERITH CONST EM
	JMPT	(BHOREF)	;BUILD HOLLERITH REF
	SMK	(DITEM)	;DOUBLE ITEM EM
	JMPT	(DCOREG)	;DOUBLE CONST REG
	SMK	(APOEM)	;ADR PLUS ONE EM
	XW0.1T	(FET)		;ONE RUNG
	XW0.0F	(FET)		;ZERO RUNG
	SON	(LTYEM)	;LOGICAL TYPE EM
	SEKT	(TRUCON)	;TRUE CONST
	JMPT	(RABCRE)	;REG AND BUILD CONST REF
	XML	(GTOPML)	;GET OP CODE
	SEQ	(MOVINS)	;MOVE INST EM	;SEE IF MOVE INSTRUCTION
	JMPF	(TIMBUI)	;TEST IMMED BUILD	;NO, CAN'T CONVERT TO IMMEDIATE
	SMK	(RHOEM)	;RIGHT HALF ONES EM	;SEE IF X,,-1
	EAWT	(.RLOI0)	;HRLOI INST
	XITT	(BSLML)	;BUILD SWITCHED LOAD ML
	SMK	(ZRHEM)	;ZERO RIGHT HALF EM	;SEE IF X,,0
	EAWT	(.MSI0)	;HRLZI INST
	XITT	(BSLML)	;BUILD SWITCHED LOAD ML
	SMK	(LHZEM)	;LEFT HALF ZERO EM	;SEE IF 0,,X
	JMPT	(BICREF)	;BUILD IMMED CONST REF
RABCRE:					;REG AND BUILD CONST REF
	STO	(CPOCLU)	;CONST POOL CLUE
	REG	(CPOFIL)	;CONST POOL FILE
	CLA	(CPOPNT)	;CONSTANT POOL PNTR
	XIT	(BFIML)		;BUILD FINAL	;"21D"
TIMBUI:					;TEST IMMED BUILD
	XML	(GTOPML)	;GET OP CODE
	SGK	(MIMINS)	;MAX IMMED INST
	JMPT	(TSTFAD)	;TEST FLOATING INST
	POW	(D1)		;PRUNE OP CODE
	SLK	(ZERO)	;ZERO
	SGKF	(MIMADR)	;MAX IMMED ADR
	JMPT	(RABCRE)	;REG AND BUILD CONST REF
BICREF:					;BUILD IMMED CONST REF
	FET	(BICFAC)	;BUILD IMMED CONST FACTOR
	W4	(AMY)
	XIT	(BIRML)	;BUILD IMMED REF

TSTFAD:					;TEST FLOATING IMMEDIATE
	SLT	(MIFINS)	;MAX FLOATING IMMED INST

	SNZT	(PDPSW)	;TEST MACHINE TYPE

	SMKT	(ZRHEM)	;TEST RIGHT HALF ZERO
	W0T	(SWH)		;SWAP HALVES
	JMPT	(BICREF)	;BUILD IMMED CONST REF

	JMP	(RABCRE)
DCOREG:					;DOUBLE CONST REG
	XW0.1	(FET)		;ONE RUNG
	XW1.0	(FET)		;ZERO RUNG
	STK	(CPOCLU)	;CONST POOL CLUE
	ISE	(CPOFIL)	;CONST POOL FILE
	JMPF	(DCORE2)	;$2
DCORE1:
	DFA	(CPOROL)	;CONST POOL ROLL
	POWF	(D1)		;ONE
	PNGF	(CPOROL)	;CONST POOL ROLL
	STOF	(CPOPNT)	;CONST POOL PNTR
	DIMF	(CPOPNT)	;CONST POOL PNTR
	JMPF	(DCORE3)	;$3
	W2	(SEQ)		;W2
	POWT	(D2)		;TWO
	DIMT	(CPOPNT)	;CONST POOL PNTR
	JMPT	(DCORE4)	;$4
	CSE	(CPOFIL)	;CONST POOL FILE
	JMPT	(DCORE1)	;$1
DCORE2:
	PNG	(CPOROL)	;CONST POOL ROLL
	STO	(CPOPNT)	;CONST POOL PNTR
	MON	(CPOROL)	;CONST POOL ROLL
DCORE3:
	MON	(CPOROL)	;CONST POOL ROLL
DCORE4:
	CLA	(CPOPNT)	;CONST POOL PNTR
	XIT	(BFIML)		;BUILD FINAL	;"21D"
PRORUN:					;PROGRAM RUN
SCAOPE:					;SCAN OPEN
	FET	(INTEPN)	;INITIAL TEMP PNTR
	STO	(AFDTPN)	;ARITH FUNC DEF TEMP PNTR
	FET	(FALCON)	;FALSE CONST
	MON	(ICOROL)	;INT CONST ROLL
	FET	(TRUCON)	;TRUE CONST
	MON	(ICOROL)	;INT CONST ROLL
	FET	(ONE)		;ONE
	MON	(ICOROL)	;INT CONST ROLL
	FET	(TWO)		;TWO
	MON	(ICOROL)	;INT CONST ROLL
	FET	(MOSPOS)	;MOST POSITIVE
	MON	(ICOROL)	;INT CONST ROLL
	FET	(ZERO)	;ZERO
	MON	(FCOROL)	;FL CONST ROLL
	FET	(ZERO)		;"23EE"
	MON	(FCOROL)	;"23EE"
	NOZ	(FSTFLA)
	NOZ	(LOCCNT)	;LOC CNT
IFN FTMANT,<	XML	(RFSBML)	;INITIALIZE STMT LENGTHS OUTPUT
		XML	(REFSTML)>
	EAW	(NOFREG)
SCAOP1:
	JOW	(PRORU1)
	EAW	(D0)
	MON	(REGROL)
	JMP	(SCAOP1)

PRORU1:
	SNZ	(ESTFLA)
	XMLF	(NLIML)
	JMPT	(FINUP)
	SNZ	(CCAFLA)
	JSBF	(STASCA)
	JMPF	(PRORU1)
PRORU2:
	DIM	(LCANUM)
PRORU4:
	SCE	(CRR)
	JSBF	(NEXCHA)
	JMPF	(PRORU4)
	LCE	(M15QT)
	JSB	(ISTPAR)
	JSB	(PRISTA)
	JSB	(OUTCOD)
	ZER	(CCAFLA)
	XML	(NLIML)
	SNZ	(CCAFLA)
	JMPT	(PRORU2)
PRORU3:
	LCE	(M15QT)
	JSB	(PRISTA)
	JMP	(PRORU1)
SCACLO:					;SCAN CLOSE
; BUILD ENTRY AND EXIT FOR SUBS AND FUNCTS
; NAME OF PROG PNTR         ENTRY NAME EM
; R50 PROG NAME
; BEGIN EXECUTION PNTR
; RETURN PNTR
IFN FTMANT,<	SNZ	(DEBFLAG)
		XMLT	(REFSTML)	;OUTPUT LAST LENGTH BYTE
		XMLT	(RFSFML)	;FORCE END OF STMT BYTES PACKING>
	XNI	(NOPPNT)	;NAME OF PROG PNTR
	FET	(ZERRUN)	;ZERO RUNG
	SEK	(MAITES)	;MAIN. TEST
	ZERF	(MSTLOC)	;MAIN START LOC
	JMPF	(SCACL1)	;$1
	SNZ	(ENDCOD)	;END CODE ALREADY GENERATED ?	;"23P"
	JMPT	(SCACL3)	;YES, GENERATE THE RESET.	;"23P"
	LSS	(EXIT.)	;EXIT.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	FET	(CREPNT)	;CRRNT REG PNTR
	BAI	(.JSA1)	;JSA 16,INST
SCACL3:				;"23P"
	JSB	(BENHEA)	;BIN ENTRY HEADER
	MOA	(CODROL)	;CODE ROLL
	POC	(.JFCL0)		;JFCL NO-OP FOR RUN UUO ENTRIES ; "26S"
	POC	(ABSINS)	;ABSOLUTE INSTRUCTION ; "26S"
	POC	(..RES0)	;RESET. INST
	FET	(LOCCNT)	;LOC CNTR
	SNZ	(ENDCOD)	;END CODE ALREADY GENNED ?	;"23P"
	W0F	(TLY)		;NO, COUNT THE CALL TO EXIT	;"23P"

	W0	(TLY)		;AND COUNT THE JFCL ; "26S"
	STO	(MSTLOC)	;MAIN START LOC
	JSB	(BJTBEG)	;BIN JMP TO BEGINNING
	XML	(P2EML)	;PRUNE TWO EXIT
SCACL1:
	SEQ	(DATTES)	;DATA. TEST
	JSBF	(BJTRET)	;BIN JMP TO RETURN
	JSB	(BENHEA)	;BIN ENTRY HEADER
	MOAT	(CODROL)	;CODE ROLL
	MOAT	(CODROL)	;CODE ROLL
	XMLT	(P2EML)	;PRUNE TWO EXIT
	FET	(NOPPNT)	;GET NAME OF PROGRAM POINTER
	SME	(FSPEM)	;IS THIS PROGRAM A FUNCTION ?
	FTM	(SINFLA)	;YES,SET AN UNUSED FLAG
	JSB	(BSAAIA)	;BIN SAVE ACS AND INIT ARGS
	JSB	(BJTBEG)	;BIN JMP TO BEGINNING
	FET	(RETPNT)	;RETURN PNTR
	JSB	(MLBGEN)	;MADE LBL GEN
	SNZ	(MULRET)	;MULT RETURN? "22A"
	JMPF	(SCACL2)	;NO "22A"
;LINE DELETED ; "26M" 	JSB	(PTEMAK)	;PERM TEMP MAKER "22A"
;LINE DELETED ; "26M" 	DIM	(TEMCNT)	;CHANGE BACK TO END OF AC BLOCK ;"22A"
	FET	(FARTEM)		;MULT. RETURN ARG POINTER ; "26M"
	IER	(DMYEM)		;DUMMY EM ; "26M"
	STK	(RETPNT)	;RETURN PNT "22A"
	BAI	(.MEM2)		;MOVEM "22A"
SCACL2:			;"22A"
	JSB	(BREACS)	;BIN RESTORE ACS
	FET	(NOPPNT)	;NAME OF PROG PNTR
	XW0.0	(FET)		;GET THE PROGRAM NAME
	STO	(SYMBOL)	;SETUP FOR ISE SEARCH
	JSB	(TYPSET)	;GET THE PROPER TYPE "24-1"
				;LINE DELETED "24-1"
	FET	(RZEPNT)	;REG ZERO PNTR
	SRD	(GDMROL)	;GLOBAL DUMMY ROLL
	ZERF	(ARGCNT)	;ARGUMENT COUNT
	JSBT	(BREARG)	;BINARY RESTORE ARGS
	W1	(SWT)		;W1
	SMK	(FSPEM)	;FUNCT SPROG EM
	BTYT	(.ME0)	;MOVE INST
	SNZ	(MULRET)	;"22A"
	FETT	(RETPNT)	;RETURN POINT "22A"
	BAIT	(.SKG0)		;SKIPG "22A"
	FET	(ARGCNT)	;ARG CNT
	ADD	(RZEPNT)	;REG ZERO PNTR
	BAI	(.JRA1)		;JRA 16,XR16
	SNZ	(MULRET)	;"22A"
	XMLF	(P1EML)		;"22A"
	FET	(RETPNT)	;RETURN POINT "22A"
	BAI	(.ADD2)		;ADD "22A"
	POC	(ABSINS)	;ABSOLUTE INST "22A"
	POC	(.JRA2)		;JRA "22A"
	XML	(P1EML)	;PRUNE ONE EXIT

BENHEA:					;BIN ENTRY HEADER
	FET	(ELOOP)	;ENTRY LOADER OP
	MON	(CODROL)	;CODE ROLL
	FET	(RPRNAM)	;R50 PROG NAME
	IER	(ENAEM)	;ENTRY NAME EM
	MON	(CODROL)	;CODE ROLL
	XNI	(NOPPNT)	;NAME OF PROG PNTR
	FET	(ZERRUN)	;ZERO RUNG
	EAW	(PERCNT)	;PERCENT
	JSB	(ILACHA)	;INSERT LABEL CHAR
	JSB	(LBLMAK)	;LBL MAKER
	IOR	(LHAMAS)	;LEFT HALF MASK
	MON	(CODROL)	;CODE ROLL
	MON	(CODROL)	;CODE ROLL
	POC	(ABSINS)	;ABS INST
	POC	(.ARG0)	;ARG INST
	XIT	(EXIML)	;EXIT
BJTBEG:					;BIN JMP TO BEGINNING
	FET	(BEXPNT)	;BEGIN EXECUTION PNTR
	JMP	(BJTRE1)	;BIN JMP TO RETURN $1
BJTRET:				;BIN JMP TO RETURN
	SNZ	(ENDCOD)	;END CODE ALREADY GENNED ?	;"23P"
	XITT	(EXIML)		;YES, RETURN	;"23P"
	SNZ	(MULRET)	;MULTIPLE RETURN? "22A"
	POCT	(ABSINS)	;ABS INST "22A"
	POCT	(.MEI1)		;"22A"
	SNZ	(RETPNT)	;RETURN PNTR
	JSBF	(LBLMAK)	;LBL MAKER
	STKF	(RETPNT)	;RETURN PNTR
	FETT	(RETPNT)	;RETURN PNTR
BJTRE1:
	BAI	(.JRST0)	;JRST INST
	XIT	(EXIML)	;EXIT
BSAAIA:					;BIN SAVE ACS AND INIT ARGS
	FET	(RZEPNT)	;REG O PNTR
	JSB	(BSRGEN)	;BLOCK SAVE REGS GEN
	FET	(TEMCNT)	;TEMP CNT
	IER	(PTEEM)	;PERM TEMP EM
	STK	(FARTEM)	;FIFTEEN ARG TEMP
	SRD	(GDMROL)	;GLOBAL DMY ROLL
	XITF	(P1EML)
	BAI	(.MEI0)
INIARG:					;INIT ARGS
	FET	(RZEPNT)	;START INDEXING AT 0(16)
	ZER	(GDMPNT)	;GLOBAL DMY PNTR
	JMP	(INIAR2)	;$2

INIAR3:
	POW	(D1)
	BIK	(.PSH1)
INIAR1:
	W0	(TLY)		;W0
INIAR2:
	DFA	(GDMROL)	;GLOBAL DMY ROLL
	ZER	(DSPFLA)	;DUMMY SPROG FLAG
	XMLF	(P1EML)	;PRUNE ONE EXIT
	SEK	(ASTERX)	;ASTERISK? "22A"
	STO	(SYMBOL)	;SYMBOL
	JMPT	(INIAR1)	;YES GO BACK "22A"
	ISE	(GSPFIL)	;GLOBAL SPROG FILE
	FETT	(CREPNT)	;CRRNT REG PNTR
	IPKT	(APNEM)	;ALLOC PNTR EM
	NOZT	(DSPFLA)	;DUMMY SPROG FLAG
	JSB	(IDCLAS)	;ID CLASSIFY
	JSBF	(REGSCA)	;REGISTER SCALAR
	SNZ	(DSPFLA)	;DUMMY SPROG FLAG
	W1T	(SWT)		;W1
	XNI	(GDMPNT)	;GLOBAL DMY PNTR
	STK	(ZERRUN)	;ZERO RUNG
	POWT	(D1)		;ONE
	JSB	(PTEMAK)	;PERM TEMP MAKER
	IOR	(CMUEM)	;CONST MULTIPLIER EM
	STO	(DAT1)	;DATA 1
	PNG	(GALROL)	;GENERAL ALLOC ROLL
	AGF	(GALFIL)	;GENERAL ALLOC FILE
	IER	(APNEM)	;ALLOC PNTR EM
	XW1.0	(STO)		;ZERO RUNG
	SNZ	(DSPFLA)	;DUMMY SPROG FLAG
	JMPT	(INIAR3)	;$3
	SMK	(SCAEM)	;SCALAR EM
	JMPF	(INIAR3)	;$4
INIAR4:
	W2	(SWT)		;W2
	W1	(SWT)		;W1
	BIK	(.PSH2)	;PUSH* XR16 INST
	W1	(SWT)		;W1
	W2	(SWT)		;W2
	SME	(DITEM)	;DOUBLE ITEM EM
	JMPF	(INIAR1)	;$1
	BAK	(.RRZ1)	;HRRZ 1 XR16 INST
	POC	(ABSINS)	;ABS INST
	POC	(.PSH3)	;PUSH 0 11 XR1 INST
	JSB	(PTEMAK)	;PERM TEMP MAKER
	POW	(D1)		;ONE
	JMP	(INIAR1)	;$1
BREARG:					;BIN RESTORE ARGS
	FET	(TEMCNT)	;TEMP CNT
	IER	(PTEEM)	;PERM TEMP EM
	CNT	(DEFROL)	;HOW MANY ARGS DEFINED ? ;"22P"
	SEQ	(ZERO)		;NONE ? ;"22P"
	POWT	(D1)		;YES, PRUNE TEMP POINTER ;"22P"
	BINF	(.RROI0)	;NO, HRROI 0 INST ;"22P"
	CNT	(GDMROL)	;GLOBAL DMY ROLL
	STK	(ARGCNT)	;ARG CNT
	ADD	(BREPNT)	;BLANK REG PNTR
BREAR1:
	ZER	(TEMP)	;CLEAR SUBI COUNT
BREAR2:
	SUB	(ONE)		;DECREMENT REG COUNT
	MOA	(GDMROL)	;GLOBAL DMY ROLL
	RELF	(DEFROL)	;RELEASE AERROL FOR FUTURE USE
	XITF	(P1EML)	;PRUNE ONE EXIT
	SEK	(ASTERX)	;ASTERISK? "22A"
	JMPT	(BREAR3)	;YES "22A"
	SMK	(SCAEM)	;SCALAR EM
	TLYF	(TEMP)		;ONLY SCALARS ARE ELIGABLE FOR ;"22P"
	POWF	(D1)		;RESTORATION ;"22P"
	JMPF	(BREAR2)	;SKIP IF NOT ELIGABLE ;"22P"
	XW0.0T	(FET)		;YES, GET NAME
	XW0.0T	(CLA)		;GET NAME ENTRY
	STOT	(SYMBOL)	;AND STORE FOR SEARCH
	ISET	(DEFFIL)	;HAS IT BEEN DEFINED ?
	JMPT	(BREAR4)	;YES, SKIP AROUND ;"22P"
	TLYF	(TEMP)		;INCREMENT SUBI COUNT
	SMK	(DITEM)		;DOUBLE ARG?"22P"
	TLYT	(TEMP)		;YES, INCREMENT SUBI COUNT "22P"
	POW	(D1)
	JMP	(BREAR2)
BREAR4:			;"22P"
	SNZ	(TEMP)
	FETT	(TEMP)
	ADDT	(RZEPNT)
	BAIT	(.SUBI0)	;SUBI 0,0
	SME	(DITEM)	;DOUBLE ITEM EM
	BAKT	(.RRO1)	;HRRO 1 XR16 INST
	POCT	(ABSINS)	;ABS INST
	POCT	(.POP1)	;POP 0 1 XR1 INST
	BIK	(.POP2)	;POP* XR16 INST
	JMP	(BREAR1)	;$1
BREAR3:
	POW	(D1)		;PRUNE ASTERISK "22A"
	JMP	(BREAR2)	;BACK "22A"
				;22 LINES DELETED	;"23C"
BREACS:				;BIN RESTORE ACS
	FET	(ABLPNT)	;GET AC BLOCK PNTR ;"21V"
	SNZ	(SINFLA)	;FUNCTION ? ;"21V"
	JMPF	(BREAC1)	;NO, RESTORE AC15/16 ONLY ;"21V"
	FET	(REGCNT)	;GET # OF CONTIGUOUS REGS ;"21V"
	SGT	(THREE)		;BLT OVERHEAD REQUIRED ? ;"21V"
	JMPF	(BREAC3)	;NO, GEN MOVE'S ;"21V"
	FET	(RONPNT)	;MAKE END OF REGS ;"21V"
	ADD	(REGCNT)	;POINTER ;"21V"
	W0	(TLY)		;CORRECTLY ;"21V"
	W1	(SWT)		;AND POSITION IT FOR THE BIK ;"21V"
	BIK	(.MSI0)		;GEN MOVSI END REG,BLOCK
	W1	(SWT)		;SAVE BLOCK PNTR FOR FUTURE USE ;"21V"
	FET	(RZEPNT)	;FAKE AN IMMEDIATE ;"21V"
	ADDA	(D2)		;MODE 2 ;"21V"
	BIN	(.HRRI0)	;GEN HRRI END REG,2 ;"21V"
	W0	(FET)		;GET END REG PNTR ;"21V"
	BIN	(.BLT0)		;GEN BLT END REG,END REG ;"21V"
	POW	(D1)		;PUT BLOCK PNTR BACK ON TOP ;"21V"
	W0	(TLY)		;MAKE PNTR COME OUT RIGHT ;"21V"
BREAC1:				;$1, TRY TO RESTORE AC15/16 ;"21V"
	ADDT	(REGCNT)	;POINT TO REG15 LOC ;"21V"
				;2 LINES DELETED "24-2"
	BAK	(.ME1)		;GEN MOVE 15,TEMP. ;"21V"
	W0	(TLY)		;POINT TO REG 16 LOC ;"21V"
BREAC2:			;$2, RESTORE AC16 ;"21V"
				;2 LINES DELETED "24-2"
	FET	(R16PNT)	;GET REG 16 PNTR ;"21V"

	W1	(SWT)		;PUT IN PROPER ORDER ;"21V"
	BIN	(.ME0)		;GEN MOVE 16,TEMP. ;"21V"
	XIT	(P1EML)		;EXIT PRUNING TEMP PNTR ;"21V"
BREAC3:				;$3, RESTORE WITH MOVE'S ;"21V"
	SNZ	(REGCNT)	;ANY REGS SAVED ? ;"21V"
	JMPF	(BREAC1)	;NO, TRY AC 15/16 ;"21V"
	FET	(RONPNT)	;GET REG ONE PNTR ;"21V"
	FET	(REGCNT)	;GET # OF REGS SAVED ;"21V"
	W2	(SWT)		;PUT IN PROPER ORDER ;"21V"
BREAC4:				;$4, ITERATION POINT ;"21V"
	W2	(DIM)		;DECREMENT REG COUNT ;"21V"
	W1	(TLY)		;INCREMENT REG COUNT ;"21V"
	BIK	(.ME0)		;GEN MOVE 2/3/4,BLOCK/+1/+2 ;"21V"
	W0	(TLY)		;INCREMENT TEMP PNTR ;"21V"
	W2	(SNZ)		;MORE REGS TO RESTORE ? ;"21V"
	JMPT	(BREAC4)	;YES, RESTORE THEM ;"21V"
	W2	(SWT)		;PUT COUNT ON TOP ;"21V"
	POW	(D2)		;PRUNE COUNT & REG PNTR ;"21V"
	JMP	(BREAC1)	;"21V"
				;LINE DELETED	;"23C"
STASCA:					;STA SCAN
	FEX	(SSCFIN)	;STA SCAN FINISH
	XML	(RREML)	;REGS RESET
	ZER	(FAICAR)	;FAIL CARD-COL
	FET	(AFDTPN)	;ARITH FUNC DEF TEMP PNTR
	STO	(LTEPNT)	;LOCAL TEMP PNTR
	SCK	(COMKEY)	;COMMENT KEY
	SCEF	(CRR)		;CARRIAGE RETURN
	JMPT	(SSCFIN)	;STA SCAN FINISH
	JSB	(LFIXLA)	;LBL FIELD XLATE
	ZER	(IOLFLA)	;IOL FLAG
	ZER	(ISAFLA)	;IF STA ACTIVE FLAG
	RSV	(ERRROL)
	SCE	(CRR)		;DID LFIXLA FIND A <CR> ?	;"23E"
	JMPT	(LIAOL)		;YES, IF WITH LABEL, IT'S ILLEGAL  "27C"
	JSB	(STAXLA)	;NO, STA XLATE

SSCFIN:					;STA SCAN FINISH
	RSV	(LIMROL)	;LIMITS ROLL
	EAW	(LIMROL)	;LIMITS ROLL
	CAR	(ERRROL)	;ERROR ROLL
	EAW	(ERRROL)	;ERROR ROLL
	CAR	(LIMROL)	;LIMITS ROLL
	SNZ	(FORFLA)	;FORMAT STA FLAG
	ZERT	(FORFLA)	;FORMAT STA FLAG
	JSBF	(PRISTA)	;PRINT STATEMENT
	REL	(ERRROL)	;ERROR ROLL
	JSB	(OUTCOD)	;OUTPUT CODE
	REL	(TEMROL)	;TEMP ROLL
	REL	(SUBROL)	;SUBEXP ROLL
	REL	(APLROL)	;ARG PLEX ROL "20E"
	XIT	(EXIML)	;EXIT
LFIXLA:					;LBL FIELD XLATE

	ZER	(SLBXLF)	;[354] CLEAR S-24 ERROR FLAG
	JSB	(DCOINI)
	XML	(LFXML)
	JMPF	(LFIXL3)	;$3
IFNDEF	$CREF,
<
	SNZ	(CRFSW)
	FETT	(DAT2)
	XMLT	(BTBCML)
	MONT	(CRFROL)
>
	REG	(LBLFIL)	;LBL FILE
	CLA	(LBLPNT)	;LBL PNTR
	SPKT	(DEFTRA)	;DEFINED TRAIT
	IPKT	(MDETRA)	;MUL DEFINED TRAIT
	IPKF	(DEFTRA)	;DEFINED TRAIT
	MOA	(DLOROL)	;DO LOOPS OPEN ROLL
	STKT	(SLBPNT)	;STA LBL PNTR
	MONT	(DLOROL)	;DO LOOPS OPEN ROLL
	SMKT	(SLPEM)	;STA LBL EM
;FOUND A STATEMENT NUMBER, WE CAN'T ASSUME THAT THE DO VARIABLE IS STILL IN THE REGISTER
	ZERF	(IIVPNT)	;INSIDE INDUC VAR PNTR
	NOZ	(SLBXLF)	; SUCCESSFUL LABEL XLATE "27C"
LFIXL3:
	STO	(SLBPNT)	;STA LBL PNTR
	JMP	(ICLGEN)	;IF CLOSE GEN

;
; THE FOLLOWING IS PATCH 27C;  A LABEL ALONE ON A LINE IS ILLEGAL.
;

LIAOL:				;LABEL ILLEGAL ALONE ON LINE  "27C"
	SNZ	(SLBXLF)	;LABEL?  "27C"
	JMPF	(SSCFIN)	;NO, CONTINUE STA  "27C"
	ZER	(SLBXLF)	;CLR FLAG  "27C"
	LCE	(S24QT)		;ERROR  "27C"
	JSB	(ISTPAR)	;IGNORE THE REST OF THE STATEMENT  "27C"
	JMP	(SSCFIN)	;AND FINISH THE LINE  "27C"
STAXLA:					;STA XLATE
IFN FTMANT,<	JSB	(OUTCOD)	;MAKE SURE WE OUTPUT JUMPS
		SNZ	(DEBFLAG)	;NOTE STMT LENGTH
		XMLT	(REFSTML)	; FOR DEBUGGER>
	XML	(SSAML)	;STATUS CONTROL
	FEX	(MPRXLA)	;MAIN PROGRAM XLATE
	SCE	(S)		;S
	JMPT	(SSTXLA)	;SUBROUTINE STA XLATE
	SCE	(F)		;F
	JMPT	(FSTXLA)	;FUNCTION STA XLATE
	SCE	(I)		;I
	JMPT	(IFSXLA)	;INTEGER FUNCTION STA XLATE
	SCE	(R)		;R
	JMPT	(RFSXLA)	;REAL FUNCTION STA XLATE
	SCE	(D)		;D
	JMPT	(DPFSXL)	;DOUBLE PREC FUNCTION STA XLATE
	SCE	(C)		;C
	JMPT	(CFSXLA)	;COMPLEX FUNCTION STA XLATE
	SCE	(L)		;L
	JMPT	(LFSXLA)	;LOGICAL FUNCTION STA XLATE
IFNDEF	$DATA,
<
	SCE	(B)		;B
	JMPT	(BDSXLA)	;BLOCK DATA STA XLATE
>
	JMP	(MPRXLA)	;MAIN PROGRAM XLATE
SSTXLA:					;SUBROUTINE STA XLATE
	QSF	(SUBQT)	;SUBROUTINE QT
	JSB	(SYMSCA)	;SYMBOL SCAN
	JSB	(REGSCA)	;REGISTER SCALAR
	CSA	(LPAREN)	;L PAREN
	JMPF	(SHEEXI)	;SPROG HEAD EXIT
	JMP	(DSESCA)	;DMY SEQ SCAN

IFNDEF	$DATA,
<
BDSXLA:					;BLOCK DATA STA XLATE
	QSF	(BLOQT)	;BLOCK QT
	CSF	(D)		;D
	QSF	(ATAQT)	;ATA QT
	SCE	(CRR)
	CCFF	(S22QT)		;SYNTAX QT	;"23M"
	SNZ	(FSTFLA)	;FIRST STA FLAG
	LCFF	(O1QT)	;ORDER QT
	LSS	(DAT.)
	NOZ	(BDPFLA)	;BLOCK DATA PROG FLAG
	JMP	(HSTFIN)	;HEAD STA FINISH
>

IFSXLA:					;INTEGER FUNCTION STA XLATE
	QSF	(INTQT)
	CSA	(ASTERI)	;INTEGER=	;"23G"
	CSA	(N2)		;INTEGER*2	;"23G"
	FTM	(SINFLA)	;"23G"
	CSA	(N4)		;OR INTEGER*4	;"23G"
	JSB	(FNASCA)	;FUNCTN NAME SCAN
	AGF	(IIDFIL)	;INTEGER ID FILE
	SNZ	(SINFLA)	;SUBSCRIPT INTEGER ? ;"23G"
	AGFT	(SIIFIL)	;YES, DEFINE IT ;"23G"
	JMP	(FDSSCA)	;FUNCTION DMY SEQ SCAN
RFSXLA:					;REAL FUNCTION STA XLATE
	QSF	(REAQT)		;REAL QT
	CSA	(ASTERI)	;REAL=	;"23G"
	CSAT	(N8)		;REAL*8 ?	;"23G"
	JMPT	(DPFSX1)	;YES, DOUBLE PRECISION=REAL*8	;"23G"
	CSA	(N4)		;REAL*4	;"23G"
	JSB	(FNASCA)	;FUNCTN NAME SCAN
	AGF	(RIDFIL)	;REAL ID FILE
	JMP	(FDSSCA)	;FUNCTION DMY SEQ SCAN
DPFSXL:					;DOUBLE PREC FUNCTION STA XLATE
	QSF	(DPRQT)	;DOUBLE PRECISION QT
DPFSX1:			;"23G"
	JSB	(FNASCA)	;FUNCTN NAME SCAN
	AGF	(DPIFIL)	;DOUBLE PREC ID FILE
	JMP	(FDSSCA)	;FUNCTION DMY SEQ SCAN
CFSXLA:					;COMPLEX FUNCTION STA XLATE
	QSF	(COMPQT)	;COMPLEX QT
	CSA	(ASTERI)	;COMPLEX=	;"23G"
	CSAT	(N1)		;"23G"
	SCET	(N6)		;COMPLEX*16 ?	;"23G"
	CCFT	(S5QT)		;YES, ILLEGAL TYPE SPECIFICATION
	CSA	(N8)		;COMPLEX*8	;"23G"
	JSB	(FNASCA)	;FUNCTN NAME SCAN
	AGF	(CIDFIL)	;COMPLEX ID FILE
	JMP	(FDSSCA)	;FUNCTION DMY SEQ SCAN
LFSXLA:					;LOGICAL FUNCTION STA XLATE
	QSF	(LOGQT)
	CSA	(ASTERI)	;LOGICAL=	;"23G"
	CSA	(N1)		;LOGICAL*1	;"23G"
	CSA	(N4)		;OR LOGICAL*4	;"23G"
	JSB	(FNASCA)	;FUNCTN NAME SCAN
	AGF	(LIDFIL)	;LOGICAL ID FILE
	JMP	(FDSSCA)	;FUNCTION DMY SEQ SCAN
FSTXLA:					;FUNCTION STA XLATE
	JSB	(FNASCA)	;FUNCTN NAME SCAN
FDSSCA:					;FUNCTION DMY SEQ SCAN
	CSF	(LPAREN)	;L PAREN
	JSB	(REGSCA)	;REGISTER SCALAR
	IER	(FSPEM)	;FUNC SPROG EM
DSESCA:					;DMY SEQ SCAN
	CSA	(DOLLAR)	;$? "22A"
	CSAF	(ASTERI)	;*? "22A"
	FETT	(ASTERX)	;ASTERISK "22A"
	MONT	(GDMROL)	;"22A"
	NOZT	(MULRET)	;SET FOR MULTIPLE RETURN "22A"
	JMPT	(DSESC1)	;"22A"
	JSB	(IDSCAN)	;ID SCAN
	REGF	(GDMFIL)	;GLOBAL DMY FILE
	LCFT	(I1QT)	;ID CONFLICT QT
DSESC1:				;"22A"
	CSA	(COMMA)	;COMMA
	JMPT	(DSESCA)	;DMY SEQ SCAN
	CSF	(RPAREN)	;R PAREN
SHEEXI:					;SPROG HEAD EXIT
	SCE	(CRR)
	CCFF	(S22QT)		;SYNTAX QT	;"23M"
	SNZ	(FSTFLA)	;FIRST STA FLAG
	LCFF	(O2QT)	;ORDER QT
	XW0.0	(FET)		;ZERO RUNG
	STO	(SYMBOL)	;SYMBOL
	STO	(NOPPNT)	;NAME OF PROG PNTR
IFN FTMANT,<	SNZ	(DEBFLAG)	;OUTPUT PROGRAM NAME
		XNIT	(NOPPNT)
		FETT	(ZERRUN)
		XMLT	(ST5RML)
		XMLT	(RFPML)>
HSTFIN:					;HEAD STA FINISH
	JSB	(GHEGEN)	;GLOBAL HEAD GEN
	XML	(SSAML)	;STATUS CONTROL
	XIT	(ETRML)	;EXIT TRUE EOL
FNASCA:					;FUNCTN NAME SCAN
	QSF	(FUNQT)	;FUNCTION QT
SYMSCA:
	ZER	(SYMBOL)
	SCK	(LETKEY)
	XITF	(NFAML)
	XML	(SYMSML)	;SYMBOL SCAN
IFNDEF	$CREF,
<
	SNZ	(CRFSW)
	FETT	(SYMBOL)
	MONT	(CRFROL)
>
	XIT	(EXIML)

IIAEXI:					;ILLEGAL IF ARG EXIT
	LCE	(M4QT)	;ILLEGAL IF ARG QT
	XIT	(IIAXML)	;$1

	POW	(D3)		;THREE
	REL	(CODROL)	;CODE ROLL
	JMP	(ISTPAR)	;ILLEGAL STA PARSE
MPRXLA:					;MAIN PROGRAM XLATE
	SNZ	(FSTFLA)	;FIRST STA FLAG
	LSST	(MAIN.)	;MAIN.
	JSBT	(GHEGEN)	;GLOBAL HEAD GEN
IASXLA:					;IF ARG STA XLATE
	XMLT	(SSAML)	;STATUS CONTROL
	FEX	(FEXFDG)	;ASSIGNMENT OR AFDS XLATE
	CSA	(G)		;G
	JMPT	(GTOGRO)	;GO TO GROUP
	CSA	(D)		;D
	JMPT	(DODODI)	;DO OR DATA OR DIMENSION
ISTXLA:					;IF STA XLATE
	QSF	(IF.QT)	;IF(QT
	JSB	(ESACOL)	;EXP SCAN AND COLLAPSE
	CSF	(RPAREN)	;R PAREN
	SCK	(DIGKEY)	;DIGIT KEY
	JMPF	(LISXLA)	;LOGICAL IF STA XLATE
	JSB	(EIRGEN)	;EXP IN REG GEN
	SMK	(CTYEM)	;COMPLEX EXPRESSION?
	LCFT	(M4QT)	;YES, ERROR
	JSB	(LBLSCA)
	CSF	(COMMA)
	AND	(RHAMAS)
	JSB	(LBLSCA)
	SCE	(CRR)		;"23HH"
	ANDT	(RHAMAS)	;"23HH"
	W0T	(FET)		;"23HH"
	JMPT	(ISTXL1)	;"23HH"
	CSF	(COMMA)
	AND	(RHAMAS)
	JSB	(LBLSCA)
	SCE	(CRR)
	CCFF	(S10QT)
	AND	(RHAMAS)	;RIGHT HALF MASK
ISTXL1:				;"23HH"
	W3	(FET)		;W3
	SME	(MINEM)	;MINUS EM
	W2T	(SWT)		;W2
	NOZ	(ISAFLA)	;IF STA ACTIVE FLAG
	JMP	(GEXFIN)	;GOTO EXIT FIN
LISXLA:					;LOGICAL IF STA XLATE
	SCE	(EQUAL)
	XITT	(FAIML)		;FAIL	;"23A"
	JMPT	(FAIL)	;FAIL
	ZER	(IIAFLA)	;ILLEGAL IF ARG FLAG
	FET	(SLBPNT)	;STA LBL PNTR
	W1	(SWT)		;W1
	JSB	(LAPSAV)	;LOOK AHEAD POSITION SAVE
	QSA	(GOTQT)	;GOTO QT
	SCKT	(DIGKEY)	;DIGIT KEY
	JSBF	(LAPRES)	;LOOK AHEAD POSITION RESET
	NOZT	(IIAFLA)	;ILLEGAL IF ARG FLAG
	SMK	(SUBEM)	;SUBEXP EM
	SPKT	(OTAEM)	;OP TABLE EM
	XW0.0T	(FET)		;OP PNTR RUNG
	SPTT	(ROPTRA)	;REL OP TRAIT
	JMPT	(LISXL3)	;$3
	JSB	(EIRGEN)	;EXP IN REG GEN
	SNZ	(IIAFLA)	;ILLEGAL IF ARG FLAG
	EORT	(NOTMAS)	;NOT MASK
	SMK	(NOTEM)	;NOT EM
	EAWT	(.JUL0)	;JUMPL INST
	EAWF	(.JUGE0)	;JUMPGE INST
	JMP	(LISXL2)	;$2
LISXL3:
	XW0.1	(FET)		;A PART RUNG
	XW1.2	(FET)		;B PART RUNG
	XW2.0	(FET)		;OP PNTR RUNG
	STK	(EOPPNT)	;EXP OP PNTR
	JSB	(RELDIS)	;RELATIONAL OP DISPATCH
	W0	(FET)		;W0
	SNZ	(IIAFLA)	;ILLEGAL IF ARG FLAG
	EORT	(SEVEN)	;SEVEN
	W5	(EOM)		;W5
	SEQ	(ZERO)	;ZERO
	JSBT	(RELGE9)	;REL GEN $9
	POW	(D1)		;ONE
	EAWT	(.JRST0)	;JRST INST
	EAWF	(.JUG0)	;JUMPG INST
	W3F	(AMY)		;W3
	W3T	(STO)		;W3
	CLAT	(RZEPNT)	;REG ZERO PNTR
	W3	(STO)		;W3
	POW	(D1)		;ONE
LISXL2:
	W1	(SWT)		;W1
	SNZ	(IIAFLA)	;ILLEGAL IF ARG FLAG
	ZER	(IIAFLA)	;ILLEGAL IF ARG FLAG
	JSBT	(LBLSCA)	;LBL SCAN
	NOZT	(JOUFLA)	;JUMP OUT FLAG
	JSBF	(LBLMAK)	;LBL MAKER
	STKF	(SLBPNT)	;STA LBL PNTR
	W2	(FET)
	XML	(BINIML)
	JMPT	(LISXL1)	;$1
	FET	(ASTFLA)	;ACTIVE STA FLAG
	NOZ	(ASTFLA)	;ACTIVE STA FLAG
	XML	(RREML)	;REG RESET
	REL	(SUBROL)	;SUBEXP ROLL
	JSB	(IASXLA)	;IF ARG STA XLATE
	JSB	(DISTES)	;DOUBLE IF STA TEST
	STO	(ASTFLA)	;ACTIVE STA FLAG
	FET	(SLBPNT)	;STA LBL PNTR
	JSB	(MLBGEN)	;MADE LBL GEN
LISXL1:
	POW	(D2)		;TWO
	STO	(SLBPNT)	;STA LBL PNTR
	JMPF	(ISTPAR)	;ILLEGAL STA PARSE
	SNZ	(IIAFLA)	;ILLEGAL IF ARG FLAG
	JMPT	(IIAEXI)	;ILLEGAL IF ARG EXIT
	JMP	(LIFEXI)	;LOGICAL IF EXIT
DODODI:					;DO OR DATA OR DIMENSION
	CSA	(O)		;LETTER O
	JMPF	(DORDIM)	;DATA OR DIMENSION
DSTXLA:					;DO STA XLATE
	JSB	(LBLSCA)	;LBL SCAN
	JSB	(IVASCA)	;INDUC VAR SCAN
	JSB	(DCOXLA)	;DO CONTROL XLATE
	MON	(DLOROL)	;LABEL OF DO CLOSE
	JMP	(DOEOEX)	;DO EOL EXIT
DCOXLA:					;DO CONTROL XLATE
	FET	(LACCCN)	;FETCH CURRENT CHARACTER POINTER ; "26E"
	STO	(TEMP)		;STORE IT IN TEMP ; "26E"
	CSF	(EQUAL)	;EQUAL
	NOZ	(SAV15)		;SAVE REG 15 ONLY IF USED ;"21V"
	ISE	(GDMFIL)	;GLOBAL DEFINITION ?
	REGT	(DEFFIL)	;YES, REGISTER AS DEFINED
	JSB	(FESACO)	;FX EXP SCAN AND COLLAPSE
	JSB	(STATCK)	;"23S"
				;4 LINES DELETED "24-3"
	CSF	(COMMA)		;COMMA ;W0_INDEX
				;10 LINES REMOVED ;"23S"
				; LINE DELETED ;"23S"
	JSB	(EXPSCA)	;EXP SCAN ;W0_FINAL
	SMK	(ITYEM)	;INTEGER TYPE EM
	LCFF	(M12QT)		;NON-INTEGER ERR "20F"
;
;PREVENT NESTED DO LOOPS FROM USING THE SAME INDEX VARIABLE ; "26E"
;
	W2	(FET)		;GET POINTER TO INDEX;"26E"
	STO	(REGTEM)	;STORE IT IN REGTEM;"26E"
	XML	(DLUSML)	;CHECK IF INDEX IS ALREADY IN USE ; "26E"
	JMPF	(DCOXL1)	;NOT IN USE, CONTINUE SCAN;"26E"
	FET	(LACCCN)	;IT IS IN USE, STORE CURRENT LOCATION ; "26E"
	FET	(TEMP)		;FETCH LOCATION OF VARIABLE CAUSING ERROR ; "26E"
	STO	(LACCCN)	;RESET TO THAT ERROR LOCATION ; "26E"
	LCE	(M21QT)		;AND GIVE ERROR MESSAGE ; "26E"
	STO	(LACCCN)	;RESTORE CURRENT LOCATION ; "26E"
	FEX	(JMPIST)	;SET FAIL EXIT TO ILL STMNT PARSE;"26E"
	XIT	(FAIML)		;FAIL EXIT;"26E"
JMPIST:	JMP	(ISTPAR)	;IGNORE REST OF STATEMENT ; "26E"
DCOXL1:
;
;END OF THIS PART OF PATCH LEVEL 26E-14/15.
;
	CSA	(COMMA)	;COMMA
	RSVT	(NESROL)	;SUBCOL WILL RELEASE THIS; "26R"
	JSBT	(FESACO)
	FETF	(CONPNT)	;CONST ONE PNTR ;W0_INCR
	W1	(SWT)		;W1
	JSB	(SUBCOL)	;SUBEXP COLLAPSE
	SMK	(SCAEM)		;6 LINES INSERTED ;"23S"
	SMKF	(CONEM)		;"23S"
	JMPT	(DCOXL2)	;"23S"
	JSB	(STATCK)	;"23S"
	JSB	(EIRGEN)	;"23S"
	JSB	(PTEMAK)	;"23S"
	BIK	(.MEM0)		;"23S"
	W1	(STO)		;"23S"
DCOXL2:				;FINAL_SCALAR OR TEMP ;"23S"
	W1	(SWT)		;W1
	SMK	(SCAEM)		;7 LINES INSERTED ;"23S"
	SMKF	(CONEM)		;"23S"
	JMPT	(DCOXL3)	;"23S"
	JSB	(STATCK)	;"23S"
	JSB	(EIRGEN)	;"23S"
	JSB	(PTEMAK)	;"23S"
	BIK	(.MEM0)		;"23S"
	W1	(STO)		;"23S"
DCOXL3:				;INCR_SCALAR OR TEMP ;"23S"
	W1	(SWT)		;W0_FINAL;W1_INCR;"24-3"
	W2	(SWT)		;W0_INIT;W1_INCR;W2_FINAL ;"24-3"
	JSB	(GENRUN)	;GEN RUN ;"24-3"
	SMK	(MINEM)		;MINUS EM ;"24-3"
	BAIT	(.MN1)		;MOVN DO REG INST ;"24-3"
	BAIF	(.ME1)		;"24-3"
	W2	(FET)		;W0_INDEX ;"23S"
	JSB	(LBLMAK)	;LBL MAKER ;10 LINES REPLACED ;"23S"
	JSB	(MLBGEN)	;MADE LBL GEN ;"23S"
	FET	(DREPNT)	;DO REG PNTR ;"23S"
	W1	(SWT)		;W1 ;"23S"
	BIK	(.MEM0)	;MOVEM INST ;"23S"
	W1	(STO)		;W1 ;"23S"
	STK	(IIVPNT)	;INSIDE INDUC VAR PNTR ;"23S"
	JSB	(LBLMAK)	;LBL MAKER ;"23S"
	JSB	(MLGAKE)	;W0_MADE LBL ;"23S"
	RSV	(DLOROL)	;DO LOOPS OPEN ROLL ;10TH LINE REPLACED ;"23S"
	W3	(SWT)		;W3_MADE LABEL;W0_FINAL ;"23S"
	W2	(SWT)		;W2_FINAL;W0_INCR ;"23S"
	W1	(STO)		;PRUNE EXTRA INDEX ;"23S"
;'2 LINES DELETED	;"23S"
	MON	(DLOROL)	;INCREMENT EXP PNTR
	MON	(DLOROL)	;FINAL VALUE EXP PNTR
	MON	(DLOROL)	;MADE LABEL TO RETURN TO
	MON	(DLOROL)	;INDEX VAR PNTR
	FET	(JOUFLA)	;JUMP OUT FLAG
	MON	(DLOROL)	;DO LOOPS OPEN ROLL
	ZER	(JOUFLA)	;JUMP OUT FLAG
	NOZ	(SAV15)		;SAVE REG 15 ONLY IF DO OR IMPLIED DO ;"21V"
	XIT	(EXIML)	;EXIT

STATCK:				;"23S"
	SNZ	(IMDFLG)	;INSIDE IMPLIED DO? "23S"
	SMKT	(SUBEM)		;YES, PNTR TO SUBEXP?"23S"
	XITF	(EXIML)		;NO "23S"
	XW0.3	(FET)		;GET STATUS RUNG "23S"
	SME	(REGEM)		;EXP IN REG? "23S"
	XW0.3T	(ZER)		;YES SET STATUS ZERO "23S"
	XIT	(EXIML)		;"23S"
DORDIM:					;DATA OR DIMENSION
IFNDEF	$DATA,
<
	CSA	(I)		;I
	JMPF	(DASTXL)	;DATA STA XLATE
>
IFDEF	$DATA,
<
	CSF	(I)
>

DISTXL:					;DIMENSION STA XLATE
	QSF	(MENQT)	;MENSION QT
DISTX1:
	JSB	(IDSCAN)	;ID SCAN
	CCFT	(I2QT)	;ID CONFLICT QT
	CSF	(LPAREN)	;LEFT PAREN
	JSB	(DSEXLA)	;DIMENSION SEQ XLATE
	CSA	(COMMA)	;COMMA
	JMPT	(DISTX1)
				;LINE DELETED	;"23M"
	JMP	(CEEEXI)	;COMMON EQUIV EOL EXIT
DSEXLA:					;DIMENSION SEQ XLATE
	FET	(SYMBOL)	;SYMBOL
	ISE	(ARRFIL)	;ARRAY FILE
	CCFT	(I2QT)	;ID CONFLICT QT
	ISE	(GDMFIL)	;GLOBAL DMY FILE
	FTM	(DARFLA)	;DMY ARRAY FLAG
IFN FTMANT,<	SNZ	(DEBFLAG)	;ZERO VARIABLE DIMENSIONS FLAG
		ZERT	(DAT3)
		FETT	(SYMBOL)	;OUTPUT ARRAY NAME
		XMLT	(ST5RML)
		XMLT	(LIM0ML)>
DSEXL1:
	JSB	(LPASCA)	;LIMIT PAIR SCAN
	JMPF	(DSEXL4)	;$4
IFN FTMANT,<	SNZ	(DEBFLAG)	;OUTPUT LIMITS
		XMLT	(LIM1ML)>
	W1	(SUB)		;W1
	ADD	(ONE)		;ONE
	SLK	(ONE)		;ZERO
	LCFT	(A1QT)	;ALLOCATION QT
	MON	(LIMROL)	;LIMITS ROLL
	MON	(LIMROL)	;LIMITS ROLL
	CSA	(COMMA)	;COMMA
	JMPT	(DSEXL1)	;$1
	FET	(ZERO)	;ZERO
	FET	(ONE)		;ONE
	FET	(ZERO)	;ZERO
	FLP	(LIMROL)	;LIMITS ROLL
DSEXL2:
	W1	(CLA)		;W1
	MON	(DIMROL)	;DIMENS ROLL
	MOA	(LIMROL)	;LIMITS ROLL
	MOA	(LIMROL)	;LIMITS ROLL
	W2	(MPY)		;W2
	W3	(ADD)		;W3
	W3	(STO)		;W3
	W0	(FET)		;W0
	W2	(MPY)		;W2
	W2	(STO)		;W2
	SRD	(LIMROL)	;LIMITS ROLL
	JMPF	(FNDXLA)	;FINISH NON-DMY DIMENS XLATE
	JMP	(DSEXL2)	;$2

DSEXL4:
	FLP	(LIMROL)	;LIMITS ROLL
DSEXL5:
	MOA	(LIMROL)	;LIMITS ROLL
	JMPF	(DSEXL6)	;$6
	SUB	(ONE)		;ONE
	MOA	(LIMROL)	;LIMITS ROLL
	W1	(SWT)		;W1
	W1	(ADD)		;W1
	JSB	(VDIREG)	;VAR DIMENS REGISTER
	SRD	(LIMROL)	;LIMITS ROLL
	MON	(DIMROL)	;DIMENS ROLL
	JMPT	(DSEXL5)	;$5
DSEXL6:
	JSB	(PTEMAK)	;PERM TEMP MAKER
	MON	(DIMROL)	;DIMENS ROLL
DSEXL7:
	MON	(DARROL)	;DIMENS ARG ROLL
	JSB	(SDIREG)	;SCALAR DIMEN REGISTER
DSEX10:
	CSA	(COMMA)	;COMMA
	JMPF	(DSEXL8)	;$8
	MON	(DIMROL)	;DIMENS ROLL
	JSB	(LPASCA)	;LIMIT PAIR SCAN
	JMPF	(DSEXL7)	;$7
	JSB	(VDIREG)	;VAR DIMENS REGISTER
	JMP	(DSEX10)	;$10

DSEXL8:
	FET	(ZERO)	;ZERO
	JSB	(PTEMAK)	;PERM TEMP MAKER
	JSB	(FDIXLA)	;FINISH DIMENS XLATE
	FET	(ZERO)	;ZERO
	JSB	(TYPSET)	;TYPE SET
	LSS	(ADJ.)	;ADJ.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	FET	(R16PNT)	;R16 PNTR
	FET	(CREPNT)	;CRRNT REG PNTR
	BIN	(.JSA0)	;JSA INST
	POW	(D1)		;ONE
	CNT	(DARROL)	;DIMENS ARG ROLL
	W1	(SWT)		;W1
	JSB	(MTYREG)	;MAKE TYPE REG
	W2	(CLA)		;W2
	DIV	(TWO)		;TWO
	POC	(ABSINS)	;ABS INST
	BAI	(.ARG0)	;ARG INST
	FET	(TEMCNT)	;TEMP CNT
	IER	(PTEEM)	;PERM TEMP EM
	BIN	(.ARG0)	;ARG INST
	POW	(D1)		;ONE
	FLP	(DARROL)	;DIMENS ARG ROLL
DSEX12:
	JOW	(EXIT)	;EXIT
	MOA	(DARROL)	;DIMENS ARG ROLL
	BAI	(.ARG0)	;ARG INST
	JMP	(DSEX12)	;$2
FNDXLA:					;FINISH NON-DMY DIMENS XLATE
	CLA	(ZERO)	;ZERO
FDIXLA:					;FINISH DIMENS XLATE
	CSF	(RPAREN)	;R PAREN
IFN FTMANT,<	SNZ	(DEBFLAG)	;DELIMITS LIMITS OUTPUT
		XMLT	(LIM2ML)>
	EAW	(DIMROL)	;DIMENSION ROLL
	RPL	(ASTROL)	;ARRAY STAT ROLL
	REL	(DIMROL)
	STO	(DAT3)		;DATA 3 - ARRAY STATUS ROLL PNTR
	STO	(DAT4)		;DATA 4
	SMK	(LHZEM)		;ARRAY SIZE < 2**18 ?	;"21E"
	LCFF	(M6QT)		;ARRAY TOO LARGE ERROR	;"21E"
	STO	(DAT2)		;DATA 2 - ARRAY SIZE
	STO	(DAT1)		;DATA 1
	STO	(SYMBOL)	;SYMBOL 1 - ARRAY NAME
	AGF	(ARRFIL)	;ARRAY FILE
	XIT	(EXIML)	;EXIT
VDIREG:					;VAR DIMENS REGISTER
	JSB	(RWOCON)	;REGISTER WORK CONST
	MON	(DARROL)	;DIMENS ARG ROLL
	JSB	(RWOCON)	;REGISTER WORK CONST
SDIREG:					;SCALAR DIMEN REGISTER
	MON	(DARROL)	;DIMENS ARG ROLL
	JMP	(PTEMAK)	;PERM TEMP MAKER
LPASCA:					;LIMIT PAIR SCAN
	JSB	(LIMSCA)	;LIMIT SCAN
	JMPF	(LPASC2)	;$2
	CSA	(SLASH)	;SLASH
	CLAF	(ONE)		;ONE
	FETF	(DAT2)	;DATA 2
	XMLF	(ETRML)	;EXIT TRUE
	JSB	(LIMSCA)	;LIMIT SCAN
	XMLT	(ETRML)	;EXIT TRUE
	W1	(SWT)		;W1
	JMP	(LPASC3)	;$3
LPASC2:
	CSA	(SLASH)	;SLASH
	JMPT	(LPASC4)	;$4
	FET	(ONE)		;ONE
LPASC3:
	JSB	(RWOCON)	;REGISTER WORK CONST
	W1	(SWT)		;W1
	JMP	(EXIFAL)	;EXIT FALSE
LPASC4:
	JSB	(LIMSCA)	;LIMIT SCAN
	JSBT	(RWOCON)	;REGISTER WORK CONST
	JMP	(EXIFAL)	;EXIT FALSE
LIMSCA:					;LIMIT SCAN
	SNZ	(DARFLA)	;DMY ARRAY FLAG
	SCKT	(LETKEY)	;LETTER KEY
	JSBF	(SISUSC)	;SIGNED SUBSCRIPT SCAN
	XMLF	(ETRML)	;EXIT TRUE
	JSB	(IDSCAN)	;ID SCAN
	JSBF	(REGSCA)	;REGISTER SCALAR
	SMK	(SCAEM)	;SCALAR EM
	ISET	(GDMFIL)	;GLOBAL DMY FILE
	LCFF	(A4QT)	;ALLOCATION QT
IFN FTMANT,<	NOZ	(DAT3)	;FLAG DUMMY AS VARIABLE DIMENSIONED>
	AND	(RHAMAS)	;RIGHT HALF MASK
EXIFAL:
	XIT	(EFAML)

FEXFDG:					;FEX FUDGE
	JMP	(AOAXLA)
IFNDEF	$DATA,
<
DASTXL:					;DATA STA XLATE
	QSF	(ATAQT)	;ATA QT
DASTX1:
	ZER	(DDOCNT)	;DATA DO CNT
	JSB	(DLIXLA)	;DATA LIST XLATE
	STO	(DLICNT)	;DATA LIST CNT
	EAW	(DLIROL)	;DATA LIST ROLL
	CAR	(CODROL)	;CODE ROLL
	CSF	(SLASH)	;SLASH
IFNDEF	HALFWD,			;"23DD"
<	FEX	(ISTPAR)	;"23DD"
>				;"23DD"
	SNZ	(DDOCNT)	;STR795, IS DO COUNT ZERO ?
	LCFT	(S17QT)		;NO, TOO MANY PARENS
	JSB	(DITXLA)	;DATA ITEMS XLATE
	JSB	(DSVCHE)	;DATA SCRIPT VAR CHECK
	CSF	(SLASH)	;SLASH
	FET	(DITCNT)	;DATA ITEMS CNT
	SEQ	(DLICNT)
	LCFF	(M11QT)		;M-11 MORE DATA NEEDED 	;"23K"
	CSA	(COMMA)	;COMMA
	JMPT	(DASTX1)	;$1
	SCE	(CRR)
	CCFF	(S9QT)		;ILL DELIM ERROR	;"23M"
	SRD	(CODROL)	;CODE ROLL
	JSBT	(OUTCOD)	;OUTPUT CODE
	FET	(DENLOP)	;DATA END LOP
	MON	(DLIROL)	;DATA LIST ROLL
	CNT	(DLCROL)	;DATA LIST CONST ROLL
	CNT	(DITROL)	;DATA ITEMS ROLL
	CNT	(DLIROL)	;DATA LIST ROLL
	W2	(FET)		;W2
	W2	(ADD)		;W2
	W1	(ADD)		;W1
	ADDA	(D3)		;THREE
	IOR	(DSTLOP)	;DATA STA LOP
	MON	(CODROL)	;CODE ROLL
	MON	(CODROL)	;CODE ROLL
	MON	(CODROL)	;CODE ROLL
	MON	(CODROL)	;CODE ROLL
	EAW	(CODROL)	;CODE ROLL
	CAR	(DLIROL)	;DATA LIST ROLL
	EAW	(CODROL)	;CODE ROLL
	CAR	(DITROL)	;DATA ITEMS ROLL
	EAW	(CODROL)	;CODE ROLL
	CAR	(DLCROL)	;DATA LIST CONST ROLL
	JSB	(PDASTA)	;PUNCH DATA STA
	ZER	(DSTFLA)
				;LINE DELETED	;"23M"
	JMP	(CEEEXI)
>
IFNDEF	$DATA,
<
DLIXLA:					;DATA LIST XLATE
	FET	(ZERO)	;ZERO
	RSV	(CODROL)	;CODE ROLL
DLIX12:
	CSA	(LPAREN)	;L PAREN
	JMPF	(DLIX13)	;STR795
	TLY	(DDOCNT)	;DATA DO CNT
	JSB	(DLIXLA)	;DATA LIST XLATE
	CSA	(RPAREN)	;R PAREN
	LCFF	(S17QT)		;PAREN MISSING
	JMP	(DLIXL5)	;$5
DLIX13:	JSB	(IDSCAN)	;ID SCAN
	JMPT	(DLIX14)	;CHECK FOR IMPLIED DO CONSTRUCT
	SCE	(EQUAL)	;EQUAL
	JMPT	(DLIXL6)	;$6
	JSB	(REGSCA)	;REGISTER SCALAR
DLIXL2:
	ISE	(GDMFIL)	;GLOBAL DMY FILE
	LCFT	(I11QT)	;ID CONFLICT QT
	JSB	(CELSIZ)	;CALC ELEMENT SIZE
	SMK	(SCAEM)	;SCALAR EM
	JMPT	(DLIXL3)	;$3
	SMK	(ARREM)	;ARRAY EM
	LCFF	(S15QT)	;ID CONFLICT QT
	CSA	(LPAREN)	;L PAREN
	JMPF	(DLIXL4)	;$4
	JSB	(DARXLA)	;DATA ARRAY XLATE
	FET	(ESIBOX)	;ELEMENT SIZE BOX
	W0	(FET)		
	IOR	(IMULOP)	;IMULI LOP
	MON	(CODROL)	;CODE ROLL
	XW1.1	(MPY)		
	STO	(OAROCL)	;OBJECT ARRAY REF OFFSET CLUE
	STO	(OARNCL)	;OBJECT ARRAY REF NAME CLUE
	REG	(OARFIL)	;OBJECT ARRAY REF FILE
	FET	(CREPNT)	;CRRNT REG PNTR
DLIXL3:
	FET	(ONE)		;ONE
	JMP	(DLIX11)	;$11
DLIX14:				;STR212
	SCE	(EQUAL)		;EQUAL SIGN?
	POWT	(D1)		;PRUNE EXCESS POINTER IF INDEX IS REALLY THERE ;"23W"
	JMPT	(DLIXL6)	;YES IMPLIED DO CONSTRUCT
	JMP	(DLIXL2)
DLIXL4:
	XW0.2	(FET)		;ARRAY SIZE RUNG
DLIX11:
	POC	(SASLOP)	;SET ARRAY SIZE LOP
	MPY	(ESIBOX)	;ELEMENT SIZE BOX
	W1	(SWT)		;W1
	W1	(FET)		;W1
	W1	(SWT)		;W1
	JSB	(BXWLOP)	;BIN XWD LOP
DLIXL5:
	W1	(AMY)		;W1
	CSA	(COMMA)	;COMMA
	JMPT	(DLIX12)	;$12
	XIT	(EXIML)	;EXIT
>
IFNDEF	$DATA,
<

DLIXL6:
	SRA	(DSVFIL)	;DATA SCRIPT VAR FILE
	LCFF	(S18QT)		;INVALID INDEX ;STR795
	JSB	(NEXCHA)	;NEXT CHAR
	FET	(ZERO)	;ZERO
	XW1.1	(STO)		;ONE RUNG
	SNZ	(DDOCNT)	;STR795
	LCFF	(S17QT)		;BAD PAREN COUNT
	JSB	(DINSWE)	;DATA INDEX SWEEP
	DIM	(DDOCNT)	;DATA DO CNT
	SNZ	(DDOCNT)	;DATA DO CNT
	JSBF	(DSVCHE)	;DATA SCRIPT VAR CHECK
	JSB	(SISUSC)	;SIGNED SUBSCRIPT SCAN
	W0	(FET)		;W0
	POC	(DINLOP)	;DO INIT LOP
	MON	(CODROL)	;CODE ROLL
	EAW	(CODROL)	;CODE ROLL
	CAR	(PCOROL)	;PROLOG CODE ROLL
	CSF	(COMMA)	;COMMA
	JSB	(SISUSC)	;SIGNED SUBSCRIPT SCAN
	FET	(ONE)		;ONE
	CSA	(COMMA)	;COMMA
	JSBT	(SISUSC)	;SIGNED SUBSCRIPT SCAN
	W1T	(STO)		;W1
	W2	(SWT)		;W2
	JSB	(CDOSIZ)	;COMPUTE DO SIZE
	W3	(MMY)		;W3
	POC	(DOENLO)	;DO END LOP
	JMP	(BXWLOP)	;BIN XWD LOP
>
IFNDEF	$DATA,
<

DITXLA:					;DATA ITEMS XLATE
	ZER	(DITCNT)	;DATA ITEMS CNT
DITXL6:
	FET	(ONE)		;ONE
	JSB	(DCOSCA)	;DATA CONST SCAN
	JMPF	(DITXL4)	;$4
	CSA	(ASTERI)	;ASTERISK
	JMPF	(DITXL1)	;$1
	SNZ	(MAC1)		;[27I]  REPEAT CNT ZERO?
	JMPF	(DITXL7)	;[27I]  YES
	SNZ	(MCOFLA)	;[27I]  OR NEGATIVE?
	JMPF	(DITXL8)	;[27I]  NO, CONTINUE
DITXL7:	LCF	(M24QT)		;[27I]  YES - ILLEGAL
DITXL8:				;[27I]
	POW	(D2)		;TWO
	CLA	(DAT1)	;DATA 1
	JSB	(DCOSCA)	;DATA CONST SCAN
	JMPF	(DITXL4)	;$4
DITXL1:
	SME	(HTYEM)	;HOLLERITH TYPE EM
	JMPF	(DITXL4)	;$4
	EAW	(ITEROL)	;ITEM TEMP ROLL
	CAR	(CTEROL)	;CONST TEMP ROLL
	CNT	(ITEROL)	;ITEM TEMP ROLL
	W1	(STO)		;W1
	JMP	(DITXL5)	;$5
DITXL4:
	FET	(DAT1)	;DATA 1
	MON	(ITEROL)	;ITEM TEMP ROLL
	SEK	(TWO)		;TWO
	FETT	(DAT2)	;DATA 2
	MONT	(ITEROL)	;ITEM TEMP ROLL
DITXL5:
	W1	(FET)		;W1
	W1	(MPY)		;W1
	ADD	(DITCNT)	;DATA ITEMS CNT
	SLK	(DLICNT)	;DATA LIST CNT
	SEKF	(DLICNT)
	LCFF	(M9QT)		;DATA CNT QT	;"23M"
	STO	(DITCNT)	;DATA ITEMS CNT
	W1	(SWH)		;W1
	W1	(IOR)		;W1
	MON	(DITROL)	;DATA ITEMS ROLL
	POW	(D1)		;ONE
	EAW	(DITROL)	;DATA ITEMS ROLL
	CAR	(ITEROL)	;ITEM TEMP ROLL
	CSA	(COMMA)	;COMMA
	JMPT	(DITXL6)	;$6
	ZER	(MCOFLA)	;"23X"
	XIT	(EXIML)	;EXIT
>
IFNDEF	$DATA,
<

DARXLA:					;DATA ARRAY XLATE
	XW0.3	(FET)		;STAT PNTR RUNG
	CFP	(ATEROL)	;ARRAY TEMP ROLL
	CNT	(ATEROL)	;ARRAY TEMP ROLL
DARXL1:
	JSB	(DSCSCA)	;DATA SCRIPT SCAN
	SUB	(ONE)		;ONE
	CSA	(COMMA)	;COMMA
	JMPT	(DARXL1)	;$1
	FLP	(DSTROL)	;DATA SCRIPT TERM ROLL
	CSF	(RPAREN)	;R PAREN
	SEQ	(ZERO)	;IS COUNT ZERO
	LCFF	(M2QT)		;WRONG # OF SUBSCRIPTS	;STR795
DARXL2:
	JSB	(DSCMAK)	;DATA SCRIPT MAKER
	SRD	(ATEROL)	;ARRAY TEMP ROLL
	XMLF	(P1EML)	;PRUNE ONE EXIT
	JSB	(RDLCON)	;REGISTER DATA LIST CONST
	IOR	(MPYLOP)	;MPY LOP
	MON	(CODROL)	;CODE ROLL
DARXL3:
	JSB	(DSCMAK)	;DATA SCRIPT MAKER
	JSB	(RDLCON)	;REGISTER DATA LIST CONST
	IOR	(MPYLOP)	;MPY LOP
	MON	(CODROL)	;CODE ROLL
	POC	(AACLOP)	;ADD AC LOP
	SRD	(ATEROL)	;ARRAY TEMP ROLL
	JMPT	(DARXL3)	;$3
	XIT	(EXIML)	;EXIT
DINSWE:					;DATA INDEX SWEEP
	FLP	(CODROL)	;CODE ROLL
DINSW1:
	MOA	(CODROL)	;CODE ROLL
	RELF	(CODROL)	;CODE ROLL
	XMLF	(P1EML)	;PRUNE ONE EXIT
	SMK	(DSVEM)	;DATA SCRIPT VAR EM
	JMPF	(DINSW3)	;$3
	W0	(FET)		;W0
	AND	(RHAMAS)	;RIGHT HALF MASK
	W2	(FET)		;W2
	AND	(RHAMAS)	;RIGHT HALF MASK
	W1	(SEQ)		;W1
	POW	(D1)		;ONE
	IERT	(ZRHEM)	;ZERO RIGHT HALF EM
	IORT	(DDOCNT)	;DATA DO CNT
DINSW3:
	MON	(PCOROL)	;PROLOG CODE ROLL
	JMP	(DINSW1)	;$1
>
IFNDEF	$DATA,
<

DSCSCA:					;DATA SCRIPT SCAN
	FET	(ZERO)	;ZERO
	SCK	(LETKEY)	;LETTER KEY
	JMPT	(DSCSC2)	;$2
	SCK	(DIGKEY)	;DIGIT KEY
	JMPF	(DSCSC6)	;$6
	JSB	(INTSCA)	;INTEGER SCAN
	CSA	(ASTERI)	;ASTERISK
	JMPF	(DSCSC4)	;$4
	CLA	(DAT2)	;DATA 2
DSCSC2:
	JSB	(SYMSCA)	;SYMBOL SCAN
	SRA	(DSVFIL)	;DATA SCRIPT VAR FILE
	JMPT	(DSCSC3)	;STR795
	FET	(LACCCN)	;LAST ACTIVE CCNS
	STO	(DAT1)	;DATA 1
	PNG	(DSVROL)	;DATA SCRIPT VAR ROLL
	AGF	(DSVACF)	;DATA SCRIPT VAR AND CCNS FILE
DSCSC3:	SCK	(POMKEY)	;PLUS OR MINUS KEY
	ZER	(DAT2)	;DATA 2
	JMPF	(DSCSC5)	;$5
	JSB	(SISUSC)	;SIGNED SUBSCRIPT SCAN
	JMP	(DSCSC7)	;$7
DSCSC6:
	JSB	(SINSCA)	;SIGNED INTEGER SCAN
DSCSC4:
	FET	(ZERO)	;ZERO
DSCSC5:
	FET	(DAT2)	;DATA 2
DSCSC7:
	MON	(DSTROL)	;DATA SCRIPT TERM ROLL
	MON	(DSTROL)	;DATA SCRIPT TERM ROLL
	MON	(DSTROL)	;DATA SCRIPT TERM ROLL
	XIT	(EXIML)	;EXIT
DSVCHE:					;DATA SCRIPT VAR CHECK
	FLP	(DSVROL)	;DATA SCRIPT VAR ROLL
DSVCH1:
	LGA	(DSVROL)	;DATA SCRIPT VAR ROLL
	XITF	(EXIML)	;EXIT
	SNZ	(DAT1)	;DATA 1
	JMPF	(DSVCH1)	;$1
	FET	(DAT1)	;DATA 1
	STO	(LACCCN)	;LAST ACTIVE CCNS
	LCF	(S17QT)		;NCOMPLETE IMPLIED DO	;STR795
>
IFNDEF	$DATA,
<

DSCMAK:					;DATA SCRIPT MAKER
	MOA	(DSTROL)	;DATA SCRIPT TERM ROLL
	MOA	(DSTROL)	;DATA SCRIPT TERM ROLL
	MOA	(DSTROL)	;DATA SCRIPT TERM ROLL
	W0	(SNZ)		;W0
	JMPT	(DSCMA1)	;$1
	POW	(D1)		;ONE
	W0	(SNZ)		;W0
	POCT	(MACLOP)	;MOVE AC LOP
	IORT	(MOVLOP)	;MOVE LOP
	MONT	(CODROL)	;CODE ROLL
	JMPT	(DSCMA2)	;$2
	POW	(D1)		;ONE
	JSB	(RDLCON)	;REGISTER DATA LIST CONST
	POC	(MACLOP)	;MOVE AC LOP
	IOR	(MOVLOP)	;MOVE LOP
	MON	(CODROL)	;CODE ROLL
	JMP	(DSCMA4)	;$4
DSCMA1:
	JSB	(RDLCON)	;REGISTER DATA LIST CONST
	POC	(MACLOP)	;MOVE AC LOP
	IOR	(MOVLOP)	;MOVE LOP
	MON	(CODROL)	;CODE ROLL
	IOR	(MPYLOP)	;MPY LOP
	MON	(CODROL)	;CODE ROLL
DSCMA2:
	W0	(SNZ)		;W0
	POWF	(D1)		;ONE
	JMPF	(DSCMA4)	;$4
	JSB	(RDLCON)	;REGISTER DATA LIST CONST
	IOR	(ADDLOP)	;ADD LOP
	MON	(CODROL)	;CODE ROLL
DSCMA4:
	MOA	(ATEROL)	;ARRAY TEMP ROLL
	XIT	(EXIML)	;EXIT
RDLCON:					;REGISTER DATA LIST CONST
	STO	(DAT1)	;FX CONST BOX
	REG	(DLCFIL)	;DATA LIST CONST FILE
	FET	(CREPNT)	;CRRNT REG PNTR
	XIT	(EXIML)	;EXIT
CELSIZ:					;CALC ELEMENT SIZE
	SMK	(DITEM)	;DOUBLE ITEM EM
	FET	(ONE)		;ONE
	CLAT	(TWO)		;TWO
	STO	(ESIBOX)	;ELEMENT SIZE BOX
	XIT	(EXIML)	;EXIT
>
IFNDEF	$DATA,
<

CDOSIZ:					;COMPUTE DO SIZE
	W1	(FET)		;W1
	W1	(SUB)		;W1
	W3	(ADD)		;W3
	W1	(STO)		;W1
	W2	(DIV)		;W2
	XIT	(EXIML)	;EXIT
BXWLOP:					;BIN XWD LOP
	W1	(FET)		;W1
	AND	(LHZMAS)	;LEFT HALF ZERO MASK
	W2	(STO)		;W2
	AND	(LHZMAS)	;LEFT HALF ZERO MASK
	W1	(SWH)		;W1
	W1	(IOM)		;W1
	JMP	(MOCOEX)	;MOVE ON CODE EXIT
>
IFNDEF	$DATA,
<

DCOSCA:					;DATA CONST SCAN
	FET	(ONE)		;ONE
	CSA	(DBLQT)	;DBL QT
	JMPT	(DCOSC6)	;$6
	SCK	(LETKEY)	;LETTER KEY
	JMPF	(DCOSC2)	;$2
	CSA	(O)		;O
	JMPT	(DCOSC6)	;$6
	CSA	(T)		;T
	CSFF	(F)		;F
	FTM	(DAT1)
	JMP	(EXIFAL)	;EXIT FALSE

DCOSC2:
	CSA	(MINUS)	;MINUS
	FTM	(MCOFLA)
	CSAF	(PLUS)	;PLUS
	JSB	(CONANA)	;CONST ANALYSIS
	SNZ	(MCOFLA)	;MINUS CONST FLAG
	JMPF	(DCOSC3)	;NEGATE NOT NEEDED
	SMKT	(CTYEM)	;COMPLEX CONST. ?
	XMLT	(PMNCML)	;YES,NEGATE BOTH WORDS
	JMPT	(DCOSC3)
	FET	(PDPSW)	;"25-1"
	SLT	(ZERO)	;PDP-10 ? "25-1"
	XMLT	(PMNML)	;YES,DFN
	XMLF	(PMN6ML)	;NO,DOUBLE PREC. NEGATE
DCOSC3:
	SMK	(DITEM)	;DOUBLE ITEM EM
	POWT	(D1)		;ONE
	CLAT	(TWO)		;TWO
	JMPT	(EXIFAL)	;EXIT FALSE
	SMK	(ITYEM)	;INTEGER TYPE EM
	SMKF	(HTYEM)	;HOLLERITH TYPE EM
	XMLT	(ETRML)	;EXIT TRUE
	XML	(P1EFML)	;PRUNE ONE EXIT FALSE
DCOSC6:
	CSA	(MINUS)	;MINUS
	FTM	(MCOFLA)	;MINUS CONST FLAG
	CSAF	(PLUS)	;PLUS
	XIT	(COCCML)	;CONV OCTAL CONST
>
GTOGRO:					;GO TO GROUP
	QSF	(OTOQT)	;OTO QT
	SCK	(DIGKEY)	;DIGIT KEY
	JMPF	(COAGTO)	;COMPUTED OR ASSIGN GO TO
GTSEXI:					;GO TO STA EXIT
	JSB	(LBLSCA)	;LBL SCAN
	BAI	(.JRST0)	;JRST INST
GEXFIN:					;GOTO EXIT FIN
	NOZ	(JOUFLA)	;JUMP OUT FLAG
	JMP	(JEOEXI)	;JUMP EOL EXIT
COAGTO:					;COMPUTED OR ASSIGN GO TO
	CSA	(LPAREN)	;L PAREN
	JMPF	(AGTSXL)	;ASSIGN GO TO STA XLATE
CGTSXL:					;COMPUTED GO TO STA XLATE
	JSB	(LLIXLA)	;LBL LIST XLATE
	CSA	(COMMA)	;COMMA
	JSB	(FESACO)	;FX EXP SCAN AND COLLAPSE
	JSB	(GENRUN)	;GEN RUN
	FET	(RONPNT)	;REG ONE PNTR
	W1	(SWT)		;W1
	SMK	(MINEM)		;"27B"
	BINT	(.MN0)		;"27B"
	FETT	(RONPNT)	;"27B"
	BIN	(.SKLE0)	;SKIPLE INST
	CNT	(ITEROL)	;ITEM TEMP ROLL
	JSB	(RWOCON)	;REGISTER WORK CONST
	BIN	(.CMLE0)	;CAMLE INST
	POC	(ABSINS)	;ABS INST
	POC	(.SKA0)	;SKIPA INST
	JSB	(LBLMAK)	;LBL MAKER
	JSB	(MLGAKE)	;MADE LBL GEN AND KEEP
	BAI	(.JRST2)	;JRST 0,@(1) INST
	ZER	(ITEPNT)	;ITEM TEMP PNTR
CGTSX1:
	DFA	(ITEROL)	;ITEM TEMP ROLL
	BAIT	(.ARG0)	;ARG INST
	JMPT	(CGTSX1)	;$1
	REL	(ITEROL)	;ITEM TEMP ROLL
	POW	(D1)		;ONE
	JMP	(GEXFIN)	;GOTO EXIT FIN
AGTSXL:					;ASSIGN GO TO STA XLATE
	JSB	(VARSCA)	;W0_VARIABLE POINTER
	SCE	(CRR)		;GO TO I ? ;"23FF"
	JMPF	(AGTSX1)	;NO, PROCESS LIST ;"23FF"
	BAI	(.SKE1)		;SKIPE 1 INST
	POC	(ABSINS)	;ABS INST
	POC	(.JRST1)	;JRST 0.XR1 INST
				;4 LINES DELETED ;"23FF"
	JMP	(GEXFIN)	;GOTO EXIT FIN ;"23FF"
AGTSX1:
				;LINE DELETED ;"23FF"
	CSA	(COMMA)	;COMMA
				;LINE DELETED ;"23FF"
	CSF	(LPAREN)	;GO TO I,"(" ;"23FF"
	BAI	(.RRZ0)		;HRRZ 1,I ;PRUNE W0 ;"23FF"
AGTSX2:				;"23FF"
	JSB	(LBLSCA)	;GO TO I,( LABEL ;W0_LABEL ;"23FF"
	BAK	(.CIN1)		;CAIN 1,LABEL ;"23FF"
	BAI	(.JRST0)	;JRST LABEL ;"23FF"
	CSA	(COMMA)		;GO TO I,( +LABEL ;"23FF"
	JMPT	(AGTSX2)	;GET SOME MORE LABELS ;"23FF"
	CSF	(RPAREN)	;R PAREN
	JMP	(GEXFIN)	;GOTO EXIT FIN
LLIXLA:					;LBL LIST XLATE
	RSV	(ITEROL)	;ITEM TEMP ROLL
LLIXL1:
	JSB	(LBLSCA)	;LBL SCAN
	MON	(ITEROL)	;ITEM TEMP ROLL
	CSA	(COMMA)	;COMMA
	JMPT	(LLIXL1)	;$1
	CSF	(RPAREN)	;R PAREN
	XIT	(EXIML)	;EXIT
AOAXLA:					;ASSIGNMENT OR AFDS XLATE
	FEX	(FOSTXL)	;FORMAT STA XLATE
	JSB	(IDSCAN)	;ID SCAN
	JMPT	(ASTXLA)	;ASSIGNMENT STA XLATE
	SNZ	(ASTFLA)	;ACTIVE STA FLAG
	SCEF	(EQUAL)	;EQUAL
	JSBT	(REGSCA)	;REGISTER SCALAR
	JMPT	(ASXFIN)	;ASSIGNMENT STA XLATE FIN
	CSA	(LPAREN)
	XITF	(FAIML)		;FAIL	;"23A"
	JSB	(LBLMAK)	;MAKE LABEL AT END OF AFDS
	BAK	(.JRST0)	;JUMP AROUND THE AFDS, SAVE THE ADDRESS
	STO	(SINFLA)	;IN A HANDY UNUSED LOCATION - "20G"
	JSB	(LBLMAK)	;LBL MAKER
	JSB	(MLGAKE)	;MADE LBL GEN AND KEEP
	BAK	(.ARG0)	;ARG INST
	EAW	(D10)		;SAVE ALL REGS ;"21V"
	STO	(REGCNT)	;"21V"
	NOZ	(SAV16)		;INCLUDING REG 16 ;"21V"
	JSB	(BSRGEN)	;BLOCK SAVE REGS GEN
	FET	(TEMCNT)	;TEMP CNT
	IER	(PTEEM)	;PERM TEMP EM
	BAI	(.MEI0)
	STO	(DAT1)	;DATA 1
	PNG	(LSPROL)	;LOCAL SPROG ROLL
	AGF	(LSPFIL)	;APPEND SYMBOL & DAT1 TO LOCAL SPROG FILE
	JSB	(SETPOS)	;SET POSITION
	STK	(LSPDEF)	;INDICATE AFDS BEING DEFINED ;"23-AM"
	RSV	(APNROL)	;ARG PNTR ROLL
AOAXL1:
	JSB	(IDSCAN)	;ID SCAN
	PNGF	(LDMROL)	;LOCAL DMY ROLL
	JSBF	(TYPSET)	;TYPE SET
	SMKT	(LDMEM)
	XITT	(FAIML)		;FAIL	;"23A"
	SMK	(DITEM)	;DOUBLE ITEM EM
	JSB	(PTEMAK)	;PERM TEMP MAKER
	TLYT	(TEMCNT)	;TEMP CNT
	STO	(DAT1)	;DATA 1
	AGF	(LDMFIL)	;LOCAL DMY FILE
	MON	(APNROL)	;ARG PNTR ROLL
	CSA	(COMMA)	;COMMA
	JMPT	(AOAXL1)	;$1
	CSA	(RPAREN)	;R PAREN
	CSAT	(EQUAL)
	XITF	(FAIML)		;FAIL	;"23A"
	JSB	(ESACOL)	;EXP SCAN AND COLLAPSE
	JSB	(LSHGEN)	;LOCAL SPROG HEAD GEN
	JSB	(DPCHEC)	;DP CHECK
	JSB	(GENRUN)	;GEN RUN
	W1	(SWT)		;W1
	JSB	(ACCAGE)	;ASSIGNMENT CONV CHECK AND GEN
	STO	(EOPPNT)	;SAVE DEST OP PNTR
	JMPT	(AOAXL2)	;IS DEST DBL AND RESLT SNGL
	W0	(FET)		;COPY W0
	AND	(SANMAS)	;SIGN CHANGE OR COMPLEMENT ?
	SEQ	(ZERO)		;YES, IF NON ZERO
	SMKT	(RZEEM)		;NO,IS DEST REG 0
	JMPT	(AOAXL5)	;YES,SKIP ALL RE LOADS
AOAXL3:
	IER	(ETYEM)		;INSERT EXP TYPE EM IN RESULT
	FET	(RZEPNT)	;GET REG 0 PNTR
	IER	(ETYEM)	;SET TYPE FOR REG LOADS"21V"
	JSB	(RLOGEN)	;GO LOAD REGS
	SMK	(RZEEM)	;REG 0 PNTR STILL HERE? "21V"
	JSBT	(DPCHE1)	;YES CHECK FOR NEGATE "21V"
AOAXL4: POCT	(ABSINS)	;GENERATE INST TO CLEAR REG 1
	POCT	(.MEI1)		;MOVEI 1,0
AOAXL5: POW	(D1)		;PRUNE W0
	JSB	(BREACS)	;BIN RESTORE ACS
	JSB	(SEXGEN)	;SPROG EXIT GEN
	ZER	(LSPDEF)	;"23-AM"
	ZER	(FSTFLA)	;AN EXECUTABLE STATEMENT
	FET	(SINFLA)	;LABEL FOR JRST "20G"
	ZER	(REGCNT)	;RESTORED REGS DON'T COUNT ;"21V"
	ZER	(SAV16)		;DITTO ;"21V"
	JSB	(MLBGEN)	;MAKE:  LABEL	BLOCK 0
	FET	(LTEPNT)	;LOCAL TEMP PNTR
	STO	(AFDTPN)	;ARITH FUNC DEF TEMP PNTR
	JMP	(AEOEXI)	;AFDS EOL EXIT
AOAXL2:	
	SMK	(RZEEM)		;IS DEST REG 0
	JMPT	(AOAXL4)	;YES CLEAR REG 1
	SNZ	(ONE)		;NO SET FLAG T
	JMP	(AOAXL3)	;RESTORE REG 0 AND CLEAR REG1
DPCHEC:					;DP CHECK
	FET	(EOPPNT)	;EXP OP PNTR
	SME	(DITEM)	;DOUBLE ITEM EM
	XNIT	(RONPNT)	;REG ONE PNTR
	NOZT	(ZERRUN)	;ZERO RUNG
	XIT	(EXIML)	;EXIT
DPCHE1:			;CHECK FOR DP NEG "21V"
	SMK	(DPNEM)	;DP? "21V"
	XITF	(EFAML)		;EXIT FALSE "21V"
	W0	(FET)		;COPY W0 "21V"
	JSB	(CSIGE1)	;NEGATE "21V"
	XIT	(EFAML)	;RETURN FALSE "21V"
ASTXLA:					;ASSIGNMENT STA XLATE
	SMK	(ARREM)	;ARRAY ID EM
	CSAT	(LPAREN)	;L PAREN
	JSBT	(AREXLA)	;ARRAY REF XLATE
	SMKF	(SCAEM)	;SCALAR EM
ASXFIN:					;ASSIGNMENT STA XLATE FIN
	CSAT	(EQUAL)
	XITF	(FAIML)		;FAIL	;"23A"
	ISE	(GDMFIL)	;GLOBAL DEFINITION ?
	REGT	(DEFFIL)	;YES, REGISTER AS DEFINED
;
;PATCH TO PREVENT MODIFICATION OF DO LOOP INDEX WITHIN AN OPEN DO
;LOOP.  PATCH LEVEL 26E-14/15.
;
	STK	(REGTEM)	;STORE POINTER IN REGTEM ; "26E"
	XML	(DLUSML)	;CHECK TO SEE IF IT IS AN INDEX VARIABLE OF AN OPEN DO LOOP ; "26E"
	JMPF	(ASXFI0)	;NOT AN INDEX VARIABLE, CONTINUE SCAN;"26E"
	FEX	(EXTFEX)	;SET FAIL EXIT TO ILL STMNT PARSE;"26E"
	LCF	(M22QT)		;IF SO, GIVE ERROR AND FAIL ; "26E"
EXTFEX:	JMP	(ISTPAR)	;AND IGNORE REST OF STATEMENT ; "26E"
ASXFI0:
;
;END OF THIS PART OF PATCH LEVEL 26E-14/15.
;
	FET	(IIVPNT)	;INSIDE INDUCTION VAR PNTR
	STO	(DSTPNT)	;SAVE INSIDE INDUCTION VAR
	JSB	(ESACOL)	;EXP SCAN AND COLLAPSE
	JSB	(SACAGE)	;SPECIAL ASSIGNMENT CHECK AND GEN
	JMPT	(ACEOEX)	;ACTIVE EOL EXIT
	JSB	(DPCHEC)	;DP CHECK
	SMK	(SUBEM)	;SUBEXPRESSION ?
	JSBT	(EIRGEN)	;YES, EXP IN REG GEN
	W1	(SWT)		;W1
	SMK	(AREEM)	;ARRAY REF EM
	JMPF	(ASXFI1)	;NO ARRAY "20K"
	XW0.2	(FET)		;GET SUBSCR RUNG "20K"
	SMK	(SUBEM)		;SUBEXPRESSION? "20K"
	XW0.4T	(TLY)		;YES TALLY "20K"
	POW	(D1)		; "20K"
	JSB	(RDRCHE)	;RESTORE DO REG CHECK
	JSB	(SCRGEN)
	JMPF	(ASXFI1)	;"23R"
	XW1.2	(FET)		;GET SCRIPT EXP PNTR "23R"
	SMK	(DREEM)		;DO REGISTER? ; "26H"
	W1	(SWT)		;PUT REG PNTR ON TOP "23R"
	XW1.3F	(STO)		;NO, SUBEXPRESSION,PUT REG PNTR IN EXP STATUS RUNG "23R" ; "26H"
	POWT	(D1)		;YES, PRUNE ONE ; "26H"
	XW1.2	(STO)		;SCRIPT EXP RUNG
ASXFI1:			;"20K"
	SON	(TEMEM)	;TEMP EM
	FETT	(TYPMAS)	;TYPE MASK
	ANDT	(EOPPNT)	;EXP OP PNTR
	W2T	(IOM)		;W2
	JSB	(AMAFIN)	;ASSIGNMENT MAKER FIN
	SNZ	(DSTPNT)	;RESTORE DO INDEX ?
	JSBT	(RDOREG)	;YES,RESTORE IT
	JMP	(ACEOEX)	;ACTIVE EOL EXIT
AMAFIN:					;ASSIGNMENT MAKER FIN
	JSB	(ACCAGE)	;ASSIGNMENT CONV CHECK AND GEN
	W1	(SWT)		;PUT RESULT ON TOP
	JSB	(REGGEN)	;INSURE RESULT IN REG & SAVE T/F FLAG STATE
	JSB	(AMFN)		;[27H]  ASSIGNMENT MAKER FINISH NOT
	W1	(SWT)		;RETURN DESTINATION TO TOP
	JSB	(MPOGEN)	;MOVEM POSITIVE GEN
	EAWT	(.SEZM0)	;SETZM INST
	JSBT	(BSHREF)	;BUILD SECOND HALF REF
	XML	(P1EML)	;PRUNE ONE EXIT
REGGEN:
	SMK	(ITYEM)
	JSBT	(AIVCHE)
	JSBF	(GIRGEN)	;MAKE SURE ITS IN A REG
	XIT	(EXIML)
RDRCHE:					;RESTORE DO REG CHECK
	XW0.2	(FET)		;SCRIPT RUNG
	SME	(DREEM)	;DO REG EM
	XITF	(EXIML)	;EXIT
RDOREG:
	SNZ	(IIVPNT)	;INSIDE INDUCTION VAR PNTR
	FETF	(DSTPNT)	;SAVE INSIDE INDUCTION VAR
	STKF	(IIVPNT)	;RESTORE DO INDEX
	NOZF	(JOUFLA)	;DEFINE DO INDEX VARIABLE
	BAIF	(.ME1)	;MOVE DO REG INST
	XIT	(EXIML)	;EXIT

AMFN:	SMK	(NOTEM)		;[27H]  NOT EM
	SMKT	(MINEM)		;[27H]  AND MINUS EM
	BAKT	(.MNS0)		;[27H]  YES, MOVNS FOR COMING SETCA
	EORT	(MINEM)		;[27H]  AND CLEAR MINEM
	SMK	(NOTEM)		;[27H]
	BRIT	(.SEA0)		;[27H]  COMPLEMENT AC
	EORT	(NOTEM)		;[27H]
	XIT	(EXIML)		;[27H]  EXIT
SACAGE:					;SPECIAL ASSIGNMENT CHECK AND GEN
	W1	(FET)		;W1
	STO	(PINATO)	;PNTR INSERT ATOM
	SMK	(SUBEM)	;SUBEXP EM
	JMPT	(SPACHE)	;SUBEXP PARTS CHECK
	SMK	(PINEM)	;PNTR INSERT EM
	JMPT	(SVACAG)	;SPECIAL VAR ASSIGNMENT CHECK AND GEN
	SMK	(COPEM)	;CONST ONE PNTR EM
	SMKT	(MINEM)	;MINUS EM
	SONT	(ITYEM)	;INTEGER TYPE EM
	SMKF	(CZPEM)	;CONST ZERO PNTR EM
	SMKF	(TCPEM)	;TRUE CONST PNTR EM
	SMKF	(FZPEM)	;FL ZERO PNTR EM
	JMPF	(CASCHE)	;CONST ASSIGNMENT CHECK
	SMK	(NOTEM)	;NOT EM
	EORT	(LCIMAS)	;LOGICAL CONST INVERT MASK
	SME	(DONEM)	;DISPL ONE EM
	BAKT	(.SEZM0)	;SETZM INST
	BAKF	(.SEOM0)	;SETOM INST
	SMK	(DITEM)	;DOUBLE ITEM EM
	EAWT	(.SEZM0)	;SETZM INST
	JSBT	(BSHREF)	;BUILD SECOND HALF REF
	XML	(P1ETML)	;PRUNE ONE EXIT TRUE
SVACAG:					;SPECIAL VAR ASSIGNMENT CHECK AND GEN
	SMK	(DPNEM)	;DOUBLE PREC NEG EM
	SMKF	(CTYEM)	;COMPLEX TYPE EM
	JMPT	(EXIFAL)	;EXIT FALSE
	SMK	(MINEM)	;MINUS EM
	JMPF	(SVACA1)	;$1
	SME	(NOTEM)	;NOT EM
	BAIT	(.AOS0)	;AOS INST
	BAIF	(.MNS0)	;MOVNS INST
	XML	(ETRML)	;EXIT TRUE
SVACA1:
	SME	(NOTEM)	;NOT EM
	BAKT	(.SEMM0)	;SETCMM INST
	XML	(P1ETML)	;PRUNE ONE EXIT TRUE
SPACHE:					;SUBEXP PARTS CHECK
	FET	(PDPSW)		;"25-1"
	SGT	(ZERO)		;"25-1"
	SMKT	(DPTEM)		;"25-1"
	XITT	(EFAML)		;EXIT IF KI10 DOUBLE PRECISION "25-1"
	XW0.0	(FET)		;OP PNTR RUNG
	SPT	(AOPTRA)	;ARITH OP TRAIT
	JMPF	(EXIFAL)	;EXIT FALSE
	SON	(ITYEM)	;INTEGER TYPE EM
	JMPF	(SPACH5)	;$5
	SMK	(ITYEM)	;INTEGER TYPE EM
	JMPF	(EXIFAL)	;EXIT FALSE
SPACH5:
	XW0.2	(FET)		;B PART RUNG
	XW1.1	(FET)		;A PART RUNG
	SON	(PINEM)	;PNTR INSERT EM
	SMKF	(PINEM)	;PNTR INSERT EM
	XMLF	(P2EFML)	;PRUNE TWO EXIT FALSE
	XW2.0	(FET)		;OP PNTR RUNG
	SPK	(ADDTRA)	;ADDITIVR OP TRAIT
	JMPT	(SPACH1)	;$1
	SME	(MOPEM)	;MPY OP EM
	SONF	(PINEM)	;PNTR INSERT EM
	XMLF	(P2EFML)	;PRUNE TWO EXIT FALSE
	JSB	(OASCHE)	;ORDER AND SIGN CHECK
	JSB	(EIRGEN)	;EXP IN REG GEN
	W0	(FET)		;PUT SUB EXP PNTR INTO W3 ;"22D"
	JSB	(RFBGF4)	;ADJUST TYPES ;"22D"
	W1	(STO)		;REMOVE EXTRA REG PNTR ;"22D"
	W1	(SWT)		;W1
	JSB	(CCAGE3)	;"23AJ"
	XW2.0	(FET)		;OP PNTR RUNG
	SME	(MOPEM)	;MPY OP EM
	JSB	(SATREG)	;SAVE THIRD REG
	BTYT	(.IMUM0)	;MPYM INST
	BTYF	(.IDIM0)	;DIVM INST
	SME	(MINEM)	;MINUS EM
	JMP	(SPACH3)	;$3
SPACH1:
	POW	(D1)		;ONE
	JSB	(OASCHE)	;ORDER AND SIGN CHECK
	EORF	(MINMAS)	;MINUS MASK
	SMK	(COPEM)	;CONST ONE PNTR EM
	SONT	(ITYEM)	;INTEGER TYPE EM
	JMPF	(SPACH2)	;$2
	SME	(MINEM)	;MINUS EM
	BAIT	(.SOS0)	;SOS INST
	BAIF	(.AOS0)	;AOS INST
	JMP	(SPACH4)	;$4
SPACH2:
	JSB	(EIRGEN)	;EXP IN REG GEN
	W0	(FET)		;PUT SUB EXP PNTR INTO W3 ;"22D"
	JSB	(RFBGF4)	;ADJUST TYPES ;"22D"
	W1	(STO)		;REMOVE EXTRA REG PNTR ;"22D"
	W1	(SWT)		;W1
	JSB	(CCAGE3)	;"23AJ"
	SON	(MINEM)	;MINUS EM
	JSB	(SATREG)	;SAVE THIRD REG
	BTYF	(.ADDM0)	;ADDM INST
	BTYT	(.SUBM0)	;SUBM INST
	POW	(D1)		;ONE
SPACH3:
	EORT	(MINMAS)	;MINUS MASK
SPACH4:
	SME	(MINEM)	;MINUS EM
	XITF	(P1ETML)

	SMK	(DPTEM)
	JMPF	(SPACH7)	;XFER IF NOT D.P. ;"25-1"

	FET	(PDPSW)		;TEST MACHINE TYPE ;"25-1"
	SLT	(ZERO)		;"25-1"
	JMPT	(SPACH6)	;XFER FOR KA10 D.P.

	FET	(PDPSW)		;"25-1"
	SGT	(ZERO)		;TEST FOR PDP-6 VS KI10 ;"25-1"
	BAKT	(.DMVE)		;KI10, COMPILE DMOVE ;"25-1"
	BAKT	(.DMVNM)	;KI10, COMPILE DMOVNM ;"25-1"
	XITT	(P1ETML)	;XFER IF KI10

SPACH7:
	BAK	(.MNS0)	;MOVNS INST IF NOT D.P. OR IS PDP-6
	SMK	(DITEM)	;DOUBLE ITEM EM
	XITF	(P1ETML)	;EXIT IF NOT A DOUBLE ITEM ;"25-1"
	EAW	(.MNS0)		;MOVNS INST ;"25-1"
	JSB	(BSHREF)	;BUILD SECOND HALF REF ;"25-1"

	SMK	(DPTEM)	;DOUBLE PREC TYPE EM FOR PDP-6 ;"25-1"
	FETT	(RONPNT)	;REGISTER ONE POINTER
	FETT	(ABSCPN)	;ALL BUT SIGN CONST POINTER
	BINT	(.TDNE0)	;TDNE INSTRUCTION
	POWT	(D1)		;ONE
	BAKT	(.SOS0)	;SOS INST
	XIT	(P1ETML)	;PRUNE ONE EXIT TRUE

SPACH6:
	BAK	(.ME0)	;MOVE INST
	EAW	(.DFN0)	;DFN INST
	JSB	(BSHREF)
	MOA	(CODROL)
	SUB	(ACMASK)
	MON	(CODROL)
	BAK	(.MEM0)	;MOVEM
	XIT	(P1ETML)
OASCHE:					;ORDER AND SIGN CHECK
	SMK	(PINEM)	;PNTR INSERT EM
	W1T	(SWT)		;W1
	SON	(MINEM)	;MINUS EM
	XMLF	(ETRML)	;EXIT TRUE
	FET	(MINMAS)	;MINUS MASK
	W3	(EOM)		;W3
	XIT	(EFAML)		;EXIT FALSE
CASCHE:					;CONST ASSIGNMENT CHECK
	SMK	(CONEM)	;CONST PNTR EM
	XITF	(EFAML)		;EXIT FALSE
	SMK	(NOTEM)	;NOT EM
	XITT	(EFAML)		;EXIT FALSE
	SMK	(ITYEM)	;INTEGER TYPE EM
	SMKF	(RTYEM)	;REAL TYPE EM
	XITF	(EFAML)		;EXIT FALSE
	SMK	(ITYEM)		;RESULT INTEGER?
	JMPF	(CASCH1)	;NO CHECK DESTINATION
	SON	(RTYEM)		;DESTINATION REAL?
	SONF	(DITEM)		;OR DOUBLE
	XITF	(EFAML)		;NO EXIT FALSE
	JSB	(FACCFI)	;CONVERT INTEGER TO FLOATING
	STO	(DAT1)		;SAVE UPPER
	ZER	(DAT2)		;CLEAR LOWER
	W0	(FET)		;FINISH CONVERSION
	JSB	(CCOFIN)	;CONVT FINISH
	STK	(EOPPNT)	;SAVE EXP TYPE
	XIT	(EFAML)		;EXIT FALSE
CASCH1:
	SON	(DITEM)		;DESTINATION DOUBLE?
	SMKT	(RTYEM)		;AND RESULT REAL?
	IERT	(DPTEM)		;CHANGE RESULT TYPE TO DP
	XIT	(EFAML)		;EXIT FALSE
FOSTXL:					;FORMAT STA XLATE
	FEX	(CSTXLA)	;CALL STA XLATE
	QSF	(FORQT)	;FORMAT QT
	SCE	(LPAREN)	;L PAREN
	XMLF	(FAIML)		;[27E]
	JSB	(LAPSAV)	;LOOK AHEAD POSITION SAVE
	CSF	(LPAREN)	;L PAREN
	JSB	(FLISCA)	;FORMAT LIST SCAN
	SCE	(CRR)
	CCFF	(S22QT)		;SYNTAX QT	;"23M"
	FET	(LACCCN)	;LAST ACTIVE CCNS
	JSB	(LAPRES)	;LOOK AHEAD POSITION RESET
	RSV	(CTEROL)	;CONST TEMP ROLL
	NOZ	(FORFLA)	;FORMAT STA FLAG
	JSB	(PHCSET)
FOSTX1:
	JSB	(PHCHAR)
	JSB	(NINCHA)
	SCE	(CRR)
	SLKF	(CARNUM)	;CARD-COL NUMBERS
	JMPF	(FOSTX1)	;$1
	POW	(D1)		;ONE
	JSB	(PHCEND)
	JSB	(LBLMAK)	;LBL MAKER
	BAK	(.JRST0)	;JRST INST
	ZER	(FSTFLA)	;FIRST STA FLAG
	CNT	(CTEROL)	;CONST TEMP ROLL
	IER	(ABSEM)	;ABS EM
	MON	(CODROL)	;CODE ROLL
	REL	(ERRROL)	;ERROR ROLL
	JSB	(PRISTA)	;PRINT STATEMENT
	JSB	(OUTCOD)
	EAW	(CODROL)	;CODE ROLL
	CAR	(CTEROL)	;CONST TEMP ROLL
	SNZ	(MACSW)	;PRINTING SUPRESSED ?
	JSBF	(PRIFOR)	;NO, PRINT FORMAT
	JSB	(PUNDAT)	;PUNCH DATA
	JSB	(MLBGEN)	;MADE LBL GEN
	JSB	(DCLGEN)	;DO CLOSE GEN
	JSB	(OUTCOD)	;OUTPUT CODE
	ZER	(ENDCOD)	;"23P"
	XML	(ETRML)	;EXIT TRUE
FLISCA:					;FORMAT LIST SCAN
FLISC1:
	CSA	(RPAREN)	;R PAREN
	XITT	(EXIML)	;EXIT
FLISC2:
	CSA	(SLASH)	;SLASH
	JMPT	(FLISC3)	;$3
	JSB	(FBASCA)	;FORMAT BASIC SCAN
	CSA	(SLASH)	;SLASH
	JMPF	(FLISC4)	;$4
FLISC3:
	CSA	(SLASH)	;SLASH
	JMPT	(FLISC3)	;$3
	CSA	(COMMA)	;COMMA
	JMPT	(FLISC2)	;$2
	JMP	(FLISC1)	;$1
FLISC4:
	CSA	(COMMA)	;COMMA
	JMPT	(FLISC2)	;$2
	CSF	(RPAREN)	;R PAREN
	XIT	(EXIML)	;EXIT
PRIFOR:					;PRINT FORMAT
	ZER	(CODPNT)	;CODE PNTR
PRIFO1:
	DFA	(CODROL)	;CODE ROLL
	XITF	(EXIML)	;EXIT
	PRQ	(ASCQT)	;ASCII QT
	XML	(ASBCML)
	PRC	(CRR)		;CAR RETURN
	JMP	(PRIFO1)	;$1
FBASCA:					;FORMAT BASIC SCAN
	CSA	(SNGLQT)	;QT
	JMPT	(FBASC8)	;$8
	CSA	(MINUS)	;MINUS
	CSAF	(PLUS)	;PLUS
	JMPF	(FBASC2)	;$2
	JSB	(INTSCA)	;INTEGER SCAN
	CSF	(P)		;P
	JMP	(FBASC4)	;$4
FBASC2:
	SCK	(DIGKEY)	;DIGIT KEY
	JMPF	(FBASC5)	;$5
	JSB	(INTSCA)	;INTEGER SCAN
	CSA	(P)		;P
	JMPF	(FBASC3)	;$3
FBASC4:
	SCK	(DIGKEY)	;DIGIT KEY
	JMPF	(FBASC5)	;$5
	JSB	(INTSCA)	;INTEGER SCAN
FBASC3:
	CSA	(X)		;X
	JMPT	(FBAS11)	;$11
	SCE	(H)		;H
	JMPT	(FBASC9)	;$9
FBASC5:
	CSA	(DOLLAR)	;DOLLAR SIGN CHAR I
	JMPT	(FBAS11)	;$11
	CSA	(T)		;T
	JMPF	(FBAS16)	;$16
	LSS	(TFMT.)	;TFMT. 
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	JMP	(INTSCA)	;INTEGER SCAN
FBAS16:
	CSA	(E)		;E
	CSAF	(F)		;F
	EAWT	(FLIRT.)	;FLIRT.
	EAWT	(FLOUT.)	;FLOUT.
	JMPT	(FBAS14)	;$14
	CSA	(D)		;D
	EAWT	(DIRT.)	;DIRT.
	EAWT	(DOUBT.)	;DOUBT.
FBAS14:
	JSBT	(RFOSPR)	;REGISTER FORMAT SPROGS
	JMPT	(FBASC6)	;$6
	CSA	(G)		;G
	JSBT	(REGALL)	;REGISTER ALLIO.
	JMPT	(FBAS13)	;$13
	CSA	(O)		;O
	EAWT	(OCTI.)	;OCTI.
	EAWT	(OCTO.)	;OCTO.
	JMPT	(FBAS15)	;$15
	CSA	(I)		;I
	EAWT	(INTI.)	;INTI.
	EAWT	(INTO.)	;INTO.
	JMPT	(FBAS15)	;$15
	CSA	(A)		;A
	EAWT	(ALPHI.)	;ALPHI.
	EAWT	(ALPHO.)	;ALPHO.
	JSBT	(RFOSPR)	;REGISTER FORMAT SPROGS
	JMPT	(INTSCA)	;INTEGER SCAN
	CSA	(L)		;L
	EAWT	(LINT.)	;LINT.
	EAWT	(LOUT.)	;LOUT.
	JSBT	(RFOSPR)	;REGISTER FORMAT SPROGS	;"23I"
	JMPT	(INTSCA)	;INTEGER SCAN	;"23I"
FBAS15:
	JSBT	(RFOSPR)	;REGISTER FORMAT SPROGS
	JMPT	(FBAS12)	;$12
	CSA	(LPAREN)	;L PAREN
	CCFF	(S3QT)	;SYNTAX QT
	JMP	(FLISCA)	;FORMAT LIST SCAN
FBASC6:
	SCK	(DIGKEY)	;DIGIT KEY
	XITF	(EXIML)	;EXIT
	JSB	(INTSCA)	;INTEGER SCAN
	CSF	(PERIOD)	;PERIOD
	JMP	(INTSCA)	;INTEGER SCAN
FBASC7:
	JSB	(NEXCHA)	;NEXT CHAR
	SCE	(CRR)		;CAR RETURN-EOF KEY
	CCFT	(M7QT)	;UNTERMINATED HOLLERITH STRING QT
FBASC8:
	CSA	(SNGLQT)	;QT
	JMPF	(FBASC7)	;$7
	SCE	(SNGLQT)	;QT
	JMPT	(FBASC7)	;$7
	JMP	(FBAS11)	;$11
FBASC9:
	JSB	(HCOSCA)	;HOL CONST SCAN
	REL	(CTEROL)	;CONST TEMP ROLL
	POW	(D1)		;ONE
FBAS11:
	SCK	(CPAKEY)	;COMMA-VIRGULE-R PAREN
	XITT	(EXIML)	;EXIT
	JMP	(FBASCA)	;FORMAT BASIC SCAN
FBAS13:
	SCK	(DIGKEY)	;DIGIT KEY
	XITF	(EXIML)	;EXIT
	JSB	(INTSCA)	;INTEGER SCAN
	CSA	(PERIOD)	;PERIOD
	JMPT	(INTSCA)	;INTEGER SCAN
	JMP	(FBAS11)	;$11
FBAS12:
	SCK	(DIGKEY)	;DIGIT KEY
	XITF	(EXIML)	;EXIT
	JMP	(INTSCA)	;INTEGER SCAN
RFOSPR:					;REGISTER FORMAT SPROGS
	XML	(LSSIML)
	REG	(GSPFIL)
	XML	(LSSIML)
	REG	(GSPFIL)
	XIT	(EXIML)
CSTXLA:					;CALL STA XLATE
	FEX	(OPSTXL)	;[27M]OPEN STATEMENT TRANSLATE
	ZER	(SPSW)		;[27M]INSURE ITS OFF
	QSF	(CALQT)	; CALL QT
	JSB	(IDSCAN)	; ID SCAN
CSTCNT:	JSBF	(RGLSPR)	;[27M]REGISTER GLOBAL SPROG
	SMK	(GSPEM)	;GLOBAL SPROG EM
	LCFF	(I10QT)	;ID CONFLICT QT
	ISE	(CNAFIL)
	LCFT	(I16QT)		;CONFLICT W/ COMMON DECLARATION	;"23A"
	FET	(NOPPNT)	;"21V"
	SME	(FSPEM)		;"21V"
	EAWT	(D12)		;"21V"
	STOT	(REGCNT)	;"21V"
	CSA	(LPAREN)	;L PAREN
	JSBT	(SASXLA)	;SPROG ARG SEQ XLATE
	XW0.0T	(FET)		;SPROG NAME PNTR RUNG
	STOT	(ETYATO)	;EXP TYPE ATOM
	NOZ	(JOUFLA)	;JUMP OUT FLAG (DO LOOP)
	JSBT	(FRPGEN)	;FUNC REF PNTR GEN
	JSBF	(SLGFIN)	;SPROG LINK GEN FIN
	POWT	(D2)		;TWO
	ZER	(SPSW)		;[27M]SPECIAL SWITCH OFF
	JMP	(ACEOEX)	;ACTIVE EOL EXIT



OPSTXL:	FEX	(CLSTXL)	;[27M] CLOSE STATEMENT XLATE
	QSF	(OPNQT)		; [27M] OPEN QUOTE
	NOZ	(OPNDEF)	;[27M]
	JSB	(IDSCAN)	;[27M]SCAN FAKE 'OPEN' SYMBOL
	ZER	(OPNDEF)	;[27M]
	NOZ	(SPSW)	;[27M]ARGUMENT SWITCH
	JMP	(CSTCNT)	;[27M]AND CONTINUE

CLSTXL:	FEX	(COSTXL)	;[27M]CONTINUE STATEMENT TRANSLATE
	QSF	(CLSQT)		;[27M]CLOSE QUOTE
	NOZ	(CLODEF)	;[27M]TURN FAKE ID ON
	JSB	(IDSCAN)	;[27M]SCAN IT
	ZER	(CLODEF)	;[27M]ZERO SWITCH
	NOZ	(SPSW)		;[27M]ON WITH SPECIAL SWITCH
	JMP	(CSTCNT)	;[27M]CONTINUE
COSTXL:					;CONTINUE STA XLATE
	FEX	(TSTXLA)	;TYPE STA XLATE
	ZER	(SPSW)		;[27M]IF WE ARE HERE, THEN DEFINITELY NOT O/C
	QSF	(CONQT)	;CONTINUE QT
	JMP	(ACEOEX)	;ACTIVE EOL EXIT
TSTXLA:					;TYPE STA XLATE
	FEX	(ACSTXL)	;ACCEPT STA XLATE
	QSF	(TYPQT)	;TYPE QT
	ZER	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	EAWI	(..OUT1)	;OUT. INST
	EAW	(D0)		;MINUS ONE
	JMP	(FCIXLA)	;FORMAT COMMA IOL XLATE
ACSTXL:					;ACCEPT STA XLATE
	FEX	(RSTXLA)	;READ STA XLATE
	QSF	(ACCQT)	;ACCEPT QT
	NOZ	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	EAWI	(..IN1)	;IN. INST
	EAW	(D3)		;MINUS FOUR
	JMP	(FCIXLA)	;FORMAT COMMA IOL XLATE
RSTXLA:					;READ STA XLATE
	FEX	(WSTXLA)	;WRITE STA XLATE
	QSF	(READQT)	;READ QT
GRSXLA:					;GENERAL READ STA XLATE
	ZER	(VIOEXP)	;NO SUBEXPRESSIONS VIOLATED
	NOZ	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	CSA	(LPAREN)	;L PAREN
	EAWI	(..IN1)	;IN. INST
	EAWF	(D4)		;MINUS FIVE
	JMPF	(FCIXLA)	;FORMAT COMMA IOL XLATE
	JSB	(IUNXLA)	;IO UNIT XLATE
	CSA	(LBSIGN)	;DIRECT ACCESS I/O ?
	CSAF	(SNGLQT)	;IBM COMPATIBLE	;"23G"
	JSBT	(DIOXLA)	;YES, GO XLATE THE RECORD #
	SCE	(COMMA)		;COMMA ;"22Q"
	JMPF	(GRSXL1)	;"22B"
	JSB	(EOEGEN)	;CHECK FOR END= OR ERR= "22B"
	JMPF	(GIOFIN)	;GENERAL IO FINISH
GRSXL1:
	CSF	(RPAREN)	;R PAREN
	LSS	(BINWR.)	;BINWR.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	EAWI	(..RTB0)	;RTB. INST
BFIENT:					;BINARY FINISH ENTRY
	W2	(STO)		;W2
	JSB	(BTAENT)	;BINARY TAPE ENTRY
	CSA	(COMMA)	;OPTIONAL COMMA
	CSA	(CRR)		;AN I/O LIST FOLLOWS ? ;"21Y"
	JMPF	(CIXEND)	;YES, COMMA IOL XLATE END ;"21Y"
	JMP	(IOLEND)	;NO, FINISH UP ;"21Y"
WSTXLA:					;WRITE STA XLATE
	FEX	(PSTXLA)	;PUNCH STA XLATE
	QSF	(WRIQT)	;WRITE QT
	CSF	(LPAREN)	;L PAREN
	ZER	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	EAWI	(..OUT1)	;OUT. INST
	JSB	(IUNXLA)	;IO UNIT XLATE
	CSA	(LBSIGN)	;DIRECT ACCESS I/O ?
	CSAF	(SNGLQT)	;IBM COMPATIBLE	;"23G"
	JSBT	(DIOXLA)	;YES, GO XLATE THE RECORD #
	SCE	(COMMA)		;COMMA ;"22Q"
	JMPF	(WSTXL1)	;BYPASS "22B"
	JSB	(EOEGEN)	;CHECK FOR END= OR ERR= "22B"
	JMPF	(GIOFIN)	;GENERAL IO FINISH "22B"
WSTXL1:
	CSF	(RPAREN)	;R PAREN
	LSS	(BINWR.)	;BINWR.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	EAWI	(..WTB0)	;WTB. INST
	JMP	(BFIENT)	;BINARY FINISH ENTRY
GIOFIN:					;GENERAL IO FINISH
	JSB	(FRESCA)	;FORMAT REFERENCE SCAN
				;2 LINES DELETED ;"22Q"
	CSF	(RPAREN)	;R PAREN
	SCE	(CRR)		;CAR RETURN
	JMPT	(IOLEND)	;IOL END
	CSA	(COMMA)	;COMMA
	JMP	(CIXEND)	;COMMA IOL XLATE END
PSTXLA:					;PUNCH STA XLATE
	FEX	(PRSTXL)	;PRINT STA XLATE
	QSF	(PUNQT)	;PUNCH QT
	ZER	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	EAWI	(..OUT1)	;OUT. INST
	EAW	(D1)		;MINUS TWO
	JMP	(FCIXLA)	;FORMAT COMMA IOL XLATE
PRSTXL:					;PRINT STA XLATE
	FEX	(RERXLA)	;REREAD STA XLATE
	QSF	(PRIQT)	;PRINT QT
	ZER	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	EAWI	(..OUT1)	;OUT. INST
	EAW	(D2)		;MINUS THREE
FCIXLA:					;FORMAT COMMA IOL XLATE
	W0	(NOT)
	JSB	(FRESCA)	;FORMAT REFERENCE SCAN
	CSA	(COMMA)		;COMMA
	JMPF	(IOLEND)	;IOL END
CIXEND:					;COMMA IOL XLATE END
	RSV	(VARROL)	;SETUP VARIABLE POINTER ROLL
	RSV	(CODROL)	;SETUP CODE ROLL
	SNZ	(IIVPNT)	;DO INDEX TO SAVE ?
	FETT	(IIVPNT)	;SAVE NORMAL DO INDEX PNTR
	STOT	(DSTPNT)	;DO STATUS PNTR
	JSB	(IOLXLA)	;IOL XLATE
	JSB	(IOLSCA)	;RESCAN THE VARIABLES FOR OPTIMIZATION
	JSBT	(RDOREG)	;RESTORE DO INDEX IF NECESSARY
	REL	(VARROL)	;RESET THE VARIABLE ROLL
IOLEND:					;IOL END
	POC	(ABSINS)	;ABS INST
	POC	(..FIN0)
	SCE	(CRR)		;IS THIS THE END ?	;"23M"
	CCFF	(S21QT)		;NO, ERROR	;"23M"
	ZER	(VIOEXP)	;[27J]SHUT OFF VIOL 
	JMP	(ACEOEX)	;ACTIVE EOL EXIT
FRESCA:					;FORMAT REFERENCE SCAN
	CSA	(COMMA)		;SCAN PAST COMMA ;"22Q"
	SCK	(DIGKEY)	;DIGIT KEY
	JSBT	(LBLSCA)	;LBL SCAN
	JMPT	(FRESC3)	;$3
	JSB	(IDSCAN)	;ID SCAN

IFNDEF	$NAME,
<
	JMPT	(FRESC2)	;$2
	ISE	(NNAFIL)	;NAMELIST NAME FILE
	JSBT	(REGNAM)	;REGISTER NAMELIST
	XNIT	(NNAPNT)	;NAMELIST NAME PNTR
	FETT	(ONERUN)	;ONE RUNG
	NOZT	(JOUFLA)	;SET JUMP OUT FLAG
	JMPT	(FRESC3)	;$3
>
FRESC2:
	SMK	(ARREM)	;ARRAY EM
	LCFF	(I4QT)	;ID CONFLICT QT
	JSB	(REGALL)	;REGISTER ALLIO.
	JMP	(IARSIZ)	;INSERT ARRAY SIZES
FRESC3:
	BAI	(.MEI1)	;MOVEI 1 INST
BTAENT:					;BINARY TAPE ENTRY
	SCE	(COMMA)		;FORMAT FOLLOWED BY COMMA ? ;"22Q"
	JSBT	(EOEGEN)	;YES, GO TO END/ERROR GENERATE ;"22Q"
	SMK	(MLBEM)	;MADE LBL EM
	JSBT	(MLGAKE)	;MADE LBL GEN AND KEEP
	CLAT	(ZERO)	;ZERO
	POC	(ABSINS)	;ABS INST
	AND	(RHAMAS)	;RIGHT HALF MASK
	W1	(IOM)		;W1
	JMP	(MOCOEX)	;MOVE ON CODE EXIT

RERXLA:					;REREAD STA XLATE
	FEX	(ESTXLA)	;ENCODE STA XLATE
	QSF	(REREQT)	;REREAD
	NOZ	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	EAWI	(..IN1)	;IN.	1,
	EAW	(D5)		;-6 = .NOT. 5
	JMP	(FCIXLA)	;FORMAT COMMA I/O LIST XLATE

ESTXLA:					;ENCODE STA XLATE
	FEX	(DESTXL)	;DECODE STA XLATE
	QSF	(ENCQT)	;ENCODE
	CSF	(LPAREN)	;LEFT PARENTHESIS
	ZER	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	EAWI	(..ENC1)	;ENC.	1,
	JMP	(EDCFIN)	;ENCODE/DECODE FIN

DESTXL:					;DECODE STA XLATE
	FEX	(INSTXL)	;INTEGER STA XLATE
	QSF	(DECQT)	;DECODE
	CSF	(LPAREN)	;LEFT PARENTHESIS
	NOZ	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	EAWI	(..DEC1)	;DEC.	1,
EDCFIN:					;ENCODE/DECODE FIN
	JSB	(IUNXLA)	;I/O UNIT XLATE
	CSF	(COMMA)	;COMMA
	SCK	(DIGKEY)	;IS FORMAT A DIGIT
	JSBT	(LBLSCA)	;GET A LABEL
	JMPT	(EDCFI3)	;NOW GEN V POINTER
	JSB	(IDSCAN)	;IS FORMAT NAME DEFINED
	SMK	(ARREM)		;AS AN ARRAY
	LCFF	(I4QT)		;NO,'FORMAT NAME NOT ARRAY'
	JSB	(REGALL)	;REG ALLIO ON ROLL
	FET	(ARRPNT)	;GET ARRAY PNTR
	W1	(SWT)		;SAVE IT IN A SAFE PLACE
EDCFI3:	CSF	(COMMA)		;COMMA TEST
	LSS	(VADDR.)	;LOAD NAME ON SYMTAB
	REG	(GSPFIL)	;REGISTER ON GSPFIL
	FET	(GSPPNT)	;GET POINTER
	JSB	(IDSCAN)	;IS VARIABLE DEFINED
	JSBF	(REGSCA)	;NO,MAKE SCALAR VARIABLE
	SMKT	(ARREM)	;IS VAR REF AN ARRAY
	JMPF	(EDCFI1)	;NO,TEST FOR SCALAR
	CSA	(LPAREN)	;YES,IS IT SUBSCRIPTED
	JSBT	(AREXLA)	;YES,ARRAY REF XLATE
	JMPT	(EDCFI2)	;"22I"
	ISE	(GDMFIL)	;GLOBAL DUMMY ARRAY? "22I"
	BAIT	(.ME0)		;MOVE INST "22I"
	JMPT	(EDCFI4)	;"22I"
EDCFI2:
	BAI	(.MEI0)	;MOVEI 0,ADDR 
EDCFI4:			;"22I"
	BAI	(.RRM0)	;HRRM 0,VADDR.
	CSF	(RPAREN)	;R PAREN? NO-FAIL
	SMK	(ARREM)		;IS FORMAT AN ARRAY
	W1T	(SWT)		;GET THE POINTER FROM ITS HIDEING PLACE
	STOT	(ARRPNT)	;RESTORE ARRAY PNTR
	JSBT	(IARSIZ)	;YES,SET SIZE AND FINISH
	JSBF	(FRESC3)	;NO,GEN INST AND FINISH
	CSA	(COMMA)	;ALLOW OPTIONAL COMMA
	JMP	(CIXEND)	;GO PROCESS LIST
EDCFI1:
	SMK	(SCAEM)	;IS VARIABLE A SCALAR
	CCFF	(I12QT)	;NO,ERR-VAR NOT SCALAR OR ARRAY
	CSA	(LPAREN)	;YES,IS IT SUBSCRIPTED
	LCFT	(S4QT)	;YES,ERR-MAY NOT BE SUBSCRIPTED
	SNZ	(DEFINE)	;ENCODE ? ;"23-AL"
	JMPT	(EDCFI2)	;NO, CONTINUE SCAN ;"23-AL
	ISE	(GDMFIL)	;GLOBAL DUMMY ? ;"23-AL"
	REGT	(DEFFIL)	;YES, DEFINE IT ;"23-AL"
;
;PATCH 26E-14/15 TO PREVENT MODIFICATION OF A DO LOOP INDEX WITHIN
;ON OPEN DO LOOP.
;
	STK	(REGTEM)	;STORE POINTER IN REGTEM ; "26E"
	XML	(DLUSML)	;CHECK TO SEE IF IT IS A LOOP INDEX ; "26E"
	LCFT	(M22QT)		;IF SO, GIVE ERROR AND FAIL ; "26E"
;
;END OF THIS PART OF 26E-14/15.
;
	JMP	(EDCFI2)	;NO,OUTPUT INSTRUCTIONS


DIOXLA:						;DIRECT ACCESS I/O XLATE
	JSB	(FESACO)	;FIXED EXP SCAN & COLLAPSE
	JSB	(EIRGEN)	;EXP IN REG GEN
	LSS	(RECNO.)	;LOAD EXTERNAL LOCATION OF RECORD #
	REG	(GSPFIL)	;REGISTER AND MAKE A PNTR
	FET	(GSPPNT)	;GET THE POINTER
	BIN	(.MEM0)	;BUILD  MOVEM 00,RECNO.
	LSS	(RANAC.)	;LOAD EXT LOC OF RANDOM ACCESS FLAG
	REG	(GSPFIL)	;REGISTER AND MAKE A PNTR
	FET	(GSPPNT)	;GET THE POINTER
	BAI	(.SEOM0)	;BUILD SETOM 00,RANAC.
	XIT	(P1EML)	;EXIT, PRUNING THE REG PNTR
IARSIZ:					;INSERT ARRAY SIZES
	XNI	(ARRPNT)	;ARRAY PNTR
	FET	(TWORUN)	;TWO RUNG
	SON	(DITEM)		;IS ARRAY DOUBLE - "20H"
	MPYT	(TWO)		;YES DOUBLE SIZE - "20H"
	W1	(SWT)		;W1
	XW0.0	(FET)		;GET ARRAY NAME
	STO	(SYMBOL)	;STORE IT FOR THE ISE SEARCH
	ISE	(GDMFIL)	;GLOBAL DUMMY DIMENSIONED LOCALY
	BAIF	(.MEI1)	;MOVEI  1,  INST
	BAIT	(.ME2)	;MOVE   1,  INST
	W0	(SNZ)
	POCT	(ABSINS)	;ABS INST
	ANDT	(RHAMAS)	;RIGHT HALF MASK
	IORT	(HRLI1I)	;HRLI 1 INST
	MONT	(CODROL)	;CODE ROLL
	XNIF	(ARRPNT)	;ARRAY PNTR
	CLAF	(CSIRUN)	;CALC SIZE RUNG
	BAIF	(.RL1)	;HRL 1 INST
	JMP	(BTAENT)	;BINARY TAPE ENTRY
IUNXLA:					;IO UNIT XLATE
	SCK	(DIGKEY)	;DIGIT KEY
	SCKF	(POMKEY)	;SIGNED CONSTANT ?
	JSBT	(SISUSC)	;SIGNED SUBSCRIPT SCAN
	XITT	(EXIML)		;EXIT TO ML
	JSBF	(VARSCA)	;VARIABLE SCAN
	SMK	(ITYEM)		;IS VAR AN INTEGER TYPE
	LCFF	(M16QT)		;NO,NON-INTEGER ERROR
	JSB	(AIVREP)	;CHECK FOR DO LOOP INDEX
	BAI	(.ME0)		;MOVE 0 INST
	JSB	(LBLMAK)	;LBL MAKER
	BAK	(.RRM0)		;HRRM 0,LBL
	XIT	(EXIML)		;EXIT
IOLXLA:					;IOL XLATE	;I/O LIST SPECIFICATION TRANSLATE
	CSA	(LPAREN)	;L PAREN
	JSBF	(IVAXLA)	;IO VAR XLATE
	JMPF	(IOLXL1)	;$1
;FOUND A (   MUST BE STARTING IMPLIED DO LOOP
	ZER	(IIVPNT)	;INSIDE INDUC VAR PNTR
	RSV	(CODROL)	;CODE ROLL
	JSB	(IOLXLA)	;IOL XLATE
	RSV	(PCOROL)	;PROLOG CODE ROLL
	EAW	(PCOROL)	;PROLOG CODE ROLL
	CAR	(CODROL)	;CODE ROLL
	CSA	(RPAREN)	;A REAL IMPLIED DO ?
	JMPT	(STNDRD)	;NO,SAVE INFO GENERATED
	JSB	(IVSFIN)	;INDUC VAR SCAN FIN
	NOZ	(IMDFLG)	;SET INSIDE IMPLIED DO FLG "22K"
	RSV	(SUBROL)	;SAV SUBROL "24-5"
	JSB	(DCOXLA)	;DO CONTROL XLATE
	REL	(SUBROL)	;RELEASE SUBROL "24-5"
	ZER	(IMDFLG)	;CLEAR FOR REGULAR DO'S ;"23S"
	FET	(IIVPNT)	;NEW INDEX
	IER	(IIVEM)	;NEW INDEX PNTR NEEDED FLAG
	MON	(CODROL)	;SAVE
	SNZ	(IOLFLA)	;ALREADY INSIDE A DO LOOP ?
	ZERT	(IIVPNT)	;YES,DEFINE THE DO INDEX VARIABLE
	EAW	(CODROL)	;CODE ROLL
	CAR	(PCOROL)	;PROLOG CODE ROLL
	NOZ	(IOLFLA)	;IOL FLAG
	JSB	(LCGFIN)	;LOOP CLOSE GEN FIN
	CSF	(RPAREN)	;R PAREN
IOLXL1:
	CSA	(COMMA)	;COMMA
	JMPT	(IOLXLA)	;IOL XLATE
	XIT	(EXIML)	;EXIT

IOLSCA:
	CSF	(CRR)		;REALLY THE END
	FLP	(VARROL)	;INVERT VARIABLE ROLL ORDER
	RSV	(PCOROL)	;SETUP PROLOG CODE ROLL
	EAW	(PCOROL)	;ROLL ADDRESS TO W0
	CAR	(CODROL)	;COPY & RELEASE CODE ROLL TO PCOROL
	FLP	(PCOROL)	;INVERT ORDER OF PCOROL
IOLSC1:
	MOA	(PCOROL)	;GET BOTTOM OF PCOROL
	XITF	(EXIML)	;NO MORE ENTRIES, EXIT
	SMK	(IIVEM)	;NEW INDEX PNTR NEEDED ?
	STOT	(IIVPNT)	;YES,RESTORE IT
	NOZT	(REGSAV)	;DISABLE SUBSCRIPT OPTIMIZATION
	JMPT	(IOLSC1)	;ITERATE
	SMKF	(VAREM)	;DOES VARIABLE GO HERE?
	MONF	(CODROL)	;NO, PUT ON CODROL
	ZERF	(IIVPNT)	;CLEAR INDEX FOR NEXT IMPLIED DO
	ZERF	(REGSAV)	;ENABLE SUBSCRIPT OPTIMIZATION
	JMPF	(IOLSC1)	;GET NEXT ENTRY
	POWT	(D1)		;REMOVE VARIABLE INDICATOR
	MOA	(VARROL)	;GET VARIABLE POINTER
	SMK	(ARREM)	;ARRAY W/O SUBSCRIPTS?
	JSBT	(SLIST)	;YES, MAKE SLIST
	JMPT	(IOLSC1)	;GET NEXT ENTRY
	JSB	(AIVCHE)	;CHECK FOR ACTIVE DO LOOP
	JSB	(MTYREG)	;MAKE AC ACCORDING TO VAR. TYPE
	BIN	(..DAT0)	;MAKE DATA UUO
	POW	(D1)		;REMOVE EXTRA WORD
	JMP	(IOLSC1)	;GET NEXT ENTRY

EOEGEN:						;END/ERROR GEN
	QSA	(ENDEQT)	;END=
	JMPF	(EOEGE3)	;$3
	NOZ	(JOUFLA)	;SET JUMP OUT FLG "22F"
	NOZ	(ENDFLG)	;SET FLG ON "22B"
	LSS	(END.)	;GET NAME OF GLOBAL ADDRESS REG
EOEGE1:
	REG	(GSPFIL)	;REGISTER & MAKE A POINTER
	FET	(GSPPNT)	;GET THE POINTER
	SCK	(DIGKEY)	;DIGIT ?
	JSBT	(LBLSCA)	;YES,GET A LABEL
	BAIT	(.MEI0)	;BUILD MOVEI 00,PROGREM LOC
	JMPT	(EOEGE4)	;$2
	JSB	(IDSCAN)	;GET A VARIABLE
	JSBF	(REGSCA)	;REGISTER A SCALAR IF NOT FOUND
	SMK	(SCAEM)
	ERMF	(S8QT)		;NO, ILLEGAL CHARACTER IN LABEL	;"23L"
	XITF	(FAIML)		;AND FAIL	;"23A"
	BAIT	(.ME0)	;BUILD MOVE 00,VARIABLE CONTAINING PROGRAM LOC
EOEGE4:
	BAIT	(.RRM0)	;BUILD HRRM 00,END./ERR.
EOEGE2:
	SCET	(COMMA)		;ANOTHER ONE ? ;"22Q"
	JMPT	(EOEGEN)	;YES,TRY AGAIN
	SNZ	(ENDFLG)	;IS FLG ON? "22B"
	ZERT	(ENDFLG)	;YES CLEAR IT "22B"
	XIT	(EXEQML)	;EXIT WITH FLAG AS SET "22B"
EOEGE3:
	QSA	(ERREQT)	;ERR
	JMPF	(EOEGE2)	;$2
	NOZ	(ENDFLG)	;SET FLG ON "22B"
	NOZ	(JOUFLA)	;SET JUMP OUT FLG "22F"
	LSS	(ERR.)	;GET NAME OF GLOBAL ADDRESS REG
	JMP	(EOEGE1)	;MAKE THE INSTRUCTION
IVAXLA:					;IO VAR XLATE
	JSB	(IDSCAN)	;ID SCAN
	JSBF	(REGSCA)	;REGISTER SCALAR
	SMK	(SCAEM)		;SCALAR? - "20D"
	SMKF	(ARREM)		;ARRAY?  - "20D"
	LCFF	(I15QT)		;NOT A SCALAR OR ARRAY - "20D"
	SNZ	(DEFINE)	;ONLY INPUT DEFINES ;"21U"
	ISET	(GDMFIL)	;GLOBAL DEFINITION ? ;"21U"
	REGT	(DEFFIL)	;REGISTER AS DEFINED
;
;PATCH 26E-14/15 TO PREVENT MODIFICATION OF ACTIVE LOOP INDEX
;
	SNZ	(DEFINE)	;IS THIS AN INPUT OPERATION ; "26E"
	JMPF	(IVAXL2)	;NO, DONT NEED TO CHECK ANYTHING HERE ; "26E"
	STK	(REGTEM)	;INPUT, STORE POINTER IN REGTEM ; "26E"
	XML	(DLUSML)	;IS THE VARIABLE AN ACTIVE LOOP INDEX? ; "26E"
	LCFT	(M22QT)		;YES, GIVE ERROR AND FAIL ; "26E"
IVAXL2:				;OUTPUT CANT AFFECT INDEX VARIABLE, SO COME HERE ; "26E"
;
;END OF THIS PART OF PATCH 26E-14/15.
	SNZ	(DEFINE)		;ONLY AFFECT BY INPUT
	JMPF	(IVAXL3)		;SO SKIP IF OUTPUT
	STK	(REGTEM)		;W0 TO REGTEM
	XML	(VIOCML)		;CHECK FOR SUBEPRESSION VIOLATIONS
	NOZT	(VIOEXP)		;EXPRESSION VIOLATED
IVAXL3:
	SCE	(EQUAL)	;EQUAL
	XITT	(EXIML)	;EXIT
	SMK	(ARREM)	;ARRAY ID EM
	JMPF	(IVAXL1)	;$1
	CSA	(LPAREN)	;L PAREN
	JSBT	(AREXLA)	;ARRAY REF XLATE
IVAXL1:
	MON	(VARROL)	;PUT POINTER ON VARIABLE ROLL
	FET	(VARPNT)	;GET VARIABLE INDICATOR
	MON	(CODROL)	;PUT ON CODROL
	XIT	(EXIML)	;EXIT

SLIST:
	XW0.4	(FET)		;CALC SIZE RUNG
	SEK	(ZERO)	;ZERO
	BAIF	(.ME0)	;MOVE 0 INST
	JSBF	(LBLMAK)	;LBL MAKER
	BAKF	(.RRM0)	;HRRM INST
	XW1.2T	(CLA)		;ARRAY SIZE RUNG
	IERF	(CVAEM)	;CALC VALUE EM
	W1	(SWT)		;W1
	JSB	(MTYREG)	;MAKE TYPE REG
	XW0.0	(FET)		;LOOK FOR THE RIGHT SYMBOL
	STO	(SYMBOL)
	ISE	(GDMFIL)	;GLOBAL DMY FILE
	BINT	(..SLI1)	;SLIST.* INST
	BINF	(..SLI0)	;SLIST. INST
	POW	(D1)		;ONE
	SMK	(CVAEM)	;CALC VALUE EM
	JSBT	(MLGAKE)	;MADE LBL GEN AND KEEP
	CLAT	(ZERO)	;ZERO
	POC	(ABSINS)	;ABS INST
	EAWI	(.ARG0)		;ARG INSTRUCTION	;"21E"
	W1	(IOM)		;COMBINE WITH ARRAY SIZE	;"21E"
	MON	(CODROL)	;AND PUT ON THE CODE ROLL	;"21E"
	XIT	(EXIML)	;EXIT
MTYREG:					;MAKE TYPE REG
	W0	(FET)		;W0
	XML	(ITDFML)	;ISOLATE TYPE IN DISPL FIELD
				;PUT TYPE BITS OF W0 RIGHT JUSTIFIED IN W0
	ADD	(ONE)		;ONE
	W1	(SWT)		;W1
	XIT	(EXIML)	;EXIT

STNDRD:					;MAKE I/O LISTS CONFORM TO THE STANDARDS
	EAW	(CODROL)
	CAR	(PCOROL)
	JMP	(IOLXL1)
INSTXL:					;INTEGER STA XLATE
	FEX	(RESTXL)	;REAL STA XLATE
	QSF	(INTQT)	;INTEGER QT
	CSA	(ASTERI)	;IBM COMPATIBLE	;"23G"
	CSAT	(N2)		;"23G"
	NOZT	(SINFLA)	;"23G"
	JMPT	(SINENT)	;"23G"
	CSA	(N4)		;"23G"
	ZER	(SINFLA)	;SUBSCRIPT INTEGER FLAG
SINENT:					;SUBSCRIPT INTEGER ENTRY
	FET	(ZERO)	;ZERO
SINEN1:
	JSB	(STYEVA)	;SYMBOL TYPE EVAL
	JMPT	(SINEN2)	;$2
	AGF	(IIDFIL)	;INTEGER ID FILE
	SNZ	(SINFLA)	;SUBSCRIPT INTEGER FLAG
	AGFT	(SIIFIL)	;SUBSCRIPT INTEGER ID FILE
	JMP	(SINEN3)	;$3
SINEN2:
	SMK	(ITYEM)	;INTEGER TYPE EM
	LCFF	(I3QT)	;ID CONFLICT QT
SINEN3:
	JSB	(TDIXLA)	;TYPE DIMENSION XLATE
	JMPT	(SINEN1)
				;LINE DELETED	;"23M"
	JMP	(CDEEXI)	;CLASS DECLAR EOL EXIT
RESTXL:					;REAL STA XLATE
	FEX	(DPSXLA)	;DOUBLE PRECISION STA XLATE
	QSF	(REAQT)	;REAL QT
	FET	(ZERO)	;ZERO
	CSA	(ASTERI)	;IBM COMPATIBLE	;"23G"
	CSAT	(N8)		;"23G"
	JMPT	(DPSXL1)	;"23G"
	CSA	(N4)		;"23G"
RESTX1:
	JSB	(STYEVA)	;SYMBOL TYPE EVAL
	JMPT	(RESTX2)	;$2
	AGF	(RIDFIL)	;REAL ID FILE
	JMP	(RESTX3)	;$3
RESTX2:
	SMK	(RTYEM)	;REAL TYPE EM
	LCFF	(I3QT)	;ID CONFLICT QT
RESTX3:
	JSB	(TDIXLA)	;TYPE DIMENSION XLATE
	JMPT	(RESTX1)
				;LINE DELETED	;"23M"
	JMP	(CDEEXI)	;CLASS DECLAR EOL EXIT
DPSXLA:					;DOUBLE PRECISION STA XLATE
	FEX	(CXSTXL)	;COMPLEX STA XLATE
	QSF	(DPRQT)	;DOUBLE PRECISION QT
	FET	(ZERO)	;ZERO
DPSXL1:
	JSB	(STYEVA)	;SYMBOL TYPE EVAL
	JMPF	(DPSXL2)	;$2
	SMK	(DPTEM)	;DOUBLE PREC TYPE EM
	LCFF	(I3QT)	;ID CONFLICT QT
DPSXL2:
	AGFF	(DPIFIL)	;DOUBLE PREC ID FILE
	JSB	(TDIXLA)	;TYPE DIMENSION XLATE
	JMPT	(DPSXL1)
				;LINE DELETED	;"23M"
	JMP	(CDEEXI)	;CLASS DECLAR EOL EXIT
CXSTXL:					;COMPLEX STA XLATE
	FEX	(LSTXLA)	;LOGICAL STA XLATE
	QSF	(COMPQT)	;COMPLEX QT
	CSA	(ASTERI)	;COMPLEX= (IBM COMPATIBLE)	;"23G"
	SCET	(N1)		;"23G"
	CSAT	(N6)		;COMPLEX*16 ?	;"23G"
	CCFT	(S5QT)		;YES, ILLEGAL TYPE SPECIFICATION	;"23G"
	CSA	(N8)		;COMPLEX*8	;"23G"
	FET	(ZERO)	;ZERO
COSTX1:
	JSB	(STYEVA)	;SYMBOL TYPE EVAL
	JMPF	(COSTX2)	;$2
	SMK	(CTYEM)	;CPLX TYPE EM
	LCFF	(I3QT)	;ID CONFLICT QT
COSTX2:
	AGFF	(CIDFIL)	;COMPLEX ID FILE
	JSB	(TDIXLA)	;TYPE DIMENSION XLATE
	JMPT	(COSTX1)
				;LINE DELETED	;"23M"
	JMP	(CDEEXI)	;CLASS DECLAR EOL EXIT
LSTXLA:					;LOGICAL STA XLATE
	FEX	(SISXLA)	;SUBSCRIPT INTEGER STA XLATE
	QSF	(LOGQT)	;LOGICAL QT
	CSA	(ASTERI)	;IBM COMPATIBLE	;"23G"
	CSA	(N1)		;"23G"
	CSAF	(N4)		;"23G"
	FET	(ZERO)	;ZERO
LSTXL1:
	JSB	(STYEVA)	;SYMBOL TYPE EVAL
	JMPF	(LSTXL2)	;$2
	SMK	(LTYEM)	;LOGICAL TYPE EM
	LCFF	(I3QT)	;ID CONFLICT QT
LSTXL2:
	AGFF	(LIDFIL)	;LOGICAL ID FILE
	JSB	(TDIXLA)	;TYPE DIMENSION XLATE
	JMPT	(LSTXL1)
				;LINE DELETED	;"23M"
	JMP	(CDEEXI)	;CLASS DECLAR EOL EXIT
TDIXLA:					;TYPE DIMENSION XLATE
	CSA	(LPAREN)	;L PAREN
	JMPF	(TDIXL1)	;$1
	JSB	(IDCLAS)	;ID CLASSIFY
	LCFT	(I2QT)	;ID CONFLICT QT
	JSB	(DSEXLA)	;DIMENSION SEQ XLATE
TDIXL1:
	CSA	(COMMA)	;COMMA
	XIT	(EXEQML)	;EXIT EQUAL ML
SISXLA:					;SUBSCRIPT INTEGER STA XLATE
IFNDEF	$NAME,
<
	FEX	(NSTXLA)	;NAMELIST STA XLATE
>
IFDEF	$NAME,	<IFNDEF	$IMPL,
<
	FEX	(IMSTXL)
>>
IFDEF	$NAME,	<IFDEF	$IMPL,
<
	FEX	(CMSTXL)
>>
	QSF	(SUBSQT)	;SUBSCRIPT QT
	QSF	(INTQT)	;INTEGER QT
	NOZ	(SINFLA)	;SUBSCRIPT INTEGER FLAG
	JMP	(SINENT)	;SUBSCRIPT INTEGER ENTRY
IFNDEF	$NAME,
<
NSTXLA:					;NAMELIST STA XLATE
	FEX	(IMSTXL)	;IMPLICIT STA XLATE
	QSF	(NAMQT)	;NAMELIST QT
NSTXL1:
	CSA	(SLASH)	;SLASH
	LCFF	(S7QT)	;SYNTAX QT
	JSB	(IDSCAN)	;ID SCAN
	ISEF	(GDMFIL)	;GLOBAL DMY FILE
	LCFT	(I6QT)	;ID CONFLICT QT
	CSF	(SLASH)	;SLASH
	REG	(NNAFIL)	;NAMELIST NAME FILE
	LCFT	(I5QT)	;ID CONFLICT QT
	JSB	(LBLMAK)	;LBL MAKER
	XNI	(NNAPNT)	;NAMELIST NAME PNTR
	STO	(ONERUN)	;ONE RUNG
NSTXL2:
	JSB	(IDSCAN)	;ID SCAN
	JSBF	(REGSCA)	;REGISTER SCALAR
	SMK	(SCAEM)	;SCALAR EM
	SMKF	(ARREM)	;ARRAY EM
	LCFF	(I15QT)	;ID CONFLICT QT
	ISE	(NNAFIL)	;NAMELIST NAME FILE
	ISEF	(GDMFIL)	;GLOBAL DMY FILE
	LCFT	(I6QT)	;ID CONFLICT QT
	CLA	(SYMBOL)	;SYMBOL
	MON	(NITROL)	;NAMELIST ITEMS ROLL
	CSA	(COMMA)	;COMMA
	JMPT	(NSTXL2)	;$2
	LSS	(BLANKS)	;BLANKS
	AGF	(NITFIL)	;NAMELIST ITEMS FILE
	SCE	(SLASH)	;SLASH
	JMPT	(NSTXL1)	;$1
	JSB	(REGALL)
				;LINE DELETED	;"23M"
	JMPF	(CEEEXI)	;COMMON EQUIV EOL EXIT
>
REGALL:					;REGISTER ALLIO.
	LSS	(ALLIO.)	;ALLIO.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	XIT	(EXIML)	;EXIT

IFNDEF	$NAME,
<
REGNAM:					;REGISTER NAMELIST
	LSS	(NMLST.)	;NMLST.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	FET	(CTBCON)	;CONVERT TO BIN CONST
	W2	(AMY)		;W2
	XIT	(EXIML)	;EXIT
>
IFNDEF	$IMPL,
<
IMSTXL:					;IMPLICIT STA XLATE
	FEX	(CMSTXL)	;COMMON STA XLATE
	QSF	(IMPQT)	;IMPLICIT QT
ITYENT:
	SCK	(LETKEY)	;"IMPLICIT" FOLLOWED BY LETTER ?
	CCFF	(S5QT)		;NO, ILLEGAL TYPE SPECIFICATION
	FET	(ZERO)		;GET BLANK PNTR TO HOLD TYPE
	QSA	(INTQT)		;INTEGER ?
	JMPF	(ITYEN1)	;NO, TRY AGAIN	;"23G"
	CSA	(ASTERI)	;"23G"
	CSAT	(N2)		;INTEGER*2 ?	;"23G"
	IERF	(ITYEM)		;NO, INTEGER	;"23G"
	IERT	(SINEM)		;YES, SUBSCRIPT INTEGER	;"23G"
	CSA	(N4)		;INTEGER=INTEGER*4	;"23G"
	JMP	(IPASCA)	;IMP PAREN SCAN	;"23G"
ITYEN1:			;"23G"
	QSA	(REAQT)		;REAL ?
	JMPF	(ITYEN2)	;NO, TRY AGAIN	;"23G"
	CSA	(ASTERI)	;"23G"
	CSAT	(N8)		;REAL*8 ?	;"23G"
	IERF	(RTYEM)		;NO, REAL	;"23G"
	IERT	(DPTEM)		;YES, DOUBLE PRECISION	;"23G"
	CSA	(N4)		;REAL=REAL*4
	JMP	(IPASCA)	;IMP PAREN SCAN	;"23G"
ITYEN2:				;"23G"
	QSA	(LOGQT)		;LOGICAL ?
	JMPF	(ITYEN3)	;NO, TRY AGAIN	;"23G"
	CSA	(ASTERI)	;LOGICAL=	;"23G"
	CSA	(N1)		;LOGICAL*1	;"23G"
	CSA	(N4)		;OR LOGICAL*4	;"23G"
	IER	(LTYEM)		;MAKE ALL OF THE ABOVE LOGICAL	;"23G"
	JMP	(IPASCA)	;IMP PAREN SCAN	;"23G"
ITYEN3:				;"23G"
	QSA	(COMPQT)	;COMPLEX ?
	JMPF	(ITYEN4)	;NO, TRY AGAIN	;"23G"
	CSA	(ASTERI)	;COMPLEX=
	CSAT	(N1)		;"23G"
	SCET	(N6)		;COMPLEX*16 ?	;"23G"
	CCFT	(S5QT)		;YES, ILLEGAL TYPE SPECIFICATION	;"23G"
	CSA	(N8)		;COMPLEX*8	;"23G"
	IER	(CTYEM)		;MAKE BOTH OF THE ABOVE COMPLEX 	;"23G"
	JMP	(IPASCA)	;IMP PAREN SCAN	;"23G"
ITYEN4:				;"23G"
	QSA	(DPRQT)	;DOUBLE PRECISION QT
	IERT	(DPTEM)	;DOUBLE PREC TYPE EM
	JMPT	(IPASCA)	;IMP PAREN SCAN
	QSA	(SUBSQT)	;SUBSCRIPT QT
	QSAT	(INTQT)	;INTEGER QT
	IERT	(SINEM)	;SUBSCRIPT INTEGER EM
	CCFF	(S5QT)	;SYNTAX QT
IPASCA:					;IMP PAREN SCAN
	CSF	(LPAREN)	;L PAREN
IPASC2:
	JSB	(IELSCA)	;IMP ELEMENT SCAN
	CSA	(COMMA)	;COMMA
	JMPT	(IPASC2)	;$2
	CSF	(RPAREN)	;R PAREN
	POW	(D1)		;ONE
	CSA	(COMMA)	;COMMA
	JMPT	(ITYENT)
	NOZ	(IIAFLA)	;"23M"
	SNZ	(GSTFLA)	;EXECUTABLE STATEMENTS PRECEED ?	;"23M"
	CCFT	(O3QT)		;YES, ORDER ERROR	;"23M"
	JMP	(CEEEXI)	;COMMON EQUIV EOL EXIT
>
IFNDEF	$IMPL,
<

IELSCA:					;IMP ELEMENT SCAN
	SCK	(LETKEY)	;LETTER KEY
	CCFF	(S6QT)	;SYNTAX QT
	XML	(ICFCML)	;IMPLICIT CLUE FROM CURRNT CHAR SET
	ISE	(IMPFIL)	;IMPLICIT FILE
	CCFT	(I3QT)	;SYNTAX QT
	FET	(IMPCLU)	;IMPLICIT CLUE
	W1	(IOR)		;W1
	MON	(IMPROL)	;IMPLICIT ROLL
	JSB	(NEXCHA)	;NEXT CHAR
	CSA	(MINUS)	;MINUS
	XITF	(EXIML)	;EXIT
	SCK	(LETKEY)	;LETTER KEY
	CCFF	(S6QT)	;SYNTAX QT
	FET	(IMPCLU)	;IMPLICIT CLUE
	XML	(ICFCML)	;IMPLICIT CLUE FROM CURRNT CHAR SET
	FET	(IMPCLU)	;IMPLICIT CLUE
	JSB	(NEXCHA)	;NEXT CHAR
	W1	(SWT)		;W1
IELSC1:
	W1	(SLK)		;W1
	XITF	(P2EML)
	ADD	(ONE)
	STO	(IMPCLU)	;IMPLICIT CLUE
	W1	(SWT)		;W1
	ISE	(IMPFIL)
	CCFT	(S12QT)		;SYNTAX QT	;"23N"
	FET	(IMPCLU)	;IMPLICIT CLUE
	W1	(IOR)		;W1
	MON	(IMPROL)	;IMPLICIT ROLL
	W1	(SWT)		;W1
	FET	(IMPCLU)	;IMPLICIT CLUE
	JMP	(IELSC1)	;$1
>
CMSTXL:					;COMMON STA XLATE
	FEX	(EQSTXL)	;EQUIVALENCE STA XLATE
	QSF	(COMQT)	;COMMON QT
	LSS	(COMM)	;COMM
	CSA	(SLASH)	;SLASH
	JMPF	(CMSTX2)	;$2
CMSTX1:
	CSA	(SLASH)	;SLASH
	JMPT	(CMSTX2)	;$2
	JSB	(SYMSCA)	;SYMBOL SCAN
	CSF	(SLASH)	;SLASH
CMSTX2:
	AGF	(CNAFIL)	;COMMON NAMES FILE
CMSTX3:
	JSB	(SYMSCA)	;SYMBOL SCAN
	ISE	(CDAFIL)	;COMMON DATA FILE
	ISEF	(GDMFIL)	;GLOBAL DMY FILE
	ISEF	(GSPFIL)	;GLOBAL SPROG FILE
	LCFT	(A2QT)	;ALLOCATION QT
	AGF	(CDAFIL)	;COMMON DATA FILE
	CSA	(LPAREN)	;L PAREN
	JSBT	(DSEXLA)	;DIMENSION SEQ XLATE
	CSA	(COMMA)	;COMMA
	JMPT	(CMSTX3)	;$3
	LSS	(BLANKS)	;BLANKS
	AGF	(CDAFIL)	;COMMON DATA FILE
	LSS	(COMM)	;COMM
	CSA	(SLASH)	;SLASH
	JMPT	(CMSTX1)
				;LINE DELETED	;"23M"
	JMP	(CEEEXI)	;COMMON EQUIV EOL EXIT
EQSTXL:					;EQUIVALENCE STA XLATE
	FEX	(EXSTXL)	;EXTERNAL STA XLATE
	QSF	(EQUQT)	;EQUIVALENCE QT
ESTXL1:
	CSF	(LPAREN)	;L PAREN
	ZER	(TEMP)		;SET FOR 2 ELEMENTS IN EQUIV
	JSB	(ESEXLA)	;EQUIV SEG XLATE
	SNZ	(TEMP)		;AT LEAST 2 ITEMS IN EQUIV?
	LCFF	(S19QT)		;NO ERROR
	CSF	(RPAREN)	;R PAREN
	LSS	(BLANKS)	;BLANKS
	AGF	(EDAFIL)	;EQUIV DATA FILE
	CSA	(COMMA)	;COMMA
	JMPT	(ESTXL1)
				;LINE DELETED	;"23M"
	JMP	(CEEEXI)	;COMMON EQUIV EOL EXIT
ESEXLA:					;EQUIV SEG XLATE
	JSB	(SYMSCA)	;SYMBOL SCAN
	ISE	(GDMFIL)	;GLOBAL DMY FILE
	LCFT	(A3QT)	;ALLOCATION QT
	ISE	(ARRFIL)	;ARRAY FILE
	CSAT	(LPAREN)	;L PAREN
	ZERF	(DAT1)	;DATA 1
	JMPF	(ESEXL3)	;$3
	XNI	(CREPNT)	;CRRNT REG PNTR
	FET	(OFFRUN)	;OFFSET RUNG
	XNI	(CREPNT)	;CRRNT REG PNTR
	FET	(SPNRUN)	;STAT PNTR RUNG
	STK	(ASTPNT)	;ARRAY STAT PNTR
	XW0.0	(CLA)		;ZERO RUNG
ESEXL1:
	JOW	(ESEXL2)	;$2
	DFA	(ASTROL)	;ARRAY STAT ROLL
	JSB	(SINSCA)	;SIGNED INTEGER SCAN
	MPY	(DAT2)	;DATA 2
	W2	(SMY)		;W2
	CSA	(COMMA)	;COMMA
	JMPT	(ESEXL1)	;$1
	JOW	(ESEXL2)	;$2
	ADD	(TWO)		;TWO
	XNI	(ARRPNT)	;ARRAY PNTR
	XNI	(SPNRUN)	;STAT PNTR RUNG
	SEQ	(ZERRUN)	;ZERO RUNG
	LCFF	(M2QT)	;TOO FEW SCRIPTS QT
	W0	(TLY)		;W0
	XNI	(ARRPNT)	;ARRAY PNTR
	SUB	(OFFRUN)	;OFFSET RUNG
ESEXL2:
	STO	(DAT1)	;DATA 1
	CSA	(RPAREN)	;R PAREN
	CCFF	(M1QT)	;TOO MANY SCRIPTS QT
ESEXL3:
	AGF	(EDAFIL)	;EQUIV DATA FILE
	CSA	(COMMA)	;COMMA
	TLYT	(TEMP)		;NOW THERE IS AT LEAST 2
	JMPT	(ESEXLA)	;EQUIV SEG XLATE
	XIT	(EXIML)	;EXIT
EXSTXL:					;EXTERNAL STA XLATE
	FEX	(RTSTXL)	;RETURN STA XLATE
	QSF	(EXTQT)	;EXTERNAL QT
EXSTX1:
	JSB	(IDSCAN)	;ID SCAN
	JMPT	(EXSTX2)	;$2
	ISEF	(CDAFIL)	;COMMON DATA FILE
			;LINE DELETED HERE "22G"
	FPCT	(ZERO)	;ZERO
EXSTX2:
	ERMT	(I7QT)	;ID CONFLICT QT
	AGFF	(GSPFIL)	;GLOBAL SPROG FILE
	CSA	(COMMA)	;COMMA
	JMPT	(EXSTX1)	;$1
	JMP	(CEEEXI)	;COMMON EQUIV EOL EXIT
RTSTXL:					;RETURN STA XLATE
	FEX	(ASSTXL)	;ASSIGN STA XLATE
	QSF	(RETQT)	;RETURN QT
	XNI	(NOPPNT)	;NAME OF PROG PNTR
	FET	(ZERRUN)	;ZERO RUNG
	SEK	(MAITES)	;MAIN. TEST
	JMPT	(STSTX1)	;MAKE JSA	16,EXIT	;"21F"
	NOZ	(JOUFLA)	;SET JUMP OUT FLG "22F"
	SEQ	(DATTES)	;DATA. TEST
	JMPT	(ACEOEX)	;ACTIVE EOL EXIT
	SCE	(CRR)		;CAR RET "22A"
	JMPT	(RTSTX3)	;YES "22A
	SNZ	(MULRET)	;MULT RETURN? "22A"
	CCEF	(S16QT)		;NO ERR "22A"
	JMPF	(RTSTX4)	;"22A"
	SCK	(DIGKEY)	;DIGITS? "22A"
	JMPF	(RTSTX2)	;NO "22A"
	JSB	(INTSCA)	;CHECK INTEGERS "22A"
	FET	(DAT2)		;GET THE NUMBER "22A"
	POC	(ABSINS)	;SET FOR ABSOLUTE "22A"
	BAI	(.MEI1)		;MOVE "22A"
	JMP	(RTSTX4)	;"22A"
RTSTX2:
	JSB	(IVASCA)	;INDUCED VAR SCA "22A"
	BAI	(.ME2)		;MOVE "22A"
	JMP	(RTSTX4)	;"22A"
RTSTX3:
	SNZ	(MULRET)	;MULT RETURN? "22A"
	JMPF	(RTSTX4)	;"22A"
	POC	(ABSINS)	;ABSOLUTE "22A"
	FET	(ZERO)		;ZERO "22A"
	BAI	(.MEI1)		;MOVE "22A"
RTSTX4:			;"22A"
	SNZ	(RETPNT)	;RETURN PNTR
	JSBF	(LBLMAK)	;LBL MAKER
	STKF	(RETPNT)	;RETURN PNTR
	FETT	(RETPNT)	;RETURN PNTR
	BAI	(.JRST0)
	JMP	(RETEXI)	;RETURN EOL EXIT	;"23P"
ASSTXL:					;ASSIGN STA XLATE
	FEX	(PASTXL)	;PAUSE STA XLATE
	QSF	(ASSQT)	;ASSIGN QT
	NOZ	(ENDFLG)	;[27F]SET ENDFLG SINCE IT DOES WHAT WE WANT
	JSB	(LBLSCA)	;LBL SCAN
	ZER	(ENDFLG)	;[27F]CLEAR ENDFLG, WE HAVE FOOLED LBLSCA
	BAI	(.MEI0)	;MOVEI INST
	QSF	(TOQT)	;TO QT
	JSB	(VARSCA)	;VAR SCAN
	BAI	(.MEM0)	;MOVEM INST
	JMP	(ACEOEX)	;ACTIVE EOL EXIT
PASTXL:					;PAUSE STA XLATE
	FEX	(STSTXL)	;STOP STA XLATE
	QSF	(PAUQT)	;PAUSE QT
	SCE	(CRR)		;CAR RETURN
	POCT	(ABSINS)	;ABS INST
	POCT	(.MEI1)	;MOVEI 1 INST
	JMPT	(PASTX1)	;$1
	SCK	(DIGKEY)	;DIGIT KEY
	JSBT	(ODISCA)	;OCTAL DIGIT SCAN
	JSBT	(RINCON)	;REGISTER INTEGER CONST
	JSBF	(CONSCA)	;CONST SCAN
	SMK	(HCOEM)	;HOLLERITH CONST EM
	BAIF	(.RROI1)	;HRROI 1 INST
	XW0.0T	(FET)		;ZERO RUNG
	W1T	(SWT)		;W1
	BAIT	(.MEI1)	;MOVEI 1 INST
	IORT	(HRLI1I)	;HRLI 1 INST
	POCT	(ABSINS)	;ABS INST
	MONT	(CODROL)	;CODE ROLL
PASTX1:
	LSS	(PAUSE.)	;PAUSE.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	FET	(CREPNT)	;CRRNT REG PNTR
	BAI	(.PSHJ1)	;PUSHJ 17 INST
	JMP	(ACEOEX)	;ACTIVE EOL EXIT
STSTXL:					;STOP STA XLATE
	FEX	(RWSTXL)	;REWIND STA XLATE
	QSF	(STOQT)	;STOP QT
	SCE	(CRR)		;A NORMAL STOP ?
	JMPT	(STSTX1)	;YES,FINISH UP
	SCK	(DIGKEY)	;FOLLOWED BY A NUMBER ?
	JSBT	(ODISCA)	;GET AN OCTAL NUMBER
	JSBT	(RINCON)	;REGISTER THE CONSTANT
	BAIT	(.ARG0)	;PASS IT ON TO FORSE.
STSTX1:
	LSS	(EXIT.)	;EXIT.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	FET	(CREPNT)	;CRRNT REG PNTR
	BAI	(.JSA1)
	JMP	(STOEXI)	;STOP EOL EXIT	;"23P"
RWSTXL:					;REWIND STA XLATE
	FEX	(BASTXL)	;BACKSPACE STA XLATE
	QSF	(REWQT)	;REWIND QT
	FET	(ZERO)	;ZERO
TFIXLA:					;TAPE FINISH XLATE
	LSS	(TPFCN.)	;TPFCN.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
BSTFXL:					;BACKSP.,SKIP TAPE FIN XLATE
	ADD	(BREPNT)	;BLANK REG PNTR
	JSB	(FESACO)	;FX EXP SCAN AND COLLAPSE
	SMK	(CONEM)	;CONST EM
	JMPF	(TFIXL1)	;$1
	XW0.0	(CLA)		;ZERO RUNG
	AND	(DISMAS)	;DISPL MASK
	ADD	(BREPNT)	;BLANK REG PNTR
	JMP	(TFIXL2)	;$2
TFIXL1:
	JSB	(EIR0GE)	;EXP IN REG 0 GEN
	JSB	(LBLMAK)	;LBL MAKER
	BAK	(.RRM0)	;HRRM 0 INST
	JSB	(LBLGEN)	;LBL GEN
TFIXL2:
	BIN	(..MTO0)	;MTOP INST
	POW	(D1)		;ONE
	JMP	(ACEOEX)	;ACTIVE EOL EXIT
BASTXL:					;BACKSPACE STA XLATE
	FEX	(USTXLA)	;UNLOAD STA XLATE
	QSF	(BACQT)	;BACKSPACE QT
	FET	(TWO)		;TWO
	LSS	(MBSR.)	;MBSR.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	JMP	(BSTFXL)	;BACKSP.,SKIP TAPE FIN XLATE
USTXLA:					;UNLOAD STA XLATE
	FEX	(SKIXLA)	;SKIP XLATE
	QSF	(UNLQT)	;UNLOAD QT
	FET	(ONE)		;ONE
	JMP	(TFIXLA)	;TAPE FINISH XLATE
SKIXLA:					;SKIP XLATE
	FEX	(ENDXLA)	;END XLATE
	QSF	(SKIQT)	;SKIP QT
	QSF	(RECQT)	;RECORD QT
	FET	(FIVE)	;FIVE
	LSS	(MSPR.)	;MSPR.
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	JMP	(BSTFXL)	;BACKSP,SKIP TAPE FIN XLATE
ENDXLA:					;END XLATE
	FEX	(ERSTXL)	;ERASE STA XLATE
	QSF	(ENDQT)	;END QT
	SCE	(CRR)		;CAR RET CHAR I
ENSTXL:					;END STA XLATE
	NOZT	(ESTFLA)	;END STA FLAG
	XITT	(ETRML)	;EXIT TRUE EOL
ENSTX1:
	QSF	(FILQT)	;FILE QT
	EAW	(D4)		;FOUR
	JMP	(TFIXLA)	;TAPE FINISH XLATE
ERSTXL:					;ERASE STA XLATE
	FEX	(ISTPAR)	;ILLEGAL STATEMENT PARSE
	QSF	(ERAQT)	;ERASE QT
	EAW	(D6)		;SIX
	JMP	(TFIXLA)	;TAPE FINISH XLATE
ISTPAR:					;ILLEGAL STA PARSE
	SRD	(ERRROL)	;ERROR ROLL
	JMPT	(ISTPA1)	;$1
	SNZ	(FAICAR)
	CCEF	(S2QT)		;SYNTAX QT	;"23N"
	FET	(FMSBOX)	;FAIL MSG BOX
	MON	(ERRROL)	;ERROR ROLL
ISTPA1:
	XML	(OER0ML)	;ORDER ERROR ROLL
	ZER	(JSTFLA)	;JUMP STA FLAG
	JSB	(DCLGEN)	;DO CLOSE GEN
	BLK	(.EXER1)	;EXER1. LINK
	JMP	(EXIFAL)	;EXIT FALSE

CDEEXI:				;INTEGER,SUBSCRIPT INTEGER,REAL,LOGICAL,
				;DOUBLE PRECISION & COMPLEX TYPE STATEMENT
				;END OF LINE EXIT
	POW	(D1)		;ONE
CEEEXI:				;COMMON,EQUIVALENCE,EXTERNAL,IMPLICIT,NAMELIST,
				;DATA & DIMENSION END OF LINE EXIT
	ZER	(ENDCOD)	;"23P"
	NOZ	(IIAFLA)	;ILLEGAL IF ARG FLAG
	SCE	(CRR)		;CAR RETURN
	CCFF	(S9QT)		;SYNTAX QT	;"23M"
				;2 LINES DELETED	;"23M"
	XIT	(ETRML)	;EXIT TRUE EOL

AEOEXI:				;AFDS EOL EXIT
	ZER	(ENDCOD)	;"23P"
	SCE	(CRR)		;CAR RETURN
	JMPT	(JAFEXI)	;JUMP AFDS EXIT
	CCF	(S20QT)		;SYNTAX QT	;"23M"
LIFEXI:				;LOGICAL IF EXIT
	NOZ	(IIAFLA)	;ILLEGAL IF ARG FLAG
ACEOEX:				;ACTIVE (ASSIGNMENT,CALL,CONTINUE,I/O,
				;RETURN(BLOCK DATA),ASSIGN,PAUSE,REWIND,
				;BACKSPACE,UNLOAD,SKIP RECORD,END FILE &
				;ERASE) END OF LINE EXIT
	SCE	(CRR)		;CAR RETURN
	CCFF	(S22QT)		;SYNTAX QT	;"23M"
	ZER	(JSTFLA)	;JUMP STA FLAG
	ZER	(ENDCOD)	;"23P"
	JMP	(JUMEXI)	;JUMP-ACTIVE EXIT

STOEXI:				;STOP STATEMENT END OF LINE EXIT	;"23P"
	XNI	(NOPPNT)	;GET PROGRAM NAME	;"23P"
	FET	(ZERRUN)	;"23P"
	SEQ	(MAITES)	;MAIN PROGRAM ?	;"23P"
	JMPF	(JEOEXI)	;NO, STOP & END GEN DIFFERENT CODE	;"23P"
RETEXI:				;RETURN STATEMENT END OF LINE EXIT	;"23P"
	NOZ	(ENDCOD)	;INDICATE END STA CODE ALREADY GENNED	;"23P"
	JMP	(JEOEX1)	;"23P"
DOEOEX:				;DO STATEMENT END OF LINE EXIT
	NOZ	(IIAFLA)	;ILLEGAL IF ARG FLAG
JEOEXI:				;GO TO END OF LINE EXIT
	ZER	(ENDCOD)	;"23P"
JEOEX1:				;"23P"
	SCE	(CRR)		;CAR RETURN
	CCFF	(S22QT)		;SYNTAX QT	;"23M"
	NOZ	(JSTFLA)	;JUMP STA FLAG
JUMEXI:					;JUMP-ACTIVE EXIT
	NOZ	(ASTFLA)	;ACTIVE STA FLAG
	JSB	(DCLGEN)	;DO CLOSE GEN
JAFEXI:					;JUMP AFDS EXIT

IFNDEF	$DATA,
<
	SNZ	(BDPFLA)
	CCFT	(O4QT)		;BLOCK QT	;"23N"
>
	NOZ	(GSTFLA)	;GEN STA FLAG
	XML	(ETRML)	;EXIT TRUE
AEXSCA:					;ARG EXP SCAN
	NOZ	(FELFLA)	;FIRST ELEM FLAG
EXPSCA:					;EXP SCAN
	ZER	(OPCPNT)	;OP PNTR
	JMP	(SUSCAN)	;SUBEXP SCAN
SSUSCA:					;SIGNED SUBEXP SCAN
	CSA	(MINUS)	;MINUS
	JSBT	(SUSCAN)	;SUBEXP SCAN
	EORT	(MINMAS)	;MINUS MASK
	XITT	(EXIML)	;EXIT
	CSA	(PLUS)	;PLUS
SUSCAN:					;SUBEXP SCAN
	RSV	(SUDROL)	;SUBORDS ROLL
	JSB	(DESCEN)	;DESCEND
	JSB	(SUBSCA)	;SUBORD SCAN
SUSCFI:					;SUBEXP SCAN FIN
	XML	(OPSCML)	;OP SCAN
	JSBF	(COLSUB)	;COLLAPSE SUBORDS
	RELF	(SUDROL)	;SUBORDS ROLL
	XITF	(ASCML)	;ASCEND
	FPC	(OPCPNT)	;OP PNTR
	W1	(SWT)		;W1
	MON	(SUDROL)	;SUBORDS ROLL
	SPK	(NEGTRA)	;NEG OP TRAIT
	EORT	(NOFMAS)	;NEG OP FLIP MASK
	JSB	(SUBSCA)	;SUBORD SCAN
	EORT	(MINMAS)	;MINUS MASK
	W1	(FET)		;W1
	SPT	(COMTRA)	;COMMUTATIVE TRAIT
	JSBF	(COLSUB)	;COLLAPSE SUBORDS
	XMLT	(OSRML)	;ORDER SUBORDS ROLL
	JMP	(SUSCFI)	;SUBEXP SCAN FIN
LUNSCA:					;LOGICAL UNARY SCAN
	QSA	(NOQT)	;.NOT. QT
	JMPF	(SUSCAN)	;SUBEXP SCAN
	FPC	(NOTMAS)	;NOT MASK
	JSB	(LUNSCA)	;LOGICAL UNARY SCAN
	AND	(ABCCMA)	;ALL BUT CHAR CNT MASK
	W1	(EOM)		;W1
	XIT	(EXIML)	;EXIT
COLSUB:					;COLLAPSE SUBORDS
COLSU1:
	MOA	(SUDROL)	;SUBORDS ROLL
	XITF	(EXIML)	;EXIT
	W2	(FET)		;W2
	SPT	(LOPTRA)	;LOGICAL OP TRAIT
	JSBT	(CLOIDE)	;COLLAPSE LOGICAL IDEMPOT
	JMPT	(COLSU2)	;RESULT IS ALWAYS LOGICAL IF COLLAPSED ;"21I"
	PNG	(NESROL)	;NEST ROLL
	W3	(SWT)		;W3
	JSB	(NESMOV)	;NEST MOVE
	JMP	(COLSU1)	;$1
COLSU2:
	IER	(LTYEM)		;MAKE THE PNTR LOGICAL ;"21I"
	SMK	(SUBEM)		;IS THIS A SUBEXPRESSION ;"21I"
	JMPF	(COLSU1)	;NO, CONTINUE ITERATION ;"21I"
	SPKT	(OTAEM)		;OR A FUNCTION POINTER ? ;"21I"
	XW0.0F	(FET)		;YES, CHANGE THE FUNCTION PNTR ;"21I"
	IERF	(LTYEM)		;OR OTHER PNTR TO TYPE LOGICAL ;"21I"
	XW1.0F	(STO)		;RESTORE THE FUNCTION PNTR ;"21I"
	JMP	(COLSU1)	;AND CONTINUE ITERATION ;"21I"
IFNDEF	$CCONS,
<

CCOSUB:					;COLLAPSE CONST SUBEXP
	FET	(EOPPNT)
	SME	(DITEM)
	SONF	(DITEM)	;DOUBLE ITEM EM
	SMKF	(DITEM)	;DOUBLE ITEM EM
	SONF	(HTYEM)	;HOLLERITH TYPE EM
	SMKF	(HTYEM)	;HOLLERITH TYPE EM
	XITT	(EFAML)	;EXIT FALSE
	FET	(OPNCLU)	;OP PNTR CLUE
	AND	(DISMAS)	;DISPL MASK
	SGK	(TWEONE)	;TWENTY ONE
	SLKF	(SIXTEE)	;SIXTEEN
	XMLT	(P1EFML)	;PRUNE ONE EXIT FALSE
	SGK	(SEVENT)	;SEVENTEEN
	SUBT	(ONE)		;ONE
	FET	(EOPPNT)	;EXP OP PNTR
	SMK	(ITYEM)		;INTEGER TYPE EM
	SMKF	(LTYEM)		;STR524
	SMKF	(OCTEM)		;OCTAL TYPE EM ; "26G"
	POW	(D1)
	EAWT	(D16)		;SIXTEEN
	EAWF	(D12)		;TWELVE
	W1	(SMY)		;W1
	JSBT	(FETCON)	;FETCH CONST
	JSBF	(FACCON)	;FETCH AND CONV CONST
	JSBT	(FETCON)	;FETCH CONST
	JSBF	(FACCON)	;FETCH AND CONV CONST
	XML	(CARML)	;PERFORM AND CHECK CONST ARITHMETIC
	STO	(DAT1)	;DATA 1
	ZER	(DAT2)		;CLEAR LOWER
	FET	(EOPPNT)	;EXP OP PNTR
	SME	(ITYEM)	;INTEGER TYPE EM
	JMPT	(CCOSU1)	;$1
	REG	(RCOFIL)	;REAL CONST FILE
	JMP	(CCOSU2)	;$2
CCOSU1:
	REG	(ICOFIL)	;INTEGER CONST FILE
CCOSU2:
	FET	(CREPNT)	;CRRNT REG PNTR
	SMK	(TCPEM)		;TR1080
	CLAT	(CONPNT)	;-1 _ .TRUE.
	IERT	(MINEM)
	XIT	(ETRML)		;EXIT TRUE
>
IFNDEF	$CCONS,
<
FACCON:					;FETCH AND CONV CONST
	W2	(FET)		;W2
>

FACCFI:					;FETCH AND CONV CONST FIN
	SMK	(ITYEM)	;INTEGER TYPE EM
	JMP	(FCOFIN)	;FETCH CONST FIN

IFNDEF	$CCONS,
<
FETCON:					;FETCH CONST
	W2	(FET)		;W2
>

GETCON:					;GET CONSTANT
	SNZ	(ZERO)	;ZERO
FCOFIN:					;FETCH CONST FIN
	XW0.0	(FET)		;ZERO RUNG
CCAASI:					;CONVERT CONST AND ADJUST SIGN
	XMLT	(FINML)	;CONVERT INTEGER TO FL
CSIADJ:					;CONST SIGN ADJUST
	SON	(MINEM)	;MINUS EM
	W1	(ZER)		;W1
	W1T	(SMY)		;W1
	W1F	(AMY)		;W1
	XIT	(EXIML)	;EXIT
ATNAMO:					;ADD TO NEST AND MOVE
	PNG	(NESROL)	;NEST ROLL
	W2	(SWT)		;W2
	FET	(IADPNT)	;INTEGER ADD PNTR
NESMOV:					;NEST MOVE
	SPK	(LOPTRA)	;LOGICAL OP TRAIT
	IERT	(LTYEM)	;LOGICAL TYPE EM
	FETT	(LTYSTA)	;LOGICAL TYPE STAMP
	XMLF	(BTSML)	;BINARY TYPE SELECT
	W1	(FET)		;W1
	ERKF	(M5QT)	;ILLEGAL CONVERSION IMPLIED
	SPT	(ROPTRA)	;REL OP TRAIT
	CLAT	(LTYSTA)	;LOGICAL TYPE STAMP
	W4	(IOM)		;W4
	MON	(NESROL)	;NEST ROLL
	MON	(NESROL)	;NEST ROLL
	MON	(NESROL)	;NEST ROLL
	XIT	(EXIML)	;EXIT

ESACOL:					;EXP SCAN AND COLLAPSE
	JSB	(EXPSCA)
SUBCOL:					;SUBEXP COLLAPSE
	STK	(EOPPNT)	;EXP OP PNTR
	JSB	(SCOFIN)	;SUBEXP COLLAPSE FIN
	REL	(NESROL)	;NEST ROLL
	W0	(FET)		;W0
	JMP	(SUSTLY)	;SUBEXP USE TLY
SCOFIN:					;SUBEXP COLLAPSE FIN
	SMK	(NESEM)	;NEST EM
	XITF	(EXIML)	;EXIT
	SMK	(LTYEM)	;LOGICAL TYPE EM
	JMPF	(SCOFI1)	;$1
	XW0.0	(FET)		;OP PNTR RUNG
	SPK	(ROPTRA)	;REL OP TRAIT
	STOT	(EOPPNT)	;EXP OP PNTR
	POWF	(D1)		;ONE
SCOFI1:
	XW0.1	(FET)		;A PART RUNG
	JSB	(SCOFIN)	;SUBEXP COLLAPSE FIN
	XW1.2	(FET)		;B PART RUNG
	JSB	(SCOFIN)	;SUBEXP COLLAPSE FIN
	XW2.0	(FET)		;OP PNTR RUNG
	STK	(EOPPNT)	;SET TO CURRENT TYPE "22D"
	JSB	(SUBREG)	;SUBEXP REGISTER
	FETT	(LTYSTA)	;LOGICAL TYPE STAMP
	STOT	(EOPPNT)	;EXP OP PNTR
	IER	(ETYEM)	;EXP TYPE EM
	XIT	(EXIML)	;EXIT
SUBREG:					;SUBEXP REGISTER
	STO	(OPNCLU)	;OP PNTR CLUE
	STK	(BPACLU)	;B PART CLUE

IFNDEF	$CCONS,
<
	SMK	(CONEM)	;CONST EM
>
	W1	(SWT)		;W1
	STK	(APACLU)	;A PART CLUE
IFNDEF	$CCONS,
<
	SMKT	(CONEM)	;CONST EM
	JSBT	(CCOSUB)	;COLLAPSE CONST SUBEXP
	JMPT	(SUBRE1)	;$1
>
	REG	(SUBFIL)	;SUBEXP FILE
	FET	(SUBPNT)	;SUBEXP PNTR
	FET	(OPNCLU)	;GET THE CURRENT OP CODE
	SMK	(ITYEM)		;IS IT AN INTEGER OPERATION ?
	POWF	(D1)		;NO, PRUNE
	JMPF	(SUBRE1)
	SPT	(COMTRA)	;IS IT COMMUTATIVE ?
	W1T	(FET)		;YES,GET B PART
	JSBT	(SUSTLY)	;ORDER OF USE MAY REQUIRE SAVEING
	SNZT	(ZERO)	;CHANGE FLAG TO PREVENT COLLAPSED CONSTANT EXIT
SUBRE1:
	W3	(SWT)		;W3
	AND	(SANMAS)	;SIGN AND NOT MASK
	W3	(IOM)		;W3
	XMLT	(P2EML)	;PRUNE TWO EXIT
	JSB	(SUSTLY)	;SUBEXP USE TLY
SUSTLY:					;SUBEXP USE TLY
	SMK	(SUBEM)	;SUBEXP EM
	XW0.4T	(TLY)		;USE CNT RUNG
	XML	(P1EML)	;PRUNE ONE EXIT
ELESCA:					;ELEMENT SCAN
	CSA	(MINUS)	;MINUS
	JSBT	(PELSCA)	;POSITIVE ELEM SCAN
	EORT	(MINMAS)	;MINUS MASK
	XITT	(EXIML)	;EXIT
	CSA	(PLUS)	;PLUS
PELSCA:					;POSITIVE ELEM SCAN
	CSA	(LPAREN)	;L PAREN
	JMPF	(OELSCA)	;OPEN ELEM SCAN
	FET	(OPCPNT)	;OP PNTR
	JSB	(EXPSCA)	;EXP SCAN
	W1	(SWT)		;W1
	STO	(OPCPNT)	;OP PNTR
	SMK	(CCRPEM)	;COMPLEX CONST REAL PART EM
	SCET	(COMMA)	;COMMA
	CSFF	(RPAREN)	;R PAREN
	XITF	(EXIML)	;EXIT
	XW0.0	(FET)		;ZERO RUNG
	STO	(DAT1)	;DATA 1
	JSB	(CCSFIN)	;COMPLEX CONST SCAN FIN
	JMP	(RCOCON)	;REGISTER COMPLEX CONST
OELSCA:					;OPEN ELEM SCAN
	SCK	(LETKEY)	;LETTER KEY
	JMPF	(CONSCA)	;CONST SCAN
	JSB	(IDSCAN)	;ID SCAN
	JMPF	(OELSC1)	;$1
	CSA	(LPAREN)	;L PAREN
	JMPT	(AELSCA)	;APPENDED ELEM SCAN
	SMK	(LSPEM)	;LOCAL SPROG EM
	CCFT	(S15QT)	;SYNTAX QT
	SMK	(ARREM)	;ARRAY ID EM
	SMKF	(GSPEM)	;GLOBAL SPROG EM
	JMPF	(FEREXI)	;$2
	SNZ	(FELFLA)	;FIRST ELEM FLAG
	SNZT	(SARFLA)	;SPROG ARG FLAG
	JMPF	(SFAW0)	;SYNTAX FAIL W0
	ISE	(GDMFIL)	;GLOBAL DUMMY FILE
	IERT	(DMYEM)	;DUMMY EM
	JMP	(FEREXI)	;FIRST ELEM RESET EXIT

OELSC1:
	CSA	(LPAREN)	;L PAREN
	JMPF	(REGSCA)	;REGISTER SCALAR
	ISET	(CNAFIL)	;COMMON BLOCK NAME ?
	LCFT	(I10QT)	;YES, SPROG NAME ALREADY IN USE ERR MSG
	JSB	(RGLSPR)	;REGISTER GLOBAL SPROG
	JMP	(SASXLA)	;SPROG ARG SEQ XLATE
AELSCA:					;APPENDED ELEM SCAN
	SMK	(LDMEM)	;LOCAL DMY EM
	LCFT	(I13QT)	;ID CONFLICT QT ;"21J"
			;LINE DELETED ;"21J"
	SMK	(ARREM)	;ARRAY ID EM
	JMPT	(AREXLA)	;ARRAY REF XLATE
	SMK	(SCAEM)	;SCALAR FOLLOWED BY LPAREN ?
	LCFT	(I10QT)	;SUB NAME ALREADY IN USE ;"21J"
			;LINE DELETED ;"21J"
SASXLA:					;SPROG ARG SEQ XLATE
	FET	(OPCPNT)	;"23AG"
	W1	(SWT)		;"23AG"
	ISE	(LFUFIL)	;LIB FUNC FILE
	FETF	(ZERO)		;"23AG"
	JMPF	(SASXL3)	;"23AG"
	XML	(ITSML)		;RE-TYPE LIB FUNCT ;"23AG"
	XNI	(CREPNT)	;"23AG"
	FET	(ONERUN)	;"23AG"
SASXL3:				;"23AG"
	W1	(SWT)		;"23AG"
	JSB	(TYPEVA)	;RE TYPE IF EXPLICIT - "20B"
	W1T	(ZER)		;"23AG"
				;2 LINES DELETED ;"23AG"
	RSV	(APNROL)	;ARG PNTR ROLL
SASXL1:
	RSV	(NESROL)	;NEST ROLL
	NOZ	(SARFLA)	;SPROG ARG FLAG
	SNZ	(SPSW)		;[27M]DOING AN OPEN OR CLOSE?
	JMPT	(OCARG)		;[27M]YES, GO CLASSIFY THE TYPE
CTRCAL:
	CSA	(DOLLAR)	;$? "22A"
	CSAF	(AMPSND)	;&? "23G"
	CSAF	(ASTERI)	;*? "22A"
	JSBT	(LBLSCA)	;FIND A LABEL "22A"
	JSBF	(AEXSCA)	;ARG EXP SCAN "22A"
	JSBF	(SUBCOL)	;COLLAPSE SUBEXP "22A"
	SMK	(SCAEM)	;SCALAR ?
	SMKF	(ARREM)	;OR ARRAY NAME ?
	JMPF	(SASXL2)	;NO, SKIP THE EXTRA CHECKS
	XW0.0	(FET)		;YES,GET THE NAME
	STO	(SYMBOL)	;STORE IT FOR SEARCH
	ISE	(GDMFIL)	;GLOBAL DUMMY ?
	REGT	(DEFFIL)	;YES, REGISTER AS DEFINED
SASXL2:	W2	(SNZ)		;"23GG"
	JMPF	(SASXL4)	;"23GG"
	SMK	(OCTEM)		;OCTAL TYPE ARGUMENT? ;  "26K"
	JMPT	(SASXL4)		;YES, ALLOW IT WITHOUT TYPE CHECKING ; "26K"
	W2	(FET)		;"23AG"
	SMK	(LTYEM)		;"24-6"
	JMPT	(SASXL6)	;"24-6"
	STK	(LFUATO)	;"23AG" -"24-6"
	SON	(LFUTEM)	;"23GG" - "24-6"
	CCFF	(I8QT)		;"23GG"
SASXL6:			;"24-6"
	POW	(D1)		;"24-6"
SASXL4:				;"23GG"
	MON	(APNROL)	;ARG PNTR ROLL
	CSA	(COMMA)	;COMMA
	JMPT	(SASXL1)	;$1
	CSF	(RPAREN)	;R PAREN
	W1	(SWT)		;"23AG"
	W0	(SNZ)		;"23GG"
	JMPF	(SASXL5)	;"23GG"
	AND	(RHAMAS)	;"23GG"
	CNT	(APNROL)	;"23GG"
	W1	(SLT)		;"23GG"
	CCFT	(I9QT)		;"23GG"
SASXL5:				;"23GG"
	POW	(D1)		;"23GG"
	STK	(FRNCLU)	;FUNC REF NAME CLUE
	EAW	(APNROL)	;ARG PNTR ROLL
	RPL	(APLROL)	;ARG PLEX ROLL
	REL	(APNROL)
	STO	(FRAPCL)	;FUNC REF ARG PLEX CLUE
	ZER	(BPACLU)	;B PART CLUE
	REG	(FREFIL)	;FUNC REF FILE
	AND	(TYPMAS)	;TYPE MASK
	IOM	(FREPNT)	;FUNC REF PNTR
	STO	(OPCPNT)	;OP PNTR
	ZER	(SARFLA)	;SPROG ARG FLAG
	NOZ	(JOUFLA)	;JUMP OUT FLAG (DO LOOP)
	FET	(FREPNT)	;FUNC REF PNTR
	IER	(FREEM)	;FUNC REF EM
	JMP	(FEREXI)	;FIRST ELEM RESET EXIT

OCARG:	ZER	(ARGNUM)	;[27M]ZERO FOROTS O/C ARG #
	ZER	(NULDIA)	;[27M]AND DIALOG W/NULL ARG
	QSA	(UNITQT)	;[27M]IS IT UNIT NUMBER?
	NOZT	(UNIDEF)	;[27M]YES, MARK AS DEFINED
	JMPT	(OCBCK)		;[27M]AND GO BACK
	TLY	(ARGNUM)	;[27M]DIALOG= IS FOROTS ARG 1
	QSA	(DIALQT)	;[27M]CHK IT
	JMPF	(SACC)		;[27M]NO, SEE IF ACCESS
	CSA	(EQUAL)		;[27M]IS IT NULL ARGUMENT?
	FETF	(CZEPNT)	;[27M]GIVE IT A ZERO ARGUMENT
	NOZF	(NULDIA)	;[27M]AND MARK IT
OCBCK:	
	TLY	(ARGKNT)	;[27M]UP THE ARGUMENT COUNT
	XML	(NXTAML)	;[27M]REGISTER IT
	LCFT	(M25QT)		;[27M]IF A DUPLICATE
	FET	(ARGKNT)	;[27M]IF FIRST VALID ARG
	SEQ	(ONE)		;[27M]THEN CLEAR
	RELT	(ERRROL)	;[27M]THE ERROR ROLL
	SNZ	(NULDIA)	;[27M]IF NULL DIALOG
	JMPT	(SASXL4)	;[27M]WE HAVE OUR ARGUMENT
	JMP	(CTRCAL)	;[27M]BACK TO PROCESS REAL ARG
SACC:	TLY	(ARGNUM)	;[27M]UP ARGUMENT COUNTER
	QSA	(ACCSQT)	;[27M]ACCESS?
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]NO
	QSA	(DEVQT)		;[27M]DEVICE?
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]NO
	QSA	(BUFFQT)	;[27M]BUFFER COUNT?
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]NO
	QSA	(BLSZQT)	;[27M]BLOCKSIZES?
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]NO
	QSA	(FILEQT)	;[27M]FILE NAME?
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]NO
	QSA	(PROTQT)	;[27M]PROTECTION?
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]NO
	QSA	(DIREQT)	;[27M]DIRECTORY?
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]NO
	QSA	(LIMQT)		;[27M]LIMIT?
	JMPT	(OCBCK)		;[27M]YS
	TLY	(ARGNUM)	;[27M]NO
	QSA	(MODEQT)	;[27M]MODE?
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]NO
	QSA	(FLSZQT)	;[27M]FILESIZE?
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]NO
	QSA	(RCSZQT)	;[27M]RECORD SIZE?
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]NO
	QSA	(DISPQT)	;[27M]DISPOSE?
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]NO
	QSA	(VERQT)		;[27M]VERSION?
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]NO
	QSA	(REELQT)	;[27M]REELS?
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]NO
	QSA	(MOUQT)		;[27M]MOUNT?
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]NO
	QSA	(ERR2QT)	;[27M]ERROR=
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]NO
	QSA	(ASVAQT)	;[27M]ASSOCIATE VARIABLE?
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]
	QSA	(PARQT)		;[27M]PARITY?
	JMPT	(OCBCK)		;[27M]YES
	TLY	(ARGNUM)	;[27M]NO
	QSA	(DENSQT)	;[27M]DENSITY?
	JMPT	(OCBCK)		;[27M]YES
	CCF	(M26QT)		;[353] CHANGED TO FAIL ON CURRENT CHAR
	JMP	(OCBCK)	;[27M]BACK
AREXLA:					;ARRAY REF XLATE
	ISE	(GDMFIL)	;GLOBAL DMY FILE
	IERT	(DMYEM)	;DMY EM
	XW0.3	(FET)		;MULT PLEX PNTR RUNG
	RSV	(NESROL)	;NEST ROLL
	RSV	(APNROL)	;ARG PNTR ROLL
	CFP	(APNROL)	;ARG PNTR ROLL
	FET	(OPCPNT)	;OP PNTR
	FET	(ZERO)	;ZERO
	FET	(ZERO)	;ZERO
AREXL1:
	MOA	(APNROL)	;ARG PNTR ROLL
	CCFF	(M1QT)	;TOO MANY SCRIPTS QT
	JSB	(EXPSCA)	;EXP SCAN
	SMK	(ITYEM)	;INTEGER TYPE EM
	JMPT	(AREXL8)
	IOR	(ABCCMA)	;ISOLATE CARD-COLUMN
	SEK	(ABCCMA)	;CARD-COLUMN POINTER PRESENT?
	CCFT	(M13QT)	;YES, FAIL
	ERM	(M13QT)	;NO, FAIL
	JMP	(SUBFAI)	;SUBEXP FAIL
AREXL8:
	SMK	(ICOEM)	;INTEGER CONST EM
	SONT	(CMUEM)	;CONST MULTIPLIER EM
	JMPF	(AREXL2)	;$2
	JSB	(GETCON)	;GET CONSTANT
	W1	(MMY)		;W1
	W2	(AMY)		;W2
	JMP	(AREXL3)	;$3
AREXL2:
	W1	(SWT)		;W1
	SMK	(CMUEM)	;CONST. MULTIPLIER EM
	SONT	(NESEM)	;NEST EM
	XW1.0T	(FET)		;ZERO RUNG
	SPTT	(ADDTRA)	;ADDITIVE TRAIT
	JMPF	(AREXL9)	;$9
	SON	(MINEM)	;MINUS EM
	XW1.2	(FET)		;B PART RUNG
	EORT	(MINMAS)	;MINUS MASK
	SMK	(ICOEM)	;INTEGER CONST EM
	POWF	(D1)		;ONE
	JMPF	(AREXL9)	;$9
	JSB	(GETCON)	;GET CONSTANT
	W1	(MPY)		;W1
	W4	(AMY)		;W4
	SON	(MINEM)	;MINUS EM
	XW1.1	(FET)		;A PART RUNG
	EORT	(MINMAS)	;MINUS MASK
	W2	(STO)		;W2
AREXL9:
	SEK	(ONE)		;ONE
	POWT	(D1)		;ONE
	JMPT	(AREXL7)	;$7
	SMK	(CMUEM)	;CONST MULTIPLIER EM
	JSBT	(RWOCON)	;REG WORK CONST
	PNG	(NESROL)	;NEST ROLL
	W2	(SWT)		;W2
	FET	(INPPNT)	;INTEGER MPY PNTR
	JSB	(NESMOV)	;NEST MOVE
AREXL7:
	W1	(SNZ)		;W1
	JSBT	(ATNAMO)	;ADD TO NEST AND MOVE
	W1F	(STO)		;W1
AREXL3:
	CSA	(COMMA)	;COMMA
	JMPT	(AREXL1)	;$1
	CSF	(RPAREN)	;R PAREN
	SRD	(APNROL)	;ARG PNTR ROLL
	LCFT	(M2QT)	;TOO FEW SCRIPTS QT
	W3	(FET)		;W3
	SME	(DITEM)	;DOUBLE ITEM EM
	W0T	(SNZ)		;W0
	PNGT	(NESROL)	;NEST ROLL
	W1T	(SWT)		;W1
	FETT	(CTWPNT)	;CONST TWO PNTR
	FETT	(INPPNT)	;INTEGER MPY PNTR
	JSBT	(NESMOV)	;NEST MOVE
	W3	(FET)		;W3
	SMK	(DMYEM)	;DMY EM
	POWF	(D1)		;ONE
	JMPF	(AREXL4)	;$4
	IER	(ITYEM)	;INTEGER TYPE EM
	W1	(SNZ)		;W1
	W1F	(STO)		;W1
	JSBT	(ATNAMO)	;ADD TO NEST AND MOVE
	W3	(XNI)		;W3
	SNZ	(ASIRUN)	;ARRAY SIZE RUNG
	JMPT	(AREXL4)	;$8
	W3	(XNI)		;W3
	FET	(OFFRUN)	;OFFSET RUNG
	IER	(MINEM)	;MINUS EM
	JSB	(ATNAMO)	;ADD TO NEST AND MOVE
	JSB	(SUBCOL)	;SUBEXP COLLAPSE
	STO	(SEXCLU)	;SCRIPT EXP CLUE
	JMP	(AREXL6)	;$6
AREXL4:
	SEK	(ZERO)	;ZERO
	RELT	(NESROL)	;NEST ROLL
	JMPT	(AREXL5)	;$5
	SMK	(NESEM)	;NEST EM
	JSBF	(AIVCHE)	;ACTIVE INDUC VAR CHECK
	FETF	(ZERO)	;ZERO
	JSBF	(ATNAMO)	;ADD TO NEST AND MOVE
	JSB	(SUBCOL)	;SUBEXP COLLAPSE
AREXL5:
	STO	(SEXCLU)	;SCRIPT EXP CLUE
	W2	(XNI)		;W2
	SUB	(OFFRUN)	;OFFSET RUNG
AREXL6:
	W2	(FET)		;W2
	SME	(DITEM)	;DOUBLE ITEM EM
	W0T	(ADD)		;W0
	ZER	(AROCLU)	;ARRAY REF OFFSET CLUE
	SMY	(AROCLU)	;ARRAY REF OFFSET CLUE
	STO	(OPCPNT)	;OP PNTR
	W0	(FET)		;W0
	AND	(ABCCMA)	;ALL BUT CHAR CNT MASK
	STO	(ARNCLU)	;ARRAY REF NAME CLUE
	REG	(AREFIL)	;ARRAY REF FILE
	AND	(LHAMAS)	;LEFT HALF MASK
	IOR	(AREPNT)	;ARRAY REF PNTR
	REL	(APNROL)	;ARG PNTR ROLL
FEREXI:					;FIRST ELEM RESET EXIT
	ZER	(FELFLA)	;FIRST ELEM FLAG
	XIT	(EXIML)	;EXIT

CLOIDE:					;COLLAPSE LOGICAL IDEMPOT
	SON	(CONEM)	;SECOND ITEM A CONSTANT?
	W1F	(SWT)		;NO, SWITCH
	SONF	(CONEM)	;TEST THE OTHER
	XITF	(EFAML)	;NEITHER A CONSTANT, EXIT FALSE
	SON	(NOTEM)	;SAVE .NOT. BIT
	XW1.0	(FET)		;FETCH ACTUAL VALUE
	W0T	(NOT)		;COMPLEMENT IF BIT SET
	SEK	(ZERO)	;IF RESULT IS NOT ZERO
	SEKF	(MINONE)	;OR MINUS ONE,
	XITF	(P1EFML)	;NOT A SPECIAL CASE, EXIT FALSE
	W3	(FET)		;FETCH OP POINTER
	SPT	(TIDTRA)	;TEST TRUE ID TRAIT (SET FOR .AND. & .EQV.)
	W0T	(NOT)		;COMPLEMENT IF SET
	SEQ	(ZERO)	;TEST RESULTANT FOR ZERO
	W2T	(STO)		;YES,.AND.(T),.OR.(F),.XOR.(F),OR .EQV.(T)
	XITT	(P1ETML)	;THE OTHER VALUE IS THE RESULT
	W2	(FET)		;NO, GET OP POINTER
	SPT	(UCOTRA)	;TEST USE COMP. TRAIT (SET FOR .XOR. & .EQV.)
	POWF	(D1)		;NO, .AND. (F) OR .OR. (T),
	W1F	(STO)		;RESULT IS F OR T, RESPECITIVELY
	XITF	(ETRML)	;RETURN TRUE, TWO ITEMS PRUNED
	EOR	(NOTMAS)	;.XOR.(T) OR .EQV.(F)
	W2	(STO)		;RESULTANT IS COMPLEMENT OF OTHER VALUE
	XIT	(P1ETML)	;EXIT TRUE
ACCAGE:					;ASSIGNMENT CONV CHECK AND GEN
	SMK	(LTYEM)	;LOGICAL TYPE EM
	XITT	(EFAML)		;EXIT FALSE
	SON	(DITEM)	;DOUBLE ITEM EM
	SONF	(HTYEM)		;OR HOLLERITH EM ;"26P"
	JMPT	(ACCAG1)	;$1
	SON	(RTYEM)		;"23Y"
	SONF	(LTYEM)		;"23Y"
	SONF	(OCTEM)		;"23Y"
	SMKT	(DITEM)		;DOUBLE ITEM EM ;"23Y"
				;LINE DELETED ;"23Y"
	JMPT	(ACCAG2)	;"22H"
	JSB	(CCAGEN)	;CONV CHECK AND GEN
	SMK	(CTYEM)		;COMPLEX DEST "22H"
ACCAG2:			;"22H"
	IERT	(ITYEM)		;SET TO SINGLE "22H"
	XIT	(EXEQML)	;EXIT EQUAL ML
ACCAG1:
	SMK	(DITEM)	;DOUBLE ITEM EM
	JSBF	(CCAGEN)	;CONV CHECK AND GEN
	XITF	(EFAML)		;EXIT FALSE
	STK	(EOPPNT)	;EXP OP PNTR
	SON	(HTYEM)		;HOLLERITH TYPE?; "26P"
	XW1.0T	(FET)		;YES,GET COUNT RUNG ;"26P"
	SGTT	(ONE)		;MORE THAN ONE WORD? ;"26P"
	XITT	(EFAML)		;YES, EXIT FALSE AS BELOW ;"26P"
	SON	(ETYEM)	;EXP TYPE EM
	XITT	(EFAML)		;YES EXIT FALSE "22H"
	IER	(ITYEM)		;NO SET TO SINGLE "22H"
	XML	(ETRML)		;EXIT TRUE "22H"
CCAGEN:					;CONV CHECK AND GEN
	SMK	(RTYEM)	;REAL TYPE EM
	SMKF	(DITEM)	;DOUBLE ITEM EM
	JMPT	(CCAGE1)	;$1
	SON	(RTYEM)	;REAL TYPE EM
	SONF	(DITEM)	;DOUBLE ITEM EM
	XITF	(EXIML)	;EXIT
	W1	(FET)		;W1
	JSB	(CTFGEN)	;CONV TO FX GEN
	JMP	(CCAGE2)	;$2
CCAGE1:
	SON	(ITYEM)	;INTEGER TYPE EM
	JMPF	(CCAGE3)	;GEN CALL TO SNGL
	SMK	(CTYEM)		;"25-1"
	W0T	(FET)		;"25-1"
	IERT	(RTYEM)		;IF COMPLEX, FLOATING SHOULD NOT ;"25-1"
	STOT	(EOPPNT)	;  GEN 2ND WORD CLEAR ;"25-1"
	STKF	(EOPPNT)	;SAVE DESTINATION TYPE ;"25-1"
	W1	(FET)		;W1
				;LINE REPLACED HERE "20A"
	JSB	(CPNGE4)	;CHECK FOR ARRAY AND FLOAT "20A"
CCAGE2:
	W2	(STO)		;W2
	XIT	(EXIML)	;EXIT

CCAGE3:
	SON	(DPTEM)	;IS RESULT D.P.
	SMKT	(RTYEM)	;AND DESTINATION REAL ?
	XITF	(EXIML)	;NO, RETURN
			;LINE DELETED HERE "20A"
	W1	(FET)		;YES, GET RESULT POINTER
				;10 LINES DELETED ;"23BB"
	FET	(PDPSW)		;"25-1"
	SLT	(ZERO)		;TEST MACHINE TYPE ;"25-1"
	JMPF	(CCAGE5)	;BRANCH FOR KI10 OR PDP-6 ;"25-1"
	JSB	(GIRGEN)	;"23BB"
	W0	(FET)		;"23BB"
	W0	(TLY)		;"23BB"
	BIN	(.FAR0)		;"23BB"
CCAGE4:
	IER	(RTYEM)	;MAKE RESULT TYPE REAL - "20A"
	STK	(EOPPNT)	;SET EXP TYPE TO REAL "22D"
				;LINE DELETED ;"23BB"
	JMP	(CCAGE2)	;CHANGE DESTINATION POINTER
CCAGE5:
	JSB	(CTFCK)		;GET REG 0 POINTER ;"25-1"
	IERT	(MINEM)		;PASS SIGN TO REG 0 IF RESULT .L. 0 ;"25-1"
	W1	(SWT)		;SETUP FOR BAK ;"25-1"
	SMK	(RZEEM)		;REG ZERO ? ;"25-1"
	JSBT	(DSITGE)	;YES, STORE IN TEMP ;"25-1"
	SMK	(AREEM)		;ARRAY EM ; "26N"
	JSBT	(GIRGEN)	;ARRAY, GRNTEE SCRIPT IN REG GEN ; "26N"
	BLK	(.SNGL)		;JSA 16, SNGL ;"25-1"
	BAK	(.ARG0)		;ARG 00, RESULT ;"25-1"
	JSB	(CTFLG1)	;RESTORE REG 0 EMS ;"25-1"
	JMP	(CCAGE4)	;CHANGE DESTINATION POINTER ;"25-1"
EIRGAS:					;EXP IN REG GEN AND SAVE
	W0	(FET)		;W0
	XW0.4	(TLY)		;USE CNT RUNG
	JSB	(GENRUN)	;GEN RUN
	JSB	(GPRGEN)	;GRNTEE POS REG GEN
	XML	(P1EML)	;PRUNE ONE EXIT
EIERGE:					;EXP IN EVEN REG GEN
	JSB	(GENRUN)	;GEN RUN
	SMK	(REGEM)	;REG EM
	SMKT	(EREEM)	;EVEN REG EM
	JMPT	(GPRGEN)	;GRNTEE POS REG GEN
	FET	(DPTSTA)	;DBL PREC TYPE STAMP
	SWT	(EOPPNT)	;EXP OP PNTR
	JSB	(RBTASS)	;REG BY TYPE ASSIGN
	W1	(SWT)		;W1
	STO	(EOPPNT)	;EXP OP PNTR
	IER	(ETYEM)	;EXP TYPE EM
	JMP	(RLOGEN)	;REG LOAD GEN
EIR0GE:					;EXP IN REG 0 GEN
	SMK	(RZEEM)	;REG ZERO EM
	JMPT	(GPRGEN)	;GRNTEE POS REG GEN
	JSB	(GR0AGE)	;GRNTEE REG 0 AVAILABLE GEN
	XW0.0	(ZER)		;ZERO RUNG
	POW	(D1)		;ONE
	SMK	(SUBEM)		;SUBEXPRESSION? "22M"
	JMPF	(EIR0G1)	;BYPASS EIRGEN "22M"
				;LINE DELETED "22M"
	JSB	(EIRGEN)	;EXP IN REG GEN
				;2 LINES DELETED "22M"
	SMK	(RZEEM)		;DID IT MAKE IT INTO AC0?
EIR0G1:			;"22M"
	W0F	(FET)		;NO, PUT IT THERE
	ANDF	(LHAMAS)	;TRANSFER THE INFO
	IORF	(RZEPNT)	;POINT TO REG 0
	W1F	(SWT)		;EXCHANGE
	JSB	(AIVREP)	;[27G]CHECK FOR DO LOOP INDEX
	BTYF	(.ME0)	;MOVE INTO AC0
GPRGEN:					;GRNTEE POS REG GEN
	SMK	(MINEM)	;MINUS EM
	XITF	(EXIML)	;EXIT
	JMP	(CSIGEN)	;CHANGE SIGN GEN
SUBGEN:					;SUBEXP GEN
	XW0.4	(DIM)		;USE CNT RUNG
	XW0.3	(FET)		;STATUS PNTR RUNG
	SMK	(IIVEM)		;INDUCTION VARIABLE ACTIVE ?
	SNZF	(VIOEXP)	;[27J]OR VIOLATION OF EXPRESSIONS?
	XW0.0T	(ZER)		;YES,CLEAR REGROL
	CLAT	(ZERO)	;GENERATE FRESH EXPRESSION
	SEK	(ZERO)	;ZERO
	JMPF	(SNCKRG)	;[343] GO SEE IF IT'S NOT REALLY STILL
				;[343] IN THE REGISTER WE THINK IT'S IN
SUBGE1:	SON	(FREEM)	;FUNC REF EM	;[343] LABEL ADDED
	POWT	(D1)		;ONE
	JSBT	(FRPGEN)	;FUNC REF PNTR GEN
	JMPT	(SUGEFI)	;SUBEXP GEN FIN
	XW1.1	(CLA)		;A PART RUNG
	XW1.2	(FET)		;B PART RUNG
	XW2.0	(FET)		;OP PNTR RUNG
	STK	(EOPPNT)	;EXP OP PNTR
	JSB	(OGERUN)	;OP GEN RUN
SUGEFI:					;SUBEXP GEN FIN
	SMK	(REGEM)	;REG EM
	JMPF	(SNOEXI)	;SIGN NOTE EXIT
	STK	(RSIATO)	;RESULTANT SIGN ATOM
	SNZ	(IOLFLA)	;INSIDE AN I/O LIST ?
	SNZT	(REGSAV)	;AND THE DO REG IS IN USE ?
	IERT	(IIVEM)	;YES,PASS THIS INFO THRU THE EXP
	XW1.3	(STK)		;NO,UPDATE THE STATUS PNTR RUNG
	W1	(FET)		;W1
;
; EDIT 26O HAS BEEN REMOVED AND REPLACED WITH THE ORIGINAL CODE, THEN
;RE-PATCHED WITH DON BLACK'S CODE:  SPR 10-12,541.
;
	SMK	(FREEM)		;SET TRUE IF FUNC. REF. ; "26O"
	XW0.0F	(FET)		;NO, GET CURRENT EXP TYPE "22D" ; "26O"
	W1T	(FET)		;YES, GET TYPE AFTER FUNCTION CALL
	STK	(LASEXP)	;[27K]  LAST EXP TYPE
	STO	(EOPPNT)		;SET EXP TYPE "22D" 
	IER	(ETYEM)		;EXP TYPE EM
	XW1.0	(STO)		;ZERO RUNG
	IPK	(RSITRA)	;RESULTANT SIGN TRAIT
SNOEXI:					;SIGN NOTE EXIT
	W1	(SWT)		;W1
	AND	(SANMAS)	;SIGN AND NOT MASK
	W1	(EOM)		;W1
	XIT	(EXIML)	;EXIT

SNCKRG:				;[343] SUBEXPRESSION CHECK IF STILL IN REGISTER
	STK	(EOPPNT)	;[343] SAVE EXPRESSION OP POINTER
	SMK	(REGEM)		;[343] SEE IF WE THINK IT'S IN A REGISTER
	JMPF	(SNOEXI)	;[343] NO, SKIP TO FINISH (THIS MAY BE A HACK)
	XW0.0	(FET)		;[343] GET WHAT'S IN THE REGISTER
	STO	(PINATO)	;[343] SAVE IT FOR COMPARE
	W1	(FET)		;[343] GET THE SUBEXPRESSION POINTER
	SME	(PINEM)		;[343] SEE IF THAT'S WHAT IN REG
	JMPT	(SNOEXI)	;[343] YES, GO FINISH
	XW1.1	(FET)		;[343] GET THE NAME WE THINK IS IN THE REG
	SME	(PINEM)		;[343] SEE IF IT'S REALLY THERE
	JMPT	(SNOEXI)	;[343] YES, GO FINISH
	CLA	(ZERO)		;[343] NO, MAKE SURE TO PUT IT BACK
	JMP	(SUBGE1)	;[343] AND GO PUT IT BACK
EQVGEN:					;EQV GEN
	FET	(NOTMAS)	;NOT MASK
	W3	(EOM)		;W3
XORGEN:					;XOR GEN
	JSB	(RFBGEN)
	JSB	(MINTST)	;"23U"CHECK FOR MINUS
	EAW	(.XOR0)	;SIXTEEN
	JMP	(LOPGEN)	;LOGICAL OP GEN
ANDGEN:					;AND GEN
	JSB	(RFBGEN)
	JSB	(MINTST)	;"23U" CHECK FOR MINUS
	EAW	(.AN0)	;EIGHT
	JMP	(LOPGEN)	;LOGICAL OP GEN
ORGEN:					;OR GEN
	JSB	(RFBGEN)
	JSB	(MINTST)	;"23U" CHECK FOR MINUS
	EAW	(.OR0)	;ZERO
LOPGEN:					;LOGICAL OP GEN
	W3	(FET)		;W3
	SMK	(NOTEM)	;NOT EM
	AND	(NOTMAS)	;NOT MASK
	W4	(EOM)		;W4
	ADDAT	(D4)		;FOUR
	W2	(FET)		;W2
	SMK	(NOTEM)	;NOT EM
	AND	(NOTMAS)	;NOT MASK
	W3	(EOM)		;W3
	ADDAT	(D2)		;TWO
	SON	(NOTEM)	;NOT EM
	ADDAT	(D1)		;ONE
	XML	(BIKIML)
	JMP	(RREEXI)	;REG RESET EXIT
MINTST:				;"23U"
	W1	(SWT)		;"23U"
	JSB	(MINTS1)	;"23U" NOW CHECK
	W1	(SWT)		;"23U"
MINTS1:				;"23U"
	SMK	(MINEM)		;"23U" MINUS?
	XITF	(EXIML)		;"23U"
	SMK	(REGEM)		;"23U" REGISTER POINTER?
	JSBT	(CSIGEN)	;"23U" YES CHANGE SIGN
	JSBF	(GIRGEN)	;"23U" NO CHANGE SIGN ANYWAY
	XIT	(EXIML)		;"23U"
GTLTGE:					;GT LT GEN
	EAW	(D0)		;ZERO
	JMP	(RGECHE)	;REL GEN CHECK
GELEGE:					;GE LE GEN
	EAW	(D6)		;SIX
RGECHE:					;REL GEN CHECK
	W2	(SWT)		;W2
	SMK	(CTYEM)	;COMPLEX TYPE EM
	SONF	(CTYEM)	;COMPLEX TYPE EM
	JMPF	(RELGEN)	;REL GEN
	FET	(EOPPNT)	;GET OP PNT	"20C"
	ERM	(M14QT)		;ERROR
	W3	(FET)		;W3
	JMP	(SUBFAI)	;SUBEXP FAIL
EQNEGE:					;EQ NE GEN
	EAW	(D3)		;THREE
	W2	(SWT)		;W2
RELGEN:					;REL GEN
	FET	(EOPPNT)	;EXP OP PNTR
	SPT	(NOPTRA)	;NOT OP TRAIT
	W2T	(TLY)
	EAW	(D0)		;ZERO
	W2	(SWT)		;W2
	SON	(CZPEM)	;CONST ZERO PNTR EM
	SONF	(FZPEM)	;FLOATING ZERO PNTR EM
	W2T	(NOT)		;W2
	JMPT	(RELGE3)	;$3
	SMK	(CZPEM)	;CONST ZERO PNTR EM
	SMKF	(FZPEM)	;FLOATING ZERO PNTR EM
	W1T	(SWT)		;W1
RELGE3:
	JSBT	(EIRGEN)	;EXP IN REG GEN
	JSBF	(RFBGFI)	;READY FOR BINARY GEN FIN
	W1F	(SWT)		;W1
	SON	(PLUEM)	;PLUS EM
	W2F	(NOT)		;W2
	SON	(NOTEM)	;NOT EM
	EAWT	(D7)		;SEVEN
	W4T	(EOM)		;W4
	STK	(RSIATO)	;RESULTANT SIGN ATOM
	SON	(RSIEM)	;RESULTANT SIGN EM
	JSBF	(CSIGEN)	;CHANGE SIGN GEN
	W4	(FET)		;W4
	SMK	(NOTEM)	;NOT EM
	EAWT	(D7)		;SEVEN
	W5T	(EOM)		;W5
	AND	(NOTMAS)	;NOT MASK
	W5	(EOM)		;W5
	W2	(SNZ)		;W2
	EAWT	(D1)		;ONE
	W4T	(EOM)		;W4
	W1	(SWT)		;W1
	SON	(CTYEM)	;COMPLEX TYPE EM
	EAW	(D0)		;ZERO
	XITT	(EXIML)	;EXIT
	SON	(CZPEM)	;CONST ZERO PNTR EM
	SONF	(FZPEM)	;FLOATING ZERO PNTR EM
	CLAT	(SEVEN)	;SEVEN
	XIT	(EXIML)	;EXIT
RELGE8:
	SEQ	(ZERO)	;ZERO
RELGE5:
	W3F	(FET)		;W3
	JMPF	(RELGE1)	;$1
RELGE9:
	FET	(EOPPNT)	;EXP OP PNTR
	SME	(DITEM)	;DOUBLE ITEM EM
	JMPF	(RELGE5)	;$5
	SMK	(AREEM)		;ARRAY ? ;"21K"
	XW0.2T	(FET)		;INDICATE EXTRA USE OF SUBSCRIPT ;"21K"
	JSBT	(SUSTLY)	;BY INCREMENTING USE COUNT ;"21K"
	BIK	(.CMN0)	;CAMN INST
	FET	(SEVEN)	;SEVEN
	W4	(EOM)		;W4
	W3	(FET)		;W3
	SEK	(FOUR)	;FOUR
	SEKF	(FIVE)	;FIVE
	SUBT	(TWO)		;TWO
	JSB	(BRESKI)	;BUILD REL EQ SKIPS
	XITT	(EXIML)	;EXIT
	W3	(FET)		;W3
	SEK	(TWO)		;TWO
	SEKF	(THREE)	;THREE
	POCT	(ABSINS)	;ABS INST
	POCT	(.SKA0)	;SKIPA INST
	XMLT	(P1EML)	;PRUNE ONE EXIT
	EOR	(ONE)		;ONE
	IOR	(SIX)		;SIX
RELGE1:
	ADDA	(.CMG0)	;CAMG INST ADR
	W3	(STK)		;W3
	XML	(BIKIML)
	XIT	(EXIML)	;EXIT
RGFNLI:					;REL GEN FOR NOT LOG IF
	FET	(EOPPNT)	;EXP OP PNTR
	JSB	(RELDIS)	;RELATIONAL OP DISPATCH
	JSB	(RELGE8)	;REL GEN $8
	W1	(SWT)		;W1
	W0	(FET)		;W0
	BIN	(.TDZA0)	;TDZA INST
	BRI	(.SEO0)	;SETO INST
	IER	(PLOEM)	;POSITIVE LOGICAL EM
	STK	(EOPPNT)	;EXP OP PNTR
	W3	(STO)		;W3
	W1	(STO)		;W1
	NOZ	(DCTYPE)	;[27P] DON'T CHANGE TYPE AT RREEXI
	JMP	(RREEXI)	;REG RESET EXIT
BRESKI:					;BUILD REL EQ SKIPS
	ADDA	(.CMG0)	;CAMG INST ADR
	SON	(DITEM)	;DOUBLE ITEM
	JMPT	(BSHREF)	;BUILD SECOND HALF REF
	W2	(FET)		;W2
	W0	(TLY)		;W0
	FET	(CZEPNT)	;CONST ZERO PNTR
	W2	(FET)		;W2
	XML	(BINIML)
	XML	(P2EML)	;PRUNE TWO EXIT
ICLGEN:					;IF CLOSE GEN
	SNZ	(ISAFLA)	;IF STA ACTIVE FLAG
	JSBT	(ICGFIN)	;IF CLOSE GEN FIN
	FET	(SLBPNT)	;STA LBL PNTR
	SEK	(ZERO)	;ZERO
	JSBF	(LGAKEE)	;LBL GEN AND KEEP
	XML	(P1ETML)	;PRUNE ONE EXIT TRUE

DISTES:					;DOUBLE IF STA TEST
	SNZ	(ISAFLA)	;IF STA ACTIVE FLAG
	XITF	(EXIML)
	ZER	(ISAFLA)	;IF STA ACTIVE FLAG
ICGFIN:					;IF CLOSE GEN FIN
	W2	(SEK)		;W2
	JMPF	(GLECHE)	;GE LE CHECK
	POW	(D1)		;ONE
	W1	(SEK)		;W1
	POWT	(D1)		;ONE
	JMPT	(AJUGEN)	;ABS JUMP GEN
	FET	(THREE)	;THREE
FTHGEN:					;FALL THROUGH GEN
	STO	(TEMP)	;TEMP
	SMK	(SLPEM)	;STA LBL PNTR EM
	W2F	(FET)		;W2
	W1F	(SWT)		;W1
	CLAT	(SEVEN)	;SEVEN
	EOMT	(TEMP)	;TEMP
	EAW	(.JUG0)	;JUMPG INST
	ADD	(TEMP)	;TEMP
	XML	(BINIML)
	POW	(D1)		;ONE
	XITT	(EXIML)	;EXIT
AJUGEN:					;ABS JUMP GEN
	SMK	(SLPEM)	;STA LBL PNTR EM
	BAKF	(.JRST0)	;JRST INST
	XML	(P2EML)	;PRUNE TWO EXIT
GLECHE:					;GE LE CHECK
	W1	(SEK)		;W1
	CLAT	(SIX)		;SIX
	JMPT	(FTHGEN)	;FALL THROUGH GEN
	W2	(SWT)		;W2
	W1	(SEK)		;W1
	CLAT	(SEVEN)	;SEVEN
	JMPT	(FTHGEN)	;FALL THROUGH GEN
	W3	(FET)		;W3
	ZER	(HITCNT)	;HITS CNTR
	W1	(SWT)		;W1
	SMK	(SLPEM)	;STA LBL PNTR EM
	BIKF	(.JUL0)	;JUMPL INST
	TLYT	(HITCNT)	;HITS CNTR
	POW	(D1)		;ONE
	W1	(SWT)		;W1
	SMK	(SLPEM)	;STA LBL PNTR EM
	BIKF	(.JUE0)	;JUMPE INST
	TLYT	(HITCNT)	;HITS CNTR
	POW	(D2)		;TWO
	SNZ	(HITCNT)	;HITS CNTR
	JMPF	(AJUGEN)	;ABS JUMP GEN
	BIN	(.JUG0)	;JUMPG INST
	XML	(P1EML)	;PRUNE ONE EXIT
CSIGEN:					;CHANGE SIGN GEN
	SPK	(SUBEM)	;SUBEXP EM
	XW0.0T	(FET)		;ZERO RUNG
	FETT	(SIGMAS)
	XW1.3T	(EOM)
	EORT	(SIGMAS)	;SIGN MASK
	XW1.0T	(STO)
	EOR	(SIGMAS)	;SIGN MASK
	W0	(FET)		;W0
	SMK	(DPTEM)	;DOUBLE PREC TYPE EM
	BTYF	(.MN0)	;MOVN INST
	XITF	(EXIML)	;EXIT
CSIGE1:			;"21V" CALLED FROM AOAXLA
	FET	(PDPSW)	;TEST MACHINE TYPE ;"25-1"
	SLT	(ZERO)	;"25-1"
	W0T	(TLY)
	BINT	(.DFN0)	;DFN INST
	XITT	(EXIML)	;EXIT
	FET	(PDPSW)		;"25-1"
	SEQ	(ONE)		;IF KI10, SET FLAG TRUE ;"25-1"
	BINT	(.DMVN)		;DMOVN ;"25-1"
	XITT	(EXIML)		;"25-1"
	W1	(TLY)		;W1
	BRI	(.SEA0)	;SETCA INST
	W1	(SWT)		;W1
	W0	(FET)		;W0
	BIN	(.MN0)	;MOVN INST
	FET	(ABSCPN)	;ALL BUT SIGN CONST PNTR
	BIN	(.TDNN0)	;TDNN INST
	CLA	(CONPNT)	;CONST ONE PNTR
	BIN	(.ADD0)
	XIT	(EXIML)
DCLGEN:					;DO CLOSE GEN
DCLGE1:
	MOA	(DLOROL)	;LABEL OF DO CLOSE
	XITF	(EXIML)	;EXIT
	SMK	(SLPEM)	;STA LBL EM
	MONF	(DLOROL)	;DO LOOPS OPEN ROLL
	XITF	(EXIML)	;EXIT
	POW	(D1)		;PRUNE LABEL OF DO CLOSE
	JSB	(LCLGEN)	;LOOP CLOSE GEN
	JMP	(DCLGE1)	;$1
LCLGEN:					;LOOP CLOSE GEN
	SNZ	(JSTFLA)	;JUMP STA FLAG
	EAWT	(C6PNTR)	;COL 6 PNTR
	W0T	(SWH)
	ERMT	(M10QT)	;ILLEGAL DO CLOSE QT
	ZER	(IOLFLA)	;IOL FLAG
LCGFIN:					;LOOP CLOSE GEN FIN
	ZER	(EOPPNT)	;EXP OP PNTR
	MOA	(DLOROL)	;JOUFLA
	MOA	(DLOROL)	;INDEX VAR PNTR
	JSB	(AIVCHE)	;INDEX STILL IN REG 15 ?
	BAKF	(.ME1)	;NO, BIN MOVE DO REG INST
	NOZF	(IOLFLA)	;NO, SET IOL FLAG
	MOA	(DLOROL)	;LABEL TO RETURN TO
	SNZ	(JOUFLA)	;JUMP OUT FLAG SET ?
	SNZF	(IOLFLA)	;NO, IOL FLAG SET ?
IFE FTMANT,<W0T	(DIM)		;YES, POINT TO CODE TO UPDATE INDEX VAR>
IFN FTMANT,<W0	(DIM)		;YES, POINT TO CODE TO UPDATE INDEX VAR>
	MOA	(DLOROL)	;FINAL VALUE EXP PNTR
	MOA	(DLOROL)	;INCREMENT EXP PNTR
	RSV	(SUBROL)	;SUBEXP ROLL
	EAW	(SUBROL)	;SUBEXP ROLL
	CAR	(DLOROL)	;INCREMENT & FINAL SUBEXP SAVED
	SMK	(CONEM)	;CONST PNTR EM
	JMPT	(CILCGE)	;CONST INCR LOOP CLOSE GEN
	W0	(FET)		;MAKE TEMPORARY COPY OF INCREMENT
	SMK	(AREEM)		;AN ARRAY ? ;"21L"
	XW0.2T	(CLA)		;YES, THEN SAVE THE SUBSCRIPT ;"21L"
	JSB	(SUSTLY)	;SAVE INCREMENT FOR SIGN TEST
	JSB	(GENRUN)	;GEN RUN
	FET	(DREPNT)	;DO REG PNTR
	W1	(FET)		;W1
	JSB	(AGEFIN)	;ADD GEN FIN
	W2	(FET)		;W2
	JSB	(EIRGEN)	;EXP IN REG GEN
	SMK	(MINEM)	;MINUS EM
	BIKT	(.ADDM0)	;ADDM INST
	BIKF	(.SUBM0)	;SUBM INST
	W2	(SWT)		;W2
	SMK	(MINEM)	;MINUS EM
	BAKT	(.SKLE0)	;SKIPLE INST
	BAKF	(.SKGE0)	;SKIPGE INST
	JSB	(RREEXI)	;REG RESET EXIT
	W1	(CLA)		;W1
	BIN	(.MN0)	;MOVN INST
	W1	(STO)		;W1
	W1	(SWT)		;W1
	BIN	(.JULE0)	;JUMPLE INST
	JMP	(LGEEXI)	;LOOP GEN EXIT
CILCGE:					;CONST INCR LOOP CLOSE GEN
	SMK	(COPEM)	;CONST ONE PNTR EM
	JMPT	(CILCG1)	;$1
	SMK	(MINEM)	;MINUS EM
	BAIT	(.SUB1)	;SUB DO REG INST
	BAIF	(.ADD1)	;ADD DO REG INST
	JSB	(LIMGEN)	;LIMIT GEN
	BINT	(.CML0)	;CAML INST
	BINF	(.CMG0)	;CAMG INST
	W1	(SWT)		;W1
	BAI	(.JRST0)	;JRST INST
	JMP	(LGEEXI)	;LOOP GEN EXIT
CILCG1:
	SME	(MINEM)	;MINUS EM
	JSB	(LIMGEN)	;LIMIT GEN
	BINT	(.CMLE0)	;CAMLE INST
	BINF	(.CMGE0)	;CAMGE INST
	W1	(SWT)		;W1
	BINT	(.SOJA0)	;SOJA INST
	BINF	(.AOJA0)	;AOJA INST
LGEEXI:					;LOOP GEN EXIT
	POW	(D2)		;TWO
	SNZ	(JOUFLA)	;JUMP OUT FLAG
	STO	(JOUFLA)	;JUMP OUT FLAG
	NOZT	(JOUFLA)	;JUMP OUT FLAG
	ZER	(IIVPNT)	;INSIDE INDUC VAR PNTR
	REL	(SUBROL)	;SUBEXP ROLL
	XIT	(EXIML)	;EXIT
LIMGEN:					;LIMIT GEN
	JSB	(GENRUN)	;GEN RUN
	JSB	(GPOGEN)	;GRNTEE POSITIVE GEN
	FET	(DREPNT)	;DO REG PNTR
	W1	(SWT)		;W1
	XIT	(EXIML)	;EXIT
GPOGEN:					;GRNTEE POSITIVE GEN
	SMK	(MINEM)	;MINUS EM
	XITF	(EXIML)		;OPTIMIZE CODE
	JSB	(GIRGEN)	;GRNTEE IN REG GEN
	SMK	(MINEM)	;MINUS EM
	W0T	(FET)		;W0
	BINT	(.MN0)	;MOVN INST
	XIT	(EXIML)	;EXIT
LSHGEN:					;LOCAL SPROG HEAD GEN
	FET	(RZEPNT)	;REG ZERO PNTR
	ZER	(APNPNT)	;ARG PNTR PNTR
LSHGE1:
	DFA	(APNROL)	;ARG PNTR ROLL
	XMLF	(P1EML)	;PRUNE ONE EXIT
	SME	(DITEM)	;DOUBLE ITEM EM
	BAK	(.PSH2)
	BAKT	(.RRZ1)	;HRRZ 1 XR16 INST
	POCT	(ABSINS)	;ABS INST
	POCT	(.PSH3)	;PUSH 0 1 XR1 INST
	W0	(TLY)		;W0
	JMP	(LSHGE1)
				;23 LINES DELETED	;"23C"
BSRGEN:				;BLOCK SAVE REGS GEN ;"21V"
	JSB	(PTEMAK)	;GET A PERM TEMP PNTR ;"21V"
	STK	(ABLPNT)	;DEFINE AS START OF BLOCK ;"21V"
	SNZ	(SINFLA)	;FUNCTION ? ;"21V"
	JMPF	(BSRGE1)	;NO, SAVE AC 15/16 ONLY ;"21V"
	FET	(REGCNT)	;GET # OF CONTIGUOUS REGS TO BE SAVED ;"21V"
	SGK	(THREE)		;BLT OVERHEAD REQUIRED ? ;"21V"
	AMY	(TEMCNT)	;INDICATE BLOCK LENGTH ;"21V"
	JMPF	(BSRGE3)	;NO, GEN MOVEM'S ;"21V"
	BAK	(.MEI0)		;GEN MOVEI 0,BLOCK
	FET	(RZEPNT)	;FAKE AN IMMEDIATE ;"21V"
	ADDA	(D2)		;MODE 2 ;"21V"
	BAI	(.RLI0)		;GEN HRLI 0,2 ;"21V"
	ADD	(REGCNT)	;MAKE END OF BLOCK ;"21V"
	BAK	(.BLT0)		;GEN BLT 0,BLOCK END ;"21V"
	W0	(TLY)		;BLOCK END +1
BSRGE1:				;$1, TRY TO SAVE AC 15/16 ;"21V"
	TLY	(TEMCNT)	;UPDATE COUNT "24A"
				;2 LINES DELETED "24-2"
	BAK	(.MEM1)		;GEN MOVEM 15,TEMP. ;"21V"
	W0	(TLY)		;ADDRESS FREE TEMP LOC ;"21V"
BSRGE2:				;$2, TRY TO SAVE AC16 ;"21V"
	TLY	(TEMCNT)	;UPDATE COUNT "24A"
				;3 LINES DELETED "24-2"
	FET	(R16PNT)	;GET REG 16 PNTR ;"21V"
	W1	(SWT)		;PUT IN PROPER ORDER ;"21V"
	BIN	(.MEM0)		;GEN MOVEM 16,TEMP. ;"21V"
	XIT	(P1EML)		;EXIT PRUNING REG PNTR ;"21V"
BSRGE3:				;$3, SAVE WITH MOVEM'S ;"21V"
	SNZ	(REGCNT)	;ANY REGS TO SAVE ? ;"21V"
	JMPF	(BSRGE1)	;NO, TRY AC15/16 ;"21V"
	FET	(RONPNT)	;GET REG 1 PNTR ;"21V"
	FET	(REGCNT)	;GET # OF REGS TO BE SAVED ;"21V"
	W2	(SWT)		;PUT IN PROPER ORDER ;"21V"
BSRGE4:				;$4, ITERATION POINT ;"21V"
	W2	(DIM)		;DECREMENT REG CNT ;"21V"
	W1	(TLY)		;INCREMENT REG CNT ;"21V"
	BIK	(.MEM0)		;GEN MOVEM 2/3/4,BLOCK/+1/+2 ;"21V"
	W0	(TLY)		;INCREMENT TEMP PNTR ;"21V"
	W2	(SNZ)		;MORE REGS TO SAVE ? ;"21V"
	JMPT	(BSRGE4)	;YES, SAVE THEM ;"21V"
	W2	(SWT)		;PUT COUNT ON TOP ;"21V"
	POW	(D2)		;PRUNE COUNT AND REG PNTR ;"21V"
	JMP	(BSRGE1)	;TRY TO SAVE AC15/16 ;"21V"
				;LINE DELETED	;"23C"
SEXGEN:					;SPROG EXIT GEN
	CNT	(APNROL)	;ARG PNTR ROLL
	ADD	(BREPNT)	;BLANK REG PNTR
	BAI	(.JRA1)	;JRA 16 XR16 INST
	REL	(APNROL)	;ARG PNTR ROLL
	REL	(LDMROL)	;LOCAL DMY ROLL
	XIT	(EXIML)	;EXIT
ASUGEN:				;ADD SUB GEN
	SEK	(ZERO)	;ZERO
	POWT	(D1)		;ONE
	JMPT	(EIRGEN)	;EXP IN REG GEN
	JSB	(RFBGEN)	;READY FOR BINARY GEN
			;LINE DELETED HERE "20J"
			;LINE RETURNED "22E"
	JSB	(SATREG)	;CHECK FOR SAVE OF XTRA REG
	JSB	(R0SACK)	;"22N"
	SON	(MINEM)	;MINUS EM
	JMPF	(AGEFIN)	;ADD GEN FIN
	SMK	(MINEM)	;MINUS EM
	BTKT	(.ADD0)	;ADD INST
	BTKF	(.SUB0)	;SUB INST
	JMP	(RREEXI)	;REG RESET EXIT
AGEFIN:					;ADD GEN FIN
	SMK	(MINEM)	;MINUS EM
	BTKT	(.SUB0)	;SUB INST
	BTKF	(.ADD0)	;ADD INST
RREEXI:					;REG RESET EXIT
	SNZ	(DCTYPE)	;[27P] DON'T CHANGE TYPE?
	ZERT	(DCTYPE)	;[27P] ZERO FLAG
	JMPT	(RREEX1)	;[27P] AND DON'T
	SON	(LTYEM)		;WILL EXP. TYPE BECOME LOGICAL? "26U"
	STOT	(EOPPNT)	;YES, USE TYPE OF OTHER PART ;"26U"
	IERT	(ETYEM)		;EM OF OTHER PART TO LOGICAL PART ;"26U"
	FETT	(EOPPNT)	;GET OTHER PART BACK ON WORKROLL ;"26U"
RREEX1:	SMK	(REGEM)		;[27P] REG EM
	XMLF	(P1EML)	;PRUNE ONE EXIT
	JSB	(RSATES)	;REG SAVE TEST
	XW0.0F	(ZER)		;ZERO RUNG
	XML	(P1EML)	;PRUNE ONE EXIT
MPYGEN:					;MPY GEN
	JSB	(RFBGEN)	;READY FOR BINARY GEN
	JSB	(MBPO2G)	;MPY BY POWER OF 2 GEN
	JSB	(SATREG)	;SAVE THIRD REG IF D.P. ;"21S"
	JSB	(R0SACK)	;"22N"
	BTKF	(.IMU0)	;MPY INST
MDGFIN:					;MPY DIV GEN FIN
	W0	(FET)		;W0
	AND	(SIGMAS)	;SIGN MASK
	W2	(EOM)		;W2
	JMP	(RREEXI)	;REG RESET EXIT
R0SACK:			;CHECK FOR SAV OF REGS 0,1
	SMK	(DITEM)		;DOUBLE ITEM? "22N"
	XITF	(EXIML)		;NO EXIT"22N"
	SON	(RZEEM)		;REG 0 EM? "22N"
	XITT	(EXIML)		;"22N"
;	FET	(RZEPNT)	;"22N"
;	IER	(DITEM)		;"22N"
;	JSB	(GABTGE)	;"22N"
;	POW	(D1)		;"22N"
	JSB	(GR0AGE)	;SAVE REG 0 IF NECESSARY "26B"
	XW0.0	(ZER)	;"26B"
	POW	(D1)	;"26B"
	XIT	(EXIML)	;"22N"
DIVGEN:					;DIV GEN
	SMK	(SUBEM)	;SUBEXP EM
	XW0.4T	(TLY)		;USE CNT RUNG
	JSB	(GENRUN)	;GEN RUN
	JSB	(DIVCCK)	;CHECK TYPES "22D"
	W1	(SWT)		;W1
	JSB	(EIRGEN)	;EXP IN REG GEN
	JSB	(DIVCCK)	;CHECK TYPES "22D"
	JSB	(SRITGE)	;SAVE REG IN TEMP GEN
	W1	(SWT)		;W1
	SMK	(REGEM)	;REG EM
	JMPF	(DIVGE1)	;$1
	XW0.0	(FET)		;ZERO RUNG
	SMK	(SUBEM)
	XW0.4T	(DIM)		;USE CNT RUNG
	IERT	(ETYEM)		;"23V" SET TO SUBEXP TYPE
	XW1.0	(STO)		;"23V" RESTORE POINTER TO REG
DIVGE1:
	JSB	(DBPO2G)	;DIVIDE BY POWER OF 2 GEN
	JMPT	(MDGFIN)	;FINISH UP IF DIVIDE GENED
	FET	(EOPPNT)	;EXP OP PNTR
	SME	(ITYEM)	;INTEGER TYPE EM
	JMPF	(DIVGE2)	;SAV TIME
	W1	(FET)		;W1
	ADDA	(D1)
	AND	(RHAMAS)	;PROPER TYPE AND SIGN MUST ALSO
	XW0.0	(FET)		;BE ATTACHED
	AND	(TASMAS)
	W1	(IOM)
;3 LINES DELETED FOR PATCH TO SAVE REGISTER ON IDIV;"26F"
;LINE DELETED	"26F"	JSB	(SRITGE)	;SAVE REG IN TEMP GEN
;LINE DELETED	"26F"	XW0.0T	(NOZ)		;ZERO RUNG
;LINE DELETED	"26F"	POWT	(D1)		;ONE
	XW0.0	(FET)		;FIX TO SAVE AC+1 ON IDIV ; "26F"
	SME	(SUBEM)		;IS ZERO RUNG SUB EXP EARMARK? ; "26F"
	JSBT	(GABTGE)	;YES, SAVE A REGISTER ; "26F"
	XW0.0	(NOZ)		;ZERO RUNG ; "26F"
	POW	(D1)		;PRUNE ONE ; "26F"
DIVGE2:
	JSBF	(SATREG)	;TEST FOR SAV NEXT REG
	JSB	(R0SACK)	;"22N"
	BTK	(.IDI0)	;DIV INST
	XW1.0T	(ZER)
;	PATCH TO FIX ARITH FUNCTION STATEMENT PROBLEM OF RESTORING ; "26D"
;	BAD VALUES TO AC15 AND AC16 WHEN AN INTEGER DIVIDE IS DONE ; "26D"
;	IN THE DEFINING EXPRESSION ; "26D"
	SNZ	(LSPDEF)	;IS THIS DURING A LOCAL SUBPROGRAM DEFINITION ? ; "26D"
	JMPT	(MDGFIN)	;YES, DON'T UP REG CNT BUT GO TO MPY DIV GEN FIN ; "26D"
	FET	(EOPPNT)	;"25-4" GET EXP PTR
	SME	(ITYEM)		;"25-4" WAS INTEGER DIVISION DONE?
	TLYT	(REGCNT)	;"25-4" YES, UP THE REG COUNT FOR SAVING
	JMP	(MDGFIN)	;MPY DIV GEN FIN
DIVCCK:			;CHECK FOR UNEQUAL TYPES "22D"
	XW2.0	(FET)		;GET EXP OP PNTR "22D"
	STO	(EOPPNT)	;SAVE TYPE "22D"
	SMK	(ETYEM)		;ARE TYPES THE SAME? "22D"
	JSBF	(GENRUN)	;NO CONVERT TO DOMINATING TYPE "22D"
	XIT	(EXIML)		;EXIT "22D"
RFBGEN:					;READY FOR BINARY GEN
	FET	(ZERO)	;ZERO
	W2	(SWT)		;W2
	JSB	(RFBGFI)	;READY FOR BINARY GEN FIN
	W2	(STO)		;W2
	FET	(EOPPNT)	;GET OP PNTR ;"21I"
	SMK	(OTAEM)		;IF AN OPERATOR IS IT A ;"21I"
	SPKT	(LOPTRA)	;LOGICAL OPERATOR ? ;"21I"
	POW	(D1)		;PRUNE THE NOW SUPERFULOUS OP PNTR ;"21I"
	IERT	(LTYEM)		;LOG OPS GIVE LOG RESULTS ;"21I"
	W1	(SWT)		;W1
	XIT	(EXIML)	;EXIT
RFBGFI:					;READY FOR BINARY GEN FIN
	XML	(BOSML)	;BINARY ORDER SELECT
	W1	(ART)		;W1
	JMPT	(RFBGF2)	;$2
	W1	(SWT)		;W1
	JSB	(MPO2CK)	;MULT POWER OF 2 CK
	POWT	(D1)		;ONE
	W2T	(NOT)		;W2
	W1F	(SWT)		;W1
RFBGF2:
	JSB	(GENRUN)	;GEN RUN
	JSB	(RFBGF4)	;CHECK FOR UNEQUAL TYPES "22D"
	W0	(ART)		;W0
	JMPF	(RFBGF1)	;$1
	JSB	(RSATES)	;REG SAVE TEST
	JMPT	(RFBGF1)	;$1
	W1	(SWT)		;W1
	JSB	(GENRUN)	;GEN RUN
	JSB	(RFBGF4)	;CHECK FOR UNEQUAL TYPES "22D"
	W1	(ART)		;W1
	JMPF	(RFBGF3)	;$3
	W2	(NOT)		;W2
	W0	(ART)		;W0
	XITF	(EXIML)	;EXIT
	JSB	(RSATES)	;REG SAVE TEST
	XMLF	(BOSML)	;BINARY ORDER SELECT
	XIT	(EXIML)	;EXIT
RFBGF1:
	W1	(SWT)		;W1
RFBGF3:
	JSB	(EIRGEN)	;EXP IN REG GEN
	JSB	(RFBGF4)	;"22D"
	SMK	(IIVEM)	;INSIDE AN IMPLIED DO LOOP ?
	JSBF	(SRITGE)	;NO, OPTIMIZE (SAVE REG IN TEMP GEN)
	W1	(SWT)		;W1
	XIT	(EXIML)	;EXIT
RFBGF4:			;CHECK FOR TYPES OF OPERANDS IN EXP
	SMK	(REGEM)		;IS EXP IN REG "22D"
	XITF	(EXIML)		;NO "22D"
	W3	(FET)		;GET EXP PNTR "22D"
	SMK	(LBLEM)		;REL OPS HAVE OFFSET IN W3 (ROLL #=0) ;"22D"
	W5T	(CLA)		;SO GET THE REAL EXP PNTR ;"22D"
	XW0.0	(CLA)		;GET OP PNTR "22D"
	STO	(EOPPNT)	;SET NEW EXP TYPE "22D"
	SMK	(ETYEM)		;IS EXP IN REG SAME AS NEXT LEVEL EXP? "22D"
	JSBF	(GENRUN)	;NO CONVERT IT "22D"
	XW0.0F	(FET)		;"23-AO"
	IERF	(ETYEM)		;"23-AO"
	XW1.0F	(STO)		;"23-AO"
	XIT	(EXIML)		;EXIT "22D"
DBPO2G:					;DIV BY POWER OF 2 GEN
	JSB	(PO2CHE)	;POWER OF 2 CHECK
	XITF	(EFAML)		;NOT A CONSTANT POWER OF 2
	W0	(NOT)		;MAKE ONE'S COMPLEMENT NEGATIVE ;"22J"
	W0	(TLY)		;MAKE TWO'S COMPLEMENT NEGATIVE ;"22J"
	SON	(ITYEM)		;DIVIDE BY ASH ? ;"22J"
	SONF	(OCTEM)		;"23-AN"
	JMPF	(SGEFIN)	;NO, TAKE THE NORMAL PATH ;"22J"
	SEK	(ZERO)		;IF N=0, 2**N=1 ;"22J"
	XMLT	(P1ETML)	;OPERATION IS IDENTITY, IGNORE ;"22J"
	W2	(FET)		;GET AC PNTR ;"22J"
	BAK	(.SKGE0)	;GEN SKIPGE 00,AC ;"22J"
	FET	(DAT1)		; GET DIVIDEND (CONSTANT POWER OF 2) ;"22J"
	SUB	(ONE)		;MAKE 2**N-1 ;"22J"
	STO	(DAT1)		;STORE IN CONSTANT FILE CLUE ;"22J"
	REG	(ICOFIL)	;REGISTER AS INTEGER CONSTANT ;"22J"
	FET	(CREPNT)	;AND GET PNTR ;"22J"
	BIN	(.ADD0)		;GEN ADD/ADDI AC,2**(N-1) ;"22J"
	POW	(D1)		;PRUNE EXTRA REG PNTR ;"22J"
	EAWI	(.ASH0)		;LOAD INSTRUCTION TO BE GENED ;"22J"
	JMP	(SGEFI2)	;AND CONTINUE AS IF NOTHING HAD HAPPENED	;"22J"
MBPO2G:					;MPY BY POWER OF 2 GEN
	JSB	(PO2CHE)	;POWER OF 2 CHECK
	JMPF	(EXIFAL)	;EXIT FALSE
SGEFIN:					;SHIFT GEN FIN
	SEK	(ZERO)	;ZERO
	XMLT	(P1ETML)	;PRUNE ONE EXIT TRUE
	AND	(RHAMAS)	;RIGHT HALF MASK
	SON	(DITEM)	;DOUBLE ITEM EM
	SONF	(RTYEM)	;REAL TYPE EM
	EAWIT	(.FSC0)	;FSC INST
				;3 LINES DELETED ;"23-AN"
	EAWIF	(.ASH0)		;ASH INST ;"23-AN"
SGEFI2:
	JSB	(SCAGEN)	;SCALE GEN
	FET	(PDPSW)	;CHECK FOR PDP-10 ;"25-1"
	SLT	(ZERO)	;PDP-6 AND KI10 ARE THE SAME ;"25-1"
	SMKT	(DITEM)	;YES ,TREAT D.P.&CMPL SAME
	JMPT	(SGEFI1)	;$1
	SMK	(CTYEM)	;COMPLEX TYPE EM
	XITF	(ETRML)	;EXIT TRUE
SGEFI1:
	EAWT	(.FSC0)	;FSC INST
	JSBT	(BSHREF)	;BUILD SECOND HALF REF
	MOA	(CODROL)	;CODE ROLL
	SUB	(ONE)		;ONE
	MON	(CODROL)	;CODE ROLL
	FET	(PDPSW)	;CHECK FOR PDP-10 ;"25-1"
	SLT	(ZERO)	;"25-1"
	SONT	(DPTEM)	;D.P. TYPE?
	XMLF	(ETRML)		;LSH
	W1	(FET)		;GET H.O.AC
	W0	(FET)		;COPY
	W0	(TLY)		;MAKE L.O.AC
	BIN	(.FAL0)	;FADL H.O.AC,L.O.AC
	POW	(D1)		;PRUNE
	XML	(ETRML)	;EXIT TRUE
MPO2CK:					;MULT POWER OF 2 CK
	FET	(EOPPNT)	;EXP OP PNTR
	SPT	(MODOTR)	;MULT OR DIV OP TRAIT
	JMPF	(EXIFAL)	;EXIT FALSE
PO2CHE:					;POWER OF 2 CHECK
	SMK	(CONEM)	;CONST PNTR EM
	XITF	(EFAML)		;EXIT FALSE
	SMK	(HCOEM)		;HOLLERITH CONST EM	;LSH
	XITT	(EFAML)		;EXIT FALSE
	XW0.0	(FET)		;ZERO RUNG
	STO	(DAT1)	;DATA 1
	SMK	(DITEM)	;DOUBLE ITEM EM
	XW0.1T	(FET)		;ONE RUNG
	STOT	(DAT2)	;DATA 2
	ZERF	(DAT2)	;DATA 2
	SMKF	(RTYEM)	;REAL TYPE EM
	XMLF	(FP2CML)	;FX POWER OF 2 CHECK ML
	SNZ	(DAT2)	;DATA 2
	JMPT	(EXIFAL)	;EXIT FALSE
	FET	(DAT1)	;DATA 1
	SMK	(FPO2EM)	;FL POWER OF 2 EM
	XMLF	(P1EFML)	;PRUNE ONE EXIT FALSE
	XIT	(MFPML)	;MAKE FL POWER ML
EXPGEN:					;EXPON GEN
	SMK	(ICOEM)	;INTEGER CONST EM
	JMPF	(EBSGEN)	;EXPON BY SR GEN
	FET	(EOPPNT)	;EXP OP PNTR
	SME	(DITEM)	;DOUBLE ITEM EM
	XW0.0	(FET)		;ZERO RUNG
	JMPF	(EXPGE1)	;$1
	SLK	(THREE)	;THREE
	JMP	(EXPGE2)	;$2
EXPGE1:
	XML	(ECHML)	;EXPON BY MPY CHECK
EXPGE2:
	POWF	(D1)		;ONE
	JMPF	(EBSGEN)	;EXPON BY SR GEN
	SEK	(ZERO)	;ZERO
	POWT	(D3)		;THREE
	FETT	(CONPNT)	;CONST ONE PNTR
	JMPT	(GENRUN)	;GEN RUN
	W1	(SWT)		;W1
	W1	(EOR)		;W1
	SME	(MINEM)	;MINUS EM
	JMPF	(EBMGEN)	;EXPON BY MPY GEN
	JSB	(EBMGEN)	;EXPON BY MPY GEN
	FET	(CONPNT)	;CONST ONE PNTR
	W1	(SWT)		;W1
	JMP	(DIVGEN)	;DIV GEN
EBMGEN:					;EXPON BY MPY GEN
	SLK	(ZERO)	;ZERO
	W0T	(NOT)
	W0T	(TLY)
	SMK	(EVEEM)	;EVEN EM
	W1	(SWT)		;W1
	JSB	(GENRUN)	;GEN RUN
	ANDT	(ABSMAS)
	W1	(SWT)		;W1
	SEK	(ONE)		;ONE
	XMLT	(P1EML)	;PRUNE ONE EXIT
	XML	(IEAML)	;INTEGER EXPON ABSTRACT
	W0	(FET)		;W0
	SMK	(REGEM)	;REG EM
	JMPF	(EBMGE1)	;$1
	JSB	(RSATES)	;REG SAVE TEST
	SNZF	(ISCBOX)	;INTEGER SCANER BOX
	JMPF	(EBMGE1)	;$1
	STO	(REGTEM)	;REG TEMP
	SMK	(DITEM)	;DOUBLE ITEM EM
	JSBT	(DSITGE)	;DOUBLE STORE IN TEMP GEN
	JSBF	(SITGEN)	;STORE IN TEMP GEN
	FET	(REGTEM)	;REG TEMP
	W1	(SWT)		;W1
	AND	(ABSMAS)	;CLEAR OUT SIGN BIT "23AN"
EBMGE1:
	STO	(VPNBOX)	;VAR PNTR BOX
	JSB	(GIRGEN)	;GRNTEE IN REG GEN
	AND	(ABSMAS)
	W0	(FET)		;W0
EBMGE2:
	FET	(ISCBOX)	;INTEGER SCANER BOX
	SLK	(ZERO)	;ZERO
	AMY	(ISCBOX)	;INTEGER SCANER BOX
	JMPF	(EBMGE3)	;NO ODD MULTIPLY
	FET	(VPNBOX)	;VAR PNTR BOX
	SMK	(AREEM)	;ARRAY ?
	JMPF	(EBMGE4)	;NOT AN ARRAY
	XW0.2	(FET)		;YES,GET SCRIPT PNTR
	SMK	(SUBEM)	;IS IT A SUB EXP ?
	XW0.4T	(TLY)		;YES, INCREMENT SCRIPT USE COUNT
	POW	(D1)		;REMOVE SCRIPT PNTR
EBMGE4:
			;LINE DELTED HERE "22D"
	BTY	(.IMU0)	;MPY INST
EBMGE3:
	SNZ	(IBICNT)	;INTEGER BITS CNTR
	DIMT	(IBICNT)	;INTEGER BITS CNTR
	JSBT	(SATREG)	;SAVE THIRD REG
	JSBT	(R0SACK)	;"23-AQ"
	BTKT	(.IMU0)	;MPY INST
	JMPT	(EBMGE2)	;$2
	FET	(VPNBOX)
	SME	(MINEM)
	BAKT	(.MNS0)
	XML	(P1EML)	;PRUNE ONE EXIT
EBSGEN:					;EXPON BY SR GEN
	FET	(EOPPNT)	;EXP OP PNTR
	SMK	(DITEM)		;DOUBLE ITEM EM ;"23-AM"
	JMPF	(ESIGEN)	;EXPON SINGLE GEN
	W1	(SWT)		;W0_EXPONENT,W1_EOPPNT ;"23-AM"
	SMK	(ITYEM)		;EXPONENT=INTEGER OR DITEM ;"23-AM"
	STKT	(EOPPNT)	;EOPPNT_INTEGER ;"23-AM"
	JSB	(GENRUN)	;"23-AM"
	JSBT	(SAEXGE)	;"23-AM"
	W1	(SWT)		;W0_EOPPNT,W1_EXPONENT ;"23-AM"
	STO	(EOPPNT)	;EOPPNT_RESTORED TO DITEM ;"23-AM"
	JSBF	(SAEXGE)	;"23-AM"
	W1	(SWT)		;W1
	SMK	(DITEM)		;"24-7"
	SMKF	(SUBEM)		;NOT DOUBLE OR COMPLEX "24-7"
	JSBF	(GENRUN)	;AND NOT A SUBEXP "24-7"
	JSB	(EIR0GE)	;EXP IN REG 0 GEN
	SMK	(DITEM)		;"24-7"
	JSBF	(GENRUN)	;"24-7" CONVERT TO DOUBLE
	W1	(SWT)		;W1
	SMK	(MLBEM)		;MADE LABEL ? (ARRAY ELEMENT ADDRESS STORE)
	JSBT	(MLGAKE)	;YES, GEN THE LABEL
	NOZ	(SAV16)		;SAVE REG 16 ONLY IF USED ;"21V"
	BAK	(.MEI2)	;MOVEI 16 INST
	SME	(ITYEM)	;INTEGER TYPE EM
	JMPT	(EBSGE1)	;$1
	FET	(EOPPNT)	;CHECK TYPE "24-7"
	SME	(CTYEM)		;COMPLEX? "24-7"
	BLKT	(.CEXP3)	;CEXP.3 LINK
	BLKF	(.DEXP3)	;DEXP.3 LINK
	XIT	(EXIML)	;EXIT
EBSGE1:
	SMK	(CTYEM)	;COMPLEX TYPE EM
	BLKT	(.CEXP2)	;CEXP.2 LINK
	BLKF	(.DEXP2)	;DEXP.2 LINK
	XIT	(EXIML)	;EXIT
CTFLGE:					;CONV TO FL GEN
	JSB	(CTFCK)	;CONVERT TO FLO OR FIX CK
	IERT	(MINEM)
	W1	(SWT)
	SMK	(RZEEM)	;REG ZERO ?
	JMPF	(CTFLG5)	;"25-02"
	SMK	(DITEM)		;DOUBLE OR COMPLEX "25-02"
	JSBT	(DSITGE)	;DOUBLE STORE IN TEMP "25-02"
	JSBF	(SITGEN)	;SINGLE STORE IN TEMP "25-02"
CTFLG5:				;"25-02"
	JSB	(AIVREP)	;REPLACE WITH DO REG IF INDEX
	SMK	(AREEM)		;"25-5" ARRAY REF?
	JMPF	(CTFLG6)	;"25-10" SKIP
	SMK	(MINEM)		;"25-10" AND NEGATIVE?
	EORT	(SIGMAS)	;"25-10" YES CLEAR THE SIGN BIT
	JSB	(GIRGEN)	;"25-5" YES,PUT IN REG
CTFLG6:			;"25-10"
	FET	(EOPPNT)	;"25-1"
	SME	(DPTEM)		;"25-1"
	BLKT	(.DFLOT)	;GET D.P. RESULT ;"25-1"
	JMPT	(CTFLG3)	;"25-1"
	FET	(PDPSW)		;"25-1"
	SGT	(ZERO)		;SET FLAG TRUE FOR KI10 ;"25-1"
	BAKT	(.FLTR)		;"25-1"
	JMPT	(CTFLG4)	;"25-1"
	BLK	(.FLOAT)	;NOT KI10 FLOAT. LINK ;"25-1"
CTFLG3:
	BAK	(.ARG0)	;ARG INST
CTFLG4:
	IER	(RTYEM)	;REAL TYPE EM
	FET	(EOPPNT)	;EXP OP PNTR
	SMK	(DITEM)	;DOUBLE ITEM EM
	POWF	(D1)		;ONE
	JMPF	(CTFLG1)	;$1
	SME	(DPTEM)	;DOUBLE PRECISION TYPE EM
	IERT	(DPTEM)		;SET NEXT OPERAND DP "22D"
	JMPT	(CTFLG1)	;"22D"
	IER	(CTYEM)	;COMPLEX TYPE EM "22D"
; DELETED "26T"	W1	(SWT)		;W1
; DELETED "26T" 	XW0.1	(NOZ)		;NEXT HIGHER REG
;DELETED "22X"	JSB	(DRGFIN)	;DOUBLE REG GEN FIN
; DELETED "26T"	W0	(TLY)		;"22X"
; DELETED "26T"	BRI	(.MEI0)		;"22X"
; DELETED "26T"	W0	(DIM)		;"22X"
; DELETED "26T"	W1	(SWT)		;W1
; DELETED "26T"	IERT	(DPTEM)	;DOUBLE PRECISION TYPE EM
	FET	(RONPNT)	;GET A REG. ONE POINTER TO CLEAR ;"26T"
	XW0.0	(NOZ)		;MARK AS USED ;"26T"
	BRI	(.MEI0)		;GEN A MOVEI 1,0 ;"26T"
	POW	(D1)		;GET RID OF EXTRA POINTER ;"26T"
CTFLG1:
	SMK	(TEMEM)		;DOES W0 HAVE A TEMP EM
	JMPF	(CTFLG2)	;NO, RETURN
	W0	(FET)		;[345] GET A COPY OF TEMP POINTER FOR TSAML
	FET	(RZEPNT)	;GET REG 0 PNTR
	XML	(TSAML)		;SET EM OF REG 0 IN ALL ENTRIES = W1
	POW	(D2)		;REMOVE REG 0 PNTR AND TEMP PNTR
CTFLG2:
	XW1.0	(STO)		;ZERO RUNG
	XIT	(EXIML)	;EXIT
CTFGEN:					;CONV TO FX GEN
	JSB	(CTFCK)	;CONVERT TO FLO OR FIX CK
	IERT	(MINEM)		;SET MINUS FOR ASSIGNMENT "22L"
	IER	(ITYEM)		;MAKE SURE REG0 IS INTEGER ;"23T"
	W1	(SWT)
			;2 LINES DELETED HERE "22L"
	SMK	(RZEEM)	;REG ZERO ?
	JMPF	(CTFGN3)	;"25-02"
	SMK	(DITEM)		;DOUBLE OR COMPLEX "25-02"
	JSBT	(DSITGE)	;DOUBLE STORE IN TEMP "25-02"
	JSBF	(SITGEN)	;SINGLE STORE IN TEMP "25-02"
CTFGN3:			;"25-02"
	JSB	(AIVREP)	;GET ACTIVE INDUCED VAR - "20A"
	SMK	(AREEM)		;IS IT ARRAY REF? - "20A"
	JMPF	(CTFGN4)	;"25-10"
	SMK	(MINEM)		;"25-10"AND NEGATIVE?
	EORT	(SIGMAS)	;"25-10" CLEAR THE SIGN BIT IF ANY
	JSB	(GIRGEN)	;YES GEN IN A REG - "20A"
CTFGN4:			;"25-10"
	SMK	(DPTEM)		;"23T" DOUBLE ITEM?
	BLKT	(.DFIX)		;CALL "IDINT" IF DOUBLE ITEM ;"25-1"
	JMPT	(CTFGN1)	;"25-1"
	FET	(PDPSW)		;"25-1"
	SGT	(ZERO)		;KI10 SETS FLAG TRUE ;"25-1"
	BAKT	(.FIX)		;FOR KI10, GEN "FIX" INSTRUCTION ;"25-1"
	JMPT	(CTFGN2)	;"25-1"
	BLK	(.IFIX)		;FOR KA10, PDP6, CALL "IFIX" ;"25-1"
CTFGN1:
	BAK	(.ARG0)		;GEN ARG FOR SUBROUTINE CALLS
CTFGN2:
	IER	(ITYEM)	;INTEGER TYPE EM
	STK	(EOPPNT)	;"22D"
	JMP	(CTFLG1)	;$1
CTFCK:					;CONVERT TO FLO OR FIX CK
	SMK	(RZEEM)	;REG ZERO EM
	FETT	(RZEPNT)	;REG ZERO PNTR
	JSBF	(GR0AGE)	;GRNTEE REG 0 AVAIL GEN
	SON	(MINEM)	;MINUS EM 
	XIT	(EXEQML)
ESIGEN:					;EXPON SINGLE GEN
	POW	(D1)		;PRUNE EOPPNT ;"23-AM"
	JSB	(GR0AGE)	;MAKE SURE REG 0 IS NOT IN USE "22N"
	POW	(D1)		;PRUNE XTRA PNTR "22N"
	SMK	(SUBEM)	;SUBEXP EM
	STKT	(EOPPNT)	;"23-AM"
	JSBT	(EIRGAS)	;EXP IN REG GEN AND SAVE
	JSBF	(AIVREP)	;ACTIVE IND VAR REPLACE
	XW2.0T	(FET)		;GET NEXT OP PNTR "22D"
	STOT	(EOPPNT)	;SET NEW EXP TYPE "22D"
	W1	(SWT)		;W1
	JSB	(EIERGE)	;EXP IN EVEN REG GEN
	JSB	(SRITGE)	;SAVE REG IN TEMP GEN
	W1	(SWT)		;W1
	XW0.4T	(DIM)		;USE CNT RUNG
	XW0.3T	(FET)		;STATUS PNTR RUNG
	JSBT	(SNOEXI)	;SIGN NOTE EXIT
	STK	(PINATO)	;PNTR INSERT ATOM
	W1	(FET)		;W1
	W0	(TLY)		;W0
	SMK	(PINEM)	;PNTR INSERT EM
	JSBT	(GPRGEN)	;GRNTEE POS REG GEN
	JSBF	(GAVGEN)	;GRNTEE AVAIL GEN
	W1	(SWT)		;W1
	W0	(FET)		;W0
	W2F	(FET)		;W2
	JSBF	(RLOGEN)	;REG LOAD GEN
	NOZ	(DCTYPE)	;[27P] DON'T CHANGE TYPE
	JSBF	(RREEXI)	;REG RESET EXIT
	W0F	(FET)		;W0
	JSB	(RREEXI)	;REG RESET EXIT
	SNZ	(LSPDEF)	;DURING LOCAL SUBPROG. DEF? ; "26L"
	TLYF	(REGCNT)	;NO, OK TO UP REG CNT FOR SAVING ; "26I" ; "26L"
	W2	(FET)		;GET BASE REG ;"21W"
	SME	(RZEEM)		;IS IT REG 0 ? ;"21W"
	JMPT	(ESIGE1)	;YES, DON'T BOTHER SAVING IT ;"21W"
	FET	(RZEPNT)	;MAKE REG 0 ;"21W"
	IER	(DITEM)		;AND REG 1 AVAILABLE ;"21W"
	JSB	(GABTGE)	;SO THE SUBROUTINES CAN USE THEM ;"21W"
	POW	(D1)		;PRUNE REG PNTR ;"21W"
ESIGE1:	SME	(RTYEM)		;REAL TYPE EM ;"23-AM"
	W1	(CLA)		;W1
	JMPT	(ESIGE3)	;[27N] $3
	SMK	(RTYEM)		;REAL TYPE EM ;"23-AM"
	LSSF	(EXP1.0)	;"23-AM"
	LSST	(EXP2.0)	;"23-AM"
ESIGE2:
	W0	(DIM)		;W0
	AND	(DISMAS)	;DISPL MASK
	IOM	(SYMBOL)	;SYMBOL
	REG	(GSPFIL)	;GLOBAL SPROG FILE
	FET	(GSPPNT)	;GLOBAL SPROG PNTR
	BAI	(.PSHJ1)	;PUSHJ 17 INST
	XIT	(EXIML)	;EXIT
ESIGE3:	SMK	(RTYEM)			;[27N] IS THE BASE REAL?
	JSBF	(CTFLGE)		;[27N] NO- CONVERT IT
	JMPT	(ESIGE4)		;[347] YES, SKIP HOUSEKEEPING  $4
	POW	(D1)			;[27N] PRUNE REG 0 FROM WL
	BAKF	(.MEM0)			;[27O] RESTORE FLOATED VALUE TO RIGHT AC
	IER	(RTYEM)			;[27N] FOR REAL TYPE FOR RESULT
	W0	(FET)			;[27N] FIX WL

ESIGE4:	LSS	(EXP3.0)		;[347] GET CORRECT EXP SUBROUTINE
	JMP	(ESIGE2)		;[27N] GO ON  $2
FRPGEN:					;FUNC REF PNTR GEN
;		1 LINE DELETED     ;"26C"
;	JSB	(GR0AGE)	;GRNTEE REG 0 AVAIL GEN
	FET	(RZEPNT)		;REG 0 POINTER ;"26C"
	XW0.0	(FET)		;REG 0 ARG TRAIT "26C"
	AND	(TYPMAS)	;TYPE MASK ;"26C"
	W1	(IOM)		;TYPE TO REG 0 POINTER ;"26C"
	JSB	(GABTGE)	;GRNTEE REG 0 AVAIL BY TYPE GEN ;"26C"
	XW1.0T	(FET)		;SPROG NAME PNTR RUNG
	W1	(SWT)		;W1
	SON	(DITEM)	;DOUBLE ITEM EM
	JMPT	(FRGFIN)	;FUNC REF GEN FIN
	SMK	(DITEM)	;DOUBLE ITEM EM
	JSB	(FRGFIN)	;FUNC REF GEN FIN
	W1	(FET)		;"25-8"
	IER	(ETYEM)		;"25-8" PUT TYPE IN EXPPTR
	XW1.0	(STO)		;"25-8" PUT PTR IN REG PTR
	XIT	(EXIML)	;EXIT
DFRGEN:					;DBL FUNC REF GEN
	SMK	(DITEM)	;DOUBLE ITEM EM
	FET	(RONPNT)	;REG ONE PNTR
	JSBT	(GAVGEN)	;GRNTEE AVAIL GEN
	XML	(P1EML)	;PRUNE ONE EXIT
FRGFIN:					;FUNC REF GEN FIN
	W2	(XNI)		;W2
	CLA	(APPRUN)	;ARG PLEX PNTR RUNG
	JSB	(APPGEN)	;ARG PLEX PNTR GEN
	JSB	(GR0AGE)	;GRNTEE REG 0 AVAIL GEN
	POW	(D1)		;ONE
	JSB	(DFRGEN)	;DBL FUNC REF GEN
	JSB	(SLIGEN)	;SPROG LINK GEN
	JSBT	(SREGEN)	;SPROG REF GEN
	XW0.0	(FET)		;SPROG NAME PNTR RUNG
	AND	(TYPMAS)	;TYPE MASK
	IOR	(RZEPNT)	;REG ZERO PNTR
	SON	(NOTEM)	;NOT EM
	POCT	(ABSINS)
	POCT	(.SEA0)
	FETT	(NOTMAS)	;NOT MASK
	W2T	(EOM)		;W2
ARPGEN:					;ARRAY REF PNTR GEN
TPNGEN:					;TEMP PNTR GEN
RPNGEN:					;REG PNTR GEN
VPNGEN:					;VAR PNTR GEN
CPNGEN:					;CONST PNTR GEN
	SMK	(ITYEM)	;INTEGER TYPE EM
	JMPF	(DTYCHE)	;DP TYPE CHECK
	JSB	(AIVCHE)	;ACTIVE INDUC VAR CHECK
	FET	(EOPPNT)	;EXP OP PNTR
	SMK	(RTYEM)	;REAL TYPE EM
	SMKF	(DITEM)	;DOUBLE ITEM EM
	POW	(D1)		;ONE
	XITF	(EXIML)	;EXIT
	SMK	(DREEM)	;DO REG EM
	JMPT	(CPNGE1)	;$1
	SMK	(CONEM)	;CONST PNTR EM
	JMPT	(FINCON)	;FL INTEGER CONST
	XW0.0	(FET)		;ZERO RUNG
	SON	(AREEM)	;ARRAY REF EM
	XW0.0T	(CLA)		;ZERO RUNG
	STO	(SYMBOL)	;SYMBOL 1
	ISE	(SINFIL)	;SUBSCRIPT INTEGER FILE
CPNGE1:
	JSBT	(GIRGEN)	;GRNTEE IN REG GEN
	JMPF	(CPNGE4)
	XW0.0	(FET)		;GET DO REG.
	IER	(RTYEM)	;MAKE SURE IT'S REAL TYPE
	XW1.0	(STO)		;RETURN IT

	SNZ	(PDPSW)	;TEST MACHINE TYPE
	BRIF	(.TLC1)	;TLC 233 OCTAL INST
	FETF	(CZEPNT)	;CONST ZERO PNTR
	BINF	(.FAR0)	;FAD INST

	BRIT	(.FSC1)	;FSC 233
	JMP	(CPNGE2)	;$2

CPNGE4:
	SMK	(AREEM)	;ARRAY REF EM
	JSBT	(SCRGEN)	;SCRIPT GEN
;LINE DELETED "25-5"	XW1.2T	(STK)		;"23-AR"
	JMPF	(CPNGE3)	;$3
	SMK	(DREEM)
	XW0.0F	(CLA)		;ZERO RUNG
	XW0.4F	(TLY)		;USE CNT RUNG
	POW	(D1)		;ONE
CPNGE3:
	JSB	(CTFLGE)	;CONV TO FL GEN
CPNGE2:
	IER	(ETYEM)	;EXP TYPE EM
	XIT	(EXIML)	;EXIT
DTYCHE:					;DP TYPE CHECK
	FET	(EOPPNT)	;EXP OP PNTR
	SME	(DITEM)	;DOUBLE ITEM EM
	XITF	(EXIML)	;EXIT
	SMK	(DITEM)	;DOUBLE ITEM EM
	XITT	(EXIML)	;EXIT
	SMK	(CONEM)	;CONST EM
	JMPF	(GIRGEN)	;GRNTEE IN REG GEN
	FET	(EOPPNT)	;EXP OP PNTR	;"21G"
	SME	(DPTEM)		;DOUBLE PRECISION OPERATION ?	;"21G"
	SMKT	(RTYEM)		;YES, IS CONST REAL?	;"21G"
	IERT	(DPTEM)		;YES CHANGE TO DBL
	XITT	(EXIML)		;EXIT
	SMK	(HTYEM)	;HOLLERITH TYPE EM
	JMPT	(LCOFIN)	;LITERAL CONSTANT FIN
	XW0.0	(FET)		;ZERO RUNG
	JMP	(FICFIN)	;FL INT CONST FIN
LCOFIN:					;LITERAL CONSTANT FINISH
	STK	(HBUIND)	;STORE ROLL PNTR
	XW0.1	(FET)		;GET HIGH ORDER PART
	XW1.0	(FET)		;GET PLEX CNT
	SLT	(TWO)		;CHK FOR DBL WD CONST
	JMPT	(FICFIN)	;NORMAL MODE FOR SINGLE WD
	SON	(MINEM)	;CHK PNTR FOR NEGATE
	JSB	(CSIADJ)	;CONSTANT SIGN ADJ
	SUBT	(ONE)		;ONE'S COMP IF NEGATE
	STO	(DAT1)	;STORE HIGH ORDER
	FET	(HBUIND)	;GET PRUNED PNTR
	XW0.2	(FET)		;GET LOW ORDER PART
	JSB	(CSIADJ)	;CONSTANT SIGN ADJ
	STO	(DAT2)	;STORE LOW ORDER
	FET	(EOPPNT)	;EXPRESSION OPERATION PNTR
	SMK	(DPTEM)	;DP TYPE EM
	POWT	(D1)		;PRUNE
	JMPT	(FICFI4)	;$4
	SME	(CTYEM)	;COMPLEX TYPE EM
	JMPF	(FICFI3)	;$3
	JMP	(FICFI5)	;$5

FINCON:					;FL INTEGER CONST
	XW0.0	(FET)		;ZERO RUNG
	XML	(FINML)	;CONV INTEGER TO FL
FICFIN:					;FL INT CONST FIN
	JSB	(CSIADJ)	;CONST SIGN ADJUST
	STO	(DAT1)	;DATA 1
	ZER	(DAT2)		;CLEAR LOWER
	FET	(EOPPNT)	;EXP OP PNTR
CCOFIN:					;CONST CONV FIN
	SMK	(DPTEM)	;DOUBLE PREC TYPE EM
	JMPF	(FICFI1)	;$1
	POW	(D1)		;ONE
	IER	(DPTEM)		;SET TO DP
FICFI4:
	REG	(DPCFIL)	;DOUBLE PREC CONST FILE
	JMP	(FICFI2)	;$2
FICFI1:
	SME	(CTYEM)	;COMPLEX TYPE EM
	JMPF	(FICFI3)	;$3
FICFI5:
	REG	(CCOFIL)	;CONPLEX CONST FILE
	JMP	(FICFI2)	;$2
FICFI3:
	REG	(RCOFIL)	;REAL CONST FILE
	FET	(CREPNT)	;GET REG PNTR
	IER	(RTYEM)		;SET IT TO REAL
	XIT	(EXIML)		;EXIT
FICFI2:
	FET	(CREPNT)	;CRRNT REG PNTR
	XIT	(EXIML)	;EXIT
AIVCHE:					;ACTIVE INDUC VAR CHECK
	STK	(PINATO)	;PNTR INSERT ATOM
	FET	(IIVPNT)	;INSIDE INDUC VAR PNTR
	SME	(PINEM)	;PNTR INSERT EM
	NOZT	(REGSAV)	;SET CLEAR STATUS FLAG
	IERT	(DREEM)	;DO REG EM
	XIT	(EXEQML)	;EXIT EQUAL ML
APPGEN:					;ARG PLEX PNTR GEN
	STK	(APLPNT)	;ARG PLEX PNTR
	SEQ	(ZERO)	;ZERO
	JMPT	(EXIFAL)	;EXIT FALSE
	RSV	(APNROL)	;ARG PNTR ROLL
	FET	(EOPPNT)	;EXP OP PNTR
	XNI	(APLPNT)	;ARG PLEX PNTR
	FET	(ZERRUN)	;ZERO RUNG
APPGE1:
	JOW	(APPGE2)	;$2
	DFA	(APLROL)	;ARG PLEX ROLL
	FET	(APLPNT)	;ARG PLEX PNTR
	W1	(SWT)		;W1
	STK	(EOPPNT)	;EXP OP PNTR
	JSB	(SARGEN)	;SPROG ARG GEN
	MON	(APNROL)	;ARG PNTR ROLL
	STO	(APLPNT)	;ARG PLEX PNTR
	JMP	(APPGE1)	;$1
APPGE2:
	STO	(EOPPNT)	;EXP OP PNTR
	XML	(ETRML)	;EXIT TRUE

AIVREP:					;ACTIVE IND VAR REPLACE
	JSB	(AIVCHE)	;ACTIVE IND VAR CHECK
	XIT	(EXIML)	;EXIT
SLIGEN:					;SPROG LINK GEN
	SMK	(LSPEM)	;LOCAL SPROG EM
	JMPF	(SLGFIN)	;NOT A LOCAL SPROG
	FET	(LSPDEF)	;"23-AM"
	STO	(PINATO)	;"23-AM"
	SMK	(PINEM)		;"23-AM"
	CCFT	(M20QT)		;"23-AM"
	XW0.1	(CLA)		;LOCAL SPROG MADE LBL RUNG
	BAI	(.JSA1)		;BUILD	JSA	16,MADE LABEL
	XIT	(EXIML)		;AND EXIT
SLGFIN:				;SPROG LINK GEN FIN
	XW0.0	(FET)		;ZERO RUNG
	STO	(SYMBOL)	;SYMBOL
	ISE	(GDMFIL)	;GLOBAL DMY FILE
	BAIF	(.JSA1)
	XITF	(EXIML)
	REG	(SCAFIL)	;SCALAR FILE
	CLA	(CREPNT)	;CRRNT REG PNTR
	BAI	(.JSA2)	;JSA* 16 INST
	XIT	(EXIML)	;EXIT
SREGEN:					;SPROG REF GEN
	ZER	(APNPNT)	;ARG PNTR PNTR
SREGE1:
	DFA	(APNROL)	;ARG PNTR ROLL
	RELF	(APNROL)	;ARG PNTR ROLL
	XITF	(EXIML)	;EXIT
	SNZ	(SPSW)		;[27M]DOING AN OPEN/CLOSE?
	JSBT	(ARGPRO)	;[27M]YES, DO PROLOG FOR O/C ARGS
	SMK	(MLBEM)	;MADE LBL EM
	JSBT	(MLGAKE)	;MADE LBL GEN AND KEEP
	JSB	(MTYREG)	;MAKE TYPE REG

	BIN	(.ARG0)	;ARG INST
	POW	(D1)		;ONE
	JMP	(SREGE1)	;$1


ARGPRO:
	SNZ	(UNIDEF)	;[27M]MAKE SURE UNIT DEFINED
	LCFF	(M27QT)		;[27M]ITS NOT
	XML	(FETAML)	;[27M]GET ARGUMENT TYPE
	FET	(RZEPNT)	;[27M]REG PTR FOR INST.
	FET	(RZEPNT)	;[27M]GOES AS INST. ADDR
	ADD	(ARGNUM)	;[27M]
	BIN	(.ARG0)		;[27M]GENERATE PAIR PROLOG
	POW	(D1)		;[27M]AND GET WORD OFF WORK
	XIT	(EXIML)		;[27M]BACK FOR ARG
SAEXGE:				;SPROG ADDRESS EXPRESSION GEN
SARGEN:					;SPROG ARG GEN
	JSB	(GENRUN)	;GEN RUN
	SMK	(MINEM)	;MINUS EM
	SMKF	(NOTEM)
	JSBT	(GIRGEN)	;GRNTEE IN REG GEN
	SMK	(AREEM)	;ARRAY REF EM
	XW0.2T	(SNZ)		;SCRIPT EXP RUNG
	SMKF	(DAIEM)	;DUMMY ARRAY ID EM
	SMKF	(DGSEM)	;DUMMY GLOBAL SPROG EM
	JMPT	(AARGEN)	;ARRAY ARG GEN
	SMK	(REGEM)	;REG EM
	XITF	(EXIML)	;EXIT
;	SPK	(SUBEM)	;SUBEXP EM
;	XW0.0T	(XNI)		
;	SNZT	(UCNRUN)	;USE CNT RUNG
;	JMPT	(ARGEFI)	;ARG GEN FIN
;	W0	(FET)		;W0
;	AND	(DISMAS)	;DISPLACEMENT MASK
;	SLK	(EIGHT)	;EIGHT
;	SGKT	(TWO)		;TWO
;	POW	(D1)		;ONE
;	JMPT	(GPRGEN)	;GRNTEE POS REG GEN
ARGEFI:					;ARG GEN FIN
	SMK	(DITEM)	;DOUBLE ITEM EM
	JMPF	(SITGEN)	;STORE IN TEMP GEN
	SMK	(DPNEM)	;DOUBLE PREC NEG EM
	JSB	(DTEMAK)	;DOUBLE TEMP MAKER
	JSBF	(DSTGEN)	;DOUBLE STORE GEN
	JSBT	(DPNSGE)	;DOUBLE PREC NEG STORE GEN
	JMP	(DSITGF)	;DOUBLE STORE IN TEMP GEN FIN
AARGEN:					;ARRAY ARG GEN
	SMK	(DGSEM)	;DUMMY GLOBAL SPROG ?
	JMPF	(AARGE1)	;NO,CONTINUE AS PREVIOUS
	XW0.0	(FET)		;GET GLOBAL SPROG NAME
	STO	(SYMBOL)	;SETUP FOR REGISTER
	REG	(SCAFIL)	;FIND OR MAKE A SCALAR
	AND	(TASMAS)	;ISOLATE TYPE AND SIGN
	IOR	(CREPNT)	;COMBINE WITH SCALAR POINTER
AARGE1:
	JSB	(RBTASS)	;REG BY TYPE ASSIGN
	W1	(FET)		;W1
	JSB	(RSTADV)	;REG STAUS ADVANCE
	W1	(SWT)		;W1
	SMK	(AREEM)	;ARRAY REF EM
	BIKF	(.ME0)	;MOVE INST
	BIKT	(.MEI0)	;MOVEI INST
	AND	(TASMAS)	;TYPE AND SIGN MASK
	W1	(SWT)		;W1
	JSB	(LBLMAK)	;LBL MAKER
	BIK	(.RRM0)	;HRRM INST
	W2	(IOM)		;W2
	JMP	(RREEXI)	;REG RESET EXIT
IFNDEF	$NAME,
<

NAMGEN:					;NAMELIST GEN
	FLP	(NNAROL)	;NAMELIST NAME ROLL
	FLP	(NITROL)	;NAMELIST ITEMS ROLL
NAMGE1:
	MOA	(NNAROL)	;NAMELIST NAME ROLL
	JMPF	(PUNCOD)	;PUNCH CODE
	MOA	(NNAROL)	;NAMELIST NAME ROLL
	JSB	(MLBGEN)	;MADE LBL GEN
	MOA	(CODROL)	;CODE ROLL
	XML	(ST5RML)	;SYMBOL TO 50 RADIX
	IER	(LOPTRA)	;LOGICAL OP TRAIT
	MON	(CODROL)	;CODE ROLL
	XML	(ST5RML)	;SYMBOL TO 50 RADIX
	POC	(ABSINS)	;ABS INST
	MON	(CODROL)	;CODE ROLL
NAMGE2:
	MOA	(NITROL)	;NAMELIST ITEMS ROLL
	SEK	(ZERO)	;MARKER SYMBOL
	POCT	(ABSINS)	;ABS INST
	MONT	(CODROL)	;CODE ROLL
	JMPT	(NAMGE1)	;$1
	STK	(SYMBOL)	;SYMBOL
	XML	(ST5RML)	;SYMBOL TO 50 RADIX
	JSB	(IDCLAS)	;ID CLASSIFY
	JSBF	(REGSCA)	;REGISTER SCALAR
	W0	(FET)		;W0
	AND	(ITYEM)	;INTEGER TYPE EM
	DIV	(TWO)		;TWO
	AND	(MOSPOS)	;MOST POSITIVE
	W2	(IOR)		;W2
	SON	(ARREM)	;ARRAY EM
	IORT	(OTYSTA)	;OCTAL TYPE STAMP
	POC	(ABSINS)	;ABS INST
	MON	(CODROL)	;CODE ROLL
	W1T	(STK)		;W1
	AND	(LHZMAS)	;LEFT HALF ZERO MASK
	MON	(CODROL)	;CODE ROLL
	POWF	(D1)		;ONE
	JMPF	(NAMGE2)	;$2
	ISE	(ARRFIL)	;ARRAY FILE
	XNI	(ARRPNT)	;ARRAY PNTR
	FET	(THRRUN)	;THREE RUNG
	XW0.0	(FET)		;ZERO RUNG
	W0	(FET)		;W0
	RSV	(LIMROL)	;LIMITS ROLL
	ADD	(THREE)	;THREE
	IER	(ABSEM)	;ABS EM
	MON	(CODROL)	;CODE ROLL
	XNI	(ARRPNT)	;ARRAY PNTR
	FET	(TWORUN)	;TWO RUNG
	MON	(LIMROL)	;LIMITS ROLL
	XNI	(ARRPNT)	;ARRAY PNTR
	FET	(ONERUN)	;ONE RUNG
	W3	(FET)		;W3
	SME	(DITEM)	;DOUBLE ITEM EM
	W0T	(ADD)		;W0
	MON	(LIMROL)	;LIMITS ROLL
	W2	(STO)		;W2
	CFP	(LIMROL)	;LIMITS ROLL
	MON	(LIMROL)	;LIMITS ROLL
	EAW	(CODROL)	;CODE ROLL
	FLP	(LIMROL)	;LIMITS ROLL
	CAR	(LIMROL)	;LIMITS ROLL
	JMP	(NAMGE2)	;$2
>
EIRGEN:					;EXP IN REG GEN
	JSB	(GENRUN)	;GEN RUN
GIRGEN:					;GRNTEE IN REG GEN
	SMK	(TEMEM)	;TEMP EM
	JMPF	(GIRGE2)	;$2
	SWT	(SYMBOL)	;SYMBOL
	ISE	(REGFIL)	;REG FILE
	SWT	(SYMBOL)	;SYMBOL
	JMPF	(RBTAAL)	;"23-AM"
	AND	(TASMAS)	;MASK TYPE & SIGN ;"23-AM"
	XNI	(CREPNT)	;CURRENT REG PNTR ;"23-AM"
	FET	(ZERRUN)	;ZERO RUNG ;"23-AM"
	AND	(SIGMAS)	;SIGN MASK ;"23-AM"
	W1	(EOM)		;SAVE TYPE & SIGN RESULT ;"23-AM"
	IOR	(CREPNT)	;CRRNT REG PNTR ;"23-AM"
	IER	(REGEM)		;SET BITS IN LEFT HALF ;"23-AM"
GIRGE2:
	SMK	(REGEM)		;REG EM
	JMPF	(RBTAAL)	;REG BY TYPE ASSIGN AND LOAD
	SMK	(DREEM)	;DO REG EM
	JMPT	(RBTAAL)	;REG BY TYPE ASSIGN AND LOAD
	FET	(EOPPNT)	;EXP OP PNTR
	SME	(DITEM)	;DOUBLE ITEM EM
	XITF	(EXIML)	;EXIT
	SMK	(DITEM)	;DOUBLE ITEM EM
	XITT	(EXIML)	;EXIT
	IPK	(ETYEM)		;"23-AO"
	JMP	(DRGFIN)	;DOUBLE REG GEN FIN
GNIR0G:					;GRNTEE NOT IN REG 0 GEN
	SMK	(RZEEM)	;REG ZERO EM
	XITF	(EXIML)	;EXIT
	JSB	(RBTASS)	;REG BY TYPE ASSIGN
	XW1.0	(FET)		;ZERO RUNG
	SMK	(SUBEM)	;SUBEXP EM
	W1	(SWT)		;W1
	XW1.3T	(STK)		;STATUS PNTR RUNG
	W1	(STO)		;W1
	XW1.0	(ZER)		;ZERO RUNG
	JMP	(RLOGEN)	;REG LOAD GEN
RBTAAL:					;REG BY TYPE ASSIGN AND LOAD
	JSB	(RBTASS)	;REG BY TYPE ASSIGN
RLOGEN:					;REG LOAD GEN
	W1	(FET)		;W1
	JSB	(RSTADV)	;REG STATUS ADVANCE
	W1	(SWT)		;W1
	SON	(DITEM)	;DOUBLE ITEM EM
	JMPF	(SRLGEN)	;SINGLE REG LOAD GEN
	SMK	(DITEM)	;DOUBLE ITEM EM
	JMPT	(DRLGEN)	;DOUBLE REG LOAD GEN
	SMK	(HTYEM)		;HOLLERITH TYPE?;"26P"
	JMPF	(RLOGN1)	;NO, PROCEED NORMALLY;"26P"
	XW0.0	(FET)		;GET WORD COUNT RUNG ;"26P"
	SGT	(ONE)		;MORE THAN ONE WORD? ;"26P"
	JMPT	(DHRLGE)	;YES, DO DOUBLE HOLL. REG. LOAD ;"26P"
RLOGN1:				; NOT DOUBLE HOLL. OR DOUBLE ;"26P"
	W1	(FET)		;W1
	IPK	(DITEM)	;DOUBLE ITEM EM
	POW	(D1)		;ONE
	JSB	(SRLGEN)

DRGFIN:					;DOUBLE REG GEN FIN
				;LINE DELETED ;"23-AK"
	SMK	(EREEM)		;EVEN REG? "22X"
	JMPT	(DRGFI1)	;IF EVEN REG CLEAR REG + 1 ;"23-AK"
	SWT	(EOPPNT)	;W0_EOPPNT,EOPPNT_TYPE OF ODD REG PNTR ;"23-AK"
	FET	(EOPPNT)	;W0_ODD REG PNTR,W1_EOPPNT ;"23-AK"
	JSB	(EIERGE)	;EXPR IN EVEN REG GEN ;"23-AK"
	W1	(SWT)		;W0_EOPPNT,W1_EVEN REG PNTR ;"23-AK"
	STO	(EOPPNT)	;RESTORE EOPPNT,W0_EVEN REG PNTR ;"23-AK"
				;6 LINES DELETED ;"23-AK"
DRGFI1:				;"22X"
	IER	(ETYEM)		;"23-AK"
	W0	(TLY)		;W0
			;LINE DELETED HERE "22D"
	XW0.0	(FET)		;ZERO RUNG ;"26A"
	SMK	(SUBEM)		;SUB-EXPRESSION ;"26A"
	XW0.3T	(ZER)		;CLEAR SUB-EXPRESSION STATUS ;"26A"
	POW	(D1)		;PRUNE 1 ;"26A"
	XW0.0	(NOZ)		;ZERO RUNG "22D"
	BRI	(.MEI0)	;SETZ INST "22D"
	W0	(DIM)		;W0
	XIT	(EXIML)	;EXIT
DRLGEN:					;DOUBLE REG LOAD GEN
	SMK	(PLUEM)	;PLUS EM
	SMKF	(DPNEM)	;DOUBLE PREC NEG EM
	BTKT	(.ME0)	;MOVE INST
	BTKF	(.MN0)	;MOVN INST
	SME	(DPNEM)	;DOUBLE PREC NEG EM
	IORT	(MINMAS)	;MINUS MASK
	XIT	(EXIML)	;EXIT
SRLGEN:					;SINGLE REG LOAD GEN
	SMK	(NOTEM)	;NOT EM
	JMPT	(SRLGE1)	;$1
	SMK	(MINEM)	;MINUS EM
	BINT	(.MN0)	;MOVN INST
	BINF	(.ME0)	;MOVE INST
	XIT	(EXIML)	;EXIT
SRLGE1:
	SMK	(MINEM)	;MINUS EM
	BIKT	(.MN0)	;MOVN INST
	W1T	(CLA)		;W1
	BINT	(.SEA0)	;SETCA INST
	BINF	(.SEM0)	;SETCM INST
	XIT	(EXIML)	;EXIT
DHRLGE:		;DOUBLE HOLL. REG. LOAD GEN.; "26P"
	W1	(FET)		;COPY REG. POINTER;"26P"
	W1	(FET)		;COPY HOLLERITH CONST. POINTER;"26P"
	EOR	(HTYEM)	;GET RID OF HOLLERITH TYPE EM;"26P"
	IER	(DITEM)	;AND FAKE DOUBLE ITEM; "26P"
	BTY	(.ME0)		;GENERATE MOVE INSTS.;"26P"
	POW	(D2)		;AND GET RID OF EXTRA POINTERS;"26P"
	XIT	(EXIML)		;AND EXIT;"26P"
GR0AGE:					;GRNTEE REG 0 AVAIL GEN
	FET	(RZEPNT)	;REG ZERO PNTR
	IER	(ETYEM)	;EXP TYPE EM
	XW0.0	(FET)		;[360] FETCH POINTER TO WHAT'S IN R0
	SME	(DITEM)		;[27K]  DOUBLE ITEM?
	JMPF	(GAVGE1)	;NO "25-8"
	JMP	(GABTG1)	;YES DO DOUBLE STORE IN TEMP "25-8"
GABTGE:					;GRNTEE AVAILABLE BY TYPE GEN
	SPK	(DITEM)		;DOES REG CONTAIN A DOUBLE ITEM?
	JMPF	(GAVGE1)	;$1
GABTG1:			;"25-8"
	JSB	(RMOTES)	;REG MOVE TEST
	XITF	(EXIML)	;EXIT
	STK	(REGTEM)	;REG TEMP
	XW0.0	(FET)		;"23AA"
	AND	(TYPMAS)	;"23AA"
	W1	(IOM)		;"23AA"
	JSB	(DSITGE)	;DOUBLE STORE IN TEMP GEN
	JMP	(GAVGE2)	;$2
RBTASS:					;REG BY TYPE ASSIGN
	XML	(REGSML)	;REG SEARCH
	JMP	(GABTGE)	;GRNTEE AVAILABLE BY TYPE GEN
GAVGEN:					;GRNTEE AVAILABLE GEN
	JSB	(RMOTES)	;REG MOVE TEST
	XITF	(EXIML)	;EXIT
	STK	(REGTEM)	;REG TEMP
	JSB	(SITGEN)	;STORE IN TEMP GEN
GAVGE2:
	CLA	(REGTEM)	;REG TEMP
	XIT	(EXIML)	;EXIT
GAVGE1:
	JSB	(GAVGEN)	;GRNTEE AVAILABLE GEN
	SMK	(DITEM)	;DOUBLE ITEM EM
	XITF	(EXIML)	;EXIT
	W0	(FET)		;W0
	W0	(TLY)		;W0
	IER	(ITYEM)	;INTEGER TYPE EM
	JSB	(SRITGE)	;SAVE REG IN TEMP GEN
	XML	(P1EML)	;PRUNE ONE EXIT
RSATES:					;REG SAVE TEST
	XW0.0	(FET)		;ZERO RUNG
RSATE1:
	SMK	(SUBEM)	;SUBEXP EM
	XW0.4T	(SNZ)		;USE CNT RUNG
	XMLT	(P1ETML)	;PRUNE ONE EXIT TRUE
	XML	(P1EFML)	;PRUNE ONE EXIT FALSE
SRITGE:					;SAVE REG IN TEMP GEN
	JSB	(RSATES)	;REG SAVE TEST
	JMPT	(GABTGE)	;GRNTEE AVAILABLE BY TYPE GEN
	XIT	(EXIML)	;EXIT

RMOTES:					;REG MOVE TEST
	XW0.0	(SNZ)		;ZERO RUNG
	XITF	(EFAML)	;EXIT FALSE ;"21D"
	SPK	(RHOEM)	;RIGHT HALF ONES EM
	SPKF	(TEMEM)	;TEMP EM
	JMPT	(EXIFAL)	;EXIT FALSE
	XML	(ETRML)	;EXIT TRUE
SITGEN:					;STORE IN TEMP GEN
	JSB	(TEMMAK)	;TEMP MAKER
	SON	(MINEM)	;MINUS EM
	BIKT	(.MNM0)	;MOVNM INST
	BIKF	(.MEM0)	;MOVEM INST
NRSNOT:					;NEW REG STATUS NOTE
	XW1.0	(FET)		;ZERO RUNG
	W0	(FET)		;W0
	AND	(TYPMAS)	;TYPE MASK
	W2	(IOM)		;W2
	W2	(FET)		;GET REG POINTER
	AND	(SIGMAS)	;ISOLATE SIGN
	W2	(EOM)		;COMBINE W/ SIGN OF TEMP. PNTR
	SMK	(SUBEM)	;SUBEXP EM
	XW0.3T	(FET)		;STATUS PNTR RUNG
	ANDT	(SIGMAS)	;SIGN MASK
	W2T	(EOR)		;W2
	XW1.3T	(STO)		;STATUS PNTR RUNG
	POW	(D1)		;ONE
	XW1.0	(STK)		;TEMP PNTR TO REG ROLL
	XML	(TSAML)	;TEMP STATUS ADVANCE
	W1	(SWT)		;W1
	IPK	(ITETRA)
	XML	(P1EML)	;PRUNE ONE EXIT
RSTADV:					;REG STATUS ADVANCE
	SON	(DITEM)	;DOUBLE ITEM EM
	XW1.0	(STK)		;ZERO RUNG
	IORT	(APOMAS)	;ADR PLUS ONE MASK
	XW1.1T	(STK)		;ONE RUNG
	XML	(P1EML)	;PRUNE ONE EXIT
DSITGE:					;DOUBLE STORE IN TEMP GEN
	JSB	(DTEMAK)	;DOUBLE TEMP MAKER
	JSB	(DSTGEN)	;DOUBLE STORE GEN
DSITGF:					;DOUBLE STORE IN TEMP GEN FIN
	W1	(FET)		;W1
	W0	(TLY)		;W0
	W1	(FET)		;W1
	W0	(TLY)		;W0
	JSB	(NRSNOT)	;NEW REG STATUS NOTE
	POW	(D1)		;ONE
	JMP	(NRSNOT)	;NEW REG STATUS NOTE
DSTGEN:					;DOUBLE STORE GEN
	SON	(CTYEM)	;COMPLEX TYPE EM
	SONT	(MINEM)	;MINUS EM
	BTKT	(.MNM0)	;MOVNM INST
	BTKF	(.MEM0)	;MOVEM INST
	SON	(DPNEM)	;DOUBLE PREC NEG EM
	EORT	(MINMAS)	;MINUS MASK
	XIT	(EXIML)	;EXIT

SATREG:						;SAVE THIRD REGISTER
;13 LINES DELETED "26-7"
;	SMK	(DPTEM)	;DOUBLE PRECISION ?
;	XITF	(EXIML)	;NO, RETURN
;	STK	(PINATO)	;SAVE FOR TEST
;	W1	(FET)		;YES,GET REGISTER TO BE USED
;	ADD	(TWO)		;POINT TO THIRD REGISTER
;	IER	(PLUEM)		;INSURE POSITIVE REG PNTR "22E"
;	SMK	(PINEM)		;ADDRESS & REG TO BE SAVED THE SAME ?
;	IER	(PLUEM)		;MAKE SURE IT'S POSITIVE ;"21S"
;	JSB	(GABTGE)	;SAVE THIS REGISTER
;	W1T	(SWT)		;YES, DON'T USE TEMP POINTER
;	ANDT	(SANMAS)	;TRANSFER SIGN AND .NOT. FLAGS
;	W1T	(IOM)
;	POWF	(D1)		;REMOVE EXTRA REG POINTER
	XIT	(EXIML)		;RETURN
MPOGEN:					;MOVEM POSITIVE GEN
	SON	(DPNEM)	;DOUBLE PREC NEG EM
	JSBT	(DPNSGE)	;DOUBLE PREC NEG STORE GEN
	XMLT	(P1EML)	;PRUNE ONE EXIT
	SON	(MINEM)	;MINUS EM
	BTYT	(.MNM0)	;MOVNM INST
	BTYF	(.MEM0)	;MOVEM INST
	XIT	(EXIML)		;EXIT
DPNSGE:				;DOUBLE PREC NEG STORE GEN
	FET	(PDPSW)		;TEST MACHINE TYPE ;"25-1"
	SLT	(ZERO)		;"25-1"
	JMPT	(DPNSG1)	;A PDP-10 !
	SNZ	(PDPSW)		;SET TRUE FOR A KI10 ;"25-1"
	BIKT	(.DMVNM)	;DMOVNM ;"25-1"
	JMPT	(DPNSG2)	;"25-1"
	BTK	(.MNM0)		;MOVNM INST
	W1	(FET)		;W1
	FET	(ABSCPN)	;ALL BUT SIGN CONST PNTR
	W1	(TLY)		;W1
	BIN	(.TDNE0)	;TDNE INST
	POW	(D1)		;ONE
	BAK	(.SOS0)	;SOS INST
	JMP	(DPNSG2)	;"25-1"

DPNSG1:
	W1	(FET)
	W0	(FET)
	W0	(TLY)
	BIN	(.DFN0)	;DFN INST
	POW	(D1)
	BTK	(.MEM0)	;MOVEM INST
DPNSG2:
	FET	(MINMAS)
	W2	(EOM)
	XW1.0	(FET)
	SMK	(SUBEM)
	FETT	(MINMAS)
	XW1.3T	(EOM)
	POW	(D1)

	XIT	(EXIML)
DTEMAK:					;DOUBLE TEMP MAKER
	JSB	(TEMMAK)	;TEMP MAKER
	W1	(FET)
	AND	(TYPMAS)
	W1	(IOM)
	JSB	(TEMMAK)	;TEMP MAKER
	XML	(P1EML)	;PRUNE ONE EXIT
TEMMAK:					;TEMP MAKER

	TLY	(LTEPNT)	;LOCAL TEMP PNTR
	FET	(LTEPNT)	;LOCAL TEMP PNTR
	SGK	(LATPNT)	;LAST ASSIGNED TEMP PNTR
	STKT	(LATPNT)	;LAST ASSIGNED TEMP PNTR
	XIT	(EXIML)	;EXIT
PTEMAK:					;PERM TEMP MAKER
	TLY	(TEMCNT)	;TEMP CNT
	FET	(TEMCNT)	;TEMP CNT
	IER	(PTEEM)	;PERM TEMP EM
	IER	(DMYEM)	;DMY EM
	XIT	(EXIML)	;EXIT

VARSCA:					;VAR SCAN
	JSB	(IDSCAN)	;ID SCAN
	JSBF	(REGSCA)	;REGISTER SCALAR
	SMK	(SCAEM)	;SCALAR EM
	XITT	(EXIML)	;EXIT
	SMK	(ARREM)	;ARRAY ID EM
	LCFF	(I12QT)	;ID CONFLICT QT
	CSA	(LPAREN)	;L PAREN
	JMPT	(AREXLA)	;ARRAY REF XLATE
	LCFF	(S14QT)	;SYNTAX QT
	XIT	(EXIML)	;EXIT
IVASCA:					;INDUC VAR SCAN
	JSB	(IDSCAN)	;ID SCAN
	JSBF	(REGSCA)	;REGISTER SCALAR
IVSFIN:					;INDUC VAR SCAN FIN
	SMK	(ITYEM)	;INTEGER TYPE EM
	LCFF	(S18QT)	;TYPE QT ;"21T"
	SMK	(SCAEM)	;SCALAR EM
	LCFF	(I14QT)	;ID CONFLICT QT
	XIT	(EXIML)	;EXIT
IDSCAN:					;ID SCAN
	SNZ	(OPNDEF)	;[27M]IS IT AN OPEN?
	SNZF	(CLODEF)	;[27M]OR A CLOSE?
	JSBF	(SYMSCA)	;[27M]NO
	JMPF	(IDCLAS)	;[27M]SO DO AS NORMAL
	SNZ	(OPNDEF)	;[27M]IS IT OPEN?
	XMLT	(REGOML)	;[27M]YES, REGISTER 'OPEN'
	XMLF	(REGCML)	;[27M]NO, REGISTER 'CLOSE'
IDCLAS:					;ID CLASSIFY
	ISE	(LDMFIL)	;LOCAL DMY FILE
	ISEF	(GSPFIL)	;GLOBAL SPROG FILE
	ISEF	(SCAFIL)	;SCALAR FILE
	ISEF	(ARRFIL)	;ARRAY FILE
	ISEF	(LSPFIL)	;LOCAL SPROG FILE
	JMPF	(EXIFAL)	;EXIT FALSE
	FPC	(CREPNT)	;CRRNT REG PNTR
	JSB	(TYPSET)	;TYPE SET
	XML	(ETRML)	;EXIT TRUE
TYPSET:					;TYPE SET
	JSB	(TYPEVA)	;TYPE EVAL
	XITT	(EXIML)	;EXIT
	XML	(ICFSML)	;IMPLICIT CLUE FROM SYMBOL SET

IFNDEF	$IMPL,
<
	ISE	(IMPFIL)	;IMPLICIT FILE
	XNIT	(CREPNT)	;CRRNT REG PNTR
	FETT	(ZERRUN)	;ZERO RUNG
	JMPT	(ITYSE1)	;$1
>
	FET	(IMPCLU)	;IMPLICIT CLUE
	SGK	(MAXSYM)	;MAX INTEGER SYMBOL
	SLKF	(MINSYM)	;MIN INTEGER SYMBOL
	CLAT	(RTYSTA)	;REAL TYPE ATOM
	CLAF	(ITYSTA)	;INTEGER TYPE ATOM
ITYSE1:
	SMK	(SINEM)	;SUBSCRIPT INTEGER EM
	IERT	(ITYEM)	;INTEGER TYPE EM
	REGT	(SIIFIL)	;SUBSCRIPT INTEGER ID FILE
	STO	(ETYATO)	;EXP TYPE ATOM
	IER	(ETYEM)	;EXP TYPE EM
	XIT	(EXIML)	;EXIT
STYEVA:					;SYMBOL TYPE EVAL
	JSB	(SYMSCA)	;SYMBOL SCAN
TYPEVA:					;TYPE EVAL
	ISE	(CIDFIL)	;COMPLEX ID FILE
	IERT	(CTYEM)	;COMPLEX TYPE EM
	XMLT	(ETRML)	;EXIT TRUE
	ISE	(DPIFIL)	;DOUBLE PREC ID FILE
	IERT	(DPTEM)	;DOUBLE PREC TYPE EM
	XMLT	(ETRML)	;EXIT TRUE
	ISE	(RIDFIL)	;REAL ID FILE
	IERT	(RTYEM)	;REAL TYPE EM
	XMLT	(ETRML)	;EXIT TRUE
	ISE	(LIDFIL)	;LOGICAL ID FILE
	IERT	(LTYEM)	;LOGICAL TYPE EM
	XMLT	(ETRML)	;EXIT TRUE
	ISE	(IIDFIL)	;INTEGER ID FILE
	IERT	(ITYEM)	;INTEGER TYPE EM
	XIT	(EXEQML)	;EXIT EQUAL ML
CONSCA:					;CONST SCAN
	JSB	(CONANA)	;CONST ANALYSIS
	SMK	(RTYEM)	;REAL TYPE EM
	JMPF	(DCAREG)	;DP CHECK AND REGISTER
RFLCON:					;REGISTER FL CONST
	REG	(RCOFIL)	;REAL CONST FILE
	JMP	(CREEXI)	;CONST REGISTER EXIT
DCAREG:					;DP CHECK AND REGISTER
	SMK	(DPTEM)	;DOUBLE PREC TYPE EM
	JMPF	(CCAREG)	;CPLX CHECK AND REGISTER
RDPCON:					;REGISTER DP CONST
	REG	(DPCFIL)	;DOUBLE PREC CONST FILE
	JMP	(CREEXI)	;CONST REGISTER EXIT
CCAREG:					;CPLX CHECK AND REGISTER
	SMK	(CTYEM)	;COMPLEX TYPE EM
	JMPF	(ICAREG)	;INT CHECK AND REGISTER
RCOCON:					;REGISTER COMPLEX CONST
	REG	(CCOFIL)	;COMPLEX CONST FILE
	JMP	(CREEXI)	;CONST REGISTER EXIT
ICAREG:					;INT CHECK AND REGISTER
	SMK	(ITYEM)	;INTEGER TYPE EM
	JMPF	(LCAREG)	;LOG CHECK AND REGISTER
RINCON:					;REGISTER INT CONST
	REG	(ICOFIL)	;INTEGER CONST FILE
	JMP	(CREEXI)	;CONST REGISTER EXIT
LCAREG:					;LOG CHECK AND REGISTER
	SMK	(LTYEM)	;LOGICAL TYPE EM
	JMPT	(FEREXI)	;FIRST ELEM RESET EXIT
HCAREG:					;HOLLERITH CHECK AND REGISTER
	SMK	(HTYEM)		;HOLLERITH TYPE EM
	JMPF	(OCAREG)
	SNZ	(SARFLA)
	FETT	(ZERO)		;GET USER END FLAG
	MONT	(CTEROL)	;STORE AT END OF STRING
	EAW	(CTEROL)	;CONST TEMP ROLL
	RPL	(HCOROL)	;HOL CONST ROLL
	REL	(CTEROL)
	W1	(IOM)		;W1
	JMP	(FEREXI)	;FIRST ELEM RESET EXIT
OCAREG:					;OCTAL CHECK AND REGISTER
	REG	(OCOFIL)	;OCT CONST FILE
CREEXI:					;CONST REGISTER EXIT
	FET	(CREPNT)	;GET REG PNTR
	AND	(RHAMAS)	;CLEAR UPPER
	W1	(IOM)		;SET POINTER IN W1
	JMP	(FEREXI)	;FIRST ELEM RESET EXIT
RWOCON:					;REGISTER WORK CONST
	STO	(DAT1)	;DATA 1
	REG	(ICOFIL)	;INTEGER CONST FILE
	FET	(CREPNT)
	XIT	(EXIML)	;EXIT
REGSCA:					;REGISTER SCALAR
	PNG	(SCAROL)	;SCALAR ROLL
	AGF	(SCAFIL)	;SCALAR FILE
SETPOS:					;SET POSITION
	W0	(FPC)		;W0
	W1	(STO)		;W1
	JMP	(TYPSET)	;TYPE SET
RGLSPR:					;REGISTER GLOBAL SPROG
	ISE	(CDAFIL)	;COMMON DATA FILE
	FPCT	(ZERO)	;ZERO
	ERMT	(I16QT)		;CONFLICT W/ COMMON DECLARATION	;"23A"
	XITT	(FAIML)		;FATAL ERROR	;"23A"
	PNGF	(GSPROL)	;GLOBAL SPROG ROLL
	AGFF	(GSPFIL)	;GLOBAL SPROG FILE
	JMP	(SETPOS)	;SET POSITION
CONANA:					;CONST ANALYSIS
	JSB	(DCOINI)	;DIGIT CONV INITIAL
	SCK	(DIGKEY)	;DIGIT KEY
	JMPT	(NOHCSC)	;NUM OR HOL CONST SCAN
	CSA	(PERIOD)	;PERIOD
	JMPT	(RDOLCS)	;REAL DBL OR LOG CONST SCAN
	CSA	(LPAREN)	;L PAREN
	JMPT	(CCOSCA)	;COMPLEX CONST SCAN
	SCE	(SNGLQT)	;QT
	JMPT	(EHCSCA)	;ENCLOSED HOL CONST SCAN
OCOSCA:					;OCTAL CONST SCAN
	CSA	(O)
	CSFF	(DBLQT)	;DBL QT
ODISCA:					;OCTAL DIGIT SCAN
	FET	(OTYSTA)	;OCTAL TYPE STAMP
	CSA	(MINUS)	;MINUS
	IERT	(MINEM)	;MINUS EM
	CSAF	(PLUS)	;PLUS
	SCK	(DIGKEY)
	CCFF	(S11QT)
	JSB	(COCNPL)
	W0	(FPC)
	W1	(STO)
	JMP	(CSIEX1)	;CONST SINGLE EXIT
NOHCSC:					;NUM OR HOL CONST SCAN
	JSB	(DICOSC)	;DIGIT CONV SCAN
	SCE	(H)		;H
	JMPT	(HCOSCA)	;HOL CONST SCAN
	SCK	(DOEKEY)	;D OR E
	JMPT	(RODCSF)	;REAL OR DBL CONST SCAN FIN
	JSB	(LAPSAV)	;LOOK AHEAD POSITION SAVE
	SCE	(PERIOD)	;PERIOD
	JSBT	(OPCHEC)	;OP CHECK
	CSFT	(PERIOD)	;PERIOD
	JMPT	(RODCSF)	;REAL OR DBL CONST SCAN FIN
	JSB	(LAPRES)	;LOOK AHEAD POSITION RESET
	FET	(ITYSTA)	;INTEGER TYPE STAMP
CSIEXI:					;CONST SINGLE EXIT
	W0	(FPC)		;W0
	SNZ	(MAC1)	;MP AC 1
	ERKT	(M3QT)	;CONST OVFLO QT
	W1	(STO)		;W1
	FET	(MAC2)	;MP AC 2
	STO	(DAT1)	;DATA 1
CSIEX1:
	ZER	(DAT2)	;DATA 2
	XML	(ETRML)	;EXIT TRUE
RDOLCS:					;REAL DBL OR LOG CONST SCAN
	SCK	(DIGKEY)	;DIGIT KEY
	JMPF	(LCOSCA)	;LOG CONST SCAN
RODCSF:					;REAL OR DBL CONST SCAN FIN
	FET	(NDISCA)	;NUM DIGITS SCANNED
	STO	(NUNPOS)	;NUM UNIT POSITIONS
	SCK	(DIGKEY)	;DIGIT KEY
	JSBT	(DICOSC)	;DIGIT CONV SCAN
	FET	(NUNPOS)	;NUM UNIT POSITIONS
	SUB	(DUSCNT)	;DIGITS USED CNT
	STK	(EXPONE)	;EXPONENT
	SLT	(ZERO)	;ZERO
	FTM	(EXPA)	;EXPONENT A
	CSA	(D)		;D
	JMPT	(RODCS1)	;$1
	CSA	(E)		;E
	JMPF	(RODCS2)	;$2
	SNZ	(ZERO)	;ZERO
RODCS1:
	PST	(CONTEM)	;CONST TEMP
	JSB	(SINSCA)	;SIGNED INTEGER SCAN
	PAD	(EXPA)	;EXPONENT A
	PST	(EXPA)	;EXPONENT A
	PLD	(CONTEM)	;CONST TEMP
RODCS2:
	XML	(FCMML)	;FL CONST MAKER
	FETT	(DPTSTA)	;DOUBLE PREC TYPE STAMP
	FETF	(RTYSTA)	;REAL TYPE STAMP
	W0	(FPC)		;W0
	W1	(STO)		;W1
	PST	(DAT1)	;DATA 1
	FET	(EXPONE)	;EXPONENT
	SGT	(MAXEXP)	;MAX EXPONENT
	ERKT	(M3QT)	;CONST OVFLO QT
	XML	(ETRML)	;EXIT TRUE
LCOSCA:					;LOG CONST SCAN
	QSA	(NOTQT)	;NOT.. QT
	JMPT	(LCOSC1)	;$1
	QSA	(TRUQT)	;TRUE. QT
	QSFF	(FALQT)	;FALSE. QT
	FETT	(TCOPNT)
	FETF	(FCNPNT)	;FALSE CONST PNTR
	FTM	(DAT1)	;DATA 1
	IER	(LTYEM)	;LOGICAL TYPE EM
	JMP	(EXIFAL)	;EXIT FALSE
LCOSC1:	JSB	(LCOSCA)	;LOG CONST SCAN
	EOR	(LCIMAS)	;LOG CONST INVERT MASK
	NOT	(DAT1)	;DATA 1
	JMP	(EXIFAL)	;EXIT FALSE
CCOSCA:					;COMPLEX CONST SCAN
	JSB	(SCOSCA)	;SIGNED CONST SCAN
	LCFF	(S23QT)		;SYNTAX QT	;"23N"
CCSFIN:					;COMPLEX CONST SCAN FIN
	JSB	(CTOFL)	;CONVERT TO FL
	CSF	(COMMA)	;COMMA
	JSB	(SCOSCA)	;SIGNED CONST SCAN
	LCFF	(S1QT)	;SYNTAX QT
	JSB	(CTOFL)	;CONVERT TO FL
	CSF	(RPAREN)	;R PAREN
	STO	(DAT2)	;DATA 2
	STO	(DAT1)	;DATA 1
	FPC	(CTYSTA)	;COMPLEX TYPE STAMP
	JMP	(EXIFAL)	;EXIT FALSE
SCOSCA:					;SIGNED CONST SCAN
	CSA	(MINUS)	;MINUS
	JMPF	(SCOSC1)	;$1
	JSB	(CONANA)	;CONST ANALYSIS
	NOT	(DAT1)	;DATA 1
	TLY	(DAT1)	;DATA 1
	XIT	(EXEQML)	;EXIT EQUAL ML
SCOSC1:
	CSA	(PLUS)	;PLUS
	JMP	(CONANA)	;CONST ANALYSIS
CTOFL:					;CONVERT TO FL
	SMK	(ITYEM)	;INTEGER TYPE EM
	FET	(DAT1)	;DATA 1
	JMP	(CCAASI)	;CONVERT CONST AND ADJUST SIGN
DCOINI:					;DIGIT CONV INITIAL
	EAW	(D10)		;TEN
	STO	(CBABOX)	;CONST BASE BOX
	PLD	(MPZERO)	;MP ZERO
	PST	(EXPA)	;EXPONENT A
	ZER	(NDISCA)	;NUM DIGITS SCANNED
	ZER	(NUNPOS)	;NUM UNIT POSITIONS
	ZER	(DUSCNT)	;CLEAR DIGITS USED CNT
	XIT	(EXIML)	;EXIT
DICOSC:					;DIGIT CONV SCAN
	SCK	(DIGKEY)	;DIGIT KEY
	CCFF	(S11QT)	;SYNTAX QT
	XIT	(CDAAML)	;CONV DIGIT AND ADV
EHCSCA:					;ENCLOSED HOL CONST SCAN
	RSV	(CTEROL)	;CONST TEMP ROLL
	JSB	(PHCSET)
EHCSC1:
	JSB	(NINCHA)
	SCE	(SNGLQT)
	JMPT	(EHCSC3)
EHCSC2:
	JSB	(PHCTST)
	JMP	(EHCSC1)

EHCSC3:
	JSB	(NINCHA)
	SCE	(SNGLQT)
	JMPT	(EHCSC2)
	SCE	(SPACE)
	SCEF	(TAB)		;TAB MUST BE HANDLED LIKE SPACE; "26Q"
	JSBT	(NEXCHA)
	JMP	(HCOSC3)

HCOSCA:					;HOL CONST SCAN
	SNZ	(MAC1)	;MP AC 1
	FETF	(MAC2)	;MP AC 2
	SGKF	(MHOCNT)	;MAX HOL CNT
	LCFT	(ECOQT)	;EXCESSIVE COUNT QT
	RSV	(CTEROL)	;CONST TEMP ROLL
	JSB	(PHCSET)

HCOSC1:
	JOW	(HCOSC2)	;$2
	JSB	(NINCHA)
	JSB	(PHCTST)
	JMP	(HCOSC1)	;$1

HCOSC2:
	JSB	(NEXCHA)
HCOSC3:
	FET	(HTYSTA)	;HOLLERITH TYPE STAMP

PHCEND:
	FET	(HBUIND)
	SEQ	(HBUINI)
	JSBF	(PHCMON)
	CNT	(CTEROL)	;COUNT # OF WORDS USED ;"21M"
	SEQ	(ZERO)		;NONE USED ? ;"21M"
	LCFT	(M7QT)		;YES, ITS ILLEGAL ;"21M"
	JMP	(EXIFAL)

PHCTST:
	SCE	(CRR)
	LCFT	(M7QT)
PHCHAR:
	XML	(PHCML)
	XITT	(EXIML)
PHCMON:
	FET	(HOLBUF)
	MON	(CTEROL)
PHCSET:
	FET	(HBUINI)
	STO	(HBUIND)
	FET	(ASCIBL)
	STO	(HOLBUF)
	XIT	(EXIML)
SISUSC:					;SIGNED SUBSCRIPT SCAN

	JSB	(SINSCA)	;SIGNED INTEGER SCAN
	FET	(DAT2)	;DATA 2
	XIT	(EXIML)	;EXIT
SINSCA:					;SIGNED INTEGER SCAN
	CSA	(MINUS)	;MINUS
	JMPF	(SINSC1)	;$1
	JSB	(INTSCA)	;INTEGER SCAN
	FET	(ZERO)	;ZERO
	SNZ	(DAT2)	;DATA 2
	NOTT	(DAT1)	;DATA 1
	SUB	(DAT2)	;DATA 2
	STO	(DAT2)	;DATA 2
	XIT	(EXIML)	;EXIT
SINSC1:
	CSA	(PLUS)	;PLUS
INTSCA:					;INTEGER SCAN
	ZER	(NDISCA)	;NUM DIGITS SCANNED
	PLD	(MPZERO)	;MP ZERO
	JSB	(DICOSC)	;DIGIT CONV SCAN
	SNZ	(CON1)	;CONST 1
	LCET	(M3QT)	;OVERFLOW QT
	XIT	(EXIML)	;EXIT
FESACO:					;FX EXP SCAN AND COLLAPSE
	JSB	(EXPSCA)	;EXP SCAN
	SMK	(ITYEM)	;INTEGER TYPE EM
	JMPF	(SUBFAI)	;SUBEXP FAIL
	JMP	(SUBCOL)	;SUBEXP COLLAPSE

LBLSCA:					;LBL SCAN
	JSB	(DCOINI)	;DIGIT CONV INITIALIZE
	JSB	(INTSCA)	;INTEGER SCAN
	FET	(DAT2)	;DATA 2
	SGK	(MLBALL)	;MAX LBL ALLOWED
	LCFT	(M6QT)	;NUMBER QT
	W0	(SNZ)		;W0
	LCFF	(M6QT)	;NUMBER QT
	POW	(D1)		;PRUNE LABEL NUMBER
	REG	(LBLFIL)	;LABEL FILE
	FPC	(CREPNT)	;CRRNT REG PNTR
	SNZ	(ENDFLG)	;"25-9" CHECK FOR END= OR ERR=
	JMPT	(LBLSC2)	;"25-9"
	SMK	(SLPEM)		;"23-AP"
	CCFT	(M19QT)		;"23-AP"
LBLSC2:			;"25-9"
IFNDEF	$CREF,
<
	SNZ	(CRFSW)
	FETT	(DAT2)
	XMLT	(BTBCML)
	MONT	(CRFROL)
>
	XIT	(EXIML)	;EXIT

LBLMAK:					;LBL MAKER
	TLY	(MLBCNT)	;MADE LBL CNT
	FET	(MLBCNT)	;MADE LBL CNT
	IER	(MLBEM)	;MADE LBL EM
	XIT	(EXIML)	;EXIT
FINUP:					;FINISH UP

IFNDEF	FILE0,
<
	SNZ	(PROGN)	;NON-TRIVIAL PROGRAM FLAG
	XITF	(POPJML)	;EXIT TO EXEC
>
	JSB	(SCACLO)
	JSB	(OUTCOD)

IFNDEF	$NAME,
<
	JSB	(NAMGEN)	;NAMELIST GEN
>
	REL	(ASTROL)	;ARRAY STAT ROLL
	ZER	(MACSW)	;ONLY SUPRESS CODE
	POC	(EOPLOP)	;END OF PROGRAM LOP
	FET	(MSTLOC)	;MAIN START LOC
	MON	(CODROL)	;CODE ROLL
	FET	(TEMCNT)	;TEMP CNT
	W0	(FET)		;W0
	FET	(LATPNT)	;LAST ASSIGNED TEMP POINTER
	AND	(DISMAS)	;DISPLAY MASK
	W0	(SWH)		;W0
	W1	(IOM)		;W1
	MON	(CODROL)	;CODE ROLL
	JSB	(PDASTA)	;PUNCH DATA STA
	JSB	(OCOPOO)	;OUTPUT CONST POOL
	ADD	(LATPNT)	;LAST ASSIGNED TEMP PNTR
	AND	(DISMAS)	;DISPL MASK
	AMY	(LOCCNT)	;LOC CNTR
	JSB	(COMALL)	;COMMON ALLOCATION
	JSB	(ALLOEQ)	;ALLOC EQUIV
	JSB	(PGAROL)	;PUBLISH GENERAL ALLOC ROLL
	JSB	(OGSROL)	;OUTPUT GLOBAL SPROG ROLL
	JSB	(AAPSAA)	;ALLOCATE AND PUBLISH SCALARS AND ARRAY
	FET	(LOCCNT)	;LOC CNTR
	SUB	(PROBRE)	;PROGRAM BREAK
	JSB	(OOAREF)	;OUTPUT OBJECT ARRAY REF
	MON	(CODROL)	;CODE ROLL
	JSB	(OCOARE)	;OUTPUT COMMON AREA
	NOZ	(ERRFLA)	;ERRORS FLAG
	JSB	(PDLERR)	;PUBLISH DO LOOP ERRORS
	JSB	(PLBERR)	;PUBLISH LBL ERRORS
	JSB	(PALERR)	;PUBLISH ALLOCATION ERROR
	XIT	(POPJML)	;EXIT TO EXEC
OCOPOO:					;OUTPUT CONST POOL
	REL	(ICOROL)	;INTEGER CONST ROLL
	REL	(FCOROL)	;FLOATING CONST ROLL
	REL	(OCOROL)	;OCT CONST ROLL
	REL	(HCOROL)	;HOLLERITH CONST ROLL
	REL	(DPCROL)	;DOUBLE PREC CONST ROLL
	REL	(CCOROL)	;COMPLEX CONST ROLL
	CNT	(CPOROL)	;CONST POOL ROLL
	W0	(FET)		;W0
	ADD	(LOCCNT)	;LOC CNTR
	ADD	(ONE)		;ONE
	STK	(LOCCNT)	;LOC CNTR
	STO	(PROBRE)	;PROGRAM BREAK
	MON	(CODROL)	;CODE ROLL
	SRD	(CPOROL)	;CONST POOL ROLL
	PRQT	(CONSQT)	;CR CONST DCR QT
	ZER	(COPRCT)	;CONST PRINT COUNT
	FLP	(CPOROL)	;CONST POOL ROLL
OCOPO1:					;$1
	MOA	(CPOROL)	;CONST POOL ROLL
	JSBF	(COLEND)	;FINISH LINE
	JMPF	(PDASTA)	;PUNCH DATA STATEMENT
	W0	(FET)		;W0
	FET	(COPRCT)	;CONST PRINT COUNT
	JSB	(POCLOC)	;PRINT OCTAL LOCATION
	TLY	(COPRCT)	;CONST PRINT COUNT
	PRC	(TAB)		;OP FIELD POSITION
	JSB	(PW0OCT)	;PRINT W0 OCTAL
	PCOL	(ZERO)	;PRINT COLUMNS
	MON	(CODROL)	;CODE ROLL
	JMP	(OCOPO1)	;$1
COMALL:					;COMMON ALLOCATION
	FLP	(CDAROL)	;COMMON DATA ROLL
	FLP	(CNAROL)	;COMMON NAMES ROLL
COMAL1:
	MOA	(CNAROL)	;COMMON NAMES ROLL
	XITF	(EXIML)	;EXIT
	STO	(CANCLU)	;COMMON AREA NAME CLUE
	REG	(CANFIL)	;COMMON AREA NAME FILE
	JSB	(ATCARE)	;ADD TO COMMON AREA
	JMP	(COMAL1)	;$1
ATCARE:					;ADD TO COMMON AREA
	MOA	(CDAROL)	;COMMON DATA ROLL
	SEK	(ZERO)	;MARKER SYMBOL
	XMLT	(P1EML)	;PRUNE ONE EXIT
	JSB	(CSACLA)	;CALC SIZE AND CLASSIFY
	XNI	(CARPNT)	;COMMON AREA PNTR
	SWT	(CASRUN)	;COMMON AREA SIZE RUNG
	W0	(FET)		;W0
	XNI	(CARPNT)	;COMMON AREA PNTR
	AMY	(CASRUN)	;COMMON AREA SIZE RUNG
	FET	(CARPNT)	;COMMON AREA PNTR
	AND	(DISMAS)	;DISPL MASK
	W0	(SWH)		;W0
	W1	(IOM)		;W1
	STO	(DAT1)	;DATA 1
	PNG	(GALROL)	;GENERAL ALLOC ROLL
	IER	(APNEM)	;ALLOC PNTR EM
	AGF	(GALFIL)	;GENERAL ALLOC FILE
	JSB	(IDCLAS)	;ID CLASSIFY
	W1	(SWT)		;W1
	XW1.0	(STO)		;ZERO RUNG
	POW	(D2)		;TWO
	JMP	(ATCARE)	;ADD TO COMMON AREA
CSACLA:					;CALC SIZE AND CLASSIFY
	STO	(SYMBOL)	;SYMBOL
CSACFI:					;CALC SIZE AND CLASSIFY FIN
	ISE	(GANFIL)	;GENERAL ALLOC NAME FILE
	FETT	(CREPNT)	;CRRNT REG PNTR
	IERT	(ENPEM)	;EQUIV NAME PNTR EM
	FET	(ZERO)	;ZERO
	JSB	(TYPSET)	;TYPE SET
	W1T	(SWT)		;W1
	STOT	(SYMBOL)	;SYMBOL
	JSB	(IDCLAS)	;ID CLASSIFY
	JSBF	(REGSCA)	;REGISTER SCALAR
	AND	(RHAMAS)	;RIGHT HALF MASK
	W1	(IOM)		;W1
	SMK	(ARREM)	;ARRAY ID EM
	XW0.2T	(FET)		;ARRAY SIZE RUNG
	FETF	(ONE)		;ONE
	SON	(DITEM)	;DOUBLE ITEM EM
	W1	(SWT)		;W1
	CLA	(SYMBOL)	;SYMBOL
	W1	(SWT)		;W1
	W0T	(ADD)		;W0
	XIT	(EXEQML)	;EXIT EQUAL ML

COLEND:						;COLUMN END
	SNZ	(REGSAV)	;LAST COLUMN PRINTED ?
	PRCT	(CRR)		;NO, END THE LINE
	ZER	(REGSAV)	;RESET COLUMN COUNTER
	XIT	(EXIML)	;RETURN
ALLOEQ:					;ALLOC EQUIV
	SRD	(EDAROL)	;EQUIV DATA ROLL
	XITF	(EXIML)	;EXIT
	EAW	(GANFIL)	;GENERAL ALLOC NAME FILE
	EAW	(D0)		;INTEGRATE INTO COMMON
	EAW	(ETEROL)	;EQUIV TEMP ROLL
	EAW	(EDAROL)	;EQUIV DATA ROLL
	JSB	(INISEG)	;INITIALIZE SEGS
	JSB	(REMNES)	;REMOVE NEST
	EAW	(ENEFIL)	;EQUIV NEST FILE
	W4	(STO)		;W4
	W2	(NOZ)
ALLEQ1:
	W1I	(SRD)		;W1
	JSBT	(LSARNE)	;LOAD SEG AND REMOVE NEST
	JMPT	(ALLEQ1)	;$1
	POW	(D4)		;FOUR
	XIT	(EXIML)	;EXIT
ALLNES:					;ALLOCATE NEST
ALLNE1:
	MOA	(ENEROL)	;EQUIV NEST ROLL
	JMPF	(ALLNE2)	;$2
	SUB	(MINBOX)	;MIN REL BOX
	ADD	(LOCCNT)	;LOC CNTR
	STO	(DAT1)	;DATA 1
	MOA	(ENEROL)	;EQUIV NEST ROLL
	STO	(SYMBOL)	;SYMBOL
	PNG	(GALROL)	;GENERAL ALLOC ROLL
	IER	(APNEM)	;ALLOC PNTR EM
	AGF	(GALFIL)	;GENERAL ALLOC FILE
	JSB	(IDCLAS)	;ID CLASSIFY
	W1	(SWT)		;W1
	XW1.0	(STO)		;ZERO RUNG
	POW	(D1)		;ONE
	JMP	(ALLNE1)	;$1
ALLNE2:
	REL	(ENEROL)	;EQUIV NEST ROLL
	FET	(MAXBOX)	;MAX REL BOX
	SUB	(MINBOX)	;MIN REL BOX
	AMY	(LOCCNT)	;LOC CNTR
	XIT	(EXIML)	;EXIT
INISEG:					;INITIALIZE SEGS
	FLP	(EDAROL)	;EQUIV DATA ROLL
INISE1:
	SRD	(EDAROL)	;EQUIV DATA ROLL
	XITF	(EXIML)	;EXIT
	RSV	(ENEROL)	;EQUIV NEST ROLL
	FET	(MOSPOS)	;MOST POSITIVE
	STK	(MINBOX)	;MIN REL BOX
	ZER	(MAXBOX)	;MAX REL BOX
	SMY	(MAXBOX)	;MAX REL BOX
INISE3:
	LGA	(EDAROL)	;EQUIV DATA ROLL
	JMPF	(INISE4)	;$4
	JSB	(CSACFI)	;CALC SIZE AND CLASSIFY FIN
	FETT	(DAT1)	;DATA 1
	AMYT	(DAT1)	;DATA 1
	ADD	(DAT1)	;DATA 1
	JSB	(MOVBOU)	;MOVE BOUNDS
	CLA	(DAT1)	;DATA 1
	JSB	(MOVBOU)	;MOVE BOUNDS
	JSB	(IDCLAS)	;ID CLASSIFY
	IER	(ENPEM)	;EQUIV NAME PNTR EM
	STO	(SYMBOL)	;SYMBOL
	AGF	(ENEFIL)	;EQUIV NEST FILE
	JMP	(INISE3)	;$3
INISE4:
	FET	(MAXBOX)	;MAX REL BOX
	MON	(ETEROL)	;EQUIV TEMP ROLL
	FET	(MINBOX)	;MIN REL BOX
	MON	(ETEROL)	;EQUIV TEMP ROLL
	EAW	(ETEROL)	;EQUIV TEMP ROLL
	CAR	(ENEROL)	;EQUIV NEST ROLL
	AGF	(ETEFIL)	;EQUIV TEMP FILE
	JMP	(INISE1)	;$1
LSARNE:					;LOAD SEG AND REMOVE NEST
	W1	(SWT)
	W0I	(FLP)
	W0I	(MOA)
	W1I	(MOA)
	ZER	(TPOBOX)	;TIE POINT BOX
	SMY	(TPOBOX)	;TIE POINT BOX
	ADD	(TPOBOX)	;TIE POINT BOX
	STO	(MAXBOX)	;MAX REL BOX
	ZER	(MINBOX)	;MIN REL BOX
	EAW	(ENEFIL)	;EQUIV NEST FILE
	JSB	(IRESOU)	;INTEGRATE REM SOURCE
	ZER	(HITCNT)	;HITS CNTR
	JSB	(RNEFIN)	;REMOVE NEST FIN
	JMP	(ALLNES)	;ALLOCATE NEST
REMNES:					;REMOVE NEST
	W1I	(SRD)
	XITF	(EXIML)	;EXIT
	W1I	(FLP)
	W1	(SWT)
	ZER	(HITCNT)	;HITS CNTR
RNECON:					;REMOVE NEST CONTINUE
	W0I	(MOA)
	STK	(SMABOX)	;SEG MAX BOX
	W2I	(MON)
	W0I	(MOA)
	STK	(SMIBOX)	;SEG MIN BOX
	W2I	(MON)
	JSB	(SEASEG)	;SEARCH SEG
	JMPF	(RNEFIN)
	TLY	(HITCNT)	;HITS CNTR
	W2	(SNZ)
	JSBF	(IINCOM)
	JSBT	(IINNES)
RNEFIN:					;REMOVE NEST FIN
	W0I	(SRD)
	JMPT	(RNECON)	;REMOVE NEST CONTINUE
	SNZ	(HITCNT)	;HITS CNTR
	XITF	(EXIML)	;EXIT
	JMP	(REMNES)	;REMOVE NEST
SEASEG:					;SEARCH SEG
SEASE1:
	W0I	(LGA)
	FET	(SYMBOL)	;SYMBOL
	W2I	(MON)
	FET	(DAT1)	;DATA 1
	W2I	(MON)
	JMPF	(EXIFAL)	;EXIT FALSE
	XNI	(SYMBOL)	;SYMBOL
	FET	(ZERRUN)	;ZERO RUNG
	SMK	(APNEM)	;ALLOC PNTR EM
	STOT	(CREPNT)	;CRRNT REG PNTR
	XMLT	(ETRML)	;EXIT TRUE
	STO	(SYMBOL)	;SYMBOL
	W3I	(ISE)
	JMPF	(SEASE1)	;$1
	XML	(ETRML)	;EXIT TRUE
IINCOM:					;INTEGRATE INTO COMMON
	XNI	(CREPNT)	;CRRNT REG PNTR
	FET	(ONERUN)	;ONE RUNG
	AND	(RHAMAS)	;RIGHT HALF MASK
	SUB	(DAT1)	;DATA 1
	ADD	(SMIBOX)	;SEG MIN BOX
	SLK	(ZERO)	;ZERO
	XNIT	(CREPNT)	;CRRNT REG PNTR
	FETT	(ONERUN)	;ONE RUNG
	XMLT	(MCAPML)	;MAKE COMMON AREA PNTR
	XW0.0T	(CLA)		;ZERO RUNG
	MONT	(AERROL)	;ALLOC ERROR ROLL
	SUB	(SMIBOX)	;SEG MIN BOX
	AMY	(SMABOX)	;SEG MAX BOX
	JSB	(ACBSIZ)	;ADV COMMON BLOCK SIZE
	EAW	(GANFIL)	;GENERAL ALLOC NAME FILE
	JMP	(INTFIN)	;INTEGRATE FIN
IINNES:					;INTEGRATE INTO NEST
	FET	(SMIBOX)	;SEG MIN BOX
	JSB	(SAMBOU)	;SET AND MOVE BOUNDS
	FET	(SMABOX)	;SEG MAX BOX
	JSB	(SAMBOU)	;SET AND MOVE BOUNDS
	EAW	(ENEFIL)	;EQUIV NEST FILE
INTFIN:					;INTEGRATE FIN
	XNI	(CREPNT)	;CRRNT REG PNTR
	FET	(ONERUN)	;ONE RUNG
	SUB	(DAT1)	;DATA 1
	STO	(TPOBOX)	;TIE POINT BOX
	W2I	(MOA)		;W2
	W3I	(MOA)		;W3
	POW	(D2)		;TWO
INTFI1:
	W2I	(MOA)		;W2
	W3I	(MOA)		;W3
	SMK	(ENPEM)	;EQUIV NAME PNTR EM
	POWF	(D2)		;TWO
	JMPF	(IRESOU)	;INTEGRATE REM SOURCE
	XW0.0	(FET)		;ZERO RUNG
	EAW	(GANFIL)	;GENERAL ALLOC NAME FILE
	W4	(SEQ)		;W4
	PNGT	(GALROL)	;GENERAL ALLOC ROLL
	IERT	(APNEM)	;ALLOC PNTR EM
	XW2.0T	(STO)		;ZERO RUNG
	STO	(SYMBOL)	;SYMBOL
	POW	(D1)		;ONE
	ADD	(TPOBOX)	;TIE POINT BOX
	STO	(DAT1)	;DATA 1
	W0I	(AGF)		;W0
	JMP	(INTFI1)	;$1
IRESOU:					;INTEGRATE REM SOURCE
IRESO1:
	W1I	(LGA)
	XMLF	(P1EML)	;PRUNE ONE EXIT
	FET	(SYMBOL)	;SYMBOL
	XW0.0	(FET)		;ZERO RUNG
	SMK	(APNEM)	;ALLOC PNTR EM
	XW0.0T	(CLA)		;ZERO RUNG
	STO	(SYMBOL)	;SYMBOL
	W1I	(REG)
	FET	(DAT1)	;DATA 1
	ADD	(TPOBOX)	;TIE POINT BOX
	XNI	(CREPNT)	;CRRNT REG PNTR
	SWT	(ONERUN)	;ONE RUNG
	XNIT	(CREPNT)	;CRRNT REG PNTR
	SUBT	(ONERUN)	;ONE RUNG
	EAW	(GANFIL)	;GENERAL ALLOC NAME FILE
	W3	(SEQ)		;W3
	FETT	(CREPNT)	;CRRNT REG PNTR
	IERT	(APNEM)	;ALLOC PNTR EM
	XW2.0T	(STO)		;ZERO RUNG
	W1	(STO)		;W1
	SEQ	(ZERO)	;ZERO
	FETF	(SYMBOL)	;SYMBOL
	MONF	(AERROL)	;ALLOC ERROR ROLL
	JMP	(IRESO1)	;$1
SAMBOU:					;SET AND MOVE BOUNDS
	SUB	(DAT1)	;DATA 1
	XNI	(CREPNT)	;CRRNT REG PNTR
	ADD	(ONERUN)	;ONE RUNG
MOVBOU:					;MOVE BOUNDS
	SGK	(MAXBOX)	;MAX REL BOX
	STKT	(MAXBOX)	;MAX REL BOX
	SLK	(MINBOX)	;MIN REL BOX
	STKT	(MINBOX)	;MIN REL BOX
	XML	(P1EML)	;PRUNE ONE EXIT
ACBSIZ:					;ADV COMMON BLOCK SIZE
	XNI	(CREPNT)	;CRRNT REG PNTR
	FET	(ONERUN)	;ONE RUNG
	XML	(MCAPML)	;MAKE COMMON AREA PNTR
	FET	(SMABOX)	;SEG MAX BOX
	XW1.1	(SGK)		;ONE RUNG
	XW1.1T	(STK)		;ONE RUNG
	XML	(P2EML)	;PRUNE TWO EXIT
PGAROL:					;PUBLISH GENERAL ALLOC ROLL
	ZER	(GALPNT)	;GENERAL ALLOC PNTR
	DNG	(GALROL)	;GENERAL ALLOC ROLL
	XITF	(EXIML)	;EXIT
	XNI	(GALPNT)	;GENERAL ALLOC PNTR
	FET	(ONERUN)	;ONE RUNG
	SMK	(LHOEM)	;LEFT HALF ONES EM
	JMPF	(PGARO1)	;$1
	JSB	(PGLDUM)	;PUBLISH GLOBAL DUMMIES
	XITF	(EXIML)	;EXIT
PGARO1:
	SMK	(LHZEM)	;LEFT HALF ZERO EM
	JSBF	(PUBCOM)	;PUBLISH COMMON
	JSBT	(PUBEQU)	;PUBLISH EQUIV
	XIT	(EXIML)	;EXIT
PGLDUM:					;PUBLISH GLOBAL DUMMIES
	PRQ	(GDDCRQ)	;GLOBAL DUMMIES DBL CAR RET QT
PGLDU1:
	AND	(DISMAS)	;DISPL MASK
	SUB	(ONE)		;ONE
	ADD	(PROBRE)	;PROGRAM BREAK
	XNI	(GALPNT)	;GENERAL ALLOC PNTR
	STK	(ONERUN)	;ONE RUNG
	XNI	(GALPNT)	;GENERAL ALLOC PNTR
	FET	(ZERRUN)	;ZERO RUNG
	W1	(SWT)		;W1
	JSB	(PIALOC)	;PUBLISH ID AND LOC
	DNG	(GALROL)	;GENERAL ALLOC ROLL
	JSBF	(COLEND)	;FINISH LINE
	XITF	(EFAML)	;EXIT FALSE
	XNI	(GALPNT)	;GENERAL ALLOC PNTR
	FET	(ONERUN)	;ONE RUNG
	SMK	(LHOEM)	;LEFT HALF ONES EM
	JSBF	(COLEND)	;FINISH LINE
	XITF	(ETRML)	;EXIT TRUE
	JMP	(PGLDU1)	;$1
PUBCOM:					;PUBLISH COMMON
	PRQ	(COMCRQ)	;COMMON QT
PUBCO1:
	W0	(FET)		;W0
	XML	(MCAPML)	;MAKE COMMON AREA PNTR
	XW0.0	(CLA)		;ZERO RUNG
	XNI	(GALPNT)	;GENERAL ALLOC PNTR
	FET	(ZERRUN)	;ZERO RUNG
	JSB	(PRIW0)	;PRINT SYMBOL
	PRC	(TAB)		;COMMON NAME LINE POSITION
	PRC	(SLASH)	;SLASH
	JSB	(PRIW0)	;PRINT SYMBOL
	PRC	(SLASH)	;SLASH
	PRC	(PLUS)	;LOC LINE POSITION
	JSB	(POCLOC)	;PRINT OCTAL LOC
	PCOL	(ZERO)	;PRINT COLUMNS
	DNG	(GALROL)	;GENERAL ALLOC ROLL
	JSBF	(COLEND)	;FINISH LINE
	XITF	(EFAML)	;EXIT FALSE
	XNI	(GALPNT)	;GENERAL ALLOC PNTR
	FET	(ONERUN)	;ONE RUNG
	SMK	(LHZEM)	;LEFT HALF ZERO EM
	JSBT	(COLEND)	;FINISH LINE
	XMLT	(ETRML)	;EXIT TRUE
	JMP	(PUBCO1)	;$1
PUBEQU:					;PUBLISH EQUIV
	PRQ	(EQCRQT)	;EQUIVALENCE QT
PUBEQ1:
	XNI	(GALPNT)	;GENERAL ALLOC PNTR
	FET	(ZERRUN)	;ZERO RUNG
	W1	(SWT)		;W1
	JSB	(PIALOC)	;PUBLISH ID AND LOC
	DNG	(GALROL)	;GENERAL ALLOC ROLL
	JSBF	(COLEND)	;FINISH LINE
	XITF	(EXIML)	;EXIT
	XNI	(GALPNT)	;GENERAL ALLOC PNTR
	FET	(ONERUN)	;ONE RUNG
	JMP	(PUBEQ1)	;$1
OGSROL:					;OUTPUT GLOBAL SPROG ROLL
	SRD	(GSPROL)	;GLOBAL SPROG ROLL
	PRQT	(CRSDCR)	;CAR RET SUBPROGRAMS DBL CAR RET QT
	CNT	(GSPROL)	;GLOBAL SPROG ROLL
	MON	(CODROL)	;CODE ROLL
	FLP	(GSPROL)	;GLOBAL SPROG ROLL
OGSRO1:
	MOA	(GSPROL)	;GLOBAL SPROG ROLL
	JSBF	(COLEND)	;FINISH LINE
	JMPF	(PDASTA)	;PUNCH DATA STA
	SMK	(APNEM)	;ALLOC PNTR EM
	CLAT	(DMYSYM)	;DUMMY SYMBOL
	W0	(FET)		;W0
	JSB	(PRIW0)	;PRINT SYMBOL
	PCOL	(ONE)		;PRINT COLUMNS
	XML	(ST5RML)	;SYMBOL TO 50 RADIX
	IER	(LENEM)	;LOADER ENTRY EM
	MON	(CODROL)	;CODE ROLL
	JMP	(OGSRO1)	;$1
AAPSAA:					;ALLOCATE AND PUBLISH SCALARS AND ARRAY
	SRD	(SCAROL)	;SCALAR ROLL
	PRQT	(SCALQT)
	EAW	(SCAROL)	;SCALAR ROLL
	EAW	(SCAPNT)	;SCALAR PNTR
	ZERT	(SCAPNT)
	NOG	(SCAROL)
IFN FTMANT,<ZER	(DAT4)>
	JSB	(SOAALL)	;SCALAR OR ARRAY ALLOCATION
	REL	(SCAROL)	;SCALAR ROLL
	SRD	(ARRROL)	;ARRAY ROLL
	PRQT	(ARAYQT)
	EAW	(ARRROL)	;ARRAY ROLL
	EAW	(ARRPNT)	;ARRAY PNTR
	ZERT	(ARRPNT)
	NOG	(ARRROL)
IFN FTMANT,<NOZ	(DAT4)>
SOAALL:					;SCALAR OR ARRAY ALLOCATION
	MPY	(TWO)
SOAAL2:
	MON	(CODROL)	;CODE ROLL
	W1I	(DNG)
	POWF	(D2)		;THREE
	JSBF	(COLEND)	;FINISH LINE
	JMPF	(PDASTA)	;PUNCH DATA STA
	W0I	(XNI)
	FET	(ZERRUN)	;ZERO RUNG
	SMK	(APNEM)	;ALLOC PNTR EM
IFE FTMANT,<
	JSBT	(GDFGAL)	;GET DATA FROM GENERAL ALLOC
	W2IT	(XNI)
	STKT	(ZERRUN)	;ZERO RUNG
	W1T	(FET)		;COPY ROLL NUMBER
	W1T	(FET)		;COPY ROLL POINTER
	JSBT	(PIALOC)	;PUBLISH THE ROLL
	MONT	(CODROL)	;CODE ROLL
	JMPT	(SOAAL1)	;$1
	W0	(FET)
	FET	(LOCCNT)	;LOC CNTR
	W0	(FET)		;W0
	MON	(CODROL)	;CODE ROLL
>
IFN FTMANT,<
	JMPF	(SOAAL3)
	JSB	(GDFGAL)	;GET DATA FROM GENERAL ALLOC
	W2I	(XNI)
	STK	(ZERRUN)	;ZERO RUNG
	W1	(FET)		;COPY ROLL NUMBER
	W1	(FET)		;COPY ROLL POINTER
	JSB	(PIALOC)	;PUBLISH THE ROLL
	W1	(FET)		;SET TYPE FLAG AND ONTO CODROL
	STO	(SYMBOL)
	JSB	(TYPCOD)
	JMP	(SOAAL1)
SOAAL3:	STK	(SYMBOL)	;HOLD IT
	W0	(FET)
	FET	(LOCCNT)		;LOCCNT
	W0	(FET)		;W0
	JSB	(TYPCOD)	;SET TYPE FLAGS AND ONTO CODROL
>
	JSB	(PIALOC)	;PUBLISH ID AND LOC
	W0	(FET)		;W0
	JSB	(CSACLA)	;CALC SIZE AND CLASSIFY
	W1	(STO)		;W1
	FET	(LOCCNT)	;LOC CNTR
	W3I	(XNI)
	STK	(ZERRUN)	;ZERO RUNG
	W1	(AMY)		;W1
	STO	(LOCCNT)	;LOC CNTR
SOAAL1:
	XML	(ST5RML)	;SYMBOL TO 50 RADIX
	IER	(LSOAEM)	;LOADER SCALAR OR ARRAY EM
	JMP	(SOAAL2)	;$2
GDFGAL:					;GET DATA FROM GENERAL ALLOC
	XW0.0	(FET)		;ZERO RUNG
	W1	(SWT)		;W1
	XW0.1	(CLA)		;ONE RUNG
	XIT	(EXIML)	;EXIT
PIALOC:					;PUBLISH ID AND LOC
	W1	(FET)		;W1
	JSB	(PRIW0)	;PRINT SYMBOL
	PRC	(TAB)		;LOC LINE POSITION
	JSB	(POCLOC)	;PRINT OCTAL LOC
	PRC	(TAB)		;SEPERATE THE COLUMNS
	PCOL	(ZERO)	;PRINT COLUMNS
	XML	(P1EML)	;PRUNE ONE EXIT
IFN FTMANT,<
TYPCOD:			;SET TYPE CODE AND MOVE ONTO CODROL
	JSB	(TYPSET)	;TYPE CODE
	SNZ	(DAT4)		;MAYBE PROCESSING ARRAY
	IORT	(ARRFLG)
	MON	(CODROL)	;CODROL
	XIT	(EXIML)	;EXIT
>
OOAREF:					;OUTPUT OBJECT ARRAY REF
	FLP	(OARROL)	;OBJECT ARRAY REF ROLL
	CNT	(OARROL)	;OBJECT ARRAY REF ROLL
OOARE1:
	MON	(CODROL)	;CODE ROLL
	MOA	(OARROL)	;OBJECT ARRAY REF ROLL
	RELF	(ARRROL)	;ARRAY ROLL
	JMPF	(PUNDAT)	;PUNCH DATA
	MOA	(OARROL)	;OBJECT ARRAY REF ROLL
	SON	(DMYEM)	;DMY EM
	XW1.0F	(FET)		;ZERO RUNG
	XMLF	(CBMOML)	;COMPUTE BASE MINUS OFFSET
	MON	(CODROL)	;CODE ROLL
	AND	(RHAMAS)	;RIGHT HALF MASK
	JMP	(OOARE1)	;$1
OCOARE:					;OUTPUT COMMON AREA
	CNT	(CARROL)	;COMMON AREA ROLL
	MON	(CODROL)	;CODE ROLL
	FLP	(CARROL)	;COMMON AREA ROLL
OCOAR1:
	MOA	(CARROL)	;COMMON AREA ROLL
	JMPF	(PUNDAT)	;PUNCH DATA
	XML	(ST5RML)	;SYMBOL TO 50 RADIX
	IER	(LCOEM)	;LOADER COMMON EM
	MON	(CODROL)	;CODE ROLL
	MOA	(CARROL)	;COMMON AREA ROLL
	MON	(CODROL)	;CODE ROLL
	JMP	(OCOAR1)	;$1
PLBERR:					;PUBLISH LBL ERRORS
	FLP	(LBLROL)	;LBL ROLL
PLBER1:
	MOA	(LBLROL)	;LBL ROLL
	JMPF	(PLBER2)	;$2
	SMK	(DEFEM)	;DEFINED EM
	XMLF	(BTBCML)	;CONVERT W0 TO BCD ABS
	MONF	(ULBROL)	;UNDEFINED LBL ROLL
	JMPF	(PLBER1)	;$1
	SMK	(MDEEM)	;MUL DEFINED EM
	ANDT	(LWEMAS)	;LBL WITHOUT EMS MASK
	XMLT	(BTBCML)	;CONVERT W0 TO BCD ABS
	MONT	(MDLROL)	;MUL DEFINED LBL ROLL
	POWF	(D1)		;ONE
	JMP	(PLBER1)	;$1
PLBER2:
	SRD	(ULBROL)	;UNDEFINED LBL ROLL
	PRQT	(CRULDC)	;CAR RET UNDEFINED LBLS DBL CAR RET QT
	EAWT	(ULBROL)	;UNDEFINED LBL ROLL
	JSBT	(PUBROL)	;PUBLISH ROLL
	SRD	(MDLROL)	;MUL DEFINED LBL ROLL
	PRQT	(CRMDLD)	;CAR RET MULTIPLY DEFINED
	EAWT	(MDLROL)	;MUL DEFINED LBL ROLL
	JMP	(PALER1)	;PUBLISH ALLOC ERR $1
PALERR:					;PUBLISH ALLOCATION ERROR
	SRD	(AERROL)	;ALLOC ERROR ROLL
	PRQT	(ALERCR)	;ALLOCATION QT
	EAWT	(AERROL)	;ALLOC ERROR ROLL
PALER1:
	JSBT	(PUBROL)	;PUBLISH ROLL
	XIT	(EXIML)	;EXIT
PDLERR:					;PUBLISH DO LOOP ERRORS
	SRD	(DLOROL)	;DO LOOPS OPEN ROLL
	PRQT	(ODLQT)	;OPEN DO LOOPS QT
PDLER1:
	MOA	(DLOROL)	;DO LOOPS OPEN ROLL
	JSBF	(COLEND)	;FINISH LINE
	XITF	(EXIML)	;EXIT
IFNDEF	FILE0,
<
	TLY	(ERRCNT)	;ERROR COUNT
>
	XW0.0	(FET)		;ZERO RUNG
	AND	(LWEMAS)	;LBL WITHOUT EMS MASK
	XML	(BTBCML)	;CONVERT W0 TO BCD ABS
	JSB	(PRIW0)	;PRINT W0
	PCOL	(ONE)		;PRINT COLUMNS
	REL	(DLOROL)	;DO LOOPS OPEN ROLL
	JMP	(PDLER1)	;$1
PUBROL:					;PUBLISH ROLL
PUBRO1:
	W0I	(MOA)
	JSBF	(COLEND)	;FINISH LINE
	XMLF	(P1EML)	;PRUNE ONE EXIT
IFNDEF	FILE0,
<
	TLY	(ERRCNT)	;ERROR COUNT
>
	SEK	(ZERO)	;BLANKS WORD
	PRCT	(SLASH)	;SLASH
	JSB	(PRIW0)	;PRINT W0
	PRCT	(SLASH)	;SLASH
	PCOL	(ONE)		;PRINT COLUMNS
	JMP	(PUBRO1)	;$1
LGAKEE:					;LBL GEN AND KEEP
MLGAKE:					;MADE LBL GEN AND KEEP
	W0	(FET)		;W0
MLBGEN:					;MADE LBL GEN
LBLGEN:					;LBL GEN
	W0	(FET)		;W0
	IOR	(CMUEM)	;CONST MULTIPLIER EM
	MON	(CODROL)	;CODE ROLL
	JSB	(CCOLBL)	;CONVERT CODE LBL
	JMP	(MOCOEX)	;MOVE ON CODE EXIT
SUBFAI:					;SUBEXP FAIL
	JSB	(SERNOT)	;SUBEXP ERROR NOTE
;LINE DELETED "26J"	XML	(FAIML)	;FAIL ML
	LCF	(M23QT)		;PUBLISH 'INTEGER EXPECTED' ERROR AND FAIL ; "26J"
SFAW0:					;SYNTAX FAIL W0
	ERM	(S13QT)	;SYNTAX QT
FAIL:					;FAIL
	XML	(FAIML)	;FAIL ML
SERNOT:					;SUBEXP ERROR NOTE
	SMK	(SUBEM)	;SUBEXP EM
	XW0.0T	(FET)		;OP PNTR RUNG
	W0F	(FPC)		;W0
	XIT	(EXIML)	;EXIT
GHEGEN:					;GLOBAL HEAD GEN
	RSV	(PCOROL)	;PROLOG CODE ROLL
	EAW	(PCOROL)	;PROLOG CODE ROLL
	CAR	(CODROL)	;CODE ROLL
	FET	(SYMBOL)	;SYMBOL
	FET	(SYMBOL)	;SYMBOL
IFNDEF	FILE0,
<
	STK	(PROGN)	;PROGRAM NAME
>
	XML	(ST5RML)	;SYMBOL TO 50 RADIX
	SNZ	(NOPPNT)	;NAME OF PROG PNTR
	JMPT	(GHEGE1)	;$1
	W1	(SWT)		;W1
	SEK	(MAITES)	;MAIN. TEST
	LSST	(FORSE.)	;FORSE.
	REGT	(GSPFIL)	;GLOBAL SPROG FILE
	LSS	(JOBFF.)	;ELIMINATE TWO SEARCHES OF JOBDAT
	REG	(GSPFIL)	;CREATE PSEUDO GLOBAL SPROG FOR THE LOADER
	PNG	(UN2ROL)	;UNUSED 2 ROLL
	STO	(NOPPNT)	;NAME OF PROG PNTR
IFN FTMANT,<	SNZ	(DEBFLAG)	;OUTPUT PROGRAM NAME FOR DEBUGGING
		XNIT	(NOPPNT)
		FETT	(ZERRUN)
		XMLT	(ST5RML)
		XMLT	(RFPML)>
	MON	(UN2ROL)	;UNUSED 2 ROLL
	JMP	(GHEGE2)	;$2
GHEGE1:
	W1	(STK)		;W1
	POC	(WONHEA)	;WORD ONE HEADER
	ZER	(SYMBOL)	;SYMBOL
	AGF	(CODFIL)	;CODE FILE
	IER	(ENAEM)	;ENTRY NAME EM
	MON	(CODROL)	;CODE ROLL
GHEGE2:
	POC	(WFOHEA)	;WORD FOUR HEADER
	ZER	(SYMBOL)	;SYMBOL
	AGF	(CODFIL)	;CODE FILE
	STK	(RPRNAM)	;R50 PROG NAME
	MON	(CODROL)	;CODE ROLL
	TLY	(SYMBOL)	;INDICATE FORTRAN FILE FOR LOADER	;"21H"
	SWH	(SYMBOL)	;LEFT HALF OF WORD CONTAINS 1 (FORTRAN);"21H"
	AGF	(CODFIL)	;CODE FILE
IFE FTMANT,<	POC	(FSIHEA)	;F4 SIGNAL HEADER>
IFN FTMANT,<	SNZ	(DEBFLAG)
		POCF	(FSIHEA)
		POCT	(DEBHEA)	;DEBUG SIGNAL>
	JSB	(PDASTA)	;PUNCH DATA STA
	EAW	(CODROL)	;CODE ROLL
	CAR	(PCOROL)	;PROLOG CODE ROLL
	JSB	(OUTCOD)	;OUTPUT CODE
GHEEXI:					;GLOBAL HEAD EXIT
	JSB	(LBLMAK)	;LBL MAKER
	JSB	(MLGAKE)	;MADE LBL GEN AND KEEP
	STO	(BEXPNT)	;BEGIN EXECUTION PNTR
	ZER	(FSTFLA)	;FIRST STA FLAG
	XIT	(EXIML)	;EXIT
PDASTA:					;PUNCH DATA STA
	NOZ	(DSTFLA)	;DATA STA FLAG
	JMP	(PUNCH)	;PUNCH

PUNDAT:					;PUNCH DATA
	ZER	(PPEFLA)	;PUNCH PEEK FLAG
	JMP	(PUNCO1)	;PUNCH

OUTCOD:					;OUTPUT CODE
	JSB	(PROCOD)	;PROCESS CODE
PUNCOD:					;PUNCH CODE
	NOZ	(PPEFLA)	;PUNCH PEEK FLAG
PUNCO1:
	ZER	(DSTFLA)	;DATA STA FLAG

PUNCH:					;PUNCH
	XML	(PUNCML)	;$1
	REL	(CODROL)
	ZER	(DSTFLA)
	XIT	(EXIML)
PROCOD:					;PROCESS CODE
	ZER	(CODPNT)	;CODE PNTR
	ZER	(ACOCNT)	;ABS CODE CNTR
	ZER	(CLBBOX)	;CODE LBL BOX
PROCO1:
	DFA	(CODROL)	;CODE ROLL
	JMPF	(CISLBL)	;CODE ISOLATED LBL	;GO GEN BLOCK 0 FOR LABEL ONLY
	SNZ	(ACOCNT)	;ABS CODE CNTR
	JMPT	(PROCO2)	;$2
	SMK	(PLIEM)	;PROG LBL INST EM
	SMKF	(MLIEM)	;MADE LBL INST EM
	JSBT	(SCOLBL)	;SET CODE LBL
	JMPT	(PROCO1)	;$1
	SEK	(ELOOP)	;ENTRY LOADER OP
	JMPF	(PROCO3)	;$3
	POW	(D1)		;ONE
	DFA	(CODROL)	;CODE ROLL
	POW	(D1)		;ONE
	JMP	(PROCO1)	;$1
PROCO3:
	SMK	(AINEM)	;ABS INST EM
	ANDT	(ACNMAS)	;ABS CNT MASK
	STOT	(ACOCNT)	;ABS CODE CNTR
	JMPT	(PROCO1)	;$1
PROCO2:
IFE FTMANT,<	SNZ	(MACSW)	;PRINTING SUPPRESSED ?
	JSBT	(PROCO4)	;YES,GET OPCODE W/O SIDE AFFECTS
	JMPT	(PROCO1)	;YES, DON'T PRINT>
	JSB	(PCOLBL)	;NO, PRINT CODE LBL
	XML	(SOFBML)	;SWITCH OCT AND FET BCD
	PRC	(TAB)
	JSB	(PRIW0)	;PRINT W0
	PRC	(TAB)
	XMLT	(PAFML)	;PRINT AC FIELD
	PRCT	(COMMA)	;COMMA
	SMK	(IINEM)	;INDIRECT INST EM
	PRCT	(INDCHA)	;INDIRECT CHAR
	SNZ	(ACOCNT)	;ABS CODE CNTR
	DIMT	(ACOCNT)	;ABS CODE CNTR
	JSBT	(CABADR)	;CODE ABS ADR
	JSBF	(CPNADR)	;CODE PNTR ADR
	SMK	(NTAEM)	;NO TAG EM
	PRCF	(LPAREN)	;L PAREN
	XMLF	(PTAML)	;PRINT TAG
	PRCF	(RPAREN)	;R PAREN
	POW	(D1)		;ONE
	PRC	(CRR)		;CAR RETURN
	JMP	(PROCO1)	;$1
IFE FTMANT,<PROCO4:
	SNZ	(ACOCNT)	;ABSOLUTE CODE ?
	DIMT	(ACOCNT)	;YES, KEEP TRACK OF THE NUMBER
	XML	(SOFBML)	;SWITCH OCT AND FET BCD
	POW	(D2)		;PRUNE OPCODE MNEMONIC & INSTR.
	XIT	(EXIML)	;RETURN W/O TRUE/FALSE FLAG>
CCLAGE:					;CONVERT CODE LBL AND GEN
	W1	(STK)		;W1
	XML	(ST5RML)
	IER	(LOPTRA)	;LOGICAL OP TRAIT
	XNI	(CODPNT)	;CODE PNTR
	STO	(ZERRUN)	;ZERO RUNG
	XIT	(EXIML)	;EXIT
SCOLBL:	DFA	(CODROL)	;CODE ROLL
	JSB	(CCLAGE)	;CONVERT CODE LBL AND GEN
	STO	(CLBBOX)	;CODE LBL BOX
	XIT	(EXIML)	;EXIT
CISLBL:					;CODE ISOLATED LBL
	FET	(CLBBOX)	;CODE LBL BOX
	SEK	(ZERO)	;ZERO
	W0F	(FET)
	JSBF	(PRIW0)
	PRQF	(B0QT)	;BLOCK 0 QT
	ZER	(CLBBOX)	;CODE LBL BOX
	PRC	(CRR)		;CAR RETURN QT ;"23D"
	XML	(P1EML)	;PRUNE ONE EXIT
PCOLBL:					;PRINT CODE LBL
	FET	(CLBBOX)	;CODE LBL BOX
	ZER	(CLBBOX)	;CODE LBL BOX
PRIW0:
IFE FTMANT,<	XML	(PW0ML)>
IFN FTMANT,<	XML	(PW0RML)	;MAYBE PRINT>
CABADR:					;CODE ABS ADR
	W0	(FET)		;W0
	AND	(RHAMAS)	;RIGHT HALF MASK
POCLOC:
	XML	(POLML)	;PRINT OCTAL LOC

CPNADR:					;CODE PNTR ADR
	SMK	(MLBEM)	;MADE LBL EM
	SMKF	(LBLEM)	;LBL EM
	W0	(FET)		;W0
	JSBT	(CCOLBL)	;CONVERT CODE LBL
	XMLT	(PW0ML)	;PRINT W0 ML
	SMK	(CONEM)	;CONST EM
	SMKF	(TEMEM)	;TEMP EM
	JMPT	(CDIREF)	;CONVERT DISPL REF
	SMK	(OAREM)	;OBJECT ARRAY REF EM
	JMPF	(CPAFIN)	;CODE PNTR ADR FIN
	SMK	(APOEM)	;ADR PLUS ONE EM
	EORT	(APOMAS)	;ADR PLUS ONE MASK
	XW0.0	(FET)		;OBJECT ARRAY REF NAME RUNG
	JSB	(CPAFIN)	;CODE PNTR ADR FIN
	XW0.1	(CLA)		;OBJECT ARRAY REF OFFSET RUNG
	W0T	(DIM)		;W0
	SLK	(ZERO)	;ZERO
	PRCF	(MINUS)	;MINUS
	PRCT	(PLUS)	;PLUS
	W0T	(NOT)
	W0T	(TLY)
	JMP	(POCLOC)	;PRINT OCTAL LOC
CPAFIN:					;CODE PNTR ADR FIN
	SMK	(APOEM)	;ADR PLUS ONE EM
	EORT	(APOMAS)	;ADR PLUS ONE MASK
	XW0.0	(CLA)		;ZERO RUNG
IFN FTMANT,<	W0	(FET)	;MAYBE OUTPUT OBJECT ARRAY REF NAME
		XML	(ST5AML)
		XML	(REFML)>
	JSB	(PRIW0)	;PRINT W0
	PRCT	(PLUS)	;PLUS
	PRCT	(N1)		;N1
	XIT	(EXIML)	;EXIT
CDIREF:					;CONVERT DISPL REF
	SMK	(PTEEM)	;PERM TEMP EM
	FETT	(PTESYM)	;PERM TEMP SYMBOL
	JMPT	(CDIRE1)	;$1
	SMK	(CONEM)	;CONST EM
	FETT	(CPOSYM)	;CONST POOL SYMBOL
	FETF	(LTESYM)	;LOCAL TEMP SYMBOL
CDIRE1:
	JSB	(PRIW0)	;PRINT W0
	SMK	(APOEM)	;ADR PLUS ONE EM
	AND	(DISMAS)	;DISPL MASK
	W0F	(DIM)		;W0
	SEK	(ZERO)	;ZERO
	XMLT	(P1EML)	;PRUNE ONE EXIT
	PRC	(PLUS)	;PLUS
	JMP	(POCLOC)	;PRINT OCTAL LOC
CCOLBL:					;CONVERT CODE LBL
	SMK	(MLBEM)	;MADE LBL EM
	XW0.0F	(CLA)		;ZERO RUNG
	AND	(RHAMAS)	;RIGHT HALF MASK
	ANDT	(DISMAS)	;DISPL MASK
	XML	(BTBCML)	;BIN TO BCD
	EAWT	(M)		;M
	EAWF	(P)		;P
ILACHA:
	XIT	(ILCHML)	;INSERT LABEL CHAR

	.MFRMT		;RESTART NICE BINARY LISTING ;"25-1"
IFNDEF	HALFWD,
<
	DEPHASE
>

IFDEF	HALFWD,
<
	IF2,	<IFN .&1,	<
	RELOC
	+CODE
	LOC>>

	RELOC	POPMEM+<.+1>/2

>
	OPSAVE	ADD
	OPSAVE	SUB
	OPSAVE	DIV
	OPSAVE	AND
;....EOF2

