	TITLE	.WILD -- SUBROUTINE TO PERFORM WILDCARD LOOKUP  %7(311)
	SUBTTL	P.CONKLIN/PFC		21-SEP-74


;***COPYRIGHT 1970, 1971, 1972, 1973, 1974  DIGITAL EQUIPMENT CORP., MAYNARD, MASS.***


CUSTVR==0		;CUSTOMER VERSION
DECVER==7		;DEC VERSION
DECMVR==0		;DEC MINOR VERSION
DECEVR==311		;DEC EDIT VERSION


;SUBROUTINE TO SCAN DIRECTORIES AND RETURN LOOKUP BLOCKS FOR THE
;VARIOUS NAMES WHICH MATCH WILD-CARDS.

	SEARCH	C,SCNMAC
	SALL

;ASSEMBLY INSTRUCTIONS:
;
IF1,<	..==%%C+%%SCNM
IFNDEF	..,<
PRINTX	?	.COMPILE WILD USING C.MAC AND SCNMAC.MAC AS UNIVERSALS
	PASS2
	END>
	PURGE	..>

;
;THEN LOAD THE .REL FILE WITH ANY PROGRAM NEEDING IT.

;;;;;;;;;;;;;;; W A R N I N G ;;;;;;;;;;;;;;;;
;;;;   UPDATE WILDDM IF LOW-SEG CHANGES   ;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

XP %%WILD,CUSTVR*1B2+DECVER*1B11+DECMVR*1B17+DECEVR
;       	TABLE OF CONTENTS FOR WILD
;
;
;                          SECTION                            PAGE
;    1. REVISION HISTORY......................................   5
;    2. MISC. DEFINITIONS.....................................   7
;    3. INITIALIZE AND PRESET CALL............................   8
;    4. LOOKUP ONE FILE.......................................   9
;    5. SECONDARY WILD-CARD LOGIC.............................  25
;    6. DIRECTORY SUBROUTINES.................................  35
;    7. STRUCTURE SUBROUTINES.................................  49
;    8. USEFUL SUBROUTINES....................................  54
;THIS SUBROUTINE WORKS ON THE DATA BASE LEFT BY THE COMMAND SCANER.
;A LIST OF PARAMETER AREAS DEFINES THE FILES REQUESTED AND THE VARIOUS
;SYSTEM STRUCTURES AND DIRECTORIES ARE SEARCHED.

	ENTRY	.LKWLD

;ONLY ONE PRINCIPLE ENTRY POINT IS DEFINED--GET THE FIRST OR NEXT FILE.
;CALL:	MOVE	T1,[LENGTH,,BLOCK]
;	PUSHJ	P,.LKWLD
; RETURN CPOPJ IF NO MORE FILES WITH T1=-1 (OR DEVCHR IF DISK ONLY)
;SKIP RETURN WITH OPEN BLOCK AND LOOKUP BLOCK PRESET
;	INDEX LOCATION WILL POINT TO CURRENT SCANER FILE SPEC
;		WITH T1=THE DEVCHR OF THE NEXT DEVICE
;		WITH T2=-1 IF DISK, 0 IF DTA, 1 OTHERS OR NUL:

;BLOCK+0: LH = LOCATION CONTAINING FIRST WORD OF FIRST SCANER FILE SPEC
;	  RH = 0 OR LOCATION CONTAINING FIRST WORD OF LAST SPEC
;      1: LH = LOCATION OF OPEN BLOCK (3 WORDS LONG)
;	  RH = LOCATION OF LOOKUP BLOCK
;      2: LH = LENGTH OF FILE SPEC FROM SCANER
;	  RH = LENGTH OF LOOKUP BLOCK
;      3: LH = CHANNEL FOR DATA FILE READING IF ANY AND FLAGS
;		1B0=1	HANDLE ALL DEVICES (ELSE, JUST DISK)
;		1B1=1	SCAN DIRECTORY BEFORE DOING ITS SFD'S
;	  RH = LOCATION OF POINTER TO FILE SPEC (INITIALLY 0)
;      4: RH = LOCATION OF ROUTINE TO NOTIFY AT END OF DIRECTORY

	ENTRY	.SCWLD

;ENTRY POINT TO COMPUTE SECONDARY FILE GIVEN
; INPUT AND WILD-CARDS.
;
;CALL:	MOVE	T1,[LENGTH,,BLOCK]
;	PUSHJ	P,.SCWLD
;	  ERROR RETURN IF NOT POSSIBLE TO SETUP (MESSAGE ALREADY ISSUED)
;	SKIP RETURN WITH DEVICE CHARACTERISTICS IN T1
;		AND T2=-1 IF DISK OR SPOOLED, 0 IF DTA, 1 OTHERWISE OR NUL:
;
;BLOCK THROUGH BLOCK+2 MANDATORY, LH=INPUT, RH=OUTPUT
;BLOCK+0:	ADDRESS OF SCAN FORMAT FILE SPEC (AT LEAST 32 WORDS)
;      1:	OPEN BLOCK (3 WORDS)
;      2:	LOOKUP/ENTER BLOCK (EXTENDED FORMAT)
;      3:	LH=ADDRESS OF DEFAULT OUTPUT EXTENSION WITH RH=-1
;		RH=LENGTH OF ENTER BLOCK

;AT RETURN, OUTPUT OPEN AND ENTER BLOCKS WILL BE SETUP
;SECONDARY ENTRY POINTS:
;	PUSHJ	P,E.DFO
;		REPORTS OPEN ERROR FOR DATA FILE
;	PUSHJ	P,.NXDTW
;	  EOF RETURN
;	NORMAL RETURN WITH NEXT WORD IN T1
;		READS ONE BYTE
;	PUSHJ	P,E.DFL
;		REPORTS LOOKUP ERROR 
;		ERROR INFO IN LOOKUP BLOCK
;	PUSHJ	P,.LKERR
;		REPORTS LOOKUP ERROR MESSAGE (NO FILE)
;		(CODE IN T1)
;		(PROT. IN 0-8 OF T3)
;	PUSHJ	P,.CHKTM
;		CHECKS /BEFORE AND /SINCE CONSTRAINTS
;		(ASSUMES LOOKUP WAS DONE INTO AREA LAST
;		 POINTED TO BY LAST CALL TO .LKWLD)
;		(ASSUMES PARAM AREA POINTED TO BY RH(E+3)
;		 IN LAST CALL TO .LKWLD)

;	PUSHJ	P,E.SCO
;		REPORTS OPEN ERROR
;	PUSHJ	P,E.SCL
;		REPORTS ENTER ERROR FROM ENTER BLOCK

;.WLDFL	=FLAG (-1 IF WILD, +1 IF STR WILD, -2 IF BOTH)
;.WIFIR	=LOCATION OF START OF CONCATENATED SET
;.WILAS	=LOCATION OF END ...  (X+Y)
;B.DC	=LOCATION OF BUFFER HEADER
;.WLDBF =BUFFER WITH CURRENT DIRECTORY BLOCK
;.WILDZ	=START OF WILD LOW SEG
;.WILDL	=LENGTH OF WILD LOW SEG

	TWOSEG
	RELOC	400000


ND FT$COR,-1		;+ TREATED SAME AS 'OR'
ND FT$SFD,-1		;SUB-FILE DIRECTORIES

IFLE .FXLND-1,<FT$SFD==0
		.FXLND==1>
	SUBTTL	REVISION HISTORY

;%1 -- 6/71 WITH 5.03 MONITOR (NAMED LOKWLD)

;A)  SHIFT INDEX TO P1 WHICH IS PRESERVED.  UPDATE USER'S
;	INDEX VIA ARGUMENT.
;B)  UPDATE TO USE THE REVISED TYPEOUT ROUTINES IN SCAN.
;C)  CHANGE CALL TO BE A BLOCK POINTED TO FROM T1.
;D)  USE CHANNEL 0 FOR ALL DIRECTORY READING.  HANDLE SFDS.  DIRECTORY
;	READING IS NOW IN DUMP MODE.
;E)  USE ARGUMENT CHANNEL FOR DATA READS.
;F)  USE C.MAC (AND SCNMAC.MAC) FOR ALL BITS AND BYTES INCLUDING THE
;	FILE SPEC AREA.
;G)  HANDLE [,] [P,] [,P] AND [-] NOTATIONS.
;H)  HANDLE + FOR UFDS (DEFICIENCY OF VERSION 1).
;I)  USE PATH. WHERE POSSIBLE FOR SYS:, ETC.
;J)  HANDLE STR, CONTROLLER CLASS, AND CONTROLLER ABBREVIATIONS.
;K)  FLAG FOR CALLER BOTH STRS AND WILD (.WLDFL=-2).
;L)  DO NOT OPEN DATA CHANNEL.
;M)  RETURN LOOKUP BLOCK IN CORE INSTEAD OF ACS.
;N)  ADD ROUTINE (.CHKTM) TO CHECK /BEFORE AND /SINCE SWITCHES.
;O)  DELAY DIRECTORY LOOKUP ERRORS TO END IN CASE SOME OTHER
;	STRUCTURE GETS IT OK.
;P)  MAKE OPEN FAILURE FATAL.  INCLUDE ASSIGNED JOB NUMBER IF KNOWN.
;Q)  ADD SEARCH LIST EMPTY (24) TO STANDARD LOOKUP ERRORS.
;R)  CHKACC DIRECTORIES
;S)  HANDLE SPECIAL DEVICES SUCH AS HLP:, ALL:, SXS:, ETC.

;%2(76) -- 5/72 WITH DIRECT %2.

;77	CORRECT BUG WHEN READING BLOCKS OF THE DIRECTORY.  EXAMINED
;	ONLY 63 FILES PER BLOCK INSTEAD OF 64.

;%3(77) -- 6/72

;100	USE .FX SYMBOLS FROM SCNMAC %3(50)
;101	USE .FXDFX TO FLAG MFD FIXUPS. HANDLE SYS:.UFD
;102	ALLOW REENTRY AFTER NON-DISK DEVICE.
;103	ALLOW FX.ADD OR .FXTRO FOR OR FUNCTION.
;104	ADD DEFENSIVE HALT IN CASE LH(DIRECTORY)=0.  (SPR 10-7182)
;105	REPLACE INTERNS BY :: FLAG.
;106	USE REAL EXTENSION IN LOOKUP ERROR MESSAGE
;107	ADD DTA HANDLING
;110	CORRECT SUBSCRIPTS IN E.DFL ROUTINE
;111	SET /DEN/PAR SWITCHES FOR MTA
;112	CONSIDER /BEFORE AND /SINCE =-1 TO BE ABSENT
;113	[*,NOT *,...] WILL NOT MATCH FOR USER PROJECT GT 7
;		AND TARGET PROJECT LE 7
;114	HANDLE [1,1].UFD CORRECTLY.  THIS ELIMINATES THE OLD NOTATION
;		OF #X0000YY.UFD[1,1]
;115	FIX BUG IN CHKACC LOGIC OF MFD.
;116	FIX BUG IN SYS: INTRODUCED BY 107.
;117	ADD ENTRY .CHKTA FOR DIRECT
;120	INCLUDE "." IN MODULE NAME.
;121	ADD SYMBOLS .WILDZ AND .WILDL FOR START AND LENGTH OF
;	LOW CORE AREA
;122	HANDLE NO MFD MESSAGE GRACEFULLY.

;%4(122) -- 12/72 WITH DIRECT %3

;123	ADD ERROR MESSAGE "NO FILE NAME SPECIFIED".
;124	ADD ROUTINE .SCWLD FOR SECONDARY WILDCARD (E.G., OUTPUT)
;125	SIMPLIFY CHECKS FOR END OF DIRECTORY LIST
;126	CHANGE HALT TO JRST AT WILDK
;127	ADD E.LKEN AND .TFILB AS GENERAL SCAN-STYLE TYPEOUTS
;130	CREATE MODULE\WILDDM
;131	DEFAULT OUTPUT PROTECTION IF TO SAME OWNER AS
;	INPUT FILE IS XYY WHERE X IS SYSTEM FILE PROT AND YY
;	IS COPIED FROM THE INPUT FILE
;132	SUPPORT DATE75
;133	SUPPORT /OKPROT AND /ERPROT.  DEFAULT IS /ERPROT
;	UNLESS WILD UFD.
;134	FIX BUG IN E.LKEN (EDIT 127)
;135	HANDLE NUL: CORRECTLY
;136	(10-10819) REMOVE BUG IN DECTAPE DIRECTORY READ
;137	GET RIGHT DIRECTORY WHEN UFD READ PROTECT. ERROR
;140	PREFIX ALL ERROR MESSAGES WITH WLDXXX
;141	(10-11421) CHECK /STR/PHY ON DIRECTORY MATCHING
;142	CORRECTLY STORE POINTER TO INPUT SPEC FOR CALLER
;%5(142) DEC, 73

;143	CORRECT BUG IN MULTIPLE DIRECTORY WILD-CARD LOGIC
;144	CORRECT SKIP INSTRUCTION ERROR IN DTA DIRECTORY LOGIC
;145	DON'T DELETE ACCESS TABLES IF WE ARE THE OWNER
;146	ADD ENTRY POINTS .INSTR, .NXSTR
;147	CONVERT TO USE C, SCNMAC AS UNIVERSALS
;150	SUPPORT /MESSAGE FROM .GTWCH
;151	MOVE .PTWRD TO .SCAN
;152	SUPPORT /MESSAGE FROM SCAN
;153	(10-12368) HANDLE UFD NAME CORRECTLY AS A FILE
;154	FIX /STRS ON NON-WILD TO GET RIGHT MESSAGE AND DIRECTORY
;155	IF /OKNONE AND NOT WILD, NO ERROR
;156	(10-12368) SUPPORT /SINC/BEFOR ON DTA
;157	ADD OPTION TO .LKWLD TO INDICATE END OF DIRECTORY
;160	ADD OPTION TO .LKWLD TO SCAN DIRECTORIES BEFORE SFD
;161	SUPPORT /ABEFORE/ASINCE/ERSUPERSEDE/LENGTH/ESTIMATE/VERSION
;162	(QAR 1882) FIX 153
;163	MORE 161
;164	MORE 153
;165	MORE 135
;%6(165) JUNE, 1974
;300	SUPPORT OF 'OR', ETC., (ADD FT$COR)
;301	DEFAULT TO /OKPROTECT IF ANY WILDCARDS
;302	ADD ERROR TWC IF TWO MANY WILD-CARDS ON INPUT
;303	IGNORE SINGLE ACCESS F/S IF NOT OWNED BY THIS JOB
;304	WARN WLDAFP IF ALL FILES PROTECTED
;305	WARN WLDAFR IF ALL FILES REJECT CONDITIONS
;306	(10-13,944) FIX TYPO IN MESSAGE
;307	(QAR 2760) ADD WLDSDP
;310	(QAR 2836) BUG IN 304
;311	ADD WLDSFP
	SUBTTL	MISC. DEFINITIONS

;ACCUMULATORS


T1=1	;SCRATCH
T2=2
T3=3
T4=4

P1=5	;INDEX TO COMMAND SCANNER DATA BASE
P2=6	;PRESERVED ACS
P3=7

P=17	;PUSH DOWN LIST

;CHANNELS

WC==0	;CHANNEL FOR DIRECTORY READING
DC==0	;READ DATA (UPDATED BY ARGUMENT)

;FLAGS

DOALDV==1B0	;DO ALL DEVICES
DIRSFD==1B1	;DO DIRECTORY BEFORE SFD
	SUBTTL	INITIALIZE AND PRESET CALL

;HERE ON EXTERNAL CALL

.LKWLD:	MOVEM	P1,SAVEP1	;SAVE POINTER
	HLRZ	T2,T1		;GET LENGTH OF BLOCK
	PUSHJ	P,.GTWRD##	;GET BLOCK+0
	TRNE	T3,-1		;SEE IF END GIVEN
	HRR	T3,(T3)		;YES--GET END OF SPECS
	MOVS	T4,T3		;SWITCH TO START
	HRR	T4,(T4)		;GET START OF SPECS
	TLNN	T4,-1		;SEE IF END SPECIFIED
	HRL	T4,T4		;NO--USE START
	HLRZM	T4,AGLIMS	;STORE END FOR TESTS
	TLZ	T4,-1		;CLEAR JUNK FOR LATER
	PUSH	P,T4		;SAVE AWAY
	PUSHJ	P,.GTWRD	;GET BLOCK+1
	HLRZM	T3,AGOPEN	;SAVE OPEN BLOCK
	HRRZM	T3,AGLOOK	;SAVE LOOKUP BLOCK
	SKIPE	AGOPEN		;PROTECT AGAINST JUNK
	SKIPN	AGLOOK		; ..
	HALT	.+1		;BAD USER CALL
	PUSHJ	P,.GTWRD	;GET BLOCK+2
	HRRZM	T3,AGLENL	;SAVE LENGTH OF LOOKUP BLOCK
	HLRZ	T3,T3		;GET LENGTH OF PARAMETER AREA
	MOVEM	T3,AGLENP	;SAVE FOR LATER
	PUSHJ	P,.GTWRD	;GET BLOCK+3
	HRRZM	T3,AGPNTR	;SAVE LOCATION OF POINTER
	HRRZ	P1,(T3)		;SETUP USER'S POINTER
	MOVEM	T3,AGFLAG	;STORE FLAGS
	HLLZ	T4,T3		;ISOLATE CHANNEL
	TLZ	T4,777760	;REMOVE JUNK
	LSH	T4,5		;POSITION FOR UUOS
	HLLZM	T4,AGDCHN	;SAVE FOR DODCHN ROUTINE
	PUSHJ	P,.GTWRD	;GET BLOCK+4			[157]
	HRRZM	T3,AGEODN	;SAVE FOR DIRECTORY READER	[157]
	POP	P,T4		;RESTORE SPEC POINTER
	SUBTTL	LOOKUP ONE FILE

	JUMPN	P1,[SKIPN NOTDSK ;IF ALREADY SETUP, CONTINUE
		    JRST  WILDN	;WITH DISK
		    MOVE  P1,.WILAS  ;OR AFTER
		    JRST  LOOKST] ; NON-DISK
	MOVX	T1,%LDMFD	;GET LOCATION OF MFD
	GETTAB	T1,		;FROM MONITOR
	  MOVE	T1,[1,,1]	;(LEV C)
	MOVEM	T1,MFDPPN	;SAVE FOR LATER

IFN FT$SFD,<
	SETZM	PTHARG		;CLEAR PATH
	MOVE	T1,[PTHARG,,PTHARG+1]
	BLT	T1,PTHEND	; ..
	MOVE	T1,[PTHLEN-1,,PTHARG]
	SETOM	PTHARG		;-1 MEANS RETURN DEFAULT PATH
	PATH.	T1,		;GET DEFAULT PATH
	  SETZM	PTHARG		;IF ERROR, CLEAR ARGUMENT
>
	GETPPN	T1,		;GET USER'S NUMBER
	  JFCL			;IN CASE OF JACCT
	MOVEM	T1,MYPPN	;STORE FOR LATER
IFN FT$SFD,<
	SKIPN	PTHDIR		;SEE IF PATH. WORKED
	MOVEM	T1,PTHDIR	;NO--SIMULATE IT
>

	SKIPA	P1,T4		;BRAND NEW--GET STARTING POINT

;LOOP OVER EACH FILE SPECIFICATION IN THE REQUEST
; TO FIND ANY AND ALL FILES WHICH MATCH IT

LOOKST:	ADD	P1,AGLENP	;NOT BRAND NEW--ADVANCE PARAMETER
	HRRZM	P1,@AGPNTR	;STORE CURRENT POINTER FOR USER
	CAMG	P1,AGLIMS	;SEE IF AT END YET
	JRST	LOOKGO		;NO--GO DO OUR BIT
	SETO	T1,		;YES--FLAG ALL DONE
	EXCH	P1,SAVEP1	;RESTORE POINTER
	POPJ	P,	

;HERE WHEN AN INPUT REQUEST HAS BEEN SPECIFIED AND SETUP IN P1

LOOKGO:	SETZM	FWAZER		;CLEAR TEMPORARIES
	MOVE	T1,[FWAZER,,FWAZER+1]	; ..
	BLT	T1,LWAZER	; ..
	MOVEM	P1,.WIFIR	;SAVE STARTING BLOCK
;LOOP TO DISCOVER A SET OF CONCATENATED FILE SPECIFICATIONS
;THE USER HAS CONCATENATED THEM TO CAUSE A SINGLE PASS WILD SEARCH.

LOOK1:	MOVEM	P1,.WILAS	;SAVE ENDING BLOCK
	PUSHJ	P,SETDIR	;SETUP DIRECTORY DEFAULTS
	LDB	T1,[POINTR (.FXMOD(P1),FX.TRM)]  ;GET TERMINATION
IFN FT$COR,<
	CAIN	T1,.FXTRC	;IF "+"				[300]
	MOVEI	T1,.FXTRO	; TREAT AS 'OR'			[300]
>
	CAIE	T1,.FXTRA	;IF 'AND'			[300]
	CAIN	T1,.FXTRO	; OR 'OR'			[300]
	JRST	LOOK1A		; CONTINUE IN SET		[300]
	CAIE	T1,.FXTRN	;UNLESS 'NOT'			[300]
	JRST	DIR1		; END SET			[300]
LOOK1A:	MOVE	T1,.FXDEV(P1)	;YES--COMPARE DEVICES
	ADD	P1,AGLENP	;ADVANCE TO NEXT ONE
	CAMG	P1,AGLIMS	;SEE IF OFF END
	CAME	T1,.FXDEV(P1)	;TEST
	JRST	DIR1		;DIFFERENT--IGNORE +
	PUSHJ	P,SETDIR	;SETUP DIRECTORY DEFAULTS
	MOVE	T1,.WIFIR	;SAME--COMPARE DIRECTORY
	MOVE	T2,.FXMOD(T1)	;COMPARE			[141]
	XOR	T2,.FXMOD(P1)	; /PHYSICAL			[141]
	TXNE	T2,FX.STR!FX.PHY ;AND /STR			[141]
	JRST	DIR1		;DIFFERENT--THAT'S ALL		[141]
	MOVE	T2,P1		; ENTRY
	HRLI	T1,-2*.FXLND	; BY
LOOK2:	MOVE	T3,.FXDIR(T2)	; ENTRY
	AOS	T2		; ..
	CAMN	T3,.FXDIR(T1)	; ..
	AOBJN	T1,LOOK2	;LOOP BACK
	JUMPGE	T1,LOOK1	;LOOP IF MATCHED
;HERE WHEN CONCATENATED REQUESTS HAVE BEEN SELECTED TO DETERMINE
; WHAT TYPE OF SEARCHING TO DO ACROSS STRS

DIR1:	MOVE	P1,.WIFIR	;REFETCH POINTER
	MOVX	T1,FX.PHY	;SEE IF USER ASKED FOR PHYS.
	TDNN	T1,.FXMOD(P1)	; ..
	JRST	NOTPHY		;NO--SKIP TESTS
	MOVSI	T1,'SYS'	;YES--SEE IF POSSIBLE
	DEVCHR	T1,UU.PHY	; BY TRYING ONE
	TRNE	T1,-1		;SEE IF GOT SOMETHING BACK
	SETOM	PHYS		;YES--SET FOR PHYS I/O
NOTPHY:	MOVSI	T2,.FXDEV(P1)	;POINT TO ARGUMENT AREA
	HRRI	T2,FSTR		;POINT TO INTERNAL AREA
	BLT	T2,ENDERR	;COPY FOR ANY ERROR MESSAGES

	MOVE	T2,.FXDEV(P1)	;GET NAME
	PUSHJ	P,DOPHYS	;GET PHYSICAL
	  DEVNAM T2,		; DEVICE
	    MOVEI T2,0		; NAME
	HLRZ	T3,T2		;SAVE GENERIC PART
	SYSSTR	T2,		;SEE IF STRUCTURE NAME
	  SKIPA			;NO--OK
	MOVEI	T3,0		;YES--KILL NAME
	MOVE	T2,.FXDEV(P1)	;FIND OUT IF STRUCTURE SEARCH NECESSARY
	PUSHJ	P,DOPHYS	;PERFORM PHYSICAL I/O CALL
	  DEVCHR T2,		;SEE IF DISK TYPE DEVICE
	CAIN	T3,'NUL'	;SEE IF NUL:
	TLO	T2,-1-<(DV.TTA)> ;YES--CHANGE DEVCHR BITS
	MOVEM	T2,DVCH		;SAVE FOR USER
	TLC	T2,-1-<(DV.TTA)> ;BUT NOT
	TLCE	T2,-1-<(DV.TTA)> ; NUL:
	TXNN	T2,DV.DSK	; ..
	SKIPA			;BAD
	JRST	ISDISK		;OK--PROCEED
	SKIPL	AGFLAG		;SEE IF ALL DEVICES TO BE HANDLED
	JRST	[MOVE	T1,T2	;NO--POSITION DEVCHR
		 EXCH	P1,SAVEP1 ;RESTORE P1
		 SETOM	NOTDSK	;SET FLAG
		 POPJ	P,]	;AND RETURN
	MOVX	T3,FX.DIR	;CLEAR
	ANDCAM	T3,.FXMOD(P1)	;  DIRECTORY
	SETZM	.FXDIR(P1)	;CLEAR DIRECTORY
	SETZM	.FXDIM(P1)	; TO AVOID CONFUSION
	TLC	T2,-1-<(DV.TTA)> ;WATCH OUT FOR
	TLCE	T2,-1-<(DV.TTA)> ; NUL:
	TXNN	T2,DV.DTA	;SEE IF DECTAPE
	SKIPA			;NO
	JRST	ISDTA		;YES--GO HANDLE
	SETOM	NOTDSK		;FLAG FOR REENTRY
	JRST	STR7		;GO SETUP OPEN BLOCK
ISDTA:	SETOM	FLDTA		;SET FLAG FOR LATER ON
ISDISK:	SETCM	T1,.FXNMM(P1)	;GET NAME MASK
	IOR	T1,.FXNAM(P1)	;AND NAME
	JUMPE	T1,E$$NFS	;ERROR IF NO NAME SPECIFIED
	HLRZ	T1,.FXEXT(P1)	;GET EXTENSION
	SKIPN	FLDTA		;IF NOT DECTAPE
	CAIE	T1,'UFD'	;AND UFD
	SETCM	T1,.FXNMM(P1)	;CHECK NAME MASK FOR WILDCARD
	JUMPN	T1,SEEIFD	;IF SO, GO DO WILD THINGS
	MOVEI	T2,.FXDIR(P1)	;NO--CHECK DIRECTORY
	HRLI	T2,-.FXLND	;ENTRY BY ENTRY
NOTPH1:	SKIPN	(T2)		;CHECK DIRECTORY
	SKIPE	1(T2)		; AND WILDCARD
	SKIPA			;SOMETHING THERE
	JRST	NOTPH2		;IF NULL, MUST BE DONE
	SETCM	T1,1(T2)	;NO--CHECK DIRECTORY MASK
	JUMPN	T1,SEEIFD	;IF WILD GO SEE IF LEVEL D
	AOS	T2		;ANDVANCE
	AOBJN	T2,NOTPH1	;AND LOOP BACK
NOTPH2:	SETCM	T1,.FXEXT(P1)	;NO--CHECK EXTENSION
	CAMN	P1,.WILAS	;SEE IF CONCATENATION
	TRNE	T1,-1		;TEST EXT. MASK
	JRST	SEEIFD		;WILD--GO SEE IF LEVEL D

;HERE IF NOT A WILD FILE SPECIFICATION

	MOVX	T1,FX.STR	;NOT WILD--SEE IF STR WILD
	TDNE	T1,.FXMOD(P1)	; BEING RQUESTED
	SKIPE	FLDTA		;AND NOT DTA:
	JRST	STR7		;NO--JUST USE USER'S DEVICE
	MOVEI	T1,1		;YES--FLAG STR WILD (BUT NOT FILE)
	JRST	DIR2		;AND GO SELECT A SEARCH LIST

;HERE WHEN THE FILE IS WILD

SEEIFD:	SETOB	T1,.WLDFL	;SET WILD FILE FLAG
	SKIPE	FLDTA		;SEE IF DECTAPE
	JRST	STR7		;YES--NO DIRECTORY JUNK
DIR2:	MOVX	T2,%CNSTS	;SEE IF LEVEL D SYSTEM
	GETTAB	T2,		; ..
	  MOVEI	T2,0		;(NO)
	TXNN	T2,ST%TDS	;TEST FIELD
	JRST	DIR4		;NO--NO FUNNY F/S LOGIC
	MOVEM	T1,.WLDFL	;YES--STORE FILE WILD FLAG
	TXNE	T2,<ST%TDS-1B9>	;SEE IF 5.03 OR LATER
	SETOM	SY2RCH		;YES--SET FLAG THAT REAL SYS: SL IS AVAILABLE

	SETZM	SUBSTR		;INDICATE INTERNAL CALL
	PUSHJ	P,INSTR		;GO INITIALIZE STR SEARCHING
	  HALT	.+1		;NOT A DISK!
	MOVE	P1,.WIFIR	;RESTORE INDEX
	JUMPGE	T1,STR6		;IF NOT SEARCHING, SKIP STR LOGIC
	SKIPGE	.WLDFL		;IF WILD FILES,
	SOS	.WLDFL		;SET FLAG TO -2 TO INDICATE WILD STRS AS WELL
	MOVSI	T1,'SYS'	;SEE IF PHYSICAL IS POSSIBLE
	DEVCHR	T1,UU.PHY	;BY TRYING A DEVICE KNOWN TO EXIST
	TRNE	T1,-1		;IF IT WORKED,
	SETOM	PHYS		;  FORCE PHYSICAL SINCE STR NAMES
				;  SHOULD NOT BE TRANSFORMED
	JRST	STR1		;GO GET A STRUCTURE
;HERE IF LEVEL-C WILDCARD INDICATED
;NEED TO CHECK FOR "SYS:" AND FIXUP DIRECTORY IF SO

DIR4:	MOVS	T1,FSTR		;GET DEVICE
	CAIN	T1,'SYS'	;SEE IF "SYS:"
	PUSHJ	P,SETSYS	;YES--SETUP FOR SYS:
	JRST	STR7		;PROCEED WITHOUT F/S LOGIC

;BACK HERE TO PROCEED TO NEXT STRUCTURE

STR1:	MOVE	P1,.WIFIR	;RESET INDEX
	PUSHJ	P,.NXSTR	;GET NEXT STRUCTURE
	JUMPE	T1,LOOKEN	;IF DONE, GO TO NEXT REQUEST
	JRST	STR7		;GO PROCESS THIS STRUCTURE

;HERE WHEN NO NEED TO SEARCH STRUCTURES

STR6:	SKIPL	.WLDFL		;SEE IF WILD FILE FLAG
	SETZM	.WLDFL		;YES--CLEAR WILD CARD INDICATOR

;HERE TO START ONE DEVICE (FILE STRUCTURE)

STR7:	AOS	NOSTRS		;COUNT STR SELECTED
	PUSHJ	P,SETOPN	;SETUP AN OPEN BLOCK
	MOVE	T4,DVCH		;GET DEVICE CHARS
	TLC	T4,-1-<(DV.TTA)> ;SEE IF NUL:
	TLCE	T4,-1-<(DV.TTA)> ;IF SO, NOT MAG TAPE
	TXNN	T4,DV.MTA	;XEE IF MAG TAPE
	JRST	NOTMTA		;NO--PROCEED
	MOVX	T4,FX.PAR	;GET BIT FOR TEST
	TDNE	T4,.FXMOD(P1)	;SEE IF /PAR:EVEN
	TXO	T1,IO.PAR	;YES--SET INTO OPEN
	LDB	T4,[POINTR (.FXMOD(P1),FX.DEN)] ;GET /DEN
	DPB	T4,[POINTR (T1,IO.DEN)] ;SET INTO OPEN
NOTMTA:	MOVE	T4,AGOPEN	;POINT TO USER AREA
	MOVEM	T1,(T4)		;STORE PHYSICAL BIT, ETC.
	MOVEM	T2,1(T4)	;STORE DEVICE NAME
	MOVEI	T3,B.DC		;POINT TO BUFFER HEADER FOR INPUT
	MOVEM	T3,2(T4)	;STORE FOR USER
	SKIPE	NOTDSK		;SEE IF NOT DIRECTORY
	JRST	UFD6		;RIGHT--GO GIVE ANSWERS
	SETZB	T4,DEPTH	;CLEAR DEPTH OF NEST
	JRST	WILDSN		;GO START A NEW UFD
;BACK HERE TO GET NEXT FILE IN THIS DIRECTORY

WILDN:	MOVE	P1,.WIFIR	;RESET SPEC POINTER
	MOVE	T4,DEPTH	;SET INDEX TO TABLES
	SETZB	T3,DIRBU(T4)	;CLEAR DIRECTORY AT THIS LEVEL
	LSH	T4,1		;GET DOUBLE WORD POINTER
	SETZM	UFDPPN(T4)	;CLEAR ERROR MESSAGE STORAGE
	SETZM	UFDPPN+1(T4)	;  AND ITS MASK
	LSH	T4,-1		;REPOSITION COUNTER
	SKIPG	DIRSTI(T4)	;SEE IF WILD AT THIS LEVEL
	JRST	WILDE		;NO--PRETEND EOF THIS DIRECTORY
	SKIPE	DIRFLG		;SEE IF DIRECTORY BEING REPEATED
	JRST	WILDP		;YES--DON'T ADVANCE BUFFER
	SOSGE	BUFCNT(T4)	;COUNT DOWN FILES IN THIS BLOCK
	JRST	WILDR		;NON LEFT--GO READ NEXT BLOCK
	MOVEI	T3,2		;OK--ADVANCE TWO WORDS
	SKIPE	FLDTA		;SEE IF DECTAPE
	MOVEI	T3,1		;YES--ADVANCE ONE WORD
WILDP:	ADDB	T3,BUFPOS(T4)	;NOTE NEW POSITION
	SKIPE	FLDTA		;SEE IF DECTAPE
	ADDI	T3,^D84		;POSITION TO FILE NAME
	MOVE	T1,.WLDBF-2(T3)  ;GET FILE NAME
	JUMPE	T1,WILDN	;NULL--LOOP FOR NEXT FILE
	SKIPE	FLDTA		;SEE IF DECTAPE
	ADDI	T3,^D21		;POINT TO EXTENSION
	HLRZ	T2,.WLDBF-1(T3)  ;GET EXTENSION
	SKIPE	FLDTA		;SEE IF DECTAPE
	JRST	WILDF		;YES--NO DIRECTORY JUNK
	CAIN	T2,'SFD'	;SEE IF SUB-FILE DIRECTORY
	JUMPN	T4,WILDS	;YES--GO HANDLE
	SKIPGE	FNDSFD(T4)	;IF REPEATING FOR SFD'S		[160]
	JRST	WILDN		; IGNORE ALL OTHER FILES	[160]
	CAIN	T2,'UFD'	;SEE IF DIRECTORY
	JUMPE	T4,WILDU	;YES--GO HANDLE
WILDF:	LSH	T4,1		;DOUBLE DEPTH
	ADDI	T4,(P1)		;POINT TO INPUT SPEC
	SKIPE	T3,.FXDIM(T4)	;GET DIRECTORY MASK		[143]
	JRST	WILDN		;NO--NO FILE ALLOWED HERE
;HERE WHEN FOUND A POSSIBLE FILE--SEE IF IT MATCHES
	AOS	NOFIL		;COUNT FILE AS SEEN
WILDC:	MOVE	T3,T1		;GET THIS FILE
	XOR	T3,.FXNAM(P1)	;COMPARE
	HRLZ	T4,T2		;GET THIS EXT
	XOR	T4,.FXEXT(P1)	;COMPARE,,FETCH MASK
	TDNN	T3,.FXNMM(P1)	;CHECK NAME
	TLNE	T4,(T4)		;CHECK EXT
	JRST	WILDCP		;FAIL--GO LOOP
	JRST	UFD7		;WIN--GO GIVE ANSWER TO USER
WILDCP:	ADD	P1,AGLENP	;ADVANCE SPEC POINTER
	CAMG	P1,.WILAS	;SEE IF STILL IN RANGE
	JRST	WILDC		;YES--GO BACK AND CHECK
	JRST	WILDN		;NO--GO GET NEXT FILE

;BACK HERE WHEN NEW DIRECTORY AND NO WILDCARD NEEDED
WILDNW:	SKIPN	DEPTH		;IF TOP LEVEL,			[154]
	SKIPN	T1,FRCPPN	; AND NOT FORCING DIRECTORY	[154]
	MOVE	T1,.FXDIR(T3)	;GET NAME
	SETOM	DIRSTI(T4)	;SET -1 FOR NO-WILD FLAG
	MOVE	T4,T3		;SETUP INDEX TO ARGS
	JRST	WILDK		;GO HANDLE DIRECTORY
;HERE WHEN UFD OR SFD SEEN IN SCANNING THE DIRECTORIES

WILDS:	SKIPL	FNDSFD(T4)	;UNLESS SFD SECOND PASS,	[160]
	SKIPE	DIRFLG		;SEE IF DIRECTORY REPEATED
	JRST	WILDL		;YES--HANDLE AS DIRECTORY NOW
	MOVX	T3,DIRSFD	;SEE IF USER WANTS SFD LATER	[160]
	TDNE	T3,AGFLAG	; (IT'S SLOWER)			[160]
	JRST	[AOS   FNDSFD(T4) ;YES--INDICATE ONE FOUND	[160]
		 JRST  WILDF]	;AND DO THIS AS FILE NOW	[160]
	SETOM	DIRFLG		;NOT YET--SET FLAG
	JRST	WILDF		;AND HANDLE AS FILE FIRST
WILDU:
WILDL:	SETZM	DIRFLG		;CLEAR DIRECTORY FLAG
	LSH	T4,1		;DOUBLE DEPTH INDEX
	ADDI	T4,(P1)		;POINT TO INPUT SPEC
WILDK:	SKIPN	DEPTH		;SEE IF TOP LEVEL		[154]
	SKIPN	T3,FRCPPN	;YES--SEE IF FORCING PPN	[154]
	MOVE	T3,.FXDIR(T4)	;NO--GET THIS DIRECTORY IN REQUEST
	JUMPE	T3,WILDN	;NO--GO HANDLE AS FILE

	TLNN	T1,-1		;SEE IF LH=0
	JRST	WILDN		;YES--CAN'T HAPPEN UNLESS MONITOR ERROR
	MOVE	T3,DEPTH	;YES--GET DEPTH OF OUR WORK
	MOVEM	T1,DIRBU(T3)	;SAVE DIRECTORY NAME
	LSH	T3,1		;DOUBLE POINTER
	MOVEM	T1,UFDPPN(T3)	;STORE FOR POSSIBLE ERROR MESSAGE
	SETOM	UFDPPN+1(T3)	;SET MASK ON FULL
	SKIPN	DEPTH		;SEE IF TOP LEVEL		[154]
	SKIPN	FRCPPN		;YES--SEE IF FORCING PPN	[154]
	SKIPA			;NO				[154]
	JRST	WILDJ		;YES--MATCH			[154]
	XOR	T1,.FXDIR(T4)	;COMPARE TO REQUEST
	TDNE	T1,.FXDIM(T4)	;SEE IF MATCH
	JRST	WILDN		;NO--GO TRY AGAIN
	JUMPN	T3,WILDJ	;SEE IF UFD
	SKIPE	T1,.FXDIM(T4)	;YES--SEE IF [*,NOT*]
	TLNE	T1,-1		; ..
	JRST	WILDJ		;NO--OK TO PROCEED
	MOVE	T1,MYPPN	;YES--GET OUR NUMBER
	MOVE	T2,UFDPPN	;AND TARGET NUMBER
	TLNE	T1,777770	;SEE IF WE ARE GT PROJ 7
	TLNE	T2,777770	;AND TARGET IS LE PROJ 7
	JRST	WILDJ		;NO--PROCEED
	JRST	WILDN		;YES--SKIP MATCH SINCE THIS
				; IS TO A SYSTEM FILE FROM USER
WILDJ:	AOS	T4,DEPTH	;LOOKS GOOD--ADVANCE DEPTH OF SEARCH
	CAIG	T4,.FXLND	;SEE IF TOO DEEP
	JRST	WILDSN		;NO--PROCEED
	SOS	DEPTH		;YES--BACK UP
	JRST	WILDN		;AND TRY AGAIN
;HERE WHEN NEW DIRECTORY SELECTED

WILDSN:	MOVEI	T3,(T4)		;GET DEPTH
	LSH	T3,1		;DOUBLE IT
	ADDI	T3,(P1)		;POINT TO INPUT SPEC
	SKIPE	T4		;SEE IF LOWER LEVEL		[154]
	SKIPN	FRCPPN		;YES--SEE IF FORCED PPN		[154]
	CAIN	T4,.FXLND	;NO--SEE IF LIMIT OF DIRECTORY	[154]
	JRST	WILDSG		;YES--GO WITH MATCH		[154]
	SKIPE	FRCPPN		;IF PPN FORCED,			[154]
	JRST	WILDNW		;  TREAT AS NO WILD-CARDS	[154]
	SETCM	T2,.FXDIM(T3)	;GET MASK
	JUMPE	T2,WILDNW	;IF NO WILD CARD, GO DOWN ONE LEVEL
	SKIPE	.FXDIR(T3)	;  OF REQUESTED DIRS.
	JRST	WILDD		;NO--SKIP ON
WILDSG:	AOS	NOUFDF		;YES--COUNT DIRECTORY AS FOUND
	AOS	NSUFD		;PRECOUNT SUCCESSFUL LOOKUP
	SKIPL	.WLDFL		;SEE IF WILD FILE NAME
	JRST	UFD6		;NO--GIVE TO CALLER
WILDD:	SETZM	DIRSTI(T4)	;CLEAR USETI POINTER

;HERE WHEN TIME TO READ NEXT BLOCK OF A DIRECTORY

WILDR:	MOVEI	T1,100		;SET FOR 100
	SKIPE	FLDTA		;SEE IF DECTAPE
	MOVEI	T1,^D22		;YES--ONLY 22 FILES
	MOVEM	T1,BUFCNT(T4)	;  FILES IN A BLOCK
	SETZM	BUFPOS(T4)	;CLEAR POSITION IN BLOCK
WILDRR:	PUSHJ	P,SETOPN	;SETUP OPEN BLOCK
	HRRI	T1,.IODMP	;READ IN DUMP MODE
	SKIPE	FLDTA		;SEE IF DECTAPE			[136,144]
	TXO	T1,IO.NSD!IO.SSD  ;YES--SET SEMI-STANDARD MODE	[136]
	OPEN	WC,T1		;OPEN WILD CHANNEL
	  JRST	E.UFO		;ERROR--GO ISSUE MESSAGE
	SKIPN	FLDTA		;SEE IF DECTAPE
	JRST	WILDRD		;NO--CHECK DIRECTORY
	SKIPE	DIRSTI		;SEE IF FIRST TIME HERE
	JRST	WILDE		;NO--GO HANDLE AS EOF
	MOVEI	T1,^D100	;SET FOR DECTAPE POSITION
	MOVEM	T1,DIRSTI	;FLAG FOR NEXT TIME
	JRST	WILDRI		;GO READ BUFFER
WILDRD:	SETZM	DIRBU-1		;ALWAYS CLEAR SWITCHES (AND MFD)
	MOVE	T1,DIRBU-1(T4)	;GET THIS DIRECTORY'S NAME
	SETZM	DIRBU-1(T4)	;CLEAR DIRECTORY
	CAIG	T4,1		;SEE IF UFD
	JRST	WILDRM		;YES--GO HANDLE IT
	MOVSI	T2,'SFD'	;SET FOR SFD
	MOVEI	T4,DIRB		;POINT TO PATH
	MOVEI	T3,1		;INDICATE NO
	MOVEM	T3,DIRBS	;  DIRECTORY SCANNING
	SKIPN	DIRBU+1		;SEE IF FIRST SFD
	MOVE	T4,DIRBU	;YES--GET UFD
	JRST	WILDRL		;GO LOOKUP DIRECTORY
WILDRM:	MOVSI	T2,'UFD'	;SET UFD
	MOVE	T4,MFDPPN	;SET MFD
	SKIPN	T1		;SEE IF TOP LEVEL
	MOVE	T1,T4		;YES--READ MFD ITSELF
WILDRL:	MOVEI	T3,0		;CLEAR E+2
	LOOKUP	WC,T1		;LOOKUP DIRECTORY
	  JRST	E.UFL		;ERROR--GO GIVE MESSAGE
	SETZM	DIRBU-1		;CLEAR SWITCHES (AND MFD)
	SKIPE	T4,DEPTH	;RESTORE DEPTH
	MOVEM	T1,DIRBU-1(T4)	;SET DIRECTORY
	HLRZ	T1,T3		;GET PROTECTION CODE
	ANDI	T1,(RB.PRV)	;CLEAR TO JUST DIRECT. PROT.
	HRLI	T1,.ACSRC	;SET SEARCH DIRECTORY FUNCTION
	MOVE	T3,MYPPN	;GET USER'S NUMBER
	SKIPN	T2,DIRBU	;GET DIRECTORY OWNER
	MOVE	T2,MFDPPN	;IF MFD, USE MFD NUMBER
	MOVEI	T4,T1		;POINT TO ARGS
	CHKACC	T4,		;CHECK ACCESS RIGHTS
	  MOVEI	T4,0		;(ASSUME OK)
	MOVEI	T2,ERPRT%	;SET PROTECTION ERROR JUST IN CASE
	HRLZ	T3,T1		;RESTORE PROTECTION JUST IN CASE
	JUMPN	T4,E.UFL1	;GIVE ERROR IF NOT PERMITTED

	MOVE	T4,DEPTH	;RESTORE DEPTH INDEX
	AOS	T1,DIRSTI(T4)	;ADVANCE BLOCK COUNT
	CAILE	T1,1
WILDRI:	USETI	WC,(T1)		;POSITION FILE
	MOVE	T1,[-200,,.WLDBF-1]
	MOVEI	T2,0		;SETUP DUMP LIST
	IN	WC,T1		;READ BUFFER
	  JRST	WILDRK		;OK
	STATZ	WC,IO.ERR	;SEE IF ANY ERRORS
	  PUSHJ	P,E.UFE		;YES--GO TELL USER
	STATO	WC,IO.EOF	;SEE IF END OF FILE
	  JRST	WILDRK		;NO--PROCEED WITH THIS BLOCK
;HERE AT END OF FILE IN A DIRECTORY

WILDE:	MOVEI	T1,CL.ACS	;DON'T UPDATE ACCESS DATE	[145]
	MOVE	T2,DIRBU	;IDENTIFY OWNER			[145]
	CAME	T2,MYPPN	;SEE IF SELF			[145]
	TRO	T1,CL.DAT	;NO--DELETE ACCESS TABLE	[145]
	CLOSE	WC,(T1)		;CLOSE DELETING ACCESS TABLES	[145]
	RELEAS	WC,		;RELEASE CHANNEL
	MOVE	P1,SAVEP1	;RESTORE AC			[157]
	SKIPE	AGEODN		;SEE IF USER WANTS TO HEAR	[157]
	PUSHJ	P,@AGEODN	; AT EO DIRECTORY		[157]
	MOVE	P1,.WIFIR	;RESTORE INDEX			[157]
	MOVE	T4,DEPTH	;GET DEPTH AS INDEX		[160]
	SKIPE	T1,FNDSFD(T4)	;SEE IF NEED SECOND PASS FOR SFD [160]
	JRST	[SETZM FNDSFD(T4) ;YES--INDICATE DONE		[160]
		 JUMPL T1,.+1	;IF END OF SECOND PASS, DONE	[160]
		 SETOM FNDSFD(T4) ;ELSE, FLAG FOR SECOND PASS	[160]
		 JRST  WILDD]	;AND DO SECOND PASS		[160]
	SOSGE	T4,DEPTH	;BACK OFF DEPTH
	JRST	STR1		;DONE WITH MFD--GO TO NEXT STR
	SETZM	DIRBU(T4)	;CLEAR DIRECTORY ENTRY
	SOSL	DIRSTI(T4)	;BACKUP BUFFER INDEX(TO FILE)
	JRST	WILDRR		;AND RE-READ BUFFER
	JRST	WILDN		;NOT WILD--GO UP AGAIN

;HERE WHEN BLOCK READ

WILDRK:	CLOSE	WC,CL.ACS	;DON'T UPDATE ACCESS DATES
	RELEAS	WC,
	JRST	WILDN		;AND GO READ FOR FILES
;HERE  WHEN FILE PRESUMED (NO WILD CARD)
UFD6:	MOVE	T1,.FXNAM(P1)	;GET USER'S NAME
	HLRZ	T2,.FXEXT(P1)	;AND EXTENSION
	AOS	NOFIL		;COUNT FILE SEEN
;HERE WHEN A FILE IS FOUND
;SETUP ANSWER BLOCK FOR CALLING PROGRAM

UFD7:	AOS	NOFILF		;COUNT FILE FOUND
	MOVEM	T1,FNAM		;SAVE FILE NAME
	HRLZM	T2,FEXT		;SAVE FILE EXTENSION
	MOVE	T2,AGLENL	;GET LENGTH OF LOOKUP BLOCK
	MOVE	T1,AGLOOK	;GET START OF LOOKUP BLOCK
	MOVEI	T3,-1(T2)	;SET LENGTH IN BLOCK
	PUSHJ	P,.PTWRD##	;STORE IN BLOCK+0
IFE FT$SFD,<
	MOVE	T3,UFDPPN
>
IFN FT$SFD,<
	SKIPN	DIRBU+1		;SEE IF PATH NEEDED
	SKIPA	T3,DIRBU	;NO--GET UFD
	MOVEI	T3,DIRB		;YES--SETUP POINTER
>
	JUMPN	T3,UFD8		;IF DIRECTORY SETUP, PROCEED
	MOVX	T4,FX.DIR	;SEE IF USER SAID NO DIRECT.
	TDNE	T4,.FXMOD(P1)	; ...
	MOVE	T3,MFDPPN	;NO--SO MUST BE MFD
UFD8:	MOVE	T4,T3		;SAVE FOR LATER
	PUSHJ	P,.PTWRD##	;STORE IN BLOCK+1
	MOVE	T3,FNAM		;GET FILE NAME
	PUSHJ	P,.PTWRD##	;STORE IN BLOCK+2
	HLLZ	T3,FEXT		;GET EXTENSION
	PUSHJ	P,.PTWRD##	;STORE IN BLOCK+3
	MOVEI	T3,0		;CLEAR PRIV WORD
	PUSHJ	P,.PTWRD##	;STORE IN BLOCK+4
	MOVE	T3,T4		;GET DIRECTORY AGAIN FOR LEVEL C
	PUSHJ	P,.PTWRD##	;STORE IN BLOCK+5
	MOVEI	T3,0		;ZERO ALL THE REST
	PUSHJ	P,.PTWRD##	;STORE IN BLOCK+6, ETC.
	JUMPG	T2,.-1		;LOOP UNTIL DONE
	MOVEM	P1,@AGPNTR	;UPDATE ARG POINTER FOR CALLER	[142]
	EXCH	P1,SAVEP1	;RESTORE ARGUMENT
	SETCM	T2,FLDTA	;GET -1 IF DISK, 0 IF DECTAPE
	SKIPE	NOTDSK		;SEE IF NOT DIRECTORY DEVICE
	MOVEI	T2,1		;RIGHT--SET FLAG
	MOVE	T1,DVCH		;RESTORE DEVICE CHARS.
	JRST	CPOPJ1		;RETURN SUCCESSFULLY
;.CHKTM -- SUBROUTINE TO CHECK CREATION DATE/TIME OF FILE
;	AGAINST /BEFORE AND /SINCE SWITCHES
;	FOR DISK FILES, IT ALSO CHECKS /ABEFORE/ASINCE
;	AGAINST ACCESS DATE AND /LENGTH AGAINST FILE LENGTH
;.CHKTA -- DITTO EXCEPT TESTS FOR ANY DEVICE
;CALL:	(AFTER LOOKUP AFTER LAST RETURN FROM .LKWLD)
;	PUSHJ	P,.CHKTM
;	  RETURN IF TOO OLD OR TOO YOUNG
;	RETURN IF OK
;USES T1-4

.CHKTM::SKIPE	NOTDSK		;SEE IF NONDIRECTORY
	SKIPE	FLDTA		; AND NOT DECTAPE		[156]
	SKIPA			;OK--GO DO			[156]
	JRST	CPOPJ1		;YES--ASSUME OK
.CHKTA::MOVE	T1,AGLOOK	;GET POINTER TO LOOKUP BLOCK
	MOVE	T2,.RBPRV(T1)	;CREATION TIME/DATE MUST EXIST
	LDB	T3,[POINTR (.RBEXT(T1),RB.CRX)]
	LSH	T3,WID(RB.CRD)	;GET EXTENSION OF CREATION DATE
	SKIPE	FLDTA		;IF DECTAPE,			[156]
	TDZA	T1,T1		; NO CREATION TIME		[156]
	LDB	T1,[POINTR (T2,RB.CRT)]  ;GET CREATION TIME
	IMULI	T1,^D60000	;CONVERT TO MILLI-SEC.
	ANDI	T2,RB.CRD	;MASK DATE
	ADD	T2,T3		;COMBINE WITH DATE EXTENSION
	PUSHJ	P,.CNVDT##	;CONVERT TO INTERNAL FORMAT
	MOVEM	T1,FLCRDT	;STORE FOR LOOP			[300]
	MOVE	T1,AGLOOK	;POINT TO LOOKUP BLOCK		[300]
	MOVE	T2,.RBEXT(T1)	;GET ACCESS DATE		[161]
	ANDX	T2,RB.ACD	;REMOVE JUNK			[161]
	MOVEI	T1,0		;CLEAR TIME			[161]
	PUSHJ	P,.CNVDT##	;CONVERT TO INTERNAL FORMAT	[161]
	MOVEM	T1,FLACDT	;STORE FOR LOOP			[300]

;LOOP OVER EACH SPEC IN THE CONCATENATED SET LOOKING FOR MATCH

	MOVE	T4,.WIFIR	;START AT START			[300]
;HERE WHEN WINNING SO FAR

CHKTML:	PUSHJ	P,CHKTST	;TEST NEXT SPEC FOR MATCH
	  JRST	CHKTMB		;NO--BAD MATCH
CHKTMD:	LDB	T1,[POINTR (.FXMOD(T4),FX.TRM)] ;GET TERMINATOR
	JRST	@[CPOPJ1	;END--WIN BIG
		  CHKTMC	;'AND'--NEXT MUST ALSO WIN
		  CPOPJ1	;'OR'--WIN BIG
		  CHKTMN	;'NOT'--NEXT MUST NOT WIN
		  CPOPJ1	;+ (INDEPENDENT OF FT$COR)--WIN BIG
		  CPOPJ1	; (5)--ASSUME WIN BIG
		  CPOPJ1	; (6)--ASSUME WIN BIG
		  CPOPJ1](T1)	; (7)--ASSUME WIN BIG

;HERE WHEN OK SO FAR, THEN 'NOT'

CHKTMN:	PUSHJ	P,CHKTAD	;ADVANCE TO NEXT SPEC
	  JRST	CPOPJ1		;NOT THERE!--ASSUME BIG WIN
	PUSHJ	P,CHKTST	;TEST FOR MATCH
	  JRST	CHKTMD		;NO--PROCEED TO NEXT BASED ON SEPARATOR

;HERE WHEN LOST--MUST WAIT FOR NEXT 'OR' TO WIN

CHKTMB:	LDB	T1,[POINTR (.FXMOD(T4),FX.TRM)] ;GET TERMINATOR
	JRST	@[CHKTMF	;END--LOOSE BIG
		  CHKTMS	;'AND'--SKIP ON
		  CHKTMC	;'OR'--START MATCHING OVER
		  CHKTMS	;'NOT'--SKIP ON
		  CHKTMP	; + --DEPENDS ON FT$COR
		  CHKTMF	; (5)--ASSUME LOOSE BIG
		  CHKTMF	; (6)--ASSUME LOOSE BIG
		  CHKTMF](T1)	; (7)--ASSUME LOOSE BIG

;HERE WHEN SKIPPING TO NEXT 'OR' BECAUSE LOOSING

CHKTMS:	PUSHJ	P,CHKTAD	;ADVANCE TO NEXT SPEC
	  JRST	CHKTMF		;IF DONE, LOOSE BIG
	JRST	CHKTMB		;IF SOMETHING, REDISPATCH

;HERE WHEN WINNING AND 'AND' ENCOUNTERED

CHKTMC:	PUSHJ	P,CHKTAD	;ADVANCE TO NEXT
	  JRST	CPOPJ1		;IF DONE, ASSUME WIN BIG
	JRST	CHKTML		;THEN GO TEST THIS ALSO

;HERE IF TOO OLD OR TOO YOUNG
;	BACK DOWN SUCCESS COUNTER

CHKTMF:	SOS	NOFILF		;DECREMENT SUCCESS COUNTER
	AOS	NOFILR		;COUNT REJECTED FILE		[305]
	POPJ	P,		;GIVE BAD NEWS TO CALLER

;DEFINE + BEHAVIOUR
IFN FT$COR,<CHKTMP==CHKTMC>
IFE FT$COR,<CHKTMP==CHKTMF>
;CHKTST -- CHECK TO SEE IF CURRENT SPEC MATCHES FILE
;CALL:	MOVE	T4,ADDR OF SPEC
;	PUSHJ	P,CHKTST
;	NON-SKIP IF NO MATCH
;	SKIP IF MATCH
;USES T1-3

CHKTST:	MOVE	T3,AGLOOK	;GET RIB POINTER		[161]
	HLLZ	T2,.RBEXT(T3)	;GET EXTENSION
	XOR	T2,.FXEXT(T4)	;COMPARE TO MATCH
	MOVX	T1,FX.NUL	;IF USER OMITTED THE
	TDNE	T1,.FXMOD(T4)	; EXTENSION, THEN
	TLZ	T2,-1		; IGNORE IT IN TEST
	MOVE	T1,.RBNAM(T3)	;GET FILE NAME
	XOR	T1,.FXNAM(T4)	;COMPARE TO MATCH
	TDNN	T1,.FXNMM(T4)	;TEST AGAINST MASK
	TLNE	T2,(T2)		;TEST AGAINST MASK
	POPJ	P,		;NO--FAIL

	SKIPE	T1,.RBPPN(T3)	;GET DIRECTORY
	CAMN	T1,FRCPPN	;SEE IF BEING FORCED
	JRST	CHKTS1		;NONE OR FORCED--ASSUME MATCH DIRECTORY
	SKIPE	FRCPPN		;SEE IF FORCING
	POPJ	P,		;YES--DIDN'T MATCH SO REJECT
	SKIPN	.FXDIR(T4)	;SEE IF LEFT AT [-]
	JRST	CHKTS1		;YES--ASSUME MATCH
IFN FT$SFD,<
	TLNE	T1,-1		;SEE IF SFD
	JRST	CHKTSU		;NO--JUST CHECK UFD
	MOVEI	T2,(T4)		;GET COPY OF SPEC POINTER
	HRLI	T1,-.FXLND	;PROTECT END
CHKTSS:	MOVE	T3,.PTPPN(T1)	;GET SFD DIRECTORY
	XOR	T3,.FXDIR(T2)	;COMPARE TO SPEC
	SKIPN	.FXDIR(T2)	;SEE IF MATCH =0
	SKIPN	T3		;YES--ERROR IF VALUE NOT 0
	TDNE	T3,.FXDIM(T2)	;TEST MASK
	POPJ	P,		;ERROR IF NOT MATCH
	SKIPN	.PTPPN(T1)	;SEE IF END
	JRST	CHKTS1		;YES--WIN ON DIRECTORY
	ADDI	T2,2		;ADVANCE SPEC BIWORD
	AOBJN	T1,CHKTSS	;LOOP OVER DIRECTORY
	JRST	CHKTS1		;WIN IF ALL MATCH
>
CHKTSU:	XOR	T1,.FXDIR(T4)	;MATCH UFD
IFN FT$SFD,<
	SKIPE	.FXDIR+2(T4)	; (MAKE SURE
	SKIPN	.FXDIM+2(T4)	;   SFDS)
>
	TDNE	T1,.FXDIM(T4)	;TEST MASK
	POPJ	P,		;FAIL IF BAD
;NOW TEST SWITCHES

CHKTS1:	MOVE	T2,AGLENP	;GET BLOCK LENGTH		[161]
	MOVE	T1,FLCRDT	;GET CREATION DATE-TIME	[300]
	SKIPLE	.FXBFR(T4)	;SEE IF /BEFORE GIVEN
	CAMG	T1,.FXBFR(T4)	;YES--SEE IF TOO YOUNG
	CAMGE	T1,.FXSNC(T4)	;SEE IF TOO OLD
	POPJ	P,		;NO--REJECT

	CAILE	T2,.FXASN	;SEE IF INCLUDES /ASINCE/ABEFORE	[161]
	SKIPE	FLDTA		; AND IF DISK			[161]
	JRST	CPOPJ1		;NO--ALL DONE WITH TESTS	[161]
	MOVE	T1,FLACDT	;GET ACCESS DATE		[300]
	SKIPLE	.FXABF(T4)	;SEE IF /ABEFORE		[161]
	CAMG	T1,.FXABF(T4)	;YES--SEE IF OK			[161]
	CAMGE	T1,.FXASN(T4)	;OK--COMPARE TO /ASINCE		[161]
	POPJ	P,		;BAD--REJECT			[161]
	MOVE	T3,AGLOOK	;GET POINTER TO FILE SPEC
	SKIPL	T1,.RBSIZ(T3)	;IF FILE LENGTH SET,		[161]
	CAIG	T2,.FXFLM	; AND SCAN INCLUDES /LENGTH,	[161]
	JRST	CPOPJ1		;NO--ACCEPT AS OK		[161]
	SKIPL	.FXFLM(T4)	;SEE IF MAX SET			[161]
	CAMG	T1,.FXFLM(T4)	;YES--COMPARE			[161]
	CAMGE	T1,.FXFLI(T4)	;CHECK MIN			[161]
	POPJ	P,		;BAD--REJECT FILE		[161]
	JRST	CPOPJ1		;JUST RIGHT--GIVE OK RETURN

;CHKTAD -- ROUTINE TO ADVANCE WITHIN A CONCATENATED SPEC
;	MAINTAINS T4 AND AGPNTR

CHKTAD:	ADD	T4,AGLENP	;ADVANCE TO NEXT SPEC
	CAMG	T4,.WILAS	;SEE IF DONE
	AOSA	(P)		;NO--SKIP RETURN
	MOVE	T4,.WIFIR	;YES--GET CLEAN POINTER
	MOVEM	T4,@AGPNTR	;STORE POINTER
	POPJ	P,		;RETURN
;HERE AT END OF A REQUEST TO SEE IF ANYTHING WAS FOUND
;IF NOT, AN APPROPRIATE ERROR MESSAGE WILL BE TYPED

LOOKEN:	MOVX	T1,FX.NOM	;SEE IF WE CARE IF ANY MATCHED
	TDNE	T1,.FXMOD(P1)	; ..
	JRST	LOOKNY		;NO--NO WARNINGS AT ALL		[311]
	HRLZI	T1,.FXDEV(P1)	;COPY ORIGINAL REQUEST
	HRRI	T1,FSTR		;  INTO ANSWER AREA
	BLT	T1,ENDERR	;  FOR TYPE OUT
	SKIPE	NOFILF		;SEE IF ANYTHING FOUND
	JRST	[SKIPN NOFILP	;YES--SEE IF ANY FILES OR	[311]
		 SKIPE NODIRP	; DIRECTORIES PROTECTED		[311]
		 JRST  E$$SFP	;YES--WARN USER			[311]
		 JRST  LOOKNY]	;NO--JUST EXIT NORMALLY		[311]
	SKIPE	NOFILR		;SEE IF REJECTIONS		[305]
	JRST	E$$AFR		;YES--INDICATE THAT		[305]
	SKIPE	NODIRP		;SEE IF DIRECTORY PROT FAILURE	[307]
	JRST	E$$SDP		;YES--ISSUE ERROR		[307]
	SKIPE	NOFILP		;SEE IF PROTECT. FAILURES	[304]
	JRST	E$$AFP		;YES--ISSUE ERROR		[304]
	SKIPE	NOFIL		;NO--SEE IF ANY FILES EXAMINED
	JRST	E$$NSF		;YES--JUST NO SUCH FILES
	SKIPE	NOUFDF		;NO--SEE IF ANY DIRECTORIES MATCHED
	JRST	E.DEM		;YES--DIRECTORY EMPTY
	SKIPE	T2,LASERR	;SEE IF ANY ERRORS LEFT LYING AROUND
	JRST	DLYERR		;YES--GO GIVE THEM AS EXPLANATION
	SKIPE	NOSTRS		;SEE IF ANY STRUCTURES FOUND
	JRST	E$$NSD		;YES--JUST NO SUCH DIRECTORY

;ERROR:	SEARCH LIST IS EMPTY

E$$SLE:	MOVE	T1,['SLE',,[ASCIZ /Search list empty for device /]]
	PUSHJ	P,WLDWRN	;ISSUE WARNING MESSAGE
	  JRST	LOOKNX		;SKIP REST IF NOT /VERB:FIRST
	PUSHJ	P,TYPSTR	;AND STR NAME
	JRST	LOOKNX		;AND RETURN

;ERROR:	NO DIRECTORY MATCHES THE USER'S REQUEST

E$$NSD:	MOVE	T1,['NSD',,[ASCIZ /No such d/]]	;NO--NO SUCH DIRECTORY
	PUSHJ	P,WLDWRN	;ISSUE WARNING
	  JRST	LOOKNX		;SKIP REST IF NOT /VERB:FIRST
	PUSHJ	P,DIRERR	;ISSUE DIRECTORY ERROR
	JRST	LOOKNX		;GO ISSUE CRLF AND RETURN

;ERROR:	THE DIRECTORY IS EMPTY

E.DEM:	SKIPE	UFDEF		;SEE IF WE FOUND AN ERROR YET
	JRST	LOOKNY		;YES--DON'T REPORT IT AGAIN
	SKIPN	NSUFD		;SEE IF ANY SUCCESSFULLY LOOKED UP
	JRST	E$$NXD		;NO--GO GIVE MESSAGE
E$$DEM:	MOVE	T1,['DEM',,[ASCIZ /D/]]
	PUSHJ	P,WLDWRN	;ISSUE WARNING
	  JRST	LOOKNX		;SKIP REST IF NOT /VERB:FIRST
	PUSHJ	P,DIRERR	;ISSUE DIRECTORY ERROR
	MOVEI	T1,[ASCIZ / is empty/]
	PUSHJ	P,.TSTRG##	;DIRECTORY EMPTY MESSAGE
	JRST	LOOKNX		;GO ISSUE CRLF AND RETURN
;ERROR: DIRECTORY COULD NOT BE FOUND ON SOME STRUCTURE

DLYERR:	MOVE	T2,[ERIPP%	;MFD MISSING
		    ERSNF%	;SFD MISSING
		    ERFNF%]-1(T2)  ;OR FILE MISSING
	SKIPN	UFDEF		;SEE IF ERROR ALREADY GIVEN
	PUSHJ	P,LKERRD	;NO--GIVE THIS ONE
	JRST	LOOKNY		;AND FINISH UP

;ERROR:	ALL MATCHING UFDS WERE NON-EXISTENT

E$$NXD:	MOVE	T1,['NXD',,[ASCIZ /Non-existent/]]
	PUSHJ	P,WLDWRN	;ISSUE WARNING
	  JRST	LOOKNX		;SKIP REST IF NOT /VERB:FIRST
	PUSHJ	P,UFDERR	;ISSUE DEVICE AND UFD CODE
	JRST	LOOKNY		;AND START OVER

;ERROR:	NO FILE MATCHES THE USER'S REQUEST

E$$SFP:	MOVE	T1,['SFP',,[ASCIZ /Some files protected /]]
	JRST	E.NSF1		;ISSUE WARNING			[311]

E$$AFP:	SKIPA	T1,['AFP',,[ASCIZ /All files protected /]]
E$$SDP:	MOVE	T1,['SDP',,[ASCIZ /Some directories protected /]]
	JRST	E.NSF1		;GO ISSUE MESSAGE		[305]

E$$AFR:	SKIPA	T1,['AFR',,[ASCIZ /All files rejected by conditions /]]
E$$NSF:	MOVE	T1,['NSF',,[ASCIZ /No such files as /]]
E.NSF1:	PUSHJ	P,WLDWRN	;ISSUE WARNING
	  JRST	LOOKNX		;SKIP REST IF NOT /VERB:FIRST
	PUSHJ	P,FILOUT	;ISSUE FILE ERROR
	JRST	LOOKNX		;END LINE AND START OVER

;ERROR:	NO FILE NAME SPECIFIED FOR DISK FILE

E$$NFS:	MOVE	T1,['NFS',,[ASCIZ /No file name specified /]]
	PUSHJ	P,WLDERR	;ISSUE ERROR
	  JRST	LOOKNX		;SKIP REST IF NOT /VERB:FIRST
	PUSHJ	P,FILOUT	;ISSUE FILE ERROR

LOOKNX:	PUSHJ	P,.TCRLF##	;ISSUE NEW LINE
LOOKNY:	MOVE	P1,.WILAS	;POSITION POINTER
	JRST	LOOKST		;GO BACK FOR NEXT REQUEST
	SUBTTL	SECONDARY WILD-CARD LOGIC
;.SCWLD -- ROUTINE TO COMPUTE SECONDARY WILD-CARDS SUCH AS FOR
;	ALTERNATE INPUT FILES AND OUTPUT FILES.
;SEE START OF LISTING FOR ARGUMENT FORMAT

.SCWLD::HLRZ	T2,T1		;GET ARGUMENT COUNT
	PUSHJ	P,.GTWRD##	;GET BLOCK+0
	MOVE	T4,(T3)		;GET ADDRESS OF OUTPUT SPEC
	MOVEM	T4,SCOSP	;SAVE FOR LATER
	HLRZS	T3		;POSITION FOR INPUT
	MOVE	T4,(T3)		;GET ADDRESS OF INPUT SPEC
	MOVEM	T4,SCISP	;SAVE FOR LATER
	PUSHJ	P,.GTWRD	;GET BLOCK+1
	HLRZM	T3,SCIOPN	;SAVE INPUT OPEN
	HRRZM	T3,SCOOPN	;SAVE OUTPUT OPEN
	PUSHJ	P,.GTWRD	;GET BLOCK+2
	HLRZM	T3,SCILKP	;SAVE INPUT LOOKUP BLOCK
	HRRZM	T3,SCOLKP	;SAVE OUTPUT LOOKUP BLOCK
	PUSHJ	P,.GTWRD	;GET BLOCK+3
	HLRZM	T3,SCODFE	;SAVE ADDRESS OF DEFAULT EXTENSION
	HRRZM	T3,SCOLLK	;STORE LENGTH OF OUTPUT LOOKUP BLOCK

	PUSHJ	P,.SAVE3##	;SAVE P1-P3
	MOVE	P1,SCOOPN	;POINT TO OUTPUT OPEN BLOCK
	MOVE	P2,SCOSP	;POINT TO OUTPUT SPEC
	SETZB	T4,2(P1)	;CLEAR BUFFER POINTERS
	MOVX	T1,FX.PHY	;CHECK FOR /PHYSICAL
	TDNE	T1,.FXMOD(P2)	; IN OUTPUT SPEC
	TXO	T4,UU.PHS	;YES--SET FOR OPEN
	MOVE	T3,[DEVCHR T2,]
	TDNE	T1,.FXMOD(P2)	;SEE IF /PHYSICAL
	TXO	T3,UU.PHY	;YES--TURN ON IN DEVCHR
	MOVSI	T2,'SYS'	;TRY IT
	XCT	T3		; RIGHT
	TRNN	T2,-1		;SEE IF SET
	TRZ	T3,UU.PHY	;NO--PHYS DEVCHR DOESN'T WIN
	MOVE	T2,.FXDEV(P2)	;GET DEVICE
	MOVEM	T2,1(P1)	;SET IN OPEN BLOCK
	XCT	T3		;GET CHARACTERISTICS
	MOVEM	T2,SCCHR	;SAVE FOR LATER ALSO
	TXNN	T2,DV.MTA	;SEE IF MAG TAPE
	JRST	SCWLD1		;NO--PROCEED
	MOVX	T1,FX.PAR	;CHECK FOR /PARITY
	TDNE	T1,.FXMOD(P2)	; FOR :EVEN
	TXO	T4,IO.PAR	;YES--SET FOR OPEN
	LDB	T1,[POINTR (.FXMOD(P2),FX.DEN)]  ;GET /DENSITY
	DPB	T1,[POINTR (T4,IO.DEN)]  ;SET INTO OPEN
SCWLD1:	MOVEM	T4,(P1)		;STORE FIRST WORD OF OPEN BLOCK
	ADDI	T3,<<DEVTYP T2,>-<DEVCHR T2,>>  ;CHANGE TO DEVTYP
	MOVE	T2,.FXDEV(P2)	;GET DEVICE NAME AGAIN
	XCT	T3		;GET DEVTYP
	MOVEI	T2,0		;CLEAR IT IF NOT AVAILABLE
	MOVEM	T2,SCTYP	;SAVE FOR ERROR MESSAGES AND LATER
;HERE TO SETUP SECONDARY LOOKUP BLOCK

	MOVE	P1,SCOLKP	;POINT TO BLOCK
	MOVE	T1,SCOLLK	;GET LENGTH
	SOS	T1		;MINUS ONE
	HRLZI	T2,1(P1)	;POINT BEYOND FIRST
	HRRI	T2,2(P1)	;SETUP BLT POINTER
	MOVEM	T1,.RBCNT(P1)	;SET LENGTH
	ADDI	T1,(P1)		;POINT TO END
	SETZM	1(P1)		;CLEAR START
	BLT	T2,(T1)		;CLEAR ENTIRE ARRAY
	MOVX	T1,RB.NSE	;GET NON-SUPERSEDING ENTER BIT
	MOVX	T2,FX.SUP	;GET /ERSUPERSEDE BIT
	TDNE	T2,.FXMOD(P2)	;SEE IF USER SET IT
	IORM	T1,.RBCNT(P1)	;YES--TELL MONITOR

	LDB	T1,[POINTR (.FXMOD(P2),FX.PRO)]  ;GET /PROTECTION
	LSH	T1,^D35-POS(RB.PRV)  ;POSITION
	MOVEM	T1,.RBPRV(P1)	;STORE FOR ENTER (WON'T HURT LOOKUP)
	SKIPG	T1,.FXEST(P2)	;GET /ESTIMATE			[161,164]
	MOVEI	T1,0		; DEFAULT TO 0			[164]
	LSH	T1,-7		;CONVERT TO BLOCKS		[161]
	CAILE	T2,.RBEST	;SEE IF ROOM IN ENTER BLOCK	[161]
	MOVEM	T1,.RBEST(P1)	;YES--SET IT FOR ENTER		[161]
	MOVE	T1,.FXVER(P2)	;GET /VERSION			[161]
	CAILE	T2,.RBVER	;SEE IF ROOM IN ENTER BLOCK	[161]
	CAMN	T1,[-1]		; AND SEE IF SET		[161]
	SKIPA			;NO--IGNORE			[161]
	MOVEM	T1,.RBVER(P1)	;YES--SET FOR ENTER		[161]
;HERE TO APPLY WILD-CARDS.  IDEA IS TO COPY CORRESPONDING INPUT WILD
; CARDS IN THE SAME ORDER OF FILE NAME, EXTENSION, DIRECTORY.

	SETZM	SCNBT		;CLEAR BIT FETCHER
	MOVE	T1,SCISP	;GET INPUT SPEC ADDRESS
	HRLI	T1,-4		;PRESET COUNTER
	ADDI	T1,.FXNMM-1	;POINT TO NAME MASK
	MOVEM	T1,SCNWD	;SAVE FOR FNDNBT ROUTINE
	MOVE	P3,SCILKP	;POINT TO INPUT BLOCK

	SKIPN	T1,.FXNAM(P2)	;GET OUTPUT NAME
	SKIPA	T1,.RBNAM(P3)	;OR INPUT IF BLANK
	SKIPA	T2,.FXNMM(P2)	;GET OUTPUT MASK
	SETOM	T2		;SET FULL MASK IF BLANK
	PUSHJ	P,INSWLD	;INSERT WILD CHARS		[153]
	  JRST	E$$IWC		;ERROR IF NO MORE
	MOVEM	T1,.RBNAM(P1)	;STORE OUTPUT NAME

	SKIPN	T1,.FXEXT(P2)	;GET OUTPUT EXT
	HLLO	T1,@SCODFE	;GET DEFAULT
	HRLO	T2,T1		;GET MASK
	TRZ	T1,-1		;CLEAR OUT JUNK
	PUSHJ	P,INSWLS	;INSERT WILD CHARS
	  JRST	E$$IWC		;ERROR IF NO MORE
	HLLZM	T1,.RBEXT(P1)	;STORE RESULT FOR ENTER
	HLRZ	T2,T1		;SAVE EXTENSION			[153]
	MOVE	T1,.RBNAM(P1)	;GET FILE NAME BACK		[153]
	CAIE	T2,'UFD'	;UNLESS .UFD			[153]
	PUSHJ	P,INSWLF	; COMPACT OUT BLANKS		[153]
	MOVEM	T1,.RBNAM(P1)	;STORE RESULT			[153]
	MOVEI	T1,0		;CLEAR DIRECTORY (SET [-])
	MOVX	T2,FX.DIR	;SEE IF ONE GIVEN
	TDNN	T2,.FXMOD(P2)	; BY THE USER
	JRST	SCNODR		;NO--USE DEFAULT
	MOVE	T1,.FXDIR(P2)	;GET USER SPECIFIED UFD
	MOVE	T2,.FXDIM(P2)	;GET UFD MASK
	TLNN	T1,-1		;SEE IF PROJECT
	TLO	T2,-1		;NO--SET MASK FULL ON
	TLNN	T1,-1		;SEE IF PROJECT
	HLL	T1,MYPPN	;BLANK--USE LOGGED IN PROJECT
	TRNN	T1,-1		;SEE IF PROGRAMMER
	TRO	T2,-1		;NO--SET MASK FULL ON
	TRNN	T1,-1		;SEE IF PROGRAMMER
	HRR	T1,MYPPN	;BLANK--USE LOGGED IN PROGRAMMER
	PUSHJ	P,INSWLD	;INSERT WILD-CARDS
	  JRST	E$$IWC		;ERROR IF NO MORE
	SKIPGE	T1		;SEE IF SIXBIT DIRECTORY
	PUSHJ	P,INSWLF	;YES--FIX IT UP
	TLNE	T1,-1		;IF NO PROJECT
	TRNN	T1,-1		;OR PROGRAMMER,
	JRST	E$$NNO		;THEN ERROR

IFN FT$SFD,<
	SKIPN	.FXDIR+2(P2)	;SEE IF SFD
	JRST	SCNODR		;NO--JUST USE UFD
	MOVEM	T1,SCSFDD	;YES--STORE UFD IN PATH
	SETZM	SCSFD		;CLEAR FIRST ARG
	SETZM	SCSFDS		;CLEAR SCAN SWITCH
;LOOP OVER SFDS
	MOVSI	P1,1-.FXLND	;PRESET DEPTH COUNTER
SCSFDL:	SKIPN	T1,.FXDIR+2(P2)	;GET NEXT SFD
	JRST	SCSFDM		;DONE--JUST CLEANUP
	MOVE	T2,.FXDIM+2(P2)	;GET MASK
	PUSHJ	P,INSWLS	;INSERT WILD CHARACTERS
	  JRST	E$$IWC		;ERROR IF NO MORE
	JUMPE	T1,E$$NNO	;ERROR IF BLANK
SCSFDM:	MOVEM	T1,SCSFDD+1(P1)	;STORE SFD
	ADDI	P2,2		;ADVANCE SPEC POINTER
	AOBJN	P1,SCSFDL	;LOOP OVER PATH
	SETZM	SCSFDD+1(P1)	;FORCE A ZERO
	MOVEI	T1,SCSFD	;POINT TO PATH
	MOVE	P1,SCOLKP	;RESTORE OUTPUT BLOCK POINTER
>

SCNODR:	MOVEM	T1,.RBPPN(P1)	;STORE DIRECTORY OR POINTER
	MOVEM	T1,.RBSIZ(P1)	;(FOR LEV.C)

	SETCMI	T2,1		;SET SINGLE WILD BIT		[302]
	PUSHJ	P,INSWLD	;GO SEE IF ANY LEFT		[302]
	  SKIPA			;NO--WORKED OUT OK		[302]
	JRST	E$$TWC		;YES--TOO MANY ON INPUT		[302]
;HERE WHEN ALL DONE

	SKIPN	T1		;SEE IF DIRECTORY
	MOVE	T1,MYPPN	;DEFAULT--USE SELF
	TLNN	T1,-1		;SEE IF SFD
	MOVE	T1,.PTPPN(T1)	;YES--GET OWNER UFD
	MOVE	T2,SCILKP	;POINT TO INPUT LOOKUP
	MOVE	T3,.RBPRV(T2)	;GET INPUT PROTECTION
	MOVE	T2,.RBPPN(T2)	;GET INPUT OWNER
	SKIPN	T2		;SEE IF DEFAULT
	MOVE	T2,MYPPN	;YES--GET SELF
	TLNN	T2,-1		;SEE IF SFD
	MOVE	T2,.PTPPN(T2)	;YES--GET OWNER UFD
	SKIPE	T1		;IF NO OUTPUT OWNER
	SKIPN	T2		;OR NO INPUT OWNER
	JRST	SCDONE		;LEAVE PROT. ALONE
	SKIPN	.RBPRV(P1)	;IF /PROTECTION
	CAME	T1,T2		;OR DIFFERENT OWNERS
	JRST	SCDONE		;LEAVE PROT. ALONE
	ANDX	T3,<RB.PRV-7B2>	;CLEAR OWNER PROTECTION
	JUMPE	T3,SCDONE	;IF 000, LEAVE ALONE
	MOVX	T1,%LDSTP	;GET SYSTEM
	GETTAB	T1,		;STANDARD FILE PROTECTION
	  MOVEI	T1,0		;(USE 0XX)
	ANDX	T1,7B2		;GET OWNER PROTECTION
	IOR	T1,T3		;INCLUDE INPUT FILE PROT
	MOVEM	T1,.RBPRV(P1)	;STORE FOR ENTER
SCDONE:	HLRZ	T1,.RBEXT(P1)	;GET RESULTING EXTENSION	[153]
	CAIN	T1,'UFD'	;SEE IF .UFD			[153]
	JRST	[SKIPN T1,.RBPPN(P1) ;YES--GET DIRECTORY	[153]
		 MOVE  T1,MYPPN	;BLANK, ASSUME SELF		[153]
		 TLNN  T1,-1	;SEE IF SFD POINTER		[153]
		 MOVE  T1,.PTPPN(T1) ;YES--GET UFD		[153]
		 CAMN  T1,MFDPPN ;SEE IF MFD:			[153]
		 JRST  .+1	;YES--ALL SET			[153]
		 MOVEM T1,.RBNAM(P1) ;NO--STORE UFD AS NAME	[153]
		 MOVE  T1,MFDPPN ;GET MFD			[153]
		 MOVEM T1,.RBPPN(P1) ;STORE AS DIRECTORY	[153]
		 JRST  .+1]	;AND PROCEED			[153]
	MOVE	T1,SCCHR	;GET DEVICE CHARACTERISTICS
	MOVE	T2,.RBNAM(P1)	;GET FILE NAME			[164]
	TLC	T1,-1-<(DV.TTA)> ;WATCH OUT FOR			[164]
	TLCE	T1,-1-<(DV.TTA)> ; NUL:				[164]
	TXNN	T1,DV.DTA!DV.DSK  ;IF DISK OR DECTAPE,		[164]
	SKIPA			;NO				[164]
	JUMPE	T2,E$$NDO	;  ERROR IF NULL NAME		[164]
	MOVE	T3,SCTYP	;GET DEVTYP
	MOVEI	T2,1		;SET FOR MISC. DEVICE
	TLC	T1,-1-<(DV.TTA)> ;IF DEVICE
	TLCN	T1,-1-<(DV.TTA)> ; IS NUL:
	JRST	CPOPJ1		; THEN RETURN
	TXNN	T3,TY.SPL	;SEE IF SPOOLED
	TXNE	T1,DV.DSK	;OR DISK
	SETOM	T2		;YES--FLAG AS SUCH
	TXNE	T1,DV.DTA	;SEE IF DECTAPE
	SETZM	T2		;YES--FLAG
	JRST	CPOPJ1		;OK RETURN TO USER
;E.SCO -- REPORT OPEN ERROR

E.SCO::
E$$SCO:	MOVE	T1,['SCO',,[ASCIZ /OPEN failure on /]]
	PUSHJ	P,WLDERR	;ISSUE ERROR
	  PJRST	.TCRLF##	;SKIP REST IF NOT /VERB:FIRST
	MOVE	T1,SCOOPN	;POINT TO OPEN BLOCK
	MOVE	T1,1(T1)	;GET NAME
	PUSHJ	P,TYPST1	;TYPE IT
	LDB	T2,[POINTR (SCTYP,TY.JOB)]  ;GET USER JOB
	PJRST	OPNER1		;GO TYPE IT

;ERROR: CAN'T LOOKUP OR ENTER SECONDARY FILE

E.SCL::	MOVE	T1,SCOLKP	;POINT TO LOOKUP BLOCK
	MOVE	T2,SCOLLK	;GET LENGTH
	MOVE	T3,SCOSP	;POINT TO OUTPUT SPEC
	PJRST	E.LKEN		;GO OUTPUT ERROR

;ERROR:	NULL NAME OR DIRECTORY

E$$NDO:	SKIPA	T1,['NDO',,[ASCIZ /Null name in output wild-card/]]
E$$NNO:	MOVE	T1,['NNO',,[ASCIZ /Null directory in output wild-card/]]
	JRST	ENEWC

;ERROR:	INSUFFICIENT INPUT WILD CARD CHARS TO MATCH OUTPUT

E$$TWC:	SKIPA	T1,['TWC',,[ASCIZ /Too many wild-cards in input for output/]]
E$$IWC:	MOVE	T1,['IWC',,[ASCIZ /Insufficient wild-cards in input for output/]]
ENEWC:	PUSHJ	P,WLDERR	;ISSUE ERROR
	  PJRST	.TCRLF##	;SKIP REST IF NOT /VERB:FIRST
	PJRST	.TFILE		;TYPE ERROR FILE SPEC
;INSWLS -- ROUTINE TO INSERT WILD CHARACTERS IN A WORD AND LEFT COMPRESS NULL CHARS
;INSWLF -- FIXUP WORD BY LEFT COMPRESSING NULL CHARS

INSWLS:	PUSHJ	P,INSWLD	;INSERT WILD CHARACTERS
	  POPJ	P,		;ERROR RETURN
	AOS	(P)		;GOOD RETURN

INSWLF:	SKIPN	T2,T1		;SHIFT ARGUMENT
	POPJ	P,		;RETURN IF NULL
	MOVEI	T1,0		;CLEAR RESULT
INSWF1:	SKIPE	T2		;IF DONE
	TLNE	T2,(77B5)	;OR NOT NULL
	JRST	INSWF2		;GO SHIFT TO ANSWER
	LSH	T2,6		;ELSE, COMPRESS NULL
	JRST	INSWF1		;AND LOOP
INSWF2:	TLNE	T1,(77B5)	;SEE IF ALL DONE YET
	POPJ	P,		;YES--RETURN
	LSHC	T1,6		;NO--SHIFT SOME MORE
	JRST	INSWF1		;AND LOOP


;INSWLD -- ROUTINE TO INSERT WILD CHARACTERS IN A WORD
;CALL:	MOVE	T1,PROPOSED WORD (TYPED BY USER OR DEFAULTED)
;	MOVE	T2,REPLACEMENT MASK (1=LEAVE BIT ALONE)
;	PUSHJ	P,INSWLD
;	  ERROR RETURN IF INSUFFICIENT INPUT WILD-CARDS TO MATCH
;	SKIP RETURN WITH T1 UPDATED FROM INPUT FILE
;ASSUMES P3 POINTS TO INPUT LOOKUP BLOCK
;GLOBAL VARIABLES SCNBT AND SCNWD MUST BE PRESET FOR FNDNBT ROUTINE

INSWLD:	MOVEI	T4,^D35		;BIT COUNTER FOR WORD IN T1
INSWL1:	MOVEI	T3,1		;GET A BIT
	LSH	T3,(T4)		;POSITION
	TDNN	T2,T3		;SEE IF NEED REPLACEMENT
	JRST	INSWL3		;YES--GO DO IT
INSWL2:	SOJGE	T4,INSWL1	;NO--LOOP UNTIL DONE
	JRST	CPOPJ1		;SUCCESS RETURN
INSWL3:	TDZ	T1,T3		;REPLACE--CLEAR OUTPUT BIT
	PUSHJ	P,FNDNBT	;FIND VALUE OF NEXT REPLACEMENT BIT
	  POPJ	P,		;NONE--GIVE ERROR RETURN
	LSH	T3,(T4)		;POSITION REPLACEMENT BIT
	IOR	T1,T3		;INCLUDE IT IN RESULT
	JRST	INSWL2		;GO REPEAT LOOP
;FNDNBT -- HELPER TO INSWLD TO FIND VALUE OF NEXT REPLACEMENT BIT
;CALL:	PUSHJ	P,FNDNBT
;	  ERROR RETURN IF NO MORE INPUT WILD-CARDS
;	SKIP RETURN WITH VALUE IN BIT 35 OF T3
;PRESERVES ALL OTHER ACS
;GLOBAL VARIABLES SCNBT AND SCNWD MUST HAVE BEEN PRESET ORIGINALLY
;	SCNBT IS BIT DOWN COUNTER FOR SCANNING INPUT SPEC
;	SCNWD IS WORD UP COUNTER FOR SCANNING INPUT SPEC
;		LH=-3 NAME, -2 EXT, -1 UFD, 0-4 SFD
;		RH=LOCATION OF INPUT SPEC MASK
;LOCAL AC USAGE:
;	T1 CONTAINS SCNBT
;	T2 CONTAINS SCNWD
;	T3 GETS RESULT
;P3 IS ASSUMED TO POINT TO THE INPUT LOOKUP BLOCK

FNDNBT:	PUSH	P,T1		;SAVE ACS
	PUSH	P,T2
	MOVE	T2,SCNWD	;GET SCNWD WHERE IT IS USEFUL

FNDNB1:	SOSL	T1,SCNBT	;COUNT TO NEXT BIT
	JRST	FNDNB2		;STILL SAME WORD--PROCEED

	MOVEI	T1,^D35		;SET COUNT FOR NEXT WORD
	AOBJP	T2,FNDNW1	;GET NEXT WORD
	HLRZ	T3,T2		;NOT SFD--GET INDEX
	XCT	[JFCL		;FILE NAME--OK
		 MOVEI T1,^D17	;EXTENSION IS ONLY 18 BITS
		 ADDI  T2,.FXDIM-.FXEXT-1]+3(T3)  ;UFD IS FARTHER DOWN
	CAIN	T3,-1		;SEE IF UFD
	JRST	FNDNW2		;YES--CHECK FOR PRESENCE
	JRST	FNDNB2		;PROCEED

FNDNW1:	AOS	T2		;ADVANCE SFD SPEC BY 2
	HLRZ	T3,T2		;GET SFD DEPTH
	CAIGE	T3,.FXLND-1	;SEE IF ALL DONE
FNDNW2:	SKIPN	-1(T2)		;SEE IF SFD IS NULL
	JRST	FNDNBX		;YES--GIVE ERROR RETURN
FNDNB2:	MOVEM	T1,SCNBT	;STORE UPDATED COUNTER
	MOVEI	T3,1		;GET A BIT
	LSH	T3,(T1)		;POSITION IT
	TDNE	T3,(T2)		;SEE IF WILD IN INPUT SPEC
	JRST	FNDNB1		;NO--REPEAT LOOP
;HERE WHEN FOUND NEXT WILD BIT--GET VALUE
	HLRE	T3,T2		;GET WORD TYPE
	SKIPLE	T1,T3		;SEE IF SFD
	MOVEI	T1,0		;YES--MAKE UNIFORM
	XCT	[MOVE T3,.RBNAM(P3)  ;FILE NAME
		 HLRZ T3,.RBEXT(P3)  ;EXTENSION
		 JRST  [MOVE T3,.RBPPN(P3)  ;UFD
			TLNN T3,-1	;SEE IF PATH
			MOVE T3,.PTPPN(T3)	;YES--GET TOP OF PATH
			JRST .+1]
		 JRST  [ADD  T3,.RBPPN(P3)  ;SFD--POINT TO PATH
			TLNE T3,-1	;SEE IF PATH
			TDZA T3,T3	;NO--KILL RESULT
			MOVE T3,.PTPPN+1(T3)	;YES--GET SFD
			JRST .+1]
		    ]+3(T1)
	MOVN	T1,SCNBT	;GET COMPLEMENT OF BIT POS
	LSH	T3,(T1)		;POSITION RESULT
	ANDI	T3,1		;MASK TO ONE BIT
	AOS	-2(P)		;SET SKIP RETURN

FNDNBX:	MOVEM	T2,SCNWD	;STORE UPDATED WORD POINTER
	POP	P,T2		;RESTORE ACS
	POP	P,T1
	POPJ	P,		;RETURN
	SUBTTL	DIRECTORY SUBROUTINES

;SUBROUTINE TO SUPPLY DEFAULTS FOR DIRECTORIES
;CALL:	MOVEI	P1,POINTER TO SPECIFICATION
;	PUSHJ	P,SETDIR
;USES T1-4
;
;HANDLES [,] (IE, DEFAULT PROJECT, DEFAULT PROGRAMMER),
;HANDLES [-] (IE, DEFAULT TO DEFAULT DIRECTORY)
;HANDLES .UFD (IE, DIRECTORY IS REALLY FILE NAME)

SETDIR:	MOVX	T1,FX.DFX	;GET FLAG
	TDNE	T1,.FXMOD(P1)	;SEE IF HERE ALREADY
	POPJ	P,		;YES--RETURN
	IORM	T1,.FXMOD(P1)	;NO--SET FLAG FOR LATER
	MOVX	T1,FX.DIR	;SEE IF DIRECTORY
	TDNE	T1,.FXMOD(P1)	;  SPECIFIED
	JRST	SETDR2		;YES--GO HANDLE IT
	HLRZ	T1,.FXEXT(P1)	;GET EXTENSION
	CAIN	T1,'UFD'	;SEE IF UFD
	JRST	SETDR		;YES--GO DO DEFAULTS
	LDB	T1,[POINTR (.FXMOD(P1),FX.TRM)] ;GET TERMINATOR	[300]
IFN FT$COR,<
	CAIN	T1,.FXTRC	;IF "+"				[300]
	MOVEI	T1,.FXTRO	; TREAT AS 'OR'			[300]
>
	CAIE	T1,.FXTRA	;IF 'AND'			[300]
	CAIN	T1,.FXTRO	; OR 'OR'			[300]
	JRST	SETDR		; NEED TO GO SET DIRECTORY	[300]
	CAMN	P1,.WIFIR	;  OR SECOND FILE
	CAIN	T1,.FXTRN	; OR 'NOT'			[300]
	JRST	SETDR		;YES--SAME AS WILD CARDS
	SETCM	T1,.FXNMM(P1)	;SEE IF WILD NAME
	SETCM	T2,.FXEXT(P1)	;  OR EXT
	TRNN	T2,-1		;IF NOT,
	JUMPE	T1,SETDR4	;  LEAVE DIRECTORY CLEAR
SETDR:
IFN FT$SFD,<
	MOVE	T1,[-.FXLND,,PTHDIR]
	MOVEI	T2,.FXDIR(P1)	;NO--COPY DEFAULT DIRECTORY
SETDR1:	SKIPN	T3,(T1)		;GET NEXT LEVEL
	SOS	T1		;BLANK--HOLD POINTER
	MOVEM	T3,(T2)		;STORE IN ARGUMENT AREA
	SKIPE	T3		;SEE IF BLANK
	SETOM	T3		;NO--FULL MATCH
	MOVEM	T3,1(T2)	;STORE AWAY
	ADDI	T2,2		;ADVANCE STORAGE
	AOBJN	T1,SETDR1	;LOOP UNTIL DONE
	JRST	SETDR3		;AND PROCEED BELOW
>
SETDR2:	MOVE	T1,.FXDIR(P1)	;GET DIRECTORY
	MOVE	T2,MYPPN	;DEFAULT PPN--GET USER
	TLNN	T1,-1		;SEE IF PROJECT PRESENT
	HLLM	T2,.FXDIR(P1)	;NO--FILL IN MY PROJECT
	TLNN	T1,-1		; ..
	HRROS	.FXDIM(P1)	; AND NO WILDCARD
	TRNN	T1,-1		;SEE IF PROGRAMMER PRESENT
	HRRM	T2,.FXDIR(P1)	;NO--FILL IN MY PROGRAMMER
	TRNN	T1,-1		; ..
	HLLOS	.FXDIM(P1)	; AND NO WILDCARD
SETDR3:
REPEAT 0,<			;SET /OKPRO IF ANY WILD-CARDS	[301]
	SETCM	T1,.FXDIM(P1)	;SEE IF WILD USER
	JUMPE	T1,SETDR4	;NO--OK
>
	MOVX	T1,FX.PRT	;YES--SET
	TDNN	T1,.FXMOM(P1)	; /OKPROTECTION
	IORM	T1,.FXMOD(P1)	; UNLESS /ERPROTECTION
SETDR4:	HLRZ	T1,.FXEXT(P1)	;GET EXTENSION
	CAIE	T1,'UFD'	;SEE IF .UFD
	POPJ	P,		;NO--ALREADY SETUP CORRECTLY
	MOVE	T1,MFDPPN	;YES--GET CORRECT DIRECTORY
	EXCH	T1,.FXDIR(P1)	;STORE (MFD)
	SETO	T2,		;CLEAR WILDCARDS
	EXCH	T2,.FXDIM(P1)	;SET INTO DIRECTORY
	MOVEM	T1,.FXNAM(P1)	;MOVE DIRECTORY TO NAME
	MOVEM	T2,.FXNMM(P1)	;MOVE DIRECTORY TO NAME
IFN FT$SFD,<
	SETZM	.FXDIR+2(P1)	;CLEAR SUB DIRECTORY
	SETZM	.FXDIM+2(P1)	; ..
>
	POPJ	P,		;RETURN

;ERROR:	DIRECTORY OPEN

E.UFO:	MOVEI	T1,[ASCIZ /directory on /]
	PUSHJ	P,OPNERR
	SETOM	UFDEF		;INDICATE ERROR MESS FOR DIRECTORY
	JRST	STR1
;ERROR:	DIRECTORY LOOKUP FAILURE

E.UFL:	SKIPE	T4,DEPTH	;RESTORE DEPTH POINTER
	MOVEM	T1,DIRBU-1(T4)	;RESTORE DIRECTORY LIST
E.UFL1:	TLZ	T2,-1		;CLEAR JUNK
	JUMPE	T4,[PUSHJ P,E.MFL  ;ISSUE MFD ERROR
		    JRST  WILDE]   ;AND LOOP
	SOS	NSUFD		;DISCOUNT UFD FOUND SUCCESSFULLY
	CAIE	T2,ERSNF%	;SEE IF SFD ERROR
	CAIG	T2,ERIPP%	;SEE IF NON-EXISTENT ERROR
	SKIPN	SRCH		;AND STR SEARCHING
	JRST	.+2		;NO--PROCEED
	JRST	E.UFLX		;YES--SKIP MESSAGE FOR NOW
	PUSHJ	P,LKERRD	;ISSUE ERROR MESSAGE
	JRST	WILDE		;AND TRY NEXT DIRECTORY

E.UFLX:	CAIN	T2,ERSNF%	;COMPACT ERROR CODE
	MOVEI	T2,2		; SFD IS WORST
	SKIPN	T2		; ..
	MOVEI	T2,3		;EXCEPT FOR FILE MISSING
	CAMLE	T2,LASERR	;SEE IF WORST YET
	MOVEM	T2,LASERR	;YES--REMEMBER IT
	JRST	WILDE		;AND CONTINUE ONWARDS

;ISSUE ERROR IN SFD/UFD/MFD
LKERRD:	SETOM	UFDEF		;FLAG THAT ERROR WAS FOUND
	MOVX	T1,FX.PRT	;SEE IF
	TDNE	T1,MOD		;/OKPROTECTION
	CAIE	T2,ERPRT%	;AND PROTECTION ERROR
	SKIPA			;NO
	JRST	[AOS  NODIRP	;YES--INDICATE PRO ERROR	[304,307]
		 POPJ P,]	;RETURN				[304]
	PUSHJ	P,LKERR		;OUTPUT LOOKUP ERROR
	  JRST	E.MFL1		; (IF MFD FAILED)
	PJRST	UFDERR		;OUTPUT UFD ERROR AND RETURN

E.MFL1:	MOVEI	T2,0		;FUDGE FILE NOT FOUND ERROR
E.MFL:	CAIN	T2,ERIPP%	;SEE IF ILL PPN
	MOVEI	T2,ERFNF%	;CHANGE TO NO SUCH FILE (MFD)
	PUSHJ	P,LKERR		;OUTPUT LOOKUP ERROR
	  HALT	.+1
	PJRST	MFDERR		;OUTPUT MFD ERROR AND RETURN

;ERROR:	I/O ERROR WHILE READING DIRECTORY

E.UFE:	GETSTS	WC,T1		;DATA ERROR--GET STATUS
	PUSHJ	P,STSERR	;OUTPUT MESSAGE
	SETSTS	WC,(T1)		;AND CLEAR ERROR BITS
	PJRST	UFDERR		;OUTPUT UFD ERROR
;.NXDTW -- GET NEXT WORD FROM DATA FILE
;CALL:	PUSHJ	P,.NXDTW
;	ERROR RETURN IF END-OF-FILE
;	NORMAL RETURN WITH WORD IN T1

.NXDTW::SOSGE	B.DC+.BFCTR	;SEE IF WORD IN BUFFER
	JRST	NXDATR		;NO--READ SOME MORE OF FILE
	ILDB	T1,B.DC+.BFPTR	;FETCH WORD
	JRST	CPOPJ1		;SKIP RETURN

NXDATR:	PUSHJ	P,DODCHN	;EXECUTE DATA CHANNEL UUO
	  IN	DC,		;READ
	    JRST  .NXDTW	;OK TO PROCEED

	PUSHJ	P,DODCHN	;EXECUTE DATA CHANNEL UUO
	  STATZ	DC,IO.ERR	;SEE IF ANY ERRORS
	    PUSHJ P,E.DFE  	;YES
	PUSHJ	P,DODCHN	;EXECUTE DATA CHANNEL UUO
	  STATO	DC,IO.EOF	;SEE IF EOF
	    JRST .NXDTW  	;NO--GET MORE DATA
	POPJ	P,		;YES--EOF RETURN



;ERROR:	DATA FILE OPEN

E.DFO::	MOVEI	T1,[0]
OPNERR:	PUSH	P,T1		;SAVE MESSAGE INSERT
E$$DFO:	MOVE	T1,['DFO',,[ASCIZ /Open failure for /]]
	PUSHJ	P,WLDERR	;ISSUE ERROR
	  JRST	[POP   P,T1	;IF NOT /VERB:FIRST
		 PJRST .TCRLF##] ; SKIP REST
	POP	P,T1		;RECOVER INSERT
	PUSHJ	P,STRER1	;OUTPUT STRUCTURE NAME
	MOVE	T2,FSTR		;GET DEVICE
	PUSHJ	P,DOPHYS	;GET PHYSICAL BIT
	  DEVTYP T2,		;GET JOB USING IT
	    JRST OPNER2		;GIVE UP IF NOT IMPLEMENTED
	LDB	T2,[POINTR (T2,TY.JOB)]  ;GET USER JOB
OPNER1:	JUMPE	T2,OPNER2	;GIVE UP IF NOT ON RECORD
	MOVEI	T1,[ASCIZ / in use by job /]
	PUSHJ	P,.TSTRG##	;TYPE PREFIX
	HRRZ	T1,T2		;GET JOB NUMBER
	PUSHJ	P,.TDECW##	;TYPE JOB NUMBER
OPNER2:	PJRST	.TCRLF		;END LINE AND RETURN
;ERROR:	DATA FILE LOOKUP ERROR

E.DFL::	MOVE	T1,AGLOOK	;POINT TO LOOKUP BLOCK
	MOVE	T2,AGLENL	;GET LENGTH
	MOVEI	T3,FSTR		;POINT TO TEMP ERROR AREA
	TDZA	T4,T4		;FLAG WILD INPUT AND SKIP INTO E.LKEN

;E.LKEN -- OUTPUT LOOKUP/ENTER ERROR FOR SCAN-BLOCK
;CALL:	MOVEI	T1,EXTENDED LOOKUP BLOCK
;	MOVEI	T2,LENGTH OF LOOKUP BLOCK
;	MOVEI	T3,SCAN BLOCK (INC. SFDS)
;	PUSHJ	P,E.LKEN

E.LKEN::SETOM	T4		;SECONDARY FLAG
	HRLZ	T3,T3		;POINT TO SCAN BLOCK
	HRRI	T3,FSTR		;POINT TO ERROR BLOCK
	BLT	T3,ENDERR	;COPY TO TEMP AREA
	CAIG	T2,.RBDEV	;SEE IF STR IS INCLUDED
	JRST	EDFL1		;NO--USE ARGUMENT
	SKIPE	T3,.RBDEV(T1)	;SEE IF BETTER STR SPECIFIED
	MOVEM	T3,FSTR		;YES--UPDATE DIAGNOSTIC
EDFL1:	SKIPE	T3,.RBNAM(T1)	;GET REAL NAME
	MOVEM	T3,FNAM		;UPDATE DIAGNOSTIC
	HLLZ	T3,.RBEXT(T1)	;GET REAL EXTENSION
	MOVEM	T3,FEXT		;USE IT IN MESSAGE
	MOVE	T3,.RBPPN(T1)	;GET BETTER PPN
	TLNE	T3,-1		;SEE IF BETTER UFD SPECIFIED
	MOVEM	T3,UFDPPN	;YES--UPDATE DIAGNOSTIC
	TLNE	T3,-1		;SEE IF SFD
	SETOM	UFDPPN+1	;NO--CLEAR WILD CARDS
	MOVE	T3,.RBPRV(T1)	;GET PROTECTION
	HRRZ	T2,.RBEXT(T1)	;GET CODE
	MOVX	T1,FX.PRT	;SEE IF
	TDNE	T1,MOD		;/OKPROTECTION
	CAIE	T2,ERPRT%	;AND PROTECTION ERROR
	SKIPA			;NO
	JRST	[SOS  NOFILF	;DON'T COUNT FILE FOUND		[304]
		 AOS  NOFILP	;COUNT PROTECTION ERROR		[304]
		 POPJ P,]	;RETURN				[304]
	MOVX	T1,FX.NOM	;SEE IF				[155]
	TDNE	T1,MOD		; /OKNONE			[155]
	JUMPE	T2,CPOPJ	;YES--IF NOT FOUND, SUPPRESS ERROR	[155]
	CAIE	T2,ERSNF%	;SEE IF NO .SFD			[155]
	CAIN	T2,ERIPP%	;SEE IF NO .UFD
	JUMPE	T4,ENDFL2	;YES--IF WILD IN, THEN SPECIAL HANDLING
	SKIPE	SRCH		;IF MULT STRS			[154]
	JUMPE	T2,[SOS  NOFILF	; AND MISSING FILE		[154]
		    POPJ P,]	; SUPPRESS MESSAGE AND CATCH LATER	[154]
E$$LKE:	MOVSI	T1,'LKE'
	PUSH	P,T2		;SAVE ERROR CODE
	MOVEI	T2,WLDWRN
	SKIPE	T4		;IF INPUT, JUST WARN
	MOVEI	T2,WLDERR
	PUSHJ	P,(T2)		;ISSUE PREFIX
	  JRST	[POP   P,T1	;IF NOT /VERB:FIRST
		 PJRST .TCRLF##] ; SKIP REST
	POP	P,T1		;RESTORE ERROR CODE
	PUSHJ	P,.LKERR	;OUTPUT LOOKUP ERROR
	PJRST	.TFILE		;OUTPUT FILE NAME AND RETURN

ENDFL2:	SKIPN	SRCH		;SEE IF MULTIPLE STRS
	JRST	E$$NXU		;NO--ISSUE MESSAGE
	SOS	NOUFDF		;YES--BACK OFF COUNTER
	SOS	NOFIL		; ..				[154]
	SOS	NOFILF		; ..				[154]
	POPJ	P,		;AND RETURN

E$$NXU:	MOVE	T1,['NXU',,[ASCIZ /Non-existent/]]
	PUSHJ	P,WLDWRN	;ISSUE WARNING
	  PJRST	.TCRLF##	;SKIP REST IF NOT /VERB:FIRST
	PJRST	UFDERR		;OUTPUT UFD NAME AND RETURN

;ERROR:	I/O ERROR WHILE READING DATA FILE

E.DFE:	PUSHJ	P,.SAVE1##	;SAVE P1
	MOVE	P1,SAVEP1	;GET BACK LOCAL P1
	PUSHJ	P,DODCHN	;DO DATA CHANNEL UUO
	  GETSTS DC,T1		;GET STATUS BITS
	PUSHJ	P,STSERR	;OUTPUT STATUS MESSAGE
	PUSHJ	P,DODCHN	;DO DATA CHANNEL UUO
	  SETSTS DC,(T1)	;CLEAR ERROR BITS
	PJRST	.TFILE		;OUTPUT FILE NAME
;LKERR -- OUTPUT LOOKUP ERROR MESSAGE
;CALL:	MOVEI	T2,ERROR CODE
;	MOVEI	T3,PROTECTION IF ERROR 2
;	PUSHJ	P,LKERR
;	ERROR RETURN IF UFD BAD
;USES T1, T2, T3

LKERR:	HRRZ	T2,T2		;GET ERROR CODE
	CAIN	T2,ERIPP%	;SEE IF UFD ERROR
	POPJ	P,		;YES--ERROR RETURN
	AOS	(P)		;NO--ADVANCE RETURN
E$$LKP:	MOVSI	T1,'LKP'
	PUSH	P,T2		;SAVE ERROR
	PUSH	P,T3		;SAVE PROTECTION
	PUSHJ	P,WLDWRN	;LIST FLAG
	  JRST	[POP  P,T3	;IF NOT /VERB:FIRST
		 POP  P,T1	; SKIP REST OF
		 POPJ P,]	; MESSAGE
	POP	P,T3		;RESTORE PROTECTION
	POP	P,T1		;RESTORE ERROR CODE

;SUBROUTINE ENTRY TO TYPEOUT A LOOKUP ERROR CODE
;CALL IS SAME AS LKERR EXCEPT ERROR IN T1 (LH=0)
;AND ALWAYS RETURNS CPOPJ
;WILL GIVE HUMAN MESSAGE FOR COMMON ERRORS

.LKERR::HRLZ	T2,T1		;PRESERVE ERROR CODE
	MOVSI	T1,-LKETBL	;GET LENGTH OF ERROR TABLE	[163]
LKERRL:	HRR	T2,LKETB(T1)	;INCLUDE JUNK			[163]
	CAME	T2,LKETB(T1)	;SEE IF MATCH			[163]
	AOBJN	T1,LKERRL	;NO--LOOP ON			[163]
	JUMPL	T1,LKERR1	;MATCH--GO HANDLE IT		[163]
	MOVEI	T1,[ASCIZ \Lookup/enter failure \]
	PUSHJ	P,.TSTRG##	;NO--PRINT OCTAL CODE
	HLRZ	T1,T2		;GET ERROR CODE
	PJRST	.TOCTW##	;  AND RETURN
LKERR1:	HLRZ	T2,T2		;GET ERROR CODE BACK		[163]
	HRRZ	T1,LKETB(T1)	;GET ASCIZ TEXT			[163]
	CAIE	T2,ERPRT%
	PJRST	.TSTRG##	;ISSUE MESSAGE AND RETURN
	PUSHJ	P,.TSTRG##	;ISSUE PROTECTION MESSAGE
	LSH	T3,-<ALIGN.(RB.PRV)>  ;POSITION PROTECTION CODE
	MOVEI	T1," "
	SKIPE	T3
	PUSHJ	P,.TCHAR##
	SKIPE	T1,T3
	PUSHJ	P,.TOCTW
	MOVEI	T1,[ASCIZ / failure/]
	PJRST	.TSTRG##	;AND RETURN

;LOOKUP/RENAME/ENTER ERROR MESSAGES

LKETB:	ERFNF%,,[ASCIZ /Non-existent/]
	ERIPP%,,[ASCIZ /Non-existent UFD/]
	ERPRT%,,[ASCIZ /Protection/]
	ERFBM%,,[ASCIZ /File being modified/]
	ERAEF%,,[ASCIZ /Already existing/]
	ERTRN%,,[ASCIZ /RIB or directory read error/]
	ERNRM%,,[ASCIZ /No room/]
	ERWLK%,,[ASCIZ /Write locked/]
	ERCSD%,,[ASCIZ /Can't supersede directory/]
	ERSNF%,,[ASCIZ /Non-existent SFD/]
	ERSLE%,,[ASCIZ /Search list empty/]
	ERLVL%,,[ASCIZ /SFD too deep/]
	ERNCE%,,[ASCIZ /No create/]
LKETBL==.-LKETB
;STSERR -- ISSUE I/O STATUS ERROR MESSAGE
;CALL:	GETSTS	T1
;	PUSHJ	P,STSERR
;UPDATES T1 TO CLEAR ERROR BITS

STSERR:	PUSH	P,T1		;SAVE STATUS
	PUSH	P,T2		;SAVE ACS
	PUSH	P,T3		; ..
E$$IOE:	MOVE	T1,['IOE',,[ASCIZ /Error /]]
	PUSHJ	P,WLDWRN	;ISSUE WARNING
	  JRST	[POP  P,T3	;IF NOT
		 POP  P,T2	; /VERB:FIRST
		 POP  P,T1	; SKIP REST
		 POPJ P,]	; OF MESSAGE
	MOVE	T1,-2(P)	;GET STATUS
	PUSHJ	P,.TOCTW	;LIST STATUS
	POP	P,T3		;RESTORE ACS
	POP	P,T2		; ..
	MOVEI	T1,[ASCIZ / while reading/]
	PUSHJ	P,.TSTRG##	;AND REST OF MESSAGE
	POP	P,T1		;RESTORE STATUS
	TRZ	T1,IO.ERR	;CLEAR ERROR BITS
	POPJ	P,		;RETURN
;MFDERR -- ISSUE MESSAGE THAT ERROR IS IN MFD
;CALL:	PUSHJ	P,MFDERR
;USES T1

MFDERR:	MOVEI	T1,[ASCIZ / MFD/]
	PUSHJ	P,STRERR	;OUTPUT STRUCTURE NAME
	PJRST	.TCRLF		;END LINE AND RETURN



;.TFILB -- OUTPUT SPECIFIC SCAN STYLE BLOCK
;.TFILE--OUTPUT UFD OR FILE NAME
;CALL:	MOVEI	T1,SCAN BLOCK (.TFILB ONLY)
;	PUSHJ	P,.TFILE/.TFILB
;USES T1

.TFILB::HRLZ	T1,T1		;POINT TO SPEC
	HRRI	T1,FSTR		;POINT TO TEMP AREA
	BLT	T1,ENDERR	;COPY
.TFILE::HLRZ	T1,FEXT		;SEE WHAT KIND OF FILE
	CAIE	T1,'UFD'	;SEE IF DIRECTORY
	JRST	DATERR		;NO--OUTPUT NORMAL FILE NAME
	SKIPN	T2,FNAM		;GET NAME
	MOVE	T2,UFDPPN	;ELSE GET DIRECTORY
	MOVE	T1,UFDPPN	;GET DIRECTORY
	CAMN	T1,MFDPPN	;SEE IF MFD
	MOVEM	T2,UFDPPN	;YES--USE FILE NAME
	SETZB	T2,UFDPPN+2	;CLEAR SFD
	SETZM	UFDPPN+3	; ..
	JRST	UFDER2		;YES--OUTPUT DIRECTORY



;UFDERR -- ISSUE MESSAGE THAT ERROR IS IN UFD
;CALL:	PUSHJ	P,UFDERR
;USES T1

UFDERR:	MOVE	T2,FLDTA	;GET DECTAPE FLAG
UFDER2:	MOVEI	T1," "		;SPACE OVER
	PUSHJ	P,.TCHAR	; ..
	PUSHJ	P,TYPSTR	;OUTPUT STRUCTURE
UFDER3:	SKIPN	T2		;SEE IF NOT DECTAPE
	PUSHJ	P,UFDLSN	;OUTPUT DIRECTORY
	MOVEI	T1,[ASCIZ /.UFD/]
IFN FT$SFD,<
	SKIPE	UFDPPN+2	;SEE IF SFD INCLUDED
	MOVEI	T1,[ASCIZ /.SFD/]
>
	SKIPE	T2		;SEE IF DECTAPE
	MOVEI	T1,[ASCIZ / directory/]
	PUSHJ	P,.TSTRG##	;SEND EXTENSION
	PJRST	.TCRLF		;END LINE AND RETURN
;DATERR -- ISSUE MESSAGE THAT ERROR IS IN A FILE
;CALL:	PUSHJ	P,DATERR
;USES T1

DATERR:	MOVEI	T1,[ASCIZ / file /]
	PUSH	P,T2		;SAVE AC
IFN FT$SFD,<
	HLRZ	T2,FEXT		;CHECK EXTENSION FOR SFD
	CAIN	T2,'SFD'	; ..
	MOVEI	T1,[ASCIZ / directory /]
>
	PUSHJ	P,.TSTRG##	;ISSUE PREFIX
	PUSHJ	P,FILOUT	;OUTPUT FILE NAME AND EXTENSION
	POP	P,T2		;RESTORE AC
	PJRST	.TCRLF		;AND END LINE AND RETURN


;DODCHN -- ROUTINE TO INCLUDE THE DATA CHANNEL IN A UUO AND EXECUTE IT
;CALL:	PUSHJ	P,DODCHN
;	  UUO TO EXECUTE
;	    NON-SKIP POINT
;	SKIP POINT
;USES NO ACS

DODCHN:	PUSH	P,T1		;PRESERVE T1
	MOVE	T1,-1(P)	;GET UUO
	MOVE	T1,(T1)		;GET UUO
	AOS	-1(P)		;ADVANCE RETURN
	IOR	T1,AGDCHN	;INCLUDE DATA CHANNEL
	EXCH	T1,(P)		;RESTORE T1 SAVE UUO
	XCT	(P)		;DO THE UUO
	  JRST	.+2		;NON-SKIP
	AOS	-1(P)		;SKIP
	POP	P,(P)		;DISCARD UUO
	POPJ	P,		;RETURN
;FILOUT -- OUTPUT NAME OF FILE AND EXTENSION
;CALL:	PUSHJ	P,FILOUT
;USES T1, T2

FILOUT:	PUSHJ	P,TYPSTR	;OUTPUT DEVICE
	HLRZ	T2,FEXT		;CHECK EXTENSION		[153]
	TRC	T2,'UFD'	;SEE IF .UFD			[153]
	JUMPE	T2,UFDER3	;YES--USE UFD FORMAT		[153]
	MOVE	T1,FNAM		;GET FILE NAME
	PUSHJ	P,.TSIXN##	;LIST IT
	HLLZ	T2,FEXT		;GET FILE EXTENSION
	MOVX	T1,FX.NUL	;SEE IF USER SPECIFIED NO EXT
	TDNE	T1,MOD		; SEE IF HE GAVE .
	JUMPE	T2,FILOU1	;NO--SEE IF HE LEFT AS NULL
	MOVEI	T1,"."		;AND SEPARATOR
	PUSHJ	P,.TCHAR	;YES--TYPE SEPARATOR
	MOVE	T1,T2		;GET NAME
	PUSHJ	P,.TSIXN	;LIST EXTENSION
FILOU1:	PJRST	UFDLSN		;OUTPUT DIRECTORY AND RETURN
;DIRERR -- ISSUE DIRECTORY ERROR MESSAGE
;CALL:	PUSHJ	P,DIRERR
;USES T1

DIRERR:	MOVEI	T1,[ASCIZ /irectory /]
	PUSHJ	P,STRER1	;OUTPUT DEVICE
				;FALL INTO UFDLSN


;UFDLSN -- ISSUE NAME OF DIRECTORY
;CALL:	PUSHJ	P,UFDLSN
;USES T1

UFDLSN:	PUSH	P,T3		;SAVE SOME ACS
	PUSH	P,T2		; ..
	SKIPE	T1,FRCPPN	;SEE IF FORCING PPN		[154]
	SETOM	UFDPPN+1	;YES--INDICATE FULL MATCH	[154]
	SKIPE	T1		;AGAIN				[154]
	MOVEM	T1,UFDPPN	;YES--FORCE NAME		[154]
	SETCM	T2,UFDPPN+1	;GET DIRECTORY MASK		[154]
	MOVE	T1,UFDPPN	;GET DIRECTORY			[154]
	CAMN	T1,MFDPPN	;IF MFD				[154]
	JUMPE	T2,[MOVE  T1,FNAM ;YES--GET NAME		[154]
		    MOVEM T1,UFDPPN ;STORE AS DIRECTORY		[154]
		    MOVE  T2,FNAM+1 ;GET NAME MASK		[154]
		    MOVEM T2,UFDPPN+1 ;STORE AS DIRECTORY MASK	[154]
		    JRST  .+1]	;THEN PROCEED			[154]
	MOVEI	T1,UFDPPN	;GET UFD NUMBER
IFN FT$SFD,<
	TLO	T1,2		;INDICATE DOUBLE WORD PATH
>
	PUSHJ	P,.TDIRB##	;AND LIST IT
	POP	P,T2		;RESTORE THOSE ACS
	POP	P,T3		; ..
	POPJ	P,		;AND RETURN
;STRERR -- OUTPUT MESSAGE AND STRUCTURE NAME
;CALL:	MOVEI	T1,MESSAGE
;	PUSHJ	P,STRERR
;USES T1

STRERR:	PUSHJ	P,.TSTRG##	;OUTPUT MESSAGE
	MOVEI	T1,[ASCIZ / on /]
STRER1:	PUSHJ	P,.TSTRG##	;OUTPUT IDENTIFICATION
TYPSTR:	SKIPN	T1,FSTR		;GET DEVICE NAME
	POPJ	P,		;RETURN IF NULL
TYPST1:	PUSH	P,T2		;SAVE AC
	PUSHJ	P,.TSIXN	;OUTPUT IT
	POP	P,T2		;RESTORE AC
	PJRST	.TCOLN##	; ..



;WLDWRN -- ISSUE WARNING PREFIX
;WLDERR -- ISSUE ERROR PREFIX
;CALL:	MOVSI	T1,ERROR CODE IN SIXBIT
;	HRRI	T1,0 OR ADDRESS OF ASCIZ MESSAGE
;	PUSHJ	P,WLDWRN/WLDERR
;NON-SKIPS IF REST OF LINE TO BE DISCARDED
;USES T1-T3

WLDWRN:	TDZA	T2,T2		;GO FOR WARNING
WLDERR:	MOVEI	T2,"?"-"%"	;GO FOR ERROR
	ADDI	T2,"%"		;CONVERT TO RIGHT TEXT
	HRLZS	T2		;POSITION ERROR INDICATOR
	HRR	T2,T1		;MOVE TEXT POINTER
	HLRZS	T1		;POSITION ERROR CODE
	HRLI	T1,'WLD'	;INDICATE FROM WILD
	HRRZ	T3,(P)		;GET ADDRESS+1 OF CALL
	SUBI	T3,2		;BACKUP TO E$$ POINT
	PUSH	P,T4		;PRESERVE T4
	PUSHJ	P,.ERMSA##	;ISSUE ERROR PREFIX
	POP	P,T4		;RESTORE T4
	TXNE	T1,JWW.FL	;SEE IF /MESSAGE:FIRST
	AOS	(P)		;YES--INDICATE TO DO REST OF LINE
	POPJ	P,		;RETURN
	SUBTTL	STRUCTURE SUBROUTINES

;.INSTR -- ROUTINE TO INITIALIZE STRUCTURE SEARCH LOOP
;CALL:	MOVE	T1,DEVICE
;	MOVE	T2,1B0 IF /PHYSICAL
;	PUSHJ	P,.INSTR
;NON-SKIP IF NOT A DISK
;SKIP WITH CODES PRESET FOR .NXSTR
;  AND T1=0 IF NO SCANNING, =1B0 IF SCANNING

.INSTR::PUSHJ	P,.SAVE1##	;SAVE P1
	MOVSI	T3,'SYS'	;SEE IF
	DEVCHR	T3,UU.PHY	; PHYSICAL
	TRNN	T3,-1		; POSSIBLE
	TXZ	T2,UU.PHS	;NO--CLEAR ARGUMENT
	LSH	T2,-^D35	;POSITION TO BIT 35
	MOVEM	T2,PHYS		;STORE FOR UUO
	SETOM	SY2RCH		;ASSUME AT LEAST 5.02
	MOVEM	T1,FSTR		;SAVE DEVICE
	SETZM	SYSRCH		;CLEAR
	SETZM	STRMSK		; FLAGS
	SETZM	STRMTH		; FOR .NXSTR
	SETZM	SRCH		;CLEAR SEARCH MODE
	SETOM	SUBSTR		;INDICATE .INSTR CALL
	MOVE	T2,T1		;COPY ARGUMENT DEVICE
	PUSHJ	P,DOPHYS	;GET
	  DEVCHR T2,		; ITS CHARACTERISTICS
	MOVS	T1,FSTR		;GET NAME AGAIN
	CAIN	T1,'NUL'	;SEE IF NUL:
	TLO	T2,-1-<(DV.TTA)> ;YES--FAKE DEVCHR FOR OLD MONITORS
	TLC	T2,-1-<(DV.TTA)> ;SEE IF NUL:
	TLCE	T2,-1-<(DV.TTA)> ; ..
	TXNN	T2,DV.DSK	;OR NOT DISK
	POPJ	P,		;RIGHT--ERROR
				;FALL INTO INSTR
				;FALL HERE FROM ABOVE
;INSTR -- INTERNAL ROUTINE TO INITIALIZE .NXSTR

INSTR:	SETZM	FRCPPN		;INDICATE NOT OVERRIDING PPN	[154]
IFN FT$SFD,<
	MOVE	T3,FSTR		;GET STRUCTURE
	MOVEI	T4,0		;CLEAR ANSWER
	MOVE	T2,[3,,T3]	;SETUP CODE
	PUSHJ	P,DOPHYS	;ASK MONITOR FOR
	  PATH.	T2,		;  SYS IDENT.
	    JRST INSTR3		;NOT IMPLEMENTED--TRY OLD WAY
	MOVE	T1,P1		;SAVE DEVICE PPN
	HLRZ	T2,T3		;GET GENERIC STR NAME
	CAIE	T2,'SYS'	;LOOK FOR SYS:
	TXNE	T4,PT.IPP	;NO--SEE IF IGNORE DIRECTORY ARGS
	JRST	.+2		;YES--CLOBBER ARGUMENT
	JRST	INSTR2		;NO--PROCEED
	CAIN	T2,'SYS'	;IF SYS,
	HRLI	T3,'DSK'	;SWITCH TO DSK TO GET RIGHT SUBSET
	MOVEM	T3,FSTR		;  LIKE "SYSA:", ETC.
	SKIPN	SUBSTR		;IF INTERNAL CALL,
	PUSHJ	P,SETPPN	;  SET REQUESTED PPN
	TXNN	T4,PT.IPP	;SEE IF IGNORE PPN
	SETOM	SYSRCH		;NO--SET SYS FLAG

;HERE TO SEE IF SPECIAL SEARCH LIST NEEDED

INSTR2:	LDB	T1,[POINTR (T4,PT.SLT)]  ;GET S/L CODE
	JUMPE	T1,INSTR3		;PROCEED IF NOTHING SPECIAL
	SETZM	SY2RCH		;EXPLICIT INFO, SO CLEAR FLAGS
	SETZM	SYSRCH		; ..
	CAIE	T1,.PTSLA	;SEE IF ALL S/L
	CAIN	T1,.PTSLS	;OR SYS S/L
	SETOM	SYSRCH		;YES--FLAG FOR ALL OR SYS
	CAIN	T1,.PTSLS	;SEE IF SYS S/L
	SETOM	SY2RCH		;YES--FLAG FOR SYS
	JRST	INSTR7		;AND SKIP AD HOC KLUDGERY
>
INSTR3:	MOVE	T2,FSTR		;GET DEVICE NAME
	MOVE	T3,[1,,T2]	;SET FOR DSKCHR
	PUSHJ	P,DOPHYS	;DO PHYS I/O CALL
	  DSKCHR T3,		;SEE IF SYS OR GENERIC
	    JRST INSTR5		;FAILED--MUST BE SYS:
	LDB	T1,[POINTR (T3,DC.TYP)]  ;GET NAME CLASS
	JUMPE	T1,INSTR7		;JUMP IF DSK:
	CAIN	T1,.DCTAB	;IF STR ABBR. (SE:)
	JRST	INSTM1		;  GO SET MASK
	CAIN	T1,.DCTCN	;IF CONTROLLER CLASS (DP:)
	JRST	INSTM4		;  GO SET DSKCHR MASK
	CAIN	T1,.DCTCC	;IF CONTROLLER (DPA:)
	JRST	INSTM5		;  GO SET IT
	JRST	INSTRX		;NOTHING SPECIAL--USE USER'S DEVICE
;HERE WHEN STR ABBREVIATION FOUND (LIKE SE: FOR SEFI: AND SEMA:)

INSTM1:	MOVE	T3,FSTR		;GET ABBREVIATION
	DEVNAM	T3,		;CONVERT TO PHYSICAL IF WE CAN
	  MOVE	T3,FSTR		;IF NOT DO THE BEST WE CAN
	PUSHJ	P,.MKMSK##	;GET MASK OF SIZE
	JRST	INSTM8		;AND GO STORE

;HERE WHEN CONTROLLER CLASS (DP:)

INSTM4:	MOVX	T1,DC.CNT	;SET MASK FOR TYPE OF CONTROLLER
	JRST	INSTM8		;AND GO STORE

;HERE WHEN CONTROLLER (DPA:)

INSTM5:	MOVX	T1,<DC.CNT!DC.CNN>	;SET MASK FOR TYPE AND NUMBER OF CONTROLLER

;HERE WITH T1=MASK, T3=MATCH

INSTM8:	MOVEM	T1,STRMSK	;STORE MASK
	MOVEM	T3,STRMTH	;STORE MATCH
	JRST	INSTR6		;AND FLAG FOR SYSSTR TYPE SEARCHING

;HERE WHEN SYS SEARCH LIST IS SELECTED

INSTR5:	SKIPN	SYSRCH		;SEE IF ALREADY SETUP
	PUSHJ	P,SETSYS	;SETUP DIRECTORY FOR SYS:
INSTR6:	SETOM	SYSRCH		;FLAG FOR SYSTEM SEARCH LIST (F/S LIST)

;HERE WHEN ANY SEARCH LIST IS SELECTED

INSTR7:	SETOM	SRCH		;FLAG TO USE A SEARCH LIST
INSTRX:	SETZM	LASSTR		;CLEAR STRUCTURE TO START
	SKIPE	T1,SRCH		;SEE IF SEARCHING
	MOVX	T1,UU.PHS	;YES--RETURN /PHYSICAL
	JRST	CPOPJ1		;AND SKIP RETURN
;.NXSTR -- ROUTINE TO GET NEXT STRUCTURE
;CALL:	PUSHJ	P,.NXSTR
;NEVER SKIPS. RETURNS NAME IN T1, 0 IF DONE.
;RESULT SHOULD ALWAYS BE USED PHYSICAL ONLY

.NXSTR::SKIPN	SRCH		;HERE FOR NEXT--SEE IF SEARCHING
	JRST	CPOPJZ		;NO--GO TO NEXT REQUEST
NXSTR2:	MOVE	T1,LASSTR	;GET F/S NAME FOR LIST
	SKIPE	SYSRCH		;NEED A NEW F/S
	JRST	NXSTR3		;FROM SYSTEM F/S LIST
	SKIPN	T1		;SEE IF FIRST PASS
	SETOM	T1		;YES--BLANKETY-BLANK UUO
	MOVE	T2,[1,,T1]	;SETUP POINTER
	JOBSTR	T2,		;FROM JOB'S SEARCH LIST
	  HALT	CPOPJZ
	JRST	NXSTR5		;GOT IT

NXSTR3:	SKIPE	SY2RCH		;NEEDS SYS: S.L.
	SKIPE	STRMSK		;IF MASK, NEEDS ALL STR LIST
	JRST	.+2		;YES--USE IT
	JRST	NXSTR4		;GO USE REAL SYS: SEARCH LIST
	SYSSTR	T1,		;CAN'T--USE ALL STRS IN SYSTEM
	  HALT	CPOPJZ
	JRST	NXSTR5		;GOT IT--GO PROCESS

NXSTR4:	SKIPN	T1		;SEE IF AT START
	SETOM	T1		;YES--FOOLISH UUO
	MOVEM	T1,GOBST+2	;STORE STR IN GOBSTR'S ARG LIST
	SETZM	GOBST		;SPECIFY JOB 0
	MOVX	T1,%LDSYS	;GET LOCATION OF SYS:
	GETTAB	T1,		;FROM MONITOR
	  MOVE	T1,[1,,1]	;(LEV. C)
	MOVEM	T1,GOBST+1	;STORE IN ARGUMENT
	MOVEI	T1,GOBST	;SETUP SHORT BLOCK
	GOBSTR	T1,		;ASK MONITOR
	  HALT	CPOPJZ		;GIVE UP IF ERROR
	MOVE	T1,GOBST+2	;GET ANSWER
;HERE WITH RESULT FROM S/L IN T1

NXSTR5:	CAMN	T1,[-1]		;LOOK FOR END
	JRST	CPOPJZ		;YES--DONE
	JUMPE	T1,CPOPJZ	;IF ZERO, ALL DONE
	MOVEM	T1,FSTR
	MOVEM	T1,LASSTR	;SAVE FOR SEARCH

	MOVEM	T1,.WLDBF	;DO A DSKCHR			[303]
	MOVE	T3,[.DCSAJ+1,,.WLDBF]
	PUSHJ	P,DOPHYS	; TO HANDLE			[303]
	  DSKCHR T3,		; SINGLE ACCESS			[303]
	    HALT CPOPJZ		; ..				[303]
	TXNE	T3,DC.SAF	;SEE IF SINGLE ACCESS		[303]
	JRST	[PJOB T2,	;YES--GET OUR JOB		[303]
		 XOR  T2,.WLDBF+.DCSAJ ;COMPARE TO S.A. USER	[303]
		 TRNE T2,-1	;SEE IF MATCH			[303]
		 JRST NXSTR2	;NO--IGNORE STRUCTURE		[303]
		 JRST .+1]	;YES--OK TO TRY IT		[303]
	SKIPN	T2,STRMSK	;SEE IF MASKING RESULTS
	JRST	NXSTRX		;NO--PROCEED WITH RESULTS
	SKIPL	T2		;SKIP IF NAME MASKING
	SKIPA	T1,T3		;POSITION DSKCHR FOR MATCH
	MOVE	T1,FSTR		;YES--GET BACK NAME		[303]
	XOR	T1,STRMTH	;SEE IF MATCHES
	TDNE	T1,STRMSK	;WHERE IMPORTANT
	JRST	NXSTR2		;NO--GO GET NEXT STR

;HERE TO RETURN VALUE TO THE CALLER
NXSTRX:	SKIPA	T1,FSTR		;RETURN RESULT
CPOPJZ:	MOVEI	T1,0		;RETURN ZERO
	POPJ	P,		;RETURN
	SUBTTL	USEFUL SUBROUTINES

;SETSYS -- SETUP DIRECTORY FOR SYS:
;CALL:	PUSHJ	P,SETSYS
;USES T1, T2

SETSYS:	MOVX	T1,%LDSYS	;GET LOCATION OF SYS:
	GETTAB	T1,		;FROM MONITOR
	  MOVE	T1,[1,,1]	;(LEV C)
SETPPN:	CAMN	T1,MFDPPN	;IF MFD:,			[153]
	JRST	[MOVE  T2,UFDPPN ;GET DIRECTORY			[153]
		 CAMN  T2,MFDPPN ;UNLESS MFD,			[153]
		 POPJ  P,	;(YES--RETURN)			[153]
		 MOVEM T2,FNAM	; STORE AS NAME			[153]
		 MOVE  T2,UFDPPN+1 ;GET DIRECTORY MASK		[153]
		 MOVEM T2,FNAM+1 ;STORE AS NAME MASK		[153]
		 JRST  .+1]	;PROCEED			[153]
	MOVEM	T1,FRCPPN	;OVERRIDE DIRECTORY		[154]
	MOVE	T2,MFDPPN	;GET MFD
	CAMN	T2,UFDPPN	;SEE IF SAME			[154]
	JRST	SETPP1		;YES--GO DIDDLE NAME
	MOVEM	T1,UFDPPN	;AND OVERSTORE REQUEST		[154]
	SETOM	UFDPPN+1	;AND NO WILD DIRECTORY		[154]
IFN FT$SFD,<
	SETZM	UFDPPN+2	;CLEAR SUB DIRECTORY		[154]
	SETZM	UFDPPN+3	; AND MASK			[154]
>
	POPJ	P,		;RETURN
SETPP1:	MOVEM	T1,FNAM		;STORE OVER NAME		[154]
	SETOM	FNAM+1		;CLEAR WILD CARD		[154]
	POPJ	P,		;RETURN
;DOPHYS -- PERFORM A LOGICAL OR PHYSICAL CALLI AS NEEDED
;CALL:	PUSHJ	P,DOPHYS
;	CALLI TO BE EXECUTED
;	CPOPJ RETURN POINT
;	SKIP RETURN POINT
;USES T1

DOPHYS:	MOVE	T1,(P)		;FETCH CALLI
	MOVE	T1,(T1)		; ..
	AOS	(P)		;ADVANCE RETURN POINT
	SKIPE	PHYS		;SEE IF PHYS I/O REQUESTED
	TRO	T1,UU.PHY	;YES--TURN ON PHYSICAL BIT
	XCT	T1		;DO THE CALLI
	POPJ	P,		;OK RETURN
CPOPJ1:	AOS	(P)		;SKIP
CPOPJ:	POPJ	P,		;RETURN



;SETOPN -- SETUP OPEN BLOCK WORD 1 AND 2
;CALL:	PUSHJ	P,SETOPN
;RETURNS WITH T1, T2 SETUP, T3=0
;USES NO ACS

SETOPN:	SETZB	T1,T3		;OPEN MFD
	SKIPN	PHYS		;SEE IF PHYS I/O REQUESTED
	SKIPE	SRCH		;OR IF USING A SEARCH LIST
	TLO	T1,(UU.PHS)	;YES--SET FOR PHYS OPEN
	SKIPN	T2,LASSTR	;GET STRUCTURE OR		[310]
	MOVE	T2,FSTR		;GET ARGUMENT DEVICE
	POPJ	P,		;RETURN
	XLIST	;LITERALS
	LIT
	LIST
	RELOC

.WILDZ::!		;START OF LOW CORE AREA

FWAZER:!	;START OF TEMPORARIES (CLEARED EACH REQUEST)
		;THIS PARALLELS INPUT PARAMETER AREA
FSTR:	BLOCK	1		;CURRENT STRUCTURE
FNAM:	BLOCK	2		;CURRENT FILE NAME
FEXT:	BLOCK	1		;CURRENT FILE EXTENSION
MOD:	BLOCK	2		;CURRENT SWITCHES
UFDPPN:	BLOCK	2*.FXLND+2	;CURRENT DIRECTORY
ENDERR==.-1

FLDTA:	BLOCK	1		;FLAG THAT DISK DEVICE
NOTDSK:	BLOCK	1		;FLAG THAT NOT A DTA/DISK DEVICE
SUBSTR:	BLOCK	1		;FLAG CALL TO SUBROUTINE .NXSTR
LASSTR:	BLOCK	1		;LAST STR FROM SEARCH UUOS
LASERR:	BLOCK	1		;LAST ERROR OF DIRECTORY NATURE
NOSTRS:	BLOCK	1		;NUMBER OF STRS IN SEARCH LIST
NOFILF:	BLOCK	1		;NUMBER OF FILES FOUND
NOFILP:	BLOCK	1		;NUMBER OF FILES WITH UNREPORTED PROTECTION ERRORS
NODIRP:	BLOCK	1		;NUMBER OF DIRECTORIES WITH UNREPORTED PROTECTION ERRORS
NOFILR:	BLOCK	1		;NUMBER OF FILES REJECTED
NOFIL:	BLOCK	1		;NUMBER OF FILES LOOKED AT
NOUFDF:	BLOCK	1		;NUMBER OF UFDS FOUND
NSUFD:	BLOCK	1		;NUMBER OF EXISTENT UFDS FOUND
DIRFLG:	BLOCK	1		;-1 IF THIS IS A DIRECTORY
FRCPPN:	BLOCK	1		;PPN TO OVERRIDE WITH
FNDSFD:	BLOCK	.FXLND		;+N IF SFD FIRST PASS, -1 IF SECOND
.WLDFL::BLOCK	1		;FILE WILD FLAG (-1=WILD FILE, +1=WILD STR ONLY,
				;  0=NEITHER, -2 IF WILD FILE AND WILD STR)
STRMSK:	BLOCK	1		;MASK FOR MATCHING STRS
				;  BY NAME IF LT 0, BY DSKCHR IF GT 0
STRMTH:	BLOCK	1		;MATCH FOR ABOVE
UFDEF:	BLOCK	1		;FLAG THAT UFD ERROR WAS REPORTED
PHYS:	BLOCK	1		;FLAG TO FORCE PHYSICAL I/O
SRCH:	BLOCK	1		;FLAG FOR SEARCH LIST IN USE
SYSRCH:	BLOCK	1		;FLAG FOR SYSTEM SEARCH LIST IN USE
SY2RCH:	BLOCK	1		;FLAG FOR REAL SYS: SEARCH LIST
.WIFIR::BLOCK	1		;FIRST P1 IN LINKED SET
.WILAS::BLOCK	1		;LAST P1 IN LINKED SET
FLCRDT:	BLOCK	1		;FILE'S CREATION DATE-TIME	[300]
FLACDT:	BLOCK	1		;FILE'S ACCESS DATE		[300]
GOBST:	BLOCK	5		;GOBSTR PARAMETER AREA

IFN FT$SFD,<
DIRB:	BLOCK	1		;BLOCK FOR DIRECTORY FOR SFD LOOKUPS
DIRBS:	BLOCK	1		; (SCANNING SWITCH)
DIRBU:	BLOCK	.FXLND		; (ACTUAL DIRECTORY LIST)
DIRBE:	BLOCK	1		;0 TO FORCE END
>
DEPTH:	BLOCK	1		;INDEX OF DIRECTORY DEPTH (0=MFD)
BUFCNT:	BLOCK	.FXLND+1	;COUNT DOWN OF FILES IN BLOCK
BUFPOS:	BLOCK	.FXLND+1	;INDEX IN BLOCK
DIRSTI:	BLOCK	.FXLND+1	;USETI IN DIRECTORY
.WLDBF::BLOCK	200		;BUFFER FOR READING DIRECTORIES
DVCH:	BLOCK	1		;LAST DEVICE CHARACTERISTICS
LWAZER==.-1	;END OF CLEARED AREA

MFDPPN:	BLOCK	1		;DIRECTORY FOR MFD
MYPPN:	BLOCK	1		;PPN OF THIS JOB

IFN FT$SFD,<
PTHARG:	BLOCK	1		;ARGUMENT/FLAG FOR PATH UUO
PTHSCN:	BLOCK	1		;SCAN SWITCH FOR PATH UUO
PTHDIR:	BLOCK	.FXLND		;ACTUAL PATH
PTHEND:	BLOCK	1		;0 TO FORCE END
PTHLEN==.-PTHARG
>

AGLENL:	BLOCK	1	;LENGTH OF LOOKUP BLOCK
AGLENP:	BLOCK	1	;LENGTH OF PARAMETER AREAS FROM SCANER
AGLIMS:	BLOCK	1	;LOCATION OF LAST AREA FROM SCANER
AGLOOK:	BLOCK	1	;LOCATION OF LOOKUP BLOCK
AGOPEN:	BLOCK	1	;LOCATION OF OPEN BLOCK
AGPNTR:	BLOCK	1	;LOCATION OF INDEX TO SCANER AREAS
AGDCHN:	BLOCK	1	;DATA CHANNEL
AGFLAG:	BLOCK	1	;USER'S FLAGS
AGEODN:	BLOCK	1	;ROUTINE TO NOTIFY AT END OF DIRECTORY
;STORAGE FOR SCWLD

SCISP:	BLOCK	1	;INPUT SPEC LOCATION
SCIOPN:	BLOCK	1	;INPUT OPEN LOCATION
SCILKP:	BLOCK	1	;INPUT LOOKUP LOCATION
SCOSP:	BLOCK	1	;OUTPUT SPEC LOCATION
SCOOPN:	BLOCK	1	;OUTPUT OPEN LOCATION
SCOLKP:	BLOCK	1	;OUTPUT LOOKUP LOCATION
SCODFE:	BLOCK	1	;ADDRESS OF DEFAULT EXTENSION
SCOLLK:	BLOCK	1	;OUTPUT LOOKUP LENGTH

SCCHR:	BLOCK	1	;DEV CHR
SCTYP:	BLOCK	1	;DEV TYP
SCNBT:	BLOCK	1	;TEMP FOR FNDNBT
SCNWD:	BLOCK	1	;TEMP FOR FNDNBT
IFN FT$SFD,<
SCSFD:	BLOCK	1	;ARG/FLAG
SCSFDS:	BLOCK	1	;SCAN
SCSFDD:	BLOCK	.FXLND	;ACTUAL PATH
SCSFDE:	BLOCK	1	;0 TO FORCE END
>

SAVEP1:	BLOCK	1	;STORAGE FOR USER'S P1


B.DC::	BLOCK	3		;DATA

.WILDL==:.-.WILDZ	;LENGTH OF LOW CORE AREA

	END
