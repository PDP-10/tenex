;<AUGUST>HOMBAT.MAC;59  1-Apr-82 18:14:55, Edit by FRENCH
;ADDED CALL TO CRASHB BEFORE RELOADING
;<AUGUST>HOMBAT.MAC;57  8-Feb-82 11:50:18, Edit by FRENCH
;MORE TYPEOUT FROM BOOTSTRAP
;<AUGUST>HOMBAT.MAC;56  3-Feb-82 19:47:39, Edit by FRENCH
;ALLOW BOOTSTRAP TO RUN IN ACS NOW THAT F4 IS FIXED
;<AUGUST>HOMBAT.MAC;55  2-Feb-82 13:13:47, Edit by FRENCH
;REWORK BOOTSTRAP TO READ DATA SWITCHES AND USE ENTRY CODES
;<AUGUST>HOMBAT.MAC;53 25-Jan-82 11:58:27, Edit by FRENCH
;CONTITIONAL BOOTSTRAP CLEARER OUTER TIL F4 CAN RUN IN ACS
;[0]<AUGUST>HOMBAT.MAC;52, 22-Jan-82 15:22:47, EDIT BY FRENCH
;CLEAN UP AS MUCH OF BOOTSTRAP AS POSSIBLE WITHOUT RUNNING IN ACS.
;DON'T WANT TO LEAVE JUNK IN UNCLEARED PORTION OF MMAP.
;<AUGUST>HOMBAT.MAC;48 21-Jan-82 13:14:32, Edit by FRENCH
;DON'T BOTHER CLEANING UP BOOTSTRAP (MMAP) AREA. AVOIDS RUNNING IN ACS
;WHICH IS NOT COOL ON F4 RIGHT NOW.  PGRINI CLEANS UP MMAP ANYWAY
;<AUGUST>HOMBAT.MAC;47 21-Jan-82 13:04:42, Edit by FRENCH
;DON'T CALL RLDCLR ON F4 OR F5 TO CLEAR PHYS MEM BEFORE BOOTING
;<FOONEX>HOMBAT.MAC;46 21-Jul-81 14:38:37, Edit by FRENCH
;PUT K IN CORDMP FILE EXTENSIONS TO AVOID CONFUSION
;<FOONEX>HOMBAT.MAC;45 22-Jun-81 16:05:20, Edit by FRENCH
;ECHO CRLF AFTER RLDTYI EATS CHARACTER IN RELOAD STUFF
;<FOONEX>HOMBAT.MAC;44 30-Apr-81 12:39:21, Edit by FRENCH
;PIOFF AND PGROFF BEFORE BOOTSTRAP RELOCATION BLT
;<FOONEX>HOMBAT.MAC;42 21-Apr-81 16:40:38, Edit by FRENCH
;HAVE BOOTSTRAP READ HOME BLOCK TO FIND MONITOR XB ADR INSTEAD
;OF ASSUMING MONTBL IS CORRECT FOR PACK
;<FOONEX>HOMBAT.MAC;38  1-Apr-81 22:13:08, Edit by FRENCH
;ADD FDBXDP FOR SYSTEM FILES (DON'T DUMP TO TAPE)
;<FOONEX>HOMBAT.MAC;36  1-Apr-81 12:27:24, Edit by FRENCH
;ADD FDB1PK FOR SYSTEM FILES, DON'T COUNT ON B0 OF SPTH FOR FREE OR NOT
;<FOONEX>HOMBAT.MAC;11 20-Mar-81 23:23:31, Edit by FRENCH
;DO FRINGE ASSIGNMENTS TO KEEP SPECAIL FILE PAGES FAR FROM
;SWAPPING AREA FOR EFFICIENCY (HARDLY EVER TOUCHED)
;<FOONEX>HOMBAT.MAC;145 18-Mar-81 11:42:29, Edit by FRENCH
;ADDED 2ND HALF MEG CORE DUMP ABILITY, SRI RUNNING A MEG
;<FOONEX>HOMBAT.MAC;144  6-Mar-81 15:03:23, Edit by FRENCH
;BUG FIX, ALLOW ACMAC AND VARMAC SUPPORT ROUTINES TO HANDLE
;RETURNS OF UP TO SKIP 4 SO BATENT AND NTRBAT RETS WORK
;<FOONEX>HOMBAT.MAC;143 13-Feb-81 12:07:53, Edit by FRENCH
;MAKE BATENT AND NTRBAT RET +1,2,3 REVEALING IF NEW ENTRY MADE
;<FOONEX>HOMBAT.MAC;136  5-Feb-81 18:26:35, Edit by FRENCH
;ADDED FIXAUT
;<FOONEX>HOMBAT.MAC;118 31-Jan-81 14:58:52, Edit by FRENCH
;SMARTEN FIXBAD
;<FOONEX>HOMBAT.MAC;105 27-Jan-81 15:02:27, Edit by FRENCH
;ADDED FIXBAD
;<FOONEX>HOMBAT.MAC;103 12-Jan-81 17:25:27, Edit by FRENCH
;STORE REASON IN RLDRSN IN RSTLNK
;<FOONEX>HOMBAT.MAC;101  6-Jan-81 14:18:05, Edit by FRENCH
;USE XMOVEM FOR RLDCLR
;<FOONEX>HOMBAT.MAC;99  5-Jan-81 23:27:18, Edit by FRENCH
;BOOTSTRAP FILE IS ONLY 1 PAGE LONG
;<FOONEX>HOMBAT.MAC;93  5-Jan-81 18:03:47, Edit by FRENCH
;ADDED CRIM10 AND GO TO RIM10 FORMAT FOR RES MON BOOTER
;<FOONEX>FOO.BAR;5  2-Jan-81 23:13:30, Edit by FRENCH
;ADDED LNKDTF AND LNKTBL STUFF
;<FOONEX>HOMBAT.MAC;85  2-Jan-81 11:57:20, Edit by FRENCH
;DO PIOFF AND ON IN CORDMP, PIOFF IN RDRESM
;<FOONEX>HOMBAT.MAC;83     1-Jan-81 17:05:03    EDIT BY SYSTEM
;CHANGE LNK AREA DEFINITIONS TO START AT 20
;<FOONEX>HOMBAT.MAC;81 31-Dec-80 14:55:40, Edit by FRENCH
;ADDED FRCRLD FOR SWITCH RELOADING VIA ADR 20 IN SCHED
;<FOONEX>HOMBAT.MAC;80 31-Dec-80 12:23:56, Edit by FRENCH
;FIX BUG IN SAVTAD
;<FOONEX>HOMBAT.MAC;75 29-Dec-80 12:39:31, Edit by FRENCH
;CLEAR ALL MEMORY JUST BEFORE DISK REBOOT
;<FOONEX>HOMBAT.MAC;72 27-Dec-80 23:42:19, Edit by FRENCH
;SLIGHT PHILOSOPHY CHANGE FOR MANUAL DISK REBOOTS
;<FOONEX>HOMBAT.MAC;71 24-Dec-80 12:44:34, Edit by FRENCH
;CLOBBER TIME AT MANRLD
;DSK:<FOONEX>HOMBAT.MAC;38 18-Dec-80 18:50:37, Edit by FRENCH
;WORK ON CORDMP AND RELOAD STUFF
;DSK:<FOONEX>HOMBAT.MAC;5 14-Oct-80 19:26:24, Edit by FRENCH
;FIX BATADR BYTE PTR
;DSK:<FOONEX>HOMBAT.PEF;3  8-Jul-80 14:25:45, Edit by FRENCH
;INSURE PRIMARY BAT WRITTEN TO DISK WHEN INITIALIZED
;DSK:<PEFMON>HOMBAT.MAC;19 12-Jun-80 12:42:24, Edit by FRENCH
;HANDLE UDSKIO ERROR IF ERROR BITS RETURNED IN AC 1
;DSK:<PEFMON>HOMBAT.MAC;18  9-Jun-80 13:47:57, Edit by FRENCH
;DON'T LET DEDRM CLOBBER 5,6 IN NTRBAT
;DSK:<PEFMON>HOMBAT.MAC;16  9-Jun-80 13:38:44, Edit by FRENCH
;DEDRM RETURNS +3 FOR SUCCESS, HANDLE IT
;ADD LOGIC FOR "BAD BUT IN USE" TABLES
;DSK:<FOONEX>HOMBAT.MAC;2  4-Jun-80 15:45:42, Edit by FRENCH
;RENAME SUPPORT STUFF FOR NO CNOFLICT WITH MACSYM STUFF
;DSK:<PEFMON>HOMBAT.MAC;35 29-May-80 13:46:51, Edit by FRENCH
;DON'T LEAVE ANY LOGICAL PACK IDENT IN BAT BLOCKS SO TRANSPORTABLE
;DSK:<PEFMON>HOMBAT.MAC;25 14-May-80 17:34:44, Edit by FRENCH
;ADDED HOMBAT PARAMETER TABLE FOR GETAB
;MOVE HDWR DISK ADR FORMAT SPEC TO PARAMS
;DSK:<PEFMON>HOMBAT.MAC;23 14-May-80 14:19:01, Edit by FRENCH
;SINCE DSKABT IN PARAMS NOW, USE IT SYMBOLICLLY INSTEAD OF 1B14

;HOME BLOCK AND BAT BLOCK STUFF

	SEARCH	STENEX,PROLOG
	TITLE	HOMBAT
	SUBTTL	AUTHOR: PHIL FRENCH

INTERN HOMBAT,NHOMBA
INTERN XB1TBL,XB2TBL
INTERN HM1TBL,HM2TBL,BB1TBL,BB2TBL
INTERN MCDTBL,MICTBL,BOTTBL,MONTBL
INTERN CD0ADR,CD1ADR,CD2ADR,CD3ADR
INTERN CRTHMA,CRTHOM,CRTBAA,CRTBAT,CRTBFA,CRTBAF
INTERN CRTSFA,DEFDIA
INTERN DOBDSA,DOBDRA,DOBDDA,DOBAT
INTERN NTRBAT
INTERN CORDMP,AUTRLD,MANRLD,FRCRLD
INTERN RDSWPM,RSTLNK,CRIM10
INTERN FIXBAD

EXTERN DSKASA,DSKASF,DEDSK,DSKDTB,NSECPG,SWPTK,SWPTKH,NSECTK
EXTERN UDSKIO,DREAD,DWRITE
EXTERN ASDRMS,DEDRM,DRMFRE,DRMSEC,DRMBND
EXTERN CVDSK,CDSKVA,CVADSW
EXTERN DIDSCA,DIDSCI,FDDSCA,FILIFG
EXTERN ASOFN,ASGPAG,SETMPG,RELPAG,RELOFN,FPTA,MLKPG,MULKPG
EXTERN GETFDB,USTDIR,JFNOFN,DSKDTB,MDDNAM,UNLCKF,CHKJFN
EXTERN BUGCHK,BUGHLT
EXTERN START,DBUGSW,DCHKSW,GETSMF,RELDSW,CDMPSW,FDDTSW
EXTERN SWCEND
EXTERN TADSEC,TADDAY,TODCLK
EXTERN BUGMSG,BUGTYO,BUGTYI
EXTERN NXTDMP,DDTIME,JB0FLG
EXTERN SCDRN2,MSTKOV
EXTERN CRASHB

	RESCD

;MODULE FLAGS

BATDBG:	Z		;NON-0 TO ALLOW INIT OF GOOD BATS WHEN DBUGSW/ 2
BATMAX:	^D500		;MAX BAD SPOTS CDC SAYS WE WILL SEE

HOMPDP:	IOWD 30,HOMPDL			;STACK PTR


;STORAGE

LS (HBXSTF,1)		;NON-ZERO IF HOMBAT FILES EXIST ON ALL PACKS
LS (RLDRSN,1)				;REASON PC FOR AUTO RELOAD
LS (LFRING,NPACKS)			;LOW FRINGE USED FOR DSKASF
LS (HFRING,NPACKS)			;HIGH FRINGE USED FOR DSKASF
LS (PDLSAV,1)				;SAVES P
LS (HOMPDL,30)				;LOCAL STACK





;WARNING: THE FOLLOWING MACROS USE ACS 14,15 BUT ARE RESTORED
;	  OUTSIDE THE CONTEXT OF THE SUPPORT PROCESSORS.
;	  .A16 IS ALWAYS CLOBBERED

.A16==16			;SCRATCH AC

.FPV==15			;FRAME PTR FOR VARMAC

;TRANSIENT VARIABLE MACRO

DEFINE VARMAC (VARS)<
	..VRR==10		;;REMEMBER CURRENT RADIX
	RADIX 8
	..VNV==1		;;INIT COUNT OF STACK WORDS
	IRP VARS,<
	  .VAR1 (VARS)>		;;PROCESS LIST
	JSP .A16,.VRSET		;;ALLOCATE STACK SPACE, SETUP .FP
	 ..VNV-1,,..VNV-1
	RADIX ..VRR		;;RESTORE RADIX
	PURGE ..VRR,..VNV>	;;CLEAN UP

DEFINE .VAR1 (VAR)<
	.VAR2 (VAR)>		;;PEEL OFF ANGLEBRACKETS IF ANY

DEFINE .VAR2 (NAM,SIZ)<
	.VAR3 (NAM,\..VNV)	;;DEFINE VARIABLE
	IFB <SIZ>,<..VNV=..VNV+1>
	IFNB <SIZ>,<..VNV=..VNV+SIZ>>

DEFINE .VAR3 (NAM,LOC)<
   IFDEF NAM,<.IF NAM,SYMBOL,<PRINTX VARMAC NAM ALREADY DEFINED>>
	DEFINE NAM<^O'LOC(.FPV)>>



.FPA==14				;FRAME PTR FOR ACMAC

;AC 1-4 SAVER AND RESTORER

DEFINE ACMAC (ARGS)<
	..ARR==10		;;SAVE RADIX
	RADIX 8
	..ANV==1		;;INIT ARG COUNT
	IRP ARGS,<
	  .ACV1 (ARGS)>		;;DEFINE ARG SYMBOL
	IFG ..ANV-5,<PRINTX ?TOO MANY ARGUMENTS: ARGS>
	JSP .A16,.ACSET		;;SETUP STACK
	RADIX ..ARR		;;RESTORE RADIX
	PURGE ..ARR,..ANV>

DEFINE .ACV1 (VAR)<
	.ACV2 (VAR)>		;;PEEL OFF ANGLEBRACKETS IF ANY

DEFINE .ACV2 (NAM,SIZ)<
	.ACV3 (NAM,\..ANV)	;;DEFINE VARIABLE
	IFB <SIZ>,<..ANV=..ANV+1>
	IFNB <SIZ>,<..ANV=..ANV+SIZ>>

DEFINE .ACV3 (NAM,LOC)<
   IFDEF NAM,<.IF NAM,SYMBOL,<PRINTX ACMAC NAM ALREADY DEFINED>>
	DEFINE NAM<^O'LOC(.FPA)>>



;MACRO TO SAVE FRAME PTRS INCASE SOME ROUTINE CLOBBERS IT

DEFINE SFRAME
<	PUSH P,.FPA
	PUSH P,.FPV
>

;MACRO TO RESTORE FRAME PTRS SAVED BY SFRAME

DEFINE RFRAME
<	POP P,.FPV
	POP P,.FPA
>



;SUPPORT ROUTINE FOR VARMAC

.VRSET::PUSH P,.FPV		;PRESERVE OLD .FPV
	MOVE .FPV,P		;SETUP FRAME PTR
	ADD P,0(.A16)		;ALLOCATE SPACE
	JUMPGE P,VRSOV
VRSET1:	PUSHJ P,1(.A16)		;CONTINUE ROUTINE, EXIT VIA .+1
.VRRET::JRST .VRRE1		;RET +1
	JRST .VRRE2		;RET +2
	JRST .VRRE3		;RET +3
	JRST .VRRE4		;RET +4
.VRRE5:	AOS -1(.FPV)		;RET +5
.VRRE4:	AOS -1(.FPV)
.VRRE3:	AOS -1(.FPV)
.VRRE2:	AOS -1(.FPV)
.VRRE1:	MOVEM .FPV,P
	POP P,.FPV
	POPJ P,

VRSOV:	SUB P,0(.A16)		;STACK OVERFLOW - UNDO ADD
	HLL .A16,0(.A16)	;GET COUNT
VRSOV1:	PUSH P,[0]		;DO ONE PUSH AT A TIME, GET REGULAR
	SUB .A16,[1,,0]		; ACTION ON OVERFLOW
	TLNE .A16,777777	;COUNT TO 0?
	JRST VRSOV1		;NO, KEEP PUSHING
	JRST VRSET1		;CONTINUE SETUP


;SUPPORT ROUTINE FOR ACMAC

.ACSET::PUSH P,.FPA		;SAVE .FPA
	MOVE .FPA,P		;SETUP FRAME POINTER
	PUSH P,1		;DO WITH PUSH, GET INTERRUPT...
	PUSH P,2
	PUSH P,3
	PUSH P,4
ACSET1:	PUSHJ P,0(.A16)		;CONTINUE ROUTINE
.ACRET::JRST .ACRE1		;RET +1
	JRST .ACRE2		;RET +2
	JRST .ACRE3		;RET +3
	JRST .ACRE4		;RET +4
.ACRE5:	AOS -1(.FPA)		;RET +5
.ACRE4:	AOS -1(.FPA)
.ACRE3:	AOS -1(.FPA)
.ACRE2:	AOS -1(.FPA)
.ACRE1:	POP P,4			;RESTORE ACS
	POP P,3
	POP P,2
	POP P,1
	MOVEM .FPA,P
	POP P,.FPA
	POPJ P,


;ASSEMBLY OF SENSITIVE PAGE HARDWARE ADRS FOR ASSIGNMENT TO ERROR FREE AREA
;ON CDC WINCHESTER DRIVES
;CYL 0, HEADS 0 AND 1 ARE AVAILABLE.
;HEAD 1 IS ASSUMED SAFER THAN HEAD 0 (LESS CHANCE OF HUMAN ERROR CLOBBERING IT)
;CYL 0, HEADS 0 AND 1, SECTOR 0 ARE ASSUMED UNSAFE (MUCH CHANCE OF HUMAN ERROR)


;LAYOUT
;* DENOTES MAY NOT BE PRESENT (USUALLY ONLY FOUND ON PACK 0 OF A STRUCTURE)
;
;CYLINDER 0, HEAD 0 (TRACK 0)
;
;				    SECTOR #
;    0        1         2         3         4         5         6         7
;------------------------------------------------------------------------------
;        ! CORE    ! HOMBAT  ! HOME    ! BAT     ! MONITOR ! CORE    ! CORE
;        ! DMP 768 ! FILE 2  ! BLOCK 2 ! BLOCK 2 ! .SAV    ! DMP 256 ! DMP 512
;        ! XB *    ! XB      !         !         ! XB      ! XB *    ! XB *
;------------------------------------------------------------------------------
;
;
;CYLINDER 0, HEAD 1 (TRACK 1)
;
;				    SECTOR #
;    0        1         2         3         4         5         6         7
;------------------------------------------------------------------------------
;        ! CORE    ! HOMBAT  ! HOME    ! BAT     ! MICRO   ! MICRO   ! BOOT
;        ! DMP 1024! FILE 1  ! BLOCK 1 ! BLOCK 1 ! CODE    ! DIAG    ! STRAP
;        ! XB *    ! XB      !         !         ! XB      ! XB      ! XB
;------------------------------------------------------------------------------


;SENSITIVE PAGE ASSIGNMENT DEFINITIONS

;UNITS

PRMUNT==0		;PRIMARY UNIT OF A STRUCTURE

;CYLINDERS

CYLALL==0		;ALL IN CYLINDER 0

;SURFACES

SRFXB1==1		;PRIMARY HOMBAT XB
SRFHM1==1		;PRIMARY HOMEBLOCK
SRFBB1==1		;PRIMARY BAT BLOCK
SRFXB2==0		;SECONDARY HOMBAT XB
SRFHM2==0		;SECONDARY HOMEBLOCK
SRFBB2==0		;SECONDARY BAT BLOCK
SRFMIC==1		;MICROCODE XB
SRFMCD==1		;MICRO DIAGNOSTICS XB
SRFBOT==1		;BOOTSTRAP XB
SRFMON==0		;DEFAULT MONITOR XB
SRFCD0==0		;CORE DUMP XB 1ST 256K
SRFCD1==0		;CORE DUMP XB 2ND 256K
SRFCD2==0		;CORE DUMP XB 3RD 256K
SRFCD3==1		;CORE DUMP XB 4TH 256K

SRFASF==2		;1ST ADR WE DON'T CARE ABOUT FOR DATA PAGE ASSIGNS

;SECTORS

SECXB1==2		;PRIMARY HOMBAT XB
SECHM1==3		;PRIMARY HOMEBLOCK
SECBB1==4		;PRIMARY BAT BLOCK
SECXB2==2		;SECONDARY HOMBAT XB
SECHM2==3		;SECONDARY HOMEBLOCK
SECBB2==4		;SECONDARY BAT BLOCK
SECMIC==5		;MICROCODE XB
SECMCD==6		;MICRO DIAGNOSTICS XB
SECBOT==7		;BOOTSTRAP XB
SECMON==5		;DEFAULT MONITOR XB
SECCD0==6		;CORE DUMP XB 1ST 256K
SECCD1==7		;CORE DUMP XB 2ND 256K
SECCD2==1		;CORE DUMP XB 3RD 256K
SECCD3==1		;CORE DUMP XB 4TH 256K

SECASF==0		;1ST ADR WE DON'T CARE ABOUT FOR DATA PAGE ASSIGNS



;TABLE OF INDEX BLOCK ADRS FOR PRIMARY HOMBAT FILES FOR ALL PACKS
;INDEXED BY PACK #

..U==0
XB1TBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFXB1>B<SRFLSB>+<SECXB1>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS

;TABLE OF INDEX BLOCK ADRS FOR SECONDARY HOMBAT FILES FOR ALL PACKS
;INDEXED BY PACK #

..U==0
XB2TBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFXB2>B<SRFLSB>+<SECXB2>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS

;DEFINE MACRO HM1MAC FOR REPEATABLE EXPANSION  IN BOOTSTRAP

DEFINE HM1MAC
<..U==0
	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFHM1>B<SRFLSB>+<SECHM1>B<SECLSB>
..U==..U+1
			> ;;END OF REPEAT NPACKS
> ;END HM1MAC

;TABLE OF ADRS FOR PRIMARY HOMEBLOCKS FOR ALL PACKS
;INDEXED BY PACK #

HM1TBL:	HM1MAC


;DEFINE MACRO HM2MAC FOR REPEATABLE EXPANSION  IN BOOTSTRAP

DEFINE HM2MAC
<..U==0
	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFHM2>B<SRFLSB>+<SECHM2>B<SECLSB>
..U==..U+1
			> ;;END OF REPEAT NPACKS
> ;END HM2MAC


;TABLE OF ADRS FOR SECONDARY HOMEBLOCKS FOR ALL PACKS
;INDEXED BY PACK #

HM2TBL:	HM2MAC


;TABLE OF ADRS FOR PRIMARY BATBLOCKS FOR ALL PACKS
;INDEXED BY PACK #

..U==0
BB1TBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFBB1>B<SRFLSB>+<SECBB1>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS

;TABLE OF ADRS FOR SECONDARY BATBLOCKS FOR ALL PACKS
;INDEXED BY PACK #

..U==0
BB2TBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFBB2>B<SRFLSB>+<SECBB2>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS


;OTHER SENSITIVE PAGES TO BE ASSIGNED TO ERROR FREE AREAS

;TABLE OF ADRS FOR MICRO CODE FILE FOR ALL PACKS
;INDEXED BY PACK #

..U==0
MICTBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFMIC>B<SRFLSB>+<SECMIC>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS



;TABLE OF ADRS FOR MICRO DIAG FILE FOR ALL PACKS
;INDEXED BY PACK #

..U==0
MCDTBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFMCD>B<SRFLSB>+<SECMCD>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS

;TABLE OF ADRS FOR BOOTSTRAP FILE FOR ALL PACKS
;INDEXED BY PACK #

..U==0
BOTTBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFBOT>B<SRFLSB>+<SECBOT>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS


;TABLE OF ADRS FOR MONITOR FILE FOR ALL PACKS
;INDEXED BY PACK #

..U==0
MONTBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFMON>B<SRFLSB>+<SECMON>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS





;TABLE OF ADRS WE DON'T CARE ABOUT FOR DATA PAGE ASSIGNS
;INDEXED BY PACK #

..U==0
ASFTBL:	REPEAT NPACKS,<

<..U>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFASF>B<SRFLSB>+<SECASF>B<SECLSB>
..U==..U+1
			> ;END OF REPEAT NPACKS


;FOUND ON PRIMARY PACK ONLY


;CORE DUMP INDEX BLOCK ADR 1ST 256K
CD0ADR==<PRMUNT>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFCD0>B<SRFLSB>+<SECCD0>B<SECLSB>

;CORE DUMP INDEX BLOCK ADR 2ND 256K
CD1ADR==<PRMUNT>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFCD1>B<SRFLSB>+<SECCD1>B<SECLSB>

;CORE DUMP INDEX BLOCK ADR 3RD 256K
CD2ADR==<PRMUNT>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFCD2>B<SRFLSB>+<SECCD2>B<SECLSB>

;CORE DUMP INDEX BLOCK ADR 4TH 256K
CD3ADR==<PRMUNT>B<UNTLSB>+<CYLALL>B<CYLLSB>+<SRFCD3>B<SRFLSB>+<SECCD3>B<SECLSB>



;HOMBLOCK DEFINITIONS

DEFINE DEFHOM (SUFFIX)
<	IRP SUFFIX, <HOM'SUFFIX==..N
		     ..N==..N+1>
>

..N==0		;INIT COUNTER FOR MACRO

DEFHOM <NAM,ID,VER,HW0,HW1,HW2,HW3,HW4>		;00 : 07
DEFHOM <HB1,HB2,MDA,MDF,MCA,MCF,BTA,BTF>	;10 : 17
DEFHOM <MNA,MNF,C0A,C0F,C1A,C1F,C2A,C2F>	;20 : 27
DEFHOM <C3A,C3F,SNM,SFG,SPK,PFG,SWP,NX1>	;30 : 37
DEFHOM <NX2,DR1,DR2,SPR>			;40 : 43


..N==HOMLEN-2	;2ND PART INIT COUNTER FOR MACRO

DEFHOM <COD,SLF>				;HOMLEN-2,HOMLEN-1

;PARAMETERS

VERHOM==1		;VERSION
HOMLEN==1000		;FULL PAGE DEVOTED TO HOMEBLOCK
CODHOM==707070


;FLAGS ASSEMBLED INTO HOME BLOCKS

MCDFGS==0		;MICRO DIAG FLAGS
MICFGS==0		;MICRO CODE FLAGS
BOTFGS==0		;BOOTSTRAP FLAGS
MONFGS==0		;DEFAULT MONITOR FLAGS
CD0FGS==0		;CORE DUMP FLAGS 1ST 256K
CD1FGS==0		;CORE DUMP FLAGS 2ND 256K
CD2FGS==0		;CORE DUMP FLAGS 3RD 256K
CD3FGS==0		;CORE DUMP FLAGS 4TH 256K
STRFGS==0		;STRUCTURE FLAGS
PAKFGS==0		;PACK FLAGS



;HOMEBLOCK PROTOTYPE (.-. TO BE FILLED IN)

HOMPRO:	SIXBIT /HOME/					;HOMNAM
	.-.						;HOMID
	VERHOM,,HOMLEN					;HOMVER
	<NUNTBT>B8+<NCYLBT>B17+<NSRFBT>B26+<NSECBT>B35	;HOMHW0
	NTKUN,,NSURFS					;HOMHW1
	NSECS,,NWSEC					;HOMHW2
	<NTKUN*NSURFS*NSECS>,,<NSURFS*NSECS>		;HOMHW3
	0						;HOMHW4
	.-.						;HOMHB1
	.-.						;HOMHB2
	.-.						;HOMMDA
	MCDFGS						;HOMMDF
	.-.						;HOMMCA
	MICFGS						;HOMMCF
	.-.						;HOMBTA
	BOTFGS						;HOMBTF
	.-.						;HOMMNA
	MONFGS						;HOMMNF
	CD0ADR						;HOMC0A
	CD0FGS						;HOMC0F
	CD1ADR						;HOMC1A
	CD1FGS						;HOMC1F
	CD2ADR						;HOMC2A
	CD2FGS						;HOMC2F
	CD3ADR						;HOMC3A
	CD3FGS						;HOMC3F
	SIXBIT /PS/					;HOMSNM
	STRFGS						;HOMSFG
	NPACKS,,.-.					;HOMSPK
	PAKFGS						;HOMPFG
	SWPTK,,SWPTKH-1					;HOMSWP

HOMPLN==.-HOMPRO		;LENGTH OF A HOME BLOCK PROTOTYPE



;CALL CRTHOM FOR ALL PACKS

CRTHMA:	PUSH P,1
	PUSH P,2
	HRROI 1,[ASCIZ/
Creating HOME Blocks and associated files./]
	PSOUT
	MOVSI 2,-NPACKS		;AOBJN FOR PACKS
CRTHM1:	HRRZ 1,2		;LOGICAL PACK # IN 1
	CALL CRTHOM
	AOBJN 2,CRTHM1
	POP P,2
	POP P,1
	AOS HBXSTF			;SAY HOMBAT FILES EXIST
	RET

;CREATE HOME BLOCKS FOR PACK
;ACCEPTS LOGICAL PACK # IN 1

CRTHOM:	ACMAC <%UNIT,%AC2,%AC3,%AC4>	;SAVE ACS
	VARMAC <$HBN,$PAGE,$OFN,$JFN>	;RESERVE INFO STUFF
	MOVEI 2,1			;INDEX BLOCK 1
	MOVEM 2,$HBN			;SAVE FOR FUTURE REF
CRTHO1:	MOVE 1,%UNIT
	CALL MPHMXB			;MAP THE INDEX BLOCK
	MOVE 1,%UNIT
	MOVE 2,$HBN
	MOVEM 3,$PAGE			;REMEMBER MAPPED PAGE ADR
	MOVEM 4,$OFN			;AND THE OFN
	CALL STHMXB			;SET UP XB
	MOVE 3,$PAGE
	MOVE 4,$OFN
	CALL RLHMXB			;RELEASE THE XB
	MOVE 1,%UNIT
	MOVE 2,$HBN
	CALL MKHMFL			;MAKE AND RELEASE FILE
	MOVE 1,%UNIT
	MOVE 2,$HBN
	CALL MAPHOM			;NOW USE FILE TO MAP HB
	 BUG (HLT,<CRTHOM: FAILED TO MAP JUST CREATED HB>)
	MOVEM 3,$PAGE			;KNOW PAGE ITS MAPPED TO
	MOVEM 4,$JFN			;KNOW JFN
	MOVE 1,%UNIT
	MOVE 2,$HBN
	CALL FILLHB			;FILL HB
	MOVE 1,%UNIT
	MOVE 2,$HBN
	MOVE 3,$PAGE
	MOVE 4,$JFN
	TLO 3,(1B0)			;INSURE IT GETS TO DISK
	CALL RELHOM			;RELEASE HB
	  BUG (HLT,<CRTHOM: FAILED TO RELEASE HB>)
	AOS 2,$HBN			;DO BOTH PRIMARY AND SECONDARY
	CAIG 2,2
	 JRST CRTHO1			;LOOP FOR NEXT
	RET

	PURGE %UNIT,%AC2,%AC3,%AC4
	PURGE $HBN,$PAGE,$OFN,$JFN


;ASSIGN AND MAP XB FOR HOME BLOCK
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ HOME BLOCK #

;RETURNS 3/ PAGE ADR MAPPED TO
;	 4/ OFN

MPHMXB:	MOVEI 0,TYPHOM		;TYPE OF BLOCK ITS FOR
	JRST MAPXB


;FILL OUT HOME XB AND ASSIGN HOME BLOCK SO NOT POINTING TO UNASSIGNED PAGE
;ACCEPTS 1/ LOGICAL PACK #
;	 2/ HOME BLOCK #
;	 3/ PAGE ITS MAPPED TO

STHMXB:	MOVEI 0,TYPHOM
	JRST SETXB


;UNMAP AND RELEASE HOME XB
;ACCEPTS 3/ PAGE ITS MAPPED TO
;	 4/ OFN

RLHMXB:	MOVEI 0,TYPHOM
	JRST RELXB


;CREATES AND RELEASES HOMEBLOCK FILE PTING TO PROPER XB
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ # OF BLOCK INVOLVED

MKHMFL:	MOVEI 0,TYPHOM
	JRST MAKFL


;MAP HOMEBLOCK TO PAGE, READ AND WRITE
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ HB #

;RETURNS 3/ PAGE ADR
;	 4/ JFN

;SKIPS IF SUCCESS, NO SKIP POSSIBLY WITH ERROR CODE IN 1

MAPHOM:	MOVEI 0,TYPHOM
	SKIPN FILIFG			;OK TO USE FILE SYSTEM YET?
	 JRST MP.BLK			;NO-JUST READ IT IN
	JRST MAPBLK


;UNMAP AND RELEASE HOMEBLOCK
;WRITING TO DISK IS ONLY MEANINGFUL IF THE FILESYSTEM IS NOT BEING
;USED FOR THE MAPPING.  ITS FOR HARD DISK WRITING ONLY WHEN NECESSARY
;WEN NOT USING THE FILESYSTEM FOR MAPPING.

;ACCEPTS 1/ UNIT
;	 2/ BLOCK #
;	 3/ PAGE ADR ITS MAPPED TO, 1B0 ON FOR WRITE IT TO DISK
;	 4/ JFN

;SKIPS IF SUCCESS, NO SKIP WITH ERROR CODE IN 1

RELHOM:	MOVEI 0,TYPHOM
	SKIPN FILIFG			;OK TO USE FILE SYSTEM YET?
	 JRST RL.BLK			;NO-UNMAP IT WITHOUT ITS HELP
	TLZ 3,(1B0)			;CLEAR WRITE FLAG, WRITING MEANINGLESS
	JRST RELBLK



;FILL OUT HOME BLOCK
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ HB #
;	 3/ PAGE ADR ITS MAPPED TO

FILLHB:	ACMAC <%UNIT,%HBN,%PAGE,%AC4>
	MOVE 3,%PAGE			;3/ MAPPED ADR
	HRLI 1,HOMPRO			;PROTOTYPE
	HRR 1,%PAGE			;TO HERE
	BLT 1,HOMPLN-1(3)		;COPY PROTO TO MAPPED HB
	HRLI 1,HOMPLN(3)		;AND CLEAR REST OF BLOCK
	HRRI 1,HOMPLN+1(3)
	SETZM HOMPLN(3)
	BLT 1,HOMLEN-1(3)
	MOVE 1,%HBN			;NOW FILL IT OUT
	ADDI 1,'0'			;MAKE # SIXBIT
	DPB 1,[POINT 6,HOMID(3),5]
	MOVE 2,%UNIT
	MOVE 1,XB1TBL(2)		;PRIMARY HOMBAT XB FOR UNIT
	MOVEM 1,HOMHB1(3)
	MOVE 1,XB2TBL(2)		;SECONDARY HOMBAT XB FOR UNIT
	MOVEM 1,HOMHB2(3)
	MOVE 1,MCDTBL(2)		;MICRO DIAG XB
	MOVEM 1,HOMMDA(3)
	MOVE 1,MICTBL(2)		;MICRO CODE XB
	MOVEM 1,HOMMCA(3)
	MOVE 1,BOTTBL(2)		;BOOTSTRAP XB
	MOVEM 1,HOMBTA(3)
	MOVE 1,MONTBL(2)		;MONITOR XB
	MOVEM 1,HOMMNA(3)
	HRRM 2,HOMSPK(3)		;LOGICAL UNIT #
	MOVE 1,DIDSCA			;INDEX.;1 XB ADR LINEAR
	CALL CVDSK			;MAKE HARDWARE ADR
	MOVE 3,%PAGE
	MOVEM 1,HOMNX1(3)
	SETZM HOMNX2(3)			;NO BACKUP INDEX.;2 CURRENTLY
	MOVE 1,FDDSCA			;DIRECTORY.;1 XB ADR LINEAR
	CALL CVDSK			;MAKE HARDWARE ADR
	MOVE 3,%PAGE
	MOVEM 1,HOMDR1(3)
	SETZM HOMDR2(3)			;NO BACKUP DIRECTORY.;2 CURRENTLY
	MOVEI 1,CODHOM			;SPECIAL CODE
	MOVEM 1,HOMCOD(3)
	MOVE 4,%HBN
	MOVE 2,%UNIT
	MOVE 1,HM1TBL(2)		;ASSUME PRIMARY HB ADR FOR UNIT
	CAIE 4,1			;IS IT?
	 MOVE 1,HM2TBL(2)		;NO-GET SECONDARY HB ADR FOR UNIT
	MOVEM 1,HOMSLF(3)		;STORE PTR TO SELF
	RET

	PURGE %UNIT,%HBN,%PAGE,%AC4



;CHECK HOME BLOCK CONSISTENCY

;ACCEPTS 1/ PAGE HOME BLOCK IS MAPPED TO
;RETURNS +1 LOOKS BAD
;	 +2 LOOKS OK

;DOES NOT CHECK XB ADRS, FLAGS, ETC. SINCE MAY BE CHANGED ON THE
;FLY OR DURING TRYING TO PIECE BROKEN SYSTEM TOGETHER

CHKHOM:	ACMAC <%PAGE,%AC2,%AC3,%AC4>
	MOVE 2,HOMNAM(1)
	CAME 2,[SIXBIT/HOME/]
	 RET
	MOVE 2,HOMID(1)
	CAME 2,[SIXBIT/1/]
	CAMN 2,[SIXBIT/2/]
	 CAIA
	RET
	MOVE 2,HOMVER(1)
	CAME 2,[VERHOM,,HOMLEN]
	 RET
	MOVE 2,HOMHW0(1)
	CAME 2,[<NUNTBT>B8+<NCYLBT>B17+<NSRFBT>B26+<NSECBT>B35]
	 RET
	MOVE 2,HOMHW1(1)
	CAME 2,[NTKUN,,NSURFS]
	 RET
	MOVE 2,HOMHW2(1)
	CAME 2,[NSECS,,NWSEC]
	 RET
	MOVE 2,HOMHW3(1)
	CAME 2,[<NTKUN*NSURFS*NSECS>,,<NSURFS*NSECS>]
	 RET
	MOVE 2,HOMSNM(1)
	CAME 2,[SIXBIT/PS/]
	 RET
	MOVE 2,HOMCOD(1)
	CAIN 2,CODHOM
	 AOS (P)
	RET

	PURGE %PAGE,%AC2,%AC3,%AC4



;READS HOMEBLOCKS UNTIL A GOOD ONE IS FOUND AND RETURNS
;DIDSCA IN AC1.  THIS IS BECAUSE ONLY THE HOMEBLOCKS TRULY
;KNOW WHERE THE WORLD STARTS SINCE DIDSCI MIGHT HAVE BEEN
;A BAD SPOT AND WAS SKIPPED OVER VIA BAT BLOCK LOGIC.

;RETURNS 1/ VALUE OF DIDSCA TO BE BELIEVED

DEFDIA:	ACMAC <%DIA,%AC2,%AC3,%AC4>
	VARMAC <$AOBJN,$GOODB,$PAGE,$RCORE>
	MOVSI 1,-NPACKS
DEFDI1:	MOVEM 1,$AOBJN			;LOOP BACK TO HERE
	HRRZ 1,$AOBJN			;GET UNIT #
	MOVEI 2,1			;BLOCK 1
	MOVEM 2,$GOODB			;ASSUME IT WILL BE GOOD
	CALL MAPHOM			;READ IT
	 JRST DEFDIM			;FAILED TO MAP
	MOVEM 3,$PAGE			;SAVE WHERE IT IS
	MOVEM 4,$RCORE			;AND ITS REAL CORE ADR
	MOVE 1,$PAGE
	CALL CHKHOM			;PRIMARY OK?
	 CAIA				;NOPE-TRY SECONDARY
	JRST DEFDI2			;YES-USE IT
	HRRZ 1,$AOBJN			;UNIT
	MOVEI 2,1
	MOVE 3,$PAGE
	MOVE 4,$RCORE
	CALL RELHOM			;RELEASE THE PRIMARY
	 JRST DEFDIR			;FAILED TO UNMAP
	HRRZ 1,$AOBJN			;UNIT
	MOVEI 2,2			;BLOCK 2
	MOVEM 2,$GOODB			;ASSUME IT WILL BE GOOD
	CALL MAPHOM			;READ IT
	 JRST DEFDIM			;FAILED TO MAP
	MOVEM 3,$PAGE			;SAVE WHERE IT IS
	MOVEM 4,$RCORE			;AND ITS REAL CORE ADR
	MOVE 1,$PAGE
	CALL CHKHOM			;SECONDARY OK?
	 JRST DEFDI3			;NO-NEXT PACK
DEFDI2:	MOVE 1,$PAGE
	MOVE 1,HOMNX1(1)		;GET HDWR FORMAT DIDSCA
	CALL CDSKVA			;MAKE IT LINEAR SOFT
	TLO 1,(DSKABT)			;DSKABT ON
	MOVEM 1,%DIA			;RET TO USER
	HRRZ 1,$AOBJN			;UNIT
	MOVE 2,$GOODB			;BLOCK #
	MOVE 3,$PAGE
	MOVE 4,$RCORE
	CALL RELHOM			;RELEASE MAPPED BLOCK
	 JRST DEFDIR			;FAILED TO UNMAP
	RET

DEFDI3:	HRRZ 1,$AOBJN			;UNIT
	MOVEI 2,2			;SECONDARY
	MOVE 3,$PAGE
	MOVE 4,$RCORE
	CALL RELHOM			;UNMAP BAD SEC HOME BLK
	 JRST DEFDIR			;FAILED TO UNMAP
	MOVE 1,$AOBJN
	AOBJN 1,DEFDI1			;LOOP FOR ALL PACKS TIL DONE
	BUG (HLT,<DEFDIA: FAILED TO READ DIDSCA FROM HOME BLOCKS>)
	MOVE 1,DIDSCI
	MOVEM 1,%DIA			;PROBABLY WILL WORK
	RET

DEFDIM:	BUG (HLT,<DEFDIA: FAILED TO MAP HOME BLOCK>)
DEFDIR:	BUG (HLT,<DEFDIA: FAILED TO RELEASE HOME BLOCK>)

	PURGE %DIA,%AC2,%AC3,%AC4
	PURGE $AOBJN,$GOODB,$PAGE,$RCORE



;BAT BLOCK DEFINITIONS

DEFINE DEFBAT (SUFFIX)
<	IRP SUFFIX, <BAT'SUFFIX==..N
		     ..N==..N+1>
>

..N==0		;INIT COUNTER FOR MACRO

DEFBAT <NAM,ID,VER,HW0,HB1,HB2,FRE,CNT,SPR,DAT>	;00 : 11

..N==BATLEN-2	;2ND PART INIT COUNTER FOR MACRO

DEFBAT <COD,SLF>


;PARAMETERS ASSEMBLED INTO BAT BLOCK HEADERS

VERBAT==1			;VERSION
BATLEN==1000			;LENGTH OF ENTIRE BLOCK
FREBAT==BATCOD-BATDAT-1		;INITIAL FREE COUNT
INIBAT==0			;INITIAL INITIAL COUNT
ADDBAT==0			;INITIAL ADDED COUNT
CODBAT==606060

OPDEF BATSCT [POINT NUNTBT,0,UNTLSB]	;PTR TO SECTOR COUNT FIELD IN ENTRY
OPDEF BATADR [POINT <NCYLBT+NSRFBT+NSECBT>,0,^D35] ;PTR TO HDWR SECTOR ADR IN ENTRY


;BATBLOCK HEADER PROTOTYPE (.-. TO BE FILLED IN)

BATPRO:	SIXBIT /BAT/					;BATNAM
	.-.						;BATID
	VERBAT,,BATLEN					;BATVER
	<NUNTBT>B8+<NCYLBT>B17+<NSRFBT>B26+<NSECBT>B35	;BATHW0
	.-.						;BATHB1
	.-.						;BATHB2
	FREBAT						;BATFRE
	INIBAT,,ADDBAT					;BATCNT

BATPLN==.-BATPRO		;LENGTH OF A BAT PROTOTYPE


;CREATION OF BAT BLOCKS IS ONLY AN OPTION FOR SYSLODS
;IF YOU WANT TO PLAY WITH THEM ON AN EXISTANT FILESYSTEM - DO
;IT THRU THE FILESYSTEM STANDALONE.

;CALL CRTBAT FOR ALL PACKS

CRTBAA:	PUSH P,1
	PUSH P,2
	HRROI 1,[ASCIZ/
Examining BAT blocks./]
	PSOUT
	MOVSI 2,-NPACKS		;AOBJN FOR PACKS
CRTAA1:	HRRZ 1,2		;LOGICAL PACK # IN 1
	CALL CRTBAT
	AOBJN 2,CRTAA1
	POP P,2
	POP P,1
	RET

;CREATE BAT BLOCKS FOR PACK
;IF THE BLOCK CURRENTLY ON THE PACK LOOKS BAD, MAKE USER INIT IT
;OTHERWISE ACCEPT IT, NEVER OVERWRITING GOOD BAT BLOCKS

;ACCEPTS LOGICAL PACK # IN 1

CRTBAT:	ACMAC <%UNIT,%AC2,%AC3,%AC4>	;SAVE ACS
	VARMAC <$PAGE1,$PAGE2,$JFN1,$JFN2>
	MOVE 1,%UNIT			;MAP BOTH BLOCKS
	MOVEI 2,1
	CALL MAPBAT			;WITHOUT FILE SYSTEM
	 BUG (HLT,<CRTBAT: FAILED TO MAP PRIMARY BAT BLK>)
	MOVEM 3,$PAGE1
	MOVEM 4,$JFN1
	MOVE 1,%UNIT
	MOVEI 2,2
	CALL MAPBAT
	 BUG (HLT,<CRTBAT: FAILED TO MAP SECONDARY BAT BLK>)
	MOVEM 3,$PAGE2
	MOVEM 4,$JFN2
	MOVE 1,$PAGE1
	CALL CHKBAT			;IS PRIMARY OK?
	 JRST CRTBA3			;NO
	MOVE 1,$PAGE2
	CALL CHKBAT			;IS SECONDARY OK?
	 JRST CRTBA2			;NO-COPY PRIMARY TO IT
	MOVE 1,DBUGSW
	CAIE 1,2			;DEBUGGING?
	 JRST CRTBA5			;NO-ACCEPT GOOD BATS
	SKIPN BATDBG			;ALLOW SMART USER AT THEM?
	 JRST CRTBA5			;NO-TAKE NO CHANCES
	HRROI 1,[ASCIZ/
You are being given this option because you are debugging BAT blocks!
Clobber GOOD!!! BAT blocks for pack /]
	PSOUT
	MOVEI 1,101
	MOVE 2,%UNIT
	MOVEI 3,12
	NOUT
	 JFCL
	HRROI 1,[ASCIZ/? /]
	PSOUT
	CALL RPLUSR
	 JRST CRTBA5			;NO-BOTH OK TO USE AS IS
	JRST CRTBA1			;YES-CLOBBER BOTH OF EM



CRTBA2:	MOVSI 1,(1B0)			;TURN ON FLAG TO INSURE WRITE
	IORM 1,$PAGE2			;OF SECONDARY TO DISK
	HRROI 1,[ASCIZ/
Copying primary BAT block to secondary BAT block for pack /]
	PSOUT
	MOVEI 1,101
	MOVE 2,%UNIT
	MOVEI 3,12
	NOUT
	 JFCL
	HRROI 1,[ASCIZ/.
/]
	PSOUT
	HRL 1,$PAGE1			;NO-COPY PIMARY TO IT THEN
	HRR 1,$PAGE2
	HRRZ 3,$PAGE2
	BLT 1,BATLEN-1(3)
	MOVE 1,[SIXBIT/2/]		;AND FIX IT UP
	MOVEM 1,BATID(3)
	MOVE 2,%UNIT
	LDB 1,[BATADR BB2TBL(2)]	;GET JUST CYL,HD,SEC OF SELF
	MOVEM 1,BATSLF(3)
	JRST CRTBA5			;BOTH OK NOW

;HERE IF PRIMARY IS BAD

CRTBA3:	MOVSI 1,(1B0)			;TURN ON FLAG TO INSURE WRITE
	IORM 1,$PAGE1			;OF PRIMARY TO DISK WHEN RELEASED
	MOVE 1,$PAGE2
	CALL CHKBAT			;IS SECONDARY OK?
	 JRST CRTBA4			;NO-TWO LOSERS
	HRROI 1,[ASCIZ/
Copying secondary BAT block to primary BAT block for pack /]
	PSOUT
	MOVEI 1,101
	MOVE 2,%UNIT
	MOVEI 3,12
	NOUT
	 JFCL
	HRROI 1,[ASCIZ/.
/]
	PSOUT
	HRL 1,$PAGE2			;YES-COPY SECONDARY TO PRIMARY
	HRR 1,$PAGE1
	HRRZ 3,$PAGE1
	BLT 1,777(3)
	MOVE 1,[SIXBIT/1/]		;AND FIX IT UP
	MOVEM 1,BATID(3)
	MOVE 2,%UNIT
	LDB 1,[BATADR BB1TBL(2)]	;GET JUST CYL,HD,SEC OF SELF
	MOVEM 1,BATSLF(3)
	JRST CRTBA5



;HERE WHEN BOTH PRIMARY AND SECONDARY BAT BLOCKS FUCKED UP

CRTBA4: HRROI 1,[ASCIZ/
Both BAT blocks on pack /]
	PSOUT
	MOVEI 1,101
	MOVE 2,%UNIT
	MOVEI 3,12
	NOUT
	 JFCL
	HRROI 1,[ASCIZ/ look bad.  Reinitialize them? /]
	PSOUT
	CALL RPLUSR
	 JRST CRTBA5			;NO-JUST UNMAP THEM, STAY BROKEN
CRTBA1:	MOVE 1,%UNIT
	MOVEI 2,1			;REINIT PRIMARY
	MOVE 3,$PAGE1
	CALL FILLBB			;INIT IT
	MOVSI 1,(1B0)			;TURN ON FLAG TO INSURE PRIMARY
	IORM 1,$PAGE1			;IS WRITTEN OUT TO DISK
	HRROI 1,[ASCIZ/
Primary BAT Done.  Use a FLAW map to initialize the BAT data? /]
	PSOUT
	CALL RPLUSR
	 JRST CRTBA2			;NO-COPY PRIMARY TO SECONDARY
	CALL GETFLW			;YES-GET FLAW MAP INFO, BUILD TABLES
	MOVE 4,$PAGE1			;1,2,3 SETUP.  4/ ADR OF BAT BLK MAPPED
	CALL BATFLW			;MAKE BAT ENTRIES FROM FLAW MAP TABLES
	CALL RELFLW			;RELEASE THE FLAW MAP
	JRST CRTBA2			;NOW COPY IT ALL TO SECONDARY

CRTBA5:	MOVE 1,%UNIT			;UNMAP BOTH BLOCKS
	MOVEI 2,1
	MOVE 3,$PAGE1			;1B0 MEANS WRITE IT OUT
	MOVE 4,$JFN1
	CALL RELBAT
	 BUG (HLT,<CRTBAT: FAILED TO UNMAP PRIMARY BAT BLK>)
	MOVE 1,%UNIT
	MOVEI 2,2
	MOVE 3,$PAGE2			;1B0 MEANS WRITE IT OUT
	MOVE 4,$JFN2
	CALL RELBAT
	 BUG (HLT,<CRTBAT: FAILED TO UNMAP SECONDARY BAT BLK>)
	RET

	PURGE %UNIT,%AC2,%AC3,%AC4
	PURGE $PAGE1,$PAGE2,$JFN1,$JFN2



;GETS REPLY Y OR N FROM CTY
;SKIPS IF Y, NO SKIP IF N

RPLUSR:	PUSH P,1
RPLUS1:	PBIN
	TRZ 1,40
	CAIN 1,"Y"
	 JRST RPLUYE
	CAIN 1,"N"
	 JRST RPLUNO
	HRROI 1,[ASCIZ/ Y or N? /]
	PSOUT
	JRST RPLUS1

RPLUYE:	AOS -1(P)
RPLUNO:	POP P,1
	RET



;ASSIGN AND MAP XB FOR BAT BLOCK
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ BAT BLOCK #

;RETURNS 3/ PAGE ADR MAPPED TO
;	 4/ OFN

MPBBXB:	MOVEI 0,TYPBAT
	JRST MAPXB


;FILL OUT BAT XB AND ASSIGN BAT BLOCK SO NOT POINTING TO UNASSIGNED PAGE
;ACCEPTS 1/ LOGICAL PACK #
;	 2/ BAT BLOCK #
;	 3/ PAGE ITS MAPPED TO

STBBXB:	MOVEI 0,TYPBAT
	JRST SETXB


;UNMAP AND RELEASE BAT XB
;ACCEPTS 3/ PAGE ITS MAPPED TO
;	 4/ OFN

RLBBXB:	MOVEI 0,TYPBAT
	JRST RELXB


;CREATES AND RELEASES BATBLOCK FILE PTING TO PROPER XB
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ # OF BLOCK INVOLVED

MKBBFL:	MOVEI 0,TYPBAT
	JRST MAKFL


;MAP BATBLOCK TO PAGE, READ AND WRITE
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ BLOCK #

;RETURNS 3/ PAGE ADR
;	 4/ JFN

;SKIPS IF SUCCESS, NO SKIP POSSIBLY WITH ERROR CODE IN 1

MAPBAT:	MOVEI 0,TYPBAT
	SKIPN FILIFG			;OK TO USE FILE SYSTEM YET?
	 JRST MP.BLK			;NO-JUST READ IT IN
	JRST MAPBLK


;UNMAP AND RELEASE BATBLOCK
;WRITING TO DISK IS ONLY MEANINGFUL IF THE FILESYSTEM IS NOT BEING
;USED FOR THE MAPPING.  ITS FOR HARD DISK WRITING ONLY WHEN NECESSARY
;WEN NOT USING THE FILESYSTEM FOR MAPPING.

;ACCEPTS 1/ UNIT
;	 2/ BLOCK #
;	 3/ PAGE ADR ITS MAPPED TO, 1B0 ON FOR WRITE IT TO DISK
;	 4/ JFN

;SKIPS IF SUCCESS, NO SKIP WITH ERROR CODE IN 1

RELBAT:	MOVEI 0,TYPBAT
	SKIPN FILIFG			;OK TO USE FILE SYSTEM YET?
	 JRST RL.BLK			;NO-UNMAP IT WITHOUT ITS HELP
	TLZ 3,(1B0)			;CLEAR WRITE FLAG, WRITING MEANINGLESS
	JRST RELBLK



;FILL OUT BAT BLOCK
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ BLOCK #
;	 3/ PAGE ADR ITS MAPPED TO

FILLBB:	ACMAC <%UNIT,%BBN,%PAGE,%AC4>
	MOVE 3,%PAGE			;3/ MAPPED ADR
	HRLI 1,BATPRO			;PROTOTYPE
	HRR 1,%PAGE			;TO HERE
	BLT 1,BATPLN-1(3)		;COPY PROTO TO MAPPED BAT BLK
	HRLI 1,BATPLN(3)		;AND CLEAR REST OF BLOCK
	HRRI 1,BATPLN+1(3)
	SETZM BATPLN(3)
	BLT 1,BATLEN-1(3)
	MOVE 1,%BBN			;NOW FILL IT OUT
	ADDI 1,'0'			;MAKE # SIXBIT
	DPB 1,[POINT 6,BATID(3),5]
	MOVE 2,%UNIT
	LDB 1,[BATADR XB1TBL(2)]	;PRIMARY HOMBAT XB SANS UNIT FIELD
	MOVEM 1,BATHB1(3)
	LDB 1,[BATADR XB2TBL(2)]	;SECONDARY HOMBAT XB SANS UNIT FIELD
	MOVEM 1,BATHB2(3)
	MOVEI 1,CODBAT			;SPECIAL CODE
	MOVEM 1,BATCOD(3)
	MOVE 4,%BBN
	MOVE 2,%UNIT
	LDB 1,[BATADR BB1TBL(2)]	;ASSUME PRIMARY HB ADR FOR UNIT
	CAIE 4,1			;IS IT?
	 LDB 1,[BATADR BB2TBL(2)]	;NO-GET SECONDARY HB ADR FOR UNIT
	MOVEM 1,BATSLF(3)		;STORE PTR TO SELF
	RET

	PURGE %UNIT,%BBN,%PAGE,%AC4



;CHECK BAT BLOCK CONSISTENCY

;ACCEPTS 1/ PAGE BAT BLOCK IS MAPPED TO
;RETURNS +1 LOOKS BAD
;	 +2 LOOKS OK

CHKBAT:	ACMAC <%PAGE,%AC2,%AC3,%AC4>
	MOVE 2,BATNAM(1)
	CAME 2,[SIXBIT/BAT/]
	 RET
	MOVE 2,BATID(1)
	CAME 2,[SIXBIT/1/]
	CAMN 2,[SIXBIT/2/]
	 CAIA
	RET
	MOVE 2,BATVER(1)
	CAME 2,[VERBAT,,BATLEN]
	 RET
	MOVE 2,BATHW0(1)
	CAME 2,[<NUNTBT>B8+<NCYLBT>B17+<NSRFBT>B26+<NSECBT>B35]
	 RET
	MOVE 2,BATFRE(1)			;CURRENT FREE COUNT
	HLRZ 3,BATCNT(1)			;INITIAL USED COUNT
	HRRZ 4,BATCNT(1)			;ADDED USED COUNT
	ADD 3,4					;3/ USED
	ADD 2,3					;2/ TOTAL FREE AND USED
	CAIE 2,FREBAT				;BETTER BE SAME AS INIT FREE
	 RET
	MOVE 2,BATCOD(1)
	CAIN 2,CODBAT
	 AOS (P)
	RET

	PURGE %PAGE,%AC2,%AC3,%AC4



;CALL CRTBAF FOR ALL PACKS

CRTBFA:	PUSH P,1
	PUSH P,2
	HRROI 1,[ASCIZ/
Creating BAT blocks and associated files./]
	PSOUT
	MOVSI 2,-NPACKS		;AOBJN FOR PACKS
CRTFA1:	HRRZ 1,2		;LOGICAL PACK # IN 1
	CALL CRTBAF
	AOBJN 2,CRTFA1
	POP P,2
	POP P,1
	AOS HBXSTF			;SAY HOMBAT FILES EXIST
	RET




;CREATE BAT BLOCK FILES NOW THAT FILE SYSTEM EXISTS

;ACCEPTS LOGICAL PACK # IN 1

CRTBAF:	ACMAC <%UNIT,%AC2,%AC3,%AC4>	;SAVE ACS
	VARMAC <$BBN,$PAGE,$OFN>	;RESERVE INFO STUFF
	MOVEI 2,1			;INDEX BLOCK 1
	MOVEM 2,$BBN			;SAVE FOR FUTURE REF
CRTBF1:	MOVE 1,%UNIT
	CALL MPBBXB			;MAP THE INDEX BLOCK
	MOVE 1,%UNIT
	MOVE 2,$BBN
	MOVEM 3,$PAGE			;REMEMBER MAPPED PAGE ADR
	MOVEM 4,$OFN			;AND THE OFN
	CALL STBBXB			;SET UP XB
	MOVE 3,$PAGE
	MOVE 4,$OFN
	CALL RLBBXB			;RELEASE THE XB
	MOVE 1,%UNIT
	MOVE 2,$BBN
	CALL MKBBFL			;MAKE AND RELEASE FILE
	MOVE 1,%UNIT
	MOVE 2,$BBN
	CALL MAPBAT			;NOW USE FILE TO MAP BAT
	 BUG (HLT,<CRTBAF: FAILED TO MAP JUST CREATED BAT>)
	MOVES (3)			;TOUCH IT
	CALL RELBAT			;RELEASE BAT, SEEMS TO WORK!
	  BUG (HLT,<CRTBAF: FAILED TO RELEASE BAT>)
	AOS 2,$BBN			;DO BOTH PRIMARY AND SECONDARY
	CAIG 2,2
	 JRST CRTBF1			;LOOP FOR NEXT
	RET

	PURGE %UNIT,%AC2,%AC3,%AC4
	PURGE $BBN,$PAGE,$OFN



;TEMP GET FLAW MAP ROUTINE
;BUILDS CYL,,HEAD TABLE AND POSITION,,LENGTH TABLE

;RETURNS 1/ ADR OF CYL,,HEAD TABLE
;	 2/ ADR OF POS,,LENGTH TABLE
;	 3/ USEABLE LENGTH OF THOSE TABLES

GETFLW:	ACMAC <%C.HTB,%P.LTB,%LEN,%AC4>
	CALL ASGPAG
	 BUG (HLT,<GETFLW: FAILED TO ASGPAG FOR CYL,,HEAD TABLE>)
	MOVEM 1,%C.HTB
	CALL ASGPAG
	 BUG (HLT,<GETFLW: FAILED TO ASGPAG FOR POS,,LEN TABLE>)
	MOVEM 1,%P.LTB
	HRROI 1,[ASCIZ/

GETFLW: Enter Clyinder,,Head in table starting at /]
	PSOUT
	MOVEI 1,101
	MOVE 2,%C.HTB
	MOVEI 3,10
	NOUT
	 JFCL
	HRROI 1,[ASCIZ/
        Enter Position,,Length in table starting at /]
	PSOUT
	MOVEI 1,101
	MOVE 2,%P.LTB
	MOVEI 3,10
	NOUT
	 JFCL
	HRROI 1,[ASCIZ/
        and # of entries in AC 1.  BUGCHK coming up.
        $P when ready.
/]
	PSOUT
	MOVEI 1,101
	DOBE
	MOVE 1,%C.HTB
	HRLI 2,(1)
	HRRI 2,1(1)
	SETZM (1)
	BLT 2,777(1)
	MOVE 1,%P.LTB
	HRLI 2,(1)
	HRRI 2,1(1)
	SETZM (1)
	BLT 2,777(1)
GETFL1:	SETO 1,			;CHECK ON PROPER SETTING OF AC 1
	BUG (CHK,<GETFLW: FAKE RTN, BUILD TABLES, SET AC 1, $P>)
	JUMPGE 1,GETFL2
	HRROI 1,[ASCIZ/
You forgot to indicate the length of the tables in AC 1.
Do it.  Tables still intact.
/]
	PSOUT
	MOVEI 1,101
	DOBE
	JRST GETFL1

GETFL2:	MOVEM 1,%LEN
	RET

	PURGE %C.HTB,%P.LTB,%LEN,%AC4

;RELEASES PAGES ASSIGNED FOR ABOVE FLAW MAP CROCK

;ACCEPTS 1/ ADR OF CYL,,HEAD TABLE
;	 2/ ADR OF POS,,LENGTH TABLE

RELFLW:	ACMAC <%C.HTB,%P.LTB,%AC3,%AC4>
	MOVEI 1,%C.HTB
	CALL RELPAG
	MOVEI 1,%P.LTB
	CALL RELPAG
	RET

	PURGE %C.HTB,%P.LTB,%AC3,%AC4



;FILL OUT BAT BLOCK GIVEN TABLES OF FLAW MAP ENTRIES

;ACCEPTS 1/ ADR OF CYL,,HEAD TABLE
;	 2/ ADR OF POSITION,,LENGTH TABLE
;	 3/ LENGTH OF THOSE TABLES
;	 4/ ADR OF BAT BLOCK TO BE FILLED OUT

BATFLW:	ACMAC <%C.H,%P.L,%LEN,%BAT>
	VARMAC <$SEC1,$SEC2,$SEC3,$SECNT,$FLWAP>
	NOSKED			;WHOLE THING IS NOSKED
	MOVEI 1,FREBAT		;INIT COUNTS
	MOVEM 1,BATFRE(4)
	MOVE 1,[INIBAT,,ADDBAT]
	MOVEM 1,BATCNT(4)
	HRLI 1,BATDAT(4)
	HRRI 1,BATDAT+1(4)
	SETZM BATDAT(4)
	BLT 1,BATCOD-1(4)	;CLEAR ALL OF DATA AREA
	SKIPN %LEN		;ANY LENGTH TO FLAW MAP?
	 JRST BATF10		;NO-NOTHING TO DO
	MOVN 1,%LEN
	HRLZM 1,$FLWAP		;FLAW MAP AOBJN PTR
	SETZM $SECNT		;SAY NO SECTORS SEEN YET
BATFL1:	MOVE 1,%C.H		;ADR OF FLAW MAP TABLES
	MOVE 2,%P.L
	HRRZ 3,$FLWAP		;FLAW MAP TABLES INDEX
	CALL FLWSEC		;CONVERT ENTRY TO SECTOR ON PACK
	 JRST BATFL7		;RAN OUT FOR THIS FLAW MAP INDEX
BATFL2:	SKIPE $SECNT		;STARTING OFF NEW SET OF SECTORS?
	 JRST BATFL4		;NO
	MOVEM 1,$SEC1		;YES-SET 1ST SECTOR
	MOVEM 1,$SEC2		;SET LAST SECTOR
	AOS $SECNT		;SAY A SECTOR SEEN
BATFL4:	CAMN 1,$SEC2		;SAME AS LAST SECTOR SEEN?
	 JRST BATFL1		;YES, BYTE IN SAME SECTOR, IGNORE
	MOVEM 1,$SEC3		;NO-SAVE CURRENT SECTOR
	SUB 1,$SEC2		;GET DIFF OF LAST AND CURRENT SECTOR
	CAIE 1,1		;CONTIGUOUS SECTORS?
	 JRST BATFL5		;NO-MAKE BAT ENTRY, START NEW SET
	AOS $SECNT		;YES-JUST BUMP SECTOR COUNT
	AOS $SEC2		;LAST SEC IS THEREFORE LAST + 1
	JRST BATFL1		;LOOP

;HERE TO MAKE BAT ENTRY BECAUSE CURRENT SECTOR IS NOT CONTIGUOUS.
;JUMP BACK INTO LOOP FOR CURRENT SECTOR AFTER ENTRY MADE

BATFL5:	MOVE 1,$SEC1		;START SECTOR
	MOVE 2,$SECNT		;# SECTORS
	MOVE 3,%BAT		;ADR OF BAT BLOCK ITSELF
	MOVSI 4,(1B0)		;SAY INITIAL ENRTY
	CALL BATENT		;DO IT (NOSKED)
	 BUG (HLT,<BATFLW: FAILED TO MAKE BAT BLOCK ENTRY>)
	  JFCL			;NO NEW ENTRIES MADE
	SETZM $SECNT		;SAY STARTING NEW SET
	MOVE 1,$SEC3		;RESTORE CURRENT SECTOR
	JRST BATFL2		;JUST LIKE FLWSEC WON 1ST TIME

;HERE BECAUSE FLWSEC CLAIMS THE POSITION CNT IN FLAW MAP ENTRY WENT
;TO ZERO AND NO MORE POSSITIONS TO PROCESS IN THEIS ENTRY

BATFL7:	MOVE 1,$FLWAP		;GET FLAW MAP AOBJN
	AOBJN 1,BATFL8		;STEP TO NEXT FLAW MAP ENTRY
	 JRST BATFL9		;ALL DONE
BATFL8:	MOVEM 1,$FLWAP		;UPDATE FLAW MAP AOBJN PTR
	JRST BATFL1		;CONTINUE USING CURRENT $SECNT

;HERE WHEN FLAW MAP EXHAUSTED.  MAKE LAST BAT ENTRY

BATFL9:	SKIPN 2,$SECNT		;I DON'T THINK IT CAN BE 0 (SAFE)
	 JRST BATF10
	MOVE 1,$SEC1		;1ST SECTOR
	MOVE 3,%BAT		;ADR OF BAT BLOCK ITSELF
	MOVSI 4,(1B0)		;SAY INITIAL ENTRY
	CALL BATENT		;MAKE LAST ENTRY (NOSKED)
	 BUG (HLT,<BATFLW: FAILED TO MAKE BAT BLOCK ENTRY>)
	  JFCL			;NO NEW ENTRIES MADE
BATF10:	OKSKED
	RET

	PURGE %C.H,%P.L,%LEN,%BAT
	PURGE $SEC1,$SEC2,$SEC3,$SECNT,$FLWAP



;PROCESS FLAW MAP ENTRY AND RETURN PACK RELATIVE SECTOR ADR
;SKIPS IF OK, NO SKIP IF NO MORE BYTE POSITIONS TO PROCESS FOR ENTRY

;ACCEPTS 1/ CYL,,HEAD TABLE ADR
;	 2/ POSITION,,LENGTH TABLE ADR
;	 3/ TABLE INDEX TO USE
;RETURNS 1/ SECTOR IF SKIPS

FLWSEC:	ACMAC <%C.H,%P.L,%FLWNX,%AC4>
	MOVE 1,%P.L
	ADD 1,%FLWNX
	HRRZ 2,(1)		;GET CNT OF ENTRY
	JUMPE 2,FLWSE1		;JUMP IF NO MORE IN THIS ENTRY
	HLRZ 2,(1)		;GET BYTE POSITION
	IDIVI 2,^D2520		;MAGICALLY CONVERT TO SECTOR
	SOS 3,(1)		;MAKE POS+1,,CNT-1
	ADD 3,[1,,0]
	MOVEM 3,(1)
	MOVE 1,%C.H
	ADD 1,%FLWNX
	HLRZ 3,(1)		;GET CYLINDER
	IMULI 3,NSURFS*NSECS	;MAKE SECTOR
	ADD 2,3			;ACCUMULATE SECTORS IN 2
	HRRZ 3,(1)		;GET HEAD
	IMULI 3,NSECS		;MAKE SECTOR
	ADD 2,3
	MOVEM 2,%C.H		;RETURN PACK RELATIVE SECTOR IN 1
	AOS (P)			;SKIP TO SAY DID IT
FLWSE1:	RET

	PURGE %C.H,%P.L,%FLWNX,%AC4



;MAKE ENTRIES INTO BAT BLOCK, MUST BE CALLED NOSKED
;IF ALREADY THERE => NOP
;ADD TO EXISTING ENTRIES VIA SECTOR COUNT FIELD IF POSSIBLE
;IF CAN'T ADD TO EXISTANT => MAKE NEW ENTRY IF POSSIBLE

;ACCEPTS 1/ START SECTOR
;	 2/ # SECTORS
;	 3/ ADR OF BAT BLOCK
;	 4/ 1B0 FOR INITIAL ENTRIES
;	    1B1 FOR ADDED ENTRIES

;RETURNS +1 FAILED TO COMPLETE, SOME SECTORS MAY HAVE MADE IT
;	 +2 SUCCESS, ALL SECTORS WERE ALREADY ENTERED
;	 +3 SUCCESS, ALL SECTORS ENTERED, AT LEAST 1 NEW SECTOR ENTERED

BATENT:	ACMAC <%SSEC,%NSEC,%BAT,%FLAGS>
	VARMAC <$SECAP,$CSEC,$BATAP,$RCNT,$NEWNT>
	SETZM $NEWNT		;NO NEW ENTRIES YET
	TLNN 4,(1B0!1B1)	;SMART USER?
	 JRST BATE10		;NO-MOST AREN'T
	MOVNS 2
	HRLZM 2,$SECAP		;AOBJN PTR FOR SECTORS TO DO
BATEN0:	HRRZ 1,$SECAP
	ADD 1,%SSEC		;1/ SECTOR TO DO
	MOVEM 1,$CSEC		;CURRENT SECTOR
	MOVE 1,%BAT		;ADR OF BAT BLOCK
	HLRZ 4,BATCNT(1)	;GET INITIAL COUNT
	HRRZ 3,BATCNT(1)	;AND ADDED COUNT
	ADDI 4,(3)		;4/ TOTAL USED COUNT
	JUMPE 4,BATEN5		;EMPTY BAT BLOCK, NO MATCHING POSSIBLE
	MOVNS 4
	HRLS 4
	HRRI 4,BATDAT(1)	;4/ - # USED,,ADR OF 0TH IN BAT BLK
BATEN1:	MOVEM 4,$BATAP		;SAVE AOBJN PTR
	LDB 2,[BATSCT (4)]	;GET COUNT
	MOVEM 2,$RCNT		;RANGE COUNT SAVED
	LDB 1,[BATADR (4)]	;GET JUST HDWR ADR
	CALL CDSKVA		;MAKE LINEAR ADR IN 1
	MOVE 2,$RCNT		;GET RANGE COUNT AGAIN
	ADD 2,1			;ADD IN STARTING LINEAR SECTOR
	SUBI 2,1		;MAKE ENDING SECTOR
	CAMLE 1,$CSEC		;CSEC BELOW RANGE?
	 JRST BATEN2		;YES
	CAMGE 2,$CSEC		;CSEC ABOVE RANGE?
	 JRST BATEN3		;YES
	JRST BATEN7		;NO-WITHIN RANGE, NOTHING TO DO FOR CSEC

;HERE CSEC IS BELOW RANGE, SEE IF IT'S BELOW BY ONE

BATEN2:	SUB 1,$CSEC		;GET DIFFERENCE
	CAIE 1,1		;CAN ADD TO THIS ENTRY VIA CNT FIELD?
	 JRST BATEN4		;NO
	MOVE 1,$CSEC		;YES-CSEC BECOMES LOW END OF RANGE
	CALL CVDSK		;MAKE HARDWAR SECTOR ADR
	AOS 2,$RCNT		;GET OLD RANGE COUNT BUMPED
	DPB 2,[BATSCT 1]	;ENTER CNT INTO HDWR SECTOR
	HRRZ 2,$BATAP		;GET ADR OF ENTRY IN QUESTION
	MOVEM 1,(2)		;REPLACE IT WITH BIGGER RANGED ENTRY
	AOS $NEWNT		;COUNT NEW ENTRY
	JRST BATEN7		;DONE WITH CSEC

;HERE CSEC IS ABOVE RANGE, SEE IF IT'S ABOVE BY ONE

BATEN3:	MOVE 1,$CSEC
	SUB 1,2			;GET DIFFERENCE
	CAIE 1,1		;CAN ADD TO THIS ENTRY VIA CNT FIELD?
	 JRST BATEN4		;NO
	AOS 1,$RCNT		;YES-BUMP COUNT
	HRRZ 2,$BATAP		;GET ADR OF ENTRY IN QUESTION
	DPB 1,[BATSCT (2)]	;ENTER NEW COUNT
	AOS $NEWNT		;COUNT NEW ENTRY
	JRST BATEN7		;DONE WITH CSEC

;HERE WHEN CSEC TOO FAR OUT OF RANGE TO BE ADDED TO EXISTING ENTRY

BATEN4:	MOVE 4,$BATAP		;GET ABOJN THRU BAT BLK
	AOBJN 4,BATEN1		;STEP TO NEXT BAT ENTRY TO EXAMINE
	 JRST BATEN5		;NO MORE-MUST MAKE NEW ENTRY FOR CSEC

;HERE WHEN ALL BAT BLK SCANNED AND CSEC FITS NOWHERE
;MUST MAKE NEW ENTRY FOR IT

BATEN5:	MOVE 1,$CSEC		;GET LINEAR CURRENT SECTOR
	CALL CVDSK		;MAKE HARWARE ADR
	MOVEI 2,1		;IT'S LENGTH IS 1
	DPB 2,[BATSCT 1]	;COMPLETE ENTRY
	MOVEM 1,$CSEC		;ITS HARDWARE NOW
	MOVE 1,%BAT		;ADR OF BAT BLK AGAIN
	SKIPG BATFRE(1)		;ANY ROOM IN BAT BLK?
	 JRST BATE10		;NO-LOSER
	SOS BATFRE(1)		;DEC # FREE
	MOVE 3,%FLAGS		;GET FLAGS
	TLNE 3,(1B0)		;INITIAL ENTRY?
	 MOVSI 2,1		;YES-BUMP LH
	TLNE 3,(1B1)		;ADDED ENTRY?
	 MOVEI 2,1		;YES-BUMP RH
	ADDM 2,BATCNT(1)	;BUMP COUNT FIELD
	HLRZ 2,BATCNT(1)	;GET INITIAL COUNT
	HRRZ 3,BATCNT(1)	;AND ADDED COUNT
	ADDI 2,(3)		;2/ OFFSET INTO DATA AREA OF BAT BLK
	ADDI 2,BATDAT-1(1)	;2/ ADR OF FREE ENTRY (-1 CAUSE WE BUMPED)
	MOVE 1,$CSEC		;GET SAVED HARDWARE ENTRY
	MOVEM 1,(2)		;ENTER IT
	AOS $NEWNT		;COUNT NEW ENTRY
	JRST BATEN7		;DO REST OF SECTORS REQUESTED


;HERE WHEN DONE PROCESSING CSEC SUCCESSFULLY AND WISH TO CONTINUE
;LOOPING FOR REQUESTED SECTOR COUNT

BATEN7:	MOVE 1,$SECAP		;AOBJN THRU REQUESTED SECTORS
	AOBJN 1,BATEN8		;LOOP FOR EM
	 JRST BATEN9		;DONE
BATEN8:	MOVEM 1,$SECAP		;UPDATE AOBJN SAVER
	JRST BATEN0		;LOOP

BATEN9:	AOS (P)			;SUCCESS
	SKIPE $NEWNT		;DID WE MAKE AT LEAST ONE NEW ENTRY?
	 AOS (P)		;YES - RET +3
BATE10:	RET			;NOSKIP FAILURE

	PURGE %SSEC,%NSEC,%BAT,%FLAGS
	PURGE $SECAP,$CSEC,$BATAP,$RCNT,$NEWNT



;CALL DOBAT FOR ALL PACKS FOR DISK ADRS

DOBDSA:	ACMAC <%AC1,%AC2,%AC3,%AC4>
	HRROI 1,[ASCIZ/
Assigning DISK addresses found in BAT blocks./]
	PSOUT
	MOVSI 3,-NPACKS		;AOBJN FOR PACKS
DOBDS1:	HRRZ 1,3		;LOGICAL PACK # IN 1
	MOVSI 2,(1B0)		;DISK ADRS ONLY
	CALL DOBAT
	AOBJN 3,DOBDS1
	RET

	PURGE %AC1,%AC2,%AC3,%AC4

;CALL DOBAT FOR ALL PACKS FOR DRUM ADRS

DOBDRA:	ACMAC <%AC1,%AC2,%AC3,%AC4>
	MOVEI 1,DRMBND		;CHECK DRUM NOT TOUCHED YET
	IMULI 1,DRMSEC
	CAME 1,DRMFRE
	 BUG (HLT,<DOBDRA: DRUM ADR ASSIGNED BEFORE BAT BLOCKS USED>)
	HRROI 1,[ASCIZ/
Assigning DRUM addresses found in BAT blocks./]
	PSOUT
	MOVSI 3,-NPACKS		;AOBJN FOR PACKS
DOBDR1:	HRRZ 1,3		;LOGICAL PACK # IN 1
	MOVSI 2,(1B1)		;DRUM ADRS ONLY
	CALL DOBAT
	AOBJN 3,DOBDR1
	RET

	PURGE %AC1,%AC2,%AC3,%AC4

;CALL DOBAT FOR ALL PACKS FOR BOTH DISK AND DRUM ADRS

DOBDDA:	ACMAC <%AC1,%AC2,%AC3,%AC4>
	MOVEI 1,DRMBND		;CHECK DRUM NOT TOUCHED YET
	IMULI 1,DRMSEC
	CAME 1,DRMFRE
	 BUG (HLT,<DOBDDA: DRUM ADR ASSIGNED BEFORE BAT BLOCKS USED>)
	HRROI 1,[ASCIZ/
Assigning DISK and DRUM addresses found in BAT blocks./]
	PSOUT
	MOVSI 3,-NPACKS		;AOBJN FOR PACKS
DOBDD1:	HRRZ 1,3		;LOGICAL PACK # IN 1
	MOVSI 2,(1B0!1B1)	;BOTH DISK AND DRUM ADRS
	CALL DOBAT
	AOBJN 3,DOBDD1
	RET

	PURGE %AC1,%AC2,%AC3,%AC4



;ASSIGNS ALL DISK AND DRUM ADRS FOUND IN BAT BLOCK FOR PACK
;BASED ON PROCESSING FLAGS

;ACCEPTS 1/ LOGICAL UNIT #
;ACCEPTS 2/ 1B0 DO DISK ASSIGNS
;	    1B1 DO DRUM ASSIGNS

DOBAT:	ACMAC <%UNIT,%FLAGS,%AC3,%AC4>
	VARMAC <$PAGE,$JFN,$BBN>
	MOVE 1,%UNIT
	MOVEI 2,1			;PRIMARY
	MOVEM 2,$BBN
	CALL MAPBAT			;MAP BAT BLOCK TO A PAGE
	 BUG (HLT,<DOBAT: FAILED TO MAP BAT BLOCK>)
	MOVEM 3,$PAGE			;SAVE MAPPED ADR
	MOVEM 4,$JFN			;AND JFN ASSIGNED
	MOVE 1,$PAGE
	CALL CHKBAT			;LOOK OK?
	 CAIA
	JRST DOBAT1			;OK, USE IT
	BUG (CHK,<DOBAT: BAD PRIMARY BAT, $P TO USE SECONDARY BAT>)
	MOVE 1,%UNIT
	MOVE 2,$BBN			;UNMAP PRIMARY
	MOVE 3,$PAGE			;1B0 OFF, DON'T WRITE IT TO DISK
	MOVE 4,$JFN			;SYS HACK SHOULD INVESTIGATE
	CALL RELBAT
	 BUG (HLT,<DOBAT: FAILED TO BREAK BAT BLOCK MAPPING>)
	MOVE 1,%UNIT
	MOVEI 2,2			;SECONDARY
	MOVEM 2,$BBN			;REMEMBER WHICH ONE
	CALL MAPBAT
	 BUG (HLT,<DOBAT: FAILED TO MAP BAT BLOCK>)
	MOVEM 3,$PAGE
	MOVEM 4,$JFN
	MOVE 1,$PAGE
	CALL CHKBAT
	 CAIA
	JRST DOBAT1
	BUG (HLT,<DOBAT: BAD SECONDARY BAT, YOU LOSE>)
	JRST DOBAT3			;INCASE WANT TO RESTART AND IGNORE BAT

;HERE WITH GOOD BAT BLOCK MAPPED TO $PAGE VIA $JFN

DOBAT1: MOVE 3,$PAGE			;WHERE ITS MAPPED TO
	HLRZ 4,BATCNT(3)		;GET INITIAL COUNT
	HRRZ 2,BATCNT(3)		;AND ADDED COUNT
	ADD 4,2				;4/ TOTAL IN USE
	JUMPE 4,DOBAT3			;JUMP IF NONE TO DO
	CAMLE 4,BATMAX			;LOTS OF SPOTS?
	 JRST [ MOVE 1,%FLAGS		;REPORT ONLY IF DOING DRUM
		TLNN 1,(1B1)		;SO ONLY SEE MSG ONCE
		 JRST .+1
		HRROI 1,[ASCIZ/
[Drive /]
		PSOUT
		MOVEI 1,101
		MOVE 2,%UNIT
		MOVEI 3,12
		NOUT
		 JFCL
		HRROI 1,[ASCIZ/ has more bad spots than allowed by CDC.]
/]
		PSOUT
		JRST .+1]
	MOVNS 4				;NEG FOR AOBJN
	HRLZS 4
	MOVE 3,$PAGE			;INCASE LITERAL CLOBBERED IT
	HRRI 4,BATDAT(3)		;PT TO DATA AREA OF BLOCK
	MOVE 1,%UNIT
	MOVE 3,%FLAGS			;PASS FLAGS
	TLO 3,(1B2)			;FORCED DISK ASSIGNS
DOBAT2:	MOVE 2,(4)			;GET AN ENTRY
	CALL ASGBAT			;DO IT
	 BUG (HLT,<DOBAT: FAILED TO FORCE ASSIGNMENT VIA BAT BLKS>)
	AOBJN 4,DOBAT2			;LOOP FOR ALL ENTRIES
DOBAT3:	MOVE 1,%UNIT
	MOVE 2,$BBN
	MOVE 3,$PAGE			;1B0 OFF, DON'T WRITE TO DISK
	MOVE 4,$JFN
	CALL RELBAT
	 BUG (HLT,<DOBAT: FAILED TO BREAK BAT BLOCK MAPPING>)
	RET

	PURGE %UNIT,%FLAGS,%AC3,%AC4
	PURGE $PAGE,$JFN,$BBN



;ASSIGN DISK AND DRUM PAGES AS APPROPRIATE GIVEN BAT BLOCK ENTRY
;ACCEPTS 1/ LOGICAL UNIT #
;	 2/ BAT BLOCK ENTRY
;	 3/ 1B0 TO DO DISK ASSIGNS
;	    1B1 TO DO DRUM ASSIGNS
;	    1B2 TO FORCE DISK ASSIGNMENTS (WIN IF ASSIGNED ALREADY)

;RETURNS +1 FAILED, 1/ HDWR ADR THAT COULD NOT BE ASSIGNED (OR ALREADY IS)
;		    2/ <1B0 => DISK ADR, 1B1 => DRM ADR>! SOFTWARE ADR
;	 +2 SUCCESS

ASGBAT:	ACMAC <%UNIT,%ENT,%FLAGS,%AC4>
	VARMAC <$LNADR,$CNT,$TYADR>
	TLNN 3,(1B0!1B1)		;USER KNOWS WHAT HES DOING?
	 BUG (HLT,<ASGBAT: NO PROCESSING FLAGS GIVEN>)
	DPB 1,[BATSCT 2]		;ENTER UNIT INTO DISK ADR
	MOVE 1,2
	CALL CDSKVA			;CONVERT TO LINEAR ADR
	MOVEM 1,$LNADR			;SAVE 1ST DISK ADR OF CONCERN
	LDB 2,[BATSCT %ENT]		;GET CNT FROM BAT ENTRY
	MOVEM 2,$CNT			;SAVE SECTOR (PAGE) COUNT
ASGBA0:	IDIVI 1,NSECTK
	IDIVI 1,NTKUN			;SEE IF SWAPPING ADR
	CAIL 2,SWPTK
	CAIL 2,SWPTKH
	 JRST ASGBA1			;NO-REAL LINEAR DISK ADR
	MOVE 2,%FLAGS
	TLNN 2,(1B1)			;DOING DRUM ADRS?
	 JRST ASGBA2			;NO-ONTO NEXT ONE, IGNORE
	MOVE 1,$LNADR			;GET DISK LINEAR ADR
	CALL CVADSW			;CONVERT TO DRUM ADR
	MOVEM 1,$TYADR			;SAVE DRUM ADR FOR ERROR RET
	CALL ASDRMS			;ASSIGN IT
	 JRST ASGBA3			;BAD ADDRESS???
	  JRST ASGBA3			;NOT AVAILABLE
	JRST ASGBA2			;SUCCESS, ON TO NEXT ONE

ASGBA1:	MOVE 2,%FLAGS
	TLNN 2,(1B0)			;DOING DISK ADRS?
	 JRST ASGBA2			;NO-ONTO NEXT ONE, IGNORE
	MOVE 1,$LNADR			;GET LINEAR DISK ADR
	MOVEM 1,$TYADR			;SAVE DISK ADR FOR ERROR RET
	TLNE 2,(1B2)			;WANT FORCE FLAG?
	 TLO 1,(1B0)			;YES-SET IT FOR DSKASA
	CALL DSKASA			;ASSIGN IT
	 JRST ASGBA4			;FAILED
ASGBA2:	SOSG $CNT			;ANYMORE TO DO?
	 JRST ASGBA6			;NO-SUCCESS
	MOVEI 1,NSECPG			;BUMP LINEAR ADR
	ADDB 1,$LNADR			;1/ NEW LINEAR ADR TO DO
	JRST ASGBA0			;GO ON TO ASSIGN NEXT ADR

;HERE ON DRUM FAILURE, FAILING LINEAR ADR IN $LNADR, DRUM ADR IN $TYADR

ASGBA3:	MOVSI 1,(1B1)			;DRUM ADR FAILED
	JRST ASGBA5

;HERE ON DISK FAILURE, FAILING LINEAR ADR IN $LNADR, DISK ADR IN $TYADR

ASGBA4:	MOVSI 1,(1B0)			;DISK ADR FAILED
ASGBA5:	IOR 1,$TYADR			;OR IN ADR OF PROPER TYPE
	MOVEM 1,%ENT			;SAY TYPE OF FAILURE IN AC 2 WITH ADR
	MOVE 1,$LNADR			;GET BACK DISK LINEAR ADR
	CALL CVDSK			;MAKE IT HARDWARE ADR
	MOVEM 1,%UNIT			;RETURN IT IN AC 1
	RET				;NOSKIP FAILURE

;HERE ON SUCCESS

ASGBA6:	AOS (P)				;SKIP SUCCESS
	RET



;POTENTIAL BACKEND TO USER JSYS FOR MAKING BAT BLOCK ENTRIES
;TRIES TO ASSIGN SPOT ON DISK OR DRUM.
;BOTH BAT BLOCKS MUST BE IN GOOD SHAPE TO DO THIS FOR NOW.
;IF NOT, JUST LOSE

;ACCEPTS 1/ HARWARE DISK ADR (OK IF IN DRUM AREA)
;	    1B0 TO MAKE ENTRY EVEN FOR DSK ADR ALREADY ASSIGNED

;RETURNS +1 FOR FAILURE
;	 +2 FOR SUCCESS, WAS ALREADY IN BAT BLOCKS
;	 +3 FOR SUCCESS, NEW ENTRY MADE

NTRBAT:	ACMAC <%F.ADR,%AC2,%AC3,%AC4>
	VARMAC <$UNIT,$PAGE1,$JFN1,$PAGE2,$JFN2,$ASGWN,$NEWNT>
	SETZM $PAGE1				;NON-0 IF IN USE
	SETZM $PAGE2
	SETZM $ASGWN				;NON 0 IF ASGBAT WON
	SETZM $NEWNT				;NO NEW ENTRIES MADE YET
	LDB 1,[BATSCT %F.ADR]			;GET UNIT #
	MOVEM 1,$UNIT				;REMEMBER IT
	MOVE 2,%F.ADR				;SETUP FOR
	TLZ 2,(1B0)				;CLEAR POSSIBLE FLAG
	MOVEI 3,1				;ONLY 1 SECTOR! CRITICAL!!
	DPB 3,[BATSCT 2]			;ENTER SECTOR COUNT IN ADR
	MOVSI 3,(1B0!1B1!0B2)			;ALLOW BOTH DISK AND DRUM
	CALL ASGBAT				;TRY TO ASSIGN IT, NO FORCING
	 JRST [	MOVE 4,%F.ADR			;GET CALLER'S FLAG
		TLNN 4,(1B0)			;OK IF IS ALREADY ASSIGNED?
		 JRST NTRBA2			;NO-ITS ASSIGNED ALREADY, BAD
		JRST NTRBA0]			;YES-CONTINUE THEN
	SETOM $ASGWN				;REMEMBER WE ASSIGNED IT
NTRBA0:	MOVE 1,$UNIT				;MAP BAT NOW, MAYBE ASSIGNED
	MOVEI 2,1				;PRIMARY
	CALL MAPBAT
	 JRST NTRBA2
	MOVEM 3,$PAGE1
	MOVEM 4,$JFN1
	MOVE 1,3
	CALL CHKBAT				;LOOK OK?
	 JRST NTRBA2				;UNMAP PRIMARY AND NO SKIP
	MOVE 1,$UNIT				;NOW MAP SECONDARY
	MOVEI 2,2
	CALL MAPBAT
	 JRST NTRBA2				;UNMAP PRIMARY AND NO SKIP
	MOVEM 3,$PAGE2
	MOVEM 4,$JFN2
	MOVE 1,3
	CALL CHKBAT				;LOOK OK?
	 JRST NTRBA2				;UNMAP BOTH AND NO SKIP



;HERE WHEN BOTH BAT BLOCKS MAPPED AND LOOK OK, MAKE ENTRY IN EACH

	LDB 1,[BATADR %F.ADR]			;GET JUST HDWR ADR
	CALL CDSKVA				;GET PACK RELATIVE LINEAR ADR
	MOVEI 2,1				;ONLY DOING 1 SECTOR
	MOVE 3,$PAGE1				;ENTER IT INTO PRIMARY
	MOVSI 4,(1B1)				;SAY ADDED ENTRY
	NOSKED					;NO TURNING BACK
	CALL BATENT
	 JRST NTRBA1				;FAILED TO MAKE ENTRY IN BAT
	  CAIA					;NO NEW ENTRIES MADE
	AOS $NEWNT				;REMEMBER MADE NEW ENTRY IN BAT
	HRL 1,$PAGE1				;NOW COPY PRIMARY TO SECONDARY
	HRR 1,$PAGE2
	HRRZ 3,$PAGE2
	BLT 1,BATLEN-1(3)
	MOVE 1,[SIXBIT/2/]			;AND FIX IT UP
	MOVEM 1,BATID(3)
	MOVE 2,$UNIT
	LDB 1,[BATADR BB2TBL(2)]		;GET JUST CYL,HD,SEC OF SELF
	MOVEM 1,BATSLF(3)
	OKSKED					;DONE WITH BATS
	MOVSI 1,(1B0)				;FLAG BOTH BATS
	IORM 1,$PAGE1				;FOR WRITING TO DISK
	IORM 1,$PAGE2				;SINCE WE CHANGED THEM
	AOS (P)					;SUCCESS SKIP RET
	SKIPE $NEWNT				;DID WE MAKE NEW ENTRY?
	 AOS (P)				;YES, RET +3
	JRST NTRBA4				;NOW JUST UNMAP THEM

;HERE WHEN SOMETHING WENT WRONG, DEASSIGN ADR WE ASSIGNED, UNMAP BLOCKS

NTRBA1:	OKSKED
NTRBA2:	SKIPN $ASGWN				;DID WE ASSIGN IT?
	 JRST NTRBA4				;NO-DON'T DEASSIGN IT THEN
	MOVE 1,%F.ADR				;HERE TO UNDO WHAT ASGBAT DID
	TLZ 1,(1B0)				;CLEAR POSSIBLE FLAG
	CALL CDSKVA				;CONVERT TO SOFT LINEAR
	MOVE 2,1
	IDIVI 2,NSECTK
	IDIVI 2,NTKUN
	CAIL 3,SWPTK				;DRUM?
	CAIL 3,SWPTKH
	 JRST NTRBA3				;NO, DISK
	CALL CVADSW				;CONVERT TO DRUM ADR
	PUSH P,5				;WILL GET CLOBBERED
	PUSH P,6
	CALL DEDRM				;DEASSIGN
	 JFCL					;BAD ADDRESS??
	  BUG (HLT,<NTRBAT: FAILED TO DEASSIGN DRUM ADR>)
	POP P,6					;RESTORE CLOBBERED ACS
	POP P,5
	JRST NTRBA4				;NOW DO UNMAPPINGS

NTRBA3:	CALL DEDSK				;DEASSIGN DISK ADR
	 BUG (HLT,<NTRBAT: FAILED TO DEASSIGN DISK ADR>)
NTRBA4:	SKIPN 3,$PAGE1				;GOT PRIMARY MAPPED?
	 JRST NTRBA5				;NO-TRY FOR SECONDARY
	MOVE 4,$JFN1
	MOVE 1,%UNIT
	MOVEI 2,1
	CALL RELBAT				;POSSIBLE WRITE OUT FLAG ON
	 BUG (HLT,<NTRBAT: FAILED TO UNMAP PRIMARY BAT BLOCK>)
NTRBA5:	SKIPN 3,$PAGE2				;GOT SECONDARY MAPPED?
	 RET					;NO
	MOVE 1,%UNIT
	MOVEI 2,2
	MOVE 4,$JFN2
	CALL RELBAT				;POSSIBLE WRITE OUT FLAG ON
	 BUG (HLT,<NTRBAT: FAILED TO UNMAP SECONDARY BAT BLOCK>)
	RET


	PURGE %F.ADR,%AC2,%AC3,%AC4
	PURGE $UNIT,$PAGE1,$JFN1,$PAGE2,$JFN2,$ASGWN,$NEWNT




;UTILITY ROUTINES FOR ABOVE HOMEBLOCK AND BATBLOCK ROUTINES.
;SOME OF THESE ROUTINES EXAMINE HBXSTF FOR EXISTANCE OF HOMBAT FILE
;TO DETERMINE ACTIONS TAKEN WITHIN ROUTINE.

;PROCESSING BLOCK TYPES
;THESE NUMBERS ALSO INDICATE WHICH PAGE OF THE HOMBAT FILE THE BLKS ARE AT

TYPHOM==0				;HOME BLOCK IS PAGE 0
TYPBAT==1				;BAT BLOCK IS PAGE 1


;ASSIGN AND MAP XB FOR BLOCK TYPE INDICATED IN 3
;ACCEPTS 0/ BLOCK TYPE
;	 1/ LOGICAL UNIT #
;	 2/ BLOCK #

;RETURNS 3/ PAGE ADR MAPPED TO
;	 4/ OFN


MAPXB:	ACMAC <%UNIT,%BN,%PAGE,%OFN>
	CAIE 0,TYPHOM			;CHECK TYPE HERE
	CAIN 0,TYPBAT
	 CAIA
	BUG (HLT,<MAPXB: ILLEGAL BLOCK TYPE REQUESTED>)
	MOVEI 1,XB1TBL			;ASSUME PRIMARY
	CAIE 2,1
	 MOVEI 1,XB2TBL			;NO-SECONDARY
	ADD 1,%UNIT			;ADD IN PACK OFFSET
	MOVE 1,(1)			;GET XB ADR
	CALL CDSKVA			;CONVERT TO SOFT LINEAR ADR
	PUSH P,1			;SAVE SOFT ADR
	SKIPE HBXSTF			;DOES FILE ALREADY EXIST?
	 JRST MAPXB1			;YES-XB MUST ALREADY BE ASSIGNED
	CALL DSKASA			;ASSIGN IT
	 BUG (HLT,<MAPXB: FAILED TO ASSIGN INDEX BLOCK>)
	JRST MAPXB2

MAPXB1:	CALL DSKASA			;MUST FAIL
	 JRST MAPXB2
	BUG (HLT,<MAPXB: EXISTANT XB FOUND TO BE UNASSIGNED>)

MAPXB2:	POP P,1				;RESTORE XB SOFT ADR
	TLO 1,(1B3!1B13!DSKABT)		;NEW FILE, CLASS BIT, DSKABT
	CALL ASOFN			;GET OFN FOR XB
	 BUG (HLT,<MAPXB: FAILED TO ASOFN XB>)
	MOVEM 1,%OFN			;SAVE IT
	CALL ASGPAG			;GET A PAGE IN JOB AREA TO MAP TO
	 BUG (HLT,<MAPXB: FAILED TO ASGPAG FOR XB>)
	MOVEM 1,%PAGE			;SAVE THE PAGE
	MOVE 2,%PAGE
	HRLI 2,140000			;2/ ACCESS,,PAGE ADR
	MOVE 1,%OFN
	CALL SETMPG			;MAP IT
	RET				;RESTORES TO RETURNED VALUES

	PURGE %UNIT,%BN,%PAGE,%OFN


;FILL OUT XB AND ASSIGN BLOCK SO NOT POINTING TO UNASSIGNED PAGE
;ACCEPTS 0/ BLOCK TYPE
;	 1/ LOGICAL PACK #
;	 2/ BLOCK #
;	 3/ PAGE ITS MAPPED TO

SETXB:	ACMAC <%UNIT,%BN,%PAGE,%OFN>
	VARMAC <$TYPE>
	MOVEM 0,$TYPE
	CAIE 0,TYPHOM
	 JRST SETXB1
	MOVEI 1,HM1TBL			;ASSUME HOME BLOCK 1
	CAIE 2,1			;IS IT?
	 MOVEI 1,HM2TBL			;NO-HOME BLOCK 2
	JRST SETXB2			;INTO COMMON CODE

SETXB1:	CAIE 0,TYPBAT
	 BUG (HLT,<SETXB: ILLEGAL BLOCK TYPE REQUESTED>)
	MOVEI 1,BB1TBL			;ASSUME BAT BLOCK 1
	CAIE 2,1			;IS IT?
	 MOVEI 1,BB2TBL			;NO-BAT BLOCK 2
SETXB2:	ADD 1,%UNIT			;ADD IN PACK OFFSET
	MOVE 1,(1)			;GET BLOCK ADR
	CALL CDSKVA			;CONVERT TO SOFT LINEAR ADR
	CALL DSKASA			;ASSIGN THE BLOCK PAGE FIRST
	 BUG (HLT,<SETXB: FAILED TO ASSIGN BLOCK>)
	MOVE 2,%PAGE
	SKIPE HBXSTF			;DOES THE FILE ALREADY EXITS?
	 JRST SETXB3			;YES-DON'T CLOBBER PREVIOUS ENTRIES
	HRLI 3,(2)
	HRRI 3,1(2)
	SETZM (2)
	BLT 3,777(2)			;CLEAN OUT XB
SETXB3:	TLO 1,(DSKABT)			;TURN ON DSKABT
	TLO 1,RWXB			;GIVE ACCESS
	ADD 2,$TYPE			;PT AT RIGHT PAGE OF HOMBAT FILE
	MOVEM 1,(2)			;ENTER PTR TO BLOCK
	RET

	PURGE %UNIT,%BN,%PAGE,%OFN
	PURGE $TYPE

;UNMAP AND RELEASE XB
;ACCEPTS 0/ BLOCK TYPE
;	 3/ PAGE ITS MAPPED TO
;	 4/ OFN

RELXB:	ACMAC <%AC1,%AC2,%PAGE,%OFN>
	MOVEI 1,0
	MOVE 2,%PAGE
	CALL SETMPG			;UNMAP IT
	MOVE 1,%PAGE
	CALL RELPAG			;RELEASE JOB AREA PAGE ASSIGNMENT
	MOVE 1,%OFN
	CALL RELOFN			;BYE
	RET

	PURGE %AC1,%AC2,%PAGE,%OFN


;CREATES AND RELEASES FILE PTING TO PROPER XB
;ACCEPTS 0/ BLOCK TYPE
;	 1/ LOGICAL UNIT #
;	 2/ # OF BLOCK INVOLVED

MAKFL:	ACMAC <%UNIT,%BN,%AC3,%AC4>
	VARMAC <$TYPE,$JFNAC,$DEVAC,<$STRNG,10>>
	SKIPE HBXSTF			;DOES FILE ALREADY EXIST?
	 RET				;YES, WORK HAS BEEN DONE ALREADY
	MOVEM JFN,$JFNAC		;DON'T CLOBBER THESE GUYS
	MOVEM DEV,$DEVAC
	MOVEM 0,$TYPE			;SAVE BLOCK TYPE
	CAIE 0,TYPHOM			;CHECK TYPE HERE
	CAIN 0,TYPBAT
	 CAIA
	BUG (HLT,<MAKFL: ILLEGAL BLOCK TYPE REQUESTED>)
	MOVE 1,%UNIT
	MOVE 2,%BN
	HRROI 3,$STRNG
	CALL MKSTNG			;1 AND 2 SETUP
	MOVSI 1,200001			;NEW FILE ONLY WINS
	HRROI 2,$STRNG
	GTJFN
	 BUG (HLT,<MAKFL: FAILED TO GTJFN FOR FILE>)
	MOVE JFN,1			;LOOKOUT, JFN IS AN AC!
	LSH JFN,SJFN
	HRROI DEV,DSKDTB
	SETZ 0,				;CLEAR FLAGS FOR GETFDB
	CALL GETFDB
	 BUG (HLT,<MAKFL: FAILED TO GETFDB FOR FILE>)
	MOVE 3,%BN
	MOVEI 2,XB1TBL			;ASSUME WANT HOMBAT 1 XB ADR
	CAIE 3,1			;IS IT?
	 MOVEI 2,XB2TBL			;NO-USE HOMBAT 2 XB ADR
	ADD 2,%UNIT			;ADD IN UNIT OFFSET
	PUSH P,1			;SAVE RETURN FROM GETFDB
	MOVE 1,(2)			;GET XB ADR
	CALL CDSKVA			;CONVERT TO SOFT LINEAR ADR
	POP P,2				;RESTORE GETFDB RETURN TO WRONG AC
	EXCH 1,2			;1/ GETFDB RET, 2/ LINEAR XB ADR
	TLO 2,(DSKABT)			;TURN ON DSKABT
	MOVEM 2,FDBADR(1)		;INTO FDB OF FILE
	MOVSI 2,FDBNXF
	ANDCAM 2,FDBCTL(1)		;IT EXISTS
	MOVSI 2,FDBPRM!FDBUND!FDB1PK!FDBXDP ;ON 1 PACK, DON'T DUMP FILE TO TAPE
	IORM 2,FDBCTL(1)		;PROTECT IT
	MOVE 2,[102340,,7664]		;THE DAY THE EARTH STOOD STILL
	MOVEM 2,FDBCRE(1)		;DATES
	MOVEM 2,FDBCRV(1)
	MOVEM 2,FDBWRT(1)
	MOVSI 2,(0B5!44B11)
	IORM 2,FDBBYV(1)		;VER RETAIN,BYTE SIZE
	MOVEI 2,2000			;BYTE COUNT FOR 2 PAGES
	MOVEM 2,FDBSIZ(1)
	MOVEI 2,1			;ASSUME SYSTEM IS 1
	HRLM 2,FDBUSE(1)		;UPDATE CREATOR
	CALL USTDIR
	MOVE 1,JFN
	LSH 1,-SJFN
	RLJFN
	 BUG (HLT,<MAKFL: FAILED TO RLJFN FILE>)
	MOVE JFN,$JFNAC			;RESTORE THESE GUYS
	MOVE DEV,$DEVAC
	RET

	PURGE %UNIT,%BN,%AC3,%AC4
	PURGE $TYPE,$JFNAC,$DEVAC,$STRNG


;MAKE FILENAME STRING IN PTR IN 3
;ACCEPTS 1/ UNIT #
;	 2/ BLOCK #
;	 3/ PTR FOR STRING

MKSTNG:	ACMAC <%UNIT,%BN,%PTR,%AC4>
	MOVE 1,%PTR
	HRROI 2,[ASCIZ/<SYSTEM>HOMBAT-/]
	SETZ 3,
	SOUT
	MOVE 2,%BN
	MOVEI 3,1
	MOVEI 4,2
	CALL MKNMBR
	HRROI 2,[ASCIZ/.PACK-/]
	SETZ 3,
	SOUT
	MOVE 2,%UNIT
	MOVEI 3,0			;MIN OF 0
	MOVEI 4,^D99			;MAX OF ^D99
	CALL MKNMBR			;TACK ONTO PTR IN 1
	HRROI 2,[ASCIZ/;1;P404000/]	;VERSION 1 ONLY!
	SETZ 3,
	SOUT
	RET

	PURGE %UNIT,%BN,%PTR,%AC4

;TACK ASCIZ # ONTO PTR
;ACCEPTS 1/ PTR
;	 2/ #
;	 3/ MIN ALLOWED
;	 4/ MAX ALLOWED

;RETURNS 1/ UPDATED PTR, ASCIZ

MKNMBR:	ACMAC <%PTR,%NUM,%MIN,%MAX>
	CAML 2,%MIN			;RANGE CHECK
	CAMLE 2,%MAX
	 BUG (HLT,<MKNMBR: NUMBER OUT OF RANGE>)
	IDIVI 2,^D10
	JUMPE 2,MKNMB1			;NO LEADING ZEROES
	ADDI 2,"0"			;ASCII
	IDPB 2,1
MKNMB1:	ADDI 3,"0"
	IDPB 3,1
	MOVEM 1,%PTR			;UPDATE RETURNED PTR
	SETZ 2,
	IDPB 2,1
	RET

	PURGE %PTR,%NUM,%MIN,%MAX



;MAP BLOCK TO PAGE, READ AND WRITE
;ACCEPTS 0/ BLOCK TYPE
;	 1/ LOGICAL UNIT #
;	 2/ BLOCK #

;RETURNS 3/ PAGE ADR
;	 4/ JFN

;SKIPS IF SUCCESS, NO SKIP POSSIBLY WITH ERROR CODE IN 1

MAPBLK:	ACMAC <%UNIT,%BN,%PAGE,%JFN>
	VARMAC <$TYPE,<$STRNG,10>>
	MOVEM 0,$TYPE			;SAVE BLOCK TYPE
	CAIE 0,TYPHOM			;CHECK TYPE HERE
	CAIN 0,TYPBAT
	 CAIA
	RET				;LOSE-ERROR # NOT VALID (TS)
	CALL ASGPAG			;GET PAGE FOR IT
	 RET				;LOSE-ERROR # NOT VALID (TS)
	MOVEM 1,%PAGE			;REMEMBER PAGE
	MOVE 1,%UNIT
	MOVE 2,%BN
	HRROI 3,$STRNG
	CALL MKSTNG			;MAKE FILENAME STRING
	MOVSI 1,100001			;OLD FILE ONLY
	HRROI 2,$STRNG
	GTJFN
	 RET
	MOVEM 1,%JFN
	MOVE 2,[440000,,300000]		;FOR READ AND WRITE
	OPENF
	 JRST [PUSH P,1			;SAVE ERROR CODE
		MOVE 1,%JFN
		RLJFN
		 JFCL
		POP P,1
		RET]			;OPENF ERROR CODE IN 1
	HRLZ 1,%JFN			;JFN,,
	HRR 1,$TYPE			;   ,,PAGE #
	SFRAME				;PRESERVE FRAME PTRS
	CALL JFNOFN			;GET OFN,,0
	 BUG (HLT,<MAPBLK: JFNOFN FAILED FOR BLOCK>)
	RFRAME				;RESTORE FRAM PTRS
	MOVE 2,%PAGE
	HRLI 2,140000			;2/ ACCESS,,PAGE ADR
	CALL SETMPG
	AOS (P)				;SKIP SUCCESS
	RET

	PURGE %UNIT,%BN,%PAGE,%JFN
	PURGE $TYPE,$STRNG



;UNMAP AND RELEASE BLOCK
;ACCEPTS 0/ BLOCK TYPE
;	 3/ PAGE ADR ITS MAPPED TO
;	 4/ JFN

;SKIPS IF SUCCESS, NO SKIP WITH ERROR CODE IN 1

RELBLK:	ACMAC <%AC1,%AC2,%PAGE,%JFN>
	MOVEI 1,0
	MOVE 2,%PAGE
	CALL SETMPG
	MOVE 1,%JFN
	CLOSF
	 RET
	MOVE 1,%PAGE
	CALL RELPAG
	AOS (P)				;SKIP SUCCESS
	RET

	PURGE %AC1,%AC2,%PAGE,%JFN



;READS BLOCK TO PAGE WHEN FILESYSTEM NOT AVAILABLE
;SKIPS FOR SUCCESS

;ACCEPTS 0/ BLOCK TYPE
;	 1/ LOGICAL UNIT #
;	 2/ BLOCK #

;RETURNS 3/ PAGE ADR MAPPED TO
;	 4/ REAL CORE ADR USED (LOCKED)


MP.BLK:	ACMAC <%UNIT,%BN,%PAGE,%RCORE>
	VARMAC <$TYPE>
	MOVEM 0,$TYPE
	CAIE 0,TYPHOM			;CHECK TYPE HERE
	CAIN 0,TYPBAT
	 CAIA
	RET				;LOSE-ERROR # NOT VALID (TS)
	CALL ASGPAG			;GET A VIRTUAL PAGE FOR READ
	 RET				;YOU LOSE
	MOVEM 1,%PAGE			;SAVE VIRTUAL ADR
	MOVES (1)			;WHAT IS EXISTANCE?
	CALL FPTA			;MAKE OFN,,PAGE
	CALL MLKPG			;LOCK AND MAKE 1/ REAL CORE PAGE
	MOVSI 2,(CORMB)			;WE ARE GONNA MODIFY IT
	IORM 2,CST0(1)
	LSH 1,^D9			;MAKE REAL CORE ADR
	MOVEM 1,%RCORE			;RETURN REAL CORE ADR IN 4
	MOVE 1,$TYPE			;TYPE
	MOVE 2,%BN			;BLOCK #
	CAIE 1,TYPHOM
	 JRST MP.BL1
	MOVEI 1,HM1TBL			;GET HDWR ADR TABLE
	CAIE 2,1
	 MOVEI 1,HM2TBL
	JRST MP.BL2			;INTO COMMON CODE

MP.BL1:	MOVEI 1,BB1TBL
	CAIE 2,1
	 MOVEI 1,BB2TBL
MP.BL2:	ADD 1,%UNIT			;ADD IN UNIT OFFSET
	MOVE 1,(1)			;GET HDWR ADR OF BAT BLOCK WE WANT
	MOVEI 2,1000			;READ 1000 WORDS
	MOVE 3,%RCORE			;TO THIS REAL CORE ADR
	CALL UDSKIO			;RETURN WHEN DONE
	SKIPN 1				;NO SKIP IF ERROR BITS RETURNED
	 AOS (P)			;SKIP SUCCESS
	RET

	PURGE %UNIT,%BN,%PAGE,%RCORE
	PURGE $TYPE


;RELEASE BAT BLOCK WITHOUT AID OF FILESYSTEM
;WRITES IT OUT IF 1B0 OF AC3 IS ON
;SKIPS FOR SUCCESS

;ACCEPTS 0/ BLOCK TYPE
;	 1/ UNIT
;	 2/ BLOCK #
;	 3/ PAGE ITS MAPPED TO, 1B0 ON FOR WRITE IT OUT TO DISK
;	 4/ REAL CORE ADR THAT WAS USED (LOCKED)

RL.BLK:	ACMAC <%UNIT,%BN,%PAGE,%RCORE>
	VARMAC <$TYPE>
	MOVEM 0,$TYPE
	CAIE 0,TYPHOM			;CHECK TYPE HERE
	CAIN 0,TYPBAT
	 CAIA
	RET				;LOSE-ERROR # NOT VALID (TS)
	MOVE 1,$TYPE			;TYPE
	MOVE 2,%BN			;BLOCK #
	CAIE 1,TYPHOM
	 JRST RL.BL1
	MOVEI 1,HM1TBL			;GET HDWR ADR TABLE
	CAIE 2,1
	 MOVEI 1,HM2TBL
	JRST RL.BL2			;INTO COMMON CODE

RL.BL1:	MOVEI 1,BB1TBL			;GET HDWR ADR TABLE
	CAIE 2,1
	 MOVEI 1,BB2TBL
RL.BL2:	ADD 1,%UNIT			;ADD IN UNIT OFFSET
	MOVE 1,(1)			;GET HDWR ADR OF BAT BLOCK WE WANT
	MOVE 2,[1B14!1000B35]		;WRITE 1000 WORDS
	MOVE 3,%RCORE			;REAL CORE ADR
	SKIPL %PAGE			;WANT IT WRITTEN?
	 JRST RL.BL3			;NO
	CALL UDSKIO			;1/ CORE ADR, 2/ DISK ADR
	SKIPE 1				;ERROR IF ERROR BITS RETURNED
	 RET
RL.BL3:	MOVE 1,%PAGE			;GET VIRTUAL ADR
	TLZ 1,(1B0)			;INCASE WRITE FLAG WAS ON
	CALL FPTA			;MAKE OFN.PN
	CALL MULKPG			;UNLOCK IT
	MOVE 1,%PAGE			;GET VIRTUAL ADR AGAIN
	TLZ 1,(1B0)			;INCASE WRITE FLAG WAS ON
	CALL RELPAG			;RELEASE PAGE
	MOVSI 1,(1B0)			;TURN OFF WRITE REQUEST FLAG
	ANDCAM 1,%PAGE			;AND RETURN IT TO USER
	AOS (P)				;WIN
	RET

	PURGE %UNIT,%BN,%PAGE,%RCORE
	PURGE $TYPE



;PARALLEL TABLES FOR GETTING PARAMETERS FOR DIFFERENT TYPES OF FILES

;PROCESSING FILE TYPES, INDEXES INTO FOLLOWING TABLES

TYPMON==0			;DEFAULT MONITOR (ALL PACKS)
TYPCD0==1			;CORE DUMP 1ST 256K
TYPCD1==2			;CORE DUMP 2ND 256K
TYPCD2==3			;CORE DUMP 3RD 256K
TYPCD3==4			;CORE DUMP 4TH 256K
TYPMIC==5			;MICROCODE (ALL PACKS)
TYPMCD==6			;MICRO DIAGNOSTICS (ALL PACKS)
TYPBOT==7			;BOOTSTRAP (ALL PACKS)

NTYPES==^D8			;# TYPES

;FILE NAMES
;0B0 INDICATES EXTENSION IS COMPLETE
;1B0 INDICATES EXTENSION SHOULD BE COMPLETED WITH PACK #

TYPNAM:	400000,,[ASCIZ/<SYSTEM>MONITOR.PACK-/]
	[ASCIZ/<SYSTEM>CORDMP.256K/]
	[ASCIZ/<SYSTEM>CORDMP.512K/]
	[ASCIZ/<SYSTEM>CORDMP.768K/]
	[ASCIZ/<SYSTEM>CORDMP.1024K/]
	400000,,[ASCIZ/<SYSTEM>MICROCODE.PACK-/]
	400000,,[ASCIZ/<SYSTEM>MICRODIAG.PACK-/]
	400000,,[ASCIZ/<SYSTEM>BOOTSTRAP.PACK-/]

; - # PACKS,,STARTING PACK TO PUT FILES ON

TYPUNT:	-NPACKS,,PRMUNT		;MONITOR (ALL FILES)
	-1,,PRMUNT		;CORE DUMP 256
	-1,,PRMUNT		;CORE DUMP 512
	-1,,PRMUNT		;CORE DUMP 768
	-1,,PRMUNT		;CORE DUMP 1024
	-NPACKS,,PRMUNT		;MICROCODE (ALL PACKS)
	-NPACKS,,PRMUNT		;MICRODIAG (ALL PACKS)
	-NPACKS,,PRMUNT		;BOOTSTRAP (ALL PACKS)


;HARWARE ADR OF XB'S
;NATURE OF HARWARE ADR IS SUCH THAT SIGN BIT IS NEVER ON AND THEREFORE
;0B0 INDICATES HARDWARE ADR COMPLETE
;1B0 INDICATES TABLE OF COMPLETE HARDWARE ADRS INDEXED BY UNIT #

TYPXBA:	400000,,MONTBL		;TABLE OF HARDWARE ADRS INDEXED BY PACK #
	CD0ADR			;HARDWARE ADR (PRIMARY PACK ONLY)
	CD1ADR			;HARDWARE ADR (PRIMARY PACK ONLY)
	CD2ADR			;HARDWARE ADR (PRIMARY PACK ONLY)
	CD3ADR			;HARDWARE ADR (PRIMARY PACK ONLY)
	400000,,MICTBL		;TABLE OF HARDWARE ADRS INDEXED BY PACK #
	400000,,MCDTBL		;TABLE OF HARDWARE ADRS INDEXED BY PACK #
	400000,,BOTTBL		;TABLE OF HARDWARE ADRS INDEXED BY PACK #

;# OF DATA PAGES TO ASSIGN INITIALLY
;0 YIELDS ZERO LENGTH FILE
; 0B0 MEANS ASSIGN FROM LOW FRINGE UP TOWRDS SWAPPING TRACKS
; 1B1 MEANS ASSIGN FROM HIGH FRINGE DOWN TOWARDS SWAPPING TRACKS

TYPNPG:	0B0!^D0			;MONITOR.PACK-X
	0B0!^D512		;CORE DUMP 1ST 512 PAGES
	0B0!^D512		;CORE DUMP 2ND 512 PAGES
	1B0!^D512		;CORE DUMP 3RD 512 PAGES
	1B0!^D512		;CORE DUMP 4TH 512 PAGES
	1B0!^D0			;MICROCODE.PACK-X
	1B0!^D0			;MICRODIAG.PACK-X
	1B0!^D0			;BOOTSTRAP.PACK-X



;CREATE ALL SPECIAL FILES

CRTSFA:	PUSH P,1
	PUSH P,2
	HRROI 1,[ASCIZ/
Creating special system files./]
	PSOUT
	MOVSI 2,-NPACKS			;INIT LOW FRINGE TABLE
CRTSF2:	MOVE 1,ASFTBL(2)		;GET HARD ADR FRO PACK
	PUSH P,2
	CALL CDSKVA			;MAKE SOFT
	POP P,2
	MOVEM 1,LFRING(2)		;STORE IN TABLE INITING
	AOBJN 2,CRTSF2
	SETOM HFRING			;INIT HIGH FRINGE TABLE
	MOVE 1,[HFRING,,HFRING+1]
	BLT 1,HFRING+NPACKS-1
	MOVSI 2,-NTYPES
CRTSF1:	HRRZ 1,2			;TYPE IN 1
	CALL CRTFIL
	AOBJN 2,CRTSF1
	POP P,2
	POP P,1
	RET

;CREATE FILE
;ACCEPTS TYPE IN 1

CRTFIL:	ACMAC <%TYPE,%AC2,%AC3,%AC4>
	VARMAC <$AOBJN,$PAGE,$OFN,$JFN>
	MOVE 2,%TYPE
	MOVE 2,TYPUNT(2)		;GET AOBJN FOR PACKS
CRTFI1:	MOVEM 2,$AOBJN			;UPDATE AOBJN PTR
	MOVE 1,%TYPE			;TYPE IN 1
	HRRZ 2,$AOBJN			;CURRENT UNIT IN 2
	CALL MP1XB			;MAP THE INDEX BLOCK
	MOVEM 3,$PAGE
	MOVEM 4,$OFN
	MOVE 1,%TYPE
	HRRZ 2,$AOBJN
	CALL ST1XB			;SET UP XB AND ASSIGN ALL DATA PAGES
	MOVE 3,$PAGE
	MOVE 4,$OFN
	CALL RL1XB			;RELEASE THE XB
	MOVE 1,%TYPE
	HRRZ 2,$AOBJN
	CALL MK1FL			;MAKE THE FILE
	MOVE 1,%TYPE
	HRRZ 2,$AOBJN
	CALL MP1FL			;NOW MAP THE FILE
	 BUG (HLT,<CRTFIL: FAILED TO MAP JUST CREATED FILE>)
	MOVEM 3,$PAGE
	MOVEM 4,$JFN
	MOVE 1,%TYPE
	HRRZ 2,$AOBJN
	CALL CL1PG			;CLEAN IT OUT
	MOVE 3,$PAGE
	MOVE 4,$JFN
	CALL RL1FL			;UNMAP AND RELEASE
	 BUG (HLT,<CRTFIL: FAILED TO RELEASE JUST CREATED FILE>)
	MOVE 2,$AOBJN
	AOBJN 2,CRTFI1			;LOOP FOR ALL PACKS DESIRED
	RET

	PURGE %TYPE,%AC2,%AC3,%AC4
	PURGE $AOBJN,$PAGE,$OFN,$JFN



;ASSIGN AND MAP XB FOR FILE
;ACCEPTS 1/ TYPE
;	 2/ UNIT
;RETURNS 3/ PAGE ADR MAPPED TO
;	 4/ OFN

MP1XB:	ACMAC <%TYPE,%UNIT,%PAGE,%OFN>
	MOVE 1,%TYPE
	MOVE 1,TYPXBA(1)		;XB ADR TABLE
	TLNN 1,(1B0)			;IS ENTRY PTR TO TABLE?
	 JRST MP1XB1			;NO-ENTRY IS HDWR ADR
	ADD 1,%UNIT			;YES-ADD IN UNIT OFFSET
	MOVE 1,(1)			;GET TABLE ENTRY
MP1XB1:	CALL CDSKVA			;CONVERT TO LINEAR ADR
	CALL DSKASA			;ASSIGN THE XB
	 BUG (HLT,<MP1XB: DSKASA FAILED FOR XB>)
	TLO 1,(1B3!1B13!DSKABT)		;NEW FILE, CLASS BIT, DSKABT
	CALL ASOFN			;GET OFN FOR XB
	 BUG (HLT,<MP1XB: ASOFN FAILED FOR XB>)
	MOVEM 1,%OFN
	CALL ASGPAG			;GET A JOB AREA PAGE TO MAP TO
	 BUG (HLT,<MP1XB: ASGPAG FAILED FOR XB>)
	MOVEM 1,%PAGE
	MOVE 2,%PAGE
	HRLI 2,140000			;2/ ACCESS,, PAGE ADR
	MOVE 1,%OFN
	CALL SETMPG			;MAP IT
	RET

	PURGE %TYPE,%UNIT,%PAGE,%OFN



;FILL OUT XB AND ASSIGN ALL DATA PAGES
;ACCEPTS 1/ TYPE
;	 2/ UNIT
;	 3/ PAGE ITS MAPPED TO

ST1XB:	ACMAC <%TYPE,%UNIT,%PAGE,%OFN>
	VARMAC <$AOBJN,$ADR>
	MOVE 1,%PAGE
	HRLI 2,(1)
	HRRI 2,1(1)
	SETZM (1)
	BLT 2,777(1)			;CLEAN OUT XB
	MOVE 1,%TYPE
	HRRZ 1,TYPNPG(1)		;# DATA PAGES TO ASSIGN
	JUMPE 1,ST1XB5			;JUMP IF NONE
	MOVNS 1
	HRLS 1				;NEGATIVE INTO LH FOR AOBJN
	HRR 1,%PAGE			;STEPS THRU XB
ST1XB2:	MOVEM 1,$AOBJN			;UPDATE AOBJN SAVER
	MOVE 1,%TYPE			;TYPE
	HLL 1,TYPNPG(1)			;FLAG FOR UP OR DOWN FRINGE ASSIGN
	HRR 1,%UNIT			;1/ FLAG,,UNIT
	MOVE 2,LFRING(1)		;ASSUME LOW FRINGE
	TLNE 1,(1B0)			;BUT ASSIGNING BACKWARDS?
	 MOVE 2,HFRING(1)		;NO-USE HIGH FRINGE
	PUSH P,1			;SAVE DSKASF ARG
	CALL DSKASF			;ASSIGN A FRINGE PAGE
	 BUG (HLT,<STIXB: FAILED TO ASSING FRINGE PAGE FOR SPECIAL FILE>)
	POP P,1				;RESTORE ARG
	TLNE 1,(1B0)			;DID LOW?
	 JRST ST1XB3
	MOVEM 2,LFRING(1)		;YES-UPDATE FOR USE LATER
	AOS LFRING(1)			;SO START AT NEXT LIKELY AVAILABLE
	JRST ST1XB4

ST1XB3:	MOVEM 2,HFRING(1)		;UPDATE FOR USE LATER
	SOS HFRING(1)			;SO START AT NEXT LIKELY AVAILABLE
ST1XB4:	TLO 2,(DSKABT)			;DSKABT
	TLO 2,RWXB			;GIVE IT ACCESS
	MOVE 1,$AOBJN			;RESTORE AOBJN PTR
	MOVEM 2,(1)			;ENTER IT IN XB
	AOBJN 1,ST1XB2			;LOOP FOR ALL PAGES
ST1XB5:	RET

	PURGE %TYPE,%UNIT,%PAGE,%OFN
	PURGE $AOBJN,$ADR

;UNMAP AND RELEASE XB
;ACCEPTS 3/ PAGE ITS MAPPED TO
;	 4/ OFN

RL1XB:	ACMAC <%AC1,%AC2,%PAGE,%OFN>
	MOVEI 1,0
	MOVE 2,%PAGE
	CALL SETMPG			;UNMAP IT
	MOVE 1,%PAGE
	CALL RELPAG			;RELEASE JOB AREA PAGE ASSIGNMENT
	MOVE 1,%OFN
	CALL RELOFN			;BYE
	RET

	PURGE %AC1,%AC2,%PAGE,%OFN



;CREATES AND RELEASES FILE PTING TO XB
;ACCEPTS 1/ TYPE
;	 2/ UNIT

MK1FL:	ACMAC <%TYPE,%UNIT,%AC3,%AC4>
	VARMAC <$JFNAC,$DEVAC,<$STRNG,10>>
	MOVEM JFN,$JFNAC		;SAVE THESE GUYS
	MOVEM DEV,$DEVAC
	MOVE 1,%TYPE
	MOVE 2,%UNIT
	HRROI 3,$STRNG
	CALL MK1STG			;BUILD NAME IN STRING
	MOVSI 1,200001
	HRROI 2,$STRNG
	GTJFN
	 BUG (HLT,<MK1FL: FAILED TO GTJFN FOR FILE>)
	MOVE JFN,1			;LOOKOUT, JFN IS AN AC!
	LSH JFN,SJFN
	HRROI DEV,DSKDTB
	SETZ 0,				;CLEAR FLAGS FOR GETFDB
	CALL GETFDB
	 BUG (HLT,<MK1FL: FAILED TO GETFDB FOR FILE>)
	PUSH P,1			;SAVE RETURN FROM GETFDB
	MOVE 1,%TYPE
	MOVE 1,TYPXBA(1)
	TLNN 1,(1B0)			;TABLE PTR?
	 JRST MK1FL1			;NO
	ADD 1,%UNIT			;YES-ADD IN UNIT OFFSET
	MOVE 1,(1)			;AND GET THE HDWR XB ADR
MK1FL1:	CALL CDSKVA			;CONVERT TO LINEAR ADR
	MOVE 2,1			;SHUFFLE THINGS
	POP P,1				;RESTORE GETFDB RETURN
	TLO 2,(DSKABT)			;TURN ON DSKABT
	MOVEM 2,FDBADR(1)		;INTO FDB OF CD FILE
	MOVSI 2,FDBNXF
	ANDCAM 2,FDBCTL(1)		;IT EXISTS
	MOVSI 2,FDBPRM!FDBUND!FDB1PK!FDBXDP ;ON 1 PACK, DON'T DUMP FILE TO TAPE
	IORM 2,FDBCTL(1)		;PROTECT IT
	MOVE 2,[102340,,7020]		;THE DAY THE EARTH STOOD STILL
	MOVEM 2,FDBCRE(1)		;DATES
	MOVEM 2,FDBCRV(1)
	MOVEM 2,FDBWRT(1)
	MOVSI 2,(0B5!44B11)
	IORM 2,FDBBYV(1)		;VER RETAIN,BYTE SIZE
	MOVE 2,%TYPE
	HRRZ 2,TYPNPG(2)		;# PAGES
	LSH 2,^D9			;TIMES 512 WORDS PER PAGE
	MOVEM 2,FDBSIZ(1)
	MOVEI 2,1			;ASSUME SYSTEM IS 1
	HRLM 2,FDBUSE(1)		;UPDATE CREATOR
	CALL USTDIR
	MOVE 1,JFN
	LSH 1,-SJFN
	RLJFN
	 BUG (HLT,<MK1FL: FAILED TO RLJFN FILE>)
	MOVE JFN,$JFNAC			;RESTORE THESE GUYS
	MOVE DEV,$DEVAC
	RET

	PURGE %TYPE,%UNIT,%AC3,%AC4
	PURGE $JFNAC,$DEVAC,$STRNG



;BUILD FILENAME

;ACCEPTS 1/ TYPE
;	 2/ UNIT
;	 3/ PTR TO STRING STORAGE

MK1STG:	ACMAC <%TYPE,%UNIT,%PTR,%AC4>
	MOVE 1,%PTR
	MOVE 2,%TYPE
	HRRO 2,TYPNAM(2)		;GET ENTRY
	SETZ 3,
	SOUT
	MOVE 2,%TYPE
	MOVE 2,TYPNAM(2)
	TLNN 2,(1B0)			;DOES EXTENSION NEED COMPLETION
	 JRST MK1ST1			;NO
	MOVE 2,%UNIT
	MOVEI 3,0
	MOVEI 4,^D99
	CALL MKNMBR			;TACK ON DRIVE NUMBER
MK1ST1:	HRROI 2,[ASCIZ/;1;P404000/]
	SETZ 3,
	SOUT
	RET

	PURGE %TYPE,%UNIT,%PTR,%AC4


;MAP FILE PAGE 0 TO PAGE, READ AND WRITE
;RETURNS 1/ TYPE
;	 3/ PAGE ADR
;	 4/ JFN

;SKIPS IF SUCCESS, NO SKIP WITH ERROR CODE IN 1

MP1FL:	ACMAC <%TYPE,%UNIT,%PAGE,%JFN>
	VARMAC <<$STRNG,10>>
	CALL ASGPAG			;GET PAGE FOR IT
	 RET				;LOSE-ERROR # NOT VALID (TS)
	MOVEM 1,%PAGE			;REMEMBER PAGE
	MOVE 1,%TYPE
	MOVE 2,%UNIT
	HRROI 3,$STRNG
	CALL MK1STG			;BUILD FILEPATH
	MOVSI 1,100001
	HRROI 2,$STRNG
	GTJFN
	 RET
	MOVEM 1,%JFN
	MOVE 2,[440000,,300000]		;FOR READ AND WRITE
	OPENF
	 JRST [PUSH P,1			;SAVE ERROR CODE
		MOVE 1,%JFN
		RLJFN
		 JFCL
		POP P,1
		RET]			;OPENF ERROR CODE IN 1
	HRLZ 1,%JFN			;JFN,,0
	SFRAME				;PRESERVE FRAME PTRS
	CALL JFNOFN			;GET OFN,,0
	 BUG (HLT,<MP1FL: JFNOFN FAILED FOR FILE>)
	RFRAME				;RESTORE FRAM PTRS
	MOVE 2,%PAGE
	HRLI 2,140000			;2/ ACCESS,,PAGE ADR
	CALL SETMPG
	AOS (P)				;SKIP SUCCESS
	RET

	PURGE %TYPE,%UNIT,%PAGE,%JFN
	PURGE $STRNG

;UNMAP AND RELEASE FILE
;ACCEPTS 3/ PAGE ADR ITS MAPPED TO
;	 4/ JFN

;SKIPS IF SUCCESS, NO SKIP WITH ERROR CODE IN 1

RL1FL:	ACMAC <%AC1,%AC2,%PAGE,%JFN>
	MOVEI 1,0
	MOVE 2,%PAGE
	CALL SETMPG
	MOVE 1,%JFN
	CLOSF
	 RET
	MOVE 1,%PAGE
	CALL RELPAG
	AOS (P)				;SKIP SUCCESS
	RET

	PURGE %AC1,%AC2,%PAGE,%JFN



;CLEARS OUT ALL FILE PAGES FOR FILE
;ACCEPTS 1/ TYPE
;	 3/ PAGE 0TH PAGE IS MAPPED TO
;	 4/ JFN
;RETURNS LAST PAGE STILL MAPPED

CL1PG:	ACMAC <%TYPE,%AC2,%PAGE,%JFN>
	VARMAC <$AOBJN>
	MOVE 1,%TYPE
	HRRZ 1,TYPNPG(1)		;# DATA PAGES TO CLEAR
	JUMPE 1,CL1PG3			;DON'T FAULT IF NONE TO DO
	MOVNS 1
	HRLZM 1,$AOBJN			;NEGATIVE INTO LH FOR AOBJN
	JRST CL1PG2			;0TH PAGE ALREADY MAPPED

CL1PG1:	MOVEM 1,$AOBJN			;UPDATE AOBJN SAVER
	MOVEI 1,0
	MOVE 2,%PAGE
	CALL SETMPG			;UNMAP CLEARED PAGE
	HRL 1,%JFN
	HRR 1,$AOBJN			;NEXT PAGE #
	SFRAME				;PRESERVE FRAME PTRS
	CALL JFNOFN			;MAKE OFN,,PAGE
	 BUG (HLT,<CL1PG: JFNOFN FAILED FOR FILE PAGE>)
	RFRAME				;RESTORE FRAM PTRS
	MOVE 2,%PAGE
	HRLI 2,140000			;2/ ACCESS,,PAGE ADR
	CALL SETMPG
CL1PG2:	MOVE 2,%PAGE
	HRLI 1,(2)
	HRRI 1,1(2)
	SETZM (2)
	BLT 1,777(2)			;CLEAR A PAGE
	MOVE 1,$AOBJN
	AOBJN 1,CL1PG1			;LOOP FOR ALL PAGES
CL1PG3:	RET				;DONE, LEAVE LAST PAGE MAPPED

	PURGE %TYPE,%AC2,%PAGE,%JFN
	PURGE $AOBJN


;MAKE BAD FILE GOOD AGAIN (WON'T WORK FOR BAD XB)
;SKIP FOR SUCCESS

;IF XB IN SPTH, THEN ITS OPEN, REFUSE TO FIX IT UNTIL CLOSED
;   
;FIX UP DISK XB
;   CLEAR USER SPECIFIED BAD PAGES FROM XB
;   CLEAR OFNBAT FROM SPTH HENCE XBBAT FROM XB OF OPEN FILE)
;   CLEAR FDBBAT IN FDBCTL (GETFDB)

;WARNING: UNLCKF UPDATES FILSTS FROM STS.  DON'T DAMAGE IT WHILE FILE LOCKED

	SWAPCD

FIXBAD:	ACMAC <%AC1,%AC2,%AC3,%AC4>
	VARMAC <$UJFN,$EJFN,$FDB,$OFN,$FORK>
	HRROI 1,[ASCIZ/

File name: /]
	PSOUT
	MOVSI 1,(1B2!1B3!1B4!1B16!1B17)
	MOVE 2,[100,,101]
	GTJFN
	 RET
	MOVEM 1,$UJFN
	MOVE 2,[44B5!1B19!1B20!1B27]
	OPENF				;AND SUCK IN XB
	 JRST [	MOVE 1,$UJFN
		RLJFN
		 JFCL
		HRROI 1,[ASCIZ/? Failed to open file./]
		PSOUT
		RET]
	MOVE JFN,$UJFN
	SFRAME
	CALL CHKJFN		;GET INFO, LOCK FILE VIA FILLCK(JFN)
	 JFCL			;FAILED
	 JFCL			;TTY
	 JRST [	RFRAME		;BYTE POINTER
		MOVE 1,$UJFN
		CLOSF
		 JFCL
		HRROI 1,[ASCIZ/ ? CHKJFN did not succeed for file./]
		PSOUT
		RET]
	RFRAME
	MOVEM JFN,$EJFN		;TRUE JFN (UJFN SHIFTED)
	TEST(NE,ASTF)		;STARS?
FIXBA0:	 JRST [	MOVE JFN,$EJFN
		CALL UNLCKF	;UNLOCK FILE
		MOVE 1,$UJFN
		CLOSF
		 JFCL
		HRROI 1,[ASCIZ/ ? Not a legal disk file./]
		PSOUT
		RET]
	HRRZ 1,DEV		;GET DIPATCH ADR
	CAIE 1,DSKDTB		;DISK?
	 JRST FIXBA0
	HRRZ 1,NLUKD(DEV)	; Get name lookup dispatch
	CAIE 1,MDDNAM		; Must be mddnam
	 JRST FIXBA0
	MOVE JFN,$EJFN
	SFRAME
	CALL GETFDB			;NOINT,LOCK DIR
	 JRST [	RFRAME
		MOVE JFN,$EJFN
		CALL UNLCKF	;UNLOCK FILE
		MOVE 1,$UJFN
		CLOSF
		 JFCL
		HRROI 1,[ASCIZ/ ? Failed to get FDB./]
		PSOUT
		RET]
	RFRAME
	MOVEM 1,$FDB		;SAVE FDB ADR	 
	MOVE 3,FDBADR(1)	;GET XB ADR
	TLZ 3,777760		;KEEP JUST ADR PART
	MOVSI 1,-NOFN		;SCAN SPTH FOR IT (PRELIMINARY TO SAVE TIME)
FIXBA1:	MOVE 2,SPTH(1)
	CAIE 2,0		;FREE IS 0 OR -1
	CAMN 2,[-1]
	 JRST FIXBA2		;NOT IN USE
	TLZ 2,777760
	CAMN 2,3		;SAME?
	JRST FIXBA3		;YES
FIXBA2:	AOBJN 1,FIXBA1
	 JSP 1,FIXBAY

FIXBA3:	HRRZM 1,$OFN
	LDB 2,[POINT ^D14,SPT(1),^D13]	;GET SHARE COUNT
	CAIE 2,1			;MUST BE JUST US
	 JRST [	MOVE JFN,$EJFN
		CALL UNLCKF	;UNLOCK FILE
		MOVE 1,$UJFN
		CLOSF
		 JFCL
		HRROI 1,[ASCIZ/ ? File is OPEN, must be closed./]
		PSOUT
		CALL USTDIR	;UNLOCK DIR, GO OKINT
		RET]
FIXBA4:	HRROI 1,[ASCIZ/
Automatically clear bad pages or Prompt for them.
A or P? /]
	PSOUT
	PBIN
	TRZ 1,40
	CAIN 1,"A"
	 JRST FIXAUT
	CAIN 1,"P"
	 JRST FIXPMT
	JRST FIXBA4



FIXAUT:	MOVSI 1,100003
	HRROI 2,[ASCIZ/<SYSTEM>FIXBAD.SAV/]
	GTJFN
FIXAU1:	 JRST [	HRROI 1,[ASCIZ/
? Problem with FIXBAD program./]
		PSOUT
		JRST FIXBA4]
	PUSH P,1
	MOVSI 1,(1B1)
	CFORK
	 JRST [	POP P,1
		RLJFN
		 JFCL
		JRST FIXAU1]
	MOVEM 1,$FORK
	POP P,1
	HRL 1,$FORK
	GET
	MOVE 1,$FORK
	GEVEC
	HLRZS 2
	CAIG 2,1			;GOT ENTRY VECTOR BIG ENOUGH?
	 JRST [	MOVE 1,$FORK
		KFORK
		RFRKH
		JRST FIXAU1]
	ADD P,[20,,20]		;GET SPACE, BHC DOES NOT GO PAST 17,,17
	JUMPGE P,[SUB P,[20,,20]
		  MOVE 1,$FORK
		  KFORK
		  RFRKH
		  JRST MSTKOV]	;FAKE OVERFLOW OF STACK
	MOVE 1,$UJFN
	MOVEM 1,-16(P)		;JFN IN AC1
	MOVEI 1,1B35		;REMOVE BAD PAGES FLAG, DON'T RELEASE FILE FG
	MOVEM 1,-15(P)		;INTO AC2
	MOVE 1,$FORK
	MOVEI 2,-17(P)		;ACS
	SFACS
	MOVE 1,JOBNO		;OUR JOB #
	MOVEM 1,SCDRN2		;JUST US AND JOB 0 WHILE WE HAVE FILE UNLOCKED
	MOVE JFN,$EJFN
	CALL UNLCKF		;UNLOCK FILE FOR INFERIOR FORK ACCESS
	MOVE 1,$FORK
	MOVEI 2,1		;START ENTRY VECTOR SLOT 1
	SFRKV			;RUN INFERIOR BAD PAGE CLOBBERER
	WFORK
	MOVE JFN,$EJFN
	AOSE FILLCK(JFN)	;LOCK FILE AGAIN
	 JSP 1,FIXBAX
	SETOM SCDRN2		;ALLOW EVERYONE ELSE NOW THAT ITS LOCKED AGAIN
	MOVE 1,$FORK
	MOVEI 2,-17(P)
	RFACS
	MOVE 3,-16(P)		;GET FORKS AC1
	SUB P,[20,,20]		;RESYNC STACK
	RFSTS
	HLRZS 1
	CAIN 1,2		;MONITOR SAYS OK?
	SKIPE 3			;FORK SAYS OK?	
	 JRST [	MOVE 1,$FORK
		KFORK
		RFRKH
		HRROI 1,[ASCIZ/
? FIXBAD program did not run successfully./]
		PSOUT
		JRST FIXBA4]
	MOVE 1,$FORK
	KFORK
	RFRKH
	JRST FIXBA6
	


FIXPMT:	HRROI 1,[ASCIZ/
Clear bad page #(8) [^Z to end list]: /]
	PSOUT
	MOVEI 1,100
	MOVEI 3,10
	NIN
	 JRST [ MOVEI 1,100
		BKJFN
		 JRST FIXBA5
		PBIN
		CAIE 1,"Z"-100
		 JRST FIXBA5
		JRST FIXBA6]
	BKJFN
FIXBA5:	 JRST [	HRROI 1,[ASCIZ/ ? Bad page number./]
		PSOUT
		JRST FIXPMT]
	PBIN
	CAIE 1,37
	 JRST FIXBA5
	CAIL 2,0
	CAILE 2,<1000*1000>-1	;LONG FILES ALLOWED
	 JRST FIXBA5

	NOSKED			;ALLOW PMAP USING UNLOCKED FILE

	MOVE JFN,$EJFN
	PUSH P,2
	CALL UNLCKF
	POP P,2
	SETO 1,
	HRL 2,$UJFN
	SETZ 3,
	PMAP			;MAP IT OUT OF EXISTANCE
	MOVE JFN,$EJFN		;SPT($OFN) NOT PTING TO DISK NOW, OK
	AOSE FILLCK(JFN)	;LOCK FILE AGAIN
	 JSP 1,FIXBAX

	OKSKED			;WE HAVE LOCK AGAIN, ITS IN SPTH

	JRST FIXPMT



FIXBA6:	MOVE 1,$OFN
	MOVSI 2,OFNBAT
	ANDCAM 2,SPTH(1)	;CLEAR BAT BIT FROM SPTH (XB OF OPEN FILE)
	MOVE 1,$FDB
	MOVSI 2,FDBBAT
	ANDCAM 2,FDBCTL(1)		;CLEAR FDBBAT IN FDB
	MOVE JFN,$EJFN
	CALL UNLCKF
	HRRZ 1,$UJFN
	CLOSF
	 JFCL
	CALL USTDIR
	AOS (P)
	RET

;PC IN 1

FIXBAX: BUG(HLT,<FIXBAD: IMPOSSIBLE LOCKING OF FILE>)
FIXBAY:	BUG(HLT,<FIXBAD: FAILED TO FIND SPTN FOR OPEN BAD FILE>)


	PURGE %AC1,%AC2,%AC3,%AC4
	PURGE $UJFN,$EJFN,$FDB,$OFN,$FORK


;HOMBAT PARAMETER TABLE
;SPECIFIES WHERE VARIOUS HOMBAT RELATED PAGES LIVE
;1B0 MEANS ON ALL PACKS, 0B0 MEANS ON PRIMARY PACK OF STRUCTURE ONLY

	RESCD

HOMBAT:	VERHOM,,HOMLEN		;LATEST HOME BLOCK VER,,LEN KNOWN TO MONITOR
	VERBAT,,BATLEN		;LATEST BAT BLOCK VER,,LEN KNOWN TO MONITOR
	FREBAT			;INITAL FREE COUNT FOR VERBAT VERSON OF BAT BLK
	BATSCT			;POINTER TO SECTOR COUNT FIELD FOR VERBAT
	BATADR			;POINTER TO HDWR DSK ADR FIELD FOR VERBAT
	PRMUNT			;PRIMARY UNIT OF A STRUCTURE
	1B0!<CYLALL>B<CYLLSB>!<SRFXB1>B<SRFLSB>!<SECXB1>B<SECLSB> ;XB1
	1B0!<CYLALL>B<CYLLSB>!<SRFHM1>B<SRFLSB>!<SECHM1>B<SECLSB> ;HM1
	1B0!<CYLALL>B<CYLLSB>!<SRFBB1>B<SRFLSB>!<SECBB1>B<SECLSB> ;BB1
	1B0!<CYLALL>B<CYLLSB>!<SRFXB2>B<SRFLSB>!<SECXB2>B<SECLSB> ;XB2
	1B0!<CYLALL>B<CYLLSB>!<SRFHM2>B<SRFLSB>!<SECHM2>B<SECLSB> ;HM2
	1B0!<CYLALL>B<CYLLSB>!<SRFBB2>B<SRFLSB>!<SECBB2>B<SECLSB> ;BB2
	1B0!<CYLALL>B<CYLLSB>!<SRFMIC>B<SRFLSB>!<SECMIC>B<SECLSB> ;MIC
	1B0!<CYLALL>B<CYLLSB>!<SRFMCD>B<SRFLSB>!<SECMCD>B<SECLSB> ;MCD
	1B0!<CYLALL>B<CYLLSB>!<SRFBOT>B<SRFLSB>!<SECBOT>B<SECLSB> ;BOT
	1B0!<CYLALL>B<CYLLSB>!<SRFMON>B<SRFLSB>!<SECMON>B<SECLSB> ;MON
	0B0!<CYLALL>B<CYLLSB>!<SRFCD0>B<SRFLSB>!<SECCD0>B<SECLSB> ;CD0
	0B0!<CYLALL>B<CYLLSB>!<SRFCD1>B<SRFLSB>!<SECCD1>B<SECLSB> ;CD1
	0B0!<CYLALL>B<CYLLSB>!<SRFCD2>B<SRFLSB>!<SECCD2>B<SECLSB> ;CD2
	0B0!<CYLALL>B<CYLLSB>!<SRFCD3>B<SRFLSB>!<SECCD3>B<SECLSB> ;CD3

NHOMBA==.-HOMBAT



;READS CORE DUMP XB AND WRITES OUT ALL OF CORE
;SKIPS FOR SUCCESS
;DOES BARE DREADS AND DWRITES

CORDMP:	.-.				;JSR TO HERE
	SKIPN CDMPSW
	 JRST @CORDMP			;NO-SKIP RET TO CALLER
	MOVEM P,PDLSAV			;SAVE P
	MOVE P,HOMPDP			;PRIVATE STACK
	CALL CORDM0			;SO CAN USE ACMAC ETC.
	 CAIA				
	AOS CORDMP			;SKIP RET
	MOVE P,PDLSAV			;RESTORE P
	JRST @CORDMP			;BACK TO CALLER


;TABLE OF XB ADRS FOR CORE DUMP FILES

CDXBTB:	CD0ADR
	CD1ADR
	CD2ADR
	CD3ADR
NCDXBT==.-CDXBTB


CORDM0:	ACMAC <%AC1,%AC2,%AC3,%AC4>	;SAVE ACS
	VARMAC <$PI,$AOBJN,$XBTBP,$1STCP>
	CONI PI,$PI			;SAVE STATE OF PI
	PIOFF				;PIOFF IN HERE
	MOVEI 1,[SIXBIT '$TAKING CORE DUMP.../']
	JSR BUGMSG
	MOVE 1,[SSAVF1,,SSAVF1+1]
	SETZM SSAVF1			;MAKE A PAGE OF 0'S FOR DUMMY PG
	BLT 1,SSAVF1+777
	HRLZI 1,-NCDXBT			;INIT XB DISK ADR TABLE PTR
CORDM1:	MOVEM 1,$XBTBP			;UPDATE XB TABLE PTR
	MOVEI 1,SSAVXB			;REAL CORE ADR TO READ TO
	HRRZ 2,$XBTBP			;DISK ADR TABLE SLOT #
	MOVE 2,CDXBTB(2)		;DISK ADR
	TLO 1,(1B0!1B1)			;SAY WAIT FOR COMPLETION, ERROR RET
	CALL DREAD			;INTO DISK DRIVER
	 JRST CORDM5			;ERR - RELEASE PAGE AND NO SKIP FAILURE
	HRRZ 1,$XBTBP			;GET XB TABLE SLOT #
	LSH 1,^D9			;1/ 1ST CORE PAGE COVERED BY THIS XB
	MOVEM 1,$1STCP			;REMEMBER 1ST CORE PAGE
	HRLI 1,-1000			;INIT CORE PAGE AOBJN
CORDM2:	MOVEM 1,$AOBJN			;UPDATE AOBJN PTR SAVER
	SUB 1,$1STCP			;MAKE PAGE TABLE INDEX FROM CORE PAGE #
	MOVE 1,SSAVXB(1)		;GET DISK ADR FROM PAGE TABLE
	TLNN 1,(DSKABT)			;POINTING TO DISK?
	 JRST CORDM6			;NO-DON'T CHASE IT DOWN, LOSE THIS PAGE
	CALL CVDSK			;CONVERT TO HARDWARE DISK ADR
	MOVE 2,1			;DISK ADR IN 2
	HRRZ 1,$AOBJN			;GET PAGE TO SPIT
	CAIL 1,MAXCOR			;BUILT FOR THIS BIG?
	 MOVEI 1,SSAVF1			;NO-OVERWRITE WITH DUMMY PAGE
	LDB 3,[POINT 6,CST0(1),5]	;DOES IT EXIST THOUGH?
	CAIN 3,01			;AVAILABLE?
	 MOVEI 1,SSAVF1			;NO-OVERWRITE WITH DUMMY PAGE
	LSH 1,^D9			;MAKE REAL CORE ADR
	TLO 1,(1B0!1B1)			;SAY WAIT FOR COMPLETION, ERROR RET
	CALL DWRITE			;INTO DISK DRIVER
	 JRST CORDM6			;REPORT ERROR
CORDM3:	MOVE 1,$AOBJN
	AOBJN 1,CORDM2			;LOOP FOR ALL CORE PAGES
	HRRZS 1				;NEXT CORE PAGE THAT WILL BE DONE
	CAIL 1,MAXCOR			;ANY MORE CORE PAGES TO DO?
	 JRST CORDM4			;NO-CUT IT OFF HERE
	MOVE 1,$XBTBP			;YES-LOOP-GET XB TABLE AOBJN PTR
	AOBJN 1,CORDM1			;LOOP FOR ALL XB'S
	JRST CORDM4			;DONE

CORDM4:	AOS (P)				;SO WE SKIP RET
	MOVEI 1,[SIXBIT 'COMPLETE.$/']
	CAIA
CORDM5:	MOVEI 1,[SIXBIT 'FAILED.$/']
	JSR BUGMSG
	MOVE 1,$PI
	TRNE 1,200
	 PION				;RESTORE PION IF NECESSARY
	RET

CORDM6:	MOVEI 1,[SIXBIT '$CORE DUMP PAGE /']
	JSR BUGMSG
	HRLZ 2,$AOBJN			;2/ PAGE # WE ARE WORKING ON IN LH
	MOVEI 3,6			;TYPE 6 DIGITS
	SETZ 1,
CORDM7:	LSHC 1,3			;GET 3 BITS IN LOW AC 1
	ADDI 1,"0"
	JSR BUGTYO
	SOJG 3,CORDM7
	MOVEI 1,[SIXBIT ' WILL BE GARBAGED.$/']
	JSR BUGMSG
	JRST CORDM3			;CONTINUE

	PURGE %AC1,%AC2,%AC3,%AC4
	PURGE $PI,$AOBJN,$XBTBP,$1STCP



;SWAPPABLE MONITOR RELOADER
;READS FROM SWPMP0 TO CONTENTS OF SWCEND
;PUSHJ P, TO HERE FROM GETSWM AT PROCESS LEVEL, PION


RDSWPM:	ACMAC <%AC1,%AC2,%AC3,%AC4>	;SAVE VIA UPDL
	VARMAC <$AOBJN,$PAGE>
RDSWP0:	HRRZ 1,GETSMF			;MONITOR FILE FROM SAME PACK AS RES MON
	MOVE 1,MONTBL(1)		;HDWR ADR OF MONITOR FILE XB
	MOVEI 2,1000			;READ 1000 WORDS
	MOVEI 3,SSAVXB			;READ INTO XB PAGE
	CALL UDSKIO
	SKIPE 1				;OK?
	 JRST RDSWPX			;NO-DIE, TRY AGAIN IF ASKED TO
	SKIPN 1,SSAVXB			;ANY FILE OUT THERE?
	 JRST RDSWPX			;NO-DIE, TRY AGAIN IF ASKED TO
	TLNN 1,(DSKABT)			;DISK ADR?
	 JRST RDSWPX			;NO-DIE, TRY AGAIN IF ASKED TO
	CALL CVDSK			;MAKE HARDWARE ADR FOR PAGE 0
	MOVEI 2,1000			;READ 1000 WORDS
	MOVEI 3,SSAVF0			;TO HERE FOR MAPPING INFO
	CALL UDSKIO
	SKIPE 1				;OK?
	 JRST RDSWPX			;NO-DIE, TRY AGAIN IF ASKED TO
	SKIPN 1,SSAVXB+1		;2ND MAPPING INFO PAGE?
	 JRST RDSWP1			;NO-SKIP IT
	TLNN 1,(DSKABT)			;DISK ADR?
	 JRST RDSWPX			;NO-DIE, TRY AGAIN IF ASKED TO
	CALL CVDSK			;TO HDWR ADR
	MOVEI 2,1000			;READ 1000 WORDS
	MOVEI 3,SSAVF1			;TO HERE FOR MAPPING INFO
	CALL UDSKIO
	SKIPE 1				;OK?
	 JRST RDSWPX			;NO-DIE, TRY AGAIN IF ASKED TO
	JRST RDSWP1			;ALL SET TO READ IT IN


;HERE WHEN XB AND ALL MAPPING INFO READ INTO CORE
;NOW SUCK UP THE PAGES

RDSWP1:	HRLZ 4,SSAVF0			;GET N PAGES
	MOVNS 4
	HRRI 4,SSAVF0+1			;AOBJN PTR, START AT WORD 1
RDSWP2:	MOVEM 4,$AOBJN
	LDB 1,[POINT ^D9,(4),17]	;GET FORK PAGE
	CAIL 1,SWPMP0			;IN SWP MON RANGE?
	CAMLE 1,SWCEND
	 JRST RDSWP3			;NO-SKIP IT
	MOVEM 1,$PAGE			;SAVE VIRTUAL PAGE #
	HRRZ 1,(4)			;GET FILE PAGE
	MOVE 1,SSAVXB(1)		;GET ITS ADR
	TLNN 1,(DSKABT)			;DISK ADR?
	 JRST RDSWPX			;NO-DIE, TRY AGAIN IF ASKED TO
	CALL CVDSK			;MAKE HDWR ADR IN 1
	MOVEI 2,1000			;READ 1000 WORDS
	MOVE 3,$PAGE			;GET PAGE #
	HRRZ 3,MMAP(3)			;GET REAL CORE PAGE (LOCKED)
	LSH 3,^D9			;MAKE IT RCA
	CALL UDSKIO
	SKIPE 1				;OK?
	 JRST RDSWPX			;NO-DIE, TRY AGAIN IF ASKED TO
RDSWP3:	MOVE 4,$AOBJN			;GET AOBJN PTR
	AOBJN 4,RDSWP2			;LOOP FOR ALL FILE PAGES
	RET				;BACK TO CALLER

RDSWPX:	MOVEI 1,[SIXBIT '$FAILED TO READ SWAPPABLE MONITOR.$/']
	CALL BUGMSG
	JRST 4,RDSWP0			;TRY AGAIN IF ASKED TO

	PURGE %AC1,%AC2,%AC3,%AC4
	PURGE $AOBJN,$PAGE


;RESIDENT MONITOR RELOADER
;NO ACMAC OR VARMAC IN HERE SINCE CAN'T RELY ON SUPPORT ROUTINES

RLDSTR==36				;1ST LOC RELOADED

RLDCDA==3000				;WHERE TO RUN THIS CODE

;MANUAL DISK REBOOT.
;DOES NOT SAVE SWITCHES VIA LINK AREA
;JUMPS TO SEDDT THROUGH ENTRY VECTOR AT 145

MANRLD:	.-.				;JSR TO HERE FROM DSKRLD
	MOVEM P,PDLSAV			;SAVE P
	MOVE P,HOMPDP			;USE OUR STACK
	SETOM GETSMF			;CLEAR TIL NEW RESMON IN FROM DISK
	CALL INVLNK			;BE SURE LINK AREA INVALID
	MOVEI 2,0			;GO TO EDDT ENTRY CODE
	MOVE 3,[-2]			;ASK USER FOR PACK TO RELOAD FROM
	JRST RELOA1			;RELOAD ENTIRE MON FROM DISK


;FORCE AUTO RELOAD FROM  DISK
;HAS -1 FOR ANY OR PACK # IN 1

FRCRLD:	.-.			;JSR TO HERE
	SETOM GETSMF
	MOVE 3,1		;PUT -1 OR PACK N IN 3
	SETO 1,			;FORCED RELOAD GETS -1 PC
	JRST RELOAD


;AUTO DISK REBOOTER (ONLY IF RELDSW NON-ZERO)

;ACCEPTS REASON IN 1
;SAVES SWITCHES VIA LINK AREA.
;JUMPS TO START THROUGH ENTRY VECTOR AT 140

AUTRLD:	.-.				;JSR TO HERE FROM BUGHLTS
	SETOM GETSMF			;CLEAR "GET SWM FROM DSK"
	SKIPN RELDSW
	 JRST @AUTRLD			;BACK TO CALLER IF NOT DESIRED
	SETO 3,				;-1 FOR PACK #
RELOAD:	MOVEM P,PDLSAV			;SAVE P
	MOVE P,HOMPDP			;USE OUR STACK
	PUSH P,3			;SAVE PACK # DESTINED FOR BOOT
	CALL SAVLNK			;SAVE LINK STUFF, REASON IN 1 !!!!
	POP P,3
	MOVEI 2,1			;GO RIGHT INTO AUTO STARTUP ENTRY CODE
RELOA1:	PUSH P,2			;SAVE ENTRY CODE
	PUSH P,3			;AND PACK # FOR BOOT
	MOVEI 1,[SIXBIT '$$RELOADING SYSTEM FROM DISK.../']
	JSR BUGMSG
	CALL CRASHB			;TURN OFF TYMNET INTERFACE
	PIOFF				;TURN OFF PI AND PGR
	PGROFF				;BLT CLOBBERS CST
	MOVE 1,[RESRDB,,RLDCDB]		;ALL RESIDENT 1:1 MAPPING
	BLT 1,RLDCDE-1			;RELOCATE RELOAD CODE
	POP P,2				;GET PACK # FLAG IN 2
	POP P,1				;GET ENTRY CODE IN 1
	JRST RDRESG			;GO TO IT, RELOCATED



;ACROSS RELOAD STUFF

LNKPTN:	252525,,525252			;PATTERN FOR VALID LNKFLG

LNKFLG=20		;HOLDS VALIDITY PATTERN

LNKRSN=21		;HOLDS BUGHLT ADR WHICH CAUSED RELOAD
LNKTAD=22		;HOLDS CRASH TAD

LNKDBS=23		;HOLDS DBUGSW
LNKDCS=24		;HOLDS DCHKSW
LNKCDS=25		;HOLDS CDMPSW
LNKRLS=26		;HOLDS RELDSW
LNKFDS=27		;HOLDS FDDTSW


;LINK TABLE - LINK CELL,,TRUE CELL

LNKTBL:	LNKDBS,,DBUGSW
	LNKDCS,,DCHKSW
	LNKCDS,,CDMPSW
	LNKRLS,,RELDSW
	LNKFDS,,FDDTSW
NLNKTB==.-LNKTBL


;VALIDATE LINK AREA

VLDLNK:	MOVE 1,LNKPTN
	MOVEM 1,LNKFLG			;SAY VALID
	RET

;INVALIDATE LINK AREA

INVLNK:	SETZM LNKFLG			;NO LNKPTN
	RET

;SAVE THINGS IN LINK AREA
;ACCEPTS REASON IN 1

SAVLNK:	MOVEM 1,LNKRSN			;REASON PC
	CALL SAVTAD			;SAVE TAD
	CALL SAVTBL			;TABLE DRIVEN SAVE SWITCHES
	CALL VLDLNK			;SAY VALID
	RET


;RESTORE THINGS (IF POSSIBLE) FROM LINK AREA

RSTLNK:	MOVE 1,LNKFLG			;VALID STUFF
	CAME 1,LNKPTN			;IMPROBABLE WIL FIND PATTERN ACCIDENTLY
	 RET				;NO
	MOVE 1,LNKRSN			;GET REASON
	MOVEM 1,RLDRSN			;RESTORE TO REASON FOR RELOAD CELL
	CALL INVLNK			;NO LONGER VALID
	CALL RSTTAD			;RESTORE TAD
	CALL RSTTBL			;TABLE DRIVEN RESTORE SWITCHES
	RET

;SAVE TAD STUFF IN CRASH LINK AREA

SAVTAD:	SETOM LNKTAD		;-1 MEANS NOT SET YET
	SKIPGE TADSEC
	 RET
	MOVE 1,TODCLK
	IDIVI 1,^D1000
	ADD 1,TADSEC
	IDIVI 1,^D24*^D3600
	HRRZM 2,LNKTAD
	ADD 1,TADDAY
	HRLM 1,LNKTAD
	RET


;RESTORE TAD STUFF IN CRASH LINK AREA

RSTTAD:	SKIPGE LNKTAD		;SET?
	 JRST [	SETOM TADSEC
		SETOM TADDAY
		RET]
	SETZ 3,
	MOVE 1,TODCLK
	IDIVI 1,^D1000		; Convert to seconds
	HRRZ 2,LNKTAD
	SUB 2,1			; Compute offset
	JUMPGE 2,.+3
	ADDI 2,^D24*^D3600	; If less than 0, augment
	AOJA 3,.-2
	HLRZ 1,LNKTAD
	SUB 1,3
	MOVEM 1,TADDAY
	MOVEM 2,TADSEC
	RET


;SAVE CELLS VIA LNKTBL

SAVTBL:	MOVSI 1,-NLNKTB		;SCAN LINK TABLE
SAVTB1:	HRRZ 2,LNKTBL(1)	;GET ADR OF CELL
	MOVE 3,(2)		;GET ITS CONTENTS
	HLRZ 2,LNKTBL(1)	;GET WHERE TO SAVE IT
	MOVEM 3,(2)		;SAVE IT IN LINK AREA
	AOBJN 1,SAVTB1		;LOOP
	RET


;RESTORE CELLS VIA LNKTBL

RSTTBL:	MOVSI 1,-NLNKTB		;SCAN LINK TABLE
RSTTB1:	HLRZ 2,LNKTBL(1)	;GET WHERE IT IS SAVED
	MOVE 3,(2)		;GET IT
	HRRZ 2,LNKTBL(1)	;GET WHERE IT GOES
	MOVEM 3,(2)		;RESTORE IT FROM LINK AREA
	AOBJN 1,RSTTB1		;LOOP
	RET


	LIT				;GET ALL LITERALS OUT OF THE WAY



RESRDB:					;SYMBOL FOR START OF BLT

	PHASE RLDCDA			;START OF PHASED CODE

;CODE IS OFFSET BY 1 WORD TO ALLOW FOR IOWD AT RLDCDA.  THAT WAY MICROCODE
;CAN SUCK UP A PAGE AND USE IT IMMEDIATELY IF IT IS SMART ABOUT SUCKING
;IT UP TO THE RIGHT PAGE IN THE FIRST PLACE.  MICRO CODE SHOULD PUT -2
;IN RLDPKN TO GET BOOT TO ASK USER QUESTIONS AFTER BOOT SUCKED IN.

;SET UP FOR RIM10 FORMAT (IOWD 0TH WORD, XFER INSTRUCTION LAST WORD)
;WORD 1 CONTAINS START INSTR (FOR WHEN RES MON IS ALL IN)

RLDCDB:	IOWD NRLDCD-1,.+1		;1ST RELOCATED ADR

RLDGO:	JRST 145			;DEFAULT START INSTR, CHANGED BY CALLER
					;EDDT IS DEFAULT

RLDPKN:	-1				;DEFAULT IS ANY MONITOR THAT WORKS
					;-2 => ASK CTY FOR PACK #
					;-1 => FIRST DISK PACK THAT WINS
					;0:NPACKS-1 => SPECIFIC PACK #

RLDPKC:	BLOCK 1				;USED FOR PACK AOBJN WHILE WORKING
RLDPGC:	BLOCK 1				;USED FOR PAGE AOBJN WHILE WORKING
RLDHM1:	HM1MAC				;COPY OF HM1TBL FOR RELOADING PURPOSES
RLDHM2:	HM2MAC				;COPY OF HM2TBL FOR RELOADING PURPOSES

RLDPDL:	BLOCK 20			;LOCAL PHASED STACK
RLDPDP:	IOWD 20,RLDPDL			;STACK PTR

;READS RESIDENT MONITOR FROM SSAVE FORMAT FILE ON DISK.
;THE 0TH PAGE LOW CORE UP TO RLDSTR IS NOT READ OVER.
;THE WAY THINGS ARE ADJUSTED, PAGE 0 MUST BE READ BEFORE PAGE 1.
;BUT OTHER PAGES CAN BE READ IN ANY ORDER.
;CLEANS OUT MEMORY FIRST

;ENTRY POINT TO READ DATA SWITCHES

RDRESM:	PIOFF				;NO INTS
	PGROFF				;NO PAGING HERE ON IN
	DATAI APR,1			;<JUNK>B17!<ENTRY CODE>B26!<PACK #>B35
	MOVE 2,1
	ANDI 2,000777			;MASK OFF PACK # (-2,-1 OR PACK #)
	TRNE 2,000400			;IS PACK # NEGATIVE?
	 IOR 2,[-1,,777000]		;YES-SIGN EXTEND IT
	LSH 1,-^D9			;POSITION ENTRY CODE
	ANDI 1,000777			;JUST ENTRY CODE IN 1
					;-2,-1 OR PACK # IN 2
					;FALL THRU...

;ENTRY CODE IN 1
;PACK # FLAG IN 2
;PI AND PGR OFF ALREADY

RDRESG:	MOVE P,RLDPDP			;NEW STACK
	MOVEM 1,RLDGO			;STORE CODE TEMPORARILY IN RLDGO
	MOVEM 2,RLDPKN			;SAVE PACK FLAG
	CAME 2,[-2]			;ASK CTY?
	 JRST RDRES0
RDRESQ:	MOVEI 1,[SIXBIT '$BOOT FROM DISK PACK # [CR FOR ANY]: /']
	CALL RLDMSG
	CALL RLDTYI			;EAT CHR AND ECHO IT
	PUSH P,1
	MOVEI 1,[SIXBIT '$/']		;NEW LINE WHEN SOMETHING TYPED
	CALL RLDMSG
	POP P,1
	MOVEI 2,-"0"(1)			;# IN 2, CHR IN 1
	CAIN 1,15
	 JRST [	SETO 2,			;-1 MEANS ANY PACK THAT WORKS
		JRST RDRES0]
	CAIL 2,0
	CAILE 2,NPACKS-1
	 JRST [	MOVEI 1,[SIXBIT ' ? HUH ?/']
		CALL RLDMSG
		JRST RDRESQ]
RDRES0:	MOVSI 1,-NPACKS			;ALL PACK AOBJN
	SKIPL 2				;WANT IT THOUGH?
	 HRRO 1,2			;NO, GET -1,,PACK #
RDRESL:	MOVEM 1,RLDPKC			;SAVE PACK AOBJN
	MOVE P,RLDPDP			;NEW STACK
IFE F4FLG!F5FLG,<	;DON'T BOTHER TO CLEAR MEM ON F4 OR F5
	CALL RLDCLR			;CLEAR PHYS MEMORY
		>
	MOVEI 1,[SIXBIT '$$BOOTING FROM DISK PACK /']
	CALL RLDMSG
	HRRZ 1,RLDPKC
	ADDI 1,"0"
	CALL RLDTYO
	MOVEI 1,[SIXBIT '.../']
	CALL RLDMSG
	MOVEI 1,SSAVXB			;REAL CORE ADR FOR FILE XB
	HRRZ 2,RLDPKC			;PACK AOBJN PTR
	MOVE 2,RLDHM1(2)		;HDWR DISK ADR OF PRIMARY HB FOR PACK
	TLO 1,(1B0!1B1)			;WAIT FOR COMPLETION, RET ON ERROR
	CALL LDREAD			;READ IT
	 CAIA				;TRY SECONDARY
	CALL RDRECH			;CHECK CONSISTENCY
	 CAIA
	JRST RDRESH			;USE IT
	MOVEI 1,SSAVXB			;REAL CORE ADR FOR FILE XB
	HRRZ 2,RLDPKC			;PACK AOBJN PTR
	MOVE 2,RLDHM2(2)		;HDWR DISK ADR OF SECONDARY HB FOR PACK
	TLO 1,(1B0!1B1)			;WAIT FOR COMPLETION, RET ON ERROR
	CALL LDREAD			;READ IT
	 JRST RDRESX
	CALL RDRECH			;CHECK CONSISTENCY
	 JRST RDRESX
RDRESH:	LDB 2,[POINT <NCYLBT+NSRFBT+NSECBT>,HOMMNA+SSAVXB,SECLSB]
				;GET MONITOR XB HARD DISK ADR SANS PACK #
	HRRZ 1,RLDPKC			;GET OUR PACK # (DON'T BELIEVE HB)
	DPB 1,[POINT NUNTBT,2,UNTLSB]	;PUT IT IN DISK ADR
	MOVEI 1,SSAVXB			;INCASE PACK IN DIFF ADR SLOT NOW
	TLO 1,(1B0!1B1)			;WAIT FOR COMPLETION, RET ON ERROR
	CALL LDREAD			;READ IT
	 JRST RDRESX
	SKIPN 2,SSAVXB			;ANY FILE OUT THERE?
	 JRST RDRESX
	TLNN 2,(DSKABT)			;DISK ADR?
	 JRST RDRESX
	CALL CVTSFT			;MAKE HARWARE ADR FOR PAGE 0
	MOVEI 1,SSAVF0			;TO HERE FOR MAPPING INFO
	TLO 1,(1B0!1B1)			;WAIT FOR COMPLETION, RET ON ERR
	CALL LDREAD
	 JRST RDRESX
	SKIPN 2,SSAVXB+1		;IS THERE A 2ND MAPPING INFO PAGE?
	 JRST RDRES1			;NO-IGNORE FILE PAGE 1
	TLNN 2,(DSKABT)			;DISK ADR?
	 JRST RDRESX
	CALL CVTSFT			;YES-CONVERT TO HDWR
	MOVEI 1,SSAVF1			;TO HERE FOR MORE MAPPING INFO
	TLO 1,(1B0!1B1)			;WAIT FOR COMPLETION, RET ON ERR
	CALL LDREAD
	 JRST RDRESX
	JRST RDRES1


;HERE WHEN SOMETHING WENT WRONG FOR PACK
;TRY FOR NEXT PACK, DIE IF ALL OUT

RDRESX:	MOVEI 1,[SIXBIT 'FAILED TO READ RESIDENT MONITOR.$/']
	CALL RLDMSG
	MOVE 1,RLDPKC			;PACK AOBJN
	AOBJN 1,RDRESL
	MOVEI 1,[SIXBIT '$YOU LOSE.  I HOPE YOU HAVE A MONITOR TAPE HANDY.$/']
	CALL RLDMSG
	JRST 4,RDRESM			;START OVER IF ASKED TO



;HERE WHEN XB AND ALL MAPPING INFO READ INTO CORE
;NOW SUCK UP THE PAGES
;CAREFUL NOT TO CLOBBER PAGES IN USE
;READS IN ONLY THOSE BELOW SWPMP0

RDRES1:	HRLZ 4,SSAVF0			;GET N PAGES
	MOVNS 4
	HRRI 4,SSAVF0+1			;AOBJN PTR, START AT WORD 1
RDRES2:	MOVEM 4,RLDPGC			;UPDATE AOBJN SAVER
	LDB 1,[POINT ^D9,(4),17]	;GET FORK PAGE
	CAIL 1,SWPMP0			;LESS THAN BOUNDRY?
	 JRST RDRES3			;NO-SKIP IT
	CAIN 1,0			;PAGE 0?
	 SKIPA 1,[RLDSTR]		;YES-START AT THIS LOC, ENDING IN PG 1
	LSH 1,^D9			;NOW-MAKE IT REAL CORE ADR
	CAIE 1,RLDCDB			;THIS PAGE?
	CAIN 1,SSAVXB			;OR XB PAGE?
	 JRST RDRES3			;YES-SKIP IT
	CAIE 1,SSAVF0			;OR MAP PAGES?
	CAIN 1,SSAVF1
	 JRST RDRES3			;YES-SKIP IT
	HRRZ 2,(4)			;GET FILE PAGE
	MOVE 2,SSAVXB(2)		;GET ITS ADR
	TLNN 2,(DSKABT)			;DISK ADR?
	 JRST RDRESX			;NO-FAIL
	CALL CVTSFT			;MAKE HDWR DISK ADR
	PUSH P,1			;SAVE MEMORY START ADR
	TLO 1,(1B0!1B1)			;WAIT FOR COMPLETION, RET ON ERR
	CALL LDREAD			;READ THE PAGE IN
	 JRST RDRESX			;FAIL
	POP P,1				;RESTORE IT
	CAIE 1,RLDSTR			;WAS IT START PAGE 0 OFFSET?
	 JRST RDRES3			;NO-NOTHIN TO DO
	MOVE 1,[RLDSTR+RLDSTR,,RLDSTR]	;YES-GOT TO BLT IT DOWN
	BLT 1,777			;FIXING UP 0TH PAGE
	MOVE 1,[1000,,1001]		;AND CLEANUP PAGE OVERLAP
	SETZM 1000			;IN PAGE 1
	BLT 1,1000+RLDSTR-1
RDRES3:	MOVE 4,RLDPGC			;GET MAP INFO PTR AGAIN
	AOBJN 4,RDRES2			;LOOP FOR ALL PAGES
	MOVEI 1,[SIXBIT 'RESIDENT MONITOR READ COMPLETE.$$/']
	CALL RLDMSG
	MOVE 3,RLDGO			;GET ENTRY CODE
	CAIN 3,2			;CODE 2
	 JRST [	MOVEI 1,[SIXBIT 'HALTING AS REQUESTED...$$/']
		MOVE 2,[JRST 4,145]	;HALT WITH EDDT LOC EFF ADR
		JRST RDRES4]
	CAIN 3,1			;CODE 1
	 JRST [	MOVEI 1,[SIXBIT 'STARTING MONITOR...$$/']
		MOVE 2,[JRST 147]
		JRST RDRES4]
	MOVEI 1,[SIXBIT 'STARTING EDDT...$$/']	;EDDT IS DEFAULT (CODE 0)
	MOVE 2,[JRST 145]
RDRES4:	MOVEM 2,RLDGO			;ENTER START INSTR
	CALL RLDMSG			;TELL USER VIA AC 1
	MOVE 1,[CLRRLD,,4]		;RELOCATE CLEANUP TO ACS
	BLT 1,4+CLRRLS-1
	MOVE 1,RLDGO			;START INSTR TO AC 1
	HRRZ 2,RLDPKC			;GET SUCCESSFUL PACK # FOR GETSMF
	JRST 4				;JUMP TO IT, CLEANUP, START

;AC RUNNABLE CODE TO CLEAN OUT THE PAGES WE ARE RUNNING IN BEFORE STARTING.
;HAS START ADR IN AC 1 WHEN RUN

CLRRLD:	MOVE 3,[RLDCDB,,RLDCDB+1]	;AC4 - 3 IS SCRATCH REG
	SETZM RLDCDB			;AC5
	BLT 3,RLDCDE-1			;AC6 - CLEAN IT ALL OUT
	MOVEM 2,GETSMF			;AC7 - SAY GET SWP MON FROM PACK N
	JRST 1				;AC10 - 1 HAS DESIRED START INSTR

CLRRLS==.-CLRRLD			;SIZE OF CLEANUP CODE


;IFN F4FLG,<
;
;PRINTX <ASSEMBLING NON-AC RUNNABLE CODE FOR BOOTSTRAP FOR F4 (NOT AN ERROR).>
;
;	HRRZ 1,RLDPKC			;GET SUCCESSFUL PACK # FOR GETSMF
;	MOVEM 1,GETSMF			;SAY GET SWP MON FROM PACK N
;	MOVE 1,[RLDCLN,,RLDGO+1]	;BLT CLEANUP TO LOW PART OF PAGE
;	BLT 1,RLDCLE-1
;	JRST RLDGO+1			;AND START CLEANUP
;
;	LIT
;
;RLDCLN==.
;
;	DEPHASE				;UNDO ORIGINAL BOOTSTRAP PHASE
;
;	PHASE RLDGO+1			;PHASE TO RELOC JUST AFTER RLDGO
;
;RLDCLB:	SETZM RLDCLE			;CLEAR LOWEST CELL WE CAN
;	MOVE 1,[RLDCLE,,RLDCLE+1]
;	BLT 1,RLDCDE-1			;CLEAN UP MOST OF BOOTSTRAP
;	JRST RLDGO			;GO TO START INSTR
;
;	LIT
;
;RLDCLE==.
;
;NRLDCL==RLDCLE-RLDCLB			;SIZE OF PHASE CLEANUP CODE
;
;	DEPHASE				;UNDO CLEANUP PHASE
;
;	PHASE RLDCLN+NRLDCL		;CONTINUE ORIGIANL BOOTSTRAP PHASE
;
;> ;END IFN F4FLG



;CLEARS ALL MEMORY BETWEEN RLDSTR AND TOP OF MEMORY
;IS CAREFUL NOT TO COMMIT SUICIDE

RLDCLR:	SETZ 1,				;PROTOTYPE WORD
	MOVEI 2,RLDSTR			;WHERE TO START CLEARING
	MOVE 3,[MAXCOR*1000]		;WHERE TO STOP
RLDCL1:	CAIE 2,RLDCDB			;THIS PAGE?
	CAIN 2,SSAVXB			;OR XB PAGE?
	 JRST RLDCL2			;YES-SKIP IT
	CAIE 2,SSAVF0			;OR MAP PAGES?
	CAIN 2,SSAVF1
	 JRST RLDCL2			;YES-SKIP IT
	XMOVEM 1,			;CLEAR VIA LOC IN AC2
	AOSA 2				;BUMP ADR
RLDCL2:	ADDI 2,1000
	CAMGE 2,3			;DONE?
	 JRST RLDCL1
	RET


;CONVERT SOFTWARE LINEAR DISK ADR IN 2 TO HDWR FORMAT IN 2
;SIMILAR TO CVDSK IN DSKPAK, HERE FOR PHASING

CVTSFT:	PUSH P,1			;CLOBBER NO ACS
	PUSH P,3
	PUSH P,4
	MOVE 1,2			;GET LINEAR ADR
	TLZ 1,DSKMSK			;FLUSH EXTRA BITS
	MOVEI 2,NTKUN			;GET AROUND EXTERNAL ARITHMETIC
	IMULI 2,NSECTK
	IDIV 1,2			;ISOLATE UNIT IN 1
	IDIVI 2,NSECTK			;ISOLATE CYLINDER IN 2
	IDIVI 3,NSECS			;ISOLATE SURFACE IN 3, SECTOR IN 4
	LSH 1,NCYLBT+NSRFBT+NSECBT	;SHIFT 1 TO HARDWARE UNIT FIELD
	LSH 2,NSRFBT+NSECBT		;SHIFT 2 TO HARDWARE CYLINDER FIELD
	LSH 3,NSECBT			;SHIFT 3 TO HARDWARE SURFACE FILED
	IOR 1,2				;MERGE CYLINDER WITH UNIT FIELDS
	IOR 1,3				;MERGE SURFACE FIELD
	IOR 1,4				;MERGE SECTOR FIELD
	MOVE 2,1			;RET IN AC2
	POP P,4				;RESTORE ACS
	POP P,3
	POP P,1
	RET



;ROUTINES FOR NON-PI TALKING

RLDTYI:	CONSO TTY,1B29			;WAIT TIL CHAR TYPED
	JRST .-1
	DATAI TTY,1			;GET IT
	ANDI 1,177			;ASCII
	CALL RLDTYO			;ECHO IT
	RET				;CHAR IN 1 (ECHOED)

RLDTYO:	CONSZ TTY,1B31			;WAIT TIL OUTPUT NOT BUSY
	JRST .-1
	DATAO TTY,1			;SPIT IT
	CONSZ TTY,1B31			;WAIT TIL ITS SENT
	JRST .-1
	RET

RLDMSG:	MOVE 7,1
	HRLI 7,440600
RLDM2:	ILDB 1,7
	ADDI 1,40
	CAIN 1,"/"
	 RET
	CAIN 1,"$"
	JRST RLDM1
RLDM3:	CALL RLDTYO
	JRST RLDM2

RLDM1:	MOVEI 1,15
	CALL RLDTYO
	MOVEI 1,12
	JRST RLDM3


;CHECK ON CONSISTENCY OF HOME BLOCK AT SSAVXB
;SKIP FOR OK

RDRECH:	MOVEI 1,SSAVXB			;LOC OF HB
	MOVE 2,HOMNAM(1)
	CAME 2,[SIXBIT/HOME/]
	 RET
	MOVE 2,HOMID(1)
	CAME 2,[SIXBIT/1/]
	CAMN 2,[SIXBIT/2/]
	 CAIA
	RET
	MOVE 2,HOMVER(1)
	CAME 2,[VERHOM,,HOMLEN]
	 RET
	MOVE 2,HOMHW0(1)
	CAME 2,[<NUNTBT>B8+<NCYLBT>B17+<NSRFBT>B26+<NSECBT>B35]
	 RET
	MOVE 2,HOMHW1(1)
	CAME 2,[NTKUN,,NSURFS]
	 RET
	MOVE 2,HOMHW2(1)
	CAME 2,[NSECS,,NWSEC]
	 RET
	MOVE 2,HOMHW3(1)
	CAME 2,[<NTKUN*NSURFS*NSECS>,,<NSURFS*NSECS>]
	 RET
	MOVE 2,HOMSNM(1)
	CAME 2,[SIXBIT/PS/]
	 RET
	MOVE 2,HOMCOD(1)
	CAIN 2,CODHOM
	 AOS (P)
	RET


;ITSY BITSY POOLE DISK DRIVER COPIED FROM DSKPAK FOR PHASING

;FLAGS:
;B0 IS 1 FOR WAIT FOR COMPLETION, 0 FOR WILL FIELD INTERRUPT LATER
;B1 IS 1 FOR TAKE NO SKIP RET ON ERROR, 0 FOR BUGHLT AT DERROR ON FAILURE

;CALL:	MOVE A,[<FLAGS>B1!<MEMORY STARTING ADDRESS>]
;	MOVE B,[BYTE(6)UNIT(13)CYLINDER(8)HEAD(8)SECTOR]
;	PUSHJ PDL,<LDWRIT OR LDREAD>
;	<RETURNS ON +2 SUCCESS, HALTS AT DERROR ON ERROR IF 0B1>
;	  <AT DERROR, ERRBIT HAS ERROR BITS IN IT.>
;	<RETURNS +2 ON SUCCESS, RETURNS +1 ON ERROR IF 1B1>
;	  <ON +1 RETURN: REG. 1 HAS ERROR BITS IN IT>
;CLOBBERS 1,2,3


OPDEF DKCO[740000,,0]		;DISK CONO IOT
OPDEF DKCI[741000,,0]		;DISK CONI IOT
OPDEF DKSO[742000,,0]		;DISK CONSO IOT
OPDEF DKSZ[743000,,0]		;DISK CONSZ IOT

;DEFS. OF TEMP. IOTS

OPDEF LA[723000,,0]
OPDEF RA[717000,,0]
OPDEF LC[721000,,0]
OPDEF RC[715000,,0]
OPDEF LE[724000,,0]
OPDEF LM[722000,,0]
OPDEF RM[716000,,0]


;RIGHT HALF ERROR BITS

S.ANY==200
S.NACT==20

;LEFT HALF BITS

S.NBSY==1000
S.SERR==400000
S.IPE==10			;INTERNAL PARITY ERROR
S.OVRN==40			;DATA OVERRUN
S.WRP==200000			;UNIT IS WRITE PROTECTED
S.NRDY==100000			;UNIT NOT READY
S.SKER==20000			;SEEK ERROR (CODE BELOW DOES AUTO. RECALIBRATE)
S.FALT==10000			;UNIT FAULT

;LOCAL PHASED STORAGE

DA:	BLOCK 1
MA:	BLOCK 1
CMD:	BLOCK 1
RCNT:	BLOCK 1
ERRBIT:	BLOCK 1
DINTFG:	BLOCK 1
FLG.MA:	BLOCK 1


LDREAD:	TDZA 3,3		;READ COMMAND IS ALL ZERO.

LDWRIT:	MOVEI 3,11000		;WRITE COMMAND.
	PUSH P,0		;0 USED AS TEMP. BELOW
	MOVEM 2,DA		;SAVE DISK ADDRESS
	CALL DOOP		;DO THE OPERATION.
	 CAIA
	AOS -1(P)		;SKIP FOR SUCCESS IF DOOP SKIPED
	POP P,0
	RET

DOOP:	DKCO 0			;CLEAR INT CHANNEL (DSKXFR TURNS IT BACK ON)
	MOVEM 1,FLG.MA		;SAVE FLAG AND MA
	TLZ 1,(1B0!1B1)		;CLEAR OUT THE FLAGS
	MOVEM 1,MA		;RECORD THE DATA ADDRESS ONLY
	MOVEM 3,CMD		;ALSO THE COMMAND.
	MOVEI 10		;RETRY COUNT
	MOVEM RCNT
	LE [2]			;RESET CTRL
DOOP1:	MOVE 1,DA		;GET DISK ADDRESS
	LA 1			;DESELECT
	TLO 1,2000		;INSTALL SELECT ENABLE BIT
	LA 1			;SELECT DRIVE AND LOAD DSK ADR.
	RC 0			;READ STATUS BITS.
	TLNN S.NRDY		;DRIVE NOT READY ?
	TLNE S.SERR		;SELECT ERROR ?
B.SERR:	JSP 2,B.ERR
	MOVEI 1,404000		;GIVE CLEAR FAULT COMMAND.
	SETZM DINTFG		;TELL GO TO WAIT FOR COMPLETION
	CALL GO
	JSP 2,B.ERR		;TIMEOUT RETURN
	MOVE 1,CMD		;NOW GIVE MAIN COMMAND.
	LM MA			;LOAD THE MEMORY ADDRESS.
	RC 0
	TLNN S.NRDY		;BETTER STILL BE READY...
	TRNE S.ANY		;...NO ERRORS SHOULD HAVE APPEARED...
R.ANY:	JSP 2,B.ERR
	SETZM DINTFG		;ASSUME WAIT FOR COMPLETION
	SKIPL FLG.MA		;WAIT?
	 SETOM DINTFG		;TELL GO TO RETURN IMMEDIATELY
	CALL GO
	 JRST B.ERR1		;RECAL IF TIMEOUT
	TLNN S.IPE		;INTERNAL PARITY ERROR ?
	TRNE S.ANY		;ANY OTHER ERROR ?
G.ANY:	JSP 2,B.ERR
	AOS (P)			;SKIP RET ON SUCCESS ALWAYS
	RET



GO:	LE [2]			;INIT THE CONTROLLER.
	LC 1			;SEND THE COMMAND.
	LE [1]			;START THE CONTROLLER.
	SKIPE DINTFG		;ARE WE TO WAIT FOR COMPLETION?
	JRST GO2			;NO, RETURN IMMEDIATELY
	MOVEI 1,60000		;TIMEOUT DELAY
GOL:	RC 0
	IMULI 4,1		;STOP USING MEMORY FOR A WHILE.
	TRNN S.NACT		;CHECK FOR ACTIVE
	SOJG 1,GOL
	JUMPLE 1,.+2		;CHECK FOR TIMED OUT...
GO2:	AOS (P)			;SKIP RETURN IF NO ERROR...
	RET

B.ERR:	SUBI 2,1
	TLNE S.SERR		;SELECT ERROR ?
	 JRST DERROR		;DIE !
	TLNE S.SKER		;SEEK ERROR ?
B.ERR1:	CALL RECAL		;YES, RECALIBRATE
	 JRST DERROR
	SOSG RCNT		;HAVE WE RETRIED ENOUGH ?
	JRST DERROR		;YES.
	JRST DOOP1		;TRY, TRY, TRY AGAIN...

;SKIP FOR SUCCESS

RECAL:	MOVE 1,[1404000]	;RECALIBRATE
	SETZM DINTFG		;TELL GO TO WAIT FOR COMPLETION
	CALL GO
	 RET
	TRNE S.ANY
	 RET
	AOS (P)
	RET

DERRO0:	SETZM FLG.MA		;CLEAR FLAGS FIRST
DERROR:	MOVEM 0,ERRBIT		;PRESERVE THE MAGIC BITS.
	MOVE 0,FLG.MA
	TLNN 0,(1B1)		;WANT FAILURE RETURN?
	 JRST 4,RDRESM		;DIE A HORRIBLE DEATH
	MOVE 1,ERRBIT
	RET			;RETURN TO DREAD OR DWRITE

	LIT			;PHASE LITERALS TOO


RLDXFR:	JRST RDRESM		;XFER INSTR, RIM10 LOADER XCTS IT

RLDCDE==.			;ADR OF RELOCATED END OF CODE

	DEPHASE			;END OF PHASED CODE

NRLDCD==RLDCDE-RLDCDB		;SIZE OF RELOAD CODE (INCLUDE AOBJN PTR)

IFG <NRLDCD-1000>,<PRINTX DISK REBOOT CODE TOO BIG>



;SPIT RELOCATED BOOTSTRAP FILE
;SKIPS FOR SUCCESS
;RIM10 FORMAT

CRIM10:	ACMAC <%AC1,%AC2,%AC3,%AC4>
	VARMAC <$JFN>
	HRROI 1,[ASCIZ/
Creating RIM10 bootstrap file.../]
	PSOUT
	MOVSI 1,600001
	HRROI 2,[ASCIZ/BOOTSTRAP.R10/]
	GTJFN
	 JRST CRTBOX
	MOVEM 1,$JFN
	MOVE 2,[440000,,300000]
	OPENF
	 JRST [	MOVE 1,$JFN
		RLJFN
		 JFCL
		JRST CRTBOX]
	MOVE 2,[444400,,RESRDB]		;POINT TO IT IN CORE
	MOVNI 3,NRLDCD			;SIZE OF IT (INCLUDES IOWD, XFER INSTR)
	SOUT
	CLOSF
	 JFCL
	HRROI 1,[ASCIZ/Completed.
/]
	PSOUT
	AOS (P)
	RET

CRTBOX:	HRROI 1,[ASCIZ/Failed.
/]
	PSOUT
	RET

	PURGE %AC1,%AC2,%AC3,%AC4
	PURGE $JFN



	PURGE ..U,..N			;UTILITY SYMBOLS ZAPPED

	END
