;<FOONEX>EDDT.10X;2 12-Nov-81 10:52:19, Edit by ECARTER
;REMOVED F3FLG
;F3LFG DLS IS 370
;DSK:<FOONEX>EDDT.10X;6 14-Nov-80 12:18:33, Edit by FRENCH
;FLUSH UMOVES SYMBOL, MACRO 53 DOESN'T KNOW THEM
;DSK:<PEFMON>EDDT.10X;5 12-May-80 16:39:20, Edit by FRENCH
;IMPLEMENT RETAINED "[" OR "]" FOR LINEFEEDS
;<134-TENEX>EDDT.10X;3    28-NOV-77 12:08:12    EDIT BY PETERS
;Changed SAVE to DDSAVE to fix multiply defined global
;<133-TENEX>EDDT.10X;5     2-NOV-75 09:56:56    EDIT BY LYNCH
; CHANGED SWITCH SETTING FOR MAXC SETTINGS BECAUSE OF TROUBLE WITH PI SYSTEM
;<133-TENEX>EDDT.10X;3     8-FEB-75 19:49:11    EDIT BY LYNCH
; MADE IT WORK FOR TERMINAL TYPE 35 INSTEAD OF TI725
;<SOURCES>EDDT.10X;32     1-AUG-74 23:58:57    EDIT BY TAFT
; Redo JMC table macros because lists got too big for literals
;<SOURCES>EDDT.10X;31     1-AUG-74 22:51:08    EDIT BY TAFT
; Update JMC table.
; Explicitly set all desired modes in TTYRET (e.g. echoing)
;<SOURCES>EDDT.10X;30    30-MAY-74 12:04:21    EDIT BY TAFT
; ADD SWXCT CONDITIONAL SO SINGLE-STEP XCT CODE CAN BE ASSEMBLED OUT.
; PATCH AT PADSO+4 SO SMALL HALFWORD NEGATIVES DON'T TYPE AS "UTRWD+NN".
;<129>EDDT.10X;28    14-DEC-73  9:50:24	EDIT BY TAFT
;<129>EDDT.10X;27    13-DEC-73 18:08:17	EDIT BY TAFT
; IMPLEMENT CONTROL-A CHARACTER DELETION.  DO SFCOC ON ENTRY/EXIT.
; "$$$" SKIP COUNTER FOR $X.
;<129>EDDT.10X;20    13-DEC-73 10:42:34	EDIT BY TAFT
; MORE FIXES TO APR SAVE/RESTORE.  ADD "L,,G$O" COMMAND TO ESTABLISH
; OFFSET LIMITS FOR "SYMBOL+N" TYPEOUT FOR LOCAL AND GLOBAL SYMBOLS.
;<129>EDDT.10X;18     3-DEC-73 17:28:50	EDIT BY TAFT
; FIX SCREWUP IN JMC TABLE.
;<129>EDDT.10X;16    28-NOV-73 20:50:25	EDIT BY TAFT
; MAKE ^Z WORK.  (ELIMINATE LAST 10/50 UUO FROM TENEX ASSEMBLY)
;<129>EDDT.10X;15    28-NOV-73 20:23:10	EDIT BY TAFT
; ADD CODE TO WAKEUP ON ALL INPUT CHARACTERS WHILE IN DDT IN USER MODE.
; FIX LOSING APR SAVE/RESTORE LOGIC.  TEST NXM IN MORE PLACES.
; MORE PADDING FOR TI!
;<131>EDDT.10X;13    26-NOV-73 20:51:52	EDIT BY TAFT
; EXTEND NUMBER OF HANDLED SKIPS TO 3 (I.E. ALLOWING .+1 THRU .+4).
; ADD VARIABLE $X RANGE AND CELL MONITORING TO SINGLE-STEP EXECUTE.
;<131>EDDT.10X;11    26-NOV-73 19:01:49	EDIT BY TAFT
;<131>EDDT.10X;9    26-NOV-73 16:58:20	EDIT BY TAFT
; SAVE AND RESTORE TRAP STATUS WORD AND WRITE DATA IF THE PSB IS
; MAPPED AS PAGE 777 (ELIMINATING THE DEFICIENCY MENTIONED BELOW).
;<131>EDDT.10X;8    23-NOV-73  2:34:15	EDIT BY TAFT
; CORRECTLY INTERPRET ALL BUT THE MOST PATHOLOGICAL CASES OF MAPPED XCT
; IN PROCEED AND SINGLE-STEP EXECUTE LOGIC.  CASES STILL INCORRECTLY
; HANDLED ARE MAPPED XCT'S OF XCT, JUMP, AND SUBROUTINE CALL
; INSTRUCTIONS (SKIPS ARE OK).
;<131>EDDT.10X;7    23-NOV-73  1:09:07	EDIT BY TAFT
; INTERCEPT PAGER TRAPS GENERATED WHILE INSIDE EDDT.  PRINT "?" IF TRAP
; CAUSED BY ILLEGAL USER REFERENCE, ELSE HALT.  NOTE IMPLEMENTATION
; DEFICIENCY IN COMMENT NEAR DDTRAP:.
;<131>EDDT.10X;6    22-NOV-73 22:52:29	EDIT BY TAFT
; ADD CODE TO INTERPRET JSYS CORRECTLY IN PROCEED LOGIC.
;<131>EDDT.10X;5    22-NOV-73  2:30:20	EDIT BY TAFT
; INSTALL HARVARD SINGLE-STEP EXECUTE FEATURE, WITH MODIFICATIONS FOR TENEX
;<131>EDDT.10X;4    22-NOV-73  1:06:55	EDIT BY TAFT
; ADD CODE TO TYPE OUT JSYS MNEMONICS (STENEX.REL MUST BE LOADED).
;<131>EDDT.10X;2    22-NOV-73  0:01:25	EDIT BY TAFT
; INSTALL UNDER THE SWMAXC CONDITIONAL:
;   SPECIAL MAXC OPCODES (JMCS).
;   CR PADDING FOR TI TERMINAL AS CONSOLE TTY.
;   INCOMPATIBLE HANDLING OF PI STATE.
;<TENEX-132>EDDT.10X;7    14-NOV-73 12:26:53	EDIT BY TOMLINSON
; FIX XTTYRE FOR TTY ON ACTIVE PI CHANNEL
;<TENEX-130>EDDT.10X;6    29-NOV-72 22:49:52	EDIT BY CLEMENTS
;<TENEX-130>EDDT.10X;5    29-NOV-72 13:09:22	EDIT BY CLEMENTS
;FIXED TTYCLR, REMOVED JSYS FROM OP TREE
;<TENEX-130>EDDT.10X;4    27-NOV-72 15:37:44	EDIT BY TOMLINSON
; INSERTED EDDT==101
;<TEN50>DDT.MAC;3    27-NOV-72 14:44:38	EDIT BY CLEMENTS
;<TEN50>DDT.MAC;2    24-NOV-72 21:12:20	EDIT BY CLEMENTS
;MODS TO RUN UNDER TENEX AND KNOW TENEX OPCODES

EDDT==301		; TENEX EDDT WITH S.S. XCT

SUBTTL 12-DEC-71  /TW/PFC/TWE
;COPYRIGHT (C) 1970,1971,1972 DIGITAL EQUIPMENT CORP., MAYNARD, MASS., USA

;SWITCHES FOR DDT FEATURES
SWEXEC==1B35	;EXEC MODE
SWPTP==1B34	;PAPER TAPE
SWFILE==1B32	;FILDDT
SWYANK==1B31	;$Y
SW10X==1B29	;MODIFICATIONS FOR TENEX
SWXCT==1B28	;SINGLE-STEP EXECUTE FEATURE (COSTS ABOUT 450 INSTRUCTIONS)
SWMAXC==1B27	;MAXC OPCODES AND OTHER INCOMPATIBILITIES
;		; I TOOK IT OUT BECAUSE IT MESSES UP THE PI SYSTEM FOR REAL PDP-10 S.
IFN EDDT&SW10X,<	SEARCH STENEX>		;GET TENEX OPDEFS

%DDTVR==<3400,,70>
IFNDEF	EDDT,<EDDT==0>

IFE  EDDT&SWFILE,<INTERN %DDTVR>
REPEAT 0,<
DDT ASSEMBLY INSTRUCTIONS
THE SOURCE FILE OF DDT WILL ASSEMBLE INTO SEVERAL DIFFERENT
VERSIONS; THE ASSEMBLY IS CONTROLLED BY THE VALUE ASSIGNED
TO THE SYMBOL "EDDT". THE SYMBOL "EDDT" IS DECODED AS FOLLOWS:

BIT 35	=0;	ASSEMBLE A USER MODE DDT
	=1;	ASSEMBLE AN EXECUTIVE MODE DDT (WILL ALSO RUN IN USER MODE)


BIT 34	=0;	DO NOT ASSEMBLE THE PAPER TAPE FEATURES INTO DDT
	=1;	ASSEMBLE THE PAPER TAPE FEATURES BUT ONLY IF
			ASSEMBLING AN EXECUTIVE MODE DDT

BIT 33	=0;	FOR USER MODE DDT ONLY- ASSEMBLE USING THE
			"TTCALL" UUO FOR TELETYPE IO
	=1;	FOR USER MODE DDT ONLY- ASSEMBLE USING THE
			"DDTIN" AND "DDTOUT" UUO'S FOR TELETYPE IO
		*** THIS SWITCH IS NO LONGER SUPPORTED BY DEC. 22-SEPT-70 *** MCO #D-343

BIT 32  =1;	ASSEMBLE A FILE DDT  -- USUALLY SET BIT 31 TOO

BIT 31 =1;	ASSEMBLE A PAPER TAPE INPUT DDT ($Y)

BITS (0-17)
	=0;	ASSEMBLE A RELOCATABLE VERSION OF DDT (RELOC 0)
	NOT=0;	ASSEMBLE AN ABSOLUTE (NON-RELOCATABLE) VERSION
			OF DDT WITH A STARTING ADDRESS BEING THE
			NUMBER IN BITS 0-17

(IF THE SYMBOL "EDDT" IS NOT DEFINED AT ALL, DDT WILL BE ASSEMBLED
	WITH	EDDT=0.)

EXAMPLES OF "EDDT" DEFINITIONS:
	EDDT=0	ASSEMBLE A RELOCATABLE USER MODE DDT

	EDDT=23	ASSEMBLE A RELOCATABLE EXECUTIVE MODE DDT

	EDDT=<XWD 4000,23>
		ASSEMBLE AN ABSOLUTE EXECUTIVE MODE DDT
		WHOSE STARTING ADDRESS IS LOCATION 4000.

	EDDT=30	ASSEMBLE A FILDDT
>	;END OF REPEAT 0
DEFINE XP (X.,Y.),<
	IF2,<X.=Y.
;+++	INTERN	X.>>


IFN EDDT&SWEXEC,<	TITLE EDDT	-EXEC MODE DDT	>
IFN EDDT&<SWEXEC!SWFILE>,<
	XJBSYM==36
	XJBUSY==32
	XZLOW==40>

IFE EDDT&SWEXEC,<
IFE EDDT&SWFILE,<	TITLE UDDT	-USER MODE DDT	>
IFN EDDT&SWFILE,<	TITLE FILDDT	-FILE DDT	
	LN.RES==400		;LENGTH OF FILDDT RESIDENT AREA
	LN.CUR==400		;LENGTH OF FILDDT WINDOW
	T30SYM==131		;SPMON (10/30)>
>

EXTERN .JBREL,.JBSA,.JBHRL,.JBSYM,.JBFF,.JBHSM,.JBHNM,.JBUSY
ZLOW==140

INTERNAL .JBVER,.JBDDT
.JBDDT==74
.JBVER==137
IFE EDDT&SWEXEC,<
	LOC	.JBVER		;DO NOT SET  IF EXEC DDT(OK USER OR FILDDT)
	%DDTVR		;PUT VERSION # IN .JBVER
	>

IFE	EDDT&SWFILE,<
	LOC	.JBDDT
	XWD	DDTEND,DDTX
>
RELOC 0

IFN EDDT&<XWD -1,0>,<LOC <EDDT>B53>


IFN EDDT&SWEXEC,<
	OPDEF	SKPUSR	[SKIPL USRFLG]	;SKIP IN USER MODE
	OPDEF	SKPEXC	[SKIPGE USRFLG]	;SKIP IN EXEC MODE
	OPDEF	SKPKA	[SKIPN KAFLG]	;SKIP FOR KA10
	OPDEF	SKPKI	[SKIPE KAFLG]	;SKIP FOR KI10
>
IFN EDDT&SWFILE,<	CM==2		;DEFINE SOFTWARE CHANS.
		DP==3
>
;DEFINE ACCUMULATORS

F=0		;FLAGS
R=<A=1>		;POINTERS TO TABLES, CORE, ETC.
S=<B=2>
W=<C=3>		;CONTAINS DISPATCH ADDRESS IN WORD ASSEMBLER
T=4		;TRANSFER DATA
W1=5
W2=6
SCH=7		;MODE CONTROL SWITCH FOR OUTPUT
AR=10		;MODE CONTROL SWITCH FOR OUTPUT
ODF=11		;MODE CONTROL SWITCH FOR OUTPUT - CURRENT RADIX
TT=12		;TEMPORARY
TT1=13		;TEMPORARY
TT2=14		;TEMPORARY (USED FOR PTR INPUT ONLY)
P=17		;PUSHDOWN STACK

;DEFINE I/O DEVICE MNEMONICS FOR DDT USE
PRS==4
TTYY==120
PTRR==104
PTPP==100

;DEFINE PUSH DOWN LENGTH
LPDL==50	;MAX LENGTH PUSH DOWN LIST

NXMKA==1B23	;NON-EX-MEM FLAG FOR KA10
NXMKI==1B29	;NON-EX-MEM FLAG FOR KI10

TINBFS==20	;TYPEIN BUFFER SIZE (FOR CHARACTER DELETION FUNCTION)
IFE EDDT&SW10X,<CDELCH=="H"-100>	;DELETE CHAR:  BACKSPACE IN 10/50
IFN EDDT&SW10X,<CDELCH=="A"-100>	;CONTROL-A IN TENEX
;DEFINE BITS FOR USE IN LEFT HALF OF ACCUMULATOR F
COMF==200000		;COMMA TYPED FLAG
TIF==100000		;TRUNCATE TO 18 BITS -  SET BY SPACE OR COMMA
PTF==100		; +, -, OR * HAS BEEN TYPED
CTF==400
SF==4		;SYLLABLE FLAG
QF==1		;QUANTITY TYPED IN TO WORD ASSEMBLER

CF==40		; $  TYPED
CCF==10000	; $$  TYPED
MF==2		;MINUS SIGN TYPED IN
LTF==20		;LETTER TYPED IN TO CURRENT SYLLABLE
ROF==10		;REGISTER OPEN FLAG
STF==4000
FAF==1000		; < TYPED
SAF==2000		; > TYPED

FPF==20000		; . TYPED IN
FEF==400000		; E FLAG

MLF==200		;*FLAG
DVF==40000		;DIVIDE FLAG


;DEFINE BITS FOR USE IN RIGHT HALF OF ACCUMULATOR F

ITF==2	;INSTRUCTION TYPED IF ITF=1
OUTF==4	;OUTPUT IF OUTF=1
CF1==400		;OUTPUT 1 REGISTER AS CONSTANT
LF1==2000		;OUTPUT 1 REGISTER AS FORCED SYMBOLIC OR CONSTANT
Q2F==1		;NUMBER TYPED AFTER ALT MODE 
R20F==10	;TEMP FLAG USED IN SETUP
SBF==20
NAF==200		;NEGATIVE ADDRESSES PERMISSABLE
POWF==4000		;ARGUMENT FOR EXPONENT COMING
PNAMEF==10000		;PROGRAM NAME SEEN IN SYM TABLE SEARCH
MDLCLF==20000		;USED BY EVAL- MULTIPLY DEFINED LOCAL SYMBOL
IFN EDDT&SWMAXC,<
JMCTF==40000		;A JMC HAS BEEN TYPED OUT
>

;DEFINE SYMBOL TABLE SYMBOL TYPES
GLOBAL==040000		;GLOBAL SYMBOL
LOCAL==100000
PNAME==740000		;PROGRAM NAME
DELI==200000		;DELETE INPUT
DELO==400000		;DELETE OUTPUT
;DEFINE UNDEFINED SYMBOL TABLE (.JBUSY) TYPES
STADD==1B0	;IF 1, THEN ADDITIVE REQUEST
STLH==1B1	;IF 1, THEN REQUEST FOR LEFT HALF
STNEG==1B4	;IF 1, THEN NEGATIVE REQUEST
IFE	EDDT&SWFILE,<
	INTERN	DDTEND		;DECLARE END OF DDT AS INTERNAL, FOR
			; USER TO SEE (USER MODE) AND ONCE ONLY CODE
			; (MONITOR)
	IFE	EDDT&SWEXEC,<	ENTRY DDT>
	IFN	EDDT&SWEXEC,<	INTERNAL DDT
			ENTRY DDTX		;NEEDED BY MONITOR>>

;DEFINE $ SYMBOLS INTERNAL TO DDT
OPDEF DDTINT [Z 0,]			;ADDRESS FLAG FOR INTERNAL REGISTERS

IFE	EDDT&SWFILE,<
RADIX 10
NBP==8	;NUMBER OF BREAKPOINTS
DEFINE DBPNT (Z.)<XP $'Z.'B,<DDTINT B1ADR+3*Z.-3>>
ZZ==0
REPEAT NBP,<DBPNT \<ZZ==ZZ+1>>
RADIX 8
XP $M,<DDTINT MSK>
XP $I,<DDTINT SAVPI>>
;DEFINE I/O DEVICE MNEMONICS

IFN EDDT&SWEXEC,<

XP  PI,004B11
XP PAG,010B11
XP CCI,014B11
XP DLB,060B11
XP DLC,064B11
XP CLK,070B11
XP PTP,100B11
XP PTR,104B11
XP CDP,110B11
XP CDR,114B11
XP TTY,120B11
XP LPT,124B11
XP DIS,130B11
XP PLT,140B11
XP  CR,150B11
XP DSK,170B11
XP  DC,200B11
XP UTC,210B11
XP UTS,214B11
XP MTC,220B11
XP MTS,224B11
XP MTM,230B11
XP DLS,370B11
XP DPC,250B11
XP DCSA,300B11
XP DCSB,304B11
XP DTC,320B11
XP DTS,324B11
XP TMC,340B11
XP TMS,344B11	
IFN EDDT&SW10X,<
XP IMP,550B11
XP PGR,024B11
>>

;DEFINE EXTENDED OPERATIONS

IFE EDDT&SWFILE,<
XP JOV,2554B11
XP JEN,2545B11
XP HALT,2542B11
IFN EDDT&SW10X,<
XP JSYS,104B8>	>
DDTOFS:		;OFFSET BASE FOR DISPATCH TABLES

IFE EDDT&SWFILE,<
DDTX:
IFN EDDT&SWYANK,<
	SETZM	COMAND		;INDICATE NO COMMAND FILE IF STARTING BY DDT COMMAND
>
DDT:	JSR	DDSAVE
	PUSHJ	P,REMOVB
	MOVEI	T,XEC1		;RESTET $P DEFAULT RETURN SO
	HRRM	T,PROC0		;  $P WILL NO-OP
IFN EDDT&SWEXEC,<
	MOVE	W1,[ASCII /DDT/]
	SKPUSR
	MOVE	W1,[ASCII /EDDT/]
	PUSHJ	P,TEXT2		;TYPE MESSAGE SAYING WHICH DDT
>
>	;END EDDT&SWFILE
IFN EDDT&SWFILE,<
DDT:	CALLI
	SETZM	COMAND		;CLEAR $Y FLAG
	SETZM	FWAZER		;CLEAR BLOCK OF STORAGE
	MOVE	T,[FWAZER,,FWAZER+1]
	BLT	T,LWAZER
	MOVEI	P,PS		;PRESET PUSH DOWN LIST
	MOVSI	T,'DSK'		;PRESET DEVICE
	MOVEM	T,FILDEV+1
	OUTSTR	[ASCIZ /File: /]
	PUSHJ	P,TINCH
	  JRST	FDINO		;IN CASE NULL LINE TYPED IN
	SETOM	CRASHS		;PRESET FOR FILE MODE
	MOVEI	TT,0		;CLEAR NAME
	MOVE	TT1,[POINT 6,TT]	;PRESET ACCUMULATOR

FDILP:	CAIN	T,"/"		;SEE IF SWITCH
	JRST	FDISW		;YES--GO DO IT
	CAIN	T,":"		;SEE IF DEVICE
	JRST	[JUMPE TT,FDIERR
		 MOVEM TT,FILDEV+1
		 JRST  FDILNP]
	CAIN	T,"."		;SEE IF EXTENSION FLAGGED
	JRST	[MOVEM TT,FILBLK
		 SETOM FDIDOT
		 JRST  FDILNP]
	CAIE	T,"["		;SEE IF PPN FLAGGED
	JRST	FDILET		;NO--MUST BE IN NAME
	PUSHJ	P,FDIOCT	;YES--GET PROJECT
	JUMPLE	TT2,FDIERR	;DISALLOW JUNK
	CAIG	TT2,377777	;DISALLOW INVALID NUMBERS
	CAIE	T,","		;VERIFY
	JRST	FDIERR		;BOMB ERROR
	HRLZM	TT2,FILBLK+3	;STORE
	PUSHJ	P,FDIOCT	;GET PROGRAMMER
	JUMPLE	TT2,FDIERR	;DISALLOW JUNK
	CAILE	TT2,-1		;DISALLOW INVALID
	JRST	FDIERR		;  NUMBERS
	HRRM	TT2,FILBLK+3	;STORE
	JUMPE	T,FDILDP	;EXIT IF DONE
	CAIE	T,"]"		;SEE IF END OF PPN
	JRST	FDIERR		;NO--BOMB OUT
	JRST	FDILOP		;GET MORE WORDS
;STILL EDDT&SWFILE

FDIOCT:	MOVEI	TT2,0		;CLEAR ANSWER
FDIOC1:	PUSHJ	P,TINCH		;GET CHAR
	  POPJ	P,		;IF DONE
	TLNE	TT2,(7B2)	;IF OVERFLOWING,
	POPJ	P,		;  GIVE UP
	CAIL	T,"0"		;SEE IF
	CAILE	T,"7"		;  OCTAL
	POPJ	P,		;NO--GIVE UP
	LSH	TT2,3		;YES--MULT AC
	ADDI	TT2,-"0"(T)	;INCREMENT
	JRST	FDIOC1		;LOOP

FDILET:	CAIL	T,"0"		;SEE IF ALPHA-NUM
	CAILE	T,"Z"
	JRST	FDIERR
	CAILE	T,"9"
	CAIL	T,"A"
	JRST	.+2
	JRST	FDIERR
	SUBI	T,40		;YES--MAKE SIXBIT
	TLNE	TT1,(77B5)	;DON'T OVERFLOW
	IDPB	T,TT1		;STORE
	JRST	FDILOP		;AND LOOP
;STILL EDDT&SWFILE

FDIERF:	OUTSTR	[ASCIZ /? Can't get at file
/]
	JRST	FDIERE

FDIHLP:	ASCIZ	\
Type  dev:file.ext[p,pn]/switches

/M  examine monitor
/P  patch monitor or file
	type ^Z to exit from file patching
/S  reload symbol table from file

if no spec, examine monitor
file defaults:  if /P or /S:  DSK:SYSTEM.XPN
		else:  DSK:CRASH.XPN

use $Y to read DSK:FILDDT.DDT and write LPT:FILDDT.LST

\
;STILL EDDT&SWFILE

TINCH:	INCHWL	T		;GET NEXT CHAR
	CAIE	T,177
	CAIN	T,15
	JRST	TINCH
	CAIE	T,40
	CAIN	T,11
	JRST	TINCH
	CAIE	T,3
	CAIN	T,32
	JRST	[RESET
		 EXIT 1,
		 JRST DDT]
	JUMPE	T,TINCH
	CAIGE	T,175
	CAIGE	T,40
	JRST	[MOVEI T,0
		 POPJ  P,]
	CAIL	T,140
	SUBI	T,40
	JRST	CPOPJ1


FDISW:	PUSHJ	P,TINCH		;GET SWITCH
	  JRST	FDIERR
	CAIN	T,"H"		;HELP
	JRST	[OUTSTR FDIHLP
		 JRST   FDIERE]
	CAIN	T,"P"		;PATCH
	JRST	[SETOM	PATCHS
		 JRST	FDILOP]
	CAIN	T,"S"		;LOAD SYMBOLS
	JRST	[SETOM SYMGET
		 JRST  FDILOP]
	CAIN	T,"M"		;MONITOR
	JRST	[SETZM CRASHS
		 JRST  FDILOP]
				;FALL INTO ERROR
;STILL EDDT&SWFILE

				;FALL HERE FROM ABOVE
FDIERR:	OUTSTR	[ASCIZ \? Command error -- type /H for help
\]

FDIERE:	CLRBFI			;CLEAR ANY TYPE AHEAD
	JRST	DDT		;AND START OVER


FDILNP:	MOVEI	TT,0		;CLEAR WORD
	MOVE	TT1,[POINT 6,TT]	;RESET POINTER
FDILOP:	PUSHJ	P,TINCH		;GET NEXT CHAR
	  SKIPA
	JRST	FDILP		;LOOP BACK TO PROCESS IT

FDILDP:	SKIPE	TT		;ALL DONE--SEE IF FILE NAME ASSEMBLED
	JRST	[SKIPE FDIDOT
		 HLLZM TT,FILBLK+1
		 SKIPN FDIDOT
		 MOVEM TT,FILBLK
		 JRST  .+1]

FDINO:	SKIPE	PATCHS		;SEE IF /P
	SKIPN	CRASHS		;AND NOT /M
	JRST	.+2		;NO
	SETOM	SYMGET		;YES--SET /S
	MOVEI	T,17		;PRESET I/O MODE
	MOVEM	T,FILDEV
	MOVE	T,['CRASH ']
	SKIPE	SYMGET		;SEE IF /S OR /P
	MOVE	T,['SYSTEM']
	SKIPN	FILBLK		;PRESET FILE NAME
	MOVEM	T,FILBLK
	MOVSI	T,'XPN'		;AND FILE EXT
	SKIPN	FDIDOT
	HLLZM	T,FILBLK+1
;STILL EDDT&SWFILE

	SKIPN	SYMGET		;SEE IF /S
	SKIPE	CRASHS		;SEE IF /M
	JRST	.+2		;/S OR -/M
	JRST	FDINOT		;PROCEED IF NOT

	OPEN	1,FILDEV	;YES--OPEN FILE
	  JRST	FDIERF
	PUSH	P,FILBLK+3	;SAVE PPN
	LOOKUP	1,FILBLK	;LOOK IT UP
	  JRST	FDIERF
	HLRE	T,FILBLK+3	;GET LENGTH
	SKIPGE	T
	MOVNS	T
	SKIPL	FILBLK+3
	IMULI	T,^D128
	MOVEM	T,MONSIZ	;STORE AS WORDS
	POP	P,FILBLK+3	;RESTORE PPN
	SKIPE	PATCHS		;SEE IF PATCHING
	SKIPN	CRASHS		;YES--SEE IF FILE
	JRST	FDINOE		;NO--SKIP ENTER
	SETZM	FILBLK+2	;CLEAR E+2
	HLLZS	FILBLK+1	;CLEAR RH(E+1)
	ENTER	1,FILBLK	;/P AND -/M
	  JRST	FDIERF
FDINOE:	USETI	1,1		;POSITION TO START
	INPUT	1,RSILST	;READ FIRST K
	STATZ	1,740000	;CHECK FOR ERRORS
	  JRST	[OUTSTR [ASCIZ \? I/O error\]
		 HALT   .-3]
	SETOM	RSAVE		;PRESET TO FORCE ACTIVE BLOCK READ
	SKIPE	RSIDNT		;SEE IF .XPN FORMAT
	JRST	[OUTSTR  [ASCIZ /? Not in .XPN format
/]
		 JRST    DDT]

	SKIPE	SYMGET		;SEE IF /S
	PUSHJ	P,SYMFIX	;YES--GO GET THEM
	SKIPN	CRASHS		;SEE IF REASON TO HOLD OPEN
	RELEAS	1,		;NO--CLEAR FILE
	SKIPE	SYMGET		;SEE IF /S
	SKIPE	PATCHS		;SEE IF /P
	JRST	FDINOT		;CONTINUE IF /P OR -/S
	SKIPE	CRASHS		;SEE IF -/M
	JRST	DDT		;IF /S AND NOT /P OR /M, START OVER

FDINOT:	JRST	DD1		;GO START DDT
;STILL EDDT&SWFILE

EXTERN	.JBREN,.JBCOR

SYMFIX:	PUSHJ	P,SYMPTR	;GO GET SYMBOL POINTER IN T AND TT
	MOVEM	TT,FIUPTR	;SAVE JOBUSY
	HLRES	TT,TT
	MOVMS	TT,TT
	MOVEM	T,FISPTR	;SAVE IT
	HLRES	T,T
	MOVMS	T,T		;LENGTH OF SYMBOL TABLE
	SKIPN	W,SAVEFF	;PICK UP START OF SYMBOL TABLE
	MOVE	W,.JBFF		;GET FROM LOADER IF FIRST TIME
	MOVEM	W,SAVEFF	;SAVE FOR FUTURE PASSES
	ADDI	W,200		;LEAVE SPACE FOR EXTRA SYMBOL DEFNS.
	HRRZ	W1,W		;SAVE LOC FOR COPY
	ADD	W,T		;ADD TABLE LENGTH
	ADD	W,TT		;INCLUDE USY TABLE
	HRRZM	W,.JBFF		;UPDATE MONITOR TO END FOR ITS BUFFER
	HRLM	W,.JBSA		; ALLOCATION MECHANISMS
	HRLM	W,.JBCOR	;INDICATE SYMBOLS FOR SAVE
	CALLI	W,11		;GET CORE
	  JRST	[OUTSTR [ASCIZ /? Not enough core
/]
		 JRST   DDT]

	MOVE	R,FIUPTR	;GET USY POINTER
	JUMPGE	R,SYMCPY	;SKIP IF NONE
	HRRM	W1,FIUPTR
UCOPY:	PUSHJ	P,FETCH
	  JRST	ERR
	MOVEM	T,(W1)
	AOS	W1
	AOBJN	R,UCOPY

SYMCPY:	MOVE	R,FISPTR	;WHEREABOUTS OF MONITOR SYMBOLS
	HRRM	W1,FISPTR	;NOW POINT TO FILDDT SYMBOLS
	JUMPGE	R,CPOPJ		;RETURN IF NO TABLE
TCOPY:	PUSHJ	P,FETCH		;GET A WORD
	  JRST ERR
	MOVEM	T,0(W1)		;STASH IT
	AOS	W1
	AOBJN	R,TCOPY
	POPJ	P,		;RETURN TO CALLER
;STILL EDDT&SWFILE

REPEAT 0,<
THE MONITOR CAN BE LOADED IN ANY OF THREE WAYS(IN ORDER OF PREFERENCE):
	1. UNDER TIME SHARING WITH REGULAR LOADER AND COMMON
	2. UNDER SPECIAL 10/30 MONITOR(SPMON) WITH REGULAR 10/30 LOADER & COMMON
	3. UNDER SPECIAL 10/30 MONITOR(SPMON) WITH BUILD

THE 3 WAYS LEAVE XJBSYM(36),.JBSYM(116) & T30SYM(131) IN DIFFERENT STATES:

	XJBSYM          .JBSYM          T30SYM

	1.  JUNK            S.T.PTR         JUNK
	2.  JUNK            JUNK(NON-NEG)   S.T.PTR
	3.  S.T.PTR         S.T.PTR         JUNK

ALSO, MORE LIKELY, IS THAT EDDT HAS ALREADY RUN ONCE:
 	S.T.PTR		OLD S.T.PTR	JUNK
>


SYMPTR:	MOVSI	S,-LN.TRY	;PRESET TABLE FOR TRIES AT PTRS
SYMPT1:	HLRZ	R,PTRTRY(S)	;GET USY LOCATION
	MOVEI	T,0		;(IN CASE SKIP)
	JUMPE	R,SYMPT2	;JUMP IF NONE
	PUSHJ	P,FETCH		;GET IT
	  JRST	ERR
SYMPT2:	MOVE	TT,T		;SAVE AS ANSWER
	HRRZ	R,PTRTRY(S)	;GET SYM LOCATION
	PUSHJ	P,FETCH		;GET POINTER
	  JRST	ERR
	JUMPL	T,SYMPT3	;IF GOOD, CONTINUE
	AOBJN	S,SYMPT1	;ELSE LOOP
SYMPT3:	MOVE	S,PTRTRY(S)	;GOOD--PICK UP LOCATIONS
	JUMPGE	TT,SYMPT4	;MAKE SURE USY TABLE IS OK
	HLRE	W,TT		;  BY COMPARING
	MOVMS	W		;  ITS END
	ADDI	W,(TT)		;  WITH START OF SYM
	CAIE	W,(T)		;IF EQUAL, OK
SYMPT4:	MOVEI	TT,0		;NO--CLEAR USY POINTER
	POPJ	P,		;RETURN

PTRTRY:	XJBUSY,,XJBSYM		;IN CASE EDDT HAS RUN
	.JBUSY,,.JBSYM		;REGULAR LOADER RAN LAST
	0,,T30SYM		;10/30 LOADER
	XJBUSY,,XJBSYM		;BUILD OR JUNK
LN.TRY==.-PTRTRY

>	;END EDDT&SWFILE
DD1:	PUSHJ	P,CRF
DD1.5:	TLZ	F,ROF		;CLOSE ANY OPEN REGISTER
	MOVE	T,[XWD SCHM,SCH]
	BLT	T,ODF		;LOAD ACS
DD2:	SETZM	IBTAKR		;CLEAR TYPEIN BUFFER TAKER PTR
DD2.5:	MOVE	T,[POINT 7,TINBUF] ;RESET INPUT BUFFER PUTTER PTR
	MOVEM	T,IBPUTR
	CLEARM	PRNC		;PARENTHESES COUNT
	MOVEI	P,PS
LIS:	MOVE	T,@USYMP	;GET UNDEF SYMBOL POINTER
	JUMPL	T,LIS0B		;IF POINTER OK, TRANSFER
	SKIPGE	T,@SYMP		;IF POINTER NOT OK, USE .JBSYM ADR
	JRST	LIS0A		; SO LONG AS IT IS NEGATIVE
IFE	EDDT&SWFILE,<
	MOVEI	R,400000+.JBHSM	;IF LO ADR NOT OK, TRY HIGH
IFN EDDT&SWEXEC,<SKPEXC>		; UNLESS IN EXEC MODE
	PUSHJ	P,FETCH		;GET HIGH SYM TABLE POINTER>
	 MOVEI T,0		;IT DOESN'T EXIST
	JUMPG	T,.-1		;IF POINTER .G. 0, GIVE 0 RESULT
LIS0A:	HRRZS	T		;USE ADR OF SYM TABLE TO INIT
	MOVEM	T,@USYMP	;  UNDEFINED SYM TABLE POINTER
LIS0B:	MOVEM	T,ESTUT		;INIT UNDEFINED SYM ASSEMBLER
	TDZ	F,[XWD 777777-ROF-STF,SBF+2+Q2F]
LIS0:	TDZ	F,[XWD 777777-ROF-STF-FAF-SAF,NAF]
	CLEARM,WRD
LIS1:	CLEARM,FRASE
LIS2:	MOVEI	T,1
	MOVEM	T,FRASE1
	TLZ	F,MLF+DVF
L1:	TLZ	F,CF+CCF+SF+FPF	;TURN OFF CONTROL, SYL, PERIOD FLAG
L1A:	CLEARM,SYL
L1RPR:	CLEARM,SYM
	MOVEI	T,6
	MOVEM	T,TEM		;INIT SYMBOL COUNTER
	MOVE	T,[POINT 7,TXT]
	MOVEM	T,CHP		;SETUP FOR OPEVAL SYMBOL
	CLEARM,DEN
	CLEARM,WRD2
L2:	PUSHJ	P,TIN		;PICK UP CHARACTER
	CAIL	T,"A"+40	;LOWER CASE A
	CAILE	T,"Z"+40	;LOWER CASE Z
	JRST	.+2
	TRC	T,40		;CHANGE LOWER CASE TO UPPER CASE
	TLNE	F,CF		;CONTROL FLAG
	JRST	L21
	CAIG	T,"Z"		;Z
	CAIGE	T,"A"		;A
	JRST	.+2
	JRST	LET
L21:	MOVE	R,T
	CAILE	T,137		;DISPATCH TABLE HAS ENTRIES ONLY .LE. 137
	JRST	ERR
	IDIVI	R,3		;REMAINDER GIVES COLUMN, QUOTIENT GIVES ROW
	LDB	W,BDISP(R+1)	;GET 12 BIT ADDRESS FROM DISPATCH TABLE
	CAIGE	W,MULT-DDTOFS	;FIRST EVAL ROUTINE
	JRST	DDTOFS(W)
	MOVE	T,SYL
	TLZN	F,LTF
	JRST	POWER
	CAIN	W,SPACE-DDTOFS	;IS TERMINATOR A SPACE?
	SKIPE	WRD		;IS CONSTRUCTED WORD SO FAR ZERO?
	SKIPA	T,[OPEVAL,,EVAL]	;SEARCH EVAL 1ST IFF: -SPACE .OR. (WRD).NE.0
	MOVS	T,[OPEVAL,,EVAL]	;SEARCH OPEVAL 1ST IFF: SPACE .AND. (WRD)=0
	MOVEM	T,SYMORD	;SAVE SYMBOL TABLE SEARCH ORDER
	JRST	L213

L212:	HLRZS	T,SYMORD	;GET ADDRESS OF THE OTHER LOOKUP ROUTINE
	JUMPE	T,UND1		;IF ADR=0, THEN SYMBOL UNDEFINED
L213:	PUSHJ	P,(T)		;CALL OPEVAL OR EVAL
	 JRST L212		;SYMBOL NOT FOUND
	CAIN	W,ASSEM-DDTOFS	;DEFINED SYMBOL FOLLOWED BY #?
	JRST	ERR		;IF DEFINED, DON'T ALLOW #
L4:	TLZE	F,MF
	MOVN	T,T
	TLNN	F,SF
	CAIE	W,LPRN-DDTOFS
	JRST	.+2
	JRST	LPRN

	EXCH	T,FRASE1
	TLNN	F,DVF
	IMULB	T,FRASE1
	TLZE	F,DVF
	IDIVB	T,FRASE1
	CAIGE	W,ASSEM-DDTOFS
	JRST	DDTOFS(W)	;MULTIPLY OR DIVIDE
	ADDB	T,FRASE
	CAIGE	W,SPACE-DDTOFS
	JRST	DDTOFS(W)	; + - @ ,

	ADD	T,WRD
	TLNE	F,TIF		;TRUNCATE INDICATOR FLAG
	HLL	T,WRD		;TRUNCATE
	MOVEM	T,WRD
	TLNN	F,QF
	MOVE	T,LWT
	CLEARM,R
	MOVE	W1,ESTUT
	CAMN	W1,@USYMP	;IF THERE ARE ANY UNDEFINED SYMBOLS IN
	JRST	L5		;THE CURRENT EXPRESSION, ANYTHING EXCEPT
	CAILE	W,CARR-DDTOFS	;FURTHER EXPRESSION INPUT, OR DEPOSITING
	JRST	ERR		;  INTO MEMORY IS ILLEGAL
L5:	CAIG	W,RPRN-DDTOFS
	JRST	DDTOFS(W)
	PUSH	P,KILRET	;WHEN INSIDE ( ), CURRENT EXPRESSION
	SKIPN	PRNC		;INVALID FOR ANYTHING OTHER
	JRST	DDTOFS(W)	;  THAN MORE EXPRESSION INPUT



ERR:	MOVEI	W1,"?"
	JRST	WRONG1
UNDEF:	MOVEI	W1,"U"
	JRST	WRONG1
WRONG:	MOVE	W1,[ASCII /XXX/]
WRONG1:	MOVEI	P,PS
	PUSHJ	P,TEXT
	PUSHJ	P,LCT		;TYPE TAB
	PUSHJ	P,LISTEN	;GOBBLE ANY INPUT CHARACTER
	JFCL
	JRST	DD2
RET:	MOVEI	P,PS
	PUSHJ	P,LCT		;COMMON RETURN FOR TAB;,JRST LIS
	JRST	DD2


UND1:	MOVE	R,ESTUT		;UNDEFINED SYM ASSEMBLER
	JUMPE	R,UNDEF		;UNDEFINED IF NO UNDEF SYM TABLE
	HLRE	S,ESTUT
	ASH	S,-1		;SETUP EVAL END TEST
	PUSHJ	P,EVAL2
	CAIN	W,ASSEM-DDTOFS
	TLNN	F,ROF
	JRST	UNDEF
	SKIPE	PRNC
	JRST	UNDEF
	MOVEI	T,"#"
	CAIE	W,ASSEM-DDTOFS
	PUSHJ	P,TOUTQ		;PRINT # IF NOT RESCANNING INPUT

	MOVN	R,[XWD 2,2]
	ADDB	R,ESTUT
	MOVE	T,SYM
	TLO	T,GLOBAL
	PUSHJ	P,DSYMER	;DEPOSIT AND TYPE ? IF IT FAILS
	HRRZ	T,LLOCO
	TLNE	F,MF
	TLO	T,(STNEG)	;SET FLAG TO SHOW SUBTRACTIVE REQUEST
	TLO	T,(STADD)	;SET FLAG TO SHOW UNCHAINED REQUEST
	ADDI	R,1
	PUSHJ	P,DSYMER
	MOVEI	T,0
	JRST	L4
QUESTN:	PUSHJ	P,CRF		;HERE FOR "?"
	TLNE	F,LTF		;HAS A SYMBOL BEEN TYPED?
	JRST	QLIST		;NO
	MOVE	R,@USYMP	;YES, LIST UNDEFINED SYMBOLS
QUEST1:	JUMPGE	R,DD1
	MOVE	T, (R)
	SKIPA	W1,@USYMP

QUEST2:	ADD	W1,[XWD 2,2]
	CAME	T,(W1)
	JRST	QUEST2
	CAME	R,W1
	JRST	QUEST4
	PUSHJ	P,SPT
	PUSHJ	P,CRF
QUEST4:	ADD	R,[XWD 2,2]
	JRST	QUEST1

QLIST:	PUSHJ	P,SYMSET	;LIST REFERENCES TO THE SYMBOL
QLIST1:	SETZM	QLPNT		;ZERO FLAG SHOWING REFERENCE
QLIST2:	MOVE	T,(R)		;PICK UP SYMBOL
	TLZN	T,PNAME		;A PROGRAM NAME?
	JRST	QLIST6		;YES
	CAMN	T,SYM		;NO, IS AN OCCURANCE FOUND?
	HRRZM	R,QLPNT		;YES, REMEMBER WHERE
QLIST3:	AOBJN	R,.+1		;LOOK THRU TABLE
	AOBJN	R,QLIST4	;END OF TABLE SEGMENT?
IFE	EDDT&SWFILE,<
	TRNN	R,1B18		;YES, WRAP AROUND
	SKIPL	R,SAVHSM
>
	MOVE	R,@SYMP
QLIST4:	AOJLE	S,QLIST2	;THRU SEARCHING?
	JRST	DD1		;YES

QLIST6:	SKIPN	QLPNT		;FOUND THE SYMBOL?
	JRST	QLIST3		;NO
	PUSHJ	P,SPT1		;YES, PRINT THE PROGRAM NAME
	MOVE	T,@QLPNT	;GET THE SYMBOL BACK AND
	TLNN	T,GLOBAL	; TEST FOR A GLOBAL SYMBOL
	JRST	QLIST7		;NOT GLOBAL
	PUSHJ	P,TSPC		;IS GLOBAL, TYPE " G"
	MOVEI	T,"G"
	PUSHJ	P,TOUT
QLIST7:	PUSHJ	P,CRF
	SETZM	QLPNT		;RESET FLAG
	JRST	QLIST3		; AND SEARCH THE NEXT SET OF SYMBOLS
NUM:	ANDI	T,17		;T HOLDS CHARACTER
	TLNE	F,CF+FPF
	JRST	NM1
	MOVE	W,SYL
	LSH	W,3
	ADD	W,T
	MOVEM	W,SYL
	MOVE	W,DEN
	IMULI	W,12		;CONVERT TO DECIMAL
	ADD	W,T
	MOVEM	W,DEN
	AOJA	T,LE1A

DOLLAR:	SKIPA	T,[46+101-13]	;RADIX 50 $ TO BE
PERC:	MOVEI	T,47+101-13	;PERCENT SIGN
LET:	TLC	F,SF+FPF	;EXPONENT IFF LTF'*FEF'*(T=105)*SF*FPF=1
	TLZN	F,LTF+FEF+SF+FPF
	CAIE	T,105		; E
	TLOA	F,LTF
	TLOA	F,FEF
	JRST	LET1
	TLZN	F,MF
	SKIPA	W1,SYL
	MOVN	W1,SYL
	MOVEM	W1,FSV
	CLEARM	DEN
LET1:	SUBI	T,101-13	;FORM RADIX 50 SYMBOL
LE1A:	TLO	F,SF+QF
LE2:	SOSGE	TEM		;IGNORE CHARACS AFTER 6
	JRST	L2
	MOVEI	W,50
	IMULM	W,SYM		;MULTIPLY BY RADIX 50
	ADDM	T,SYM		;  AND ADD NEW CHAR INTO SYM
	MOVEI	T,"A"-13(T)	;CONVERT LETTERS BACK TO ASCII
	IDPB	T,CHP
	JRST	L2
NUM1:	EXCH	T,WRD2		;FORM NUMBER AFTER $
	IMULI	T,12
	ADDM	T,WRD2
	TRO	F,Q2F
	JRST	L2

NM1:	TLNE	F,CF
	JRST	NUM1
	MOVEI	W1,6		;FORM FLOATING POINT NUMBER
	AOS	NM1A
NM1A:	MOVEI	W2,0
	MOVSI	R,201400
NM1A1:	TRZE	W2,1
	FMPR	R,FT(W1)
	JUMPE	W2,NM1B
	LSH	W2,-1
	SOJG	W1,NM1A1
NM1B:	MOVSI	W1,211000(T)
	FMPR	R,W1		;COMPUTE VALUE OF NEW DIGIT
	FADRB	R,FH		;ADD VALUE INTO FLOATING NO.
	MOVEM	R,SYL
	AOJA	T,LE1A

POWER:	TLNN	F,FEF
	JRST	L4		;NO EXPONENT
	CAIE	W,PLUS
	CAIN	W,MINUS
	TROE	F,POWF
	TRZA	F,POWF
	JRST	(W)		; E+-

	MOVE	W2,DEN
	CLEARM	FRASE
	MOVEI	W1,FT-1
	TLZE	F,MF
	MOVEI	W1,FT01
	SKIPA	T,FSV
POW2:	LSH	W2,-1
	TRZE	W2,1
	FMPR	T,(W1)
	JUMPE	W2,L4
	SOJA	W1,POW2
PERIOD:	MOVE	T,LLOC
	TLNE	F,SF		;SYLLABLE STARTED
	MOVE	T,DEN
	MOVEM	T,SYL
	TLNE	F,FPF		;HAS A PERIOD BEEN SEEN BEFORE?
	TLO	F,LTF		;YES, TWO PERIODS MAKES A SYMBOL
	TLON	F,FPF+SF+QF
	MOVEI	T,0
	IDIVI	T,400
	SKIPE	T
	TLC	T,243000
	TLC	W1,233000
	FAD	T,[0]		;NORMALIZE T AND W1
	FAD	W1,[0]
	FADR	T,W1
	MOVEM	T,FH
	HLLZS	NM1A
	MOVEI	T,45		;RADIX 50 PERIOD
	JRST	LE2

IFE	EDDT&SWFILE,<
PILOC:	MOVEI	T,SAVPI		;GET ADDRESS FOR $I>
QUANIN:;TLO	T,(DDTINT)	;(FUTURE) FLAG DDT INTERNAL REGISTERS
	JRST	QUAN1

QUAN:	TLNN	F,CCF		;$Q OR $$Q, WHICH?
	SKIPA	T,LWT		;$Q STRAIGHT
QUANSW:	MOVS	T,LWT		;$$Q SWAPPED (ALSO FOR $V)
QUAN1:	MOVEM	T,SYL
QUAN2:	TLO	F,SF+QF		;WRD,SYL STARTED
	TLZ	F,CF+CCF
	JRST	L2

CONTRO:				;SOME KIND OF ALTMODE
IFN EDDT&SWEXEC,<	MOVEI T,"$"	;$
	SKPUSR
	PUSHJ	P,TOUTQ		;TYPE OUT $
>
	TLOE	F,CF
	TLO	F,CCF
	JRST	L2

IFN	EDDT&SWFILE,<PILOC==ERR>
SUBTTL SYMBOL TABLE LOGIC
;SYMBOL EVALUATION ROUTINE

EVAL:	PUSHJ	P,SYMSET	;SET UP SYM TABLE POINTER AND COUNT
EVAL2:	TRZ	F,PNAMEF!MDLCLF	;CLEAR FLAGS FOR EVAL
	SETZM	SYMPNT		;CLEAR LOCAL SYM POINTER
	JUMPE	S,CPOPJ		;XFER IF SYM TABLE EMPTY
	JUMPGE	R,CPOPJ		;XFER IF POINTER NOT VALID

EVAL3:	MOVE	T,(R)		;GET SYM FROM SYM TABLE
	TLZN	T,PNAME		;PROGRAM NAME? ALSO CLEAR THE FLAGS
	JRST	[JUMPE T,EVAL4	;YES, IGNORE IF SYMBOL IS NULL
		TRO F,PNAMEF	;SET PROGRAM NAME FLAG-MCO#D-533
		JRST .+1]
	CAMN	T,SYM		;SYMBOL MATCH?
	JRST	EVAL6		;YES
EVAL4:	AOBJN	R,.+1		;NO VALID MATCH, CONTINUE LOOKING
	AOBJN	R,EVAL4A	;POINTER EXPIRED?
IFE	EDDT&SWFILE,<
	TRNN	R,1B18		;TEST FOR HIGH SEGMENT SYM TABLE
	SKIPL	R,SAVHSM	;WAS LOW SEG, GET HIGH SEG POINTER, IF ANY
>
	MOVE	R,@SYMP		;WRAP AROUND TO LOW SEG END OF TABLE
EVAL4A:	AOJLE	S,EVAL3		;TRANSFER IF ANY SYMBOLS LEFT

	SKIPE	R,SYMPNT	;SEARCH FINISHED, ANY LOCAL SYMS OUTSIDE
				;CURRENT PROGRAM AREA?
	TRNE	F,MDLCLF	;YES, WITH A UNIQUE VALUE?
	POPJ	P,		;NO, SEARCH FAILS
EVAL5:	SKIPA	T,1(R)		;GET VALUE OF SYMBOL
CPOPJ2:	AOS	(P)		;SKIP TWICE
CPOPJ1:	AOS	(P)		;FOUND SYMBOL, SKIP
CPOPJ:	POPJ	P,

EVAL6:	MOVE	T,(R)		;SYM MATCHES, GET FLAGS BACK
	TLNE	T,DELI		;IS SYMBOL DELETED FOR INPUT?
	JRST	EVAL4		;YES
	TLNN	T,GLOBAL	;GLOBAL SYMS VALID ANYWHERE
	TRNN	F,PNAMEF	;HAS SECOND PROGRAM TABLE BEEN STARTED?
	JRST	EVAL5		;LOCALS ALWAYS VALID IN CURRENT PROGRAM
	SKIPN	T,SYMPNT	;LOCAL OUTSIDE OF CURRENT PROGRAM
	JRST	EVAL7		;YES, AND THE 1ST ONE OF THEM
	MOVE	T,1(T)		;GET VALUE OF PREVIOUS LOCAL
	CAME	T,1(R)		;IS IT THE SAME VALUE?
	TRO	F,MDLCLF	;NO, MULTIPLY DEFINED
EVAL7:	MOVEM	R,SYMPNT	;SAVE POINTER TO THIS LOCAL
	JRST	EVAL4		;CONTINUE LOOKING FOR GLOBALS

;BIT 40 - DELETE OUTPUT
; 20 - DELETE INPUT
; 10 - LOCAL
; 04 -GLOBAL
; NO BITS - PROGRAM NAME
;SYMBOL TABLE POINTER AND COUNT SET UP ROUTINE

SYMSET:	IFE	EDDT&SWFILE,<
	MOVEI	R,400000+.JBHSM	;TRY TO GET HIGH SEG SYM TABLE POINTER
IFN EDDT&SWEXEC,<SKPEXC>		;NO HI SYM TABLE POINTER IN EXEC MODE
	PUSHJ	P,FETCH
	 MOVEI T,0		;NO HIGH SEGMENT
	MOVEM	T,SAVHSM	;SAVE HIGH SEG POINTER (OR 0)
	>
	HLLZ	S,@SYMP		;GET WORD COUNT FOR LOW SEG TABLE
IFE	EDDT&SWFILE,<
	SKIPGE	T		;IF .JBHSM .GT. 0, INVALID
	ADD	S,T		;ADD WORD COUNT FOR HIGH SEG TABLE
>
	ASH	S,-^D19		;PUSH TO RIGHT HALF AND DIVIDE BY 2
	SKIPL	T,PRGM		;GET $: POINTER, GOOD ONLY IF .LT. 0
	JRST	SYMS4		;NOT GOOD, USE .JBSYM
IFE	EDDT&SWFILE,<
	TRNE	T,1B18		;POINTER FROM .JBSYM OR .JBHSM?
	JRST	[MOVE R,SEGNAM	;.JBHSM. DOES SEGMENT NAME MATCH?
		SKIPGE T,SAVHSM	; AND ALSO GOOD .JBHSM?
		CAME R,400000+.JBHNM
		JRST SYMS4	;NO .JBHSM OR HI SEG NAME MISMATCH
		JRST SYMS2]
>
	SKIPL	T,@SYMP		;PRGM CAME FROM .JBSYM
	JRST	SYMS5		;.JBSYM POINTER INVALID
SYMS2:	HLRE	R,T		;GET NEGATIVE LENGTH
	SUB	T,R		;GET LAST ADR OF TABLE
	MOVS	R,PRGM		;GET NEG. LENGTH FOR $: POINTER
	ADD	R,T		; AND CALCULATE STARTING ADR
	HLL	R,PRGM		; AND SET UP TABLE LENGTH
	JUMPL	R,CPOPJ		;NO, POINTER IS OK AS LONG AS IT IS .LT. 0
SYMS4:	SKIPL	R,@SYMP		;SET UP POINTER INTO LOW SEG TABLE
SYMS5:	IFE	EDDT&SWFILE,<
	MOVE	R,SAVHSM	;LOW SEG POINTER BAD, TRY HI SEG
	>
IFN	EDDT&SWFILE,<
	MOVEI	R,0
>
	POPJ	P,
SETNAM:	SKIPGE	R,@SYMP		;LOOK UP PROGRAM NAME FOR $:
	PUSHJ	P,SETSUB	;SEARCH LO SEG SYM TABLE
	JUMPL	R,SETN2		;XFER IF NAME FOUND
IFE	EDDT&SWFILE,<
	MOVEI	R,400000+.JBHSM
IFN EDDT&SWEXEC,<SKPEXC>	;NO HI SYM TABLE POINTER IN EXEC MODE
	PUSHJ	P,FETCH		;GET .JBHSM
	 JRST UNDEF		;NO HI SEG, NAME$: UNDEFINED
	SKIPGE	R,T		;IS HI SEG POINTER GOOD?
	PUSHJ	P,SETSUB	;YES, LOOK THRU HI SYM TABLE
>
	JUMPGE	R,UNDEF		;UNDEFINED IF NOT IN HI SEG
IFE EDDT&SWFILE,<
	HRRI	W,1B18		;SET FLAG SHOWING HI SEGMENT
	MOVEI	R,400000+.JBHNM	;GET ADR OF HI SEG PROGRAM NAME
IFN EDDT&SWEXEC,<SKPEXC>
	PUSHJ	P,FETCH		;  AND GO GET THE NAME
	 MOVEI	T,0		;NO HI SEG NAME, OR EXEC MODE
	MOVEM	T,SEGNAM >	;SAVE HI SEG NAME
SETN2:	MOVEM	W,PRGM		;SAVE -WC IN LH, HISEG=1 FLAG IN RH
	JRST	RET		;DONE, THANK YOU

		;SUBROUTINE TO SEARCH A SYM TABLE FOR A PROGRAM NAME
SETSB1:	MOVE	T,(R)		;ENTRY POINT IS "SETSUB"
	CAMN	T,SYM		;MATCH FOR PROGRAM NAME?
	POPJ	P,		;YES, RETURN WITH "ANSWER" IN W
	ADD	R,[2,,2]	;GO TO NEXT ENTRY
	TLNN	T,PNAME		;WAS LAST ENTRY A PROG NAME?
SETSUB:	HLLZ	W,R		;(ENTRY POINT) YES, SAVE POINTER TO HERE
	JUMPL	R,SETSB1	;XFER IF ANY SYMBOLS LEFT
	POPJ	P,		;SEARCH FAILED, RETURN
KILL:	TLNN	F,LTF		;DELETE SYMBOLS
	JRST	ERR
	PUSHJ	P,EVAL
	JRST	KILL1
	MOVE	T,(R)		;GET SYM WITH FLAGS
	TLO	T,DELO		;ASSUME DELETE OUTPUT
	TLNE	F,CCF		;$$K?
	MOVSI	T,DELO!DELI!37777	;MAKE SYM IMPOSSIBLE LOCAL, DELETED IN AND OUT
	PUSHJ	P,DSYMER	;DEPOSIT IF LEGAL, ELSE ?
KILRET:	JRST	RET		;USED AS A CONSTANT


KILL1:	SKIPL	R,@USYMP	;REMOVE UNDEFINED SYMS
	JRST	UNDEF
KILL1A:	HLRE	S,R		;GET LENGTH OF UNDEFINED TABLE, AND
	ASH	S,-1		;DIVIDE BY 2 TO GET # OF ENTRIES
IFE	EDDT&SWFILE,<
	SETZM	SAVHSM		;LOOK ONLY IN LOW SEG
>
KILL2:	PUSHJ	P,EVAL2
	JRST	RET
REPEAT 0,<		;IF ASSEMBLED OUT, DON'T ZERO CHAINED ADDRESSES
	PUSH	P,R
	SKIPL	R,1(R)		;CHAINED REQUEST?
	JRST	KILL4		;YES
KILL3:	POP	P,R	>
	PUSHJ	P,REMUN
	MOVE	R,@USYMP	;START TABLE SEARCH OVER
	JRST	KILL1A

REPEAT 0,<		;IF ASSEMBLED OUT, DON'T ZERO CHAINED ADDRESSES
KILL4A:	SKIPE	R,S		;GET CHAIN ADR, STOP IF 0
KILL4:	PUSHJ	P,FETCH		;GET NEXT ADR OF CHAIN
	 JRST KILL3		;FAILED, QUIT SEARCHING LIST
	HRRZ	S,T		;SAVE CHAIN POINTER
	HLLZS	T		;GET RID OF CHAIN ADDRESS, AND
	PUSHJ	P,DEPMEM	;  DEPOSIT BACK INTO MEMORY
	 JFCL			;IGNORE IF WRITE LOCKED SEG
	JRST	KILL4A	>

REMUN:	MOVE	S,@USYMP	;REMOVE ONE UNDEFINED SYMBOL
	MOVE	T,(S)		;MOVE SYMBOL 2 LOCATIONS
	PUSHJ	P,DSYMER
	MOVE	T,1(S)
	ADDI	R,1
	PUSHJ	P,DSYMER
	SUBI	R,1
	MOVE	S,[2,,2]
	ADDB	S,@USYMP
	POPJ	P,
TAG:	TLNN	F,LTF		; NO LETTERS IS ERROR
	JRST	ERR		; GO SAY ERROR
	TLNE	F,FAF		; DEFINE SYMBOLS
	JRST	DEFIN		;A.LT.B:
	TLNE	F,CF		;DEFINE SYMBOL AS OPEN REGISTER
	JRST	SETNAM
	MOVE	W,LLOCO
	HRRZM	W,DEFV

DEFIN:	PUSHJ	P,EVAL		;DEFINED SYMBOL?
	JRST	DEF1		;NO - DEFINE
	MOVE	T,0(R)		;YES, GET FLAGS FOR SYMBOL TYPE
	TLNE	T,PNAME		;PROGRAM NAME?
	JRST	DEF2		;NO, REDEFINE SYMBOL

DEF1:	SKIPL	R,@SYMP		;DEFINE A NEW SYMBOL
IFE	EDDT&SWFILE,<
	JRST	[MOVEI R,400000+.JBHSM
		IFN EDDT&SWEXEC,<SKPEXC> ;NO HI SYM POINTER IN EXEC MODE
		PUSHJ P,FETCH	;GET HI SEG SYM POINTER
		 JRST ERR	;THERE IS NO SYM POINTER ANYWHERE
		SUB T,[2,,2]	;MAKE ROOM FOR ANOTHER ENTRY
		PUSHJ P,DSYMER	; AND STORE IT BACK
		MOVE R,T
		JRST DEF1A]
>
IFN	EDDT&SWFILE,<
	JRST	ERR
>
	SUB	R,[2,,2]
	MOVEM	R,@SYMP		;DECREMENT LO SEG SYM POINTER
DEF1A:	SKIPL	@USYMP		;DOES AN UNDEFINED TABLE EXIST?
	JRST	DEF2		;NO
	MOVE	S,R
	SOS	R,@USYMP	;MOVE HI NUMBERED ENTRY ON UNDEFINED
	MOVE	T,1(S)		;  TABLE TO LOW END
	PUSHJ	P,DSYMER
	SOS	R,@USYMP	;SAME FOR SECOND WORD
	MOVE	T,(S)
	PUSHJ	P,DSYMER
	MOVE	R,S		;GET DEFINED SYM POINTER BACK
DEF2:	MOVSI	T,GLOBAL
	IORB	T,SYM
	PUSHJ	P,DSYMER
	MOVE	T,DEFV
	MOVEI	R,1(R)
	PUSHJ	P,DSYMER
	MOVE	R,@USYMP
DEF3:	JUMPGE	R,RET		;PATCH IN VALUE FOR UNDEF SYM ENTRY
	MOVE	T,SYM
	TLO	T,GLOBAL	;UNDEFINED TABLE HAS GLOBAL ENTRIES
	CAME	T,(R)
	JRST	DEF4
	PUSH	P,R		;SAVE POINTER INTO UNDEF TABLE
	SKIPL	R,1(R)		;IS ENTRY AN ADDITIVE REQUEST?
	JRST	DEF7		;NO, CHAINED IN RIGHT HALF
	PUSHJ	P,FETCH		;GET OBJECT CELL
	 JRST ERR
	TLNN	R,(STNEG)	;ADDITIVE OR SUBTRACTIVE?
	SKIPA	S,DEFV		;ADDITIVE
	MOVN	S,DEFV		;SUBTRACTIVE
	TLNE	R,(STLH)	;RIGHT OR LEFT HALF?
	JRST	[HRLZS S	;LEFT HALF
		ADD T,S		;ADD INTO LEFT HALF
		JRST DEF5]
	ADD	S,T		;RIGHT HALF, ADD HALVES
	HRR	T,S		;  AND REPLACE RIGHT HALF
DEF5:	PUSHJ	P,DMEMER	;STORE RESULT BACK INTO MEMORY
DEF6:	POP	P,R		;GET UNDEF TABLE POINTER BACK
	PUSHJ	P,REMUN
DEF4:	ADD	R,[XWD 2,2]	;REMOVE THE NOW DEFINED SYMBOL
	JRST	DEF3

DEF7:	JUMPE	R,DEF6		;JUMP IF ALL DONE
	PUSHJ	P,FETCH		;GET OBJECT CELL
	 JRST ERR
	HRRZ	S,T		;SAVE CHAIN POINTER
	HRR	T,DEFV		;REPLACE WITH NEW VALUE
	PUSHJ	P,DMEMER	; AND STORE BACK INTO MEMORY
	HRRZ	R,S		;LOOP TO END
	JRST	DEF7		;  OF CHAIN
SUBTTL

TEXI:	PUSHJ	P,TEXIN		;INPUT TEXT
	TLNE	F,CF		;$ IMPLIES SIXBIT INPUT
	PUSHJ	P,CONV6		;CONVERT TO SIXBIT
	MOVEM	T,SYL
	MOVEI	W1,5
	MOVEI	T-1,0
	PUSHJ	P,TEXIN
	CAIN	T,33		;NEW ALT MODE, ESCAPE
	JRST	QUAN2
	TLNE	F,CF
	JRST	SIXBIN
	SKIPA
TEXI2:	PUSHJ	P,TEXIN
	CAMN	T,SYL
	SOJA	W1,TEXI3
	ROT	T,-7
	LSHC	T-1,7
	SOJA	W1,TEXI2

TEXI3:	LSHC	T-1,-43
	JUMPL	W1,QUAN1
	LSH	T,7
	SOJA	W1,.-2

SIXBI1:	PUSHJ	P,TEXIN		; INPUT TEXT (SIXBIT)
SIXBIN:	PUSHJ	P,CONV6		;CONVERT TO SIXBIT
	CAMN	T,SYL
	JRST	SIXBI2
	ROT	T,-6
	LSHC	T-1,6
	SOJA	W1,SIXBI1
SIXBI2:	MOVE	T,T-1
	JUMPL	W1,QUAN1
	LSH	T,6
	SOJA	W1,.-2

CONV6:	CAIL	T,"A"+40	;IS CHAR BETWEEN LOWER CASE "A" AND
	CAILE	T,"Z"+40	; LOWER CASE "Z"?
	SKIPA			;NO
	TRC	T,40		;YES, CONVERT TO UPPER CASE
	CAIL	T," "		;IS CHAR IN SIXBIT SET?
	CAILE	T,"_"
	JRST	ERR		;NO
	ANDI	T,77		;YES, MASK TO 6 BITS
	TRC	T,40		;CONVERT TO SIXBIT FORM
	POPJ	P,
;***ROUTINES BEYOND HERE EVALUATE THEIR ARGUMENT***
MULT:	TLOA	F,PTF+MLF	;*
DIVD:	TLO	F,DVF+PTF	;SINGLE QUOTE
	JRST	L1

ASSEM:	JRST	PLUS		;#
MINUS:	TLO	F,MF
PLUS:	TLO	F,PTF
	JRST	LIS2

LPRN:	CAML	P,[XWD LPDL-4,0]	;LEFT PARENTHESIS
	JRST	ERR
	PUSH	P,F		;RECURSE FOR OPEN PAREN
	PUSH	P,WRD
	PUSH	P,FRASE
	PUSH	P,FRASE1
	AOS,PRNC
	JRST	LIS

INDIRE:	HRLZI	W,20		;@
	IORB	W,WRD
	TLO	F,QF
	JRST	LIS2

ACCF:	MOVE	R,T		;COMMA PROCESSOR
ACCCF:	MOVEI	T,.-.		;LEFT HALF OF A,,B
	TLOE	F,COMF		;COMMA TYPED BEFORE?
	JRST	ACCF1		;YES
	HRRM	R,ACCCF		;NO, SAVE LEFT HALF OF A,,B
	HLLZ	T,R
	LSH	R,^D24		;SHIFT TO B11 AS FOR I/O INSTRUCTION
	LDB	W1,[POINT 9,WRD,8] ;FETCH OPCODE
IFN EDDT&SWMAXC,<
	CAIGE	W1,JMCMIN	;TEST FOR JMC INSTRUCTION
>
	CAIGE	W1,700		;SKIP IF I/O INSTRUCTION
	LSH	R,-1		;SHIFT AC TO B12 FOR NON-I/O INSTRUCTION
	ADD	T,R
	ADDB	T,WRD
	JRST	SPAC1

ACCF1:	ADD	T,WRD		; FOR ",," GET LEFT HALF TOGETHER
	HRLZM	T,WRD		; AND PUT IT IN LEFT HALF
	JRST	SPAC1

SPACE:	TLNE	F,QF
SPAC1:	TLO	F,TIF
	TLZ	F,MF+PTF
	JRST	LIS1
RPRN:	TLNN	F,QF		;)
	MOVEI	T,0
	MOVS	T,T
	SOSGE,PRNC
	JRST	ERR
	POP	P,FRASE1
	POP	P,FRASE
	POP	P,WRD
	POP	P,F
	TLNE	F,PTF
	TLNE	F,SF
	JRST	RPRN1
	MOVEM	T,SYL
	TLO	F,QF+SF
	JRST	L1RPR
RPRN1:	ADDB	T,WRD
	TLO	F,QF
	JRST	L1A
SUBTTL REGISTER EXAMINATION LOGIC

LINEF:	PUSHJ	P,DEPRA		;NEXT REGISTER
IFN EDDT&SWEXEC,<SKPUSR
	JRST	LI0		;NO CARRIAGE RETURN IF EXEC MODE	>
	PUSHJ	P,CRNRB		;TYPE CARRIAGE RETURN-RUBOUT	MCO #D-626
	JRST	.+2
LI0:	PUSHJ	P,CRF
	AOS	T,LLOC
LI1:		;PUSHJ P,LINCHK		;TRUNCATE ADRS (UNLESS INSIDE DDT)
	HRRZM	T,LLOC
	HRRZM	T,LLOCO
	PUSHJ	P,PAD
	MOVEI	T,"/"
	TRNN	F,LF1			;EITHER SQUARE TYPE OUTPUT?
	 JRST	LII2			;NO
	MOVEI	T,"["			;YES-ASSUME NONSYMBOLIC
	TRNN	F,CF1			;SYMBOLIC?
	 MOVEI	T,"]"			;YES
LII2:	TLNE	F,STF
	MOVEI	T,"!"
	PUSHJ	P,TOUT
LI2:	TLZ	F,ROF
	PUSHJ	P,LCT
	MOVE	R,LLOCO
	PUSHJ	P,FETCH
	JRST	ERR
	TLO	F,ROF
	TLNE	F,STF
	JRST	DD2
	JRST	CONSYM		;RETURN IS A POPJ

REPEAT 0,<
LINCHK:	CAML	T,[DDTINT SAVPI]	;TRUNCATE ADDRESSES
	CAMLE	T,[DDTINT BNADR+2]
	HRRZS	T
	MOVEM	T,LLOC
	MOVEM	T,LLOCO
	POPJ	P,
>

VARRW:	PUSHJ	P,DEPRA		;^
	PUSHJ	P,CRF
	SOS	T,LLOC
	JRST	LI1

CARR:	PUSHJ	P,DEPRA		;CLOSE REGISTER
IFN EDDT&SWEXEC,<	SKPUSR
	JRST	DD1		;NO NEED TO FLUSH CR IN EXEC MODE >
IFN EDDT&SW10X,<
	JRST DD1.5		;TENEX HAS ECHOED CRLF, WONT INPUT LF.
>
IFE EDDT&SW10X,<
	PUSHJ	P,TIN
	CAIN	T,15
	JRST	.-2
	JRST	DD1.5
>

OCON:	TROA	F,CF1		;OPEN AS CONSTANT
OSYM:	TRZ	F,CF1		;OPEN SYMBOLICALLY
	TRO	F,LF1
	TLZ	F,STF
	JRST SLASH1

SUPTYO:	TLOA	F,STF		;SUPPRESS TYPEOUT
SLASH:	TLZ	F,STF		;TYPE OUT REGISTER
	TRZ	F,LF1+CF1	;CLEAR LINEFEED FLAGS
SLASH1:	TLNN	F,QF		;WAS ANY QUANTITY TYPED?
	JRST	SLAS1		;NO. DO NOT CHANGE MAIN SEQUENCE
	MOVE	R,LLOC		;YES. SAVE OLD SEQUENCE AND
	MOVEM	R,SAVLOC
	HRRZM	T,LLOC		;PUSHJ P,LINCHK		;TRUNCATE ADRS- SET UP NEW SEQUENCE
SLAS1:	HRRZM	T,LLOCO
	JRST	LI2

ICON:	PUSHJ	P,DEPRS		;BACKSLASH
	JRST	SLAS1

TAB:	PUSHJ	P,DEPRS		;OPEN REGISTER OF Q
	MOVEI	T,-1(T)
	EXCH	T,LLOC		;SET UP NEW SEQUENCE AND
	MOVEM	T,SAVLOC	;SAVE OLD SEQUENCE
	JRST	LI0
DEPRA:	MOVE	R,SAVLOC
	TLNE	F,CF		;RESTORE OLD SEQUENCE IF $CR,$CF, OR
	EXCH	R,LLOC		;IF $^ OR $BS WAS TYPED
	MOVEM	R,SAVLOC	;SETUP "NEW" OLD SEQUENCE
	TLNE	F,ROF		;IF REGISTER IS BEING CHANGED
	TLNN	F,QF		;REMOVE ALL PREVIOUS UNDEFINED
	JRST	DEPRS		;SYMBOL REFERENCES TO IT
	MOVE	R,@USYMP	;GET POINTER TO ALL OLD UNDEF ITEMS
	MOVEM	W1,@USYMP	;INCLUDE THE NEW ITEMS IN UNDEF LIST
IFN	EDDT&SWFILE,<
	SKIPN	CRASHS		;SEE IF /M
	JRST	DEPRS		;YES--NO UNDEF FIXUPS
>
	MOVEM	T,LWT		;SAVE T IN LWT, DEPRS DOES IT ANYWAY
DEPRA2:	MOVE	T,LWT		;RESTORE T
	JUMPGE	R,DEPRS		;IF JOBUSY SYM TABLE EDITED, STOP
	PUSH	P,R
	MOVE	W,1(R)		;GET FLAGS AND POINTER
	JUMPG	W,DPRS3		;1B0=0 IMPLIES CHAINING
DEPRA4:	POP	P,R
	HRRZ	T,1(R)		;GET ADDRESS OF FIXUP
	SKIPE	T		;DELETE ENTRY IF ADR=0, OR
	CAMN	T,LLOCO		; IF ADR IS BEING CHANGED
	PUSHJ	P,REMUN		;REMOVE ENTRY FROM JOBUSY TABLE
	ADD	R,[2,,2]	;CONTINUE SEARCHING TABLE
	JRST	DEPRA2

DPRS3:	HRROI	S,1(R)		;GET 1ST CHAIN ADR FROM JOBUSY TABLE
				;  AND SET FLAG TO USE DEPSYM FIRST TIME
DPRS4:	HRRZ	R,W		;GET NEXT ADR (AFTER ADR IN S)
	JUMPE	R,DEPRA4	;STOP ON 0 ADR
	PUSHJ	P,FETCH		;GET CONTENTS OF ADR IN R
	 HALT	.	;******WHAT HAPPENS IF A DEPOSIT FAILS***
	EXCH	T,W
	EXCH	S,R
	CAME	S,LLOCO		;IS THIS WORD BEING CHANGED?
	JRST	DPRS4		;NO, CONTINUE SEARCHING LIST
	HRR	T,W		;PATCH CHAIN ADR AROUND ITEM
	TLNN	R,-1		;SEE IF NEED TO USE DEPSYM
	TDZA	TT1,TT1		;NO--USE DEPMEM
	MOVEI	TT1,DEPSYM-DEPMEM  ;YES.  NOTE THAT R CAME FROM S
				;  WHICH HAS -1 IN LH FIRST TIME AROUND
				;  LOOP AND 0 OTHER TIMES.
	PUSHJ	P,DEPMEM(TT1)	;CALL EITHER DEPMEM OR DEPSYM
	 HALT	.
	JRST	DPRS4		;CONTINUE DOWN CHAIN
SUBTTL MODE CONTROL SWITCHES

TEXO:	MOVEI	R,TEXTT-HLFW	;$T ASSUME 7 BIT ASCII
	MOVE	T,WRD2
	CAIN	T,6		;CHECK FOR $6T
	MOVEI	R,SIXBP-HLFW	;SET MODE SWITCH FOR SIXBIT
	CAIN	T,5		;CHECK FOR $5T
	MOVEI	R,R50PNT-HLFW	;SET MODE SWITCH FOR RADIX 50
HWRDS:	ADDI	R,HLFW-TFLOT	;H
SFLOT:	ADDI	R,TFLOT-PIN	;F
SYMBOL:	ADDI	R,PIN-FTOC	;S
CON:	ADDI	R,FTOC		;C
	HRRZM	R,SCH
	JRST	BASE1

RELA:	TRZE	F,Q2F		;CHANGE ADDRESS MODE TO RELATIE
	JRST	BASECH
	MOVEI	R,PADSO-TOC
ABSA:	ADDI	R,TOC		;A
	HRRZM	R,AR
	JRST	BASE1

BASECH:	MOVE	T,WRD2		;$NR  CHANGE OUTPUT RADIX TO N, N>1
	CAIGE	T,2
	JRST	ERR
	HRRZM	T,ODF
BASE1:	MOVS	S,[XWD SCHM,SCH]
	TLNN	F,CCF
	JRST	LIS1
	BLT	S,ODFM		;WITH $$, MAKE MODES PERMANENT
	JRST	RET

SEMIC:	MOVEM	T,LWT		;SEMICOLON TYPES IN CURRENT MODE
	JRST	@SCH

EQUAL:	PUSH P,F		;SAVE FLAGS
	TRO	F,CF1		;=
	JRST PSYM1

PSYM:	PUSH P,F		;SAVE FLAGS
	TRZ	F,CF1		;@
PSYM1:	TRO	F,LF1
	PUSHJ	P,CONSYM
	POP P,F			;RESTORE FLAGS
	JRST	RET

FIRARG:	MOVEM	T,DEFV
	TLO	F,FAF
	JRST	ULIM1
ULIM:	TLO	F,SAF
	HRRZM	T,ULIMIT
ULIM1:	TLNN	F,QF
	JRST	ERR
	JRST	LIS0
SUBTTL GO AND EXECUTE LOGIC

IFE	EDDT&SWFILE,<
CNTRLZ:	IFN EDDT&SWEXEC,<
	SKPUSR			;SEE IF USER MODE
	JRST	ERR		;NO--ERROR  >
	MOVE	T,[IFE EDDT&SW10X,< EXIT 1,>
		   IFN EDDT&SW10X,< HALTF  >]
	JRST	XEC0		;GO EXECUTE IT

GO:	HRLI	T,(JRST)	;G
;--------------- HARVARD PATCH 10
	TLOE	F,QF		;DID USER TYPE AN ARG TO $G?
	JRST	XEC		;YES, GO DO IT
	HRR	T,.JBSA		;NO, GET ADDR FROM .JBSA
IFN EDDT&SWEXEC,<
	SKPEXC			;EXEC MODE HAS NO .JBSA, SO ERROR
>
	TRNN	T,-1		;WAS C(.JBSA) NONZERO?
	JRST	ERR		;NO, SO ERROR

;------------- HARVARD PATCH 03
XEC:	TLNN	F,QF		;SKIP IF QUANTITY TYPED
IFE EDDT&SWXCT,<	;IF NO SINGLE-STEP XCT FEATURE
	JRST	ERR		;ERROR IF NOT
>IFN EDDT&SWXCT,<	;IF SINGLE-STEP EXECUTE FEATURE PRESENT
	TDZA	T,T		;MAKE SURE COUNT IS ZERO
	TLNN	T,777000	;SKIP IF VALID INSTRUCTION
	JRST	$X		;GOTO SINGLE STEP EXECUTE ROUTINE
>
;---------------
XEC0:	MOVEM	T,TEM
	PUSHJ	P,CRF
	PUSHJ	P,INSRTB
	MOVEI	T,4		;INITIALIZE SKIP COUNTER
	MOVEM	T,SKPCNT
	JSP	T,RESTORE
	XCT	TEM		;EXECUTE THE INSTRUCTION
XEC1:	  SOS	SKPCNT		;+1 RETURN
	  SOS	SKPCNT		;+2 RETURN
	  SOS	SKPCNT		;+3 RETURN
	JSR	DDSAVE		;+4 RETURN
	PUSHJ	P,REMOVB
	PUSHJ	P,SKPRNT	;PRINT ONE $ PER SKIP
	JRST	DD1.5
>

IFN	EDDT&SWFILE,<
BCOM==<XEC==<GO==ERR>>
>
	SUBTTL SINGLE STEP EXECUTE LOGIC

IFE EDDT&SWFILE,<IFN EDDT&SWXCT,<

;$X IS A HARVARD FEATURE THAT OPERATES AS FOLLOWS:
;	$X OR N$X OR $$X OR N$$X, WHERE N .LT. 2^27, WILL DISPATCH TO
;	THIS CODE.  THE FOLLOWING ACTIONS WILL BE PERFORMED:
;
;   $X	EXECUTE A SINGLE INSTRUCTION, THEN INCREMENT THE PC.  THE
;	OPERANDS TO THE INSTRUCTION WILL BE PRINTED OUT AS THEY
;	EXIST **AFTER** EXECUTION OF THE INSTRUCTION.  AN EXTRA
;	LINE FEED WILL BE PRINTED IF THE INSTRUCTION SKIPPED OR
;	JUMPED.  THE NEXT INSTRUCTION WILL THEN BE PRINTED.
;	$P WILL ALWAYS DO THE RIGHT THING AFTER ANY NUMBER OF $X'S.
;
;  N$X	REPEAT THE $X CYCLE N TIMES.
;
; N$$X	SAME AS N$X EXCEPT THAT ALL PRINTOUT IS SUPPRESSED FOR
;	ALL BUT THE LAST $X CYCLE.
;
;  $$X	PERFORM A NON-PRINTING $X CYCLE UNTIL THE PC REACHES EITHER
;	.+1 OR .+2; I.E. UNTIL ONE OF THE NEXT 2 INSTRUCTIONS IS
;	EXECUTED.  THIS IS USEFUL FOR TREATING A SUBROUTINE CALL
;	AS A SINGLE INSTRUCTION FOR THE PURPOSES OF $X.

;  $$NX	SAME AS $$X EXCEPT THE TERMINATION CONDITION IS THAT THE PC
;	REACHES .+1 THROUGH .+N WITH RESPECT TO THE ORIGINAL INSTRUCTION.

;  ADR<N$$X OR ADR<$$X  SAME AS N$$X OR $$X EXCEPT THAT C(ADR) ARE
;	CHECKED AFTER EVERY INSTRUCTION AND EXECUTION STOPS IF IT
;	HAS CHANGED (ALSO THE BELL IS RUNG).


;THE SINGLE-STEP EXECUTE FEATURE WAS ORIGINALLY IMPLEMENTED
;	AT BBN BY STEVE BUTTERFIELD, AND WAS CONSIDERABLY IMPROVED
;	AND RECODED AT HARVARD BY GEORGE MEALY AND EDWARD TAFT.
;	TENEX MODS AND FURTHER IMPROVEMENTS AT XEROX PARC BY EDWARD TAFT.

; >>	;BALANCES OPEN BRACKETS IN PREVIOUS COMMENTS

;FLAGS USED IN $X LOGIC ONLY

	FAC==	1		;SIGNALS AC TO BE PRINTED
	DFAC==	2		;SIGNALS INST THAT USES 2 AC'S
	FLG==	4		;INST MODIFIES FLAGS (JRST,JFCL)
	IMM==	10		;SIGNALS IMMEDIATE MODE INST
	EA==	20		;SIGNALS MEMORY REFERENCE INST
	DEA==	40		;SIGNALS INST THAT REFERENCES 2 MEM LOCS
	FLA==	100		;SIGNALS FLOATING AC OPERAND
	FLE==	200		;SIGNALS FLOATING MEM OPERAND
;COME HERE FROM $X COMMAND, WITH T SET TO ZERO IF NO QUANTITY WAS
;   TYPED.

$X:	MOVEM	T,XTEM		;STORE REPETITION COUNT
	JUMPG	T,$X00		;JUMP IF POSITIVE COUNT
	HRRZ	T,PROC0		;ZERO, FETCH CURRENT PC
	MOVEM	T,LOCSAV	;AND REMEMBER IT
	SKIPG	W,WRD2		;PC RANGE OFFSET SPECIFIED?
	MOVEI	W,2		;NO, ASSUME 2 (I.E. STOPS AT .+1 OR .+2)
	ADDI	W,(T)		;COMPUTE LAST ADR IN PC RANGE
	HRRZM	W,LOCSV1	;SAVE IT
	SETOM	XTEM		;SET REPETITION COUNT NEGATIVE
	TLNN	F,CCF		;$$X WITH NO ARG?
	MOVNS	XTEM		;NO, ONLY $X. TREAT AS 1$X
$X00:	HRRZS	R,DEFV		;ADDRESS TO MONITOR WHILE EXECUTING?
	TLNN	F,FAF
	JRST	$X0		;NO
	PUSHJ	P,FETCH		;YES, GET ITS ORIGINAL CONTENTS
	  JRST	ERR
	MOVEM	T,WRDSAV	;SAVE IT AWAY
	HRROS	DEFV		;REMEMBER WE ARE MONITORING
$X0:	PUSHJ	P,CRF		;OUTPUT CRLF TO START

;HERE ON REPEATED $X CYCLES

$X01:	SOSN	XTEM		;DECREMENT AND TEST COUNTER
	TLZ	F,CCF		;CLEAR $$ FLAG TO END REPETITIONS
	TLZ	F,QF!CF!STF	;TURN OFF QUANT, $, ! FLAGS
	MOVEM	F,FLAGS		;SAVE REGULAR DDT FLAGS
	HRRZI	T,100		;SETUP MAX XCT DEPTH
	HRRZM	T,XCTS
	SETZM	SKPCNT		;INITIALIZE SKIP COUNTER TO 0 IN CASE JUMP
IFN EDDT&SW10X,<
	DPB	T,[POINT 4,MXINST,12] ;INIT TO NO FORCED USER MAPPING
>
	HRRZ	R,PROC0		;FETCH ADR OF CURRENT INST
	CAIN	R,XEC1		;JUST HIT BREAKPOINT OR DID $X LAST?
	JRST	ERR		;NO, JUST ENTERED DDT, SO ERROR
	SKIPL	XTEM		;INDEFINITE $$X BEING EXECUTED?
	MOVEM	R,LOCSAV	;NO, REMEMBER OLD PC FOR THIS INST
$X02:	PUSHJ	P,FETCH		;FETCH CURRENT INSTRUCTION
	  JRST	ERR		;ERROR
$XO3:	MOVEM	T,I.NST		;STORE CURRENT INSTRUCTION
	JSR	SWAP		;SWAP TO USER CONTEXT
	MOVEM	T,SAFETY	;SAVE T
IFN EDDT&SW10X,<
	JSR	MAPXCT		;FORCE USER MAPPING IF NECESSARY
>
	MOVEI	T,@I.NST	;COMPUTE EFFECTIVE ADR OF INST
	DPB	T,[POINT 23,I.NST,35] ;STORE COMPUTED ADR IN CURRENT INST
	HRRZM	T,I.NSTEA	;REMEMBER IT AGAIN
	MOVE	T,SAFETY	;RESTORE T
	JSR	SWAP		;SWAP BACK TO DDT CONTEXT
	LDB	W1,[POINT 4,I.NST,12] ;EXTRACT AC FIELD
	MOVEM	W1,I.NSTAC	;STORE IT AWAY
	MOVSI	T,777000	;MASK FOR OPCODE
	AND	T,I.NST		;FETCH OPCODE
	HLRZ	F,T		;SAVE IN RH FOR LATER
	CAMLE	T,$XTBL(T)	;IN RANGE OF CURRENT TABLE ENTRY?
	AOJA	T,.-1		;NO, KEEP SEARCHING
	JRST	@$XTBL(T)	;YES, DISPATCH

IFE EDDT&SWEXEC,<
	MONUI==	JUSTI		;IF USER DDT, TREAT MONITOR UUOS
	MONUE==	JUSTE		;  AS HARDWARE INSTRUCTIONS
	MONUAI==SETI
	MONUAE==SETEA
	MONINI==ERR		;CANNOT TRACE INIT
>
;OPCODE DISPATCH TABLE.
;   LH OF EACH ENTRY CONTAINS LARGEST OPCODE COVERED BY THAT ENTRY,
;   RH CONTAINS DISPATCH ADDRESS.

$XTBL:	SETZB	SET	; 400-403  SETZX
	ORCBB	CHECKI	; 404-473  ALL LOGICAL EXCEPT SETX
	SETOB	SET	; 474-477  SETOX
	HLRES	CHEKIS	; 500-577  HALFWORD
	TSON	TESTS	; 600-677  TEST CLASS
IFE EDDT&SWMAXC,<
	777000,,IOTS	; 700-777  I/O INSTRUCTIONS
> IFN EDDT&SWMAXC,<
	775000,,IOTS	; 700-775  I/O INSTRUCTIONS
	777000,,SETI	; 776-777  UJMC, JMC
>
	0 ,,	ERR	;     000  ALWAYS ILLEGAL
	037000,,USRUUO	; 001-037  USER UUOS
	CALL	MONUAE	;     040  CALL
	INIT	MONINI	;     041  INIT
	CALLI	MONUAI	; 042-047  UNDEFINED AND CALLI
	TTCALL	MONUE	; 050-051  OPEN,TTCALL
	054000,,MONUAI	; 052-054  UNDEFINED
	OUT	MONUE	; 055-057  RENAME,IN,OUT
	STATO	MONUI	; 060-061  SETSTS,STATO
	GETSTS	MONUE	;     062  GETSTS
	OUTBUF	MONUI	; 063-065  STATZ,INBUF,OUTBUF
	OUTPUT	MONUE	; 066-067  INPUT,OUTPUT
	USETO	MONUI	; 070-075  CLOSE,RELEAS,MTAPE,UGETF,USETI,USETO
	ENTER	MONUE	; 076-077  LOOKUP,ENTER
IFN EDDT&SW10X,<
	103000,,CHEKIS	; 100-103  UMOVEX
	JSYS	IIJSYS	;     104  JSYS
>
	107000,,SETI	; 105-107  UNDEFINED
	DFDV	DFLOT	; 110-113  DFAD,DFSB,DFMP,DFDV		*** KI10
	117000,,SETI	; 114-117  UNDEFINED
	DMOVN	DMOV	; 120-121  DMOVE,DMOVN			*** KI10
	FIX	FXAFLE	;     122  FIX				*** KI10
	123000,,SETI	;     123  UNDEFINED
	DMOVNM	DMOV	; 124-125  DMOVEM,DMOVNM		*** KI10
	FIXR	FXAFLE	;     126  FIXR				*** KI10
	FLTR	FLAFXE	;     127  FLTR				*** KI10
	UFA	IUFA	;     130  UFA
	DFN	IDFN	;     131  DFN
	FSC	IFSC	;     132  FSC
	IBP	JUSTE	;     133  IBP
	DPB	SETEA	; 134-137  XLDB,XDPB
	FDVRB	FLOAT	; 140-177  FADXX,FSBXX,FMPXX,FDVXX
;CONTINUATION OF OPCODE DISPATCH TABLE.

	MOVMS	CHEKIS	; 200-217  MOVXX
	IMULB	CHECKI	; 220-223  IMULX
	DIVB	MULDIV	; 224-237  MULX,XDIVX
	LSH	SETI	; 240-242  ASH,ROT,LSH
	JFFO	IJFFO	;     243  JFFO
	LSHC	DBLI	; 244-246  ASHC,ROTC,LSHC
	247000,,SETI	;     247  UNDEFINED
	EXCH	SETEA	;     250  EXCH
	BLT	SETI	;     251  BLT
	AOBJN	IAOBJ	; 252-253  AOBJP,AOBJN
	JRST	IJRST	;     254  JRST
	JFCL	IJFCL	;     255  JFCL
	XCT	IIXCT	;     256  XCT
	MAP	SETEA	;     257  MAP				*** KI10
	PUSHJ	IIPUSHJ	;     260  PUSHJ
	POP	SETEA	; 261-262  PUSH,POP
	POPJ	IPOPJ	;     263  POPJ
	JSR	I.JSR	;     264  JSR
	JSP	I.JSP	;     265  JSP
	JSA	I.JSA	;     266  JSA
	JRA	IAOBJ	;     267  JRA
	SUBB	CHECKI	; 270-277  ADDX,SUBX
	CAIG	SETI	; 300-307  CAIXX
	CAMG	SETEA	; 310-317  CAMXX
	SOSG	JMPSKP	; 320-377  JUMPXX,SKIPXX,AOJXX,AOSXX,SOJXX,SOSXX
;MONITOR UUO HANDLER

IFN EDDT&SWEXEC,<
MONUAI:	TLO	F,FAC		;REMEMBER TO PRINT AC
MONUI:	SKPEXC			;SKIP IF EXEC MODE
	JRST	JUSTI		;USER MODE, TREAT UUO AS SINGLE INST
	JRST	USRUUO		;EXEC MODE, TRACE THE UUO

MONUAE:	TLO	F,FAC		;REMEMBER TO PRINT AC
MONUE:	SKPEXC			;SKIP IF EXEC MODE
	JRST	JUSTE		;USER MODE, TREAT UUO AS SINGLE INST
	JRST	USRUUO		;EXEC MODE, TRACE THE UUO

MONINI:	SKPEXC			;SKIP IF EXEC MODE
	JRST	ERR		;USER MODE, CAN'T FOLLOW AN INIT
				;EXEC MODE, TRACE NORMALLY
>
;USER UUO HANDLER

USRUUO:	MOVEI	R,40		;SETUP JOBUUO
	EXCH	F,FLAGS		;RESTORE REGULAR FLAGS
	MOVE	T,I.NST		;FETCH INST WITH EFF ADR COMPUTED
	PUSHJ	P,DEPMEM	;STORE USER UUO IN JOBUUO
	  JRST	ERR		;ERROR
	EXCH	F,FLAGS		;RESTORE $X FLAGS
	MOVE	T,[XCT 41]	;PRETEND INSTRUCTION WAS AN XCT
	JRST	$XO3

;INTERPRET UFA

IUFA:	TLOA	F,FLA+FLE+DFAC	;REMEMBER FLTG PT, USES 2 AC'S

;INTERPRET DFN

IDFN:	TLO	F,FLA!FLE	;DFN, REMEMBER AC AND E FLOAT
	JRST	SETEA

;INTERPRET FLOATING POINT INSTRUCTIONS

FLOAT:	ANDI	F,7000		;FLOATING PT, GET MODE
	CAIN	F,1000		;LONG MODE?
	TLOA	F,DFAC		;YES, PRINT 2 AC'S
	CAIE	F,5000		;IMMEDIATE MODE?
	TLOA	F,FLA+FLE+FAC+EA ;NO, PRINT AC AND E BOTH FLOATING
FLOATI:	TLO	F,FLA+FLE+FAC+IMM ;YES, PRINT AC AND E IMMEDIATE FLTG
	JRST	DOIT
;INTERPRET JRST

IJRST:	TLO	F,IMM		;REMEMBER TO PRINT E
	TRNE	W1,2		;IS INSTRUCTION JRSTF?
	TLO	F,FLG		;YES, REMEMBER TO PRINT FLAGS
IJRST0:	PUSHJ	P,FETCH		;FETCH INST OR INDIRECT WORD
	  JRST	ERR		;ERROR
	MOVE	W1,T		;COPY INTO W1
	LDB	R,[POINT 4,T,17] ;LOAD INDEX FIELD
	JUMPE	R,IJRST1	;JUMP IF NO INDEXING TO PERFORM
	MOVE	T,AC0(R)	;FETCH CONTENTS OF INDEX REGISTER
	TLZ	T,(Z @(17))	;CLEAR I AND X FIELDS IN INDEX REG
	ADDI	T,(W1)		;COMPUTE INDEXED ADDRESS
	TLZ	T,(Z @(17))	;CLEAR ANY OVERFLOW
IJRST1:	MOVEI	R,(T)		;COPY RESULTING ADDRESS
	TLNE	W1,(@)		;INDIRECT?
	JRST	IJRST0		;YES, FOLLOW NEXT LEVEL OF INDIRECTION

;LH OF T NOW CONTAINS FLAGS THAT WILL BE RESTORED

IFN EDDT&SWEXEC,<
	SKPEXC			;NOW IN EXEC MODE?
	JRST	IJRST3		;NO, USER MODE
	MOVE	W1,I.NSTAC	;YES, FETCH AC FIELD OF JRST INST
	TRNE	W1,1		;JUMP TO USER MODE?
	JRST	JRSPRC		;YES, CAN'T TRACE. GO DO $P
	TRNE	W1,2		;JRSTF?
	TLNN	T,(1B5)		;YES, GOING TO ENTER USER MODE?
	JRST	IJRST3		;NO TO EITHER, HANDLE NORMALLY
JRSPRC:	EXCH	F,FLAGS		; $X OPERATION IMPOSSIBLE. RESTORE FLAGS
	TLZ	F,QF+CCF	;CLEAR QUANT AND $$ FLAGS
	JRST	PROCD1		;AND EXECUTE $P TO GO INTO USER MODE
>

IJRST3:	HRRI	T,NOSKIP	;MODIFY THE JRST EFFECTIVE ADR
	MOVEM	T,BCOM		;STORE NEW FLAGS,,NOSKIP
	MOVE	T,I.NST		;FETCH INST AGAIN
	HRRM	T,PROC0		;STORE EFF ADR AS NEW PC
	HRRI	T,BCOM		;TURN INTO JRST @BCOM
	TLO	T,(@)
	MOVEM	T,I.NST		;AND STORE
	JRST	DOIT1		;DO IT
IFN EDDT&SW10X,<	;INTERPRET JSYS

IIJSYS:	HRRZ	R,I.NSTEA	;GET EFFECTIVE ADR
IFN EDDT&SWEXEC,<
	SKPEXC			;EXEC MODE?
>
	CAIL	R,1000		;NO, USER-USER JSYS?
	JRST	XJSYS		;ONE OF THOSE, GO INTERPRET
	MOVEI	T,1		;USER-EXEC JSYS, SETUP TO PRINT OUT
	MOVEM	T,I.NSTAC	;   AC'S 1, 2, AND 3
	MOVEI	T,3
	MOVEM	T,I.NSTEA
	JRST	UXJSYS		;GO SET FLAGS FOR 2 AC'S AND EFF ADR

;HERE ON USER-USER JSYS OR ANY JSYS EXECUTED FROM EXEC MODE
XJSYS:	AOS	W1,PROC0	;COMPUTE PC WORD
	HLL	W1,SAVPI
	MOVSI	T,(1B4)		;CLEAR BIS
	ANDCAM	T,SAVPI
IFN EDDT&SWEXEC,<
	CAIL	R,1000		;EX JSYS?
	JRST	XJSYS1		;NO
	MOVSI	T,(1B7)		;YES, SET CALL FROM MONITOR FLAG
	IORM	T,SAVPI
	ADDI	R,1000		;OFFSET TO MONITOR JSYS TABLE
>
XJSYS1:	EXCH	F,FLAGS		;GET DDT'S FLAGS
	PUSHJ	P,FETCH		;FETCH JSYS DISPATCH WORD
	  JRST	ERR
	EXCH	F,FLAGS		;GET BACK $X FLAGS
	HLRZM	T,I.NSTEA	;CAUSE SAVED PC WORD TO BE PRINTED
	TLO	F,EA
	HRRM	T,PROC0		;SET NEW PC
	HLRZ	R,T		;GET LH OF JSYS DISPATCH WORD
	MOVE	T,W1		;COPY PC TO BE STORED
	EXCH	F,FLAGS		;GET DDT'S NORMAL FLAGS
	PUSHJ	P,DEPMEM	;STORE PC WORD
	  JRST	ERR
	JRST	TELL1		;GO PRINT RESULT
> ;END EDDT&SW10X
;INTERPRET XCT

IIXCT:	MOVE	F,FLAGS		;GET BACK NORMAL DDT FLAGS
	SOSG	XCTS		;CHECK XCT COUNTER
	JRST	ERR		;ERROR - DEPTH EXCEEDED
IFN EDDT&SW10X,<
	DPB	W1,[POINT 4,MXINST,12] ;REMEMBER FORCED MAPPING BITS IF ANY
>
	TLNE	F,CCF		;$$X?
	JRST	IIXCT1		;YES, DON'T PRINT ANYTHING
	HRRZ	T,I.NSTEA	;GET EFF ADR OF XCT
	PUSHJ	P,PINST		;PRINT INST BEING XCT'ED
	PUSHJ	P,CRF		;OUTPUT CRLF AFTER INST
IIXCT1:	HRRZ	R,I.NSTEA	;GET EFF ADR OF XCT AGAIN
	JRST	$X02		;PROCESS EXECUTED INST

;INTERPRET PUSHJ

IIPUSHJ:AOS	T,PROC0		;GET CURRENT PC +1
	HLL	T,SAVPI		;PUT FLAGS IN LH
	MOVEM	T,I.NSTPC	;STORE AWAY TO BE STACKED
	MOVSI	T,(1B4)		;CLEAR BIS FLAG IN NEW PC WORD
	ANDCAM	T,SAVPI
	MOVE	T,I.NST		;GET EFF ADR OF PUSHJ,
	HRRM	T,PROC0		;STORE NEW PC
	HRLZI	T,(<PUSH>-<PUSHJ>) ;WANT TO TURN PUSHJ INTO A PUSH
	DPB	T,[POINT 5,I.NST,17] ;CLEAR I AND AC FIELD
	JRST	IPOPJ2		;REST OF CODE COMMON WITH POPJ

;INTERPRET POPJ

IPOPJ:	EXCH	F,FLAGS		;POPJ, RESTORE NORMAL DDT FLAGS
	HRRZ	R,AC0(W1)	;FETCH CONTENTS OF CORRECT USER AC
	PUSHJ	P,FETCH		;FETCH PCWORD IT POINTS TO
	  JRST	ERR		;ERROR
	EXCH	F,FLAGS		;RESTORE $X FLAGS
	HRRM	T,PROC0		;STORE AS CURRENT PC
	HRLZI	T,(<POP>-<POPJ>) ;SETUP TO TURN POPJ INTO POP

;COMMON CODE FOR PUSHJ, POPJ

IPOPJ2:	ADDM	T,I.NST		;TURN PUSHJ INTO PUSH OR POPJ INTO POP
	HRRZI	T,I.NSTPC	;SETUP ADR OF PC WORD FOR PUSHJ
	HRRM	T,I.NST
	MOVEI	T,3		;PRESET SKIP COUNTER FOR ZERO SKIPS
	MOVEM	T,SKPCNT	;  WHICH WILL ALSO MAKE $$ NOT COME OUT
	TLO	F,FAC		;REMEMBER TO PRINT AC
	JRST	DOIT1		;GO EXECUTE THE PUSH OR POP
;INTERPRET JSA

I.JSA:	AOS	T,PROC0		;JSA, SETUP RETURN PC
	HRL	T,I.NSTEA	;PUT EFF ADR IN LH LIKE JSA DOES
	EXCH	T,AC0(W1)	;STORE IN USER AC, GET OLD CONTENTS
	JRST	I.JSR2		;STORE OLD CONTENTS LIKE JSR, THEN JUMP

;INTERPRET JSR

I.JSR:	AOS	T,PROC0		;JSR, GET CURRENT PC
	HLL	T,SAVPI		;SETUP LH OF PC WORD
	TLO	F,FAC		;REMEMBER NOT TO PRINT AC FIELD
	MOVSI	W1,(1B4)	;CLEAR BIS FLAG IN NEW PC WORD
	ANDCAM	W1,SAVPI
I.JSR2:	TLO	F,EA		;PRINT E NORMALLY
	EXCH	F,FLAGS		;RESTORE NORMAL DDT FLAGS
	HRRZ	R,I.NSTEA	;FETCH EFF ADR OF JSR OR JSA
	PUSHJ	P,DEPMEM	;STORE PC WORD
	  JRST	ERR		;ERROR
	EXCH	F,FLAGS		;RESTORE $X FLAGS
	HRRZ	T,I.NSTEA	;GET EFF ADR AGAIN
	AOJA	T,I.JSR4	;INC PAST STORED PC WORD

;INTERPRET JSP

I.JSP:	AOS	T,PROC0		;JSP, SETUP RETURN PC
	HLL	T,SAVPI		;SETUP LH OF PC WORD
	MOVEM	T,AC0(W1)	;STORE IN USER AC
	MOVSI	T,(1B4)		;CLEAR BIS FLAG IN NEW PC WORD
	ANDCAM	T,SAVPI
	HRRZ	T,I.NSTEA	;GET BACK EFF ADR
I.JSR4:	HRRM	T,PROC0		;STORE NEW PC
	TLC	F,FAC		;REMEMBER TO PRINT AC
	JRST	TELL		;GO PERFORM PRINTOUT


;INTERPRET KI10 INSTRUCTIONS

DFLOT:	TLO	F,FLA+FLE	;REMEMBER THAT AC AND E ARE FLOATING
DMOV:	TLO	F,DFAC+DEA	;REMEMBER AC AND E BOTH DOUBLE
	JRST	SETEA

FXAFLE:	TLOA	F,FLE		;REMEMBER THAT E FLOATS (FIX,FIXR)
FLAFXE:	TLO	F,FLA		;REMEMBER THAT AC FLAOATS (FLTR)
	JRST	SETEA
;INTERPRET JFFO

IJFFO:	TLO	F,DFAC		;REMEMBER JFFO USES 2 AC'S

;INTERPRET JUMP AND SKIP INSTRUCTIONS

JMPSKP:	TRNE	F,10000		;JUMP/SKIP, WHICH IS IT?
	JRST	SKP		;SKIP CLASS
	TRNN	F,53000		;JUMP CLASS, IS IT JUMP OR JUMPA?
	TLO	F,FAC		;YES, DON'T PRINT AC FIELD

;INTERPRET AOBJN AND AOBJP

IAOBJ:	TLCA	F,FAC+IMM	;HANDLE AS IMMEDIATE MODE INST WITH AC

;INTERPRET JFCL

IJFCL:	TLO	F,FLG		;REMEMBER TO PRINT FLAGS
	MOVEI	T,JMP		;JUMP CLASS OR AOBJ, COME BACK TO $X
	HRRM	T,I.NST		;STORE MODIFIED INST
	JRST	DOIT		;GO EXECUTE CONDITIONAL INST

;HERE AFTER EXECUTING CONDITIONAL JUMP INSTRUCTION THAT ACTUALLY
;   DOES JUMP

JMP:	EXCH	T,I.NSTEA	;SAVE T, GET EFF ADR OF JUMP
	HRRM	T,PROC0		;STORE EFF ADR AS NEW PC
	EXCH	T,I.NSTEA
	SETZM	SKPCNT		;DISABLE PC UPDATE AND $$$ PRINTING
	JRST	NOSKIP		;NOW DO PRINTOUT

;HERE FOR ALL SKIP INSTRUCTIONS

SKP:	JUMPN	W1,SETEA	;SKIP CLASS - AC FIELD ZERO?
JUSTE:	TLOA	F,EA		;YES, JUST PRINT E

;INTERPRET SHIFT COMBINED INSTRUCTIONS

DBLI:	TLO	F,FAC+DFAC+IMM	;REMEMBER 2 AC'S USED, IMMEDIATE
	JRST	DOIT		;EXECUTE NORMALLY

;INTERPRET FSC

IFSC:	TLOA	F,FLA		;REMEMBER THE AC IS FLOATING

;INTERPRET TEST CLASS INSTRUCTIONS

TESTS:	TRNN	F,10000		;SKIP ON TD OR TS BUT NOT ON TR OR TL
	TLOA	F,FAC+IMM	;IMMEDIATE MODE
	TLO	F,FAC+EA	;NORMAL MODE
	JRST	DOIT
;I/O INSTRUCTIONS

IOTS:	TRNE	W1,4		;SKIP IF BLKI,DATAI,BLKO,DATAO
	CAIN	W1,5		;SKIP IF NOT CONI
	TLOA	F,EA		;MEM REF INSTRUCTION
JUSTI:	TLO	F,IMM		;IMMEDIATE INST
	JRST	DOIT

;ALL PATHS CONVERGE HERE

CHEKIS:	TRC	F,3000		;HERE TO TEST FOR IMMEDIATE OR SELF MODE
	TRCE	F,3000		;SKIP IF SELF MODE
	JRST	CHECKI		;NO, CHECK IMMEDIATE
	JRST	SKP		;YES, GO TEST FOR NONZERO AC FIELD
SET:	ANDI	F,3000		;HERE FOR SETZX,SETOX
	CAIE	F,2000		;SETZM,SETOM?
	TLO	F,FAC		;NO, AC IS ALWAYS AFFECTED
	TRNE	F,2000		;SETZM,SETZB,SETOM,SETOB?
	TLO	F,EA		;YES, MEM IS ALWAYS AFFECTED
	JRST	DOIT

;FIXED POINT MULTIPLY AND DIVIDE (NOT INCLUDING IMULX)

MULDIV:	ANDI	F,3000		;MASK MODE BITS
	CAIE	F,2000		;TO MEMORY ONLY?
UXJSYS:	TLO	F,DFAC		;NO, INST USES 2 AC'S
CHECKI:	TRNE	F,1000		;TEST FOR IMMEDIATE MODE INST
	TRNE	F,2000
SETEA:	TLOA	F,FAC+EA	;MEM REF INSTRUCTION
SETI:	TLO	F,FAC+IMM	;IMMEDIATE MODE INSTRUCTION
DOIT:	MOVEI	T,4		;INITIALIZE SKIP COUNTER
	MOVEM	T,SKPCNT
DOIT1:	EXCH	F,FLAGS		;RESTORE NORMAL DDT FLAGS
	PUSHJ	P,TTYLEV	;RESTORE STATUS OF CTY (EXEC MODE)
	JSR	SWAP		;SWAP TO USER CONTEXT
IFN EDDT&SW10X,<
	JSR	MAPXCT		;FORCE USER MAPPING IF NECESSARY
>
I.NST:	0			;INSTRUCTION BEING EXECUTED
	  SOS	SKPCNT		;+1 RETURN
	  SOS	SKPCNT		;+2 RETURN
	  SOS	SKPCNT		;+3 RETURN
				;+4 RETURN
;HERE AFTER SIMULATING OR EXECUTING INSTRUCTION.
;  PERFORM REQUIRED PRINTOUT.

NOSKIP:	JSR	SWAP		;RESTORE DDT CONTEXT
	PUSHJ	P,TTYRET	;RESTORE TTY STATE
	JRST	.+2
TELL:	EXCH	F,FLAGS		;GET DDT'S FLAGS
TELL1:	MOVE	W1,SKPCNT	;UPDATE PC BY NUMBER OF SKIPS
	ADDM	W1,PROC0
	SKIPL	R,DEFV		;IS THERE AN ADDRESS BEING MONITORED?
	JRST	TELL2		;NO
	PUSHJ	P,FETCH		;YES, GET ITS PRESENT CONTENTS
	  JRST	ERR
	CAMN	T,WRDSAV	;HAS IT CHANGED?
	JRST	TELL2		;NO, CONTINUE
	SETZM	XTEM		;YES, ZERO ITERATION COUNTER AND
	TLZ	F,CCF		;   CLEAR FLAG TO STOP EXECUTION
	MOVEI	T,7		;RING THE BELL
	PUSHJ	P,TOUT
TELL2:	TLNE	F,CCF		;IF $$X, DON'T PRINT ANYTHING
	JRST	NXTIT
	CAIE	W1,1		;IF INSTRUCTION SKIPPED OR JUMPED
	PUSHJ	P,SKPRNT	;PRINT 1 $ PER SKIP
	EXCH	F,FLAGS		;RESTORE $X'S FLAGS
	PUSH	P,SCH		;SAVE CURRENT OUTPUT MODE
	TLNE	F,FLA		;FLOATING AC?
	MOVEI	SCH,TFLOT	;YES, SETUP TO OUTPUT IN FLOATING PT
	TLNE	F,FAC		;AC TO BE PRINTED?
	PUSHJ	P,FAC0		;YES, DO IT
	TLNE	F,DFAC		;INST USE 2 AC'S?
	PUSHJ	P,DBL0		;YES, PRINT LOW-ORDER AC
	TLNE	F,FLG		;INSTRUCTION ACCESS THE FLAGS?
	PUSHJ	P,FLG0		;YES, PRINT FLAGS
	MOVE	SCH,(P)		;RESTORE OLD MODE
	TLNE	F,FLE		;FLOATING MEMORY OPERAND?
	MOVEI	SCH,TFLOT	;YES, SETUP FLTG OUTPUT
	TLNE	F,IMM		;IMMEDIATE MODE?
	PUSHJ	P,IMM0		;YES, JUST PRINT E
	TLNE	F,EA		;MEM REF INST?
	PUSHJ	P,EA0		;YES, PRINT C(E)
	TLNE	F,DEA		;DOUBLE-WORD MEM OPERAND?
	PUSHJ	P,DEA0		;YES, OUTPUT 2ND WORD
	POP	P,SCH		;RESTORE CURRENT OUTPUT MODE
	EXCH	F,FLAGS		;RESTORE DDT FLAGS
	PUSHJ	P,CRF		;OUTPUT CRLF
;NOW TEST WHETHER TO CONTINUE, AND PRINT NEXT INST IF REQUIRED.

NXTIT:	HRRZ	T,PROC0		;FETCH NEW PC
	MOVEI	W1,1(T)		;COMPUTE PC+1
	HRRZM	W1,BCOM		;STORE FOR $P
	HRRZ	W1,LOCSAV	;FETCH OLD PC
	SKIPL	XTEM		;INDEFINITE $$X IN PROGRESS?
	JRST	NXT0		;NO
	CAIL	T,1(W1)		;YES, ARE WE IN DESIRED PC RANGE
	CAMLE	T,LOCSV1	;   FOR TERMINATION?
	CAIA			;NO, CONTINUE
	JRST	$XQUIT		;YES, STOP ITERATION NOW
NXT0:	PUSHJ	P,LISTEN	;NO, HAS USER TYPED ANYTHING?
	  JRST	NXT1		;NO, CONTINUE
$XQUIT:	SETZM	XTEM		;YES, STOP ITERATION BY ZEROING COUNTER
	TLZ	F,CCF		;  AND CLEARING CONTROL FLAG
NXT1:	TLNE	F,CCF		;$$ STILL IN EFFECT?
	JRST	NXT2		;YES, DON'T PRINT ANYTHING
	HRRZ	T,PROC0		;FETCH CURRENT PC AGAIN
	PUSHJ	P,PINST		;PRINT INSTRUCTION ABOUT TO BE EXECUTED
	SKIPE	XTEM		;ARE WE STILL LOOPING?
	PUSHJ	P,CRF		;YES, PRINT CRLF AFTER INST
NXT2:	SKIPE	XTEM		;SKIP IF REPEAT COUNTER IS ZERO
	JRST	$X01		;NONZERO, REPEAT $X CYCLE AGAIN
	JRST	TTYCLR		;ZERO, FLUSH ANY WAITING INPUT CHARACTERS
				;   AND RETURN FROM $X INSTRUCTION
;OUTPUT ROUTINES

;ROUTINE TO PRINT SECOND ACCUMULATOR

DBL0:	AOS	T,I.NSTAC	;INCREMENT AC NUMBER
	TRZA	T,777760	;ENSURE 17 WRAPS AROUND TO 0

;ROUTINE TO PRINT CONTENTS OF ACCUMULATOR

FAC0:	MOVE	T,I.NSTAC	;FETCH AC NUMBER
	JRST	EA2

;ROUTINE TO PRINT THE FLAGS

FLG0:	PUSHJ	P,LCT		;PRINT TAB
	HLRZ	T,SAVPI		;GET LH OF PC WORD
	JRST	IMM1		;PRINT FLAGS

;ROUTINE TO PRINT JUST E FOR AN IMMEDIATE MODE INSTRUCTION

IMM0:	PUSHJ	P,LCT		;PRINT TAB
	HRRZ	T,I.NSTEA	;FETCH E
	TLNE	F,FLE		;FLTG PT MEM OPERAND?
	MOVS	T,T		;YES, IMMEDIATE SWAPS HALVES
IMM1:	EXCH	F,FLAGS		;RESTORE DDT FLAGS
	PUSHJ	P,CONSYM	;OUTPUT CONTENTS OF T
	JRST	EA6		;RESTORE $X FLAGS AND RETURN

;ROUTINE TO PRINT 2ND MEMORY OPERAND

DEA0:	AOS	I.NSTEA		;INC TO ADR OF 2ND OPERAND

;ROUTINE TO PRINT MEMORY OPERAND

EA0:	MOVE	T,I.NSTEA	;FETCH ADR OF MEM OPERAND
EA2:	EXCH	F,FLAGS		;HERE FROM DBL0,FAC0
	PUSH	P,T		;SAVE ARG
	PUSHJ	P,LCT		;OUTPUT TAB
	POP	P,T		;RESTORE ADR OF LOC TO BE PRINTED
	PUSHJ	P,LI1		;PRINT ADR/	CONTENTS
EA6:	EXCH	F,FLAGS		;RESTORE $X FLAGS
	POPJ	P,

;ROUTINE TO PRINT INSTRUCTION ALWAYS IN SYMBOLIC DESPITE CURRENT MODE

PINST:	PUSH	P,SCH		;SAVE CURRENT OUTPUT MODE
	MOVEI	SCH,PIN		;SET TO PRINT SYMBOLIC INST MODE
	PUSHJ	P,LI1		;OUTPUT INST
	POP	P,SCH		;RESTORE CURRENT MODE
	POPJ	P,
;ROUTINE TO SWAP BETWEEN DDT AND USER CONTEXTS.
;   AC'S AND FLAGS ARE SWAPPED, BUT BREAKPOINTS AND OTHER STUFF
;   ARE NOT TOUCHED, SINCE CONTROL IS EXPECTED TO RETURN TO DDT SOON.

SWAP:	0
	EXCH	0,AC0		;SWAP AC 0
	MOVEM	0,SAV0		;SAVE 0 FOR WORK
	HLLZ	0,SWAP		;GET CURRENT FLAGS
	HLR	0,SAVPI		;GET SAVED FLAGS
	HRLM	0,SWAP		;SWITCH FLAGS
	HLLM	0,SAVPI
	MOVE	0,[EXCH 1,AC0+1] ;SETUP INST FOR SWAPPING AC'S
SWAPL:	XCT	0		;SWAP AN AC
	ADD	0,[Z 1,1]	;INC AC AND MEM FIELDS
	TLNN	0,1000		;AC 20 REACHED?
	JRST	SWAPL		;NO, LOOP
	MOVE	0,SAV0		;YES, RESTORE SAVED AC
	JRSTF	@SWAP		;RETURN, RESTORING NEW FLAGS

;VARIABLES USED IN $X LOGIC

SAV0:	0			;SAVES AC 0 IN SWAP ROUTINE
XCTS:	0			;XCT DEPTH COUNTER
I.NSTAC:0			;AC FIELD OF INST BEING EXECUTED
I.NSTEA:0			;E FIELD OF INST BEING EXECUTED
XTEM:	0			;$X REPEAT COUNTER
I.NSTPC:0			;PC OF INST BEING EXECUTED
FLAGS:	0			;SAVES DDT FLAG REGISTER
LOCSAV:	0			;SAVES LOCATION OF INST BEING EXECUTED
LOCSV1:	0			;SAVES UPPER PC LIMIT FOR TERMINATION
WRDSAV:	0			;SAVES CONTENTS OF CELL BEING MONITORED
SAFETY:	0			;SAVES T

;----------- END HARVARD PATCH 04
>	;END IFN EDDT&SWXCT

;ROUTINE TO PRINT (SKPCNT) DOLLAR SIGNS AND CR/LF
SKPRNT:	MOVEI	T,"$"
	SOSGE	SKPCNT
	JRST	CRF		;CRLF AND RETURN
	PUSHJ	P,TOUT		;PRINT $
	JRST	SKPRNT

>	;END IFE EDDT&SWFILE
SUBTTL ENTER AND LEAVE DDT LOGIC
IFE	EDDT&SWFILE,<

DDSAVE:	0		;SAVE THE ACS AND PI SYSTEM
IFN EDDT&SWEXEC,<	MOVEM T,TEM	;FREE AN AC
	JSP	T,.+1		;GET USR FLAG
	XOR	T,SAVPI		;COMPARE WITH OLD USR FLAG(LAST DDT EXIT)
	TLNE	T,(1B5)		;SAME?
	SETZM	SARS		;NO, SAVE AC'S AND PC FOR EXIT
			; SO EXEC/USER MODE FLOP RESTORED AS ENTERED
	JSP	T,.+1		;GET PC WORD AGAIN
	ROT	T,5		;ROTATE USER MODE BIT TO SIGN
	MOVEM	T,USRFLG	; AND SAVE IT
	MOVNI	T,1		;LOAD T WITH ALL ONES
	AOBJN	T,.+1		;ADD ONE TO BOTH HALFS
	MOVEM	T,KAFLG		;0 MEANS KI10; 1,,0 MEANS KA10
	MOVEI	T,NXMKA		;ASSUME KA10 NXM FLAG BIT
	SKPKA			;IS IT A KA10?
	MOVEI	T,NXMKI		;NO, KI10
	MOVEM	T,NXM		;SAVE THE CORRECT BIT FOR NXM FLAG
	HRRI	T,XJBSYM	;GET EXEC SYMBOL POINTER ADR
	SKPEXC			;EXEC MODE?
	HRRI	T,.JBSYM	;NO, GET USER MODE SYM POINTER ADR
	HRRM	T,SYMP		; AND SAVE IT
	HRRI	T,XJBUSY	;GET EXEC UNDEF SYM TABLE POINTER ADR
	SKPEXC			;EXEC MODE?
	HRRI	T,.JBUSY	;NO, GET USER MODE UNDEF SYM POINTER ADR
	HRRM	T,USYMP		; AND SAVE RESULTING ADR
	MOVE	T,TEM		;RESTORE THE AC	>

	SKIPN	SARS
	JRST	SAV1
	AOS	DDSAVE
	JRST	SAV5
SAV1:	IFN	EDDT&SWEXEC,<
	SKPEXC
	JRST	SAV11
	CONI	PRS,SAVPI
	CONO	PRS, @SAVPI+1>
SAV11:	MOVEM	17,AC17
	HRRZI	17,AC0
	BLT	17,AC0+16
	MOVE	T,DDSAVE
	HLLM	T, SAVPI
IFN EDDT&SWEXEC,<
	SKPEXC
	JRST	SAV12		;TRANSFER IF IN USER MODE
	CONI	T		;GET APR FLAGS
	ANDI	T,7		;KEEP JUST PI SETTING
	IORI	T,1B26+1B29+1B32 ;WANT TO CLEAR CLOCK, FOV, OV ON EXIT
	CONSZ	@NXM		;TEST NXM FLAG AND
	TLO	T,(1B0)		;  MOVE IT TO BIT 0
	MOVEM	T,SAVAPR	;SAVE STATE OF APR REGISTER
IFN EDDT&SW10X,<
	ANDI	T,40		;ISOLATE TRAP OFFSET BIT
	LSH	T,1		;COMPUTE TRAP INSTRUCTION LOCATION
	HRROI	T,70(T)		;   (70 FOR APR 0, 170 FOR APR 1)
	POP	T,SAVTRP	;SAVE TRAP INSTRUCTION
	PUSH	T,[JSYS [DDTRPC,,SVTSWF]] ;INSTALL NEW ONE FOR TEST
	SETZM	TSWSVF		;INDICATE TSW NOT SAVED YET
	MOVE	W,[777571,,SAVTSW]
	CONO	@NXM		;CLEAR NXM
	BLT	W,SAVTSW+1	;TRY TO SAVE THE TSW AND WRITE DATA
	CONSO	@NXM		;HERE ONLY IF NO TRAP.  TEST NXM
	SETOM	TSWSVF		;SET FLAG IF HAPPENED SUCCESSFULLY
SVTSWF:	MOVEI	T,-1(T)
	PUSH	T,[JSYS DDTRAP]	;INSTALL TRAP INSTRUCTION FOR DDT
	SETZM	PGTENB		;INDICATE TRAPS SHOULDN'T HAPPEN FOR NOW
>
SAV12:	>
	MOVEI	P,PS		;SET UP PUSH DOWN POINTER
	PUSHJ	P,TTYRET	;INITIALIZE TTY
SAV5:
REPEAT 0,<	;WAIT FOR 5.3 RELEASE FOR THIS TEST
IFN EDDT&SWYANK,<SKPEXC		;IF IN USER MODE, RETURNING FROM $G,$P
	SKIPN	COMAND		;AND A COMMAND FILE WAS OPEN
	JRST	SAV6
	MOVEIT	T,CM		;MAKE SURE A RELEASE HASN'T BEEN DMNE
	CALLI	T,4		;DEVCHR
	TRNN	T,200000	;DEVICE PAT STILL INITED?
	SETZM	COMAND		;NO, DONT READ ANY MORE
SAV6:	>	;END IFN EDDT&SWYANK
>	;END OF REPEAT 0 CONDITIONAL
	MOVEI	F,0		;INIT FLAG REGISTER
	SETOM	SARS		;FLAG PROTECTING SAVED REGISTERS
	MOVEI	P,PS
	MOVE	T,[XWD SCHM,SCH]
	BLT	T,ODF		;LOAD THE ACS WITH MODE SWITCHES
	JRST	@DDSAVE
;STILL UNDER EDDT&SWFILE

RESTOR:		;RESTORE ACS AND PI SYSTEM
	HRRM	T,DDSAVE
	PUSHJ	P,TTYLEV	;RESTORE STATUS OF CONSOL TTY (EXEC MODE)
	MOVE	T,SAVPI
	TLZ	T,010037	;DON'T TRY TO RESTORE USER MODE FLAG
	HLLM	T,DDSAVE
IFN EDDT&SWEXEC,<
	SKPEXC
	JRST	RESTR2
IFE EDDT&SWMAXC,<
	AND	T, SAVPI+1
	IORI	T, 2000		;TURN ON CHANNELS
> IFN EDDT&SWMAXC,<
	ANDI	T,200		;TURN ON PI SYSTEM IF ON BEFORE
>
	MOVEM	T, SAVPI
IFN EDDT&SW10X,<
	MOVS	T,[777571,,SAVTSW]
	SKIPE	TSWSVF		;WERE THE TSW AND WRITE DATA SAVED?
	BLT	T,777572	;YES, RESTORE THEM TO THE PSB
	MOVEI	T,67		;TRAP INSTRUCTION LOCATION -1
	CONSZ	0,40		;TRAP OFFSET?
	IORI	T,100		;YES, OFFSET FOR SECOND PROCESSOR
	PUSH	T,SAVTRP	;RESTORE SAVED TRAP INSTRUCTION
>
RESTR2:	HRLZI	17,AC0
	BLT	17,17
	SETZM	SARS
IFN EDDT&SWEXEC,<	SKPEXC
	JRST	RESTR3		;TRANSFER IF IN USER MODE
	CONO	0,@NXM		;CLEAR NXM FLAG
	CONO	@SAVAPR		;RESTORE APR REGISTER
IFE EDDT&SW10X,<	;SORRY, THIS DOESN'T WORK UNDER TENEX
	SKIPGE	SAVAPR		;TEST MOVED NXM FLAG
	MOVES	-1		;SET NXM FLAG
>

	CONO	PRS,@SAVPI
RESTR3:>
	JRST	2,@DDSAVE
SUBTTL BREAK POINT LOGIC

;STILL UNDER EDDT&SWFILE

BP1:	REPEAT	NBP,<	0		;JSR TO HERE FOR BREAKPOINT
	JSA	T, BCOM
	0		;HOLDS INSTRUCTION WHILE BREAKPOINT IS IN PLACE
>

B1INS=BP1+2
BPN=.-3
;STILL UNDER EDDT&SWFILE

BCOM:	0
	POP	T,LEAV		;MOVE INSTRUCTION TO LEAV
	MOVEI	T,B1SKP-B1INS+1(T)
	HRRM	T,BCOM3		;CONDITIONAL BREAK SETUP
	MOVEI	T,B1CNT-B1SKP(T)
	HRRM	T,BCOM2		;PROCEDE COUNTER SETUP
	MOVE	T,BP1-B1CNT(T)	;GET PC WORD
	HLLM	T,LEAV1		;SAVE FLAGS FOR RESTORING
	EXCH	T,BCOM		; ALSO SAVE PC WORD IN BCOM

BCOM3:	SKIPE	B1SKP		;ADDR MOD TO LOOK AT COND. INST.
	XCT	@.-1
BCOM2:	SOSG	B1CNT		;ADDR MOD TO LOOK AT PROCEED COUNTER
	JRST	BREAK

	MOVEM	T,AC0+T
	LDB	T,[POINT 9,LEAV,8]	;GET INSTRUCTION
	CAIL	T,264		;JSR
	CAILE	T,266		;JSA,JSP
	TRNN	T,700		;UUO
	JRST	PROC1		;MUST BE INTERPRETED
	CAIE	T,260		;PUSHJ
	CAIN	T,256		;XCT
	JRST	PROC1		;MUST BE INTERPRETED
IFN EDDT&SW10X,<
	CAIN	T,104		;JSYS
	JRST	PROC1		;MUST BE INTERPRETED
>
IFN EDDT&SWEXEC,<
	MOVSI	T,010000	;DON'T TRY TO RESTORE USER MODE BIT
	ANDCAM	T,LEAV1	>
	MOVE	T,AC0+T
	JRST	2,@LEAV1	;RESTORE FLAGS, GO TO LEAV

LEAV1:	XWD	0,LEAV
;STILL UNDER EDDT&SWFILE

BREAK:	JSR	DDSAVE		;SAVE THE WORLD
	PUSHJ	P,REMOVB	;REMOVE BREAKPOINTS
	PUSHJ	P,TTYCLR	;FLUSH WAITING TTY CHARACTERS FOR INPUT -MCO #D-343
	SOS	T,BCOM3
	HRRZS	T		;GET ADR OF CONDITIONAL BREAK INST
	SUBI	T,B1ADR-3	;CHANGE TO ADDRESS OF $0B
	IDIVI	T,3		;QUOTIENT IS BREAK POINT NUMBER
	HRRM	T,BREAK2	;SAVE BREAK POINT #
	MOVE	W1,[BYTE (7) "$","0","B",76,0]	;PRELIMINARY TYPEOUT MESSAGE
REPEAT 0,<IFN EDDT&SWEXEC,<
	SKPUSR
	TRC	W1,7_^D15	;IN EXEC MODE, TYPE "$NEG"
>>
	SKIPG	@BCOM2		;TEST PROCEED COUNTER
	TRO	W1,76_1		;CHANGE T TO /$0BGG/
	DPB	T,[POINT 4,W1,13]	;INSERT BREAK POINT # IN MESSAGE
	PUSHJ	P,TEXT2
	MOVE	T,BCOM
	HLLM	T, SAVPI	;SAVE PROCESSOR FLAGS
	MOVEI	T,-1(T)
	PUSHJ	P,PAD		;TYPE PC AT BREAK
	HRRZ	T,@BCOM3
	HRRM	T,PROC0		;SETUP ADDRESS OF BREAK
	HLRZ	T,@BCOM3
	JUMPE	T,BREAK1	;TEST FOR REGISTER TO EXAMINE
	PUSHJ	P,LCT		;PRINT TAB
	HLRZ	T,@BCOM3
	PUSHJ	P,LI1		;EXAMINE REGISTER C($NB)LEFT
BREAK1:	MOVSI	S,400000
BREAK2:	ROT	S,.-.		;ROT BY # OF BREAK POINT
	PUSHJ	P,LISTEN	;DONT PROCEED IF TTY KEY HIT
	TDNN	S,AUTOPI	;DONT PROCEED IF NOT AUTOMATIC
	JRST	RET		;DONT PROCEED
	JRST	PROCD1
;STILL UNDER EDDT&SWFILE

PROCED:	TLNN	F,QF		;N$P	;PROCEED AT A BREAKPOINT
	MOVEI	T,1
	MOVEM	T,@BCOM2
	HRRZ	R,BCOM3
	PUSHJ	P,AUTOP
PROCD1:	PUSHJ	P,CRF
PROC0:	HRRZI	R,XEC1		;MODIFIED TO ADDR OF BREAKPOINT
	PUSHJ	P,FETCH
	JRST	BPLUP1		;ONLY GET HERE IF MEMORY SHRANK
	MOVEM	T,LEAV
	PUSHJ	P,INSRTB
	JRST	PROC2

PROC1:	MOVE	T,AC0+T
	JSR	DDSAVE
	JFCL
	MOVE	T,BCOM		;STORE FLAGS WHERE "RESTORE"
	HLLM	T,SAVPI		;  CAN FIND THEM
PROC2:	MOVEI	W,100
	MOVEM	W,TEM1		;SETUP MAX LOOP COUNT
IFN EDDT&SW10X,<
	DPB	W,[POINT 4,MXINST,12] ;ASSUME NO FORCED USER MAPPING WANTED
>
	JRST	IXCT5
;STILL UNDER EDDT&SWFILE

IXCT4:
IFN EDDT&SWEXEC,<	SKPUSR
	JRST	IXCT41		;INIT NOT SPECIAL CASE IN EXEC MODE >
	SUBI	T,041		;IS UUO "INIT"?
	JUMPE	T,BPLUP
	AOJGE	T,IXCT6		;DONT PROCEDE FOR INIT
				;DONT INTERPRET FOR SYSTEM UUOS
IXCT41:	MOVEM	R,40		;INTERPRET FOR NON-SYSTEM UUOS
	MOVEI	R,41
IFN EDDT&SW10X,<
	JRST	.+2
>
IXCT:
IFN EDDT&SW10X,<
	DPB	W1,[POINT 4,MXINST,12] ;REMEMBER ANY FORCED USER MAPPING BITS
>
	SOSL	TEM1
	PUSHJ	P,FETCH
	JRST	BPLUP		;BREAKPOINT LOOPING OR FETCH FAILED
	MOVEM	T,LEAV
IXCT5:	LDB	T,[POINT 9,LEAV,8]	;GET INSTRUCTION
	CAIN	T,254		;DON'T DO ANYTHING TO JRST
	JRST	IXCT6
IXCT51:	HRLZI	17,AC0
	BLT	17,17
IFN EDDT&SW10X,<
	JSR	MAPXCT		;DO FORCED USER MAPPING IF NECESSARY
>
	MOVEI	T,@LEAV
	DPB	T,[POINT 23,LEAV,35]	;STORE EFFECTIVE ADDRESS
	LDB	W1,[POINT 4,LEAV,12]	;PICK UP AC FIELD
	LDB	T,[POINT 9,LEAV,8]	;PICK UP INSTRUCTION FIELD
	MOVEI	P,PS
	CAIN	T,260
	JRST  IPUSHJ		;INTERPRET PUSHJ

	CAIN	T,264
	JRST	IJSR		;INTERPRET JSR
	CAIN	T,265
	JRST	IJSP		;INTERPRET JSP
	CAIN	T,266
	JRST	IJSA		;INTERPRET JSA
	MOVE	R,LEAV
	TRNN	T,700
	JRST	IXCT4		;INTERPRET UUO
	CAIN	T,256
	JRST	IXCT		;INTERPRET XCT
IFN EDDT&SW10X,<
	CAIN	T,104
	JRST	IJSYS		;INTERPRET JSYS
>

IXCT6:	JSP	T,RESTORE
IFN EDDT&SW10X,<
	JSR	MAPXCT		;DO FORCED USER MAPPING IF NECESSARY
>
LEAV:	0			;INSTRUCTION MODIFIED
	JRST	@BCOM
	JRST	.+4		;INSTRUCTION SKIPPED
	JRST	.+2		;+3 RETURN
	AOS	BCOM		;+4 RETURN
	AOS	BCOM
	AOS	BCOM
	JRST	@BCOM

BPLUP:	PUSHJ	P,REMOVB	;BREAKPOINT PROCEED ERROR
BPLUP1:	JSR	DDSAVE
	JFCL
	JRST	ERR
;STILL UNDER EDDT&SWFILE

IPUSHJ:	DPB	W1,[POINT 4,CPUSHP,12]	;STORE AC FIELD INTO A PUSH
	HLL	T,SAVPI		;PICK UP FLAGS
	HLLM	T,BCOM		;SET UP THE OLD PC WORD
	MOVSI	T,(1B4)		;TURN OFF BIS FLAG IN NEW PC WORD
	ANDCAM	T,SAVPI
	JSP	T,RESTORE	;RESTORE THE MACHINE STATE
CPUSHP:	PUSH	.-.,BCOM	;GETS MODIFIED IN AC FIELD
	JRST	@LEAV		;JUMP TO "E" OF THE PUSHJ

IJSA:	MOVE	T,BCOM		;INTERPRET JSA
	HRL	T,LEAV
	EXCH	T,AC0(W1)
	JRST	IJSR2

IJSR:	MOVE	T,BCOM		;INTERPRET JSR
	HLL	T,SAVPI		;SET UP THE OLD PC WORD
	MOVSI	W,(1B4)		;TURN OFF BIS IN NEW PC WORD
	ANDCAM	W,SAVPI
IJSR2:	MOVE	R,LEAV
	PUSHJ	P,DEPMEM
	 JRST BPLUP		;ERROR, CAN'T STORE
	AOSA	T,LEAV
IJSR3:	MOVE	T,LEAV
	JRST	RESTORE

IJSP:	MOVE	W,BCOM		;INTERPRET JSP
	HLL	W,SAVPI		;PICK UP PC WORD FLAGS
	MOVEM	W,AC0(W1)	;INSERT OLD PC WORD INTO AC
	MOVSI	T,(1B4)		;TURN OFF BIS FLAG IN NEW PC WORD
	ANDCAM	T,SAVPI
	JRST	IJSR3

IFN EDDT&SW10X,<		;INTERPRET JSYS
IJSYS:	HRRZ	R,LEAV		;GET EFFECTIVE ADR
IFN EDDT&SWEXEC,<
	SKPEXC
>
	CAIL	R,1000		;USER CALL TO EXEC?
	SKIPA	W1,BCOM		;NO
	JRST	IXCT6		;YES, NO NEED TO INTERPRET
	HLL	W1,SAVPI	;COMPUTE PC WORD
	MOVSI	T,(1B4)		;CLEAR BIS FLAG IN NEW STATE
	ANDCAM	T,SAVPI
IFN EDDT&SWEXEC,<
	CAIL	R,1000		;EX JSYS?
	JRST	.+4		;NO
	MOVSI	T,(1B7)		;YES, SET CALL FROM MONITOR FLAG
	IORM	T,SAVPI
	ADDI	R,1000		;OFFSET TO EX JSYS TABLE
>
	PUSHJ	P,FETCH		;FETCH JSYS DISPATCH WORD
	  JRST	BPLUP		;ERROR, CAN'T FETCH
	HLRZ	R,T		;WHERE TO STORE PC
	EXCH	W1,T		;PC WORD TO T
	PUSHJ	P,DEPMEM	;STORE PC WORD
	  JRST	BPLUP		;ERROR, CAN'T STORE
	MOVE	T,W1		;GET BACK JSYS DISPATCH
	JRST	RESTORE		;RESTORE STATE AND JUMP THERE
>
;STILL UNDER EDDT&SWFILE

;INSERT BREAKPOINTS

INSRTB:	MOVE	S,[JSR BP1]
INSRT1:	SKIPE	R,B1ADR-BP1(S)
	PUSHJ	P,FETCH
	JRST	INSRT3
	MOVEM	T,B1INS-BP1(S)
	MOVE	T,S
	PUSHJ	P,DEPMEM
	 JFCL			;HERE ONLY IF CAN'T WRITE IN HIGH SEG
INSRT3:	ADDI	S,3
	CAMG	S,[JSR BPN]
	JRST	INSRT1
	POPJ	P,

;REMOVE BREAKPOINTS

REMOVB:	MOVEI	S,BNADR
REMOV1:	MOVE	T,B1INS-B1ADR(S)
	SKIPE	R,(S)
	PUSHJ	P,DEPMEM
	 JFCL			;HERE ONLY IF NO WRITE IN HIGH SEG
	SUBI	S,3
	CAIL	S,B1ADR
	JRST	REMOV1
	POPJ	P,		;MCO #D-343
;	JRST TTYCLR		;FLUSH ALL TTY INPUT CHARACTERS MCO #D-343
;STILL UNDER EDDT&SWFILE

;ALL $B COMMANDS GET HERE IN FORM: <A>$<N>B


BPS:	TLZE	F,QF		;HAS <A> BEEN TYPED?
	JRST	BPS1		;YES
	TRZE	F,Q2F		;NO, HAS <N> BEEN TYPED?
	JRST	BPS2		;YES
	MOVE	T,[XWD B1ADR,B1ADR+1]	;NO, COMMAND IS $B - CLEAR ALL BREAKPOINTS
	CLEARM	B1ADR
	BLT	T,AUTOPI	;CLEAR OUT ALL BREAKPOINTS AND AUTO PROCEDE REGESTER
	JRST	RET

BPS1:	MOVE	R,T
	PUSHJ	P,FETCH		;CAN BREAKPOINT BE INSERTED HERE?
	 JRST ERR		;NO
	PUSHJ	P,DEPERR	; AGAIN NO
	TRZN	F,Q2F		;HAS <N> BEEN TYPED?
	JRST	BPS3		;NO
	TRO	F,2		;YES, PROCESS THE COMMAND A$NB
BPS2:	MOVE	T,WRD2
	CAIL	T,1
	CAILE	T,NBP
	JRST	ERR
	IMULI	T,3
	ADDI	T,B1ADR-3
	TRZN	F,2
	JRST	MASK2
	EXCH	R,T
	JRST	BPS5
;STILL UNDER EDDT&SWFILE

BPS3:	MOVE	T,R		;PUT THE BREAKPOINT ADR BACK IN T
	MOVEI	R,B1ADR		;PROCESS THE COMMAND A$B
BPS4:	HRRZ	W,(R)
	CAIE	W,(T)
	SKIPN	(R)
	JRST	BPS5
	ADDI	R,3
	CAIG	R,BNADR
	JRST	BPS4
	JRST	ERR
BPS5:	MOVEM	T,(R)
	CLEARM,1(R)
	CLEARM,2(R)

AUTOP:	SUBI	R,B1ADR		;AUTO PROCEDE SETUP SUBROUTINE
	IDIVI	R,3
	MOVEI	S,1
	LSH	S,(R)
	ANDCAM	S,AUTOPI
	TLNE	F,CCF
	IORM	S,AUTOPI
	POPJ	P,

>	;END EDDT&SWFILE

IFN EDDT&SWFILE,<BPS==<PROCEDE==ERR>>
SUBTTL MEMORY MANAGER SUBROUTINES

;DEPOSIT INTO MEMORY SUBROUTINE

DEPRS:	MOVEM	T,LWT		;DEPOSIT REGISTER AND SAVE AS LWT
	MOVE	R,LLOCO		;QUAN TYPED IN REGIS EXAM
	TLZE	F,ROF
	TLNN	F,QF
	POPJ	P,0
		;CAIL R,DDT
		;CAILE R,DDTEND-1
	PUSHJ	P,DEPMEM	;STORE AWAY
	JRST	ERR		;CAN'T STORE (IN DDT OR OUT OF BOUNDS)
	POPJ	P,		;RETURN

;DEPOSIT INTO MEMORY SUBROUTINE

IFE EDDT&SWFILE,<
DEPSYM:
DEPMEM:
IFE EDDT&SW10X,<
	JSP	TT1,CHKADR	;LEGAL ADDRESS?
	JRST	DEP4		;YES BUT IN HI SEGMENT
>
	TRNN	R,777760
	JRST	DEPAC		;DEPOSIT IN AC
IFN EDDT&SW10X,<IFN EDDT&SWEXEC,<
	SKPUSR
	CONO	@NXM		;CLEAR NXM FLAG
	SETOM	PGTENB		;ENABLE NO-OPING OF PAGER TRAP
>>
	MOVEM	T,(R)
IFN EDDT&SW10X,<IFN EDDT&SWEXEC,<
	SKPUSR
	CONSO	@NXM		;DID THAT GENERATE A NXM
	AOSE	PGTENB		;   OR CAUSE A PAGER TRAP?
	POPJ	P,		;YES, FAIL RETURN
>>
	JRST	CPOPJ1		;SKIP RETURN

DEPAC:	MOVEM	T,AC0(R)	;DEPOSIT IN AC
	JRST	CPOPJ1		;SKIP RETURN

IFE EDDT&SW10X,<
DEP4:	MOVEI	TT1,0
	SETUWP	TT1,		;IS HI SEGMENT PROTECTED? TURN OFF
	POPJ	P,		;PROTECTED, NO SKIP RETURN
	MOVEM	T,(R)		;STORE WORD IN HI SEGMENT
	TRNE	TT1,1		;WAS WRITE PROTECT ON?
	SETUWP	TT1,		;YES, TURN IT BACK ON
	JFCL
	JRST	CPOPJ1		;SKIP RETURN
>
DSYMER:			;DEPOSIT FOR SYM TABLE ROUTINES
DEPERR:
>
DMEMER:	PUSHJ	P,DEPMEM	;DEPOSIT AND GO TO ERR IF IT FAILS
	 JRST ERR
	POPJ	P,
	IFN	EDDT&SWFILE,<
DSYMER:	PUSHJ	P,DEPSYM	;TRY SYMBOL TABLE DEPOSIT
	  HALT	.		;GIVE UP
	POPJ	P,		;AND RETURN

DEPSYM:	PUSH	P,TT		;SAVE TWO LOCATIONS
	PUSH	P,TT1		;  TO PROTECT FILDDT
	MOVE	TT,FISPTR	;GET DEF POINTER
	HLRE	TT1,TT		;GET LENGTH
	SUB	TT,TT1		;COMPUTE END OF SYMBOLS
	TLZ	TT,-1		;CLEAR JUNK
	SKIPL	TT1,FIUPTR	;GET START OF UNDEF SYMBOLS
	MOVE	TT1,FISPTR	;FAILING THAT, GET START OF SYMBOLS
	TLZ	TT1,-1		;CLEAR JUNK
	CAIG	TT1,(R)		;SEE IF TOO LOW
	CAIGE	TT,(R)		;OR TOO HIGH
	HALT	.		;YES--QUIT
	POP	P,TT1		;OK--RESTORE TEMPS
	POP	P,TT		; AND PROCEDE
	CAME	T,(R)		;SEE IF DIFFERENT
	SETOM	CHGSFL		;YES--FLAG THAT SYMBOLS CHANGED
	MOVEM	T,(R)		;STORE NEW VALUE
	JRST	CPOPJ1		;RETURN
DEPMEM:	SKIPN	PATCHS		;SEE IF PATCHING
	JRST	CPOPJ1		;NO--GIVE NOOP
	SKIPN	CRASHS		;SEE IF CRASHING
	JRST	MONPOK		;NO--POKE MONITOR
	PUSH	P,T		;PRESERVE T
	PUSHJ	P,FETCH		;YES--GET WORD
	  JRST	[POP	P,T
		 POPJ	P,]
	POP	P,T		;RESTORE WORD TO STORE
	TLNN	TT2,-1		;SEE IF RESIDENT OR CURRENT WINDOW
	JRST	[CAME	T,RSIDNT(TT2)
		 SETOM	CHGRFL
		 MOVEM	T,RSIDNT(TT2)
		 JRST	DEPRET]
	CAME	T,CURENT(TT2)
	SETOM	CHGFLG
	MOVEM	T,CURENT(TT2)
DEPRET:	JRST	CPOPJ1		;GIVE GOOD RETURN

MONPOK:	PUSH	P,T		;SAVE ARGUMENT
	MOVEM	T,POKER+2	;SET AS NEW VALUE
	HRRZM	R,POKER		;SET ADDRESS
				;NOTE--LAST TYPEOUT IS IN POKER+1
				;  SO THAT USER MUST KNOW WHAT
				;  HE IS CHANGING
	MOVE	T,[3,,POKER]	;GET POINTER
	CALLI	T,114		;POKE. MONITOR
	  JRST	ERR		;COMPLAIN IF WE CAN'T
	POP	P,T		;RESTORE VALUE
	JRST	CPOPJ1		;SKIP RETURN

POKER:	BLOCK	3		;ARGUMENTS FOR POKING
;STILL UNDER EDDT&SWFILE

;HERE WHEN ^Z TYPED TO CLOSE OUT

CNTRLZ:	SKIPE	CRASHS		;SEE IF NOT /M
	SKIPN	PATCHS		;OR NOT /P
	JRST	NOCHNZ		;RIGHT--JUST WRAP UP
	SKIPN	CHGSFL		;SEE IF SYMBOL TABLE CHANGED
	JRST	NOSCPY		;JUMP IF NOT
	PUSHJ	P,SYMPTR	;YES--REFETCH FILE POINTER
	MOVE	W1,FIUPTR	;PREPARE TO
	MOVE	R,T
	JUMPGE	W1,NOUCPY	;JUMP IF NONE
	MOVE	R,TT		;  COPY UNDEF SYMS
OUCPY:	MOVE	T,(W1)
	PUSHJ	P,DMEMER
	AOS	R
	AOBJN	W1,OUCPY

NOUCPY:	HRRZ	T,TT		;GET START
	HLL	T,FIUPTR	;GET NEW LENGTH
	PUSH	P,R		;SAVE START OF SYMBOLS
	HLRZ	R,S		;GET LOCATION POINTER IS KEPT
	PUSHJ	P,DMEMER	;STORE NEW POINTER

	HRRZ	R,(P)		;START AT BEGINNING
	MOVE	W1,FISPTR	;PREPARE TO COPY SYMS
	JUMPGE	W1,NOSCP
OSCPY:	MOVE	T,(W1)
	PUSHJ	P,DMEMER
	AOS	R
	AOBJN	W1,OSCPY

NOSCP:	POP	P,T		;GET START
	HLL	T,FISPTR	;GET NEW LENGTH
	HRRZ	R,S		;GET LOCATION POINTER IS KEPT
	PUSHJ	P,DMEMER	;STORE NEW POINTER
;STILL UNDER EDDT&SWFILE

NOSCPY:	SKIPL	R,RSAVE		;SEE IF CURRENT WINDOW USED YET
	SKIPN	CHGFLG		;YES--SEE IF CHANGED
	JRST	NOCHNX		;NO--PROCEED BELOW
IFN	LN.CUR-200,<
	IMULI	R,LN.CUR/200
>
	USETO	1,1(R)		;POSITION
	OUTPUT	1,CURLST	;WRITE IT
	STATZ	1,740000
	  JRST	[OUTSTR [ASCIZ \? I/O error\]
		 HALT   .-3]
NOCHNX:	SKIPN	CHGRFL		;SEE IF RESIDENT CHANGED
	JRST	NOCHNY		;NO--PROCEED
	USETO	1,1		;YES--POSITION
	OUTPUT	1,RSILST	;WRITE IT
	STATZ	1,740000
	  JRST	[OUTSTR [ASCIZ \? I/O error\]
		 HALT   .-3]

NOCHNY:	CLOSE	1,		;CLOSE OUTPUT
	RELEAS	1,		;CLEAR CHANNEL
NOCHNZ:	CALLI	12		;EXIT WITHOUT RECOURSE
	>
;FETCH FROM MEMORY SUBROUTINE

FETCH:	IFE EDDT&SWFILE,<
IFE EDDT&SW10X,<
	JSP	TT1,CHKADR	;LEGAL ADDRESS?
	JFCL			;HIGH OR LOW OK FOR FETCH
> IFN EDDT&SW10X,<IFN EDDT&SWEXEC,<
	SKPUSR
	CONO	@NXM		;CLEAR NXM FLAG
	SETOM	PGTENB		;ENABLE NO-OPING OF PAGER TRAP
>>
	TRNN	R,777760	;ACCUMULATOR?
	SKIPA	T,AC0(R)	;YES
	MOVE	T,(R)		;NO
IFN EDDT&SW10X,<IFN EDDT&SWEXEC,<
	SKPUSR
	CONSO	@NXM		;DID THAT GENERATE A NXM
	AOSE	PGTENB		;   OR CAUSE A PAGER TRAP?
	POPJ	P,		;YES, FAIL RETURN
>>
	JRST	CPOPJ1		;SKIP RETURN ONLY FOR LEGAL ADDRESS >

IFN EDDT&SWFILE,<	SKIPN CRASHS		;CRASH.SAV EXIST?
	JRST	MONPEK		;NO - GO PEEK AT RUNNING MONITOR
	HRRZ	TT1,R		;STRIP OFF POSSIBLE COUNT
	CAML	TT1,MONSIZ	;IS LOC LARGER THAN FILE?
	POPJ	P,		;YES, ERROR RET
	MOVEI	TT2,(TT1)	;PRESET TT2
	CAIGE	TT2,LN.RES	;SEE IF RESIDENT
	JRST	RSDNT		;YES--GET FROM THERE
	IDIVI	TT1,LN.CUR	;TT1 HAD LOCATION
	CAMN	TT1,RSAVE	;IS LOC INCORE ?
	JRST	INCORE		;TT2=LOC
	EXCH	TT1,RSAVE	;UPDATE MEMORY
	SKIPN	CHGFLG		;SEE IF CHANGED
	JRST	NOCHNG		;JUMP IF NOT
IFN	LN.CUR-200,<
	IMULI	TT1,LN.CUR/200
>
	USETO	1,1(TT1)	;POSITION FOR OUTPUT
	OUTPUT	1,CURLST
	STATZ	1,740000
	  JRST	[OUTSTR [ASCIZ \? I/O error\]
		 HALT   .-3]
NOCHNG:	SETZM	CURENT		;CLEAR BUFFER SINCE MONITOR WON'T
	MOVE	TT1,[CURENT,,CURENT+1]
	BLT	TT1,CURENT+LN.CUR-1
	MOVE	TT1,RSAVE
IFN	LN.CUR-200,<
	IMULI	TT1,LN.CUR/200	;INCLUDE MULTIPLIER  >
	USETI	1,1(TT1)	;BLK 0 DOES NOT EXIST
	INPUT	1,CURLST	;GET 16 BLKS
	STATZ	1,740000
	  JRST	[OUTSTR [ASCIZ \? I/O error\]
		 HALT   .-3]
INCORE:	TLO	TT2,-1		;FLAG CURRENT BLOCK
	SKIPA	T,CURENT(TT2)
RSDNT:	MOVE	T,RSIDNT(TT2)
	JRST	CPOPJ1
MONPEK:	HRRZ	T,R		;REMOVE COUNT
	CALLI	T,33		;DO PEEK UUO
	JRST	CPOPJ1		;RETURN VALUE IN AC T  >
IFE EDDT&SWFILE,<IFE EDDT&SW10X,<
CHKADR:	HRRZ	TT,.JBREL	;GET HIGHEST ADDRESS IN LOW SEGMENT
IFN EDDT&SWEXEC,<
	SKPUSR
	JRST	[CONO 0,@NXM	;IN EXEC MODE, CHECK FOR NXM
		MOVE TT,(R)	;MAKE A TRIAL MEMORY REFERENCE
		CONSO 0,@NXM	;TEST NXM FLAG
		JRST 1(TT1)	;OK- LOW SEGMENT
		POPJ P, ]	;NXM
	>
	CAIL	TT,(R)		;CHECK FOR WITHIN LOW SEGMENT
	JRST	1(TT1)		;ADDRESS IS OK IN LOW SEGMENT, SKIP RETURN
	HRRZ	TT,.JBHRL	;GET HIGHEST ADDRESS IN HIGH SEGMENT
	TRNE	R,400000	;IS THE ADDRESS IN HIGH SEGMENT?
	CAIGE	TT,(R)		;IS THE ADR TOO BIG FOR HIGH SEGMENT?
	POPJ	P,		;NO,YES- ILL. ADR.
	JRST	0(TT1)
>>

IFN EDDT&SWEXEC,<IFN EDDT&SW10X,<
;HERE ON A PAGER TRAP OUT OF DDT
DDTRAP:	DDTRPC,,.+1
	AOSE	PGTENB		;ENABLED FOR SPECIAL HANDLING?
	HALT	DDTX		;NO, HALT (DDT BUGGY OR MESSED UP)
	EXCH	T,777571	;YES, GET TRAP STATUS WORD
	TLNE	T,12		;SKIP IF NEITHER READ NOR XCT ACCESS
	AOS	DDTRPC		;SKIP OVER OFFENDING INST (ALREADY DONE FOR WRITE)
	EXCH	T,777571	;RESTORE T
	JRSTF	@DDTRPC		;DISMISS TRAP (EFFECTIVELY NO-OPING IT)
>>
SUBTTL BINARY TO SYMBOLIC CONVERSION

;	PUSHJ	P,LOOK		;AC T CONTAINS BINARY TO BE INTERPRETED
;	  RETURN 1		;NOTHING AT ALL FOUND THAT'S USEFUL
;	  RETURN 2		;SOMETHING FOUND, BUT NO EXACT MATCH
;	  RETURN 3		;EXACT MATCH FOUND AND PRINTED

LOOK:	MOVEM	T,TEM		;SAVE VALUE BEING LOOKED UP
	PUSHJ	P,SYMSET	;SET UP SYM SEARCH POINTER AND COUNT
	TRZ	F,MDLCLF!PNAMEF	;INIT FLAGS
	TLZ	F,(1B0)		;CLEAR SYMBOL TYPED FLAG
	MOVE	T,TEM		;RESTORE VALUE BEING LOOKED UP
	JUMPGE	R,CPOPJ		;RETURN, NOTHING FOUND

LOOK1:	MOVE	W2,(R)		;GET FLAGS FOR SYMBOL
	TLNE	W2,DELI!DELO	;DELETED?
	JRST	LOOK3		;YES, GET NEXT SYMBOL
	TLNN	W2,PNAME	;PROGRAM NAME?
	JRST	[JUMPE W2,LOOK3	;YES, IGNORE NULL PROGRAM NAMES
		TRO F,PNAMEF	;SET PROGRAM NAME FLAG
		JRST LOOK3]	;GET NEXT SYMBOL
	TLNN	W2,GLOBAL	;NOT PROGRAM NAME. GLOBAL SYMBOL?
	TRNN	F,PNAMEF	;LOCAL SYMBOL. INSIDE SPECIFIED PROGRAM?
	JRST	LOOK5		;CHECK FOR BEST VALUE SO FAR
	CAIL	T,20		;NO OUTSIDE LOCALS LESS THAN 20 - MCO #D-366
	JRST	LOOK5		;OUTSIDE LOCAL .GT. 20, CHECK FOR BEST
LOOK3:	AOBJN	R,.+1
	AOBJN	R,LOOK3A	;ADVANCE POINTER TO NEXT SYM. ANY LEFT?
IFE	EDDT&SWFILE,<
	TRNN	R,1B18		;HIGH SEGMENT SEARCH?
	SKIPL	R,SAVHSM	;NO, SEARCH HIGH SEG TABLE , IF ANY
>
	MOVE	R,@SYMP		;NO, WRAP AROUND END OF TABLE
LOOK3A:	AOJLE	S,LOOK1		;TRANSFER IF MORE SYMBOLS TO LOOK AT
LOOK4:	JUMPGE	F,CPOPJ		;RETURN 1 IF NO GOOD SYMBOLS FOUND
	SUB	T,1(W1)		;SOMETHING FOUND, CALCULATE HOW FAR OFF
	JUMPE	T,LOOK7		;JUMP IF PERFECT (OUTSIDE LOCAL)
	JRST	CPOPJ1		;RETURN 2, SOMETHING FOUND BUT NOT EXACT

LOOK5:	MOVE	W,1(R)		;GET VALUE FROM TABLE
	XOR	W,T		;COMPARE SIGNS
	JUMPL	W,LOOK3		;REJECT IF SIGNS DIFFERENT
	HLRZ	W,SYMOFS	;GET OFFSET LIMIT FOR LOCAL SYMBOLS
	TLNN	W2,GLOBAL	;BUT IF THIS SYMBOL IS GLOBAL,
	TRNN	F,PNAMEF	;  OR IS INSIDE SPECIFIED PROGRAM,
	HRRZ	W,SYMOFS	;THEN USE GLOBAL SYMBOL OFFSET LIMIT
	ADD	W,1(R)		;COMPUTE SYMBOL VALUE UPPER BOUND
	CAML	T,1(R)		;IF VALUE LESS THAN SYMBOL
	CAMLE	T,W		;  OR GREATER THAN SYMBOL+OFFSET,
	JRST	LOOK3		;THEN REJECT
	JUMPGE	F,LOOK6		;TRANSFER IF NOTHING FOUND YET
	MOVE	W,1(R)		;GET VALUE FROM TABLE
	SUB	W,1(W1)		;COMPARE WITH BEST VALUE SO FAR
	TLNN	W2,GLOBAL	;GLOBAL SYMBOL
	TRNN	F,PNAMEF	;  OR INSIDE SPECIFIED PROGRAM?
	TRNN	F,MDLCLF	;YES, AND WAS OLD SYMBOL AN OUTSIDE LOCAL?
	JUMPLE	W,LOOK3		;NO, REJECT IF VALUE WORSE OR SAME
	JUMPL	W,LOOK3		;YES, REJECT IF WORSE BUT KEEP IF SAME
LOOK6:	HRR	W1,R		;SAVE AS BEST VALUES SO FAR
	TLO	F,(1B0)		;SET FLAG SHOWING SOMETHING FOUND
	TLNN	W2,GLOBAL	;GLOBAL SYMBOL
	TRNN	F,PNAMEF	;  OR INSIDE SPECIFIED PROGRAN?
	TRZA	F,MDLCLF	;YES, CLEAR "OUTSIDE LOCAL" FLAG
	TROA	F,MDLCLF	;NO, SET FLAG AND CONTINUE SEARCH
	CAME	T,1(R)		;YES, IS THIS SYMBOL'S VALUE PERFECT?
	JRST	LOOK3		;NO, CONTINUE SEARCH
LOOK7:	PUSHJ	P,SPT0		;MATCHED EXACTLY, TYPE THE SYMBOL
	MOVEI	T,"#"		;PRINT "#" IF OUTSIDE LOCAL
	TRNE	F,MDLCLF
	PUSHJ	P,TOUT
	JRST	CPOPJ2		;DOUBLE SKIP RETURN
CONSYM:	MOVEM	T,LWT
IFN	EDDT&SWFILE,<
	MOVEM	T,POKER+1	;STORE FOR /P/M LOGIC>
	TRNN	F,LF1
	JRST	@SCH		;PIN OR FTOC
	TRNE	F,CF1
	JRST  FTOC

PIN:	TLC	T,700000	;PRINT INSTRUCTION
	TLCN	T,700000
	JRST	INOUT		;IN-OUT INSTRUCTION OR NEG NUM
	AND	T,[XWD 777000,0]	;EXTRACT OPCODE BITS
	JUMPE	T,HLFW		;TYPE AS HALF WORDS
PIN1:	PUSHJ	P,OPTYPE
	TRNE	F,ITF		;HAS INSTRUCTION BEEN TYPED?
	JRST	PIN2		;YES
IFN EDDT&SW10X,<
	MOVE	T,LWT		;NO, TRY FOR FULL-WORD MATCH (E.G. JSYS)
	PUSHJ	P,LOOK
	  JRST	.+3		;NOT THERE
	  JRST	.+2		;NOT EXACT
	POPJ	P,		;FOUND IT (ALREADY TYPED)
>
	MOVSI	T,777000
	AND 	T,LWT
	PUSHJ	P,LOOK		;NO, LOOK IN SYMBOL TABLE
	  JRST	HLFW		;NOTHING FOUND, OUTPUT AS HALFWORDS
	  JRST	HLFW		;NO EXACT MATCH, OUTPUT AS HALFWORDS
PIN2:	  TRO	F,NAF		;EXACT MATCH TYPED, ALLOW NEG ADDRESSES
	PUSHJ	P,TSPC
	LDB	T,[XWD 270400,LWT]	;GET AC FIELD
	JUMPE	T,PI4
	HLRZ	W,LWT
	CAIL	W,(JRST)
	CAILE	W,256777	;IS INST BETWEEN JRST AND XCT?
	JRST	[PUSHJ P,PAD	;NO, PRINT SYMBOLIC AC
		JRST PI3A]
	PUSHJ	P,TOC		;YES, PRINT NUMERIC AC
PI3A:	MOVEI	W1,","
	PUSHJ	P,TEXT
PI4:	MOVE	W1,LWT
	MOVEI	T,"@"
	TLNE	W1,20		;CHECK FOR INDIRECT BIT
	PUSHJ	P,TOUT
	HRRZ	T,LWT
IFN EDDT&SWMAXC,<
	TRNE	F,JMCTF		;DID WE TYPE A JMC MNEMONIC?
	TRZ	T,177B24	;YES, CLEAR JMC INDEX FIELD
>
	LDB	W,[XWD 331100,LWT]	;INSTRUCTION BITS
IFN EDDT&SW10X,<
	CAIN	W,104		;EXEC JSYS?
	CAIL	T,1000
IFE EDDT&SWMAXC,<CAIA>		;NO, TYPE SYMBOLICALLY
IFN EDDT&SWMAXC,<CAIL W,JMCMIN>	;NO, TYPE SYMBOLICALLY UNLESS IT'S A JMC
	JRST	PI4A		;YES, OUTPUT ADDR AS NUMBER
>
	CAIL	W,240
	CAILE	W,247
	JRST	PI8		;ALL (EXCEPT ASH,ROT,LSH) HAVE SYMBOLIC ADRS
PI4A:	TLNN	W1,20
	CAIN	W,<JFFO>_-33
	JRST	PI8		;JFFO AND @ GET SYMBOLIC ADDRESSES
	PUSHJ	P,PADS3A	;ONLY ABSOLUTE ADDRESSING FOR LSH, ASH, AND ROT
PI7:	TRZ	F,NAF	
	LDB	R,[XWD 220400,LWT]	;INDEX REGISTER CHECK
	JUMPE	R,CPOPJ		;EXIT
	MOVEI	T,"("
	PUSHJ	P,TOUT
	MOVE	T,R
	PUSHJ	P,PAD
	MOVEI	T,")"
	JRST	TOUT		;EXIT

PI8:	PUSHJ	P,PAD
	JRST	PI7
HLFW:	REPEAT	0,<	MOVE T,LWT
	CAML	T,[DDTINT SAVPI]
	CAMLE	T,[DDTINT BNADR+2]
	SKIPA
	JRST	PAD>
	HLRZ	T,LWT		;PRINT AS HALF WORDS
	JUMPE	T,HLFW1		;TYPE ONLY RIGHT ADR IF LEFT ADR=0
	TRO	F,NAF		;ALLOW NEGATIVE ADDRESSES
	PUSHJ	P,PAD
	MOVSI	W1,(ASCII /,,/)
	PUSHJ	P,TEXT2		;TYPE ,,
HLFW1:	HRRZ	T,LWT

;PRINT ADDRESSES (ARG USUALLY 18 BITS BUT CAN BE 36 BITS)

PAD:	ANDI	T,-1
	JRST	@AR		;PADSO OR PAD1
PADSO:	JUMPE	T,FP7B		;PRINT A ZERO
	PUSHJ	P,LOOK
	  JRST	PADS3		;NOTHING FOUND, TYPE NUMERIC
	  SKIPA	W2,1(W1)	;SOMETHING FOUND, GET VALUE
	  POPJ	P,		;EXACT MATCH FOUND AND TYPED
IFN EDDT&SW10X,<
	MOVE	W,TEM
	TRNE	F,NAF		;NEGATIVE ALLOWED?
	CAIGE	W,777600	;YES, PRINT NON-EXACT HIGH PSB LOCS NUMERICALLY
>
	CAIGE	W2,60		;PRINT ADRS .LT. 60 NUMERICALLY
	JRST	PADS3		;PRINT ADDRESS NUMERICALLY
	MOVEM	T,TEM
	PUSHJ	P,SPT0
	MOVEI	T,"#"		;LOCAL SYMBOL OUTSIDE CURRENT TABLE?
	TRNE	F,MDLCLF
	PUSHJ	P,TOUT		;YES, SIGNAL WITH "#"
	MOVEI	T,"+"
PADS1A:	PUSHJ	P,TOUT
	HRRZ	T,TEM
PAD1:	JRST	TOC		;EXIT

PADS3:	MOVE	T,TEM
PADS3A:	TRNE	F,NAF
	CAIGE	T,776000
	JRST	TOC
PADS3B:	MOVNM	T,TEM
	MOVEI	T,"-"
	JRST	PADS1A
INOUT:	TDC	T,[XWD -1,400000]	;IO INSTRUCTION OR NEG NUM
	TDCN	T,[XWD -1,400000]
	JRST	PADS3B		;TYPE AS NEG NUM
IFN EDDT&SWMAXC,<
	CAML	T,[<JMCMIN>B8]	;IS IT A JMC?
	JRST	[TLC T,(17, @)	;YES, ARE @ AND AC FIELDS ALL 1'S?
		TLCE T,(17, @)
		JRST PIN1	;NO, PRINT AS NORMAL INST
		JRST HLFW]	;YES, PRINT AS HALFWORDS
>
	LDB	R,[POINT 7,T,9]	;PICK OUT IO DEVICE BITS
	CAIL	R,700_-2	;IF DEVICE .L. 700, THEN TYPE
	JRST	HLFW		;TYPE AS HALF WORDS
	LDB	R,[POINT 3,T,12]
	DPB	R,[POINT 6,T,8]	;MOVE IO BITS OVER FOR OP DECODER
	PUSHJ	P,OPTYPE
	PUSHJ	P,TSPC
	MOVSI	T,077400
	AND	T,LWT
	JUMPE	T,PI4
	PUSHJ	P,LOOK		;LOOK FOR DEVICE NUMBER
	  JRST	INOUT2		;NOTHING FOUND, PRINT AS OCTAL
	  JRST	INOUT2		;NO EXACT MATCH, PRINT AS OCTAL
	  JRST	PI3A		;EXACT MATCH TYPED
INOUT2:	MOVE	T,TEM
	LSH	T,-30
	PUSHJ	P,TOC
	JRST	PI3A

; L,,G$O -- SET OFFSET LIMITS FOR "SYMBOL+N" TYPEOUTS FOR LOCAL AND GLOBAL SYMS
SETOFS:	MOVEI	R,SYMOFS	;REGISTER TO BE SET
	JRST	.+2		;SAME AS MASK LOGIC

; MASK$M -- SET MASK FOR WORD SEARCHES
MASK:	MOVEI	R,MSK		;REGISTER TO BE SET
	TLNE	F,QF
	JRST	MASK1
IFE	EDDT&SWFILE,<
	MOVEI	T,(R)
MASK2:	MOVEI	W,1
	MOVEM	W,FRASE1
	JRST	QUANIN
>
IFN	EDDT&SWFILE,<JRST ERR>
MASK1:	MOVEM	T,(R)
	JRST	RET
SUBTTL SEARCH LOGIC

EFFEC:	TLO	F,LTF
	HRRZ	T,T
WORD:	MOVEI	R,322000-326000	;JUMPE-JUMPN
NWORD:	ADDI	R,326000+40*T	;JUMPN T,
	HRLM	R,SEAR2
	TLZN	F,QF
	JRST	ERR
	SETCAM	T,WRD
	MOVSI	T,FRASE-DEN-1	;PREVENT TYPE OUT OF DDT PARTS
	SETCMM	FRASE(T)
	AOBJN	T,.-1
	MOVE	T,ULIMIT
	TLNE	F,SAF
	TLO	F,QF		;SIMULATE A $Q TYPED
	PUSHJ	P,SETUP
	PUSHJ	P,CRF
SEAR1:	PUSHJ	P,FETCH
	JRST	SEAR2B
	TLNE	F,LTF		;CHECK FOR EFFECTIVE ADDRESS SEARCH
	JRST	EFFEC0
	EQV	T,WRD
	AND	T,MSK
SEAR2:	JUMPE	T,SEAR3		;OR JUMPN T
SEAR2A:	AOS	R,DEFV		;GET NEXT LOCATION
	PUSHJ	P,LISTEN	;ANYTHING TYPED?
	CAMLE	R,ULIMIT	;OR END OF SEARCH?
	JRST	SEARFN		;YES
	JRST	SEAR1		;NO, LOOK SOME MORE

SEAR2B:	MOVEI	R,400000-1	;MOVE UP TO HI SEGMENT
	IORB	R,DEFV		;PUT IN MEMORY TOO
	TRNN	R,400000	;ALREADY IN HI SEGMENT?
	JRST	SEAR2A		;NO
SEARFN:	SETCMM	LWT		;COMPLEMENT BITS BACK AND STOP SEARCH
	JRST	DD1
SEAR3:	MOVE	R,DEFV
	PUSHJ	P,FETCH
	JRST	ERR
	TLZ	F,STF		;GET RID OF SUPPRESS TYPEOUT MODE
	MOVE	T,DEFV
	PUSHJ	P,LI1		;CALL REGISTER EXAMINATION LOGIC TO TYPE OUT
	PUSHJ	P,CRF
	SETCMM	LWT
	SETCMM	TEM
	TRNE F,Q2F		;$NW OR $NE?
	SOSLE WRD2		;YES. COUNT DOWN N
SEAR4:	JRST  SEAR2A
	JRST SEARFN		;COUNTED OUT

EFFEC0:	MOVEI	W,100
	MOVEM	W,TEM
EFFEC1:	MOVE	W,T
	LDB	R,[POINT 4,T,17]	;GET IR FIELD
	JUMPE	R,EFFEC2
	PUSHJ	P,FETCH
	JRST	ERR
	HRRZS	T		;GET RID OF BITS IN LEFT IN ORDER
	ADDI	T,(W)		;  PREVENT AROV WHEN ADDING ADDRESSES
EFFEC2:	HRR	R,T
	TLNN	W,20		;INDIRECT BIT CHECK
	JRST	EFFEC3
	SOSE,TEM
	PUSHJ	P,FETCH
	JRST	SEAR4
	JRST	EFFEC1
EFFEC3:	EQV	T,WRD
	ANDI	T,777777
	JRST	SEAR2
SETUP:	TLNN	F,QF		;QUANTITY TYPED?
	MOVEI	T,777777	;NO, DEFAULT HIGH ADR IS TOP OF MEMORY
	HRRZM	T,ULIMIT	;SAVE LAST ADDRESS OF SEARCH
	HRRZS	R,DEFV		;GET 1ST ADDRESS
	TLNN	F,FAF		;WAS A 1ST ADR SPECIFIED?
	SETZB	R,DEFV		;NO, MAKE IT ZERO
	CAMLE	R,ULIMIT	;LIMITS IN A REASONABLE ORDER?
	JRST	ERR		;NO
	POPJ	P,		;YES, RETURN

ZERO:	TLNN	F,CCF
	JRST	ERR
	PUSHJ	P,SETUP
	HRRZ	S,@SYMP		;GET 1ST ADR OF SYMBOL TABLE
	HLRE	W1,@SYMP	;GET LENGTH OF SYM TABLE
	SUB	W1,S		;GET NEG OF LAST ADR
	MOVNS	W1		;GET POS LAST ADR
	MOVEI	T,0		;0 TO STORE IN MEMORY
ZERO1:	TRNN	R,777760
	JRST	ZEROR		;OK TO ZERO AC'S
IFN EDDT&SWEXEC,<
	SKPUSR
	>
IFN	EDDT&<SWEXEC!SWFILE>,<
	JRST	[CAIGE R,XZLOW
		MOVEI R,XZLOW		;IN EXEC MODE, DON'T ZERO 20-40
		JRST ZERO3 ]	>
IFE	EDDT&SWFILE,<
	CAIGE	R,ZLOW
	MOVEI	R,ZLOW		;DON'T ZERO 20 THRU ZLOW
ZERO3:	CAIL	R,DDTX
	CAILE	R,DDTEND
	JRST	.+2
	MOVEI	R,DDTEND	;DON'T ZERO DDT
	CAML	R,S
	CAMLE	R,W1
	JRST	.+2
	HRRZ	R,W1		;DON'T ZERO SYMBOL TABLE
>IFN EDDT&SWFILE,<ZERO3:>
ZEROR:	CAMLE	R,ULIMIT	;ABOVE LIMITS?
	JRST	DD1		;YES, STOP
	PUSHJ	P,DEPMEM	;DEPOSIT T
IFE	EDDT&SWFILE,<
	 TROA R,377777	;
	AOJA	R,ZERO1
	TRNN	R,400000	;HI SEGMENT?
	AOJA	R,ZERO1		;NO, KEEP GOING
>
	JRST	DD1		;FINISH
IFN	EDDT&SWFILE,<AOJA R,ZERO1>
SUBTTL OUTPUT SUBROUTINES

FTOC:		;NUMERIC OUTPUT SUBROUTINE
TOC:	HRRZ	W1,ODF
	CAIN	W1,10		;IS OUPUT RADIX NOT OCTAL, OR
	TLNN	T,-1		;ARE THERE  NO LEFT HALF BITS?
	JRST	TOCA		;YES, DO NOTHING SPECIAL
	HRRM	T,TOCS		;NO, TYPE AS HALF WORD CONSTANT
	HLRZS	T		;GET LEFT HALF
	PUSHJ	P,TOC0		;TYPE LEFT HALF
	MOVSI	W1,(ASCII /,,/)
	PUSHJ	P,TEXT2		;TYPE ,,
TOCS:	MOVEI	T,.-.		;GET RIGHT HALF BACK
TOCA:	HRRZ	W1,ODF		;IS OUTPUT RADIX DECIMAL?
	CAIN	W1,12
	JRST	TOC4		;YES,TYPE SIGNED WITH PERIOD
TOC0:	LSHC	T,-43
	LSH	W1,-1		;W1=T+1
	DIVI	T,@ODF
	HRLM	W1,0(P)
	SKIPE	T
	PUSHJ	P,TOC0
	HLRZ	T,0(P)
	ADDI	T,"0"
	JRST	TOUT

TOC4:	MOVM	A,T		;TYPE AS SIGNED DECIMAL INTEGER
	JUMPGE	T,TOC5
	MOVEI	T,"-"
	PUSHJ	P,TOUT
TOC5:	PUSHJ	P,FP7		;DECIMAL PRINT ROUTINE
TOC6:	MOVEI	T,"."
	JRST	TOUT

;SYMBOL OUTPUT SUBROUTINE

SPT0:	HRRZM	W1,SPSAV	;SAVE POINTER TO TYPED SYM
SPT:		;RADIX 50 SYMBOL PRINT
	LDB	T,[POINT 32,0(W1),35]	;GET SYMBOL
SPT1:	IDIVI	T,50
	HRLM	W1,0(P)
	JUMPE	T,SPT2
	PUSHJ	P,SPT1
SPT2:	HLRZ	T,0(P)
	JUMPE	T,CPOPJ		;FLUSH NULL CHARACTERS
	ADDI	T,260-1
	CAILE	T,271
	ADDI	T,301-272
	CAILE	T,332
	SUBI	T,334-244
	CAIN	T,243
	MOVEI	T,256
	JRST	TOUT
SYMD:			;$D ;DELETE LAST SYM & PRINT NEW
	HRRZ	R,SPSAV		;PICK UP POINTER TO LAST SYM
	JUMPE	R,ERR
	MOVE	T,(R)		;PICK UP SYMBOL
	TLO	T,DELO		;TURN ON "SUPPRESS OUTPUT" BIT
	PUSHJ	P,DSYMER	;STORE BACK IN SYMBOL TABLE
	MOVE	T,LWT
	JRST	CONSYM		;PRINT OUT NEXT BEST SYMBOL
;FLOATING POINT OUTPUT

TFLOT:	MOVE	A,T
	JUMPGE	A, TFLOT1
	MOVNS	A
	MOVEI	T,"-"
	PUSHJ	P,TOUT
	TLZE	A,400000
	JRST	FP1A
TFLOT1:	TLNN	A, 400
	JRST	TOC5		;IF UNNORMALIZED, TYPE AS DECIMAL INTEGER

FP1:	MOVEI	B,0
	CAMGE	A,FT01
	JRST	FP4
	CAML	A,FT8
	AOJA	B,FP4
FP1A:	MOVEI	C,0

FP3:	MULI	A,400
	ASHC	B,-243(A)
	SETZM	TEM1		;INIT 8 DIGIT COUNTER
	SKIPE	A,B		;DON'T TYPE A LEADING 0
	PUSHJ	P,FP7		;PRINT INTEGER PART OF 8 DIGITS
	PUSHJ	P,TOC6		;PRINT DECIMAL POINT
	MOVNI	A,10
	ADD	A,TEM1
	MOVE	W1,C
FP3A:	MOVE	T,W1
	MULI	T,12
	PUSHJ	P,FP7B
	SKIPE,W1
	AOJL	A,FP3A
	POPJ	P,

FP4:	MOVNI	C,6
	MOVEI	W2,0
FP4A:	ASH	W2,1
	XCT,FCP(B)
	JRST	FP4B
	FMPR	A,@FCP+1(B)
	IORI	W2,1
FP4B:	AOJN	C,FP4A
	PUSH	P,W2		;SAVE EXPONENT
	PUSH	P,FSGN(B)	;SAVE "E+" OR "E-"
	PUSHJ	P,FP3		;PRINT OUT FFF.FFF PART OF NUMBER
	POP	P,W1		;GET "E+" OR "E-" BACK
	PUSHJ	P,TEXT
	POP	P,A		;GET EXPONENT BACK
FP7:	IDIVI	A,12		;DECIMAL OUTPUT SUBROUTINE
	AOS,TEM1
	HRLM	B,(P)
	JUMPE	A,FP7A1
	PUSHJ	P,FP7

FP7A1:	HLRZ	T,(P)
FP7B:	ADDI	T,260
	JRST	TOUT

	353473426555	;1.0E32
	266434157116	;1.0E16
FT8:	233575360400	;1.0E8
	216470400000	;1.0E4
	207620000000	;1.0E2
	204500000000	;1.0E1
FT:	201400000000	;1.0E0
	026637304365	;1.0E-32
	113715126246	;1.0E-16
	146527461671	;1.0E-8
	163643334273	;1.0E-4
	172507534122	;1.0E-2
FT01:	175631463146	;1.0E-1
FT0=FT01+1

FCP:	CAMLE	A, FT0(C)
	CAMGE	A, FT(C)
	Z	FT0(C)

FSGN:	ASCII	.E-.
	ASCII	.E+.
TEXTT:	MOVE	W1,T
TEXT:	TLNN	W1,774000	;LEFT JUSTIFIED UNLESS LEFT CHAR IS NULL
	LSH	W1,35
TEXT2:	MOVEI	T,0		;7 BIT ASCII TEXT OUTPUT SUBROUTINE
	LSHC	T,7
	PUSHJ	P,TOUT
	JUMPN	W1,TEXT2
	POPJ	P,

R50PNT:	LSH	T,-36		;RADIX 50 SYMBOL PRINTER
	TRZ	T,3
	PUSHJ	P,TOC
	PUSHJ	P,TSPC
	MOVEI	W1,LWT		;SETUP FOR SPT
	JRST	SPT

SIXBP:	MOVNI	W2,6		;SIXBIT PRINTER
	MOVE	W1,LWT
SIXBP1:	MOVEI	T,0
	ROTC	T,6
	ADDI	T,40
	PUSHJ	P,TOUT
	AOJL	W2,SIXBP1
IFN EDDT&SWMAXC,<
	JUMPN	W1,SIXBP1	;JMC TYPER ENTERS AT SIXBP1 WITH 0 IN W2
>
	POPJ	P,

CRNRB:	PUSHJ	P,CRN		;TYPE A CARRIAGE RETURN FOLLOWED BY
	MOVEI	T,177		;  A RUBOUT   MCO #D-626
	JRST	TOUT

CRN:	MOVEI	T,15		;CARRIAGE RETURN
	JRST	TOUT


CRF:	PUSHJ	P,CRN
	MOVEI	T,12		;LINE FEED
	JRST	TOUT

LCT:	MOVEI	T,11
IFN EDDT&SWEXEC,<	SKPEXC >
	JRST	TOUT		;IN USER MODE, TYPE A TAB
IFN EDDT&SWEXEC,<
	PUSHJ	P,TSPC
	PUSHJ	P,TSPC >

TSPC:	MOVEI	T,40		;SPACE
	JRST	TOUT
BITO:	TRZN	F,Q2F		;ARG AFTER $?
	JRST	SETOFS		;NO, SET SYMBOL TYPEOUT OFFSET LIMIT
	MOVEI	R,BITT		;BYTE OUTPUT SUBROUTINE
	HRRZI	AR,TOC
	MOVE	T,WRD2
	MOVEM	T,SVBTS
	MOVEI	T,^D36
	IDIV	T,WRD2
	SKIPE	T+1
	ADDI	T,1
	MOVEM	T,SVBTS2
	HRRZ	SCH,R
	JRST	BASE1

BITT:	MOVE	T,SVBTS2
	MOVEM	T,SVBT2
	MOVE	T+1,LWT
	MOVEM	T+1,SVBT3
	PUSH	P,LWT
BITT2:	MOVEI	T,0
	MOVE	T+2,SVBTS
	LSHC	T,(T+2)
	MOVEM	T,LWT
	MOVEM	T+1,SVBT3
	CAIE	AR,PADSO
	PUSHJ	P,TOCA
	CAIE	AR,TOC
	PUSHJ	P,PIN
	SOSG	SVBT2
	JRST	BITT4
	MOVEI	T,","
	PUSHJ	P,TOUT
	MOVE	T+1,SVBT3
	JRST	BITT2

BITT4:	POP	P,LWT
	POPJ	P,

SVBTS:	0
SVBTS2:	0
SVBT3:	0
SVBT2:	0
SUBTTL PUNCH PAPER TAPE LOGIC

IFN EDDT&SWPTP,<IFN EDDT&SWEXEC,<


PUNCH:	SKPEXC
	JRST	ERR		;PAPER TAPE STUFF ILLEGAL IN USER MODE
	TLC	F,FAF+QF
	TLCE	F,FAF+QF
	JRST	ERR		;ONE ARGUMENT MISSING
PUN2:	ADDI	T,1
	HRRZM	T,TEM1
	SUB	T,DEFV
	JUMPLE	T,ERR

PUN1:	MOVEI	T,4		;PUNCH 4 FEED HOLES
	PUSHJ	P,FEED
	TLNE	F,CF		;PUNCH NON-ZERO BLOCKS?
	JRST	PUNZ		;YES
	HRRZ	R,DEFV
	IORI	R,37
	ADDI	R,1
	CAMLE	R,TEM1
	MOVE	R,TEM1
	EXCH	R,DEFV
	MOVE	T,R
	SUB	T,DEFV
	HRL	R,T
	JUMPGE	R,RET		;EXIT OR PUNCH

PBLK:	MOVE	T,R
	SOS	W,T		;INIT CHECKSUM
	PUSHJ	P,PWRD
PBLK1:	PUSHJ	P,FETCH
	JRST	ERR
	ADD	W,T
	PUSHJ	P,PWRD
	AOBJN	R,PBLK1
	MOVE	T,W
	PUSHJ	P,PWRD
	JRST	PUN1
;PUNCH NON-ZERO BLOCKS

PUNZ0:	AOS	DEFV		;LOOK AT NEXT WORD
PUNZ:	HRRZ	W,DEFV		;ENTER HERE - GET STARTING ADDRESS
	MOVE	R,W
	SUB	W,TEM1		;CALCULATE NEGATIVE LENGTH
	HRL	R,W		;SET UP AOBJN POINTER
	JUMPGE	R,RET		;FINISHED?
	CAMG	R,[XWD -40,0]	;BLOCK LONGER THAN 40?
	HRLI	R,-40		;YES, FIX IT UP
	MOVSI	W1,400000	;W1 NEGATIVE MEANS FLUSH 0 WORDS
PUNZ2:	PUSHJ	P,FETCH		;GET WORD FROM MEMORY
	JRST	ERR
	JUMPE	T,[AOJA W1,PUNZ4]	;IF WORD IS 0, INDEX 0 WORD COUNTER
	MOVEI	W1,0		;CLEAR 0 WORD COUNTER
PUNZ4:	JUMPL	W1,PUNZ0	;FLUSH 0 WORD, GET ANOTHER
	CAIL	W1,3		; NOSKIP FOR 3RD 0 WORD AFTER NON 0 WORD
	AOSA	R		;ADVANCE R TO LAST ADR+1
	AOBJN	R,PUNZ2
	ADD	W1,DEFV		;CALCULATE DEFV-R+W1=-WORD COUNT
	SUB	W1,R
	HRLM	W1,DEFV		;PUT -WC IN LEFT HALF OF FA
	EXCH	R,DEFV		;SAVE ADR FOR NEXT BLOCK, GET POINTER
	JRST	PBLK
LOADER:	SKPUSR
	TLNE	F,QF
	JRST	ERR
	MOVEI	T,400
	PUSHJ	P,FEED
	MOVE	R,LOADE
LOAD1:	MOVE	T,0(R)
	PUSHJ	P,PWRD
	AOBJN	R,LOAD1
	MOVEI	T,20
LOAD2:	PUSHJ	P,FEED
	JRST	RET

BLKEND:	SKPEXC
	JRST	ERR
	TLNN	F,QF		;BLOCK END
	MOVE	T,[JRST 4,DDT]
	TLNN	T,777000	;INSERT JRST IF NO OPCODE
	TLO	T,(JRST)
	PUSH	P,T
	MOVEI	T,20
	PUSHJ	P,FEED
	POP	P,T
	PUSHJ	P,PWRD
	PUSHJ	P,PWRD		;EXTRA WORD FOR READER TO STOP ON
	MOVEI	T,400
	JRST	LOAD2

PWRD:	MOVEI	W1,6
PWRD2:	ROT	T,6
	CONSZ	PTPP,20
	JRST	.-1
	CONO	PTPP,50
	DATAO	PTPP,T
	SOJG	W1,PWRD2
	POPJ	P,0

FEED:	CONSZ	PTPP,20
	JRST	.-1
	CONO	PTPP,10
	DATAO	PTPP,FEED1
	SOJN	T,FEED
FEED1:	POPJ	P,0		;ADDRESS USED AS A CONSTANT
LOADB:

PHASE 0			;RIM10B CHECKSUM LOADER
	XWD	-16,0
BEG:	CONO	PTRR,60
	HRRI	AA,RD+1
RD:	CONSO	PTRR,10
	JRST	.-1
	DATAI	PTRR,@TBL1-RD+1(AA)
	XCT	TBL1-RD+1(AA)
	XCT	TBL2-RD+1(AA)
AA:	SOJA	AA,

TBL1:	CAME	CKSM,ADR
	ADD	CKSM,1(ADR)
	SKIPL	CKSM,ADR

TBL2:	JRST	4,BEG
	AOBJN	ADR,RD
ADR:	JRST	BEG+1
CKSM=ADR+1

DEPHASE

LOADE:	XWD	LOADB-.,LOADB
>>	;END OF IFN EDDT&SWPTP
	;FOR PAPER TAPE IO
SUBTTL TELETYPE IO LOGIC

IFN EDDT&SWEXEC,<	;EXECUTIVE MODE TELETYPE I/O

XTIN:	PUSHJ	P,XLISTE	;TELETYPE CHARACTER INPUT
	 JRST .-1
	PUSHJ	P,SPCCHK	;CHECK FOR SPECIAL CHARACTERS
	TRNE	T,140		;DON'T ECHO CR,LF,ALT,TAB,BACK SPACE,ETC
XTOUT:	CAIG	T,04		;DON'T TYPE EOT OR LOWER CHARS
	POPJ	P,
IFN EDDT&SWMAXC,<
;	CAIE	T,15		;CARRIAGE RETURN?
;	JRST	.+4		;NO
;	PUSHJ	P,.+2		;YES, TYPE 6 OF THEM FOR SAKE OF
;	PUSHJ	P,.+1		;   SLOW CARRIAGE
;	PUSHJ	P,.+1		;   RETURN ON TI TERMINAL
>
	HRLM	T,(P)
	IMULI	T,200401	;GENERATE PARITY
	AND	T,[11111111]
	IMUL	T,[11111111]
	HLR	T,(P)
	TLNE	T,10
	TRC	T,200		;MAKE PARITY EVEN
	CONSZ	TTYY,20
	JRST	.-1
	DATAO	TTYY,T
	ANDI	T,177		;FLUSH PARITY
	POPJ	P,0

XLISTE:
IFN EDDT&SWYANK,<
	SKIPE	COMAND		;COMAND FILE?
	JRST	XPTRIN		;YES, READ IT
>
	CONSO	TTYY,40		;NO, LISTEN FOR TTY
	POPJ	P,
	DATAI	TTYY,T
	ANDI	T,177
	JRST	CPOPJ1
XTTYRE:	MOVEI  T,3410
TTY1:	CONI	TTYY,W2		; SAVE TTYY PI
	CONO	TTYY,0		; CLEAR TTYY PI
	ANDI	W2,7
	MOVEM	W2,SAVTTY
	MOVEI	W2,100000
	CONSZ	TTYY,120
	SOJG	W2,.-1
	CONI	TTYY,W2
	IORM	W2,SAVTTY
	DATAI	TTYY,W2
	HRLM	W2,SAVTTY
	CONO	TTYY,(T)
	POPJ	P,
XTTYLE:	MOVE	T,SAVTTY
	TRZ	T,160
	TRO	T,3600
	TRNE	T,10
	TRZ	T,200
	JRST	TTY1

;	TTYCLR==CPOPJ
XTEXIN:	PUSHJ	P,XTIN		;INPUT SUBROUTINE FOR TEXT MODES
	TRNN	T,140
	JRST	XTOUT		;ECHO CHARACTERS (0-37) NOT ECHOED
	POPJ	P,
>
	IFN	EDDT&4,<	;ASSEMBLE WITH OLD DDT MODE IO

TIN:	MOVE	T,POUTBF	;GET NEXT CHARACTER ROUTINE
	CAME	T,[POINT 7,INBFF]
	PUSHJ	P,FINOUT

IFE EDDT&SWFILE,<	ILDB T,PINBFF >
IFN EDDT&SWFILE,<	PUSHJ P,INCHR >

	CAIE	T,176
	CAIN	T,175
	MOVEI	T,33		;CHANGE TO NEW ALT MODE
	CAIN	T,177		;RUBOUT?
	JRST	WRONG		;YES PRINT XXX
	JUMPN	T,CPOPJ
	MOVE	T,[POINT 7,INBFF]
	MOVEM	T,PINBFF
	CALL	T,[SIXBIT /DDTIN/]
	JRST	TIN

TOUT:	JUMPE	T,CPOPJ		;OUT PUT A CHARACTER FLUSH NULLS

IFN EDDT&SWFILE,<	SKIPE COMAND
	JRST	PUTCHR >

	IDPB	T,POUTBF
	CAIE	T,12
	POPJ	P,
TTYLEV:
FINOUT:	MOVEI	T,0
	IDPB	T,POUTBF
	MOVE	T,[POINT 7,INBFF]
	MOVEM	T,PINBFF
	MOVEM	T,POUTBF
	CALL	T,[SIXBIT /DDTOUT/]
	CLEARM	INBFF
	POPJ	P,

PINBFF:	POINT	7,INBFF
POUTBF:	POINT	7,INBFF

TTYCLR=CPOPJ
LISTEN=CPOPJ
INBFF:	BLOCK	21

TTYRET:	MOVE	T,[POINT 7,INBFF]
	MOVEM	T,POUTBF
	MOVEM	T,PINBFF
	CLEARM	INBFF
	POPJ	P,

TEXIN=TIN	;USE NORMAL INPUT FOR TEXT WHEN IN USER MODE
>
	IFE	EDDT&4,<	;ASSEMBLE WITH TTCALL TELETYPE IO

OPDEF TTCALL [51B8]

TEXIN:
IFN EDDT&SWEXEC,<
	ILDB	T,IBTAKR	;RESCANNING INPUT AFTER ^A?
	JUMPN	T,TINX		;ILDB RETURNS 0 IF 0 POINTER OR LAST CHAR
	SETZM	IBTAKR		;NO, ENSURE NO FURTHER RESCAN
	SKPUSR
	JRST	XTEXIN >
TIN:
	ILDB	T,IBTAKR	;RESCANNING INPUT AFTER ^A?
	JUMPN	T,TINX		;ILDB RETURNS 0 IF 0 POINTER OR LAST CHAR
	SETZM	IBTAKR		;NO, ENSURE NO FURTHER RESCAN

IFN EDDT&SWEXEC,<	SKPUSR
	JRST	XTIN >

IFN EDDT&SWYANK,< SKIPE COMAND		;COMMAND FILE?
	PUSHJ	P,PTRIN		;YES>
IFE EDDT&SW10X,<
	TTCALL	0,T		;GET NEXT CHARACTER INTO T
>
IFN EDDT&SW10X,<
	PUSH P,A
	PBIN
	CAIN A,37		;TENEX EOL?
	MOVEI A,15		;YES. MAKE A CR
	MOVE T,A
	POP P,A
>

SPCCHK:	CAIE	T,175
	CAIN	T,176
	MOVEI	T,33		;CHANGE OLD ALT MODES TO NEW
	CAIN	T,177
	JRST	WRONG		;TYPE XXX FOR A RUBOUT
	CAIN	T,CDELCH	;CHARACTER DELETE CHARACTER?
	JRST	TINDEL		;YES (^A IN TENEX, ^H IN 10/50)
TINX:	EXCH	T,IBPUTR	;NO, MAKE SURE NOT OVERFLOWING BUFFER
	CAMN	T,[POINT 7,TINBUF+TINBFS-1,34]
	SETZ	T,		;PREVENT CHAR DELETION AFTER THIS
	EXCH	T,IBPUTR
	IDPB	T,IBPUTR	;SAVE CHAR FOR POSSIBLE RESCAN
	POPJ	P,

TINDEL:	SKIPG	IBPUTR		;ANY CHARACTERS TO DELETE?
	JRST	ERR		;NO (BUFFER EMPTY OR OVERFLOWED)
	MOVEI	T,"\"		;YES, ECHO THE DELETED CHARACTER
	PUSHJ	P,TOUT
	LDB	T,IBPUTR
	CAIN	T,33		;TYPE $ FOR ALTMODE
	MOVEI	T,"$"
	PUSHJ	P,TOUT
	MOVE	T,[POINT 7,TINBUF] ;INITIALIZE RESCAN POINTER
	EXCH	T,IBTAKR
	DPB	T,IBPUTR	;WIPE OUT THE DELETED CHARACTER
	JRST	DD2.5		;START RESCAN OF WHOLE COMMAND
TOUTQ:	SKIPE	IBTAKR		;RESCANNING INPUT AFTER ^A?
	POPJ	P,		;YES, DON'T TYPE

TOUT:

IFN EDDT&SWEXEC,<	SKPUSR
	JRST	XTOUT >

IFN EDDT&SWFILE,<	SKIPE COMAND		;IS THERE A COMMAND FILE?
	JRST	PUTCHR		;YES >

IFE EDDT&SW10X,<
	TTCALL	1,T		;OUTPUT A CHARACTER
>
IFN EDDT&SW10X,<
	PUSH P,A
	MOVE A,T
	PBOUT
APOPJ:	POP P,A
>
	POPJ	P,
LISTEN:
IFN EDDT&SWEXEC,<	SKPUSR
	JRST	XLISTE >
IFE	EDDT&SWFILE,<
IFN EDDT&SWYANK,<
	SKIPE	COMAND
	JRST	PTRIN>>
IFN EDDT&SWFILE,<			;FILDDT?
	SKIPN	COMAND		;STILL READING COMAND FILE?
				; IF YES, DO NOT LOOK FOR INPUT
				; 1. SPEED UP FILDDT AND
				; 2. ALLOW USER TO TYPE AHEAD
				;  (ONE CONTROL C)
>
IFE EDDT&SW10X,<
	TTCALL	2,T		;GET NEXT CHAR, NO IO WAIT
	POPJ	P,		;NO CHARACTER EXISTED, RETURN
	JRST	CPOPJ1		;CHARACTER WAS THERE, SKIP RETURN
>
IFN EDDT&SW10X,<
	SKIPA
	POPJ P,0
	PUSH P,A
	PUSH P,B
	MOVEI A,100
	SIBE
	  SKIPA
	JRST BAPOPJ
	PBIN
	CAIN A,37		;TENEX EOL?
	MOVEI A,15		;YES. MAKE CR
	MOVE T,A
	POP P,B
	POP P,A
	JRST CPOPJ1
BAPOPJ:	POP P,B
	JRST APOPJ
>
IFN EDDT&<SWEXEC!SW10X>,<TTYRET:>
IFN EDDT&SWEXEC,<
	SKPUSR
	JRST	XTTYRET
> IFE EDDT&SW10X,<
	POPJ	P,		;NOTHING TO DO IN 10/50 USER MODE
> IFN EDDT&SW10X,<
	PUSH	P,A		;SAVE AC'S NEEDED TO CALL TENEX
	PUSH	P,B
	PUSH	P,C
	MOVEI	A,100
	RFCOC			;READ CONTROL CHAR ECHO CONTROL
	MOVEM	B,SVFCC1	;SAVE THE DATA
	MOVEM	C,SVFCC2
	MOVE	B,DDTCC1	;SET THE ONES WE WANT IN DDT
	MOVE	C,DDTCC2
	SFCOC
	RFMOD			;READ JFN MODE WORD FOR TTY
	MOVEM	B,SVFMOD	;SAVE IT
	MOVEI	B,77B23+2B25+1B29 ;SET TO WAKEUP ALL, NORMAL ECHO, ASCII
	JRST	STFMOD

DDTCC1:	BYTE(2) 0,0,1,1,1,1,1,2,1,2,2,1,1,2,1,1,1,1
DDTCC2:	BYTE(2) 1,1,1,1,1,1,1,1,1,3,1,1,1,2
>
IFE EDDT&<SWEXEC!SW10X>,<TTYRET==CPOPJ>

TTYCLR:
IFN EDDT&SWEXEC,<	SKPEXC >
IFE EDDT&SW10X,<
	TTCALL	14,		;CLEAR ^O, SKIP ON INPUT CHARS
	  POPJ	P,		;NO INPUT CHARS, OR EXEC MODE
	TTCALL	11,		;FLUSH ALL
	POPJ	P,		;WAITING INPUT CHARACTERS
>
IFN EDDT&SW10X,<
IFN EDDT&SWEXEC,<	SKIPA
			POPJ P,0>
	PUSH P,A
	MOVEI A,100
	CFIBF
	JRST APOPJ
>

IFN EDDT&<SWEXEC!SW10X>,<TTYLEV:>
IFN EDDT&SWEXEC,<
	SKPUSR
	JRST	XTTYLEV
IFE EDDT&SW10X,<
	POPJ	P,		;NOTHING TO DO IN 10/50 USER MODE
> IFN EDDT&SW10X,<
	PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	MOVEI	A,100
	MOVE	B,SVFCC1	;RESTORE OLD CONTROL CHAR ECHO
	MOVE	C,SVFCC2
	SFCOC
	MOVE	B,SVFMOD	;GET SAVED JFN MODE WORD FOR TTY
STFMOD:	SFMOD			;SET IT
	POP	P,C
	JRST	BAPOPJ		;RESTORE B, A, AND RETURN
>
IFE EDDT&<SWEXEC!SW10X>,<TTYLEV==CPOPJ>

>	;END OF IFN EDDT&4
SUBTTL DDT COMMAND FILE LOGIC

;START PAPER TAPE INPUT
IFE EDDT&SWYANK,<TAPIN=ERR>
IFN EDDT&SWYANK,<
TAPIN:
IFN EDDT&SWEXEC,<	SKPEXC			;SKIP IF EXEC MODE
	JRST	UTAPIN		;USER MODE
	CONSO	PTRR,400	;TAPE IN READER?
	JRST	ERR		;NO - ERROR
	SETZM	EPTPTR		;YES. INDICATE START READING IN
	SETOM	COMAND		;SHOW THERE IS A COMMAND FILE
	JRST	RET
>	;END IFN EEDT&1
UTAPIN:
	HIADDR=W		; NEW JOB BOUNDARY(.JBREL)
	CM=17			;CHAN FOR COMMANDS
	INIT	CM,0		; ASCII MODE
	SIXBIT	/DSK/		;ALWAYS ON DEVICE DSK
	XWD	0,CBUF		; ESTABLISH RING HEADER
	JRST	ERR		; NOT ASSIGNED, ERROR
	TLNE	F,QF		;NAME GIVEN?
	SKIPA	T,SYL		;YES. USE IT
IFE	EDDT&SWFILE,<
	MOVE	T,[SIXBIT /PATCH/]	;NO, DEFAULT=PATCH
>
IFN	EDDT&SWFILE,<
	MOVE	T,[SIXBIT /FILDDT/]
>
	MOVEM	T,COMNDS	;SAVE NAME IN LOOKUP BLOCK
	LOOKUP	CM,COMNDS	; LOOKUP CMD FILE(IN CASE DIR DEV)
	JRST	ERR		; NOT FOUND
	MOVE	T,.JBFF		; LOAD .JBFF
	MOVEM	T,SVJBFF	; AND SAVE IT
	HRRZ	T,.JBREL	; LOAD .JBREL
	MOVEI	HIADDR,2000(T)	; NEEDED, NOW PRPARE NEW .JBREL
	IORI	HIADDR,1777	; NEW .JBREL TO ASK FOR
	HRRZ	TT,@SYMP	; BOTTM OF SYM TBL
	HLRE	TT1,@SYMP	; NEG LENGTH
	SUB	TT,TT1		; TOP OF SYMBOL TBL
	MOVEM	TT,.JBFF	; ASSUME THIS NEW .JBFF AND SAVE IT
	SUB	T,TT		; COMPUTE WDS BETWEEN SYM TOP AND .JBREL
	CAILE	T,207		; ENUFF FOR DSK BUFF+FUDGE FACTOR?
	JRST	HAVECM		; YES
	CALLI	HIADDR,11	; NO, GET ANOTHER 1K
	JRST	ERR		; NOT AVIL, TREAT AS NO CMD FILE
HAVECM:	SETOM	COMAND		; FLAG CMD FILE FOUND
	INBUF	CM,1		; 1 BUFFER ONLY
IFN	EDDT&SWFILE,<
	INIT	DP,1		;ALSO DO LISTING FILE
	  SIXBIT /LPT/
	  XWD LBUF,0
	  JRST	[SETZM COMAND
		 JRST  ERR]
	MOVSI	TT,'LST'
	MOVEM	TT,COMNDS+1
	SETZM	COMNDS+3
	ENTER	DP,COMNDS
	  JRST	[SETZM COMAND
		 JRST  ERR]
	OUTBUF	DP,2
	>
	JRST	RET
>	;END IFN EDDT&SWYANK
IFN EDDT&SWYANK,<
IFN EDDT&SWEXEC,<
XPTRIN:	PUSHJ	P,PTRXNX	;GET NEXT CHAR FROM PTR
	 JRST PTRDON		;THROUGH
	JRST	PTRCHR		;PROCESS THE CHAR.
>
PTRIN:	PUSHJ	P,PTRNX		;GET NEXT CHAR
	 JRST PTRDON		;EOF ON COMMAND FILE
PTRCHR:	CAIE	T,177		;RUBOUT?
	SKIPN	TT2,T		;NULL?
	JRST	PTRNXT		;IGNORE IT
IFN EDDT&SWEXEC,<
	SKPEXC			;EXEC MODE?
	JRST	PTRCH2
	CAIE	T,15		;YES. CR?
	JRST	CPOPJ1		;NO. ECHO OF CHAR WILL HAPPEN LATER
	PUSHJ	P,CRN		;YES. ECHO CR-LF
	PUSHJ	P,PTRXNX	;READ (AND IGNORE) NEXT CHAR
	 JFCL			; WHICH OUGHT TO BE A LINE-FEED
	MOVEI	T,15		;RETURN CR AS CHAR
	JRST	CPOPJ1
PTRCH2:		>;END IFN EDDT&SWEXEC
	CAIE	T,33		;ESCAPE?
	CAIL	T,175		;ALT-MODE?
	MOVEI	T,"$"		;YES, ECHO "$"
	PUSHJ	P,TOUT		;ECHO CHAR
	MOVE	T,TT2		;RESTORE T
	JRST	CPOPJ1		;SKIP-RETURN WITH DATA

PTRNXT:
IFN EDDT&SWEXEC,< SKPUSR
	JRST	XPTRIN>
	JRST	PTRIN

;THROUGH WITH  COMMAND FILE
PTRDON:	SETZM	COMAND
	PUSHJ	P,.+1		;2 CR-LFS
	PUSHJ	P,CRF
	POPJ	P,		;NON-SKIP RETURN
;COMMAND FILE IO
PTRNX:	SOSLE	CBUF+2		;DATA LEFT?
	JRST	PTRNX1		;YES
	INPUT	CM,		;GET NEXT BUF
	STATZ	CM,740000	;ERROR?
	HALT	.+1		;TOO BAD
	STATZ	CM,20000	;EOF?
	JRST	PTRNX2		;YES
PTRNX1:	ILDB	T,CBUF+1
	JRST	CPOPJ1		;SKIP-RETURN WITH DATA
PTRNX2:	RELEASE	CM,		;EOF - DONE
IFN	EDDT&SWFILE,<
	CLOSE	DP,
	RELEAS	DP,
>
	MOVE	TT,SVJBFF
	MOVEM	TT,.JBFF	;RESET .JBFF
	POPJ	P,		;NON-SKIP MEANS DONE WITH COMMAND FILE
IFN EDDT&SWEXEC,<
PTRXNX:	SKIPE	TT2,EPTPTR	;DATA IN PTR BUF?
	JRST	PTRXN3		;YES
	MOVE	TT2,[POINT 7,EPTRBF]	;NO SET UP TO STORE IN PTR BUFFER
	SETZM	EPTRBF		;SWITCH FOR END OF TAPE TEST
	CONO	PTRR,20		;START PTR GOING
PTRXN1:	CONSO	PTRR,400	;EOT?
	JRST	PTRXN4		;YES
	CONSO	PTRR,10		;DATA?
	JRST	PTRXN1		;WAIT SOME MORE
	DATAI	PTRR,T		;READ A CHAR
	JUMPE	T,PTRXN1	;IGNORE NULLS
PTRXN2:	IDPB	T,TT2		;SAVE IN DATA BUFFER
	CAIE	T,12		;LF
	CAMN	TT2,EPTRND	; OR BUFFER FULL?
	SKIPA	TT2,[POINT 7,EPTRBF]	;YES. START TAKING CHARS OUT OF BUF
	JRST	PTRXN1		;NO - READ ANOTHER
	CONO	PTRR,0		;SHUT OFF PTR BEFORE READING NEXT CHAR

PTRXN3:	ILDB	T,TT2		;GET A CHAR
	CAIE	T,12		;LF
	CAMN	TT2,EPTRND	; OR END OF BUFFER?
	SETZ	TT2,		;YES, START PTR FOR NEXT CHAR
	MOVEM	TT2,EPTPTR	;SAVE PNTR FOR NEXT CHAR
	JRST	CPOPJ1		;HAVE A CHAR RETURN

;EOT
PTRXN4:	SKIPN	EPTRBF		;ANY DATA?
	POPJ	P,		;NO - DONE RETURN
	SETZ	T,		;YES -  FILL REST OF BUFFER WITH 0'S
	JRST	PTRXN2

EPTPTR:	0
EPTRBF:	BLOCK	5		;BUFFER SO PTR WONT CHATTER
EPTRND:	POINT	7,EPTRBF+4,34	;PNTR FOR LAST CHAR IN BUF
>	;END IFN EDDT&SWEXEC
COMAND:	0
SVJBFF:	0
CBUF:	BLOCK	3
COMNDS:	SIXBIT	/PATCH/
	SIXBIT	/DDT/
	0
	0
>	;END EDDT&SWYANK
IFN EDDT&SWFILE,<
PUTCHR:	SOSLE	LBUF+2		;ANY ROOM?
	JRST	PUTOK		;YES
	OUTPUT	DP,
	STATZ	DP,740000	;ERRORS?
	HALT	.+1		;YES

PUTOK:
	IDPB	T,LBUF+1	;DEPOSIT CHAR.
	POPJ	P,

>	;END OF IFN EDDT&SWFILE
SUBTTL DISPATCH TABLE

BDISP:	POINT	12,DISP(R),11
	POINT	12,DISP(R),23
	POINT	12,DISP(R),35
DISP:	
DEFINE D (Z1,Z2,Z3)<				BYTE (12) Z1-DDTOFS,Z2-DDTOFS,Z3-DDTOFS
	IFN	<<Z1-DDTOFS>!<Z2-DDTOFS>!<Z3-DDTOFS>>&<-1,,770000>,
	<PRINTX Z1, Z2, OR Z3 TOO LARGE FOR DISPATCH TABLE> >
	;THIS MACRO PACKS 3 ADDRESSES INTO ONE WORD; EACH ADR IS 12 BITS

IFN <EDDT&<SWPTP!SWEXEC>>-<SWPTP!SWEXEC>,<	PUNCH==ERR
	BLKEND==ERR
	LOADER==ERR>

D (ERR,ERR,ERR);	(0)
D (CNTRLZ,ERR,ERR);	(3)
D (ERR,ERR,VARRW);	(6)
D (TAB,LINEF,ERR);	(11)
D (ERR,CARR,ERR);	(14)
D (ERR,ERR,ERR);	(17)
D (PUNCH,ERR,ERR);	(22)
D (ERR,ERR,ERR);	(25)
D (ERR,ERR,CNTRLZ);	(30)
D (CONTROL,ERR,ERR);	(33)
D (ERR,ERR,SPACE);	(36)
D (SUPTYO,TEXI,ASSEM);	(41)
D (DOLLAR,PERC,ERR);	(44)
D (DIVD,LPRN,RPRN);	(47)
D (MULT,PLUS,ACCF);	(52)
D (MINUS,PERIOD,SLASH);	(55)
D (NUM,NUM,NUM);	(60)
D (NUM,NUM,NUM);	(63)
D (NUM,NUM,NUM);	(66)
D (NUM,TAG,SEMIC);	(71)
D (FIRARG,EQUAL,ULIM);	(74)
D (QUESTN,INDIRE,ABSA);	(77)
D (BPS,CON,SYMD);	(102)
D (EFFEC,SFLOT,GO);	(105)
D (HWRDS,PILOC,BLKEND);	(110)
D (KILL,LOADER,MASK);	(113)
D (NWORD,BITO,PROCEDE);	(116)
D (QUAN,RELA,SYMBOL);	(121)
D (TEXO,ERR,QUANSW);	(124)
D (WORD,XEC,TAPIN);	(127)
D (ZERO,OCON,ICON);	(132)
D (OSYM,VARRW,PSYM);	(135)

;THIS TABLE DOES NOT HAVE ENTRIES FOR CHARS .GE. 140; THESE
; ARE DETECTED AS ERRORS NEAR L21:
	SUBTTL	OP DECODER

;DESCRIPTION OF OP DECODER FOR DDT:
;
;         THE ENTIRE INSTRUCTION SET FOR THE PDP-6 CAN BE COMPACTED INTO
;A SPACE MUCH SMALLER THAN ONE REGISTER FOR EVERY SYMBOL.  THIS OCCURS
;BECAUSE OF THE MACHINE ORGANIZATION AND INSTRUCTION MNEMONICS CHOSEN
;FOR THE PDP-6.  FOR EXAMPLE, IF BITS (0-2) OF AN INSTRUCTION EQUAL
;101(2) THE INSTRUCTION IS A HALF WORD INSTRUCTION AND AN "H" MAY
;BE ASSUMED. "T" MAY BE ASSUMED FOR ALL TEST INSTRUCTIONS (WHICH
;BEGIN WITH 110(2).
;
;     	THE TABLE TBL IN DDT CONSISTS OF 9 BIT BYTES, 4 TO A WORD.
;THE NUMBERS IN THE BYTES HAVE THE FOLLOWING SIGNIFICANCE:
;0-37(8):	THIS IS A DISPATCH COMMAND FOR THE OP-DECODER INTERPRETER.
;	LET THE RIGHT MOST TWO BITS EQUAL N; LET THE NEXT 3 BITS
;	EQUAL P.
;
;	THE CONTENTS OF INST (INSTRUCTION) CONTAIN IN THE RIGHT
;	MOST NINE BITS THE BINARY FOR THE MACHINE INSTRUCTION.
;	P AND N REFER TO THE CONTENTS OF INST, AND THE OP DECODER
;	WILL PRODUCE AN ANSWER D GIVEN P, N, AND THE CONTENTS
;	OF INSTX N+1 GIVES THE NUMBER OF BITS IN INST; P GIVES THE
;	POSITION (FROM THE RIGHT EDGE) OF THE N+1 BITS.
;
;	EXAMPLE: P = 6
;	         N = 2
;
;;	C(INST) = .010 101 100(2)
;
;	THE RESULT = D = 010(2) = 2(8)
;
;	D IS USED AS A DISPATCH ON THE NEXT BYTES IN THE TABLE.
;	IF D = 5, 5 BYTES IN THE TABLE (DON'T COUNT THE BYTES WHICH
;	PRINT TEXT OR ARE THE EXTEND BYTE, 41-73(8))
;	ARE SKIPPED OVER AND THE 6TH BYTE RESUMES
;	THE INTERPRETATION.
;
;40(8)	THIS IS A STOP CODE; WHEN THIS IS REACHED INTERPRETATION
;	IS FINISHED.
;41(8)-72(8)	THE ALPHABET IS ENCODED INTO THIS RANGE.
;	41- A
;	42- B
;	72- Z
;	WHEN A BYTE IN THIS RANGE IS REACHED, ITS CORRESPONDING
;	LETTER IS TYPED.
;73(8)	THIS IS THE "EXTEND" BYTE. THE NEXT BYTE IN THE TABLE
;	IS A TRANSFER BYTE BUT MUST HAVE THE ADDRESS EXTENDED
;	BY <1000-74*2+FIR.> FIRST.
;
;74(8)-777(8)	THIS IS A TRANSFER BYTE.  IF THE BYTE IN THIS RANGE IS
;	CONSIDERED TO BE A, TRANSFER INTERPRETATION TO THE 
;	<A-74(8)+FIR.>RD BYTE IN THE TABLE.
;
;MACROS ASSEMBLE THE TABLE TBL:
; 1.   A NUMBER FOLLOWED BY ^ ASSEMBLES A DISPATCH BYTE.  THE FIRST
;	DIGIT IS THE POSITION; THE SECOND DIGIT IS THE SIZE.
; 2.   A POINT (.) ASSEMBLES A STOP CODE.
; 3.   A NAME FOLLOWED BY A SLASH ASSEMBLES A TRANSFER TO THE
;	SYMBOLICALLY NAMED BYTE.
; 4.   A STRING OF LETTERS TERMINATED BY A SPACE, COMMA, OR POINT,
;	ASSEMBLE INTO A STRING OF BYTES, EACH BYTE BEING ONE LETTER.
;
;EXAMPLE OF BINARY TO SYMBOLIC DECODING:
;	THE MACHINE CODE FOR JRST IS 254
;		INST    0  1  0  1  0  1  1  0  0
;	THE INTERPRETER STARTS WITH THE FIRST BYTE IN THE TABLE (63^).
;	THE RESULT OF APPLYING THIS TO C(INST) GIVES 2.  SKIPPING OVER
;	2 BYTES IN THE TABLE AND INTERPRETING THE THIRD RESULTS IN
;	HAK/ BEING INTERPRETED.  AT HAK:, THERE IS A 33^.  APPLYING
;	THIS TO C(INST) RESULTS IN 5 NON PRINTING BYTES BEING SKIPPED
;	OVER:
;		1.  MV/
;			MOV	PRINTING TEXT
;		2.  MO/
;		3.  ML/
;		4.  DV/
;		5.  SH/
;
;H1/ IS THE NEXT BYTE INTERPRETER.  AT H1: 03^ IS FOUND SO
;4 BYTES ARE SKIPPED OVER:
;		EXC	PRINTING TEXT
;		1.  S3/
;		BL	PRINTING TEXT
;		T	PRINTING TEXT
;		2.  .
;		3.  AO/
;		4.  AOB/
;		THE NEXT LETTERS JRS ARE TYPED OUT.  THEN T/ IS FOUND.  AT
;T; A T IS TYPED OUT; THEN A "." IS FOUND AND EVERYTHING STOPS.
;
;		THE TABLE IS ALSO USED GOING FROM SYMBOLIC TO BINARY BUT A
;	TREE SEARCH METHOD IS USED.
REPEAT 0,<

DEFINE REDEF (XX)<
DEFINE INFO (AA,BB)<
AA XX'BB>>


DEFINE BYT9 (L)<
;NOTE: THIS DEFINITION DOESN'T HANDLE THE EXTENDED TABLE
XLIST
REDEF %
	ZZ==0
	ZZZ==0
	ZZM==1

	IRPC	L,<
	Z=="L"
	IFE	Z-":",<INFO <>,<==CLOC>
		IFNDEF FIR.,<FIR.==CLOC>
		IFGE CLOC+73-1000-FIR.,<PRINTX OPTABLE TOO LONG>
		Z==0>
	IFE	Z-"/",<IF1 <OUTP 1>
		IF2,<INFO OUTP,+73-FIR.>
		Z==0>
	IFE	Z-"^",<OUTP <ZZ&70/2+ZZ&7-1>
	Z==0>
	IFE	<Z-",">*<Z-".">*<Z-40>,<IFN ZZZ,<
				REPEAT 5,<ZZ==ZZZ&77
					IFN ZZ,<OUTP ZZ>
					ZZZ==ZZZ/100>>
				IFE Z-".",<OUTP 40>
				Z==0>
	IFN	Z,<INFO REDEF,L
	ZZ==ZZ*10+Z&7
	ZZZ==ZZZ+<Z-40>*ZZM
	ZZM==ZZM*100>
	IFE	Z,<REDEF %
	ZZ==0
	ZZZ==0
	ZZM==1>>
LIST>

DEFINE OUTP (A)<
	BINRY==BINRY*400+BINRY*400+A
	BINC==BINC-1
	IFE	BINC,<EXP BINRY
		BINRY==0
		BINC==4>
	CLOC==CLOC+1>
TBL:		;OPDECODER BYTE TABLE

BINRY==0
CLOC==0		;SET BYTE LOCATION COUNTER TO 0
BINC==4		;INIT BYTES/WORD COUNTER

BYT9 <63^UUO/FLO/HAK/ACCP/BOOLE/H HWT/T ACBM/>

;IO INSTRUCTIONS
BYT9 <21^BD/CON,11^OI/S,01^Z/O/>
BYT9 <BD:01^BLK,IO/DATA,IO:11^I/O/OI:01^O/I/>

;UUOS
;NOTE - UNDER TENEX THE UUO'S ARE CLOBBERED BY KILLING THE
;"32^" IN NEXT LINE TO BE A "."
BYT9 <UUO:51^.,32^U40/U50/U60/21^U703/11^USET/01^>
BYT9 <LOOKU,P/ENTE,R/USET:USET,01^I/O/>
BYT9 <U40:03^CAL/INI T/.....,CALL I/>
BYT9 <U60:21^U603/01^IN,BPUT/OUT,BPUT:11^BU,F:F.,PU,T/>
BYT9 <U603:01^U6062/STAT,11^O:O.,Z:Z.,U6062:11^S,U62/G,U62:ETST,S/>

;BYTE AND FLOATING INSTRUCTIONS

BYT9 <FLO:51^BYTE/F 32^ AD A/SB A/MP A/DV A:>
BYT9 <21^LMB/R,IMB/LMB:02^.,L:L.,M:M.,B:B.,BYTE:32^I100/,I110/,I120/,03^UF,PA/DF,N/>
BYT9 <FS C/IB P:P.,I LD/LD:LD B/I DP/DP:DP B/>

;FWT,FIXED POINT ARITH,MISC.

BYT9 <HAK:33^MV/MV:MOV MO/ML/DV/SH/H1/JP/>
BYT9 <21^ADD IMB/SU BIMB:B IMB:02^.,I:I.,M/B/MO:22^>
BYT9 <EIMS:E IMS/S IMS/N IMS/M IMS:02^.,I/M/S:S.,>
BYT9 <ML:21^I ML1/ML1:MUL IMB/DV:21^I DV1/DV1:>
BYT9 <DI DV2:V IMB/H1:03^EXC S3/BL T:T.,AO/AO:AOBJ,>
BYT9 <AOB/JRS T/JFC L/XC T/MA P/AOB:01^P/N/>
BYT9 <JP:03^PU/PU:PUSH PUS/PO/PO:POP POP/JS,R:R.,>
BYT9 <JS P/JS PA:A.,JR PA/PUS:01^J:J..,POP:>
BYT9 <01^.,J/SH:02^A S2/ROT S1/L S2:S S3:H S1/21^JFF O/.,S1:21^.,C:C.,>

;ARITH COMP,SKIP,JUMP

BYT9 <ACCP:42^CA CA1/SJ/A JS/S JS:O 31^>
BYT9 <J COMP/S COMP/CA1:31^I COMP/M COMP/>
BYT9 <SJ:31^JUM PSJ/SKI PSJ:P COMP:>
BYT9 <03^.,L/E:E.,L E/PA/G E/N:N.,G.,>
;HALF WORDS

BYT9 <HWT:51^HW1/21^R HW2/L HW2:R HW3/HW1:>
BYT9 <21^L HW4/R HW4:L HW3:32^IMS/Z IMS/O IMS/EIMS/>

;TEST INSTRUCTIONS

BYT9 <ACBM:31^AC1/01^D AC2/S AC2/AC1:01^R AC2/L,>
BYT9 <AC2:42^N EAN/Z EAN/C EAN/O EAN:12^.,E/PA/N/>


;BOOLEAN

BYT9 <BOOLE:24^ST/AN:AND B2/AN/ST/AN/ST/>
BYT9 <X OR:OR B2/I OR/AN/EQ DV2/ST/OR/ST/OR/OR/>
BYT9 <ST:SET B2:24^Z IMB/IMB/CA:C TA/TM:M IMB/>
BYT9 <CM:C TM/TA:A IMB/IMB/IMB/CB:C BIMB/IMB/CA/>
BYT9 <CA/CM/CM/CB/O IMB/>

;INSTRUCTION GROUP 120
BYT9 <I120:11^ DMOV/ 01^ FIX,FIX2/ 21^.,FLT,FIX2: 21^. R/>
BYT9 <DMOV:DMOV,01^ E,EM// N,EM:21^. M/>

;MORE UUO'S
BYT9 <U50:03^OPE,N/TT,CAL:CAL L/...,RENAM,E/I,N/OU,T/>
BYT9 <U703:02^CLOS,E/RELEA,S/MTAP,E/UGET,F/>

;INSTRUCTION GROUP 100 - TENEX HARDWARE MODS

BYT9 <I100:21^U MV/.>
;ABOVE SHOULD BE <I100:21^U MV/02^JSY S/...> BUT FOR PRECEDENCE
; OF TYPEOUT. FIX TO TYPE FULL-WORD OPS FIRST SOMEDAY.

;INSTRUCTION GROUP 110 - DF ARITHMETIC
BYT9 <I110:21^DF DF// ., DF:02^AD.,SB.,M P/ DV.>

REPEAT BINC,<BINRY==BINRY*400+BINRY*400>
IFN BINRY,<EXP BINRY>
>	;END OF REPEAT 0
DEFINE BYT9 (A) <IRP A,<
A>>

IF1,<

DEFINE	.ADR	(A) <
%'A==	CLOC
FIR.==	CLOC
DEFINE	.ADR	(B) <
%'B==	CLOC
LASTB==CLOC+74-FIR.>>

DEFINE	.TRA (A)<CLOC==CLOC+1>
DEFINE .TRAX (A)<CLOC==CLOC+2>

SYN	.TRA,	.DIS

DEFINE	.TXT	(A) <
IFNB	<A>,	<IRPC A,<CLOC==CLOC+1>>>

DEFINE	.END	(A) <
IFNB	<A>,	<IRPC A,<CLOC==CLOC+1>>
CLOC==	CLOC+1>

>	;END OF IF1
IF2,<

DEFINE .ADR (A)<IFN %'A-CLOC,<PRINTX PHASE ERR AT: %'A>>

DEFINE .TRA (A) <OUTP %'A+74-FIR.>

DEFINE .TRAX (A),<OUTP 73
	OUTP	74+<Z1==%'A-FIR.-1000+74>
	IFL	Z1,<PRINTX "A" TOO SMALL FOR .TRAX>>

DEFINE .DIS (A) <OUTP A&70/2+A&7-1>

DEFINE .TXT (A) <IFNB <A>,<IRPC A,<OUTP "A"-40>>>

DEFINE	.END	(A) <
IFNB	<A>,	<IRPC A,<OUTP "A"-40>>
OUTP	40>

DEFINE OUTP (A)<
IFGE <A>-1000,<PRINTX OPTABLE BYTE "A" TOO BIG>
IFE <BINC==BINC-9>-^D27,<BINR1==A>
IFE BINC-^D18,<BINR2==A>
IFE BINC-9,<BINR3==A>
	IFE	BINC,<	BYTE (9) BINR1,BINR2,BINR3,<A>
	BINC==^D36>
CLOC==CLOC+1 >
>
IFN EDDT&SW10X,<DEFINE .DISQ (A)<.END
>>
IFE EDDT&SW10X,<SYN .DIS, .DISQ
>
TBL:  ;OPDECODER BYTE TABLE

CLOC== 0 ;SET BYTE LOCATION COUNTER TO 0
BINC== ^D36 ;INIT BYTES/WORD COUNTER

;**********THE ARGUMENT FOR THE FOLLOWING "BYT9" MACRO
;**************TERMINATES AT THE NEXT COMMENT WITH: **************

BYT9 <

.DIS 63,.TRA UUO,.TRA FLO,.TRA HAK,.TRA ACCP,.TRA BOOLE
	.TXT H,.TRA HWT,.TXT T,.TRA ACBM


;IO INSTRUCTIONS

.DIS 21,.TRA BD,.TXT CON,.DIS 11,.TRA OI,.TXT S,.DIS 01,.TRA Z,.TRA O
.ADR BD,.DIS 01,.TXT BLK,.TRA IO,.TXT DATA,.ADR IO,.DIS 11,.TRA I,.TRA O
	.ADR OI,.DIS 01,.TRA O,.TRA I
;UUOS

.ADR UUO,.DIS 51,.END,.DISQ 32,.TRA U40,.TRAX U50,.TRA U60
	.DIS 21,.TRAX U703,.DIS 11,.TRA USET,.DIS 01
.TXT LOOKU,.TRA P,.TXT ENTE,.TRA R,.ADR USET,.TXT USET,.DIS 01,.TRA I,.TRA O
.ADR U40,.DIS 03,.TRAX CAL,.TXT INI,.TRA T,.END,.END,.END,.END,.END,.TXT CALL,.TRA I
.ADR U60,.DIS 21,.TRA U603,.DIS 01,.TXT IN,.TRA BPUT,.TXT OUT
	.ADR BPUT,.DIS 11,.TXT BU,.ADR F,.END F,.TXT PU,.TRA T
.ADR U603,.DIS 01,.TRA U6062,.TXT STAT,.DIS 11,.ADR O,.END O,.ADR Z,.END Z
	.ADR U6062,.DIS 11,.TXT S,.TRA U62,.TXT G,.ADR U62,.TXT ETST,.TRA S

;BYTE AND FLOATING INSTRUCTIONS

.ADR FLO,.DIS 51,.TRA BYTE,.TXT F,.DIS 32,.TXT AD,.TRA A,.TXT SB
	.TRA A,.TXT MP,.TRA A,.TXT DV,.ADR A
.DIS 21,.TRA LMB,.TXT R,.TRA IMB,.ADR LMB,.DIS 02,.END
	.ADR L,.END L,.ADR M,.END M
.ADR B,.END B,.ADR BYTE,.DIS 32,.TRAX I100,.TRAX I110,.TRA I120
	.DIS 03,.TXT UF,.TRA PA,.TXT DF,.TRA N
.TXT FS,.TRA C,.TXT IB,.ADR P,.END P,.TXT I,.TRA LD
	.ADR LD,.TXT LD,.TRA B,.TXT I,.TRA DP,.ADR DP,.TXT DP,.TRA B
;FWT-FIXED POINT ARITH-MISC

.ADR HAK,.DIS 33,.TRA MV,.ADR MV,.TXT MOV,.TRA MO,.TRA ML,.TRA DV
	.TRA SH,.TRA H1,.TRA JP
.DIS 21,.TXT ADD,.TRA IMB,.TXT SU,.ADR BIMB,.TXT B,.ADR IMB,.DIS 02,.END
	.ADR I,.END I,.TRA M,.TRA B,.ADR MO,.DIS 22
.ADR EIMS,.TXT E,.TRA IMS,.TXT S,.TRA IMS,.TXT N,.TRA IMS,.TXT M
	.ADR IMS,.DIS 02,.END,.TRA I,.TRA M,.ADR S,.END S
.ADR ML,.DIS 21,.TXT I,.TRA ML1,.ADR ML1,.TXT MUL,.TRA IMB
	.ADR DV,.DIS 21,.TXT I,.TRA DV1
.ADR DV1,.TXT DI,.ADR DV2,.TXT V,.TRA IMB,.ADR H1,.DIS 03,.TXT EXC,.TRA S3,.TXT BL
	.ADR T,.END T,.TRA AO,.ADR AO,.TXT AOBJ
.TRA AOB,.TXT JRS,.TRA T,.TXT JFC,.TRA L,.TXT XC,.TRA T,.TXT MA,.TRA P
	.ADR AOB,.DIS 01,.TRA P,.TRA N
.ADR JP,.DIS 03,.TRA PU,.ADR PU,.TXT PUSH,.TRA PUS,.TRA PO
	.ADR PO,.TXT POP,.TRA POP,.TXT JS,.ADR R,.END R
.TXT JS,.TRA P,.TXT JS,.ADR PA,.END A,.TXT JR,.TRA PA
	.ADR PUS,.DIS 01,.ADR J,.END J,.END,.ADR POP
.DIS 01,.END,.TRA J,.ADR SH,.DIS 02,.TXT A,.TRA S2,.TXT ROT,.TRA S1,.TXT L
	.ADR S2,.TXT S,.ADR S3,.TXT H,.TRA S1,.DIS 21,.TXT JFF,.TRA O,.END
	.ADR S1,.DIS 21,.END,.ADR C,.END C

;ARITH COMP-SKIP-JUMP

.ADR ACCP,.DIS 42,.TXT CA,.TRA CA1,.TRA SJ,.TXT A,.TRA JS,.TXT S
	.ADR JS,.TXT O,.DIS 31
.TXT J,.TRA COMP,.TXT S,.TRA COMP,.ADR CA1,.DIS 31,.TXT I,.TRA COMP,.TXT M,.TRA COMP
.ADR SJ,.DIS 31,.TXT JUM,.TRA PSJ,.TXT SKI,.ADR PSJ,.TXT P,.ADR COMP
.DIS 03,.END,.TRA L,.ADR E,.END E,.TXT L,.TRA E,.TRA PA,.TXT G,.TRA E
	.ADR N,.END N,.END G
;HALF WORDS

.ADR HWT,.DIS 51,.TRA HW1,.DIS 21,.TXT R,.TRA HW2,.TXT L,.ADR HW2,.TXT R,.TRA HW3
.ADR HW1,.DIS 21,.TXT L,.TRA HW4,.TXT R,.ADR HW4,.TXT L
	.ADR HW3,.DIS 32,.TRA IMS,.TXT Z,.TRA IMS,.TXT O,.TRA IMS,.TRA EIMS

;TEST INSTRUCTIONS

.ADR ACBM,.DIS 31,.TRA AC1,.DIS 01,.TXT D,.TRA AC2,.TXT S,.TRA AC2
	.ADR AC1,.DIS 01,.TXT R,.TRA AC2,.TXT L
.ADR AC2,.DIS 42,.TXT N,.TRA EAN,.TXT Z,.TRA EAN,.TXT C,.TRA EAN,.TXT O
	.ADR EAN,.DIS 12,.END,.TRA E,.TRA PA,.TRA N

;BOOLEAN

.ADR BOOLE,.DIS 24,.TRA ST,.ADR AN,.TXT AND,.TRA B2,.TRA AN,.TRA ST,.TRA AN,.TRA ST
.TXT X,.ADR OR,.TXT OR,.TRA B2,.TXT I,.TRA OR,.TRA AN,.TXT EQ
	.TRA DV2,.TRA ST,.TRA OR,.TRA ST,.TRA OR,.TRA OR
.ADR ST,.TXT SET,.ADR B2,.DIS 24,.TXT Z,.TRA IMB,.TRA IMB
	.ADR CA,.TXT C,.TRA TA,.ADR TM,.TXT M,.TRA IMB
.ADR CM,.TXT C,.TRA TM,.ADR TA,.TXT A,.TRA IMB,.TRA IMB,.TRA IMB
	.ADR CB,.TXT C,.TRA BIMB,.TRA IMB,.TRA CA
.TRA CA,.TRA CM,.TRA CM,.TRA CB,.TXT O,.TRA IMB
;INSTRUCTION GROUP 120
.ADR I120,.DIS 11,.TRA DMOV,.DIS 01,.TXT FIX,.TRA FIX2,.DIS 21,.END
	.TXT FLT,.ADR FIX2,.DIS 21,.END,.TRA R
.ADR DMOV,.TXT DMOV,.DIS 01,.TXT E,.TRAX EM,.TXT N
	.ADR EM,.DIS 21,.END,.TRA M

;MORE UUO'S

.ADR U50,.DIS 03,.TXT OPE,.TRA N,.TXT TT,.ADR CAL,.TXT CAL,.TRA L,.END,.END,.END
	.TXT,.TXT RENAM,.TRA E,.TXT I,.TRA N,.TXT OU,.TRA T
.ADR U703,.DIS 02,.TXT CLOS,.TRA E,.TXT RELEA,.TRA S
	.TXT MTAP,.TRA E,.TXT UGET,.TRA F

;INSTRUCTION GROUP 100 - TENEX HARDWARE MODS

.ADR I100,.DIS 21,.TXT U,.TRA MV,.END
;SEE COMMENTS IN FIRST MACRO ABOUT JSYS OP 104

;INSTRUCTION GROUP 110 - DF ARITHMETIC
.ADR I110,.DIS 21,.TXT DF,.TRAX DF,.END,.ADR DF,.DIS 02
	.END AD,.END SB,.TXT M,.TRA P,.END DV

;**********THIS TERMINATES THE "BYT9" MACRO ARGUMENT******
>

IF1,<	BLOCK	<CLOC+3>/4>
	IF2,<	IFN BINC-^D36,<BYTE (9) BINR1,BINR2,BINR3,0> >

IFNDEF CLOC.,<CLOC.==CLOC>
IFN CLOC.-CLOC,<PRINTX PHASE ERROR IN OPTABLE>
PNTR:	EXP	INST		;POINTER TO BITS IN INST
INST:	0		;BINARY FOR INSTRUCTION
CHP:	0		;CHAR POINTER INTO TXT, TXT+1
TXT:	BLOCK	2		;STORE INPUT TEXT FOR OPEVAL
SAVPDL:	0		;SAVE PUSH DOWN LIST POINTER

BTAB:	POINT	9,TBL		;TABLE USED TO GET NEXT BYTE POINTER
	POINT	9,TBL,8		;FOR TRANSFER BYTE
	POINT	9,TBL,17
	POINT	9,TBL,26

OPEVAL:	MOVEI	T,0		;EVALUATE FOR AN OP CODE
	IDPB	T,CHP		;INSERT NULL IN TEXT FOR SYMBOL
	MOVEM	P,SAVPDL
	TRZA	F,OUTF
OPTYPE:	TRO	F,OUTF		;TYPE AN OPCODE SYMBOLICALLY
	TRZ	F,ITF+<IFN EDDT&SWMAXC,<JMCTF>> ;CLEAR INSTRUCTION TYPED FLAGS
IFN EDDT&SWMAXC,<
	HRRZ	W1,T		;IN CASE THIS IS A JMC,
	LSH	W1,-^D11	;   RIGHT-JUSTIFY JMC INDEX
>
	LSH	T,-33
	MOVEM	T,INST		;GET OPCODE INTO RIGHT 9 BITS
IFN EDDT&SWMAXC,<
	CAIL	T,JMCMIN	;ARE WE TYPING OUT A JMC?
	JRST	JMCOUT		;YES, SPECIAL HANDLING
>
	MOVE	T,[XWD 440700,TXT]
	MOVEM	T,CHP		;FOR OPEVAL,SETUP POINTER TO INPUT TEXT
	CLEARB	R,W1
	MOVE	W2,BTAB
DC1:	ILDB	T,W2		;GET NEXT BYTE IN TBL
	CAILE	T,40
	CAIL	T,74
	SOJGE	R,DC1		;SKIP OVER # BYTES = C(R)
	JUMPG	R,DC1		;SKIP OVER ALPHA TEXT (AND EXTEND BYTES) WITHOUT COUNTING
	SUBI	T,40
	JUMPE	T,DECX		;TRANSFER ON ASTOP CODE
	JUMPG	T,DC2
	DPB	T,[XWD 340500,PNTR]	;SETUP R ON A DISPATCH BYTE
	TRZ	T,-4
	AOS	T
	DPB	T,[XWD 300600,PNTR]
	TRNN	F,OUTF
	JRST	DC6		;FOR OPEVAL ONLY
	LDB	R,PNTR		;GET # BYTES TO SKIP OVER
	JRST	DC1

DC2:	HRREI	T,-33(T)	;TOTAL SUBTRACTED NOW IS 73
	JUMPL	T,DECT		;TYPE OUT A LETTER
	JUMPG	T,DC3		;XFER IF BYTE .GE. 74
	ILDB	T,W2		;BYTE IS EXTEND BYTE (73), GET NEXT
	MOVEI	T,1000-74*2+1(T)	; BYTE AND ADD IN EXTENSION (-OFFSET)
DC3:	MOVEI	W1,FIR.-1(T)	;BYTE IS AN XFER (1ST XFER IS 74)
	IDIVI	W1,4
	MOVE	W2,BTAB(W2)	;CALCULATE POINTER TO NEXT BYTE
	ADDI	W2,(W1)
	JRST	DC1
DECT:	TRNE	F,OUTF
	JRST	DC8		;TYPE OUT A LETTER
	ILDB	W1,CHP		;GET NEXT INPUT LETTER
	CAIE	W1,133(T)	;COMPARE WITH ASSUMED NEXT LETTER
	JRST	NOMAT		;DOESNT MATCH
	JRST	DC1		;MATCHES, TRY NEXT

DECX:	TRNE	F,OUTF		;STOP (CODE 40) HAS BEEN SEEN
	POPJ	P,		;IF FOR OUTPUT, RETURN
	ILDB	W1,CHP		;GET NEXT INPUT CHAR IF ANY
	JUMPE	W1,DC7		;DOES # OF CHARS MATCH
NOMAT:	POP	P,R		;NO, BACK UP AND TRY SOME MORE
	POP	P,W2
	POP	P,PNTR
	POP	P,CHP
NOMAT1:	AOS	R		;ASSUME NEXT NUMBER FOR BIN VALUE
	DPB	R,PNTR		;STUFF INTO ANSWER
	LDB	R,PNTR
	JUMPN	R,DC6AA		;IF =0, BYTE WAS TOO BIG
	CAME	P,SAVPDL
	JRST	NOMAT		;NOT AT TOP LEVEL
IFN EDDT&SWMAXC,<	;FOR MAXC, SEARCH JMC TABLE BEFORE GIVING UP
	SKIPA	W1,[POINT 6,R]	;CONVERT THE INPUT STRING TO SIXBIT IN R
	IDPB	W2,W1		;   (WHICH HAPPENS TO BE 0 ON ENTERING HERE)
	ILDB	W2,CHP
	SUBI	W2,40
	JUMPGE	W2,.-3
	MOVSI	T,JMCMIN-1000	;NEG NUMBER OF JMC OPCODES TO LH
JMCSRC:	MOVE	W1,JMCTAB(T)	;FETCH A JMC TABLE POINTER
	TLC	W1,-1		;MAKE AOBJN POINTER
	CAMN	R,(W1)		;IS THIS IT?
	JRST	JMCIN		;YES, GO COMPUTE INSTRUCTION BITS
	AOBJN	W1,.-2		;NO, LOOP THRU JMC SUBOPERATION TABLE
	AOBJN	T,JMCSRC	;LOOP THRU JMC OPCODE TABLE
>
	POPJ	P,		;UNDEFINED, FINALLY

DC6:	MOVEI	R,0		;ASSUME 0 FOR INITIAL BINARY VALUE
	DPB	R,PNTR
DC6AA:	CAMN	P,SAVPDL
	JRST	DC6BB
	LDB	T,-2(P)		;OLD VALUE OF PNTR
	CAME	T,(P)
	JRST	NOMAT1
DC6BB:	PUSH	P,CHP
	PUSH	P,PNTR
	PUSH	P,W2
	PUSH	P,R
	JRST	DC1

DC7:	MOVE	P,SAVPDL	;RESTORE PUSH DOWN POINTER
	MOVE	T,INST
	LSH	T,33		;PUSH BINARY INTO POSITION FOR OPEVAL
	LDB	R,[POINT 3,T,8]
	TLC	T,700000
	TLCN	T,700000
	DPB	R,[POINT 10,T,12]	;ONLY DONE FOR IO INSTRUCTIONS
	JRST	CPOPJ1		;SYMBOL FOUND, SKIP RETURN

DC8:	TRO	F,ITF		;SET INSTRUCTION TYPED FLAG
	MOVEI	T,133(T)
	PUSHJ	P,TOUT		;OUTPUT A LETTER
	CLEARM	SPSAV		;SO $D WONT TRY TO DELETE OP CODES
	JRST	DC1
IFN EDDT&SWMAXC,<
;THE FOLLOWING CODE IS FOR INPUT AND OUTPUT OF JMC (JUMP TO MICROCODE)
;INSTRUCTIONS FOR MAXC.  THIS IS DONE IN A SEPARATE SEARCH WITH A SEPARATE
;TABLE FOR 3 REASONS:
;  (1) THE JMC'S HAVE NO PARTICULAR MNEMONIC ORGANIZATION AS DO PDP-10
;	INSTRUCTIONS AND HENCE THE TREE STRUCTURE OF THE MAIN OPCODE
;	DECODER TABLE WOULD BUY US NOTHING.
;  (2) JMC'S ARE DIFFERENTIATED BY B18-24 OF THE INSTRUCTION, WHICH ARE
;	NOT ACCESSIBLE FROM WITHIN THE OPCODE DECODER LANGUAGE.
;  (3) THE OPCODE DECODER TABLE WOULD PROBABLY OVERFLOW ANYWAY.

;HERE WHEN WE KNOW WE HAVE A JMC TO OUTPUT.  W1 HAS JMC INDEX, T HAS OPCODE
JMCOUT:	TRO	F,ITF+JMCTF	;REMEMBER WE HAVE TYPED A JMC
	SETZM	SPSAV		;SO $D WON'T TRY TO DELETE OPCODES
	MOVE	T,JMCTAB-JMCMIN(T) ;FETCH TABLE POINTER FOR THIS JMC
	HLRZ	W2,T		;GET NUMBER OF DEFINED MNEMONICS
	CAIL	W1,(W2)		;WITHIN RANGE?
	TRZA	F,JMCTF		;NO, CLEAR FLAG AND USE "JMC" OR "UJMC"
	ADDI	T,1(W1)		;YES, INDEX BY JMC SUBOPERATION
	MOVE	W1,(T)		;FETCH SIXBIT MNEMONIC
	JRST	SIXBP1		;PRINT IT AND RETURN FROM OPTYPE

;HERE WHEN INPUT MATCHED A JMC MNEMONIC.  T AND W1 HAVE AOBJN POINTERS
;TO MAIN JMC TABLE AND SUBTABLE ENTRIES RESPECTIVELY.
JMCIN:	SUB	W1,JMCTAB(T)	;COMPUTE JMC INDEX +1
	LSH	W1,2		;SHIFT TO B33
	TRNN	W1,-1		;WAS OFFSET ZERO?
	TRZA	T,-1		;YES, OPCODE WAS "JMC" OR "UJMC"
	HRRI	T,-4(W1)	;NO, INSERT INDEX INTO INSTRUCTION
	LSH	T,^D9		;SHIFT OPCODE TO B8 AND INDEX TO B24
	JRST	CPOPJ1		;SUCCESS RETURN FROM OPEVAL

;JMC OPCODE AND MNEMONIC DEFINITIONS

DEFINE JMCS <
	JMCD	UJMC
	  SJMCD	<RICTR,RTAG,WTAG,RECTR>
	JMCD	JMC
	  SJMCD	<APIL,APIP,API,RPI,CLRIR,IDEV,ALEV,RINT>
	  SJMCD	<IINT,PIOFF,PION,INCP,COMPAT,SIGNAL,PRES,RPIP>
	  SJMCD	<SLOC,MAPOFF,SPLO,CBASE,VCLR,ACLR,PSWIT,KOFF>
	  SJMCD	<KON,KIOFF,KSEEK,IORES,KGO,WABS,RABS,MVA>
	  SJMCD	<WICTR,CHECK,LEVOFF,LEVON,ENLOG,DISLOG,WECTR>
>

DEFINE JMCD(OP) <
	N%'OP ,, J%'OP
>
DEFINE SJMCD(LIST) <>

JMCTAB:	JMCS

	JMCMIN==1000-<.-JMCTAB>	;OPCODE OF SMALLEST JMC

DEFINE JMCD(OP) <
J%'OP:	SIXBIT	/OP/
	N%'OP==	0
DEFINE SJMCD(LIST) <IRP LIST <
	SIXBIT	/LIST/
	N%'OP==	N%'OP+1
>>>

	JMCS
> ;END OF CONDITIONAL ON EDDT&SWMAXC
LIT
SUBTTL VARIABLE STORAGE

WRD:	0
WRD2:	0
PRNC:	0

FRASE:	0	;DONT CHANGE ORDER, SEE  SEARC+3
SYL:	0
LWT:	0
TEM2:	0
FRASE1:
TEM3:	0
DEN:	0

SAVHSM:	BLOCK	1		;C(.JBHSM), USED BY EVAL, LOOK
SEGNAM:	0		;THE HIGH SEGMENT NAME (OR 0)
				;WHEN $: IS SUCCESSFULLY DONE
PRGM:	0
ESTUT:	0
FSV:	0
FH:	0
SYM:	0
IFE	EDDT&SWFILE,<
SYMP:	Z	.JBSYM		;POINTS TO LOW SEG SYM TABLE POINTER
USYMP:	Z	.JBUSY		;POINTS TO UNDEF SYM TABLE POINTER
>
IFN	EDDT&SWFILE,<
SYMP:	Z	FISPTR
USYMP:	Z	FIUPTR
>
SYMPNT:	0	;USED BY SYM TABLE SEARCHES
SPSAV:	0	;POINTER TO LAST SYMBOL TYPED
DEFV:	0
ULIMIT:	0
LLOC:	0
LLOCO:	0
SAVLOC:	0		;THE ADR OF OLD REGISTER EXAMINATION SEQUENCE
SYMORD:	0	;HOLDS ADDRESSES OF EVAL-OPEVAL ROUTINES
		;SPECIFYING WHICH ORDER TO SEARCH THEM FOR SYMBOLS
QLPNT:	0	;USED IN "QLIST" AS POINTER TO A SYMBOL
SYMOFS:		;MAXIMUM LOCAL,,GLOBAL OFFSETS FOR "SYMBOL+N" TYPEOUT
	IFE EDDT&<SWEXEC!SWFILE>,<0,,77>
	IFN EDDT&<SWEXEC!SWFILE>,<0,,777>

TINBUF:	BLOCK	TINBFS		;TYPEIN BUFFFER FOR RESCAN AFTER CHAR DELETE
IBPUTR:	0	;BYTE PTR TO PUT CHARS IN BUFFER
IBTAKR:	0	;BYTE PTR TO TAKE CHARS FROM BUFFER
	IFE	EDDT&SWFILE,<
SAVAPR:	0		;USED TO SAVE APR REGISTER IN EXEC MODE
SAVPI:	0
IFE EDDT&SWMAXC,<1177>		;TURN OFF ALL PI CHANNELS ON PDP-10
IFN EDDT&SWMAXC,<400>		;TURN OFF PI SYSTEM ON MAXC
SAVTTY:	0
IFN EDDT&SWEXEC,<IFN EDDT&SW10X,<
SAVTRP:	0		;SAVES PAGER TRAP INSTRUCTION WHILE IN DDT
DDTRPC:	0		;PC OF TRAP FROM DDT
PGTENB:	0		;-1 TO SKIP OVER NEXT INST CAUSING A TRAP
TSWSVF:	0		;-1 IF TSW AND WRITE DATA HAVE BEEN SAVED
SAVTSW:	0		;SAVES 777571 (TRAP STATUS WORD)
	0		;SAVES 777572 (TRAP WRITE DATA)
>>
IFN EDDT&SW10X,<
SVFMOD:	0		;SAVES JFN MODE WORD FOR TTY
SVFCC1:	0		;SAVES FIRST TTY CONTROL CHAR WORD
SVFCC2:	0		;SAVES SECOND TTY CONTROL CHAR WORD
>
SKPCNT:	0		;INSTRUCTION SKIP COUNTER
	>
MSK:	XWD	-1,-1
IFE	EDDT&SWFILE,<
B1ADR:	0
B1SKP:	0
B1CNT:	0

REPEAT NBP*3-3, <	0>

BNADR=.-3
AUTOPI:	0

AC0:	BLOCK	17

AC17:	0
>

SCHM:	EXP	PIN		;DO NOT CHANGE ORDER
ARM:	EXP	PADSO
ODFM:	EXP	10

SARS:	0
TEM:	0
TEM1:	0
IFN EDDT&SWEXEC,<
USRFLG:	0	;-1 IN USER MODE, 0 IN EXEC MODE
KAFLG:	0	;0 FOR KI10; 1,,0 FOR KA10 OR PDP-6
NXM:	0	;KA10 NXM FLAG, OR KI10 NXM FLAG
>
IFN EDDT&SW10X,<
; ROUTINE TO PERFORM ANY NECESSARY FORCED USER MAPPING FOR INSTRUCTION
; SIMULATION.  SET AC BITS (9-12) IN MXINST FOR DESIRED MAPPING, THEN:
;	JSR	MAPXCT
;	  THE INSTRUCTION TO BE EXECUTED
;	+1, +2, +3 RETURNS FROM INSTRUCTION

MAPXCT:	0
	EXCH	T,MAPXCT	;SAVE T, GET PC
	HRRM	T,MXINST	;PUT ADR OF INST IN RH OF XCT INST
	ADDI	T,4		;PRESET +4 RETURN
	HRRM	T,MAPXCR
	HRRI	T,.+2		;RESTORE FLAGS (JSR CLOBBERS BIS)
	JRSTF	(T)
	MOVE	T,MAPXCT	;RESTORE T
MXINST:	XCT	0,0		;AC SET BY CALLER, E SET ABOVE
	  SOS	MAPXCR		; +1 RETURN
	  SOS	MAPXCR		; +2 RETURN
	  SOS	MAPXCR		; +3 RETURN
MAPXCR:	JRST	0		;RETURN (E SET ABOVE).  **NOT** JRSTF!
>
IFN EDDT&SWFILE,<			;FILDDT STUFF
FWAZER:!		;START OF AREA TO ZERO
FILDEV:	BLOCK	3		;OPEN BLOCK FOR CRASH FILE
FILBLK:	BLOCK	4		;LOOKUP BLOCK FOR CRASH FILE
LBUF:	BLOCK	3
SYMGET:	Z			;-1 IF /S, 0 IF NOT
CRASHS:	Z			;-1 IF CRASH.SAV ON DISK ,0 IF PEEK AT MONITOR
FDIDOT:	Z			;-1 IF . TYPED IN, 0 IF NOT
PATCHS:	Z			;-1 IF PATCHING MODE
CHGFLG:	Z			;CHANGED CURRENT WINDOW
CHGRFL:	Z			;CHANGED RESIDENT BLOCK
CHGSFL:	Z			;CHANGED SYMBOL TABLE
AC0=.
AC17=.+17
RSIDNT:	BLOCK	LN.RES		;LOCS 0-777 ALWAYS IN CORE
CURENT:	BLOCK	LN.CUR		;WINDOW TO THE FILE ON DISK
RSAVE:	BLOCK	1		;INDEX OF THE CURRENT BLOCK. 0,1,...
LWAZER==.-1		;END OF AREA TO ZERO

FISPTR:	Z			;POINTER TO SYMBOLS
FIUPTR:	Z			;POINTER TO UNDEF SYMS

RSILST:	IOWD	LN.RES,RSIDNT
	Z
CURLST:	IOWD	LN.CUR,CURENT
	Z
MONSIZ:	BLOCK	1		;HIGHEST LOC+1 IN CRASH.SAV FILE
				;(USED SO WE WON'T EXAMINE PAST END)
SAVEFF:	Z			;WHERE TO LOAD SYMBOLS IF /S
>
PS:	BLOCK	LPDL		;STORAGE FOR PUSH DOWN LIST

DDTEND:		;ONLY STARTING ADDRESS FOR FILDDT
		;NO START ADDRESS FOR EXEC OR USER DDT
		;BECAUSE USER PROGRAMS AND MONITOR ARE LOADED
		;WITH EXEC OR USER DDT
		;BUT STILL WANT TO BE STARTED AT THEIR OWN START ADDRESSES
IFN EDDT&SWFILE,<END DDT>
	END
