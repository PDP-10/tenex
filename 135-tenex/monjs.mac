;<FOONEX>MONJS.EDC-GAH;3 25-Nov-81 11:31:10, Edit by ECARTER
;CHANGED CUTOFF TO BE EXTERNAL,DEFINED IN SCHED
;<FOONEX>MONJS.EDC-GAH;2 12-Nov-81 14:59:58, Edit by ECARTER
;REMOVED KAFLG ETC CONDITIONALS
;<FOONEX>MONJS.EDC;18  6-Nov-81 16:30:12, Edit by ECARTER
;ADDED WSPFLG, ASSEMBLE REFERENCES JOBWSP TABLE IF ON
;<FOONEX>MONJS.EDC;9 29-Oct-81 12:09:54, Edit by ECARTER
;ADDED WATCH TO .OPRFN
;<EDCMON>MONJS.MAC;2  8-Oct-81 10:04:01, Edit by ECARTER
;ADDED SUPERW,JOBWSP GETAB TABLES
;<FOONEX>MONJS.MAC;86 30-Jul-81 10:58:38, Edit by FRENCH
;ADD WORDS TO FDFMTF TABLE
;<FOONEX>MONJS.MAC;85 29-Jul-81 15:11:58, Edit by FRENCH
;USE JOBNM2 INSTEAD OF SNAMES IN WHRUS
;<FOONEX>MONJS.MAC;83 27-Jul-81 18:28:28, Edit by FRENCH
;HACK UP SETNM JSYS FOR ACCEPT JOB # IN AC 3
;<FOONEX>MONJS.MAC;79 27-Jul-81 15:15:41, Edit by FRENCH
;ADDED .WHRUS
;<FOONEX>MONJS.MAC;78 24-Jul-81 12:31:06, Edit by FRENCH
;ADD FLAGS AND PACK # TO HSYST5 BUT DON'T BOUT IT TO HSYS.TIMES
;INCREASE LEN OF NTHOST GETAB TO INCLUDE TYMFLG
;<FOONEX>MONJS.MAC;76 19-Jun-81 12:00:54, Edit by FRENCH
;ADDED PTYPTR
;<FOONEX>MONJS.MAC;69 12-Jun-81 12:40:02, Edit by FRENCH
;ADD OPRSPY OPRFN FUNCTION
;<FOONEX>MONJS.MAC;68  3-Jun-81 16:00:57, Edit by FRENCH
;ADDED DIRPAR GETAB TABLE
;<FOONEX>MONJS.MAC;66 21-May-81 10:40:19, Edit by FRENCH
;ADD HOSTST GETAB AND RELATED GHSTST ROUTINE FOR REAL HSTSTS
;<FOONEX>MONJS.MAC;65 20-May-81 17:35:24, Edit by FRENCH
;ADD NETHST GETAB TABLE
;<FOONEX>MONJS.96;4 20-May-81 15:20:30, Edit by FRENCH
;ADD IMPLT5 AND HOSTNN GETAB, GIVE NLHOST INSTEAD OF NOHOST FOR LHOSTN GETAB
;<FOONEX>MONJS.MAC;63    28-Apr-81 18:31:32    EDIT BY FRENCH
;CHANGE DSKRCE TO DSKNRE
;<FOONEX>MONJS.MAC;62 10-Feb-81 11:21:55, Edit by FRENCH
;UP NTHOST GETAB # WORDS TO INCLUDE DEFAULT AUX CIR NAME
;<FOONEX>MONJS.MAC;61  6-Feb-81 11:23:29, Edit by FRENCH
;ADDED SCDRN1 AND SCDRN2 TO OPRFN STUFF
;<FOONEX>MONJS.MAC;60  6-Feb-81 10:20:27, Edit by FRENCH
;REMOVE PATVEC
;<FOONEX>MONJS.MAC;56 28-Jan-81 16:50:45, Edit by FRENCH
;USE PATVEC
;<FOONEX>MONJS.MAC;55 23-Jan-81 11:33:52, Edit by FRENCH
;USE CONNECTED DIR PA1050.SAV IF EXISTS IN GETPAT
;<FOONEX>MONJS.MAC;54    15-Jan-81 18:51:54    EDIT BY SYSTEM
;ADD RLDRSN TO GETAB TABLE
;<FOONEX>MONJS.MAC;50  2-Jan-81 23:35:35, Edit by FRENCH
;ADDED FDDTSW SETTING VIA OPRFN
;<FOONEX>MONJS.MAC;49 21-Dec-80 19:16:13, Edit by FRENCH
;ADDED RELDW AND CDMPSW SETTING VIA OPRFN
;DSK:<FOONEX>MONJS.MAC;46 28-Jul-80 14:43:25, Edit by FRENCH
;ADDED OPRBTI SO CHKDSK CAN INIT DSKBIT WITHOUT DSKAS CROCK
;DSK:<FOONEX>MONJS.MAC;44 23-Jul-80 15:12:53, Edit by FRENCH
;ADDED OPRBAT
;DSK:<FOONEX>MONJS.MAC;39 17-Jul-80 11:19:51, Edit by FRENCH
;ADDED MON2US AND US2MON OPRFN FUNCTIONS
;<FOONEX>MONJS.MAC;37    18-Jun-80 08:30:44    EDIT BY LYNCH
; ADDED TYMNET ON, OFF OPRFN
;DSK:<FOONEX>MONJS.MAC;36  4-Jun-80 14:16:40, Edit by FRENCH
;ADDED HOMBAT GETAB TABLE, REMOVED DUPLICATE FDFMTF TABLE ENTRY
;DSK:<134-TENEX>MONJS.MAC;35 27-May-80 16:22:48, Edit by PETERS
; New SYSGT and GETAB and GTBLT for funny GETAB entries
;DSK:<134-TENEX>MONJS.MAC;34 21-May-80 20:21:42, Edit by PETERS
; Made GETAB changes to support new IMPDV and NETWRK
;<134-TENEX>MONJS.MAC;33    14-Apr-80 08:34:40    EDIT BY LYNCH
; MADE DEMO HACK JUST GIVE "CUTOFF" PERCENT OF THE MACHINE
; INSTEAD OF HAVING IT PLAY AROUND ON QUEUE 1.
;DSK:<134-TENEX>MONJS.MAC;32  2-Apr-80 11:59:51, Edit by RKNIGHT
; Add LLORCA as GETABable table.
;DSK:<134-TENEX>MONJS.MAC;31 14-Mar-80 15:52:44, Edit by PETERS
; Fix TTYCHS to be in GETAB symtab also
;DSK:<134-TENEX>MONJS.MAC;30  5-Mar-80 15:30:12, Edit by RKNIGHT
; Added TTYCHS for GETAB.
;DSK:<134-TENEX>MONJS.MAC;29 13-Feb-80 18:55:40, Edit by FRENCH
;CHANGE DSKRCT TO DSKRCE IN GETAB TABLES
;<134-TENEX>MONJS.MAC;28    27-Jan-80 18:30:25    EDIT BY PETERS
; Fix F3AFLG to F3FLG
;DSK:<PEFMON>MONJS.MAC;1 31-Dec-79 12:06:54, Edit by FRENCH
;ADD FAKING OF SOME GETAB TABLES FOR GATEWAY FAKEOUT.
;<134-TENEX>MONJS.MAC;25    19-Nov-79 16:26:22    EDIT BY PETERS
;Added sysmem getab entry
;<134-TENEX>MONJS.MAC;24    16-Sep-79 17:55:56    EDIT BY PETERS
;<134-TENEX>MONJS.MAC;23     9-Apr-79 17:59:33    EDIT BY PETERS
;<134-TENEX>MONJS.MAC;22     8-Sep-78 17:03:20    EDIT BY PETERS
;<134-TENEX>MONJS.MAC;21     5-Sep-78 18:24:29    EDIT BY PETERS
;<134-TENEX>MONJS.MAC;20     5-Sep-78 13:35:25    EDIT BY PETERS
;<134-TENEX>MONJS.MAC;19     1-Sep-78 19:40:42    EDIT BY PETERS
;<134-TENEX>MONJS.MAC;18    13-DEC-77 17:16:40    EDIT BY PETERS
;<134-TENEX>MONJS.MAC;17    27-Jun-77 12:44:53    EDIT BY MMCM
;1 Added TOPS20 format .GET from ISI
;<134-TENEX>MONJS.MAC;16    22-Mar-77 22:59:53    EDIT BY LYNCH
; TOOK OUT PDP-15
;<134-TENEX>MONJS.MAC;15    10-Feb-77 19:20:57    EDIT BY SYSTEM
; FIXED TYPE FOR CALLI STUFF.
;<134-TENEX>MONJS.MAC;14     7-Oct-76 23:03:40    TVEDIT'd by Geoff
; Put in the BBN code so programs can figure out what type of system the'r on.
;<134-TENEX>MONJS.MAC;13	27-Sep-76 13:04:30	Edit by DANG
;  Deleted SETNT code
;<134-TENEX>MONJS.MAC;12    13-MAY-76 09:43:02    EDIT BY LYNCH
;ADDED FDFMTF ENTRY TO GTTAB,SYMTAB
;<134-TENEX>MONJS.MAC;11    21-APR-76 14:58:04    EDIT BY LYNCH
; TOOK OUT GUTS OF CPUTL JSYS TO WAIT TO GET ED TAFT'S OLD CODE
;<134-TENEX>MONJS.MAC;10    19-APR-76 14:23:48    EDIT BY UNTULIS
;REDID ASGDSH CODE FOR SRI
;<134-TENEX>MONJS.MAC;6    24-FEB-76 13:45:29    EDIT BY UNTULIS
;CHANGE UPDUT CALL TO GRPT
;<134-TENEX>MONJS.MAC;2    11-FEB-76 17:25:54    EDIT BY UNTULIS
;ADDED FAST .GETAB ,GTBLT,SRI-AI TABLES
;.SETNT JSYS AND OPRFIF
;<135-TENEX>MONJS.MAC;12    12-DEC-75 11:10:25    EDIT BY PLUMMER
; MAKE EXTERN OF CPUSED BE UNDER IFN PIESLC
; ADD EXTERN ON MSTKOV AFTER SNMJFN
;<135-TENEX>MONJS.MAC;11    10-DEC-75 12:55:58    EDIT BY ROSENBERG
; FIX THE MKPGSA OPRFN TO PERMIT THE PAGE WHOSE PAGE NUMBER IS EQUAL
; TO THE VALUE OF SWPCOR, TO BE MADE AVAILABLE.
;<134-TENEX>MONJS.MAC;9    17-OCT-75 14:40:02    EDIT BY ROSENBERG
; IMPROVE COMMENTS IN GETAB JSYS (AND ADD COMMENTED OUT CODE)
;<134-TENEX>MONJS.MAC;8    17-OCT-75 11:32:18    EDIT BY CLEMENTS
; Remove check of SUBSYS/SYSTEM/HACKS from SETNM. If insist type,
;  it gets set, else it doesn't, regardless of directory.
;<134-TENEX>MONJS.MAC;7    17-SEP-75 13:35:48    EDIT BY PLUMMER
; LH(3) TO HSYS CONTAINS USER NUMBER
;<134-TENEX>MONJS.MAC;6    15-AUG-75 18:48:04    EDIT BY CLEMENTS
; Fix typo in .hsys mod
;<134-TENEX>MONJS.MAC;5    11-AUG-75 17:52:26    EDIT BY CLEMENTS
; HSYS writes 3 words into <system>hsys.times file
;<134-TENEX>MONJS.MAC;4    15-JUL-75 15:55:32    EDIT BY CLEMENTS
; ADD IMPDRQ AND HSTINI TO OPRFN JSYS
; ADD "INSIST" FLAG TO SETNM JSYS. IF LH(1) IS 1, THEN ARG IS IN 2
;  AND IT GOES INTO TABLE IF POSSIBLE. ELSE, IT'S .OTHER .
;<134-TENEX>MONJS.MAC;3    28-APR-75 12:10:57    EDIT BY CLEMENTS
;<134-TENEX>MONJS.MAC;2    24-APR-75 12:39:57    EDIT BY CLEMENTS
;<134-TENEX>MONJS.MAC;2    24-APR-75 12:27:48    EDIT BY CLEMENTS
;<134-TENEX>MONJS.MAC;1    23-APR-75 14:51:32    EDIT BY CLEMENTS
;SPLITTING SWPMON INTO FINITE SIZE PIECES. THIS IS MONJS.MAC

	SEARCH PROLOG
	TITLE MONJS

	SWAPCD

;THIS MODULE CONTAINS JSYS CODE FROM SWPMON FOR MISC
; JSYSES, INFO-OBTAINING JSYSES... ALSO ROUTINES CALLED AT JSYS LEVEL.

INTERNAL	.HSYS,GETPAT,.GJINF,.TIME,.JOBTM,.RUNTM   ;.SETNT (deleted)
INTERNAL	.GTRPI,.GTDAL,.SYSGT,.GETAB,.SETNM,.GETNM
INTERNAL	.SWTCH,.LITES,.USRIO,.PEEK,CAPX,WHEELX
INTERNAL	.GET,.SAVE,.SSAVE,.OPRFN

EXTERNAL	BHC,BLOCK1,BUGCHK,BUGHLT,CAPENB,CAPMSK
EXTERNAL	CLFRET,CLRLFK,CVTAD,DBUGSW,DCHKSW,RELDSW,CDMPSW,FDDTSW
EXTERNAL	DDTFSH,DRMFRE,DSKNRE
EXTERNAL	FKDIR,FKHPTN,FORKX,FPTA,HSYST2,HSYST3
EXTERNAL	ITRAP1,JB0FLG,JFNOFN,JOBNAM,JOBONT,JOBPT,JOBRT
EXTERNAL	JOBRTT,LOGDES,MAPDIR,MKPGSA,MKPGSU,MRPACS
EXTERNAL	NDSKEW,NLGDES,NMNDSC,NNAMES,R,RSKP
EXTERNAL	SBLKTM,SBSNMS,SETJFK,SETLF1,SETLFK,SETMPG
EXTERNAL	SETPT,SKMRTN,SNAMES,SPC1,SPFLTS,SPTC,STIMES
EXTERNAL	SVN,SVNN,SVNUM,SWAKES,SWPCOR,TODCLK,TTFORK
IFDEF DRMCHN,<
EXTERNAL	NDRMEW,DRMCFE
>
IFN PIESLC,<
EXTERNAL	GRPLOK,NJBGRP,SSHARE,TOTSHR
>
IFDEF IMPCHN,<
EXTERNAL	GTBHSS,GTBHRT,IMPLT1,IMPLT2,IMPLT3,IMPLT4,IMPLT5
EXTERNAL	IMPNLK,IMPRDY,NLHOST
>

EXTERNAL	NTHOST,RLDRSN,PTYPTR

EXTERNAL	MENTR,MRETN

;HALT SYSTEM - REQUIRES MAINT (OR WHEEL ETC.) CAPABILITY
; ACCEPTS A GTAD-STYLE DATE AND TIME IN 1, AT WHICH TIME TENEX
;WILL BE SHUT DOWN. JOB 0 NOTIFIES USERS AND DOES THE SHUTDOWN.
; AND ACCEPTS A GTAD TIME IN 2 WHEN SYSTEM IS EXPECTED UP AGAIN
; ACCEPTS 4-BIT CODE FOR REASON FOR DOWNAGE IN 3.
; REQUIRES WHEEL, MAINT, OR OPER CAPABILITY.

.HSYS:	MCENT		;SET UP AC BLOCK
	MOVE 2,CAPENB		;SEE IF USER ALLOWED TO HALT TENEX.
	HLL 2,0(P)		;OR IF PC SAYS CALLED FROM MONITOR
	TLNE 2,UMODF		;CALL FROM MON SPACE?
	TRNE 2,WHEEL+OPER+MAINT	; OR PRIVILEGED?
	SKIPA			; YES. OK TO DO IT.
	JRST CAPXR		;NO. RETURN CAPX ERROR
	JUMPG 1,HSYS1		;JUMP UNLESS ABORTING THE SHUTDOWN
	SETZM HSYST1		;ABORTING. KILL FLAGS.
	SETZM HSYST2		; ..
	SETZM HSYST3		; ..
	JRST SKMRTN		;SKIP RETURN TO USER

HSYS1:	PUSH P,1		;HOLD THE DESIRED SHUTDOWN.
	CALL CVTAD		; LINEARIZE
	PUSH P,1
	GTAD			;GET CURRENT TIME AND DATE
	CALL CVTAD		; LINEARIZE
	SUB 1,0(P)		;DIFFERENCE IN TIMES
	SKIPGE 1		; NOW MUST BE BEFORE SHUTDOWN
	SKIPGE 1,[^D<7*24*60*60>]
	RETERR TIMEX1		;YES. GIVE BAD TIME FAILURE
	POP P,HSYST2		; LINEAR TAD OF SHUTDOWN
	POP P,HSYST1		; GTAD OF SHUTDOWN
	UMOVE 1,2		; TIME BACK UP, GTAD FORMAT
	CAMG 1,HSYST1		; LATER THAN SHUTDOWN? (IGNORING SIGN)
	MOVEI 1,0		; NO. ASSUME JUNK - UNKNOWN RETURN
	MOVEM 1,HSYST4		; STORE FOR GETAB, IMPHLT.
	SETZM HSYST3		; NO MSG TYPED YET
	UMOVE 2,3		; GET USER#,,<FLAGS>B23!<PACK#>B29!REASON
	MOVEM 2,HSYST5		;STORE WHO,,HOW AND WHY
	AOS JB0FLG		;WAKE JOB 0 TO SEE THIS
HSYS2:	SKIPN JOBNO		;CALLED FROM BACKGROUND?
	JRST HSYS2A		;YES. DON'T NEED TO WRITE FILE.
	PUSH P,CAPENB		;GIVE US WHEEL PRIVILEGES SO CAN
	NOINT			; WRITE ON SYSTEM
	MOVEI A,WHEEL		; ..
	IORM A,CAPENB		; ..
	MOVSI A,400001		;CREATE FILE TO HOLD SHUTDOWN TIME
	HRROI B,[ASCIZ /<SYSTEM>HSYS.TIMES;1/]
	GTJFN			; ..
	  JRST HSYS2F		;FAILED?
	MOVE C,A		;COPY JFN IN CASE FAILS
	MOVE 2,[440000,,100000]	;WRITE AT BEGINNING
	OPENF
	  JRST [MOVE A,C	;GET JFN BACK. FAILED.
		RLJFN
		 JFCL
		JRST HSYS2F]
	MOVE B,HSYST1		;NOW PUT OUT TIME GOING DOWN
	BOUT
	MOVE B,HSYST4		;AND TIME BACK UP
	BOUT			; ..
	MOVE B,HSYST5		;AND USER,,REASON
	AND 2,[-1,,000017]	;STRIP OFF OTHER STUFF
	BOUT
	CLOSF			;CLOSE THE FILE
HSYS2F:	  BUG(CHK,<HSYS - TROUBLE WITH <SYSTEM>HSYS.TIMES FILE>)
	POP P,CAPENB		;RESTORE CORRECT CAPABILITIES
	OKINT
HSYS2A:	JRST SKMRTN		;AND GIVE SUCCESS RETURN TO USER.

EXTERN HSYST1,HSYST4		;GTAD FORMAT, IN SYSTAT GETAB TABLE

;POINTS (IN MINUTES BEFORE SHUTDOWN) AT WHICH TO DO NOTIFICATION

CTIMS::	^D<BYTE (9) 60,30,15,10>
	^D<BYTE (9) 5,1,0>

;GET 10/50 COMPATIBILITY FILE ON FIRST USE OF UUO IN A GIVEN FORK

GETPAT:	MCENT		;GETS HERE FROM UUO HANDLER
	move	1, 40		; Pick up user's call.
	tlz	1, 777
	came	1, [47000,,41]	; Calli 41?
	 jrst	getpa1
	ldb	2, [point 4,40,12]	; Pick up AC.
	umove	1, 0(2)
	came	1, [112,,11]	; Want system type?
	 jrst	getpa1		; No.
	movei	1, 30000	; Say a Tenex.
	umovem	1, 0(2)		; Return to user.
	jrst	skmrtn
getpa1:	PUSH P,ENTVEC		;SAVE CURRENT ENTRY VECTOR
	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /<SUBSYS>PA1050.SAV/]
	GTJFN
	 ITERR ILINS3		;NO FILE
	HRLI 1,400000		;LOAD IT INTO THIS FORK
	GET
	MOVE 1,ENTVEC		;COMPATIBILITY ENTRY VECTOR
	MOVEM 1,PATADR		;PUT IT IN RESERVED PLACE
	POP P,ENTVEC		;RESTORE REGULAR VECTOR
	UMOVE 2,3(1)		;VIRTUAL 40 FOR PAT
	HRRM 2,PATU40
	UMOVE 2,4(1)		;PC WORD FOR PAT
	HRRM 2,PATUPC
	AOJ 1,			;INITIAL ENTRY IS 1, REGULAR 0
	HRLI 1,UMODF
	EXCH 1,0(P)		;SET NEW PAC, GET OLD ONE
	XCTUU PATUPC
	MOVE 1,40
	XCTUU PATU40
	JRST MRETN		;GO TO COMPATIBILITY

IFN PIESLC,<

;ROUTINE TO ASSIGN DSHARE VALUES. WINDFALL GOES TO LEAST COST-EFFECTIVE GROUP
ASGDSH:: PUSH P,2
	PUSH P,3
	PUSH P,5
	PUSH P,12

	NOINT
	LOCK GRPLOK

	SETZ 12,			;12 USED TO MAINTAIN ACTUAL INDEX
					;TO PIE-SLICE-GROUP.DATA ENTRIES

	MOVSI 5,-NGRPS			;LOOP OVER ALL GROUPS
ASGDS1:	SKIPN NJBGRP(5)			;ANYBODY USING THIS GROUP?
	 JRST ASGDS2			;NO, GO ON TO NEXT ONE

	MOVE 2,SSHARE(12)		;YES, GET NUMBER OF SHARES
	FDVR 2,TOTSHR			;COMPUTE FRACTION
	HRRZ 3,5
	CAMN 3,DEMO##			; IS THIS THE DEMO PIE SLICE?
	 MOVE 2,CUTOFF##		; YES, SO GIVE IT CANNED AMOUNT
	MOVEM 2,DSHARE(5)		;AND STASH IN DSHARE

ASGDS2:	ADDI 12,NWDGRP			;MAINTAIN ACTUAL INDEX
	AOBJN 5,ASGDS1			;ON TO NEXT GROUP

ASGDS3:	UNLOCK GRPLOK
	OKINT
	POP P,12
	POP P,5
	POP P,3
	POP P,2
	RET

;PIE-SLICE GROUP FILE PARAMETER GETAB TABLE (DO NOT SEPARATE ENTRIES)

GRPDES:	NGRPPG
	NWDGRP
	NGRPS
NGRPD=.-GRPDES

>;END PIE-SLICE SCHEDULER CONDITIONAL

;INFO JSYS'S

;ACCEPTS 1/ JOB # TO START AT ,, DIR # TO FIND LOGGED IN

;RETURNS 1/ SIXBIT SUBSYSTEM NAME FROM SNAMES
;RETURNS 2,3,4/ SAME INFO AS GJINF BUT FOR FOUND JOB

.WHRUS::MCENT
	HLRE 2,1			;GET JOB NO IN 1
	CAIL 2,0
	CAILE 2,NJOBS-1		;LEGAL?
	 RETERR (WHRUX1)	;ILLEGAL JOB #
	MOVEI 5,NJOBS		;ALL JOBS
	SUB 5,2			;HOW MANY TO DO
	MOVNS 5
	HRLS 5
	HRR 5,2			;5/ - # TO DO,,STARTING JOB #
.WHRU0:	HRRZ 2,JOBDIR(5)	;GET LOGGED IN DIR
	CAIN 2,(1)		;SAME?
	 JRST .WHRU1		;YES-DONE SEARCHING
	AOBJN 5,.WHRU0
	RETERR (WHRUX2)		;NO JOB FOUND - ERROR

;RH 5/ JOB NUMBER

.WHRU1:	MOVE 1,JOBNM2(5)	;GET THE SIXBIT SUBSYS NAME
	UMOVEM 1,1		;TO USERS 1
	HLRE 1,JOBDIR(5)	;CONNECTED DIR #
	UMOVEM 1,2		;TO USERS 2
	HRRE 1,5		;JOB NUMBER
	UMOVEM 1,3		;TO USERS 3
	HLRE 1,JOBPT(5)		;CONTROLLING TTY
	UMOVEM 1,4		;TO USERS 4
	JRST SKMRTN		;SKIP RETURN, INFO IN 1 : 4



.GJINF:	MOVE 3,JOBNO
	HRRZ 1,JOBDIR(3)
	HLRZ 2,JOBDIR(3)
	MOVE 4,CTRLTT
	XCT MJRSTF

.TIME:	MOVE 1,TODCLK		;TIME SINCE SYSTEM STARTED
RTIM:	MOVEI 2,^D1000		;DIVISOR FOR SECONDS
	XCT MJRSTF

.JOBTM:
	MOVE 1,JOBNO
	MOVE 1,JOBRT(1)
	ADD 1,JOBRTT
	XCT MJRSTF

.RUNTM:	MCENT
	XCTUU [HRRZ 1,1]	;FORK HANDLE
	CAIN 1,-5		;WHOLE JOB?
	JRST RUNTM1		;YES
	CALL SETJFK
	CALL SETLF1
	MOVE 1,FKRT(1)		;FORK RUN TIME FROM PSB
	ADD 1,JOBRTT
	JRST RUNTM2

RUNTM1:	NOINT
	MOVE 1,JOBNO
	MOVE 1,JOBRT(1)
RUNTM2:	MOVE 3,TODCLK		;CURRENT TIME
	SUB 3,CONSTO		;LESS TIME ON, FOR CONSOLE TIME USED
	MOVEI 2,^D1000		;MILLISECONDS
RETA3:	UMOVEM 1,1		;RETURN VALUES IN 1,2,3
	UMOVEM 2,2
	UMOVEM 3,3
	JRST CLFRET

.GTRPI:	MCENT
	CALL SETLFK
	MOVE 1,UTRPCT
	MOVE 2,USWPCT
	MOVE 3,PTTIM
	JRST RETA3

;GET DIRECTORY ALLOCATION
; TAKES A DIRECTORY NUMBER IN 1. 0 MEANS CURRENT CONNECTED DIR
; RETURNS ALLOCATION IN 1, USED IN 2. IF NO SUCH DIRECTORY,
; RETURNS 0 IN 1 AND 2
;
.GTDAL:	MCENT
	JUMPLE 1,GTDAL1
	PUSHJ P,HSHLUK##	; DIR SUPPLIED. SEE IF IT EXISTS
	  JRST GTDAL3		; NOPE.
	PUSHJ P,USTDIR##	; YES. UNLOCK IT.
	JRST GTDAL2		; AND USE THAT DIRECTORY NUMBER

GTDAL1:	MOVE 1,FORKX
	SKIPGE 1,FKDIR(1)
	MOVE 1,FKDIR(1)		;1=CONN DIR,,USER DIR
	HLRZS 1
GTDAL2:	SETO 2,
	CALL MAPDIR
	HLRZ 1,DIRDSK		; GET MAXIMUM ALLOCATION
	UMOVEM 1,1
	HRRZ 1,DIRDSK		;CURRENT IN-USE COUNT
				;(DOESN'T INCLUDE PAGES CREATED FOR
				; FILES WHICH ARE STILL OPEN)
	UMOVEM 1,2
	JRST MRETN

GTDAL3:	PUSHJ P,USTDIR##	; UNLOCK DIRECTORY
	MOVEI 1,0		; RETURN 0 AS ANSWER FOR USED AND ALLOC
	UMOVEM 1,2
	UMOVEM 1,1
	JRST MRETN


;GET NUMBER OF TABLE AND FIRST WORD GIVEN SIXBIT SYMBOL

.SYSGT:	MCENT
	MOVSI 4,-GTBSIZ
	CAMN 1,SYMTAB(4)
	JRST SYSGT1
	AOBJN 4,.-2
	XCTUU [SETZM 2]		;NOT FOUND RETURN 0
	JRST MRETN

SYSGT1:	LDB 2,[POINT 12,GTTAB(4),17]	;SIZE
	MOVN 2,2		;NEGATE IT
	HRLI 4,0(2)		;COMBINE WITH TABLE NUMBER
	UMOVEM 4,2		;GIVE TO USER
	SKIPGE 1,GTTAB(4)	;ADDRESS OF FIRST WORD
	 JRST [	SETZ 2,		;FIRST WORD
		CALL 0(1)	;CALL IT
		JRST RETS1]

;TEMPORARILY PROVIDE AN EXTRA LEVEL OF ADDRESSING FOR SYSSTAT
;TABLE WHICH WILL GO AWAY SOON.
	MOVEI 4,0(4)		;CLEAR LEFT HALF
	CAIN 4,SYSSTN		;IS THIS THE SYSSTAT TABLE?
	MOVE 1,0(1)		;YES

	MOVE 1,0(1)
RETS1:	UMOVEM 1,1		;GIVE FIRST WORD TO USER
	JRST MRETN

; Get word from table given table number in rh 1 and index in lh 1.
; Return negative of table length in 1 if index is negative.
; Return +1 if error, +2 if success

REPEAT 0,<	; MAY BE SOMEBODY CAN MAKE THIS WORK WITH THE NEW
		; FORMAT OF GTTAB WHEREIN THE SIGN BIT SAYS TO
		; CALL A FUNCTION.  YOU NEED TO WORRY ABOUT ACS
		; GETTING SMASHED BY THAT FUNCTION.  BEST TO MAKE
		; IT BECOME A SLOW JSYS IN THAT CASE.


.GETAB:
	MOVEM 2,XMENTR		; Save an ac in protected temp
; YOU SHOULD PROBABLY BE NOINT HERE SO THAT IF THIS
; FORK GETS A PSI AND DOES ANOTHER JSYS AT PSI LEVEL, XMENTR WILL
; NOT GET CLOBBERED.  BUT THEN AGAIN, WHO CARES ABOUT AC2 AFTER A GETAB.
	MOVSI 2,(1B1)		; GETAB capability exist for fork?
	TDNN 2,CAPMSK
	 JRST [	MOVEI 1,GTABX3	; No, return error
		JRST GETAB3]
	HRRZ 2,1		; Yes, copy table number
	CAIL 2,GTBSIZ		; Within bounds?
	 JRST [	MOVEI 1,GTABX1	; No, return error
		JRST GETAB3]
	JUMPL 1,[LDB 1,[POINT 12,GTTAB(1),17]  ; If negative index,
					       ;  get table length
		MOVNS 1		; Negate it
		JRST GETAB1]	; Return it
	HLLO 1,1		; Set rh to max so compare works
	CAML 1,GTTAB(2)		; Index in bounds? SIGN BIT SCREWS THIS
	 JRST [	MOVEI 1,GTABX2	; No, return error
		JRST GETAB3]
	HLRZ 1,1		; Yes, put index in rh
	ADD 1,GTTAB(2)		; Compute address of word
	CAIN 2,SYSSTN		; Is this the "SYSTAT" table?
	 MOVE 1,0(1)		; Yes, indirect another level
	MOVE 1,0(1)		; Get the data word
GETAB1:	MOVE 2,FPC		; Get return pc
	HRRI 2,1(2)		; Increment it without carry into lh
	MOVEM 2,FPC		; Put it back
GETAB2:	MOVE 2,XMENTR		; Restore saved ac
	XCT MJRSTF		; Return to user
GETAB3:	MOVEM 1,LSTERR##		; Save for the nervous ones.
	JRST GETAB2
>; END REPEAT 0 AROUND SRI CODE

REPEAT 1,<			; THIS WAS THE OLD SLOW JSYS WAY
.GETAB:	MCENT
	MOVSI 2,(1B1)
	TDNN 2,CAPMSK		;GETAB CAPABILITY EXISTS?
	RETERR GTABX3		;NO
	HLRE 2,1		;INDEX OR -1
	MOVEI 3,0(1)		;TABLE NUMBER
	CAIL 3,GTBSIZ		;LEGAL NUMBER?
	RETERR GTABX1		;NO
	LDB 1,[POINT 12,GTTAB(3),17] ;GET SIZE OF TABLE
	JUMPL 2,RETN1		;IS INDEX LESS THAN ZERO?
	CAIL 2,0(1)		;NO. INDEX WITHIN BOUNDS?
GETAB1:	RETERR GTABX2		;NO
	SKIPGE 1,GTTAB(3)	;REGULAR TABLE?
	 JRST [	CALL 0(1)	;CALL IT
		JRST RET1]
	ADDI 2,0(1)		;COMPUTE ADDRESS OF DESIRED WORD

;ADD LEVEL OF ADDRESSING FOR SYSSTAT AS PER COMMENT IN SYSGT
	CAIN 3,SYSSTN		;SYSSTAT?
	MOVE 2,0(2)

	MOVE 1,0(2)		;GET WORD
RET1:	UMOVEM 1,1		;RETURN IT TO USER
URSKP:	AOS 0(P)		;SKIP RETURN
	JRST MRETN

RETN1:
;;;;;;;;AOJL 2,GETAB1		;"UNCOMMENT" TO ENFORCE RESTRICTION
				;AGAINST INDEX VALUES LESS THAN -1
	XCTUU [MOVNM 1,1]	;RETURN NEG OF LENGTH
	JRST URSKP		;SKIP RETURN
>; END OF REPEAT 0 FOR OLD GETAB CODE.

; ".CPUTL" JSYS For Returning Current Job's Utilization Data
.cputl::
	setz 1,			;share to ac 1
	setz 2,			;overall util to ac 2
	setz 3,			;cpu util to ac 3
	setz 4,			;memory util to ac 4
	setz 5,			;io util to ac 5
	xct mjrstf		;return to user mighty fast...

;GTBLT -- BLT PIECE OF TABLE TO USER -- GET MANY ENTRIES AT ONCE
;AC1 LH: IDX TO BEGIN, RH: TABLE NO.
;AC2 LH: NO. OF ENTRIES TO MOVE, RH: BUFFER ADR IN USER SPACE
;IF LH OF AC1 = -1, THEN IGNORE LH OF AC2 AND BLT WHOLE TABLE

.GTBLT::MCENT	;SLOW DOWN
	MOVSI 3,(1B1)
	TDNN 3,CAPMSK	;GETAB CAPABILITY?
	 RETERR GTABX3	;NO
	HLRE 3,1	;INDEX OR -1
	MOVEI 4,(1)	;TABLE NUMBER
	CAIL 4,GTBSIZ	;LEGAL NUMBER?
	 RETERR GTABX1	;NO
	LDB 1,[POINT 12,GTTAB(4),17] ;GET SIZE OF TABLE
	JUMPL 3,WHOLTB	;BLT WHOLE TABLE IF INDEX .LESS. 0
	HLRZ 5,2	;GET NO. OF ENTRIES
	JUMPE 5,GTBLT1	;LH 2 .EQ. 0 IS A NOP
	ADDI 5,(3)	;PLUS BEGINNING IDX TO GET END
	CAILE 5,(1)	;INDEX WITHIN BOUNDS?
	 RETERR GTABX2	;NO
	SKIPGE 6,GTTAB(4) ; REGULAR TABLE?
	 JRST SOMETB	; NO.  GO SETUP LOOP OVER CALL
	ADD 3,GTTAB(4)	;COMPUTE ADDRESS 0F DESIRED BEGINNING
	HLRZ 5,2	;GET COUNT TO BLT
	ADDI 5,(2)	;ADD BUFFER ADR TO GET LAST ENTRY +1
	HRL 2,3		;PUT BEGINNING ADR IN LH OF 2
BLTABL:	XCTMU [BLT 2,-1(5)] ;DO THE BLT
GTBLT1:	AOS (P)		;SKIP RETURN
	JRST MRETN

WHOLTB:	SKIPGE 6,GTTAB(4) ; Regular table?
	 JRST WHOLT1	; No.  Must loop over function call
	HRL 2,GTTAB(4)	;BEGINNING OF TABLE
	ADDI 1,(2)	;BUFFER ADR + SIZE IS END OF BLT +1
	MOVEI 5,(1)	;INTO 5 FOR THE BLT
	JRST BLTABL	;DO THE BLT


; 6/	400000+tabsiz,,function
; 1/	table size
; 2/	pointer to user's buffer

WHOLT1:	MOVNS 1			; Get negative length
	HRLZ 7,1		; AOBJN ptr over pseudo table
	JUMPGE 7,GTBLT1		; Done already
	MOVE 10,2		; Save user ptr in safe place

WHOLT2:	HRRZ 2,7		; Arg for function
	CALL 0(6)		; Get a number
	UMOVEM 1,0(10)		; Pass it to the user
	ADDI 10,1		; Bump user ptr for next time
	AOBJN 7,WHOLT2		; Do next
	JRST GTBLT1		; Done


SOMETB:	HLRZ 7,2		; Positive count
	MOVNS 7			; Make negative
	HRLZS 7			; Count for AOBJN
	HRRI 7,0(3)		; Starting index
	MOVE 10,2		; Put user pointer in safe place
	JRST WHOLT2		; Joint whole table case

;TABLE OF TABLES

	EXTERN FKPT,FKJOB,NBALFX	
	EXTERN NDEV,DEVNAM,DEVCHR,DEVUNT,JOBDIR
	EXTERN TOTRC,MAXQ,QSUM,NTASKT,SOLD,NLOADT,RJTSUM,NEVENT,DRMRD

IFN SWTFLG,<
	EXTERN NSUPRS
>

GTTAB:	XWD NJOBS,JOBPT		;CONTROL TTY,,TOP FORK
	XWD NJOBS,JOBRT		;JOB RUN TIME
	XWD 1,[^D1000]		;DIVISOR FOR SECONDS
	XWD NJOBS,JOBDIR	;DIRECTORY BEING USED
	XWD NLINES,TTFORK
	XWD 1,TOTRC
	XWD 1,SYSMEM##
	XWD NDEV,DEVNAM
	XWD NDEV,DEVCHR
	XWD NDEV,DEVUNT
	XWD NDSKEW,DSKNRE
IFDEF DRMCHN,<
	XWD NDRMEW,DRMCFE
>
	XWD SVNN,SVN
	XWD 1,SVNUM
	XWD 400000+1,CNTDIR##
IFN SWTFLG,<
	XWD NSUPRS,NBALFX	
>
	XWD 3,UTRPCT
SYSSTN==.-GTTAB
	XWD NSTAT,SYSST
	XWD MAXQ+1,QSUM
	XWD NJOBS,JOBNAM
	XWD NNAMES,SNAMES
	XWD NNAMES,STIMES
	XWD NNAMES,SPFLTS
	XWD NNAMES,SWAKES
	XWD NNAMES,SBLKTM
	XWD 5,DBUGSW		;DBUGSW, DCHKSW, CDMPSW, RELDSW, FDDTSW
	XWD NLGDES,LOGDES
	XWD GTBSIZ,SYMTAB	;THE 6BIT SYMBOLS
	XWD GTBSIZ,GTTAB	;AND THE POINTERS
	XWD 1,ENTFLG		;ENTRY ALLOWED IF NON-ZERO
	XWD 1,DRMFRE		;TEMP TILL MOUNTABLE PACKS/NEW SWAPPER
	XWD NTASKT,SOLD
	XWD NLOADT,RJTSUM
	XWD NEVENT,DRMRD
	XWD 2,LGNPAR##		;LOGIN FAILURE CODE IF SYSTEM FULL
				; AND LAST LOGIN DATE.
	XWD NDSKPR##,DSKPAR##	; DSK PARAMETERS
	XWD NHOMBA##,HOMBAT##	; FILESYSTEM HOME AND BAT BLOCK PARAMETERS
	XWD 3,FDFMTF##		; DIRECTORY FORMAT FLAG AND INFO
	XWD NJOBS,JOBACT##	;JOB ACTIVITY   ***SRI-AIC***
	XWD	NFKS,FKPT	;LIST STATUS OF FORK
	XWD	NFKS,FKJOB	;JOB NUMBER,,JSB
	XWD	NFKT,FORKT	;FORK TABLES *** SRI-AIC ***
	XWD	NJOBS,JOBPGF##	;NUMBER OF PAGE FAULTS PER JOB  *** SRI-AIC ***
IFN WSPFLG,<
	XWD 	NJOBS,JOBWSP##	;WORKING SET SIZE PER JOB
>
	Xwd	Njobs,TTYCHS##	;Number of characters on TTY per job.
	Xwd	Njobs,LLORCA##	;Last login/change account date/time.
	XWD NJOBS,JOBONT	;JOB OWNERSHIP TABLE
	XWD NJOBS,JOBNM2	;REAL JOB NAME EVEN IF ".OTHER"
;MORE

;MORE OF ABOVE
IFDEF IMPCHN,<		;NETWORK RELATED TABLES
	EXTERN NHOSTS,GHOSTN,LSKT,FSKT,GNTAWD,NETBAL,NETSTS,NETBUF
	EXTERN NHSTN,HSTNAM,NETBTC,IMPGTN,GHSTNN,NETHST,GHSTST

	XWD IMPGTN,IMPRDY
	XWD 400000+10,GTBHRT
	XWD 400000+200,GTBHSS
GTBNHN::XWD NHSTN,HSTNAM
GTBHST::XWD 400000+NHOSTS,GHOSTN
	XWD 400000+NHOSTS,GHSTNN
	XWD 400000+NHOSTS,GHSTST
	XWD NSKT,LSKT
	XWD NSKT,FSKT
	XWD 400000+NSKT,GNTAWD
	XWD NSKT,NETBAL
	XWD NSKT,NETSTS
	XWD NSKT,NETBUF
	XWD NSKT,NETBTC
	XWD NSKT,NETHST
	XWD IMPNLK,IMPLT1
	XWD IMPNLK,IMPLT2
	XWD IMPNLK,IMPLT3
	XWD IMPNLK,IMPLT4
	XWD IMPNLK,IMPLT5
	XWD 2,NLHOST		;HOST NUMBER, NVT COUNTER
>

;NET TABLES IF NOT ON ARPANET BUT HAVE ACCESS TO GATEWAY

IFNDEF IMPCHN,<

GTBNHN::XWD NHSTN##,HSTNAM##
GTBHST::XWD 400000+NHOSTS##,GHOSTN##
	XWD 400000+NHOSTS##,GHSTNN##
	XWD 400000+NHOSTS##,GHSTST##
	XWD 2,NLHOST##		;HOST NUMBER, NVT COUNTER
>

IFN PIESLC,<
	XWD NGRPS,NAPROC##
	XWD NGRPS,DSHARE##
	XWD NJOBS,PIEGRP##
	XWD NGRPS,NJBGRP
	XWD NGRPD,GRPDES
> ; END PIE-SLICE SCHEDULER CONDITIONAL

	XWD 4,NTHOST
	XWD 1,RLDRSN
	XWD 1,PTYPTR

GTBSIZ==.-GTTAB
	BLOCK 10

;SYMBOL TABLE PARALLEL TO ABOVE

SYMTAB:	SIXBIT /JOBTTY/
	SIXBIT /JOBRT/
	SIXBIT /TICKPS/
	SIXBIT /JOBDIR/
	SIXBIT /TTYJOB/
	SIXBIT /NCPGS/
	SIXBIT /SYSMEM/
	SIXBIT /DEVNAM/
	SIXBIT /DEVCHR/
	SIXBIT /DEVUNT/
	SIXBIT /DSKERR/
IFDEF DRMCHN,<
	SIXBIT /DRMERR/
>
	SIXBIT /SYSVER/
	SIXBIT /VERNUM/
	SIXBIT /DIRPAR/
IFN SWTFLG,<
	SIXBIT /SUPERW/
>
	SIXBIT /PGSTAT/
	SIXBIT /SYSTAT/
	SIXBIT /QTIMES/
	SIXBIT /JOBNAM/
	SIXBIT /SNAMES/
	SIXBIT /STIMES/
	SIXBIT /SPFLTS/
	SIXBIT /SWAKES/
	SIXBIT /SBLKTM/
	SIXBIT /DBUGSW/
	SIXBIT /LOGDES/
	SIXBIT /SYMTAB/
	SIXBIT /GETTAB/
	SIXBIT /ENTFLG/
	SIXBIT /DRMFRE/
	SIXBIT /TASKTB/
	SIXBIT /LOADTB/
	SIXBIT /EVENTS/
	SIXBIT /LGNPAR/
	SIXBIT /DSKPAR/
	SIXBIT /HOMBAT/
	SIXBIT /FDFMTF/
	SIXBIT /JOBACT/
	SIXBIT /FKPT/
	SIXBIT /FKJOB/
	SIXBIT /FORKT /
	SIXBIT /JOBPGF/
IFN WSPFLG,<
	SIXBIT /JOBWSP/
>
	SIXBIT /TTYCHS/
	Sixbit /LLORCA/
	SIXBIT /JOBONT/
	SIXBIT /JOBNM2/
;MORE

;MORE OF ABOVE
IFDEF IMPCHN,<
	SIXBIT /NETRDY/
	SIXBIT /IMPHRT/
	SIXBIT /HSTSTS/
	SIXBIT /HSTNAM/
	SIXBIT /HOSTN/
	SIXBIT /HOSTNN/
	SIXBIT /HOSTST/
	SIXBIT /NETLSK/
	SIXBIT /NETFSK/
	SIXBIT /NETAWD/
	SIXBIT /NETBAL/
	SIXBIT /NETSTS/
	SIXBIT /NETBUF/
	SIXBIT /NETBTC/
	SIXBIT /NETHST/
	SIXBIT /IMPLT1/
	SIXBIT /IMPLT2/
	SIXBIT /IMPLT3/
	SIXBIT /IMPLT4/
	SIXBIT /IMPLT5/
	SIXBIT /LHOSTN/
>

;IF NOT ARPANET CONNECTION, FAKE SOME TABLES SO CAN DO
;GATEWAY STUFF

IFNDEF IMPCHN,<	SIXBIT /HSTNAM/
		SIXBIT /HOSTN/
		SIXBIT /HOSTNN/
		SIXBIT /HOSTST/
		SIXBIT /LHOSTN/>

IFN PIESLC,<
	SIXBIT /NAPROC/
	SIXBIT /DSHARE/
	SIXBIT /PIEGRP/
	SIXBIT /NJBGRP/
	SIXBIT /GRPDES/

> ; END PIE-SLICE SCHEDULER CONDITIONAL

	SIXBIT /THOSTN/
	SIXBIT /RLDRSN/
	SIXBIT /PTYPTR/

IFN GTBSIZ-<.-SYMTAB>,<	PRINTX  GETAB SYMBOL TABLE INCORRECT
>
	BLOCK 10


;TEMPORARY SYSTAT TABLE CONTAINING ADDRESSES OF DATA WHICH
;USED TO BE FOUND IN PREVIOUS SYSTAT TABLE
SYSST:	IDLE##
	SWAPWT##
	GCCR##
	PTRAP##
	DRMRD
	DRMWR##
	DSKRD##
	DSKWR##
	WAKEUP##
	TTINTS##
	BSTSUM##
	RJTSUM##
	RJAV##
	RJAV+1
	RJAV+2
	[0]
	[0]
	NTTYIN##
	NTTYOT##
	GCCR+1
	PPG##
	NREMJ##
	[0]
	HSYST1##
	HSYST4##
	HSYST5##
NSTAT==.-SYSST
FORKT:	XWD	NUFKS,SYSFK	;***SRI-AIC***
	XWD	NUFKS,FKPTRS	;***SRI-AIC***
	XWD	NFKS,FKPGS##	;***SRI-AIC***
	XWD	NFKS*^D10,FKSTAT##	;***SRI-AIC***
NFKT==.-FORKT			;***SRI-AIC***


;SUBSYSTEM STATISTICS LOGIC

GS SNMPT,1			;NEG COUNT OF ENTRIES IN SNAMES
GS SNMLCK,1			;LOCK FOR SNAMES TABLE

;B16 ON IN AC 1 WITH RH AC 1 = 0 MEANS TARGET JOB NUMBER IN AC 3
;UGH....

.SETNM:	MCENT
	PUSH P,JOBNO		;ASSUME THIS JOB GETS THIS STUFF
	PUSH P,ZERO##		;ASSUME NOT THE "INSIST" CASE
SNMNRM:	TLNE A,777774		;WHICH CASE IS IT?
	 JRST SNM2		;ORDINARY SIXBIT
	TLZE A,(1B16)		;JOB NUMBER IN 3?
	 JRST SNMFIX		;YES-FANCY SHIT
SNMINS:	TLZN A,(1B17)		;INSIST FLAG ON?
	 JRST SNMJFN		;NO, JFN BUT NOT INSIST.
	UMOVE A,2		;INSIST. AC2 HAS SIXBIT OR JFN
	SETOM 0(P)		;SET THE "INSIST" FLAG ON STACK
	TLNN A,-2		;SIXBIT OR JFN?
	 JRST SNMJFN		;JFN IN AC A
SNM2:	NOINT			;SIXBIT IN A, INSIST FLAG AT 0(P)
	AOSE SNMLCK		;LOCK TABLE
	JSYS BLOCK1		;OR WAIT TILL LOCKABLE
	HRLZ 3,SNMPT		;NEG COUNT OF ENTRIES
	CAMN 1,SNAMES(3)	;DESIRED NAME?
	JRST SNM1		;YES
	AOBJN 3,.-2		;NO, LOOKED AT ALL?
	MOVEI 3,0(3)
	MOVE 2,1		;COPY SUPPLIED NAME. WILL IT FIT?
	SKIPE 0(P)		;INSIST FLAG OFF, OR FULL TABLE?
	CAIL 3,NNAMES-1		; ..
	SKIPA 2,[SIXBIT /.OTHER/] ;YES, USE CATCH-ALL NAME
	SOSA SNMPT		;UPDATE POINTER
	MOVEI 3,NNAMES-1	;PUT .OTHER AT THE END
	MOVEM 2,SNAMES(3)	;ADD NAME TO TABLE
SNM1:	MOVE 2,-1(P)		;GET JOB NUMBER
	MOVEM 1,JOBNM2##(2)	;SAVE REAL NAME EVEN IF .OTHER
	HRRM 3,JOBNAM(2)	;PUT INDEX IN JOB TABLE
	SETOM SNMLCK		;UNLOCK TABLE
	OKINT
	SUB P,BHC+2		;DISGARD STACKED INFO
	JRST MRETN

SNMJFN:	HRRZ D,A		;SAVE THE JFN IN D
	GTSTS			;IS IT GOOD?
	TLNN B,(1B10)		; ..
	JRST SNMPRV		;NO, JUNK. SET TO PRIV.
	HRROI A,1(P)		;SPACE FOR DIRECTORY NAME
	ADD P,BHC+10		; ..
	JUMPGE P,MSTKOV##
SNMJF1:	HRROI 1,-7(P)		;NOW GET THE NAME FIELD
	HRRZ B,D		;GET THE JFN AGAIN
	MOVSI C,001000		;NAME FIELD
	JFNS
	MOVEI A,-10(P)		;WORD BEFORE NAME
	HRLOI B,003777		;TRUNCATE TO 6 CHARS
	ANDCAM B,2(A)		; ..
	PUSHJ P,ASCSIX##
	  JRST SNMPR1		;FAILED?
	SUB P,BHC+10		;RESTORE STACK
	JRST SNM2		;STORE SIXBIT NOW IN A
SNMPR1:	SUB P,BHC+10		;RESTORE STACK
SNMPRV:	MOVE A,SBSNMS+1		;GET SIXBIT FOR (PRIV)
	JRST SNM2		;AND GO SET IT.

;HERE WHEN B16 ON IN AC1 MEANING JOB # IN 3.
;ALL THIS BECAUSE OF ROSENBERG...UGH...

SNMFIX:	HRRZM 3,-1(P)		;SAVE JOB # GIVEN US BY USER
	HRRZ 4,JOBONT(3)	;GET OWNER OF THAT JOB
	CAME 3,JOBNO		;THIS JOB?
	CAMN 4,JOBNO		;OR WE OWN IT?
	 JRST SNMFI1		;YES-OK
	MOVE 3,CAPENB
	TRNE 3,WHEEL+OPER+MAINT	;PRIVILEGED?
	 JRST SNMFI1		;YES-OK
	ITERR WHELX1		;NO-GIVE INTERRUPT TO JERK

SNMFI1:	TLNE A,(1B17)		;INSIST CASE?
	 JRST SNMINS		;YES, SIXBIT OR JFN IN 2
	MOVE 1,2		;NO-PUS SIXBIT OR JFN IN 1
	JRST SNMNRM		;DO NORMAL CASE



.GETNM:	MOVE 1,JOBNO
	MOVE 1,JOBNM2(1)
	XCT MJRSTF

.SWTCH:
	DATAI APR,1
	XCT MJRSTF

.LITES:	MCENT
	MOVE 2,CAPENB
	TRNN 2,WHEEL+OPER+MAINT	;REQUIRES STATUS
	JRST WHEELX
	DATAO PI,1		;DISPLAY
	JRST MRETN

.USRIO:	MCENT
	MOVEI 1,WHEEL+OPER+MAINT
	TDNN 1,CAPENB		;REQUIRES STATUS
CAPXR:	RETERR CAPX1
	MOVSI 1,(1B6)		;USER IO BIT
	IORM 1,0(P)		;PUT IT ON
	JRST SKMRTN

;PEEK - AC1:  N,,MONLOC
;       AC2:     USRLOC

.PEEK:	MCENT
	MOVEI 3,WHEEL+OPER+MAINT
	TDNN 3,CAPMSK		;HAS NECESSARY CAPS?
CAPX:	ITERR CAPX1		;NO.
	MOVSI 5,0(1)		;SETUP BLT ARGS - FROM
	HRRI 5,0(2)		; .. TO
	MOVEI 6,0(2)
	HLRZ 3,1		;COUNT
	ADDI 6,-1(3)		; .. TO LIMIT
	ADDI 3,-1(1)		;FROM LIMIT
	XORI 3,0(1)		;SEE IF BLOCK CROSSES PAGE BOUNDARY
	TRNE 3,777000
	RETERR PEEKX1		;CAN'T CROSS PAGE BOUNDARY
	MOVEI 1,0(1)
	MRPAC			;GET ACCESS OF PAGE
	TLNN 2,READB		;READ ALLOWED?
	RETERR PEEKX2		;NO
	XCTMU [BLT 5,0(6)]	;TRANSFER WORD(S)
	AOS 0(P)
	JRST MRETN

;ERROR - WHEEL OR OPER REQUIRED BUT NOT ENABLED

WHEELX:	ITERR WHELX1

;GET AND SAVE ROUTINES

;AC USAGE IN GET ROUTINE:
; 4 - PAGE NUMBER IN USER SPACE CURRENTLY MAPPED TO FTPG1
; 5 - POINTER TO ADDRESS IN FTPG1 CORRESPONDING TO AC 6
; 6 - AOBJN (NOT IOWD) POINTER TO USER SPACE WHERE CURRENTLY READING
;14 - SETPT ARGUMENT FOR FTPG1
;15 - FORK HANDLE BEING GET'ED INTO
;16 - JFN BEING READ FROM

.GET:	MCENT
	CALL GTSVI		;CHECK PARAMETERS, ETC.
	HRRI 2,1B19		;READ BIT
	TLNN 3,777		;DISK?
	HRRI 2,5B21+1B25	;YES, REQUEST RD,XCT ACCESS AND THAWED
	PUSH P,2		;SAVE THE DESIRED OPENING BITS
	GTSTS			;SEE IF THE FILE IS OPEN ALREADY
	TLNN 2,(1B0)		; ..
	JRST GET2A		;NO. GO OPEN IT.
	TLNE 3,777		;IT'S OPEN. IS IT A DISK?
	JRST GET2B		;NO. ASSUME HE OPENED IT RIGHT
	TLC 2,(1B0+1B1+1B3)	;SEE IF RD & XCT BOTH ON
	TLNE 2,(1B0+1B1+1B3)	; ..
	JRST GETE2		;NO.
GET2B:	RFBSZ			;AND CORRECT BYTE SIZE?
	CAIE 2,44		; ..
	JRST GETE2		;NO
	POP P,2			;OK. CLEAR STACK
	JRST GET2C		;AND GO READ THE OPEN FILE.

GET2A:	POP P,2			;RETRIEVE OPENING MODE BITS
	OPENF			;OPEN FILE FOR INPUT
	JRST ITRAP1		;WON'T OPEN
GET2C:	MOVEI 1,FTPG1A
	CALL FPTA		;GET HANDLE OF TEMP PAGE FOR LATER
	MOVE 14,1
;FALL THRU

;FALLS THRU
GET2:	TSTINT			;INTERRUPT PENDING?
	CALL GETINT		;YES, GO ALLOW IT
	MOVEI 1,0(16)		;JFN
	BIN			;GET IOWD COUNT,ADR
	JUMPE 2,[GTSTS		;ZERO. PROBABLY EOF.
		TLNE 2,(1B8)	;IS IT?
		JRST GETE1	;YES. TRUNCATED FILE.
		MOVEI 2,0	;NO, A ZERO ENTRY VECTOR.
		JRST .+1]	;HANDLE IT
	MOVE 6,2
	HLRZ 2,2
	cain 2,1776		;1 TOPS20 style save format?
	 jrst getexe		;1 Yes
	CAIL 2,1000		;LEFT HALF IMPLYING SSAVE?
	CAIL 2,10000
	JRST .+2		; NO
	JRST SGET		; YES.
	JUMPGE 6,GET1		;POSITIVE MEANS END
	ADDI 6,1		; CHANGE IOWD TO AOBJN POINTER
GET5:	CALL GET3		;SET MAP FOR THIS PAGE, SET AC 5
	MOVEI 2,0(6)		;ADDRESS IN USER SPACE
	ORCMI 2,777		;MINUS NUMBER OF WORDS IN THAT PAGE
	HLRE 3,6		;LENGTH OF THE IOWD
	CAMLE 2,3		;WILL IT FIT IN THE WINDOW PAGE?
	MOVE 3,2		;NO. JUST READ WHAT WILL FIT
	MOVM 2,3		;POSITIVE FOR UPDATING POINTERS
	HRL 2,2			;IN BOTH HALVES. THIS IS +N,,+N
	ADD 6,2			;UPDATE THE AOBJN WORD. MAY OR MAY NOT GO +
	MOVE 2,5		;ADDRESS IN WINDOW PAGE
	HRLI 2,444400		;BYTE POINTER TO IT.
	SUB 5,3			;3 IS ALREADY -N FOR SIN. COUNT WINDOW ADDR.
	SIN			;NOW READ INTO THE WINDOW
	JUMPL 6,GET5		;JUMP IF POINTER CROSSED PAGE BOUNDARY
	JRST GET2		;DONE THIS POINTER. READ NEXT ONE.

GET1:	MOVEI 1,0(15)		;FORK HANDLE
	CALL SETLFK		;MAP PSB
	MOVEM 6,ENTVEC(1)	;STORE ENTRY VECTOR DATA
	MOVEI 1,0(16)		;JFN
	JRST SAVER

SGET:	CAIE 2,1000		;CORRECT TYPE NUMBER?
	JRST GETE1		;NO, STRANGE FILE
	MOVEI 13,0(6)		;SAVE COUNT
	MOVE 1,16
	DVCHR
	TLNE 2,777		;DISK FILE?
SSAVE1:	ITERR SSAVX1		;NO, CAN'T DO IT
SGET1:	MOVE 1,SPTC		;SPT USE COUNT
	CAML 1,SPC1		;RUNNING LOW?
	ITERR GETX2		;YES, BOMB OUT
	MOVE 1,16
	BIN
	MOVEI 1,0(2)		;FILE PAGE NUMBER
	LDB 3,[POINT 9,2,8]	;ACCESS
	LDB 2,[POINT 9,2,17]	;MEMORY PAGE
	ROT 3,-^D9
	TLZE 3,(1B0)		;WRITE COPY REQUEST?
	TLO 3,COPYB		;YES, SET APPROPRIATE BITS
	HRLI 1,0(16)
	HRLI 2,0(15)
	PMAP			;MAP FILE PAGE INTO FORK
	SOJG 13,SGET1
	JRST GET2

GETINT:	SETZ 1,
	MOVEI 2,FTPG1A		;UNMAP STUFF
	CALL SETMPG
	CALL CLRLFK		;THIS DOES OKINT, INTERRUPT HAPPENS HERE
	MOVEI 1,0(15)
	CALL SETLFK		;REESTABLISH STATE
	SETO 4,
	RET

GTSVI:	MOVEI 16,0(1)		;JFN
	HLRZ 15,1		;FORK HANDLE
	MOVEI 1,0(16)		;JFN
	DVCHR			;GET DEVICE CHARACTERISTICS
				;DO THIS FIRST IN CASE OF ITRAP
	HLRZ 3,2		;SEE WHAT KIND OF DEVICE. PREVENT
	ANDI 3,777		; TTY'S, CAUSE FORK HANDLES ARE OFTEN
	CAIN 3,12		; MISPLACED INTO JFN AND LOOK LIKE TTY.
	ITERR (DESX4)		; THEN JOB HANGS NOINT ON TTY BIN
	PUSH P,2
	MOVEI 1,0(15)
	CALL SETLFK		;MAKE SURE FORK IS LEGAL
	MOVEI 1,0(16)		;JFN
	POP P,3			;DEVICE BITS
	MOVSI 2,^D36B23		;BYTE SIZE FOR BIN/BOUT XFER
	SETO 4,
	RET

;CHECK AND REMAP PAGE - 4/ CURRENT PAGE (-1 FIRST TIME)
; SET FTPG1 TO POINT INDIRECT TO USER PAGE ADDRESSED BY AC6

GET3:	TSTINT
	CALL GETINT
	LDB 2,[POINT 9,6,26]	;PAGE NUMBER NEXT REFERENCE
	CAIN 2,0(4)		;SAME AS CURRENT
	JRST GET3A		;YES
	MOVEI 4,0(2)		;REMEMBER IS CURRENT
	HRLI 2,0(15)		;FORK HANDLE
	MOVE 1,2
	CALL FKHPTN		;CONVERT TO INTERNAL FORM
	MOVE 2,14
	MOVSI 3,RWX
	CALL SETPT		;SETUP INDIRECT POINTER TO PAGE
GET3A:	MOVEI 5,0(6)		;SETUP ADDRESS FOR MON REFERENCES
	ANDI 5,777
	ADDI 5,FTPG1A
	MOVEI 1,0(16)		;RESTORE JFN TO 1
	RET

GETE2:	MOVEI 1,GETX3##		;FILE NOT PROPERLY OPENED
	JRST GETE0		;RETURN THIS ERROR CODE
GETE1:	MOVEI 1,GETX1##		;RETURN ERROR CODE
GETE0:	PUSH P,1		;SAVE THE ERROR CODE
	MOVEI 1,0(16)
	CLOSF
	JFCL
	SETZ 1,
	MOVEI 2,FTPG1A
	CALL SETMPG
	CALL CLRLFK
	POP P,1
	JRST ITRAP1		;RETURN ERROR CODE WITH ITRAP

;1 Begin addition
; GETEXE - Get routine for TOPS20 style (.EXE) sharable save files
;	   See TOPS20 Monitor Calls handbook for file format
;
; AC usage (different from above):
;
;	4) Temporary
;	5) Repeat count of number of pages to map
;	6) Count of number of words in directory section

GETEXE:	MOVEI 6,(6)		; Get count of number of entries
	SOJL 6,GETE1		; Minus one for header (must be positive)
	LSH 6,-1		; ...at two words per entry
	MOVEI 1,(16)		; Check for disk device
	DVCHR
	TLNE 2,777
	 ITERR SSAVX1		; If not, error
GETEX2:	JUMPE 6,GETEX5		; If no more entries left, then done
	CALL GETWRD
	MOVEM 2,4		; Save first word
	CALL GETWRD
	HRRZ 1,4		; Get page number in file
	JUMPE 1,GETEX4		; If zero, means "no page" so skip
	HRLI 1,(16)		; Get file handle
	MOVSI 3,READB!XCTB	; Give read and execute access at least
	TLNE 4,(1B1+1B2)	; If wanted write or share, give copy-on-write
	TLO 3,COPYB
	LDB 5,[POINT 9,2,8]	; Get repeat count
	HRLI 2,(15)		; AC2 set up from BIN, get fork handle
GETEX3:	HRRZ 4,2		; Get fork page number
	CAILE 4,777		; Is it a reasonable number?
	 JRST GETEX4		; No, go to next entry
	MOVE 4,SPTC		; Check share count
	CAML 4,SPC1		; If too high, abort
	 ITERR GETX2
	PMAP			; Map the page in
	SOJL 5,GETEX4		; If count goes negative, then done
	ADDI 1,1		; Otherwise, increment page numbers and repeat
	AOJA 2,GETEX3
GETEX4:	SOJA 6,GETEX2		; Decrement entry counter and go back
	;.....

; Now get entry vector and "end of directory" block
; AC usage	4) Temporary
;		5) B0 - Flag to denote entry vector encountered
;		6) Contains entry vector word

	;.....
GETEX5:	MOVSI 6,(JRST)		; Set up default entry vector
	SETZB 4,5		; Clear 4 (count) and 5 (flag)
GETEX6:	CALL GETWRD		; Get next directory word
	SOJGE 4,GETEX6		; Loop through until start of block
	HLRZ 4,2		; Get block type into 4
	CAIN 4,1775		; Is it entry vector?
	 JRST GETEX7		; Yes, go process
	CAIN 4,1777		; Is it end of file?
	 JRST GET1		; Yes, go store entry vector. We're done
	MOVEI 4,(2)		; Don't recognize this block, ignore
	SOJA 4,GETEX6
GETEX7:	TLOE 5,(1B0)		; Set and check if we've evec yet...
	 JRST GETE1		; Yes, we did.  Syntax error
	MOVEI 4,(2)		; Check count of this block
	SUBI 4,3		; Minus header and two for evec spec
	JUMPL 4,GETE1		; If not big enough, error
	CALL GETWRD		; Get a word
	MOVSI 6,(2)		; This is address
	CALL GETWRD
	HRRI 6,(2)		; Next word is count
	JRST GETEX6		; Fall through remaining words, and go on

; GETWRD - Gets word from file and checks for EOF

GETWRD:	MOVEI 1,(16)		; Get JFN
	BIN			; Get byte from file
	JUMPN 2,R		; Return if something there
	GTSTS			; Zero byte, check for EOF
	TLNE 2,1000		; Is flag set?
	 JRST GETE1		; Yes, error
	SETZ 2,			; Restore register
	POPJ P,			; And return
;1 End

;SAVE, GIVEN LIST OF BLOCK DESCRIPTORS OR ONE BLOCK DESCRIPTOR
;
; AC USAGE IN THIS ROUTINE --
; 16/ JFN BEING SAVED ONTO
; 15/ FORK HANDLE BEING SAVED FROM
; 10/ USER'S AC2 -- A SINGLE +N,,ADDR OR A
;     POINTER TO A LIST OF THEM, COUNTED AS THEY ARE PROCESSED.
;  7/ CURRENT +N,,ADDR FROM USER TABLE. MADE -N,,ADDR AT SAVEB
;  6/ -N,,ADDR FOR A GROUP OF NON-ZERO WORDS, OR WORDS UP TO PAGE END
;  5/ POINTER TO WINDOW PAGE (FTPG1), OFFSET VERSION OF RH OF 6

.SAVE:	MCENT
	MOVE 10,2		;SAVE DESCRIPTOR
	CALL GTSVI
	HRRI 2,1B20		;WRITE FILE
	OPENF
	JRST ITRAP1
	MOVEI 2,31
	MOVEI 3,2
	MTOPR			; SET BLOCK SPACING TO 2 IF DTA
	TLNE 10,-1		;SOMETHING IN LH?
	JRST SAVE3		;YES, IT'S ONE DESCRIPTOR
SAVE2:	UMOVE 7,0(10)		;GET NEXT DESCRIPTOR
	JUMPE 7,SAVE1		;CHECK FOR END OF LIST OF DESCRIPTORS
	CALL SAVEB		;WRITE BLOCK
	AOJA 10,SAVE2

SAVE3:	MOVE 7,10
	CALL SAVEB
SAVE1:	MOVEI 1,0(15)		;FORK HANDLE
	CALL SETLFK
	MOVE 2,ENTVEC(1)	;GET ENTRY VECTOR POINTER
	MOVEI 1,0(16)		;JFN
	BOUT			;WRITE ENTRY VECTOR POINTER
SAVER:	CLOSF
	JFCL
	SETZ 1,
	MOVEI 2,FTPG1A		;CLEAR TEMP MAPPINGS
	CALL SETMPG
	JRST CLFRET

;SAVE, PROCESS ONE BLOCK
; ARGUMENT IS +N,,ADDR IN 7 . SEE AC USAGE COMMENT ABOVE

SAVEB:	HLRZ 6,7		;MAKE LH COUNT NEGATIVE
	TRZE 6,400000		;LARGER THAN 377777?
	PUSH P,[SAVEBL]		;YES, DO IN TWO PARTS
	MOVNI 6,0(6)
	HRLI 7,0(6)
SAVEB1:	TSTINT
	CALL GETINT
	JUMPGE 7,R		;DONE?
	MOVE 6,7		;SETUP TO SCAN FOR NON-0'S
	LDB 1,[POINT 9,6,26]	;GET PAGE NUMBER
	CAIN 1,0(4)		;DIFFERENT FOR CURRENT MAPPING?
	JRST SAVE3A		;NO, SAME
	MOVEI 4,0(1)
	HRLI 1,0(15)		;FORK HANDLE
	CALL FKHPTN
	PUSH P,1
	CALL MRPACS		;SEE IF PAGE EXISTS
	POP P,2
	TLNN 1,READB		;CAN IT BE READ?
	JRST SAVE3B		;NO, FORGET IT
	MOVE 1,2
	MOVE 2,[XWD RWX,FTPG1A]
	CALL SETMPG		;MAP PAGE
SAVE3A:	CALL GET3A		;SETUP REFERENCE ADDRESS
	JRST SAVE8

SAVE3B:	ANDI 6,777000
	ADDI 6,1000		;TO NEXT PAGE
	SUBI 6,0(7)
	HRLI 6,0(6)		;COUNT OF WORDS SKIPPED IN BOTH HALVES
	ADD 7,6			;UPDATE COUNT AND ADDRESS
	JRST SAVEB1

SAVEBL:	HRLI 7,400000		;DID N-400000 BEFORE, DO LAST 400000 NOW
	JRST SAVEB1

SAVE12:	TRNN 6,777		;NEW PAGE?
	JRST SAVE5		;YES
SAVE8:	SKIPN 0(5)		;NON-0 WORD?
	JRST SAVE6		;NO, GO CHECK FOR MORE
SAVE7:	ADDI 5,1
	AOBJN 6,SAVE12
	MOVE 6,7		;END OF BLOCK. 6/ -N,,ADDR

;WRITE ALL OR PART OF ONE PAGE. ARGS ARE -N,,ADDR IN 6 AND
; OFFSET ADDR IN 5. ALSO -N',,ADDR IN 7.
;VALUES ARE UPDATED 5 AND 7


SAVED:	HLRE 2,6		;COUNT OF WORDS JUST SCANNED
	ADD 5,2			;RESET WINDOW POINTER
	MOVEI 1,0(16)		;JFN
	MOVE 2,6
	SUBI 2,1		;OUTPUT IOWD CNT,ADR
	BOUT
	MOVEI 2,(5)		;FORM BYTE POINTER TO WINDOW
	HRLI 2,444400		; FOR 36 BIT SOUT
	HLRO 3,6		;NEGATIVE COUNT
	SOUT			;OUTPUT THIS BLOCK OF DATA
	HLRO 6,6		;NOW UPDATE THE POINTERS. - NUM WDS SENT
	MOVM 6,6		;POSITIVE NUMBER OF WORDS SENT
	ADDI 5,(6)		;UPDATE POINTER TO WINDOW
	HRLI 6,(6)		;PLUS N IN BOTH HALVES
	ADD 7,6			;UPDATE MAJOR AOBJN CTR. MAY BE SOME LEFT
	RET

;SPECIAL PURPOSE JSYS'S INSTALLED BY ***SRI-AIC***		BEGIN ***SRI-AIC*** TO END OF PAGE

repeat 0,<
;	NETON JSYS,  TRUNS THE NET ON AND OFF ACCORDING TO THE CONTENTS OF
;	AC1.	AC1=0	== TURN THE NET OFF
;		AC1=-1	== TURN THE NET ON
.SETNT:	MCENT	;USE SLOW CODE
	SETZ 0,		;ASSUME HE WANTS IT OFF
	JUMPE 1,.+3	;DOES HE?
	SETO 0,		;NO, SEE IF HE WANTS IT ON
	AOJN 1,MRETN	;MAYBE, BUT HE DIDN'T SAY IT RIGHT
	MOVEM 0,NETON	;OK, SET IT
	JRST MRETN
>; end repeat 0 SETNT
;FOUND 0 WORD, CHECK FOR MORE

SAVE6:	MOVEI 2,0(6)
	CAIN 2,0(7)		;FIRST WORD OF BLOCK OR PAGE?
	JRST SAVE9		;YES
	HLRZ 2,6
	SETCMI 3,0(6)
	CAIE 2,-1		;END OF BLOCK, OR
	TRNN 3,777		;END OF PAGE?
	JRST SAVE5		;YES, FINISH BLOCK
	SKIPE 1(5)		;SUCCESSIVE 0?
	JRST SAVE7		;NO, CONTINUE SCAN
SAVE5:	MOVNI 6,0(6)		;COMPUTE NUMBER OF WORD TO DUMP
	ADDI 6,0(7)		;(-CURRENT)+OLD = -DIFFERENCE
	MOVSI 6,0(6)
	HRRI 6,0(7)		;FIRST ADDRESS
	CALL SAVED		;WRITE BLOCK
	JRST SAVEB1

;SCAN OVER BLOCK OF 0'S

SAVE10:	TRNE 6,777		;END OF PAGE?
	SKIPE 0(5)		;OR NON-0 WORD?
	JRST SAVE11		;YES
SAVE9:	ADDI 5,1
	AOBJN 6,SAVE10
SAVE11:	MOVE 7,6		;UPDATE POINTER
	JRST SAVEB1		;RECHECK PAGE, ETC.

;SHARED SAVE

.SSAVE:	MCENT
	MOVE 10,2		;OUTPUT DESCRIPTOR
	CALL GTSVI
	TLNE 3,777		;DISK?
	JRST SSAVE1		;GOTTA BE
	HRRI 2,1B20		;WRITE
	OPENF
	JRST ITRAP1
	MOVSI 13,2		;START MAPPING INTO FILE PAGE 2
	JUMPL 10,SSAV3		;SINGLE DESCRIPTOR
SSAV2:	UMOVE 7,0(10)		;GET NEXT DESCRIPTOR
	JUMPE 7,SSAV1		;DONE
	CALL SSAVB		;OUTPUT THE STUFF
	AOJA 10,SSAV2

SSAV3:	MOVE 7,10
	CALL SSAVB
SSAV1:	MOVEI 1,0(15)		;FORK HANDLE
	CALL SETLFK
	MOVE 2,ENTVEC(1)	;PUT ENTRY VECTOR IN FILE
	MOVEI 1,0(16)		;JFN
	BOUT
	HLRZ 2,13		;NEXT FREE PAGE IN FILE
	ASH 2,^D9		;FIRST WORD OF THAT PAGE
	SFPTR			;SET EOF AFTER ALL EXISTING PAGES
	BUG(CHK,<SSAVE - UNEXPECTED BAD RETURN FROM SFPTR>)
	JRST SAVER		;REGULAR FINISH UP

;SAVE PAGES ACCORDING TO AC7, XWD -NPAGES,,ACCESS,FIRST PAGE

SSAVB:	PUSH P,10
	TLC 7,777000		;MAKE SURE COUNT .L. 1000 PAGES
	TLCE 7,777000		;I.E. BITS 0-8 SHOULD BE 0
	ITERR SSAVX2		;LOSE
	HLLZ 13,13		;CLEAR COUNT FOR PAGES IN THIS BLOCK
	SETZ 1,
	MOVEI 2,FTPG1A
	CALL SETMPG		;CLEAR TEMP PAGE
SSAVB2:	MOVSI 1,0(15)
	HRRI 1,0(7)
	ANDCMI 1,777000		;FLUSH ACCESS BITS FROM HERE
	RPACS			;GET STATE OF THIS MEM PAGE
	JUMPE 2,SSAVB1		;DOESN'T EXIST
	TLNN 2,(1B2)		;READABLE?
	JRST SSAVB1		;NO, SKIP IT
	TRNE 7,1B19		;ACCESS FROM SOURCE PAGE REQUESTED?
	JRST [	TSC 7,2		;YES
		TRZ 7,1B18+RWX+TRAPUB ;MOVE THESE BITS INTO ACCESS WD
		TSC 7,2		;FROM RPACS OF SOURCE PAGE
		TLNE 2,WRITEB+COPYB ;SOURCE HAS SOME KIND OF WRITE?
		TRO 7,1B18	;YES, GIVE WRITE-COPY
		JRST .+1]
	CALL FKHPTN
	MOVE 2,[XWD RWX,FPG2A]
	CALL SETMPG		;SETUPT INDIRECT PTR TO USER PAGE
	MOVSI 1,0(16)		;JFN
	HLR 1,13		;FILE PAGE NUMBER
	PUSH P,13
	CALL JFNOFN
	BUG(HLT,<SSAVE - JFNOFN FAILED>)
	POP P,13
	MOVE 2,[XWD RWX,FPG3A]
	CALL SETMPG		;MAP THE FILE PAGE
	HRLI 2,FPG2A
	BLT 2,FPG3A+777		;COPY USER'S PAGE TO FILE
	HLRZ 2,13		;PAGE IN FILE TO USE
	HRLI 2,0(7)		;MEM PAGE IN LH, FILE PAGE IN RH
	TLZ 2,(1B1+7B7)		;FLUSH UNSPECIFIED BITS
	MOVEM 2,FTPG1A(13)	;SAVE FOR LATER OUTPUT
	AOBJP 13,.+1		;INCREMENT FILE PAGE NUMBER AND COUNT
SSAVB1:	AOBJN 7,SSAVB2		;COUNT MEM PAGES
	MOVEI 2,0(13)		;NUMBER OF FILE PAGES DONE
	JUMPE 2,SSAVB3
	HRLI 2,1000		;TYPE NUMBER
	MOVEI 1,0(16)
	BOUT
	MOVNI 7,0(13)		;GET NEG COUNT FOR THIS BLOCK
	MOVSI 7,0(7)		;SETUP AOBJN WORD
	MOVE 2,FTPG1A(7)	;GET WORD FOR ONE PAGE
	BOUT
	AOBJN 7,.-2
SSAVB3:	SETZ 1,			;CLEAR TEMP PAGE
	MOVEI 2,FTPG1A
	CALL SETMPG
	MOVEI 2,FPG2A
	CALL SETMPG
	MOVEI 2,FPG3A
	CALL SETMPG
	POP P,10
	RET

;OPERATOR FUNCTION CALL JSYS "OPRFN". THIS JSYS EXISTS TO BE
;USED BY THE EXEC OR EPHEMERONS TO DO OPERATOR TASKS, SO THE OP
;DOES NOT NEED TO GET INTO MDDT MOST OF THE TIME.
;
;THE FUNCTIONS ARE CALLED BY SIXBIT NAME, WHICH REQUIRES A TABLE
;SEARCH BUT IS OK BECAUSE THESE FUNCTIONS SHOULD ONLY BE CALLED
;ONCE A DAY OR SO. 
;
;FIELD SITES NOTE -- BBN WILL NEVER ADD ANY SIXBIT NAMES STARTING WITH
;THE LETTER "X". FIELD SITES CAN USE THAT CLASS OF NAMES WITHOUT 
;NEEDING TO WORRY ABOUT CONFLICT WITH FUTURE BBN FUNCTIONS.

;CALL - MOVE 1,[SIXBIT .FUNCTION-NAME.]
;	MOVE 2,ARGUMENT DEPENDENT ON FUNCTION. (MORE IN 3 &4...)
;	OPRFN
;	  FAIL RETURN, ERROR CODE IN 1
;	GOOD RETURN

INTERN .OPRFN

.OPRFN:	MCENT			;ESTABLISH MONITOR CONTEXT
	MOVSI F,-NOPRFS		;COUNT THRU NAME TABLE
	CAMN A,OPRFTB(F)	;SEARCH. THIS ONE?
	JRST OPRFN1		;YES.
	AOBJN F,.-2		;NO, SEARCH ONWARDS.
	MOVEI A,OPRFX1##	;NOT IN TABLE.
	JRST MRETNE##		;FAIL, NONSKIP, CODE TO LSTERR AND 1

OPRFN1:	HLRZ E,OPRFT2(F)	;SEE WHAT CAPABILITIES ARE NEEDED
	TDNN E,CAPENB		;ARE THEY ON IN THIS FORK?
	JRST CAPX		;NO. FAIL.
	HRRZ E,OPRFT2(F)	;YES. GO DO THE FUNCTION
	PUSHJ P,0(E)		; ..
	  JRST MRETNE		;FAILED. ERROR CODE IN 1
	JRST SKMRTN		;SUCCESS RETURN.

;HERE ARE THE FUNCTIONS DEFINED SO FAR. ARGS TO THE "X" MACRO
; ARE SIXBIT NAME, CAPABILITIES NEEDED, TAG TO CALL.

DEFINE OPRFNS <
IFDEF IMPCHN,<
	X(IMPDRQ,WHEEL+OPER+MAINT,OPRICY)
	X(HSTINI,WHEEL+OPER,OPRHIN)
	X(NETON,WHEEL+OPER+MAINT,OPRNTN)>

IFNDEF IMPCHN,<X(HSTINI,WHEEL+OPER,OPRHIN)>

IFN JTRPSW,<X(JTRPON,WHEEL+OPER,OPRJTN)>

	X(ENTFLG,WHEEL+OPER+MAINT,OPRENT)
	X(MKPGSA,WHEEL+OPER+MAINT,OPRMPA)
	X(MKPGSU,WHEEL+OPER+MAINT,OPRMPU)
	X(DDTFSH,WHEEL+OPER,OPRFSD)
	X(DBUGSW,WHEEL+OPER,OPRBSW)
	X(DCHKSW,WHEEL+OPER,OPRCSW)
	X(CDMPSW,WHEEL+OPER,OPRDSW)
	X(RELDSW,WHEEL+OPER,OPRRSW)
	X(FDDTSW,WHEEL+OPER,OPRFSW)
	X(USRSPC,WHEEL+OPER,OPRUSP)
	X(SYSSPC,WHEEL+OPER,OPRSSP)
	X(ACTINI,WHEEL+OPER,OPRACT)
	X(TYMNET,WHEEL+OPER+MAINT,OPRTYM)
	X(MON2US,WHEEL+OPER+MAINT,OPRM2U)
	X(US2MON,WHEEL+OPER+MAINT,OPRU2M)
	X(QUEBAT,WHEEL+OPER+MAINT,OPRBAT)
	X(DSKBTI,WHEEL+OPER+MAINT,OPRBTI)
	X(TTYSPY,WHEEL,OPRSPY)
IFN SWTFLG,<X(WATCH,WHEEL,OPRWAT)>
;ADD MORE HERE
>

DEFINE X(NAME,CAPS,ROUTIN)<	<SIXBIT \NAME\>>
OPRFTB:	OPRFNS
NOPRFS==.-OPRFTB

DEFINE X(NAME,CAPS,ROUTIN)<	XWD CAPS,ROUTIN>
OPRFT2:	OPRFNS

;REINIT THE DISK BITTABLE

OPRBTI:	CALL REDBTI##		;REINIT DISK BITTABLE
	AOS (P)
	RET

;QUEUE BAT BLOCK ENTRY FOR JOB 0 TO ENTER
;ACCEPTS HARWARE DISK ADR IN 2
;AC 2 1B0 ON TO TELL JOB 0 TO MAKE ENTRY EVEN IF DISK ADR ALREADY ASSIGNED
;SKIPS FOR SUCCESS, NO SKIP IF FAILED

OPRBAT: MOVE 1,2		;ENTRY IS IN 2 JUST AS IT GOES IN BATENQ
	CALL QUEBAT##		;QUE FOR JOB 0
	 SKIPA 1,[OPRFX3##]	;FAILED-GIVE ERROR CODE, NO SKIP
	AOS (P)
	RET


;TABLE OF MONITOR CELLS ACCESSABLE TO USER

OPRMTB:	FORKX##			;SYSTEM FORK INDEX IN PSB
	SCDRN1##		;RUN JUST SPECIFIED JOB
	SCDRN2##		;RUN JUST SPECIFIED JOB AND JOB 0
NMONTB==.-OPRMTB

;STORE MONITOR CELL IN 2 INTO USER CELL IN 3
;IF 2 HAS 1B0: RH 2 IS INDEX INTO MONITOR CELL TABLE

OPRM2U:	TLZE 2,(1B0)		;INDEX?
	 JRST OPRM21		;YES
	MOVE 2,(2)		;GET MON CONTENTS
	UMOVEM 2,(3)		;INTO USER ADR SPACE
	JRST RSKP

OPRM21:	CAIL 2,0		;RANGE CHECK
	CAILE 2,NMONTB-1
	 JRST [	MOVEI 1,OPRFX1##
		RET]
	MOVE 2,@OPRMTB(2)	;GET CONTENTS VIA TABLE
	UMOVEM 2,(3)		;INTO USER SPACE
	JRST RSKP

;LOAD MONITOR CELL IN 2 FROM USER CELL IN 3
;IF 2 HAS 1B0: RH 2 IS INDEX INTO MONITOR CELL TABLE

OPRU2M:	TLZE 2,(1B0)		;INDEX?
	 JRST OPRU21		;YES
	UMOVE 3,(3)		;GET USER CONTENTS
	MOVEM 3,(2)		;INTO MONITOR ADR SPACE
	JRST RSKP

OPRU21:	CAIL 2,0		;RANGE CHECK
	CAILE 2,NMONTB-1
	 JRST [	MOVEI 1,OPRFX1##
		RET]
	UMOVE 3,(3)		;GET USER CONTENTS
	MOVEM 3,@OPRMTB(2)	;STORE CONTENTS VIA TABLE
	JRST RSKP


OPRTYM:	SKIPE C,B		; SET TYMFLG TO 0 OR -1
	AOJN C,OPRFXX		; JUMP IF NOT LEGAL VALUE
	MOVEM B,TYMFLG##	; OK, SET IT.
	JRST RSKP

;SPY DETECTOR
;ACCEPTS LINE # TO CHECK IN 2
;RETURNS +1 IF ERROR OR NOT BEING SPIED ON (-1 RETURNED THEN)
;RETURNS +2 	1/ <USER # DOING THE SPYING>,,<TTY #,JOB #>
;		2/ <USER # DOING THE SPYING>,,<TTY #,JOB #> OR 0 FOR NOONE
;		3/ <USER # DOING THE SPYING>,,<TTY #,JOB #> OR 0 FOR NOONE
;		4/ <USER # DOING THE SPYING>,,<TTY #,JOB #> OR 0 FOR NOONE
;		IF JOB & USER NOT IDENTIFIABLE THEY WILL BE -1 BUT TTY # VALID

OPRSPY:	MOVEI 1,DESX1##			;IN CASE ILLEGAL LINE #
	CAIL 2,0			;LEGAL TTY #?
	CAILE 2,NLINES
	 RET
	NOINT
	NOSKED				;LOCK UP
	MOVE 1,TTLINK##(2)		;GET LINK WORD
	CAMN 1,MINUS1##			;ANYONE SEEING MY OUTPUT?
	 JRST OPRSP5			;RET +1 WITH -1 IN AC1 IF NO SPIES
	SETZ 0,				;0 IS SPY COUNTER
	MOVE 4,[-4,,11]			;4 TTYS POSSIBLE,,DEST AC
	MOVE 5,[POINT 9,TTLINK##(2)]	;PT AT 1ST BYTE FOR ILDB
OPRSP1:	ILDB 3,5			;GET SPYING TTY # IN 3
	CAIN 3,777			;IN USE?
	 JRST OPRSP2			;NO-LOOP
	CALL OPRSCK			;CHECK TO SEE NOT A FULL LINK
	 JRST OPRSP2			;WE SEE THEM TOO, NOT A SPY THEN
	HLRE 1,TTFORK##(3)		;GET JOB #
	SKIPGE 1			;WEIRD?
	SKIPA 1,MINUS1##		;YES-RETURN -1 FOR JOB AND USER FIELDS
	HRL 1,JOBDIR##(1)		;MAKE USER,,JOB
	DPB 3,[POINT 9,1,^D26]		;MAKE USER,,<TTY,JOB>
	MOVEM 1,(4)			;INTO USER ACS
	ADDI 0,1			;REMEMBER # REAL SPIES IN 0
	JRST OPRSP3			;AND LOOP

OPRSP2:	SETZM (4)			;CLEAR AC , NOT IN USE
OPRSP3:	AOBJN 4,OPRSP1
OPRSP4:	CAIN 0,0			;ANY SPIES SEEN?
	 JRST OPRSP5			;NO-RETURN AC1/ -1 AND NOSKIP
	UMOVEM 11,1			;RETURN INFO IN USER ACS
	UMOVEM 12,2
	UMOVEM 13,3
	UMOVEM 14,4
	AOS (P)				;SKIP RET
	JRST OPRSP6

OPRSP5:	SETO 1,				;-1 RETURNED VIA MRETNE FOR NO SKIP
OPRSP6:	OKSKED				;OTHERWISE ALREADY RETURNED FOR SKPRET
	OKINT
	RET

;SEES IF WE SEE SUSPECTED TERMINALS OUTPUT TOO (NOT A SPY BUT A FULL LINK)
;ACCEPTS 2/ OUR TERMINAL
;	 3/ TERMINAL SUSPECTED OF SPYING ON US
;RETURNS +1 FULL LINK
;	 +2 SPYING
;CLOBBERS AC 1

OPRSCK:	PUSH P,2			;SAVE OUR TERMINAL
	PUSH P,4			;AND 4
	MOVE 2,[POINT 9,TTLINK##(3)]	;POINT TO SUSPECTS LINK WORD
	MOVSI 4,-4			;CHECK 4 TTYS
OPRSC1:	ILDB 1,2			;GET A TTY
	CAMN 1,-1(P)			;OUR TTY?
	 JRST OPRSC2			;YES-NOT A SPY
	AOBJN 4,OPRSC1			;LOOP FOR ALL
	AOS -2(P)			;A SPY!  WE DON'T SEE HIS OUTPUT
OPRSC2:	POP P,4
	POP P,2
	RET

IFDEF IMPCHN,<
OPRNTN:	SKIPE C,B		;SET NETON TO 0 OR -1
	AOJN C,OPRFXX		;JUMP IF NOT LEGAL VALUE
	MOVEM B,NETON##		;OK, SET IT.
	JRST RSKP
>

OPRENT:	SKIPE C,B		;SET ENTFLG TO 0 OR -1
	AOJN C,OPRFXX		;JUMP IF NOT 0 OR -1
	MOVEM B,ENTFLG##	;OK, SET IT.
	JRST RSKP
IFN JTRPSW,<
OPRJTN:	SKIPE C,B		;SET JTRPON TO 0 OR -1
	AOJN C,OPRFXX		;JUMP IF NOT LEGAL VALUE
	MOVEM B,JTRPON##	;OK, SET IT.
	JRST RSKP
>
OPRFSD:	PUSHJ P,DDTFSH		;FLUSH DDT
	JRST RSKP

OPRDSW:	CAIE B,0		;SET CDMPSW TO 0 OR 1
	CAIN B,1
	CAIA
	 JRST OPRFXX
	MOVEM B,CDMPSW
	JRST RSKP

OPRRSW:	CAIE B,0		;SET RELDSW TO 0 OR 1
	CAIN B,1
	CAIA
	 JRST OPRFXX
	MOVEM B,RELDSW
	JRST RSKP


OPRFSW:	CAIE B,0		;SET FDDTSW TO 0 OR 1
	CAIN B,1
	CAIA
	 JRST OPRFXX
	MOVEM B,FDDTSW
	JRST RSKP


OPRBSW:	CAIL B,0		;SET DEBUGSWITCH TO 0 THRU 2
	CAILE B,2		; ..
	JRST OPRFXX		;BAD VALUE
	MOVEM B,DBUGSW		;OK. SET IT
	JRST RSKP

OPRCSW:	CAIE B,0		;0 OR 1 TO DCHKSW
	CAIN B,1
	JRST OPRCS1		;OK
OPRFXX:	MOVEI A,OPRFX2##		;BAD ARG ERROR CODE
	POPJ P,0		;NON-SKIP RETURN
OPRCS1:	MOVEM B,DCHKSW		;STORE GOOD DCHKSW
	JRST RSKP

OPRMPA:	MOVE A,B		;MOVE ARGUMENTS OVER TO 1 AND 2
	MOVE B,C
	CAMLE A,B		;PAGES IN RIGHT ORDER?
	JRST OPRFXX
	CAMLE A,SWPCOR		;AND IN REASONABLE AREA?   ***SRI-AI***
	CAIL B,MAXCOR		; ..
	JRST OPRFXX		;NO
	PUSHJ P,MKPGSA		;PUT PAGES ON LINE
	JRST RSKP

OPRMPU:	MOVE A,B		;TAKE PAGES OFF LINE
	MOVE B,C
	CAMLE A,B
	JRST OPRFXX
	CAML A,SWPCOR
	CAIL B,MAXCOR
	JRST OPRFXX
	PUSHJ P,MKPGSU
	JRST RSKP

OPRUSP:	JUMPL B,OPRFXX		;LEGAL FOR .GE. 0
	MOVEM B,USRSPC##	;SET USER DISK LIMIT
	JRST RSKP

OPRSSP:	JUMPL B,OPRFXX		;LEGAL FOR .GE. 0
	MOVEM B,SYSSPC##	;SET SYSTEM DISK LIMIT
	JRST RSKP

OPRACT:	CALL ACTIN1##		; PUT NEW UACHK.FILE OUT
	 RET				; FAILED
	JRST RSKP			; OK

IFDEF IMPCHN,<
OPRHIN:	CALL HSTINI##		;LOAD NEW HOST NAME FILE
	  POPJ P,0		;FAILED
	JRST RSKP		;OK.

OPRICY:	MOVEI B,1		;SET IMPDRQ TO CYCLE THE NET
	MOVEM B,IMPDRQ##	; ..
	JRST RSKP		;RETURN.
>

IFNDEF IMPCHN,<
OPRHIN:	CALL HSTINI##		;LOAD NEW HOST NAME FILE
	  POPJ P,0		;FAILED
	JRST RSKP		;OK.
>


IFN SWTFLG,<
OPRWAT:	CAIE B,0		;SET GATHER TO 0 OR 1
	CAIN B,1
	 CAIA			;OK
	JRST OPRFXX		;BAD ARG ERROR CODE
	MOVEM B,GATHER##	;STORE GOOD GATHER
	SETZM WRQIX##
	SETZM RDQIX##
	SETZM WRQSMX##
	SETZM RDQSMX##
	SETZM RDQIDL##
	SETZM INRPLQ##
	SETZM IIOIP##
	SETZM ISUMNR##
	MOVE A,TODCLK
	MOVEM A,LASTIM##
	SETZ B,
	MOVSI A,-NJOBS
OPRWT1: HRRZ C,A	
IFN WSPFLG,<
	HRLM B,JOBWSP(C)
>
	HRLM B,JOBPGF(C)
	CAIG C,NNAMES-1
	 HRRM B,SBLKTM(C)
	AOBJN A,OPRWT1
	JRST RSKP	
>
	END ; OF MONJS.MAC

