;<PUP>PFUCMD.MAC;3     2-SEP-79 15:57:17    EDIT BY TAFT;<PUP>PFUCMD.MAC;2     2-JUN-77 21:34:33    EDIT BY TAFT; Make control-F not echo;<PUP>PFUCMD.MAC;1    10-MAR-77 14:04:33    EDIT BY TAFT; Split out from PUPFTP.MAC; Copyright 1979 by Xerox Corporation	TITLE PFUCMD -- PUP FTP USER COMMAND INTERPRETER ROUTINES	SUBTTL E. A. Taft / March 1977	SEARCH PUPDEF,PFUDEF,STENEX	USEVAR FTPVAR,FTPPVR; Input keyword from terminal;	A/ -length ,, address of keyword table; Returns +1:  Not found, no word input, or line delete typed;	+2:  Found, A/ address of matching keyword table entry; In either case, the word that was input is described by; WRDLEN and WRDBYT.  Recognition is performed if the keyword; is terminated by Escape, and the tail is appended to CMDBUF.; On either return, D contains the attributes of the terminating; character.; Clobbers A-DINKEY::	PUSHJ P,SAVE1##		; Get another ac	MOVE P1,A		; Use it to hold cmd tbl ptrINKEY1:	MOVEI A,KEYHLP		; Routine to call on "?"	MOVSI B,(C.ALPH+C.NUM)	; Only alphanumerics allowed	TRO F,RAISEF		; Raise lower case letters	PUSHJ P,INWORD		; Input a word	 JRST INKEY9		; Line delete typed, return +1	JUMPE C,INKEY9		; Give error return on empty word	HRROI A,TEMP##		; Copy the word here	PUSHJ P,CPYWRD	MOVE A,P1		; Set command table ptr	HRROI B,TEMP##		; Get byte ptr to start of word	PUSHJ P,NAMSRC##	; Search for name in table	 JRST INKEY2		; Not found	JRST INKEY6		; Found, give success return; If exact match not found, check for unique initial substring.;	A/ AOBJN ptr to smallest entry > keyINKEY2:	JUMPGE A,INKEY8		; Fail if off end of table	AOBJP A,INKEY3		; Advance to next, jump if none	PUSHJ P,NAMCMP##	; Compare strings	 JUMPN D,[TRNN F,ESCAPF	; Ambiguous, terminated by Escape?		 JRST INKEY8	; No, fail as if not found		ERROR <>	; Yes, ring bell to say ambiguous		JRST APWORD]	; Resume INWORD for more input	 JRST INKEY3		; Did not match, continue	PUSHJ P,SCREWUP##	; Wasn't supposed to match!INKEY3:	SUB A,[1,,1]		; Now back to current entry	PUSHJ P,NAMCMP##	; Compare strings	 JUMPN D,INKEY4		; Jump if initial substring	 JRST INKEY8		; No match, fail	PUSHJ P,SCREWUP##; Got unique initial substring; Print and append tail if input terminated by Escape;	D/ String pointer to tailINKEY4:	TRNN F,ESCAPF		; Input terminated by Escape?	 JRST INKEY6		; No, just give success return	PUSH P,A		; Yes, save ptr to matching entry	TYPE <%4S>		; Print tail	PUSHJ P,BAKBYT		; Back up to overwrite terminatorINKEY5:	ILDB A,D		; Get char of tail	JUMPN A,[IDPB A,CMDBYT	; If non-null, append to command		AOS WRDLEN	; Account in word length		JRST INKEY5]	; Repeat	MOVEI A,33		; Put Escape on end	IDPB A,CMDBYT	POP P,A			; Restore ptr to matching entry; Here to take success returnINKEY6:	PUSHJ P,ESPACE		; Print space if Escape typed	AOS 0(P)		; Preset +2 return; Here to take fail returnINKEY8:	LDB B,CMDBYT		; Recover terminator	MOVE D,CHRTAB(B)	; Return attributes for terminatorINKEY9:	TRZ F,RAISEF		; Stop raising lower-case letters	POPJ P,; Help routine called from within INWORD if "?" typed;	P1/ Keyword table pointer (as passed to INKEY); Returns +1; Clobbers A, BKEYHLP:	TYPE < One of the following:%/>	SKIPA D,P1		; Copy keyword table pointerKEYHL1:	PRINT ","		; Comma	MOVEI A,101		; Get width of page	RFMOD	LDB C,[POINT 7,B,17]	RFPOS			; Get current position on page	CAIGE C,^D15(B)		; Room for another keyword?	 PRINT EOL		; No, go to new line	HLRO B,0(D)		; Get key name string ptr	TYPE < %2S>		; Print it	AOBJN D,KEYHL1		; Repeat for all	POPJ P,; Copy last word input (not including terminator) to another place.; Characters are quoted as appropriate for inclusion in property; lists.;	A/ Destination string ptr; Returns +1; Updates A, clobbers B, C, appends null to destination stringCPYWRD::TLC A,-1		; Turn -1 lh into byte ptr	TLCN A,-1	 HRLI A,(POINT 7)	MOVE B,WRDBYT		; Get ptr to start of last wordCPYWR1:	ILDB C,B		; Get a byte	CAMN B,CMDBYT		; Was that the terminator?	 JRST [	MOVE B,A	; Yes, append null		SETZ C,		IDPB C,B		POPJ P,]	; Done	CAIE C,"("		; Character need quoting?	CAIN C,")"	 JRST .+3		; Yes	CAIE C,PQUOTE	 JRST CPYWR2		; No	MOVEI C,PQUOTE		; Yes, insert quote	IDPB C,A	LDB C,B			; Recover the characterCPYWR2:	IDPB C,A		; Store it	JRST CPYWR1		; Repeat; Confirm typed-in command by awaiting carriage return; Returns +1:  Aborted;	+2:  Confirmed; Clobbers A-DCONFRM::LDB A,CMDBYT		; Get existing terminator	MOVE D,CHRTAB(A)	; Get attributes for character	MOVEI A,100		; Set to wakeup on all characters	MOVEI B,77B23+2B25+1B29	SFMODCONFR1:	TLNE D,(C.CEOL)		; End-of-line character?	 JRST SKPRET##		; Yes, return +2	TLNE D,(C.SPAC)		; Space?	 JRST .+3		; Yes, just ignore	ERROR < ? >		; No, complain	PUSHJ P,BAKBYT		; Remove byte from buffer	HRROI A,[ASCIZ /Confirm with carriage return/]	SETZ B,			; No legal word constituents	PUSHJ P,INWORD		; Input a character	 POPJ P,		; Line delete, abort command	JRST CONFR1		; Got char, check it; Input and edit word up to a terminator;	A/ String pointer to text to print if "?" input;	   or 0,,address of routine to call;	B/ Attribute bits denoting legal constituent characters; Returns +1:  Line delete encountered;	+2:  Normal, A/ Terminating character;		B/ Byte pointer to start of word (also in WRDBYT);		C/ Character count (also in WRDLEN);		D/ Attribute bits for terminating character; Leading spaces and tabs are ignored if space is not a legal; constituent character (but are still stored in the buffer).; Terminating character stored in buffer but not included in count.; If the terminator is Escape, the ESCAPF flag is set.INWORD::MOVEM A,HLPDAT		; Store help data	MOVEM B,WRDATR		; Store character attributes	SETZM WRDLEN		; Init # characters in current word	MOVE A,CMDBYT		; Preserve pointer to start	MOVEM A,WRDBYT	POP P,WRDXIT		; Save return in case APWORD called	MOVEM P,WRDPDP		; Save stack pointer too	JRST INWOR0		; Enter edit loop; Enter here to append to an existing word; Overwrites existing terminator (assumed to be Escape); Returns to where INWORD was last called from!APWORD::MOVE P,WRDPDP		; Get stack ptr from INWORD call	PUSHJ P,BAKBYT		; Back up byte pointerINWOR0:	PUSH P,WRDXIT		; Put exit point back on stack; Loop here for each character inputINWOR1:	TRNE F,NEOLEF		; Want EOL echoing off?	 JRST [	MOVEI A,100	; Yes, get current control bits		RFCOC		PUSH P,B	; Save current settings		PUSH P,C		TRZ B,3B21+3B27	; Turn off cr, lf, eol		TRZ C,3B27		SFCOC		; Issue revised settings		BIN		; Input the char		EXCH B,-1(P)	; Save char, restore old settings		POP P,C		SFCOC		POP P,A		; Restore char		JRST .+2]	PBIN			; Input character from terminal	TRZ F,ESCAPF		; Assume it is not EscapeINWOR2:	MOVE D,CHRTAB(A)	; Get attributes and dispatch adr	TRNE D,-1		; Is there a special dispatch?	 JRST 0(D)		; Yes, take itINWOR3:	IDPB A,CMDBYT		; No, append char to string	HRRZ B,CMDBYT		; Make sure not overflowing buffer	CAIL B,CMDBUF+CMDLEN-1	 JRST [	MOVSI D,(C.CDEL)  ; Treat as command delete		ERROR(<%/Command too long>,1)]	TDNN D,WRDATR		; Is this a terminating character?	 JRST INWOR4		; Yes	AOS WRDLEN		; No, count characters in word	JRST INWOR1		; Back for moreINWOR4:	PUSHJ P,APPNUL		; Append null to command	LDB A,CMDBYT		; Recover terminating char	MOVE B,WRDBYT		; Get starting byte pointer	MOVE C,WRDLEN		; Get character count	JRST SKPRET##		; Return +2; Special characters handled by INWORD; Lower case lettersLOWERC:	TRNE F,RAISEF		; Want to raise lower case letters?	 SUBI A,40		; Yes, do so	JRST INWOR3; Control-VCTRLV:	PBIN			; Input next character literally	MOVSI D,(C.ALPH)	; Treat as alphabetic	JRST INWOR3; Control-ACTRLA:	SKIPG WRDLEN		; Any characters to delete?	 JRST [	ERROR <>	; No, ring bell		JRST INWOR1]	; Ignore	PRINT "\"		; Yes, print backslash	LDB A,CMDBYT		; Get last character typed in	TRNN F,NECHOF		; Unless echoing off	 PRINT (A)		; Print it	PUSHJ P,BAKBYT		; Back up byte pointer	SOS WRDLEN		; Decrement count	JRST INWOR1		; On to next character; Control-WCTRLW:	SKIPG WRDLEN		; Any characters to delete?	 JRST [	ERROR <>	; No, ring bell		JRST INWOR1]	; Ignore	PRINT "_"		; Yes, note word delete	SETZM WRDLEN		; Zero character count	MOVE A,WRDBYT		; Reset byte pointer	MOVEM A,CMDBYT	JRST INWOR1		; On to next character; "?"INQUES:	SKIPE WRDLEN		; First character of word?	 JRST INWOR3		; No, treat normally	MOVE A,HLPDAT		; Yes, get help data word	TLNE A,-1		; String pointer?	 TYPE < %1S>		; Yes, type string	TLNN A,-1	 PUSHJ P,0(A)		; No, use as address of routine	JRST CTRLR1		; Retype command line; Control-RCTRLR:	TRNE F,NECHOF		; Echoing off?	 JRST [	ERROR <>	; Yes, refuse to retype (since		JRST INWOR1]	;  we might type a password)CTRLR1:	PRINT EOL		; Print crlf	PUSHJ P,APPNUL		; Append null to command string	HRROI A,CMDBUF		; Print contents of command string	PSOUT	JRST INWOR1		; On to next char; More INWORD special characters; Space or tabINSPAC:	TDNN D,WRDATR		; Is space a terminator?	SKIPE WRDLEN		; Yes, is this a leading space?	 JRST INWOR3		; No, handle normally	IBP WRDBYT		; Yes, advance start of word	IDPB A,CMDBYT		; Store the character	TRNE F,NECHOF		; Echoing off?	 PRINT 0(A)		; Yes, do the echo ourselves	JRST INWOR1		; On to next char; Carriage returnINCR:	PBIN			; Flush following line feed	JRST INEOL1		; Substitute EOL; Line feedINLF:	PRINT 15		; Print carriage returnINEOL1:	MOVEI A,37		; Substitute EOL	JRST INWOR2		; Treat as if EOL was input; EscapeINESC:	TDNE D,WRDATR		; Is Escape a terminator?	 JRST [	ERROR <>	; No, don't allow		JRST INWOR1]	TRO F,ESCAPF		; Yes, note Escape hit (for NOISE)	JRST INWOR3; Control-Q, control-XCTRLQ:	TYPE <___%/>	JRST INDEL1; DeleteINDEL:	TYPE <XXX%/>INDEL1:	POPJ P,			; Take +1 return; Initialize editor at beginning of command; Returns +1; Clobbers A-CINIEDT::MOVE A,[POINT 7,CMDBUF]	; Initialize byte pointer	MOVEM A,CMDBYT	PUSHJ P,OKECHO		; Normalize terminal parameters	MOVE B,[BYTE(2) 0,0,1,1,1,1,0,2,0,2,2,1,1,2,1,1,1,0]	MOVE C,[BYTE(2) 0,1,1,1,0,0,0,1,1,0,1,1,1,3]	SFCOC			; Set desired control echoing	POPJ P,; Back up CMDBYT byte pointer; Returns +1; Clobbers ABAKBYT::MOVE A,CMDBYT		; Get byte pointer	BKJFN			; Let Tenex back it up	 PUSHJ P,SCREWUP	MOVEM A,CMDBYT		; Store it back	POPJ P,; Append null to command string without affecting pointer; Returns +1; Clobbers A, BAPPNUL::MOVE A,CMDBYT		; Get byte pointer	SETZ B,			; Append null	IDPB B,A	POPJ P,; Turn echoing off and on; Returns +1; Clobbers A, BNOECHO::TROA F,NECHOF		; Echoing offOKECHO:: TRZ F,NECHOF		; Echoing on	MOVEI B,16B23+1B29	; Wakeup on punct & control, Ascii	TRNN F,NECHOF		; Want echoing?	 IORI B,2B25		; Yes	MOVEI A,100		; Set new terminal bits	SFMOD	POPJ P,; Type crlf if not already at left margin; Returns +1; Clobbers A, BCRIF::	MOVEI A,101		; Get current position	RFPOS	TRNE B,-1		; At left margin already?	 PRINT EOL		; No, go there	POPJ P,; If last char was Escape, substitute and print a space; Returns +1; Clobbers nothingESPACE::PUSH P,A	LDB A,CMDBYT		; Get last char input	CAIE A,33		; Escape?	 JRST ESPAC1		; No	MOVEI A," "		; Yes, substitute space	DPB A,CMDBYT	PBOUT			; Print space alsoESPAC1:	POP P,A	POPJ P,; Handlers for command-related UUOs; NOISE <string>; Type noise word iff last input was terminated by Escape%UNOIS::TRNN F,ESCAPF		; Last terminator Escape?	 POPJ P,		; No	PUSHJ P,ESPACE		; Yes, ensure turned into space				; Rest same as PROMPT; PROMPT <string>; Type the given string and also append to command buffer (for ^R)%UPROM::PUSHJ P,FORMAT##	; Call formatter	 MOVE A,CMDBYT		; Setup string ptr to cmd buffer	 PUSHJ P,%UPRO2		; Completion -- fix ptr, type text	POPJ P,%UPRO2:	MOVE B,A		; Copy string ptr	SETZ C,			; Append null	IDPB C,B	EXCH A,CMDBYT		; Store end pointer, recover start	PSOUT			; Type the text	POPJ P,; Character attribute and dispatch table; Attributes from list in PFUDEF.MACDEFINE X(CHAR,ATTR) <IRP CHAR<RELOC CHRTAB+CHAR	ATTR>>DEFINE XRNG(CHAR1,CHAR2,ATTR) <RELOC CHRTAB+CHAR1REPEAT CHAR2-CHAR1+1,<ATTR>>CHRTAB::; Editing characters	X <"A"-100,"H"-100>,CTRLA	X <"R"-100>,CTRLR	X <"V"-100>,CTRLV	X <"W"-100>,CTRLW	X <"?">,C.PUNC+INQUES; Non-editing controls	X <0>,INWOR1		; Flush nulls	XRNG "B"-100,"G"-100,C.CTRL	X <"K"-100>,C.CTRL	XRNG "N"-100,"P"-100,C.CTRL	XRNG "S"-100,"U"-100,C.CTRL	XRNG "Y"-100,"Z"-100,C.CTRL	XRNG 34,36,C.CTRL; End-of-line characters	X <12,14>,C.CEOL+INLF	X <15>,C.CEOL+INCR	X <33>,C.ESC+INESC	X <37>,C.CEOL; Line delete characters	X <"Q"-100,"X"-100>,C.CDEL+CTRLQ	X <177>,C.CDEL+INDEL; Punctuation characters	X <"I"-100," ">,C.SPAC+INSPAC	X <"+","#">,C.PUNC+C.HSTP	X <"-","/">,C.PUNC+C.HSTC	X <"!",42,"$","%","&","'","(",")","*">,C.PUNC	X <54,".",":",";",74,"=",76,"@">,C.PUNC	XRNG 133,140,C.PUNC	XRNG 173,176,C.PUNC; Alphanumeric characters	XRNG "A","Z",C.ALPH	XRNG "a","z",C.ALPH+LOWERC	XRNG "0","9",C.NUMRELOC CHRTAB+200; Storage for command processorLS CMDBUF,CMDLEN	; Command string bufferLS CMDBYT		; Byte ptr to tail of command stringLS WRDBYT		; Byte ptr to start of current wordLS WRDLEN		; Length of current wordLS WRDATR		; Attributes of legal word constituentsLS HLPDAT		; Data for help message ("?")LS WRDXIT		; Return pc for last call of INWORDLS WRDPDP		; Stack level of last call of INWORD	END