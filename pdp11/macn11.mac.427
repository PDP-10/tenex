;<VOICE>MACN11.MAC.164    22-Aug-78 15:48:45    EDIT BY KODA
;	Bug fix:	Both FMUL and FSUB were in the wrong place in
;			op-code table thus were not available.
;<VOICE>MACN11.MAC.163    26-Jun-78 16:25:04    EDIT BY KODA
;	Whatnot:	MACRO arguments can now have trailing blanks.
;<VOICE>MACN11.MAC.162    31-May-78 09:31:16    EDIT BY KODA
;	Bug fix:	Fixes to ":" code in command parser.
;<VOICE>MACN11.MAC.161    30-May-78 16:31:09    EDIT BY KODA
;	Bug fix:	Added code to handle ":" in command line,
;			was screwing up "<" processing.
;[BBN-TENEXA]<TOMLINSON>MACN11.MAC.46, 24-May-78 22:23:59, Ed: TOMLINSON
; SOUPED TOGETHER ISI AND BBN CHANGES
;[BBN-TENEXA]<TOMLINSON>MACN11.MAC.44, 24-May-78 08:44:23, Ed: TOMLINSON
; Added new syntax for half-killed symbols:
;	X=!expr		defines X as half-killed.
;	X==!expr	defines X as half-killed global.
;	X:!		defines X as half-killed label.
;	X::!		defines X as half-kileed global label.
;	.ENABL .5K	Inverts the meaning of ! in assignments.
;			Does not affect labels.
;<VOICE>MACN11.MAC.160    24-Apr-78 10:32:21    EDIT BY KODA
;	Bug fix:	In Tenex command scanner, on a ambiguous directory
;			lookup return it would jump into another routine.
;	Bug fix:	In PROWRD, should check byte modification bit and
;			if on then mask to 8 bits.
;	Bug fix:	In .BYTE processing, forgot to set byte modification
;			bit when generating global references.
;<VOICE>MACN11.MAC.159    12-Jan-78 12:54:27    EDIT BY KODA
;	Whatnot:	The cref reference section will have variable number
;			of fields according to max sequence number.
;<VOICE>MACN11.MAC.158    11-Jan-78 11:16:54    EDIT BY KODA
;	Whatnot:	Create routine to output symbol value with
;			sector name.  Used by both cref and regular
;			symbol table output routines.
;<VOICE>MACN11.MAC.157    20-Dec-77 16:52:48    EDIT BY KODA
;	Whatnot:	LOHBIT was removed since it wasn't needed and
;			caused .SBHED not to page throw if it was on the
;			second line of a page
;<VOICE>MACN11.MAC.156    19-Dec-77 10:23:30    EDIT BY KODA
;	Bug fix:	Lines with an error did not get listed when in
;			.NLIST
;	Bug fix:	Formfeed (^L) got through in conditionals
;	Bug fix:	.MEXIT didn't restore .IFFLG flag when exiting
;			a conditional
;	Bug fix:	.ASCII and .ASCIZ would flag an expression that was
;			negative with T flag.
;	Whatnot:	Made both types of symbol table output the value
;			of PC and CSECT lengths including the blank CSECT
;<VOICE>MACN11.MAC.155    22-Sep-77 12:10:45    EDIT BY KODA
;	Whatnot:	Merged in the following edit from CMU.

;MACN11.MAC[a711pd11]@CMUA 21 September 77 00:38 Rick Gumpertz
;	Changed interpretation of digits in LSTMSG to only happen
;	after "%", so non-Tenex version will work properly.  Also changed
;	old "%" to be "%0".

;<VOICE>MACN11.MAC.154    16-Aug-77 15:34:52    EDIT BY KODA
;	Bug fix:	Somewhere in the CMU-ISI edit exchange, my edit to
;			fix .OPDEF and .MACRO wth the same name bug was lost.
;			So here it is again.
;<VOICE>MACN11.MAC.153    12-Aug-77 18:49:10    EDIT BY KODA
;	Whatnot:	Tenex version is not re-locatable and both data and
;			code areas are on a page boundary.
;<VOICE>MACN11.MAC.152    12-Aug-77 14:25:19    EDIT BY KODA
;	Bug fix:	.MEXIT in .REPT if it was not nested in a macro call
;			did not exit properly.
;<VOICE>MACN11.MAC.151    11-Aug-77 21:53:41    EDIT BY KODA
;	Bug fix:	Made .MEXIT work correctly in .IRP & .IRPC range.
;<VOICE>MACN11.MAC;150    10-AUG-77 19:32:50    EDIT BY KODA
;	Bug fix:	CRFDEF should set the definition field only on pass 2
;<VOICE>MACN11.MAC.149    12-Jul-77 15:11:24    EDIT BY KODA
;	Whatnot:	Reinstated "T" in the version string. [V4.37]
;MACN11.MAC[a711pd11]@CMUA 25 June 77 11:11	Rick Gumpertz
;	Merged CMU and ISIB versions into V4.37
;MACN11.MAC[a711pd11]@CMUA 21 June 77 20:42	Rick Gumpertz
;	Made .GLOBL accept args separated by spaces
;	Made /L be ignored at CMU, temporarily
;	Fixed TOPS-10 GETFIL to save R14 when processing switches.
;	 Again I wonder about those TENEX losers who take care of their own
;MACN11.MAC[a711pd11]@CMUA 21 June 77 10:57	Rick Gumpertz
;	Changed .REQUIRE to obey PAGE THROW flag at end as well as start
;<VOICE>MACN11.MAC.148    20-Jun-77 15:03:05    EDIT BY KODA
;	Whatnot:	Merged in source version 147 which had a floating
;			point instruction (ABSF) declared as 45 but its really
;			a 35/40.  Also changed tally line to say number of
;			35/40 floating point instructions instead of 40.
;MACN11.MAC[n810rg02]@CMUA 20 June 77 18:52	Rick Gumpertz
;	Moved down setting of HDRBIT in ASSEMB pass 2 setup,
;	 since it was being clobbered by BRKBIT in GETWRD
;	 This caused no FF after the TOC at DEC sites.
;	 I am not sure what else is clobbered by the overlap of
;	 BRKBIT and HDRBIT, but .REQUIRE/.INSERT are prime candidates.
;	Fixed ENDLR to not print a blank line for FORM FEEDs at end
;	 of a non-blank page
;	Fixed .REQUIRE, etc. to PUSH/POP INPGNM
;	Fixed TOPS-10 .REQUIRE to set REQBIT
;	Fixed TOPS-10 GETSRC to zero CHRCNT
;	Got mad at those TENEX people who broke .REQUIRE, etc. in version 4 for BOTTOMS-10
;	Made .MCALL use SON to determine whether to throw page
;	Made .MCALL call GETEOL before calling .INSERT rather than after
;	Fixed Header to special case pass 1 page numbers under SON
;	Changed PAGSIZ to include the header length.
;	Changed default PAGSIZ at CMU
;	Made .MCALL be a NOP after the first time per pass
;<VOICE>MACN11.MAC;146     8-JUN-77 17:38:05    EDIT BY KODA
;	Bug fix:	Problems with .OPDEF and .MACRO of the same name.

;MACN11.MAC[a711pd11]@CMUB 4 June 77 15:57	Rick Gumpertz
;	Various formatting changes in the source, principally
;	to not indent the assembly conditionals, thereby making
;	it easier to find the beginning of such conditionals.
;<VOICE>MACN11.MAC;145     3-JUN-77 18:01:28    EDIT BY KODA
;	Augmentation:	Implemented .MCALL by inserting SYSMAC.SML
;	Bug fix:	GETSRC/TRYJFN was taking error exit instead of
;			returning +1; caused .REQUIRE to blow instead
;			of flaging it in the listing.
;	Optimization:	There were some CALLs to HDROUB which did a
;			JRST BSBYTE so made it call directly.
;	Whatnot:	Minor editting changes to make listing look better.
;	Whatnot:	Made CCLJFN be defined in storage area.
;<VOICE>MACN11.MAC;144     2-JUN-77 15:23:33    EDIT BY KODA
;	Whatnot:	CREF information is not stored when there is no
;			listing file - reducing overhead.
;	Bug fix:	In .REPT handling, there was no check for a nested
;			.IRP or IRPC which caused the .REPT to terminate
;			prematurely.

;MACN11.MAC[a711pd11]@CMUB 2 June 77 10:17	Rick Gumpertz
;	Fixed REQPSH in TOPS-10 version to not POP R16 without pushing it.
;	Fixed GETSRC to save and restore XE3 (the PPN) over lookups

;MACN11.MAC[a711pd11]@CMUB 1 June 77 12:44	Rick Gumpertz
;	Changed GBLOCK to call GETCOR
;	Changed GETCOR to update CR1PNT and CR2PNT

;MACN11.MAC[a711pd11]@CMUB 1 June 77 12:08	Rick Gumpertz
;	Changed JOBREL and JOBFF to .JBREL and .JBFF
;	Made .JBVER (137) contain something more reasonable

;MACN11.MAC[a711pd11]@CMUB 1 June 77 00:45	Rick Gumpertz
;	Added the routine BINOUT instead of BINOU4 and renamed
;	BINOUT to BINBYT

;<VOICE>MACN11.MAC;143    31-MAY-77 19:00:45    EDIT BY KODA
;	Whatnot:	Added conditionals to SEARCH either STENEX or
;			MONSYM according to .CPU.
;	Bug fix:	At REQLP1: IBP R2,SRCPNT should have been only
;			IBP SRCPNT.
;	Bug fix:	In .IF DF processing CRFREF was being called even
;			when the symbol was un-defined causing previous
;			symbol to get an extra reference.

;MACN11.MAC[a711pd11]@CMUB 31 May 77 19:17	Rick Gumpertz
;	Fixed BINCNT to be BINBUF+1 under BOTTOMS-10
;	Fixed CMUID to allow 13 character PPNs at CMU

;MACN11.MAC[a711pd11]@CMUB 31 May 77 16:14	Rick Gumpertz
;	Fixed the IBP at REQLP1: to not have a non-zero AC field, which
;	made it look like an ADJBP instruction on the KL-10.
;	Also renamed NONREN to TwoSgs, and made it an IFE/IFN switch
;	instead of an IFDEF/IFNDEF switch.

;<VOICE>MACN11.MAC;142    24-MAY-77 22:17:28    EDIT BY KODA
;	Bug fix:	"<" was not in the command scanner character
;			table correctly.
;<VOICE>MACN11.MAC;141    22-APR-77 18:21:56    EDIT BY KODA
;	Augmentation:	Run-time checks for Tenex or Tops-20.
;			Back-up character will be ^A or DEL according to
;			the operating system conventions.
;	Bug fix:	In CREF table output the first line was 1 short
;			on references.
;<VOICE>MACN11.MAC;140    13-APR-77 14:32:09    EDIT BY KODA
;	Bug fix:	Must have a new version of the temporary file
;			used in command file recognition.
;<VOICE>MACN11.MAC;139    31-MAR-77 14:59:29    EDIT BY KODA
;	Whatnot:	Minor change to error printing routines to make
;			output more informative.
;	Bug fix:	DOTCHK for Tenex systems was falling thru to
;			COMCHK and getting mixed up.
;<TOMLINSON>MACN11.MAC.38    21-Mar-77 20:54:14    EDIT BY TOMLINSON
; Folded in BBN changes as follows:
;	CCL	TENEX version now has ability to do this too
;	Source files were not properly closed after an assembly.
;		This is not a problem unless multiple assemblies are
;		done such as happens under CCL.
;	Replaced PSOUT  with ESOUT in some error printers.  Without this,
;		running under batch will noo known errors have happened
;		and plow ahead regardless.
;	Changed character type of < from 5 to 1.  File names with directories
;		were not being parsed correctly.
;	Reset PAGPTR on each assembly and clear the page.  Else it over
;		runs after a few assemblies and blows up.
;	Redid the multiple extension source checker to be a loop driven
;		by a table of valid extensions.  Added .P11 to this list.
;	Fixed a couple of PMAPs to clear R3.  Necessary for TOPS-20.
;	KL20F conditional for certain things that must be done
;	differently on the KL20, e.g. LINK! should look in SYS:
;	Bug fix:	If there was an error in pass 1, the BLNKLN cell was
;			not set so it may not print the error line.
;<VOICE>MACN11.MAC;137    26-JAN-77 19:12:07    EDIT BY CASNER
;	1.  Bugfix:	Changed CAIN to CAMN in FLTCOP and moved FLTCOL init
;			in ENDLR up before pass 1 check
;<VOICE>MACN11.MAC;136    24-JAN-77 19:42:28    EDIT BY CASNER
;	1.  Rework:	Changed expanded floating point comment line to list
;			as an extension line for the .FLT2 or .FLT4
;	2.  Added:	.LIST/.NLIST FLC for floating comment line
;	3.  Bugfix:	A couple of fixes to previous edit for Jim
;<VOICE>MACN11.MAC;135    24-JAN-77 18:08:37    EDIT BY KODA
;	Whatnot:	Put back old style symbol table if /CRF was set
;<VOICE>MACN11.MAC;134    24-JAN-77 15:48:22    EDIT BY KODA
;	Whatnot:	Put back old cref stuff so multiple module crefs
;			are available. [V4.32T]
;<VOICE>MACN11.MAC;133    18-JAN-77 16:02:20    EDIT BY KODA
;	1. Whatnot:	Made AC0-AC5 half-killed symbols.
;<VOICE>MACN11.MAC;132    12-JAN-77 22:04:07    EDIT BY KODA
;	1. Bug fix:	Local symbols are not listed in the cross-reference
;			table
;	2. Whatnot:	Added AC0-AC5 in the permanment symbol table
;<VOICE>MACN11.MAC;131    12-JAN-77 17:01:45    EDIT BY KODA
;	1. Bug fix:	.REQUIRE code blew up if a file had required files and
;			more source files followed it.
;<VOICE>MACN11.MAC;130     4-JAN-77 15:44:06    EDIT BY KODA
;	1. Bug fix:	In non-Tenex version; error printing routines.
;<VOICE>MACN11.MAC;129     6-DEC-76 17:08:52    EDIT BY RAVELING
;	Fixed editing error:  One insertion in SSRCH was one line
;	ahead of its rightful place, causing all manner of calamities.
;<VOICE>MACN11.MAC;128     6-DEC-76 07:54:55    EDIT BY RAVELING
;	1.  Bug fix:  Added checks for "." in SSRCH & CRFREF to cure
;		"." being undefined and references to it being attributed
;		to other symbols.
;	2.  Bug fix:  Logic error corrected in CRFREF, extending reference
;		block queue.
;<VOICE>MACN11.MAC;127     3-DEC-76 14:02:35    EDIT BY RAVELING
;	1.  Bug fix:  ASSEM2 fix tested flag bits for inverted values.
;	2.  Bug fix:  Several CRFREF calls needed to be deleted or moved
;		to insure INSRT had been called first.
;<VOICE>MACN11.MAC;126     3-DEC-76 09:14:39    EDIT BY RAVELING
;	Added more changes to support cross referencing.  It should
;	work now, except for a few bells & whistles in symbol table
;	listing.
;<VOICE>MACN11.MAC;125     2-DEC-76 15:59:37    EDIT BY RAVELING
;	1.  Bug fix:  ASSEM2 checked something random instead of the
;		bit that identifies .LIST  SYM to decide whether to
;		list the symbol table.
;	2.  First round of changes to support cross referencing entirely
;		within MACN11 are in.
;<VOICE>MACN11.MAC;124    29-OCT-76 15:11:56    EDIT BY KODA
;	1. CRLFLG was in the wrong data area; was being cleared at init
;	   time. [V4.27T]
;<VOICE>MACN11.MAC;123    14-OCT-76 15:16:33    EDIT BY KODA
;	1. Bug fix in command scanner; ^X for first field didn't work.
;<VOICE>MACN11.MAC;122     8-SEP-76 16:37:50    EDIT BY KODA
;	1. Forgot an instruction in .PSECT processing.
;<VOICE>MACN11.MAC;121    27-AUG-76 20:04:28    EDIT BY KODA
;	1. Fixed conditionals for 10/50 version.
;	2. Listing page number gets zero instead of 1.
;	3. Starting to remove EOL's and converting to CR-LF
;<VOICE>MACN11.MAC;120     5-AUG-76 15:10:29    EDIT BY RAVELING
;	1.  Added MFPS & MTPS to op table, added MODLSI as model code
;		for LSI-11 instructions, and added code to report
;		number of LSI-11 instructions at end of assembly.
;<VOICE>MACN11.MAC;119    27-JUL-76 01:46:36    EDIT BY KODA
;	1. Bug fixes in command parsing. [V4.24T]
;<VOICE>MACN11.MAC;118     9-JUL-76 18:03:37    EDIT BY KODA
;	1. Before jumping to a program we must clear out the address space.
;<VOICE>MACN11.MAC;117     8-JUN-76 21:07:17    EDIT BY KODA
;	1. Forgot to add HFKFLG into ENMASK.
;<VOICE>MACN11.MAC;116     7-JUN-76 22:45:01    EDIT BY KODA
;	1. Bug fixes in half killed symbol code.
;	2. Made .MACN. and .VRSN. half killed.
;<VOICE>MACN11.MAC;115     7-JUN-76 17:04:00    EDIT BY KODA
;	1. New .ENABL operand called .5K for half killing symbols defined by
;	   a "=".
;<VOICE>MACN11.MAC;114     5-JUN-76 16:44:39    EDIT BY RAVELING
;	1.  Fixed bug in expression evaluation:  Relocation level
;	    wasn't pushed & popped in recursive calls to EXPR0 for
;	    nested expressions.  This caused spurious A flags and
;	    incorrect evaluation of some types of expressions.
;	2.  Eliminated RECLVL (expression parser's recursion level variable),
;	    which was never needed for its intended purpose.
;<VOICE>MACN11.MAC;113    25-MAY-76 21:24:42    EDIT BY KODA
;	1. Bug in command string parser which made an infinite loop when
;	   trying complete directory names which were complete.
;<VOICE>MACN11.MAC;112    19-MAY-76 15:12:36    EDIT BY KODA
;	1. GTJFN and OPNEF failures will now print the filename it failed on.
;	2. Command parsing will retype command string when an error occurs.
;<VOICE>MACN11.MAC;111    12-MAY-76 11:20:43    EDIT BY RAVELING
;	Installed bug in .enabl lsb:  Contrary to the MACRO-11 manual,
;	existing DEC assemblers and some of DEC's code start a new
;	local symbol block whenever a .enabl lsb occurs, even if a
;	.enabl lsb is already in effect.  We had to install this bug
;	to allow Lynn Cosell to do RT11 assemblies.
;<VOICE>MACN11.MAC;110    11-MAY-76 15:19:16    EDIT BY RAVELING
;	Fixed bug in .enabl lsb:  It should have reset the current local
;	symbol block but didn't.  Its failure to do this results from the
;	incomprehensible wording of the paragraph of the MACRO-11 manual
;	that says it's supposed to do this.
;<VOICE>MACN11.MAC;109    27-APR-76 16:29:58    EDIT BY KODA
;	1. Fixed bug in command parsing, string backup routine for handling
;	   errors on the first field were backing up too far.
;<VOICE>MACN11.MAC;108    13-APR-76 09:57:03    EDIT BY RAVELING
;	1.  Fixed .if df/ndf parsing bug reported by Dennis Smith --
;		valid use of "&" or "!" bombed the assembler violently.
;	2.  Reset Tenex version number for maintenance release.
;		"nn" in "V4.nnT" now indicates number of source edits
;		since release of version 4.
;<VOICE>MACN11.MAC;107    20-MAR-76 14:58:04    EDIT BY RAVELING
;	1. Fixed .list/.nlist initialization bug:  It needed to be set
;	   in initialization for each pass to protect against an extra
;	   .nlist suppressing listing for the entire assembly.
;<VOICE>MACN11.MAC;106     1-MAR-76 16:49:32    EDIT BY KODA
;	1. In the terminal input routine if the primary JFN is not the
;	   controlling terminal then it won't echo.
;	2. When print the symbol table the subtitle field of the header has
;	   "Symbol table" as the subtitle.
;<VOICE>MACN11.MAC;105     5-FEB-76 17:27:45    EDIT BY KODA
;	1. Forgot to echo byte after source terminal input.
;<VOICE>MACN11.MAC;104     5-FEB-76 17:03:03    EDIT BY KODA
;	1. Allow source input from controlling terminals only.
;	2. Added ^V as a quoting character in the terminal input routine.
;	3. Made all control characters printing in source text.
;<VOICE>MACN11.MAC;103    29-JAN-76 21:55:08    EDIT BY KODA
;	1. NSF is enabled as default.
;<VOICE>MACN11.MAC;102    16-JAN-76 17:19:26    EDIT BY KODA
;	1. Fixed interfacing problems with the new terminal input routine.
;	2. Made .INSERT suppress HDRBIT so that a new paged won't be listed.
;<VOICE>MACN11.MAC;101    14-JAN-76 23:56:16    EDIT BY KODA
;	1. Generalized terminal input to a subroutine so that terminals can
;	   be used as input files when I get around to writing that part.
;<VOICE>MACN11.MAC;100    13-JAN-76 13:44:12    EDIT BY KODA
;	1. Clean-up of .REQUIRE implementation.
;<VOICE>MACN11.MAC;99    13-JAN-76 00:54:38    EDIT BY KODA
;	1. Bug fixes to .REQUIRE and added .INCLUDE and .INSERT in op-code 
;	   table as synonyms for .REQUIRE
;<VOICE>MACN11.MAC;98    12-JAN-76 23:17:52    EDIT BY KODA
;	1. Implemented .REQUIRE for the Tenex version, but only for Disk files.
;<VOICE>MACN11.MAC;97    19-DEC-75 01:38:20    EDIT BY KODA
;	1. Location is printed only on macro calls not on .IRP or .IRPC
;<VOICE>MACN11.MAC;96    17-DEC-75 16:59:00    EDIT BY KODA
;	1. Bug fix in .PAGE - it was doing a new header page in a macro
;	   call and .NLIST ME in effect.
;<VOICE>MACN11.MAC;95    16-DEC-75 15:04:06    EDIT BY KODA
;	1. New listing directive called ASC, which will control listing of
;	   the bytes for .ASCIZ and .ASCII pseudo-ops.
;	2. Fixed bug in PRNTA routine, if binary listing was suppressed then
;	   PF1 and PF2 are filled with a TAB instead of being ignored.
;<VOICE>MACN11.MAC;94    15-DEC-75 11:47:20    EDIT BY KODA

;	1. Fixed listing control of PC next to macro calls.  Only if
;	   MACLVL is zero will the PC be printed or if .LIST ME is in effect.
;	2. filename! is now accepted by the command scanner.

;			---------------------

;			CHANGES FOR VERSION 4

;			---------------------

;<VOICE>MACN11.MAC;93     2-DEC-75 19:00:27    EDIT BY CASNER

;	Fixed sign extension so right logical shift (_) works properly.

;<VOICE>MACN11.MAC;92    26-NOV-75 08:33:46    EDIT BY RAVELING

;	1.  Changed macro call processing to list the pc in the first
;	    binary print field, rather than the second.
;	2.  Fixed .IRP to work properly (i.e., expand nothing) when
;	    no argument values at all are supplied.

;<VOICE>MACN11.MAC;91    24-NOV-75 18:04:31    EDIT BY KODA
;	At the end of Pass 2, partial binary word is sent if it exists.
;<VOICE>MACN11.MAC;90    24-NOV-75 16:30:58    EDIT BY RAVELING

;	Fixed bugs in binary alignment code due to mismatch between
;	Tenex output & CMU 1050 code -- Now it works for Tenex configuration,
;	but not for 1050.

;<VOICE>MACN11.MAC;89    21-NOV-75 23:49:07    EDIT BY KODA
;	Finally got all bugs out of source file I/O stuff.
;<VOICE>MACN11.MAC;88    21-NOV-75 16:25:30    EDIT BY RAVELING
;	Fixed another editing flub (omitted label).
;<VOICE>MACN11.MAC;87    21-NOV-75 16:10:49    EDIT BY RAVELING

;	Fixed editing error -- unterminated literal!

;<VOICE>MACN11.MAC;86    21-NOV-75 15:34:51    EDIT BY RAVELING

;	1.  Supplied switch defaults as requested by Stanford
;	    when STANSW is set to 1.
;	2.  Increased the stack size to prevent overflows which
;	    happen in certain cases of abnormal input.
;	3.  Added several operand values for /FO switch:
;		NOP -- No padding between blocks in object output
;		PAD -- Padding between blocks . . .
;		NAL -- No alignment for packed output blocks
;		HAL -- Half (PDP-10) word alignment . . .
;		WAL -- Word alignment . . .
;	4.  Fixed register clobber at BINOU4 which caused invalid
;	    trash in object files in Tenex configuration.
;	5.  Modified macro call processing to list the PC next to
;	    macro calls.
;	6.  Fixed an editing bug in BLKDMP & modified the same section
;	    to behave as specified by the new /FO options.

;<VOICE>MACN11.MAC;85    20-NOV-75 21:07:13    EDIT BY KODA
;	Non-disk source files are possible now.
;	Also when the source file is not on disk then .VRSN. is undefined.
;<VOICE>MACN11.MAC;84    20-NOV-75 15:58:57    EDIT BY RAVELING

;	Fixed the only obvious editing goofs in all that merging.

;<VOICE>MACN11.MAC;83    20-NOV-75 10:51:28    EDIT BY RAVELING

;	   Continued merging in CMU code for . . .
;		.LIST  SON
;		.REQUIRE
;		.IDENT
;		.PSECT
;		Object output block alignment within PDP-10 words

;<VOICE>MACN11.MAC;82    19-NOV-75 16:49:10    EDIT BY RAVELING

;	    Collated in more CMU code for . . .
;		.LIST  SON
;		.REQUIRE
;		.IDENT bug fix
;		.PSECT

;<VOICE>MACN11.MAC;81    18-NOV-75 15:19:04    EDIT BY RAVELING

;	1.  Changed all occurrences of several symbolic labels
;	    to simplify comparing sources with CMU's version --
;	    1st attempt generated a SRCCOM listing 161 pages long!
;	2.  Modified assembly parameter definitions to allow
;	    specifying installation-dependent options in a separate file.
;	3.  Installed part of CMU's changes for .LIST	SON option.


;	Jim Koda forgot to do a ;d for version 80.  Tsk.

;	1. Added .PSECT code from CMU
;	2. Bug fix in .ASCIZ processing of expressions
;	3. Added new symbol .VRSN. which has the current source file version
;	   number as its value.
;<VOICE>MACN11.MAC;79    23-OCT-75 18:48:13    EDIT BY KODA
;<VOICE>MACN11.MAC;78    15-OCT-75 22:25:55    EDIT BY KODA
;	1. If SEQ listing directive is off, then sequence numbers are not
;	   inserted for CREF.  This allows CREF to created its line numbers.
;	2. Fixed bugs in printing headers when .NLIST was in effect.
;<VOICE>MACN11.MAC;77    13-OCT-75 19:41:03    EDIT BY KODA
;	1. Made default extension of listing files to be .CRF if /CRF was typed.
;<SOURCES>MACN11.MAC;7    22-SEP-75 15:45:01    EDIT BY SMITH
; added a counter to keep track of full lstbuf
;<SOURCES>MACN11.MAC;6    22-SEP-75 13:36:04    EDIT BY SMITH
; increased size of lstbuf to allow for cref info generated
;<SOURCES>MACN11.MAC;5    19-SEP-75 15:33:14    EDIT BY SMITH
;<SOURCES>MACN11.MAC;4    19-SEP-75 10:05:37    EDIT BY SMITH
;V04.1T
; EQ switch							[ECL1]
; Fixed CREF							[ECL2]
; Made .MACRO allow tabs and blanks between arguments		[ECL3]
;<VOICE>MACN11.MAC;76    13-AUG-75 22:57:41    EDIT BY KODA
;	1. Bug in listing of .IFTF, wasn't checking list modes.
;	2. Control-Q interrupt now prints line number it is assembling.
;<VOICE>MACN11.MAC;75     7-AUG-75 19:11:25    EDIT BY KODA
;	1. Open the listing file after complete parse of the command string.
;	2. Installed ^Q interrupt for status of the assembly.
;<VOICE>MACN11.MAC;74     6-AUG-75 22:29:01    EDIT BY KODA
;	1. ^W to delete last field in a filename and ^X to delete whole
;	   filename field.  ^U to delete entire command line.
;<VOICE>MACN11.MAC;73     6-AUG-75 17:39:09    EDIT BY KODA
;	1. Added new assembly switch: MD20SW so that if it is non-zero
;	   intructions which cannot run on a model 20 are flagged with Z errors.
;<VOICE>MACN11.MAC;72     6-AUG-75 00:12:41    EDIT BY KODA
;	1. Filename recognition in the command string.
;<VOICE>MACN11.MAC;71     4-AUG-75 18:35:23    EDIT BY KODA
;	1. Tally for 45 only, 40/45, 45 floating, 40 floating, EIS, and
;	Memory management instructions to be printed out upon exit.
;	2. Added 40 floating point instructions to op-code table.
;<VOICE>MACN11.MAC;70    31-JUL-75 00:38:58    EDIT BY KODA
;	1. Under Tenex version: No high seg. Free core starts at the page
;	   after the command scanner data page.
;<VOICE>MACN11.MAC;69    30-JUL-75 22:38:26    EDIT BY CASNER
; fixed .if abs to check addressing mode
;<VOICE>MACN11.MAC;68    29-JUL-75 01:55:19    EDIT BY CASNER

; Added .IF EQV (equivalent), .IF NQV (not equivalent), and .IF ABS (absolute)
; which all take address expressions as arguments.
;
; Added .NKIND which is like .NTYPE except it returns DEFSYM,LBLSYM,GLBSYM,
; REGSYM, and RELSYM to tell type of address expression, and .NVAL which
; returns its value.

;<VOICE>MACN11.MAC;66    27-JUL-75 16:24:31    EDIT BY KODA
;	1. Impelented PMAP for source input files.
;<VOICE>MACN11.MAC;65    25-JUL-75 23:58:44    EDIT BY KODA
;	1. Input a line of text from the source file thru a SIN, instead of
;	   time consuming BIN's.
;<VOICE>MACN11.MAC;64    25-JUL-75 16:11:50    EDIT BY KODA
;<VOICE>MACN11.MAC;63    25-JUL-75 00:35:04    EDIT BY KODA
;	1. Parse all the source files and then start assembling.
;<VOICE>MACN11.MAC;62    24-JUL-75 15:06:20    EDIT BY KODA
;	1. Changed LPTDMP so it will buffer up to a LF then dump the line.
;<VOICE>MACN11.MAC;61    23-JUL-75 23:49:01    EDIT BY KODA
;	1. Converting I/O UUO's to JSYS's.
;<VOICE>MACN11.MAC;60    22-JUL-75 02:24:33    EDIT BY KODA
;	1. Bug fixes for .MEXIT and .NARG from 10/50 version.
;<VOICE>MACN11.MAC;59    13-FEB-75 20:05:03    EDIT BY KODA
;<VOICE>MACN11.MAC;58    10-NOV-74 18:36:56	EDIT BY KODA

;	1.  Moved SECBAS from cleared impure to no-clearable area.
;		since it is cleared by INIPAS and also changed clearing of
;		SECBAS from loop to BLT method.
;	2.  Now all error message output routines are Tenexized.

;<VOICE>MACN11.MAC;57     9-NOV-74 14:00:50	EDIT BY KODA

;	MORE TENEX CODE ADDED.
;
;<VOICE>MACN11.MAC;56     2-NOV-74 17:43:13	EDIT BY KODA

;	CODE FOR TENEX FILES STARTING TO APPEAR.
	XLIST
;			---------------------

;			CHANGES FOR VERSION 3

;			---------------------

;<VOICE>MACN11.MAC;55    25-OCT-74 22:58:30	EDIT BY RAVELING

;	Fixed bug in P-section additive displaced relocation due
;	change in R4/R6 usage in AEXP area.

;<VOICE>MACN11.MAC;54    22-OCT-74 17:53:23	EDIT BY RAVELING

;	Incorporated changes to fix CCL bugs, fixed by
;	Rick Gumpertz at CMU.

;<VOICE>MACN11.MAC;53    19-OCT-74 16:40:04	EDIT BY KODA

;	1.  CHECKING FOR A SWITCH FIRST INSTEAD OF A PPN CAUSED
;	    SOME WEIRD ERRORS.  ALSO EXCHANGED MODBIT AND BRKBIT.

;<VOICE>MACN11.MAC;52    19-OCT-74 15:55:18	EDIT BY KODA

;	1.  FIXED TYPOS IN STANFORD PPN PROCESSING AND CHANGE "CALL CHFOLD"
;	    IN CHARTB TO "JRST CHFOLD" SO THAT CHFOLD MAY DO THE RETURN FROM
;	    CHAR.

;<VOICE>MACN11.MAC;51    18-OCT-74 23:35:57	EDIT BY KODA

;	1.  NEW SWITCH CALL STANSW WHICH IF NON-ZERO WILL ASSEMBLE
;	    WITH CODE THAT WILL ACCEPT STANFORD PPN'S.  WHILE DOING
;	    THIS CODE, CHANGED PPN PROCESSING SO IT WILL NOT ACCEPT
;	    A PPN IN THE MIDDLE OF A FILE NAME.

;<VOICE>MACN11.MAC;50    18-OCT-74 21:27:58	EDIT BY RAVELING

;	1.  FIXED POTENTIAL BUG:  SOME OF THE DEFAULT .ENABL
;	    MODES WERE TAMPERED WITH IN PASS INITIALIZAION.
;	2.  FIXED ACTUAL BUG:  MACRO CALLS GOT EXTRANEOUS Q FLAGS
;	    IF THEY HAD A COMMENT AND THEIR LAST ARGUMENT WAS OF
;	    THE FORM "<...>" OR "^\...\".

;<VOICE>MACN11.MAC;49    17-OCT-74 19:44:28	EDIT BY RAVELING

;	FIXED BUGS IN OUTPUT OF INTERNAL SYMBOL DEFINITIONS.

;<VOICE>MACN11.MAC;48    17-OCT-74 01:41:00	EDIT BY RAVELING

;	FIXED (HOPEFULLY) BUGS CAUSED BY CONFLICTING USE OF R4.

;<VOICE>MACN11.MAC;47    17-OCT-74 00:50:19	EDIT BY RAVELING

;	1.  ADDED INTERNAL SYMBOL OUTPUT IN OBJECT MODULES, UNDER
;	    CONTROL OF .ENABL ISD.

;	2.  REWROTE SETCHR, GETNT, TSTNSP, & ALL THOSE GOODIES TO
;	    RUN FASTER AT THE EXPENSE OF USING R4.  THEY NOW MAP
;	    CHARACTER TYPES FROM COLUMN 6 OF CHJTBL.

;	3.  FIXED A FEW MINOR BUGS IN NEW FEATURES & CLEANED UP
;	    ASSORTED SMALL PIECES OF CODE.

;<VOICE>MACN11.MAC;46    15-OCT-74 20:42:55	EDIT BY KODA

;	1.  COMMAND PARSER ABLE TO HANDLE MUTIPLE ARGUMENTS TO SWITCHES.
;		(E.G. /NL:CND:ME ,  ETC. )

;<VOICE>MACN11.MAC;45    14-OCT-74 01:18:34	EDIT BY RAVELING

;	1.  Revised .ENABL/.DSABL to accept overrides
;	    from command string.

;	2.  Implemented .ENABL/.DSABL GBL.

;	3.  Fixed a minor but catastrophic editing error &
;	    cleaned up assorted flag definitions.

;<VOICE>MACN11.MAC;44    13-OCT-74 20:07:36	EDIT BY RAVELING

;	BUG FIXES FOR LOCAL SYMBOL GENERATION.

;<VOICE>MACN11.MAC;43    13-OCT-74 18:50:21	EDIT BY RAVELING

;	BUG FIXES FOR .RAD50, LISTING OVERRIDES, AND AUTOMATIC
;	LOCAL SYMBOL GENERATION.

;<VOICE>MACN11.MAC;42    13-OCT-74 01:32:13	EDIT BY RAVELING

;	1.  REWROTE .RAD50 PROCESSING TO ACCEPT BRACKETED
;	    EXPRESSIONS.

;	2.  ADDED THE REST (?) OF THE CODE FOR AUTOMATIC GENERATION
;	    OF LOCAL SYMBOLS IN MACRO CALLS.

;	3.  MODIFIED LISTING DIRECTIVE PROCESSING TO ACCOUNT FOR
;	    OVERRIDES FROM THE COMMAND STRING.

;	4.  CHANGED TREATMENT OF MACRO-GENNED LINES ON LISTING:
;	    INSTEAD OF KLUDGY LOOKING "M" MARKER, THE MACRO
;	    CALL NESTING LEVEL IS PRINTED TO THE LEFT OF THE
;	    LINE NUMBER.

;<VOICE>MACN11.MAC;41    12-OCT-74 21:21:44	EDIT BY KODA

;	1.  BUG IN CRF SWITCH PROCESSING ROUTINE - WAS SETTING BIT IN
;		WRONG HALF OF R16.

;<VOICE>MACN11.MAC;40    11-OCT-74 00:16:40	EDIT BY RAVELING

;	1.  MODIFIED LOCAL SYMBOL PROCESSING TO HANDLE NUMERIC
;	    VALUES UP TO 65535.

;	2.  FIXED 2 GLITCHES IN "\" PROCESSING.

;	3.  ADDED IDENTIFICATION FOR MACRO-GENERATED LINES IN
;	    THE SEQUENCE NUMBER FIELD.

;	4.  ADDED THE FIRST INSTALLMENT OF CODE TO GENERATE
;	    LOCAL SYMBOLS AUTOMATICALLY IN MACRO CALLS.

;<VOICE>MACN11.MAC;39     7-OCT-74 21:17:22	EDIT BY KODA

;	1.  FIXED ANOTHER BUG: COULDN'T TYPE JUST A DEVICE LIKE TTY:
;		AS THE SOURCE FILE WITH SWITCHES.

;<VOICE>MACN11.MAC;38     7-OCT-74 20:12:12	EDIT BY KODA

;	1.  ADDED /FO SWITCH FOR BINARY FORMATS:
;		WHICH ARE "I" FOR IMAGE AND "P" FOR PACKED.

;<VOICE>MACN11.MAC;37     6-OCT-74 15:25:38	EDIT BY KODA

;	1.  WAS LOSING REGISTER R1 WHICH HAD DEVICE NAME IN SWITCH
;		PROCESSING ROUTINE.
;	2.  PUT SOME PATCH SPACE IN IMPURE AREA.

;<VOICE>MACN11.MAC;36     6-OCT-74 14:22:16	EDIT BY KODA

;	1.  FIXED A FEW BUGS IN COMMAND PARSER.

;<VOICE>MACN11.MAC;35     5-OCT-74 19:36:23	EDIT BY KODA

;	1.  IMPLEMENTED NEW COMMAND PARSING SCHEME.

;<VOICE>MACN11.MAC;34    30-SEP-74 22:28:11	EDIT BY KODA

;	1.  CHANGED BYTE AND DISPATCH TABLES ON COMMAND PARSER.
;		(GETTING READY FOR REAL SWICTHES.)

;<VOICE>MACN11.MAC;33    30-SEP-74 20:39:18	EDIT BY RAVELING

;	-- FIXED ALL 3 BUGS IN THE CHANGES FOR ;32.

;<VOICE>MACN11.MAC;32    29-SEP-74 19:46:02	EDIT BY RAVELING

;	1.  JIM KODA CLEANED UP WHOLE GOBS OF ASSORTED INEFFICIENCIES
;	    (& DIDN'T LEAVE COMMENTS HERE!!!)

;	2.  "::" AND "==" ARE HANDLED AS PRESCRIBED FOR THE DOS V09
;	    LANGUAGE SET.

;	3.  .ASCII/.ASCIZ PARSER NOW ACCEPTS BLANKS AND TABS BETWEEN
;	    FIELDS.

;	4.  BUGS IN "\" PROCESSING HAVE BEEN FIXED. . .

;		-- RESULT IS A NUMBER IN THE CURRENT RADIX,
;			RATHER THAN ONLY IN OCTAL.
;		-- LOWER CASE IN THE EXPRESSION FOLLOWING "\" IS
;			HANDLED PROPERLY IN ALL CASES.


;			---------------------

;			CHANGES FOR VERSION 2

;			---------------------


;<RAVELING>MACN11.MAC;31    13-JUL-74 20:13:12	EDIT BY RAVELING

;	1.  CORRECTED SIDE EFFECT OF .DSABLE PNC -- PROGRAM
;		COUNTER DIDN'T INCREMENT!
;	2.  FINISHED .ENABL LC - RELATED CODE;  MACRO PROTOTYPES
;		AND ARGUMENT VALUES ARE NO LONGER FOLDED.

;<RAVELING>MACN11.MAC;30    13-JUL-74 15:38:00	EDIT BY RAVELING

;	1.  IMPLEMENTED PNC OPTION OF .ENABL/.DSABL.
;	2.  NEARLY FINISHED .ENABL LC:  LOWER CASE ASCII IS
;		NOW ASSEMBLED AS SUCH BY .ASCII, .ASCIZ,
;		'X, AND "XX;  TITLES AND SUBTITLES AREN'T
;		FOLDED INTO UPPER CASE EITHER.

;<RAVELING>MACN11.MAC;29     2-JUL-74 23:23:30	EDIT BY RAVELING

;	1.  MODIFIED SYMBOL TABLE INITIALIZATION TO SET PREDEFINED
;		SYMBOL VALUES, DEFINED IN TABLE PERMST.  CURRENT
;		ENTRIES DEFINE R0-R7, SP, PC, AND .MACN. -- .MACN.
;		IS EVALUATED TO THE ASSEMBLER'S VERSION NUMBER.
;	2.  ADDED ASSEMBLY PARAMETER 'TENEX' & FIRST INSTALLMENT OF
;		CONDITIONAL ASSEMBLIES, TO TAILOR THE ASSEMBLER TO
;		EITHER 1050 OR GENUINE TENEX EVIRONMENTS.

;<RAVELING>MACN11.MAC;28    28-JUN-74 22:33:40	EDIT BY RAVELING

;	1.  INCORPORATED STEVE CASNER'S CHANGES TO IMPLEMENT THE
;		LOGICAL SHIFT OPERATOR (_) AND TO PREVENT ^R
;		FROM GENERATING Q FLAGS.
;	2.  BUG FIXED:  .IRP IGNORED ITS LAST ARGUMENT IF IT WAS
;		EXPLICITLY OMITTED.  PROPER EXPANSION IS TO GEN
;		THE IRP BLOCK WITH A NULL VALUE SUBSTITUTED FOR
;		THE ARGUMENT.



;			---------------------

;			CHANGES FOR VERSION 1

;			---------------------


;<RAVELING>MACN11.MAC;27    12-JUN-74 21:51:00	EDIT BY RAVELING

;	JIM KODA'S CHANGES:

;	    1.  FIXED GLITCHES IN COMMAND STRING LISTING.
;	    2.  ADDED FILE NAME IN SUBTITLE LINES.

;	MY CHANGES:

;	    1.  FIXED TABLE ENTRY THAT CAUSED .IF GT TO BE
;		TREATED AS .IF GE.
;	    2.  FIXED LISTING BUG:  BLANK LINES GENERATED FROM
;		MACROS WERE LISTED EVEN WITH .NLIST ME IN EFFECT.

;<RAVELING>MACN11.MAC;26     3-JUN-74 18:40:34	EDIT BY RAVELING

;	ANOTHER .ENABL AMA BUG SQUASHED:  MODE 7 ADDRESSES WERE
;	BEING PERVERTED TO MODE 3.

;<RAVELING>MACN11.MAC;25     2-JUN-74 14:28:46	EDIT BY RAVELING

;	1.  JIM KODA IMPLEMENTED .IDENT.
;	2.  FIXED A BUG IN .IF B & .IF NB:  IT DID ITS OWN PARSING,
;	    INSTEAD OF CALLING MACARG, SO IT THOUGHT '<>' WAS NONBLANK.

;<RAVELING>MACN11.MAC;24    31-MAY-74 17:52:22	EDIT BY RAVELING

;	FIXED BUG IN .IRP ARGUMENT HANDLING -- IT STRIPPED OFF
;	ONE LEVEL TOOO MANY OF NESTED BRACKETS.

;<RAVELING>MACN11.MAC;23    31-MAY-74 15:46:57	EDIT BY RAVELING

;	CHANGED .IRP & .IRPC'S ALGORITHM FOR EXPANDING ARGUMENTS
;	IN THE PROPER ORDER TO BE LESS CPU-CONSUMING AND
;	LESS BUG-PRONE.

;<RAVELING>MACN11.MAC;22    30-MAY-74 23:02:03	EDIT BY RAVELING

;	1.  FIXED BUG CAUSING PHASE ERRORS WHEN ABS MODE
;	    ADDRESSING IS ENABLED.
;	2.  FINISHED .IRP & .IRPC.

;<RAVELING>MACN11.MAC;21    30-MAY-74 16:25:06	EDIT BY RAVELING

;	FIXED TYPOS & FIRST ROUND OF .IRP/.IRPC PROBLEMS.

;<RAVELING>MACN11.MAC;20    29-MAY-74 21:58:55	EDIT BY RAVELING

;	ADDED .IRP & .IRPC PROCESSING, BUT THEY'RE NOT QUITE
;	COMPLETE YET.

;<RAVELING>MACN11.MAC;19    29-MAY-74 15:47:01	EDIT BY RAVELING

;	1.  MERGED IN JIM KODA'S CHANGES FOR PROPER TITLES,
;	    LISTING THE COMMAND STRING, AND ANNOUNCING THE VERSION.
;	2.  FIXED A BUG IN .IF -- IT WASN'T SKIPPING A COMMA
;	    BETWEEN THE CONDITION FIELD AND ARGUMENT FIELD
;	    IN SOME CASES.

;<RAVELING>MACN11.MAC;18    22-MAY-74 12:09:34	EDIT BY CASNER

;	TOOK UNUSED LOCAL SYMBOL CODE OUT OF NUMERIC TERM PROCESSOR.
;	ADDED ^R CODE TO TERM PROCESSOR.

;<RAVELING>MACN11.MAC;17    17-MAY-74 20:11:51	EDIT BY RAVELING

;	1.  CLEANED UP .NCHR AND .NTYPE.
;	2.  SET MACRO BLOCK SIZE TO 30 WORDS INSTEAD OF 10.
;	3.  IMPLEMENTED .IIF.

;<RAVELING>MACN11.MAC;16    16-MAY-74 21:13:42	EDIT BY RAVELING

;	1.  ADDED STEVE CASNER'S .NTYPE CODE.
;	2.  FIXED BUG IN .NCHR (IMPROPER TREATMENT OF BLANK & TAB
;	    AS SEPARATORS).
;	3.  MODIFIED MACRO CALL PROCESSOR TO HANDLE NESTED ARGUMENTS
;	    PROPERLY.

;<RAVELING>MACN11.MAC;15    15-MAY-74 19:03:49	EDIT BY RAVELING

;	1.  FIXED BUG IN MACARG (COULD HAVE ARBITRARILY BEEN CALLED
;		BUG IN .IF DIF/.IF IDN).
;	2.  FIXED BUG IN .IF B & .IF NB.

;<RAVELING>MACN11.MAC;14    15-MAY-74 00:09:34	EDIT BY RAVELING

;	1.  FIXED BUG IN .IF DUE TO OVERZEALOUS CLEANUP.
;	2.  RE-IMPLEMENTED .IF DIF & .IF IDN TO TAKE MACRO-TYPE
;	    ARGUMENTS.
;	3.  IMPLEMENTED .NCHR.
;	4.  SUPPLIED PROPER PAGE NUMBERING.

;<RAVELING>MACN11.MAC;13    14-MAY-74 14:02:14	EDIT BY RAVELING

;	DELETED SOURCE REPRODUCTION, WHICH IS NEITHER
;	USED, NEEDED, NOR POSSIBLE TO DO CORRECTLY ANY MORE.

;<RAVELING>MACN11.MAC;12    11-MAY-74 15:34:14	EDIT BY RAVELING

;	1.  FIXED UNBALANCED CONDITIONAL & DELETED CCL
;	    CODE AGAIN.
;	2.  MODIFIED .NARG TO BE CONSISTENT WITH DEC ASSEMBLERS
;	    WHEN AN ARGUMENT IS EXPLICITLY NULL.

;<RAVELING>MACN11.MAC;11     9-MAY-74 21:17:39	EDIT BY RAVELING

;	FIXED BUGS IN .NARG & ASSEMBLY TERMINATION.

;<RAVELING>MACN11.MAC;10     9-MAY-74 20:09:49	EDIT BY RAVELING

;	CCL'S BACK IN -- THE "%$#(#"! WON'T ASSEMBLE WITHOUT IT!

;<RAVELING>MACN11.MAC;9     9-MAY-74 19:48:00	EDIT BY RAVELING

;	1.  SET ASSEMBLY PARAMETER FOR NO CCL FEATURES.

;	2.  DELETED PAGE EXTENSIONS, ANTICIPATING GENUINE PAGE
;	    NUMBERING.

;	3.  FIXED .SBTTL BUG THAT CAUSED OCCASIONAL GARBLING.

;	4.  IMPLEMENTED .NARG.

;	5.  MODIFIED .PRINT & .ERROR TO PRINT THE WHOLE LINE,
;	    TO MATCH MACRO-11.

;<RAVELING>MACN11.MAC;8    27-MAR-74 21:43:22	EDIT BY RAVELING

;	1.  DELETED ALL REFERENCES TO .PDP10 FEATURE USE COUNT.
;	2.  CHANGED .RAD50 AND .OPDEF TO CHECK NSFFLG INSTEAD OF
;		.PDP10 FOR NONSTANDARD FEATURES.
;	3.  .ASCII & .ASCIZ ACCEPT ANY EXPRESSION (NOT JUST A NUMBER)
;		WITHIN ANGLE BRACKETS.

;			----------------------------------

;			CHANGES FOR VERSION 0 & PREHISTORY

;			----------------------------------


;<RAVELING>MACN11.MAC;7     8-MAR-74 17:14:23	EDIT BY RAVELING

;	1.  FIXED BUG IN NUMBER CONVERSION DUE TO LOCAL
;		SYMBOL CHECKING.
;	2.  FIXED BUG IN LOCAL SYMBOL PROCESSING (LOCAL SYMBOL
;		BLOCK NUMBER WASN'T RESET BEFORE PASS 2).

;<RAVELING>MACN11.MAC;6     8-MAR-74 14:55:20	EDIT BY RAVELING
;<RAVELING>MACN11.MAC;5    15-FEB-74 22:18:31	EDIT BY RAVELING
;<RAVELING>MACN11.MAC;4    14-FEB-74 20:59:45	EDIT BY RAVELING
;<RAVELING>MACN11.MAC;3     1-FEB-74 20:53:04	EDIT BY RAVELING
;<RAVELING>MACN11.MAC;2    16-JAN-74 21:13:36	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;58    14-JAN-74 10:11:56	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;57    14-JAN-74 07:11:10	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;56     9-JAN-74 08:47:11	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;55     4-JAN-74 17:02:31	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;54    28-DEC-73 20:34:17	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;53    28-DEC-73 13:51:54	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;52    14-DEC-73 19:08:02	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;51    28-NOV-73 15:50:49	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;50    26-NOV-73 21:33:46	EDIT BY CASNER
;<RAVELING>MACX11.MAC;49    26-NOV-73 18:24:30	EDIT BY CASNER
;<RAVELING>MACX11.MAC;44    31-OCT-73 17:46:51	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;43    25-OCT-73 18:30:31	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;41    24-OCT-73 21:12:50	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;40    23-OCT-73 19:45:43	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;39    19-OCT-73 18:08:33	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;38    19-OCT-73 16:36:11	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;37    18-OCT-73 19:17:42	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;36    18-OCT-73 18:35:03	EDIT BY RAVELING
	LIST
;	Contributing installations and programmers:

;	-- CMU	    (Rick Gumpertz, Brian Rosen)
;	-- USC-ECL  (Dennis Smith)
;	-- USC-ISI  (Steve Casner, Jim Koda, Paul Raveling)
;	-- SCRL	    (Shari Price, Dave Retz)
;	-- BBN	    (Ray Tomlinson)

	IFNDEF	CMUSW,<CMUSW==0>
	   IFN	CMUSW,<
		TENEX==0
		STANSW==0
		IFNDEF PAGSIZ,<PAGSIZ==^D60>
	   >;IFN CMUSW
	IFNDEF	STANSW,<STANSW==0>	; FOR STANFORD PPN'S
	   IFN	STANSW,<
		TENEX==0
		CMUSW==0
		IFNDEF TwoSgs,<TwoSgs==0>
	   >;IFN STANSW

	IFNDEF	TENEX,<TENEX==1>	; Default to Tenex configuration
	IFN	TENEX,<TwoSgs==0>	; No high segment for Tenex
	IFNDEF	TwoSgs,<TwoSgs==1>	; Everywhere else defaults 2 segments
	IFN	TENEX,<TEMPC==0>	; NO TEMPCOR IF TENEX
	IFNDEF	CCLSW,<CCLSW==1>	; NORMALLY ASSEMBLE WITH CCL FEATURES
	IFE	CCLSW,<TEMPC==0>	; TMPCOR UUO FLAG
	IFNDEF	TEMPC,<TEMPC==1>	; NORMALLY USE CCL WITH TMPCOR UUO

	IFNDEF	PAGSIZ,<PAGSIZ==^D54+3>	; Default page size is 54 lines + 3 header lines.
	IFNDEF	MD20SW,<MD20SW==0>	; Don't flag non-mod 20 instructions.


	ENTRY	MACN11
IFE TENEX,< EXTERNAL .JBREL,.JBFF >

IFN TENEX,<
IFE .CPU.-4,<
	SEARCH	MONSYM
>;IFE .CPU.-4
IFE .CPU.-3,<
	SEARCH	STENEX
>;IFE .CPU.-3
>;IFN TENEX

IFN TwoSgs,<
	TWOSEG
	RELOC	400000
>;IFN TwoSgs

IFN TENEX,<
	PURE== 1000			; Beginning of pure code
	LOC	PURE
>

	RADIX 10

	VERMAJ==4		; Major version number
	VERMIN==42		; Minor (edit) version number


	DEFINE	CTITLE (MAJ,MIN)
< IFN TENEX, TITLE MACN11 V'MAJ'.'MIN'T
  IFE TENEX, TITLE MACN11 V'MAJ'.'MIN
>

	DEFINE	CNAME	(N1,N2,N3)
<	IFN TENEX, SIXBIT /V'N1'.'N2'N3'T/
	IFE TENEX, SIXBIT /V'N1'.'N2'N3' /
>

	CTITLE	(\VERMAJ,\VERMIN)

	N2==VERMIN/10
	N3==VERMIN-<N2*10>


TITLE:	SIXBIT	/MACN11/
ASMVER:	CNAME	(\VERMAJ,\N2,\N3)
IFE TENEX,<
	.JBVER=^O137
	LOC	.JBVER
	XWD	VERMAJ*100,VERMIN
	RELOC
>;IFE TENEX

	PURGE	N2,N3

	RADIX	8
	SUBTTL	VARIABLE PARAMETERS

IFE TENEX,<
	NUMBUF== 2			; NUMBER OF BUFFERS PER DEVICE

	CORINC== 2000			; CORE INCREMENT
>;IFE TENEX

	SPL==	 5			; SYMBOLS PER LINE (SYMBOL TABLE LISTING)

	SPLTTY== 3			; SYMBOLS PER LINE (TTY)

	DATLEN== ^D350			; DATA BLOCK LENGTH

	RLDLEN== ^D40

	WPB==	 ^D30			; MACRO BLOCK SIZE
	MACNES== ^D32			; MACRO NESTING LIMIT
					; -- THIS APPLIES TO BOTH NESTED MACRO
					;    DEFINITIONS AND NESTED CALLS.

	CPL1==	 ^D72			; CHARACTERS PER LOGICAL LINE
	CPL2==	 ^D83			; CHARACTERS PER PHYSICAL LINE
	CPL3==	 ^D144			; CHARACTERS PER .PDP10 LINE

	PDPLEN== ^D256			;  PUSH-DOWN POINTER LENGTH

	CRFLEN== ^D36			; CREF SYMBOLS/LINE MAX

	COLLPT== ^D132			; CPL LPT

	COLTTY== ^D79			; CPL TTY

TRUE==  1
BKT1==	1
BKT2==	2
BKT3==	3
BKT4==	4
BKT6==	6

	SUBTTL	ACCUMULATOR ASSIGNMENTS

	R0=	0			; ACCUMULATION OF SIXBIT SYMBOL, SCRATCH
	R1=	1			; SYMBOL VALUE AND FLAGS SET BY SRCH.  SCRATCH
	R2=	2			; SCRATCH
	R3=	3			; UNIVERSAL SCRATCH
	R4=	4			; UNIVERSAL SCRATCH +1
	R5=	5			; LOCATION COUNTER
	R6=	6			; SCRATCH
	R7=	7			; SYMBOL TABLE SEARCH INDEX
	R10=	10			; EXPRESSION OR TERM VALUE, SCRATCH
	R11=	11			; SCRATCH
	R12=	12			; MACRO STORAGE BYTE POINTER
	R13=	13			; LINE BUFFER BYTE POINTER
	R14=	14			; CURRENT CHARACTER (ASCII)
	R15=	15			; LH - ASSEMBLER FLAGS,  RH - ERROR FLAGS
	R16=	16			; EXEC FLAGS


;	ALTERNATE SYMBOLIC AC ASSIGNMENTS ----

RLOC==	5				; LOCATION COUNTER
RBPTR==	13				; INPUT BYTE POINTER
RBYTE==	14				; INPUT BYTE
RMODE==	15				; MODE FLAG REGISTER (LEFT  HALF)
RERR==	15				; ERROR FLAG REGISTER (RIGHT HALF)
P=	17				; STACK PTR FOR SUBROUTINE LINKAGE

IFN 0,<	;The following is for the "@" listing program used at MIT, SAIL and CMU:
	.XCREF R0,R1,R2,R3,R4,R5,R6,R7,R10,R11,R12,R13,R14,R15,R16
	.XCREF P
	.XCREF CALL,RETURN
>;IFN 0 for "@"
	SUBTTL	FLAG REGISTERS

					; R16 - LH

	LSTBIT== 000001			; 1- SUPRESS LISTING OUTPUT
	BINBIT== 000002			; 1- SUPRESS BINARY OUTPUT
	CSWBIT== 000004			; 1- SUPRESS CROSS REFERENCE
	IRPBIT== 000010			; 1- GENERATING .IRP CALL BLOCK
					;    * THAT MEANS PARSE ONLY 1 ARG.
	FOLBIT== 000020			; 1- OVERRIDE INPUT FOLDING
	MODBIT== 000040			; 1- USER MODE AC'S SET
;	GEQBIT== 000100			; 1- GLOBAL EQUATE (==) BEING PROCESSED
	TTYBIT== 000200			; 1- LISTING IS ON TTY
	ERRBIT== 000400			; 1- ERROR MESSAGES ENABLED
	SBTBIT== 001000			; 1- SUBTITLE AVAILABLE
	NLISLN== 002000			; 1- SUPPRESS LIST OF CURRENT LINE
	LBLBIT== 004000			; 1- STATEMENT IS LABELED (MAY BE
					;    USED TO FORCE PRINTING LOC)
	PF1BIT== 010000			; 1- PRINT PF1 AS IS, INSTEAD OF
					;    A WORD FROM CODBUF
	MEXBIT== 020000			; 1- MACRO EXPANSION IN PROGRESS
	BEXBIT== 040000			; 1- BINARY EXTENSION LINE BEING LISTED
;**** Available bit here!!!!! ****
	IIFBIT== 200000			; 1- .IIF (NOT .IF!) IN PROGRESS
	REQBIT== 400000			; 1- .REQUIRE in progress


					; R16 - RH

; This bits are used in command line processing


	CKBBIT== 000001			; 1- CHECKING FOR BINARY FILE
	CKLBIT== 000002			; 1- CHECKING FOR LISTING FILE
	SWTBIT== 000004			; 1- ENTER SWITCH MODE
	INFBIT== 000010			; 1- VALID INFORMATION SEEN
	GENBIT== 000020			; 1- Looking for generation #
	DEVBIT== 000040			; 1- NEW DEVICE HAS BEEN NAMED
	NLTBIT== 000100			; 1- PROCESSING .NL
	DSABIT== 000200			; 1- PROCESSING .DS
	ENDBIT== 000400			; 1- END OF ALL INPUT FILES
	ARWBIT== 001000			; 1- LEFT ARROW SEEN
	EXTBIT== 002000			; 1- EXPLICIT EXTENSION SEEN
	NULBIT== 004000			; 1- NON-NULL COMMAND STRING
	DOTBIT== 010000			; 1- PERIOD WAS LAST CHARACTER
	COMBIT== 020000			; 1- COMMA WAS LAST CHARACTER
	COLBIT== 040000			; 1- COLON WAS LAST CHARACTER
	FILBIT== 100000			; 1- Looking for filename
	DIRBIT== 200000			; 1- Looking for directory name
IFE TENEX,<
	BRKBIT== 200000			; 1- Bracket was last character
>;IFE TENEX
	SWTBIT== 400000			; 1- Looking a switch characters

; Bits used by the assembler

	FFBIT==  020000			; 1- FORM-FEED SEEN
	EXLBIT== 040000			; 1- This is an extension line
	ASCBIT== 100000			; 1- This line contains a .ASCIZ or .ASCII and
					;    binary output is to be suppressed
	HDRBIT== 200000			; 1- TIME FOR NEW LISTING PAGE
	SEQBIT== 400000			; 1- SEQUENCE NUMBER SEEN


					; R15 - LH

	CDRFLG== 000001			; 1- CARD READER INPUT (73-80 IGNORED)
	LCFLG==  000002			; 1- LOWER CASE INPUT
	LSBFLG== 000004			; 1- LOCAL SYMBOL BLOCK ENABLED
	PNCFLG== 000010			; 1- BINARY OUTPUT ENABLED
	ENDFLG== 000020			; 1- END OF SOURCE ENCOUNTERED
	REGFLG== 000040			; 1- REGISTERS DEFINED BY ASSEMBLER
	AMAFLG== 000100			; 1- ABS MODE ADDRESSING
	CONFLG== 000200			; 1- CONCATENATION CHARACTER SEEN
	HFKFLG== 000400			; 1- Half-killed symbol mode enabled
	FPTFLG== 001000			; 1- FLOATING POINT TRUNCATION MODE
	GBLFLG== 002000			; 1- TREAT UNDEFINED SYMBOLS AS GLOBAL
	HOVFLG== 004000			; 1- CAUSES SYMBOL BEGINNING WITH A-F
					;    TO BE INTERPRETED AS A HEX
					;    CONSTANT, IF RADIX=16
	ABSFLG== 010000			; 1- ABSOLUTE OBJECT
	ISDFLG== 020000			; 1- INTERNAL SYMBOL DICTIONARY REQ'D
	FLTFLG== 040000			; 1- ERROR ENCOUNTERED IN FLOATING ROUTINE
	PSWFLG== 100000			; 1- IMAGE (UNPACKED) MODE
	NSFFLG== 200000			; 1- NONSTANDARD FEATURES ENABLED
	P1F==	 400000			; 1- PASS 1 IN PROGRESS

;	** ALL BITS CORRESPONDING TO .ENABL/.DSABL OPTIONS:

ENAMA1== ABSFLG+AMAFLG+CDRFLG+FPTFLG+GBLFLG+HOVFLG
ENAMA2== LCFLG+LSBFLG+PNCFLG+REGFLG+ISDFLG+HFKFLG

ENMASK== ENAMA1+ENAMA2

ENDEF==	LCFLG+PNCFLG+REGFLG+NSFFLG	; ***** DEFAULT ENABL MODES *****


					; R15 - RH

	ERRA== 400000			; 1- ADDRESSING ERROR.
	ERRB== 200000			; 1- BOUNDARY ERROR.
	ERRD== 100000			; 1- DOUBLY-DEFINED SYSMBOL REFERENCED.
	ERRE== 040000			; 1- END DIRECTIVE NOT FOUND.
	ERRI== 020000			; 1- ILLEGAL CHARACTER DETECTED.
	ERRL== 010000			; 1- LINE BUFFER OVERFLOW (EXTRA CHARCTERS IGNORED).
	ERRM== 004000			; 1- MULTIPLE DEFINITION OF A LABEL.
	ERRO== 002000			; 1- OPCODE ERROR.
	ERRP== 001000			; 1- PHASE ERROR.
	ERRQ== 000400			; 1- QUESTIONABLE SYNTAX
	ERRR== 000200			; 1- REGISTER TYPE ERROR.
	ERRT== 000100			; 1- TRUNCATION ERROR.
	ERRU== 000040			; 1- UNDEFINED SYMBOL.
	ERRN== 000020			; 1- 8 OR 9 WITHOUT DECIMAL POINT.
	ERRZ== 000010			; 1- MARGINAL INSTRUCTION

	ERRP1==  000001

	SUBTTL	MISCELLANEOUS PARAMETERS
IFE TENEX,<

	TTYDEV== 000010			; 1- DEVICE IS A TTY
	PTRDEV== 000200			; 1- DEVICE IS A PTR
	LPTDEV== 040000			; 1- DEVICE IS A LPT
	CDRDEV== 100000			; 1- DEVICE IS A CDR

	IODATA== 200000			; 1- IO DATA ERROR
	IODEV==  100000			; 1- IO PARITY ERROR
	IOWRLK== 400000			; 1- IO WRITE LOCK ERROR
	IOBKTL== 040000			; 1- IO BLOCK TOO LARGE
	IOEOF==	 020000			; 1- END OF FILE ON IO DEVICE


					; DEVICE PARAMETERS

	BIN==	1
	LST==	2
	SRC==	3
	CMD==	4

	RQSTKL=	<7*^D10>+1		; .Require stack length for ^D10 files
>;IFE TENEX

	ILLCHR== 1			; ILLEGAL CHARACTER SUBSTITUTE
	ELLCHR== 2			; END OF LOGICAL LINE CHARACTER
	INBIT==	2			; DEVICE CAN DO INPUT
	ALMODE== 1			; ASCII LINE MODE

IFN TENEX,<
	EOL==	37			; TENEX END OF LINE
	ESC==	33			; ESCAPE FOR INTERACTIVE MODE
	DEL==	177			; Delete one character
	SWTWRD==  DOTBIT		; 1- LOOKING FOR A SWITCH (3 CHARS OR LESS)
	MAXJFN== ^D20			; Maximum source files allowed
	RQSTKL== <<MAXJFN-1>*^D11>+1	; Length of the require stack
	SPGMAP== 777			; Page to map source files into
	SINLEN== 1000			; Length of a SIN for source files

>;IFN TENEX

;	-------- LISTING CONTROL FLAGS -----------

;	THESE FLAGS ARE USED IN THE FOLLOWING WORDS:

;	LIWORD	LH - VALUE OF OVERRIDES FROM COMMAND STRING
;		RH - MASK SHOWING WHICH MODE BITS ARE OVERRIDDEN

;	LSTCTL	LH - VALUE OF LISTING MODES SET BY SOURCE DIRECTIVES
;		RH - EFFECTIVE MODES, DETERMINED BY ALL 3 1/2 WORDS ABOVE

LBEX==	000001				; BINARY EXTENSIONS
LBIN==	000002				; BINARY CODE
LCOM==	000004				; COMMENTS
LCND==	000010				; UNSATISFIED CONDITIONS
LLD==	000020				; LISTING DIRECTIVES WITHOUT ARGUMENTS
LLOC==	000040				; LOCATION COUNTER
LMC==	000100				; MACRO CALLS
LMD==	000200				; MACRO DEFINITIONS
LME==	000400				; MACRO EXPANSIONS
LMEB==	001000				; MACRO EXPANSION BINARY CODE
LSEQ==	002000				; SOURCE SEQUENCE NUMBERS
LSON==	004000				; SOURCE ORIENTED NUMBERING
LSRC==	010000				; SOURCE CODE
LSYM==	020000				; SYMBOL TABLE
LTOC==	040000				; TABLE OF CONTENTS
LTTM==	100000				; TELETYPE MODE
LASC==	200000				; ASCII and ACIZ output control
LFLC==	400000				; Expanded floating point in a generated comment line

LDEF=	777777-LLD-LME-LMEB-LTTM-LSON	; *****  DEFAULT LIST MODES  *****
IFN CMUSW,< LDEF== LDEF+LSON+LMEB >

BINRDX==	1			; BIT DEFINITIONS FOR GLBRDX CONTROL WORD
QUARDX==	2
OCTRDX==	4
DECRDX==	10
HEXRDX==	20
HEXENB==	40			; ENABLES HEX CONSTANTS TO START WITH A-F,
					;  SO CONSEQUENTLY SYMBOLS CAN'T

IFE TENEX,<				; 1050 OPDEFS

	OPDEF	RESET	[CALLI	 0]
	OPDEF	DEVCHR	[CALLI	 4]
	OPDEF	CORE	[CALLI	11]
	OPDEF	EXIT	[CALLI	12]
	OPDEF	DATE	[CALLI	14]
	OPDEF	APRENB	[CALLI	16]
	OPDEF	MSTIME	[CALLI	23]
	OPDEF	RUNTIM	[CALLI	27]
	OPDEF	ZBINK	[CLOSE BIN,]

	OPDEF	OUTCHR	[TTCALL 1,]
	OPDEF	OUTSTR	[TTCALL 3,]
	OPDEF	INCHWL	[TTCALL 4,]
>;IFE TENEX

	OPDEF	CALL	[PUSHJ P,]
	OPDEF	RETURN	[POPJ P,]



	DEFINE	GENM40	(A,B,C,D,E,F)	; GEN MOD 40
<
	XWD	$'A*50*50+$'B*50+$'C , $'D*50*50+$'E*50+$'F
>;GENM40

	DEFINE	ARG	(A,B,C,VALUE)	; ARG TABLE GENERATOR
<
	XWD	VALUE,$'A*50*50+$'B*50+$'C
>;ARG
IFN TENEX,<
	SUBTTL	EXEC -- Tenex style

MACN11:
IFN CCLSW,<
	TDZA	0,0
	 SETO	0,
	MOVEM	0,CCLFLA
>;IFN CCLSW
	MOVEI	R4,DEL			; Assume Tops-20 editting character
	SETZB	R3,TENFLG		; Assume we are on Tenex
	HRROI	R1,R3			; Store the string in R3
	HRLOI	R2,600015		; Get the null device name
	DEVST				; Convert it
	 JFCL				; Ignore any errors
	CAMN	R3,[ ASCIZ /NUL/ ]	; Is it Tops-20 because its NUL?
	 JRST	MACNT2			; Yes - skip Tenex stuff
	SETOM	TENFLG			; No - set the Tenex flag
	MOVEI	R4,"A"-100		; Assume Tenex editting character
MACNT2:	MOVEM	R4,BAKCHR		; Load the back-up editting character
NULFIL:	RESET
	MOVEI	R1,100			; Primary input
	RFPOS				; Read line position
	HRROI	R1,$CRLF		; Assume we need a new line
	TRNE	R2,-1			; Beginning of the line?
	 PSOUT				; No - get a new line
	MOVEI	R1,(1B0)		; THIS FORK
	MOVE	R2,[ XWD ALEV,ACHN ]	; TABLES ADDRESSES
	SIR				; SET THEM UP FOR PSI
	MOVSI	R2,(1B2)		; Channel 2
	AIC				; Activate it
	MOVEI	R1,(1B0)		; THIS FORK
	EIR				; OK, NOW ENABLE PSI
	MOVE	P,[IOWD PDPLEN,PDPSTK]	; INIT STACK POINTER.
	MOVE	R1,[ IOWD RQSTKL,REQSTK ] ; Get .REQUIRE stack pointer
	MOVEM	R1,REQSP		;  and reset it
	SETO	R1,			; GET RID OF PAGE
	SETZ	R3,
	SKIPN	R2,CMDPAG		; GET COMMAND STRING PAGE #
	 JRST	NCMDPG			; FORGET THIS IF NO PAGE
	HRLI	R2,(1B0)		; THIS FORK
	PMAP				; KILL PAGE
NCMDPG:	MOVE	R2,[ XWD 400000,SPGMAP ]
	PMAP				; Map data page out to pe clean
	MOVE	R1,[ XWD 400000,<ZZZZZZ+777>/1000 ]
FPGTST:	RPACS				; Test to see if page exists
	TLNE	R2,(1B5)		; Is it there?
	 AOJA	R1,FPGTST		; Yes - test next page
	MOVEM	R1,CMDPAG		; No - free page
	LSH	R1,^D9			; SHIFT FOR ADDRESS
	HRRZM	R1,PAGPTR		; SAVE THE FIRST LOCATION
	ADDI	R1,1000			; Move to next page to be used for free
	HRRZM	R1,.JBFF		;  space
	MOVEI	R1,776777		; Make last address the end of free
	MOVEM	R1,.JBREL		;  space

IFN CCLSW,<
	SKIPE	CCLFLA			; USING CCL?
	 CALL	DSKNIT			; OPEN CCL INPUT
	  CAIA				; FAILED
	   JRST	NXTCCL
>;IFN CCLSW
	MOVE	R0,TITLE		; DISPLAY "MACN11"
	CALL	LSTVER			; AND VERSION # ON
	MOVEI	R1,"-"			; USER'S TERMINAL.
	PBOUT

	MOVE	R0,ASMVER		; GET VERSION #.
	CALL	LSTVER

	HRROI	R1,$CRLF		; Follow with a new line
	PSOUT
NXTCCL:	MOVE	R0,[XWD BZCOR,BZCOR+1]	; CLEAR A BUNCH OF WORKING
	SETZM	BZCOR			;    STORAGE TO 0.
	BLT	R0,EZCOR-1
	HRRZ	R1,PAGPTR		; RESTORE PAGPTR
	MOVEI	R2,777(R1)		; Point to last location in page
	HRL	R1,R1			; Need address in both halves
	SETZM	(R1)			; Clear first word
	AOJ	R1,			; BLT needs [ .,.+1 ]
	BLT	R1,(R2)			; Clear that page

	MOVEI	R1,"*"			; Print user prompt
IFN CCLSW,<
	SKIPN	CCLFLA
>;IFN CCLSW
	PBOUT				; COMMAND STRING INPUT.
	CALL	CORSET			; INITIALIZE SYMBOL TABLE.
	MOVSI	R16,BINBIT!LSTBIT!CSWBIT ; INIT FLAGS IN R16 LH.
	SETZB	R15,R5			; Clear byte count and flag register

CMDGET:	MOVE	R7,PAGPTR		; GET A FREE ADDRESS
	HRLI	R7,(POINT 7,,34)	;  FOR STRING POINTER
	SOJ	R7,			; Make the address correct
	MOVEM	R7,CMDSTR		; SAVE COMMAND STRING POINTER
IFN CCLSW,<
	SKIPN	CCLFLA
	 JRST CMDSGT
	MOVE	R1,CCLJFN
RCCLLN:	BIN
	CAIN	R2,15
	 JRST	RCCLLN			; IGNORE CR
	JUMPE	R2,CCLDUN		; DONE ON EOF
	CAIN	R2,12
	 JRST	FINI2			; END ON LF
	IDPB	R2,R7			; STORE IN COMMAND STRING
	JRST	RCCLLN

CCLDUN:	MOVE	R1,CCLJFN
	HRLI	R1,400000
	CLOSF
	 JFCL
	HRRZS	R1
	DELF
	 JFCL
	HALTF
	JRST	MACN11
>;IFN CCLSW
CMDSGT:
	MOVEI	R1,EBRKTB		; Character break list
	MOVE	R4,CMDSTR		; Original string pointer
	MOVE	R2,R7			; New string pointer
	SETZ	R3,			; Unlimited byte count
	CALL	REREAD			; Get the string
	MOVEI	R5,(R3)			; Reset byte count
	MOVE	R7,R2			; Save updated string pointer
	HLRZ	R2,R1			; Get address to jump
	JRST	(R2)			;  and go

HLTMAC:					; Halt MACN11
	PBOUT				; Output the ^Z
	HALTF				; Then halt
	JRST	NULFIL			; If continue then restart

RSPACE:					; Got a space so echo it but don't
	MOVEI	R1," "			;  put it in the string
	PBOUT
	JRST	CMDSGT			; Back to main get

FLDDEL:					; Erase a field
	HRROI	R1,[ ASCIZ /^X___
/ ]
	PSOUT
	CALL	FLDBAK			; Back up to last field
	JRST	CMDSGT			; Get more characters

CTRLW:
	JUMPE	R5,DINGA		; If nothing then ring bell
	SETZB	R2,R3			; Set flag
CTRLW0:
	JUMPE	R5,CTLW1		; If all the way back then done
	LDB	R1,R7			; Get current byte
	CAIE	R1,"="			; Look for separators
	CAIN	R1,"_"
	 JRST	CTLW1
	CAIE	R1,"."
	CAIN	R1,","
	 JRST	CTLW1
	CAIE	R1,":"
	CAIN	R1,"/"
	 JRST	CTLW1
	CAIE	R1,74			; Left and right angle brackets
	CAIN	R1,76
	 JRST	CTLW1
	CAIN	R1,";"
	 JRST	CTLW1
	DPB	R3,R7			; Place a zero byte
	CALL	BKSPTR			; Back-up the pointer
	AOJA	R2,CTRLW0
CTLW1:
	JUMPE	R2,DINGA		; If nothing deleted then ring the bell
	MOVEI	R1,"_"			;  Else tell user so
	PBOUT
	JRST	CMDSGT			; Back to user

DINGA:	MOVEI	R1,"G"-100		; Output bell to the terminal
	PBOUT
	JRST	CMDSGT			; Back to get more

RECOG:
	MOVEI	R4,(R1)			; Save the breaking character
	MOVE	R14,CMDSTR		; Get start of command string
	MOVE	R11,R14			; Need it in two places
	HRRI	R16,CKBBIT!FILBIT	; Set intial bits
FILREC:	ILDB	R2,R14			; Get a byte from the comamnd string
	SOJL	R3,LOOKUP		; If no more bytes - then look it up
	CAIN	R2,"."			; End of filename?
	 JRST	DOTCHK			; Check it out
	CAIN	R2,","			; End of a field?
	 JRST	COMCHK			; Yes
	CAIN	R2,";"			; Semicolon for version?
	 JRST	SEMCHK			; Yes
	CAIN	R2,":"			; Colon for new device?
	 JRST	[ TRZ	R16,INFBIT	; Yes - start new field
		  JRST	FILREC	]	; Keep reading
	CAIN	R2,"/"			; Switch?
	 JRST	SWITCK			; Yes
	CAIN	R2,76			; Right angle bracket?
	 JRST	UNDIR			; Yes
	CAIE	R2,"="			; Source file separators?
	CAIN	R2,"_"
	 JRST	LARCHK			; Yes
	CAIN	R2,74			; Angle bracket?
	 JRST	LFTCHK			; Yes
	TRO	R16,INFBIT		; Count this byte as information
	JRST	FILREC			; Keep going

DOTCHK:
	SKIPN	TENFLG			; Tenex or Tops-20?
	 JRST	DOTT20			; Tops-20 so it maybe generation number
	TRZN	R16,FILBIT		; Must have been in filename wait
	 TRO	R16,ERRBIT		;  else error
	TRO	R16,EXTBIT		; Now move to extension
	JRST	FILREC			; Move on the next character

DOTT20:
	TRZN	R16,FILBIT		; May have been in filename
	 JRST	DOTCK1			; Wasn't
	TRO	R16,EXTBIT		; Now we're in ext
	JRST	FILREC

DOTCK1:	TRZN	R16,EXTBIT		; Must have been in extension
	 TRO	R16,ERRBIT		; Error if not
	TRO	R16,GENBIT		; Now in generation number
	JRST	FILREC

COMCHK:
	TRNE	R16,CKBBIT		; From binary?
	JRST	[ HRRI	R16,CKLBIT!FILBIT ; Yes
		  JRST	RECEXT	]	; Exit back to get more bytes
	HRRI	R16,FILBIT		; No - getting source now
	JRST	RECEXT			; Get more bytes

SEMCHK:
	TRNN	R16,FILBIT!EXTBIT!GENBIT	; Came from filename or extension?
	 TRO	R16,ERRBIT		; No - error
	JRST	FILREC			; Get those bytes

UNDIR:
	TRZN	R16,DIRBIT		; Was dir bit on before?
	 TRO	R16,ERRBIT		; NO - flag error
	TRO	R16,FILBIT		; Now make it filename
	JRST	FILREC			; Keep going

LFTCHK:					; Left angle bracket check
	TRNE	R16,INFBIT		; Anything prior to this?
	 JRST	LARCHK			; Yes - treat like source file separator
	HRRI	R16,DIRBIT		; Reset flags to directory input
	MOVE	R1,R14			; Load current byte pointer
	BKJFN				; Back it up 
	 0
	MOVE	R11,R1			; Save it
	JRST	FILREC			; Get more bytes
LARCHK:
	HRRI	R16,FILBIT		; Set to inputting filename
RECEXT:	MOVE	R11,R14			; Reset byte pointer
	TRZ	R16,INFBIT		; Make sure info bit is off
	JRST	FILREC			; Get more characters

SWITCK:
	TRO	R16,SWTBIT		; Set switch bit
	JRST	FILREC
LOOKUP:
	TRNN	R16,INFBIT		; Any thing to lookup on?
	 JRST	DINGA			; No - ring bell
	TRNE	R16,ERRBIT!SWTBIT	; Errors or switch?
	 JRST	QUEST			; Error print "?"
	TRNE	R16,DIRBIT		; Looking for a directory?
	 JRST	DIRLOK			; Yes - treat it differently
	SKIPN	TMPJFN			; GTJFN I/O file mapped in?
	CALL	TMPMAP			; No - map it
	MOVE	R2,R7			; Get pointer to last byte
	IDPB	R4,R2			; Place ESC or ^F in the string
	MOVEI	R2,(R16)		; Get flags
	ANDI	R2,CKBBIT!CKLBIT	; Mask all except binary and listing
	MOVE	R1,EBLK(R2)		; Load right E block pointer
	JUMPE	R2,SRCLUK		; Treat source lookup differently
	MOVEI	R2,[ ASCIZ /OBJ/	; Load right default extention
		     ASCIZ /LST/ ]-1(R2)
	HRROM	R2,5(R1)		; Set it in the E block
	MOVE	R2,R11			; Load main string pointer
	GTJFN				; Look up the filename
	 JRST	[ MOVE	R3,TMPPTR	; Failed - get temp file pointer
		  ILDB	R2,R3		; Load the next byte
		  JUMPE	R2,QUEST	; Error if nothing there
		  JRST	APPLP	]	; Merge back in
SRCREL:
	RLJFN				; Release this JFN
	 JFCL
	MOVE	R2,TMPPTR		; Get a copy of the string pointer
	ILDB	R1,R2			; Get next byte
	JUMPE	R1,DINGA		; If nothing then name must be complete
APPLP:	ILDB	R1,TMPPTR		; Get byte from the temp file
	JUMPE	R1,[ MOVE R1,TMPJFN
		     SETZ R2,
		     BOUT		; Mark off with zero byte
		     JRST CMDSGT  ]
	CAIE	R1,"G"-100		; Bell?
	 JRST	[ IDPB	R1,R7		; No - output to string
		  AOJA	R5, .+1	]	; Also, count this byte
	PBOUT				; Always output to the terminal
	JRST	APPLP			; Keep looping

DIRLOK:
	MOVSI	R1,(1B0)		; Try to recognize the dir name
	IBP	R11			; Bump byte pointer
	MOVE	R2,R11			; Load the string pointer
	STDIR
	 JRST	QUEST			; No match error
	 JRST	[ MOVEI	R1,"G"-100	; Tell user that we need more
		  PBOUT
		  JRST	CMDSGT	]
DIRL1:	CAMN	R2,R7			; All done?
	 JRST	DIRL2			; Yes - exit this loop
	ILDB	R1,R7			; Get a byte
	PBOUT				;  and output it
	AOJA	R5,DIRL1		; Count it and loop

DIRL2:	MOVEI	R1,76			; Close the dir name
	IDPB	R1,R7			; In both string
	PBOUT				;  and terminal
	MOVEI	R1,"G"-100		; Assume ESC was typed
	CAIN	R4,ESC			; Was it?
	PBOUT				; Yes
	AOJA	R5,CMDSGT		; Bump byte count and back for more

QUEST:	HRROI	R1,[ ASCIZ / ?
/ ]
	PSOUT
	CALL	FLDBAK			; Back up to last field

; Output the command string over again so user can see what happended

QUESTP:
	JUMPLE	R5,CMDSGT		; No characters so forget it
	MOVEI	R1,101			; Primary output
	MOVE	R2,CMDSTR		; Load string pointer
	MOVN	R3,R5			; Load negative byte count
	SOUT				; Output the commad string
	JRST	CMDSGT			; back to user for more characters
FLDBAK:
	SETZ	R3,
	CAMN	R7,CMDSTR		; Back to the beginning?
	JRST	QUEST2			; Yes
	LDB	R1,R7			; Get current byte
	CAIE	R1,"="			; Separator?
	CAIN	R1,"_"
	 JRST	QUEST2			; Yes - exit
	CAIN	R1,","
	 JRST	QUEST2
	CAIN	R1,74			; Left angle bracket?
	 JRST	[ MOVE	R4,R7		; Yes - save this pointer
		  CALL	BKSPTR		; Back up the pointer
		  CAMN	R7,CMDSTR	; Any more left?
		   JRST	QUEST2		; No - exit
		  LDB	R1,R7		; Get byte
		  CAIE	R1,"="		; Separator?
		  CAIN	R1,"_"
		  JRST	QUEST2		; Yes - now we have right pointer
		  CAIN	R1,74		; Test for left angle bracket
		  JRST	QUEST2
		  MOVE	R7,R4		; Reset byte pointer
		  JRST	QUEST2	]
	DPB	R3,R7			; Replace the byte with a null byte
	CALL	BKSPTR			; Back up the string pointer
	JRST	FLDBAK+1		; Back to the loop

QUEST2:
	MOVE	R2,R7			; Get string pointer
	IDPB	R3,R2			; Store a null byte
	RETURN				; Back to caller


BKSPTR:
	SOJ	R7,			; Decrement the address
	IBP	R7			; Move to next byte
	IBP	R7			; Move to next byte
	IBP	R7			; Move to next byte
	IBP	R7			; Move to next byte
	SOJ	R5,			; Decrement byte count
	RETURN				; Back to caller

SRCLUK:					; Lookup on source filename
	MOVSI	R3,-NSEXTS		; LOOP THRU ALL STANDARD EXTS
SRCLKL:	HRROI	R2,SEXTS(R3)		; WORKS IF EXTS LESS THAN 4 CH
	MOVEM	R2,5(R1)		; Set it
SRCLKN:	MOVE	R2,R11			; Set string pointer
	GTJFN				; Try to get the JFN
	 CAIA
	  JRST	SRCREL			; Got it - release the JFN first
	MOVE	R1,TMPPTR		; Get byte pointer
	ILDB	R2,R1			; Get next byte
	JUMPN	R2,APPLP
	MOVEI	R1,SRCBLK
	AOBJN	R3,SRCLKL		; TRY ALL THE EXTENSIONS
	SETZ	R2,
	EXCH	R2,5(R1)
	JUMPN	R2,SRCLKN		; LOOK AT NO EXTENSION TOO
	JRST	QUEST			; Couldn't find it error out

SEXTS:	ASCIZ /M11/
	ASCIZ /P11/
	ASCIZ /MAC/
	ASCIZ /SML/
NSEXTS==.-SEXTS

TMPMAP:
	MOVSI	R1,400001		; Output file from a string pointer
	HRROI	R2,[ ASCIZ /MACN11.TMP;-1;T/ ]
	SKIPN	TENFLG			; Did we load the right string pointer?
	HRROI	R2,[ ASCIZ /MACN11.TMP.-1;T/ ]	; No, load Tops-20 filename
	GTJFN				; Get its JFN
	 JRST	RECERR			; Ooops can't do this
	MOVE	R2,[ XWD 070000,300000 ] ; Read and write access
	OPENF				; Open the file
	 JRST	RECERR			; Hmmm, error
	HRRZM	R1,TMPJFN		; Save the JFN
	HRLI	R1,(R1)			; Make both halves contain the JFN
	MOVE	R2,EBLK			; Get first E block address
	ADDI	R2,1
	MOVEM	R1,(R2)			; Load it into the E block
	MOVE	R2,EBLK+1
	ADDI	R2,1
	MOVEM	R1,(R2)			; Next
	MOVE	R2,EBLK+2
	ADDI	R2,1
	MOVEM	R1,(R2)			; Load the last block
	TRZ	R1,-1			; Clear the RH
	MOVE	R2,[ XWD 400000,SPGMAP ] ; PMAP to I/O data page
	MOVSI	R3,(3B3)		; Read and write acccesses
	PMAP				; Map it
	MOVE	R1,[ POINT 7,SPGMAP*1000, ]
	MOVEM	R1,TMPPTR		; Set string pointer up
	RETURN				; Back to caller

RECERR:	HRROI	R1,[ ASCIZ /
 Can't do file recognition because: / ]
	PSOUT
	POP	P,			; Pop off return address
	CALL	JERRPR			; Type JSYS error
	HRROI	R1,$CRLF		; Start with a new line
	PSOUT
	JRST	QUESTP			; Now retype the command line so far

FINI:
	HRROI	R1,$CRLF		; Output a CR-LF to get a new line
	PSOUT
FINI2:	MOVEI	R1,CRR			; MARK END OF STRING WITH CR
	IDPB	R1,R7
	MOVEI	R1,LF			; Add on a LF
	IDPB	R1,R7
	IBP	R7			; PLACE NULL ON END
	MOVEI	R1,1(R7)		; NEXT WORD OF FREE SPACE
	HRRZM	R1,PAGPTR		; UPDATE FREE SPACE POINTER
	SKIPE	TMPJFN			; See if we need to close the temp file
	 JRST	[ SETO	R1,		; Map out a page
		  MOVE	R2,[ XWD 400000,SPGMAP ] ; Where temp file is mapped
		  PMAP			; Map it out
		  HRRZ	R1,TMPJFN	; Load the temp file JFN
		  TLO	R1,(1B0)	; Don't release the JFN
		  CLOSF			; Yes - close it
		   JFCL
		  SETZM	TMPJFN		; Zero the JFN/flag word
		  TLZ	R1,-1		; Clear the LH
		  DELF			; Delete the file
		   JFCL
		  JRST	.+1	]	; Continue on
	MOVE	R7,CMDSTR		; MAKE IT POINT TO BEGINNING OF COMMAND STRING
	TRZ	R16,-1			; Clear RH flags
	CALL	GETBIN			; GET THE BINARY FILE
	TRNN	R16,ARWBIT		; GO ON TO SOURCE IF ARROW SEEN
	CALL	GETLST			; ELSE GET THE LISTING FILE
	CALL	GETSRC			; GET A SOURCE FILE
	 JRST	GJFNER			; If error then quit now
	JRST	FINI1			; Skip over call
FINI0:	CALL	GETSRC			; Get next source file
	 JRST	GJFNER			; If error then exit now
FINI1:	TRZN	R16,ENDBIT		; At the end of the source files?
	 JRST	FINI0			; No - keep going
	TLO	R15,P1F			; Set for pass 1
	MOVE	R1,SRCTAB		; Get back first JFN
	CALL	SFINIT			; Init it and open it
	AOS	R2,SRCIDX		; Get and bump source index
	SETZM	SRCTAB-1(R2)		; Separated source and .require JFNs
	SUBI	R2,1			; Back to last JFN
	MOVEM	R2,REQBEG		;  and save it for later
	TLNE	R16,LSTBIT		; Have a listing file to open?
	 JRST	ALLWEL			; No - skip OPENF
	MOVE	R1,LSTJFN		; Yes - load JFN
	MOVE	R2,[ XWD 070000,100000 ] ; 7-bit bytes, write
	MOVEI	R3,(R1)			; Save the JFN in case OPENF fails
	OPENF				; Open the file
	 JRST	OPNERR			; Can't open file!
ALLWEL:
IFN CCLSW,<
	SKIPE	CCLFLA
	 HRROI	R1,[ASCIZ /MACN11: /]
	SKIPN CCLFLA
>;IFN CCLSW
	HRROI	R1,$CRLF
	PSOUT				; SO LET THE USER KNOW
	MOVEI	R1,400000		; GET TIME AT START OF ASSEMBLY.
	RUNTM
	MOVEM	R1,RUNTIM		; SAVE FOR STATISTICS OUTPUT.
	HRROI	R1,DATSTR		; GET DATE AND TIME,
	SETO	R2,			; SAVE FOR PAGE HEADINGS.
	SETZ	R3,
	ODTIM
>;IFN TENEX
IFE TENEX,<
	SUBTTL	EXEC -- TOPS-10 STYLE

MACN11:					; MAIN ENTRY POINT
IFN CCLSW,<
	TDZA	0,0			; NORMAL ENTRY, CLEAR CCL FLAG
	 SETOM	0			; CCL ENTRY, SET FLAG
	MOVEM	0,CCLFLA		; SAVE FLAG
>;IFN CCLSW
NULFIL:	RESET				; RESET ALL I/O
	HRRZ	R0,.JBFF
	ADDI	R0,204*NUMBUF*2+200+200	; ACCOUNT FOR POSSIBLE CCL FILES
	CORE	R0,
	 HALT	.
	MOVE	P,[IOWD PDPLEN,PDPSTK]
	MOVE	R1,[ IOWD RQSTKL,REQSTK ] ; Get .REQUIRE stack pointer
	MOVEM	R1,REQSP		;  and reset it
IFN CCLSW,<
	SKIPE	CCLFLA
	CALL	DSKNIT			; INIT DSK: FOR COMMAND FILE
	 CAIA
	  JRST	NXTCCL			; SKIP RETURN FROM DSKNIT
>;IFN CCLSW

	MOVE	R0,TITLE		; GET NAME
	CALL	LSTVER			; TYPE IT OUT TO USER
	OUTCHR	["-"]
	MOVE	R0,ASMVER		; GET VERSION NUMBER
	CALL	LSTVER
	CALL	LSTOU1			; TYPE CR-LF
	OUTCHR	["*"]
NXTCCL:
	MOVE	R0,[XWD BZCOR,BZCOR+1]
	SETZB	R1,BZCOR
	BLT	R0,EZCOR-1
	RUNTIM	R1,
	MOVEM	R1,RUNTIM
	DATE	R0,
	MOVEM	R0,DATE			; SAVE DATE
	MSTIME	R0,
	MOVEM	R0,MSTIME		;  AND TIME
	CALL	CORSET			; SET UPPER CORE
	MOVSI	R16,BINBIT!LSTBIT!CSWBIT
	SETZ	R15,			; CLEAR ASSEMBLER FLAG REGISTER
	MOVE	R1,.JBFF
	HRLI	R1,(POINT 7,)
	MOVEM	R1,CMDSTR		; SAVE COMMAND STRING POINTER
	MOVEM	R1,TTIPNT
START1:
IFN CCLSW,<
	SKIPE	CCLFLA
	CALL	GETCMD			; READ A CHARACTER FROM COMMAND FILE
	SKIPN	CCLFLA
>;IFN CCLSW
	INCHWL	R2
	IDPB	R2,R1
	CAIE	R2,LF
	 CAIN	R2,ALTMOD
	  TDZA	R2,R2
	   JRST	START1
	IDPB	R2,R1
	MOVEI	R1,1(R1)
	MOVEM	R1,.JBFF
	MOVSI	R1,(SIXBIT /DSK/)
	CALL	GETBIN			; INITIALIZE THE BINARY FILE
	MOVSI	R1,(SIXBIT /DSK/)
	TRNN	R16,ARWBIT		; GO ON TO SOURCE IF _ HAS BEEN SEEN
	CALL	GETLST			; INITIALIZE THE LISTING FILE

	MOVE	R5,TTIPNT
	MOVEM	R5,TTISAV		; SAVE TTI POINTER
	MOVSI	R1,(SIXBIT /DSK/)
	CALL	GETSRC			; INITIALIZE THE SOURCE FILE
IFN CCLSW,<
	SKIPE	CCLFLA
	OUTSTR	[ASCIZ /MACN11: /]	; ANNOUNCE YOURSELF
	SKIPN	CCLFLA
>;IFN CCLSW

	OUTSTR	[BYTE (7) CRR, LF, 0]	; CONFIRM ALL'S WELL
>;IFE TENEX
	SUBTTL	CALL ASSEMBLER AND PRINT STATISTICS

	CALL	ACEXCH			; SAVE EXEC AC'S
	CALL	ASSEMB			; CALL THE ASSEMBLER

IFN CCLSW,< SKIPN CCLFLA >
	 CALL	LSTCR			; SKIP ONE LINE
	CALL	ACEXCH			; SWAP AC'S
IFN CCLSW,<
	EXTERNAL	.JBERR
	HRRZ	R11,ERRCNT
	ADDM	R11,.JBERR		; UPDATE ERROR COUNT
	JUMPN	R11,START2		; DON'T PRINT 0 ERRORS
	SKIPE	CCLFLA			; IF CCL MODE
	 JRST EXIT
>;IFN CCLSW
START2:	PUSH	P,R16
	TRO	R16,HDRBIT		; PRINT STATISTICS ON NEW PAGE.
	CALL	LSTCR			; (THIS ALSO KEEPS TTY CLEAN).
	TLO	R16,ERRBIT		; SHOW STATS ON GRUBBY TTY TOO.
	SETZM	LSTCNT			; Insure that summaries will list.
	CALL	LSTCR			; SKIP A LINE
	MOVEI	R2,"?"			; ASSUME ERROR
	SKIPE	R11,ERRCNT		; TEST ERRORS, LOAD R11
	CALL	LSTOUT
	MOVEI	R10,[ASCIZ / Errors detected: %0/]
	CALL	LSTMCR
	CALL	LSTCR
	MOVE	R10,[POINT 7,[ASCIZ / */],]
	CALL	LSTASC
	MOVE	R10,CMDSTR
	CALL	LSTASC			; PRINT OUT COMMAND STRING
	POP	P,R0
IFN CCLSW,<
	SKIPE	CCLFLA			; SKIP REST IF CCL MODE
	 JRST	EXIT
>;IFN CCLSW
	SKIPN	R11,OPCCNT		; Any 45 only instructions?
	 JRST	START7			; None - skip type out
	MOVEI	R10,[ASCIZ \ Number of 11/45 instructions = %0\]
	CALL	LSTMCR
START7:
	SKIPN	R11,OPCCNT+1		; Any EIS instructions?
	 JRST	START8			; None
	MOVEI	R10,[ASCIZ \ Number of EIS instructions = %0\ ]
	CALL	LSTMCR			; Print it
START8:	SKIPN	R11,OPCCNT+2		; Any 40 instructions?
	 JRST	START9
	MOVEI	R10,[ASCIZ \ Number of 40/45 instructions = %0\ ]
	CALL	LSTMCR
START9:	SKIPN	R11,OPCCNT+3		; Any memory management instructions?
	 JRST	STRT10			; None
	MOVEI	R10,[ASCIZ / Number of memory management instructions = %0/]
	CALL	LSTMCR			; Print it
STRT10:	SKIPN	R11,OPCCNT+4		; Any 45 floating instructions?
	 JRST	STRT11			; None
	MOVEI	R10,[ASCIZ / Number of 45 floating point instructions = %0/ ]
	CALL	LSTMCR
STRT11:	SKIPN	R11,OPCCNT+5		; Any 40 floating instructions?
	 JRST	STRT12
	MOVEI	R10,[ASCIZ \ Number of 35/40 floating point instructions = %0\ ]
	CALL	LSTMCR
STRT12:	SKIPN	R11,OPCCNT+6		; Any LSI-11 instructions?
	 JRST	STRT13
	MOVEI	R10,[ASCIZ / Number of LSI-11 instructions = %0/]
	CALL	LSTMCR
STRT13:
IFE TENEX,<
	SETZ	R11,
	RUNTIM	R11,			; GET RUNTIM
	SUB	R11,RUNTIM		; DEDUCT STARTING TIME
	IDIVI	R11,^D1000		; CONVERT TO SECONDS
>;IFE TENEX
IFN TENEX,<
	MOVEI	R1,(1B0)		; Get CPU time used by this process
	RUNTM
	SUB	R1,RUNTIM		; Now get difference
	MOVE	R11,R1			; Load it into right register
	IDIV	R11,R2			; Convert to seconds
>;IFN TENEX
	MOVEI	R10,[ASCIZ / Run-time:  %0 seconds/]
	CALL	LSTMCR
IFE TENEX,<
	HRRZ	R11,.JBREL		; GET TOP OF COR
	ASH	R11,-^D10		; CONVERT TO "K"
	ADDI	R11,1			; BE HONEST ABOUT IT
	MOVEI	R10,[ASCIZ / Core used:  %0K/]
	CALL	LSTMCR			; LIST MESSAGE
>;IFE TENEX
	CALL	LSTCR
	JRST	EXIT			; CLOSE OUT


LSTVER:	MOVSI	R6,(POINT 6,R0,)
	ILDB	R1,R6
	JUMPE	R1,CPOPJ		; RETURN ON NULL BYTE
	ADDI	R1,40			; CONVERT TO 7-BIT ASCII
IFE TENEX,< OUTCHR R1 >
IFN TENEX,< PBOUT >
	TLNE	R6,770000
	 JRST	LSTVER+1
	RETURN
IFN TENEX,<
	SUBTTL	File Initialization -- Tenex style

; Initialize a binary file.
; Gets the binary file name (if any) and stores it for later when it
; will be opened.

GETBIN:
	TRZ	R16,CKLBIT		; Not looking for a listing file
	TRO	R16,CKBBIT		; but a binary file.
	CALL	GETFIL			; Get a file name
	RETURN				; Just return if none
	MOVEM	R14,BINFIL		; Save the file name pointer
	TLZ	R16,BINBIT		; Indicate a good file
	RETURN				; and return

; Now we can open the file (end of pass 1).

SETBIN:
	TLNE	R16,BINBIT		; Do we have a binary file to open?
	RETURN				; Nope, return then
	CALL	ACEXCH			; Get EXEC's ACs
	MOVEI	R1,BINBLK		; Address of GTJFN look-up block
	MOVE	R2,[ XWD 377777,377777 ] ; No input or output JFN
	MOVEM	R2,1(R1)		; Place it in block
	MOVEI	R2,[ ASCIZ /OBJ/ ]	; First assume reloc mode
	TLNE	R15,ABSFLG		; Is it ABS?
	MOVEI	R2,[ ASCIZ /BIN/ ]	; Yup, put right default ext. in
	HRROM	R2,5(R1)		; and store it in block
	MOVE	R2,BINFIL		; Finally get file string pointer
	MOVE	R14,R2			; Save the string pointer
	GTJFN				; Now try to get JFN
	 JRST	GJFNER			; Well better luck next time
	HRRZM	R1,BINJFN		; Save the JFN
	MOVE	R2,[ XWD 440000,100000 ] ; 36-bit bytes
	MOVEI	R3,(R1)			; Save the JFN in case of failure
	OPENF				; Now open the file
	 JRST	OPNERR			; Hmmm, strange can't open
	JRST	ACEXCH			; Swap AC's and return
; Initialize the listing file.

GETLST:
	TRZ	R16,CKBBIT		; Make sure not binary file
	TRO	R16,CKLBIT		; but listing file
	CALL	GETFIL			; See if we can get file name
	 JRST	[ TLNE	R16,CSWBIT	; /CRF typed?
		   RETURN		; No - just return now
		  HRROI	R14,[ ASCIZ /CREF.CRF/ ]
		  JRST	.+1 ]		; Load string pointer and continue
	MOVEI	R1,LSTBLK		; Get address of look-up block
	MOVE	R2,[ XWD 377777,377777 ] ; No input and output JFN
	MOVEM	R2,1(R1)		; Place it in block
	SETZM	4(R1)			; Zero out name default field
	MOVEI	R2,[ ASCIZ /LST/ ] 	; Assume its a .LST file
	TLNN	R16,CSWBIT		; Cref?
	 MOVEI	R2,[ ASCIZ /CRF/ ]	; Yes - use .CRF as the extension
	HRROM	R2,5(R1)		; Load it
	MOVE	R2,R14			; Load string pointer
	GTJFN				; Get the JFN
	 JRST	GJFNER			; Ooops, can't get JFN
	HRRZM	R1,LSTJFN		; Save it
	TLZ	R16,LSTBIT		; Ok, now we got a listing file
	MOVE	R1,LSTPT1		; Get original output line pointer
	MOVEM	R1,LINPTR		; Set it
	MOVEI	R1,LSTBFL		; full count		[ECL2]
	MOVEM	R1,LSTBFC		; set count		[ECL2]
	GJINF				; Get job info (controlling terminal #)
	MOVE	R1,LSTJFN		; Now get listing JFN
	DVCHR				; Get device characteristics
	HLRZ	R2,R1			; Get device designator
	ANDI	R2,777			; Mask off device bits to get type #
	CAIE	R2,12			; Terminal?
	 JRST	LPTINI			; No - skip this
	CAIN	R4,(R1)			; Units numbers match?
	 TLO	R16,TTYBIT		; Yes - set TTY bit
	JRST	LPTINI			; Exit and set a few words on the way out
; Initilize a source file.
; Will try .M11, .P11, .MAC and null extensions in order to complete
; the filemane.
;
; Returns:
;	R1	JFN of the source file
;	R2	Index+1 into SRCTAB

GETSRC:
	TRZ	R16,CKBBIT!CKLBIT	; Now looking for source files
	CALL	GETFIL			; Get a file name
	 JRST	ERRSE			; Gotta have one, else error
TRYJFN:
	MOVE	R2,[ XWD 377777,377777 ] ; Input and output jfns are null
	MOVEM	R2,SRCBLK+1		; Save it in block
	MOVSI	R3,-NSEXTS		; TRY ALL STANDARD EXTENSIONS
GETSRL:	HRROI	R2,SEXTS(R3)		; GET EXTENSION STRING
	MOVEM	R2,SRCBLK+5
GETSRN:	MOVEI	R1,SRCBLK
	MOVE	R2,R14
	GTJFN				; Lets see if we can get a JFN
	 JRST	SRCNFD			; NOT THAT ONE
	PUSH	P,R1			; Save the JFN
	DVCHR				; Get device characteristics
	HLRZ	R2,R2			; Get LH
	ANDI	R2,777			; Leave only device type
	CAIE	R2,12			; Terminal?
	 JRST	SCLUK			; No - put JFN in source table
	PUSH	P,R3			; Yes - save unit number
	GJINF				; Now get job info
	POP	P,R3			; Restore unit number of the file
	CAIE	R4,(R3)			; Is it the controlling terminal?
	 JRST	[ HRROI	R1,[ ASCIZ / Only controlling terminal is allowed for terminal input.
/ ]
		  PSOUT			; Output error message
		  JRST	NULFIL	]	; Start over

SCLUK:	POP	P,R1			; Restore JFN
	AOS	R2,SRCIDX		; Get and increment index
	CAILE	R2,MAXJFN+1		; Did we go past the max. limit?
	 JRST	TABFUL			; Yes, no more room
	HRRZM	R1,SRCTAB-1(R2)		; Save it in the source JFN table
	JRST	CPOPJ1			; Return +2

SRCNFD:	AOBJN	R3,GETSRL		; LOOP THRU ALL EXTS
	SETZ	R2,
	EXCH	R2,SRCBLK+5		; TRIED NO DEFAULT YET?
	JUMPN	R2,GETSRN		; NO, TRY IT
	RETURN				; Take error return

SETP2:
	CALL	ACEXCH			; Get EXEC's ACs
	TRZ	R16,ENDBIT!FFBIT	; Clear a couple of bits
	SETZM	SJFNIX			; Clear index too
	MOVE	R1,SRCTAB		; Get first file JFN
	CALL	SFINIT			; Init the first file
	JRST	ACEXCH			; Exit thru AC exchange


; SFINIT - Initializes a source file.
;	Also the source filename string is generated.
;
; Accepts:
;	R1	JFN of a source file
;
; Returns:	+1	Error number in R1
;		+2	Success

SFINIT:					; Routine to set byte and page count
	HRRZM	R1,SRCJFN		; Save current JFN
	PUSH	P,R2			; Save registers
	PUSH	P,R3
	PUSH	P,R4

; Create new source file string name

	MOVEI	R2,(R1)			; Load JFN in R2
	HRROI	R1,SFILNM		; Address to place string
	SETZ	R3,			; Output format is defaulted
	JFNS				; Convert to a string

; Now get device type of this file

	MOVEI	R1,(R2)			; Load back the JFN in R1
	DVCHR				; Get device characteristics
	HLRZ	R2,R1			; Get its LH
	HRRZ	R1,SRCJFN		; Get back JFN
	MOVEI	R3,(R1)			; Save JFN in a safe register
	ANDI	R2,777			; Mask off device bits
	MOVEM	R2,SRCFLG		; Let device type be the flag
	JUMPN	R2,SFINS		; Can't PMAP so use SIN
	TLNN	R15,P1F			; Pass 1?
	 JRST	SFIN2			; No - it's already open
	MOVE	R2,[ XWD 440000,200000 ]
	OPENF				; Open the file
	 JRST	OPNERR			; Error
SFIN2:	MOVE	R2,[ XWD 1,7 ]		; Get version number
	MOVEI	R3,SRCVER		; Address to place it
	GTFDB				; Get version number
	MOVEI	R3,BSIZE		; Destination of the info
	MOVE	R2,[ XWD 2,11 ]		; Get byte size and count and page count
	GTFDB				;  from the FDB
	LDB	R2,[ POINT 6,BSIZE,11 ]	; Get byte size
	MOVE	R3,BCOUNT		; Get byte count
	CAIN	R2,^D36			; Already number of words?
	 JRST	SFIN1			; Yes
	CAIE	R2,7			; Must be either 7 or 36 bit bytes
	 JRST	SFBAD1			; Neither - can't use it
	IDIVI	R3,5			; Convert byte count to word count
	CAIE	R4,			; Round-up
	 AOJ	R3,
SFIN1:	LSH	R3,-^D9			; Convert word count to page count
	AOJ	R3,			; But page numbers start at 0
	HRRM	R3,BSIZE		; Save page count
	SOJ	R3,			; Get number of full pages
	MOVE	R4,BCOUNT		; Get back byte count
	CAIE	R2,7			; 7-bit bytes?
	IMULI	R4,5			; No - convert
	MOVE	R2,R4			; Copy it
	IMULI	R3,^D512*5		; Get number of bytes used in these pages
	SUB	R2,R3			; Get number of bytes left in last page
	MOVEM	R2,BCOUNT		; Save it
	HRLZM	R1,SRCPGN		; Set source JFN and page 0
	MOVSI	R1,(R1)			; JFN,,file page 0
	HRLOM	R1,INPGNM		; SET INPGNM TO 0,,-1
	MOVE	R2,[ XWD 400000,SPGMAP ]
	MOVSI	R3,160000		; All accesses
	PMAP				; Map first page in
	HRRZ	R2,BSIZE		; Get page count
	MOVEI	R3,^D512*5		; Assume file has more than 1 page
	CAIG	R2,1			; Is the first page the last?
	MOVE	R3,BCOUNT		; Yes - set this count
	MOVEM	R3,SRCCNT		; Set byte count
	MOVE	R3,[ POINT 7,SPGMAP*^D512, ]
	MOVEM	R3,SRCPNT		; Set new byte pointer
	MOVSI	R4,DEFSYM		; Define it
	HLR	R4,SRCVER		; Load file version number
SETVEC:	PUSH	P,R0			; Save a register
	MOVE	R0,[ GENM40 .,V,R,S,N,. ]
	CALL	SSRCH			; Find it in the symbol table
	 JFCL				; Forget can't find return
	MOVE	R1,R4			; Get value
	TLO	R1,HFKSYM		; Make .VRSN. half killed
	CALL	INSRT			;  and insert it
	POP	P,R0
	POP	P,R4			; Restore registers
	POP	P,R3
	POP	P,R2
	RETURN				; Back to caller


SFINS:					; Set up the file for SIN
	CAIN	R2,12			; Input from terminal?
	 JRST	[ TLNE	R15,P1F		; Pass 1 or 2 ?
		   JRST	SFINS2		; 1 - no message
		  HRROI	R1,[ ASCIZ /[Pass 2]
/ ]
		  PSOUT			; Tell user we are waiting for pass 2
		  JRST	SFINS2	]	; Continue
	MOVE	R2,[ XWD 440000,200000 ]
	OPENF				; Open the file again
	 JRST	OPNERR			; Impossible!!
SFINS2:	SETO	R1,			; Map out a page
	MOVE	R2,[ XWD 400000,SPGMAP ]
	SETZ	R3,
	PMAP				; Just in case left over mapping
	SETZB	R4,SRCCNT		; Zero byte count and made .VRSN.
					;  undefined
	JRST	SETVEC			; Set version and exit

; If a file doesn't have have either 7 or 36 bit bytes then we can't
;  use it for input.

SFBAD1:	HRROI	R1,SFILNM		; Get source file name
	PSOUT
	HRROI	R1,[ ASCIZ / doesn't have 7 or 36 bit bytes.
/ ]
	PSOUT
	JRST	NULFIL			; Start all over
>;IFN TENEX

IFE TENEX,<
	SUBTTL	FILE INITIALIZATION -- TOPS-10 STYLE

;INITIALIZE A BINARY FILE
;COLLECTS A DEVICE NAME IN AC R1, A FILE NAME IN XE, AND
;AN OPTIONAL FILE NAME EXTENSION, THE DEVICE IS INITIALIZED IN
;BINARY MODE ON CHANNEL ONE, WITH EITHER ONE OR TWO BUFFERS.

GETBIN:
	TRZ	R16,CKLBIT		; MAKE SURE NOT CHECKING FOR LISTING FILE
	TRO	R16,CKBBIT		; TRYING FOR BINARY FILE
	CALL	GETFIL			; GET A DEVICE NAME AND FILE NAME
	RETURN				; NULL FILE EXIT
	MOVE	R0,R1			; GET AN EXTRA COPY OF THE DEVICE
	DEVCHR	R0,			; TEST ITS CHARACTERISTICS
	TLNE	R0,TTYDEV!PTRDEV!LPTDEV!CDRDEV
	JRST	ERRTB			; ILLEGAL FOR BINARY
	MOVE	R0,[INIT BIN,10]	; INIT IMAGE MODE
	MOVSI	R2,BINBUF		; GET BUFFER HEADER ADDRESS
	CALL	INISET			; INITIALIZE THE BINARY DEVICE
	OUTBUF	BIN,NUMBUF
	MOVE	R3,XE
	MOVEM	R3,BINNAM		; SAVE BINARY NAME
	TRZE	R16,EXTBIT		; WAS THERE AN EXTENSION
	HLLOM	R14,BINNAM+1		;  YES, SAVE IT
	TLZ	R16,BINBIT		; INDICATE GOOD BINARY FILE
	RETURN				; EXIT

SETBIN:					; SET BIN (END OF PASS 1)
	TLNE	R16,BINBIT		; ANY BINARY?
	RETURN				;  NO, EXIT
	CALL	ACEXCH			; YES, GET EXEC AC'S
	MOVE	R3,BINNAM
	MOVEM	R3,XE			; SET UP BINARY NAME
	MOVSI	R3,(SIXBIT /OBJ/)
	TLNE	R15,ABSFLG		; ABS MODE?
	MOVSI	R3,(SIXBIT /BIN/)	;  YES
	SKIPE	BINNAM+1		; WAS THERE AN EXPLICIT EXTENSION?
	MOVE	R3,BINNAM+1		;  YES, FORGET THE ABOVE
	HLLZM	R3,XE1			; SET IN LOOKUP BLOCK
	SETZM	XE2			; ZERO REMAINDER
	SETZM	XE3
	ENTER	BIN,XE			; ENTER FILE NAME IN DIRECTORY
	 JRST	ERRNR			; DIRECTORY FULL
	JRST	ACEXCH			; TOGGLE AC'S AND EXIT

;INITIALIZE A LISTING FILE
;COLLECTS A DEVICE NAME IN AC R1, A FILE NAME IN XE AND
;AN OPTIONAL FILENAME EXTENSION, THE DEVICE IS INITIALIZED IN
;ASCII LINE MODE ON CHANNEL 2, IF THE DEVICE IS A TTY, THE
;TTYLST FLAG IS SET TO 1, AND THE INBUF/OUTBUF INDEX IS INCREMENTED.

GETLST:
	TRZ	R16,CKBBIT		; CLEAR CHECK FOR BINARY FILE
	TRO	R16,CKLBIT		; LOOK FOR LISTING FILE
	SETZM	XE
	CALL	GETFIL			; GET A DEVICE AND FILE NAME
	 TLNN	R16,CSWBIT
	  CAIA
	   RETURN
	TLNE	R16,CSWBIT
	 JRST	GETLS2			; NORMAL
	MOVE	R3,[SIXBIT /CREF/]
	SKIPN	XE			; EXPLICIT CREF NAME?
	 MOVEM	R3,XE			;  NO, GIVE IT DEFAULT
	TRON	R16,EXTBIT		; EXPLICIT EXTENSION?
	 MOVSI	R14,(SIXBIT /CRF/)	;  NO, SUPPLY ONE
GETLS2:	MOVE	R0,[INIT LST,1]
	MOVSI	R2,LSTBUF		; GET BUFFER HEADER ADDRESS
	CALL	INISET			; INITIALIZE LISTING FILE
	MOVE	R0,R1
	DEVCHR	R0,			; GET DEVICE CHARACTERISTICS
	TLNE	R0,TTYDEV		; IS IT A TTY?
	 TLO	R16,TTYBIT		; SET FLAG
	  OUTBUF	LST,NUMBUF
	TRZN	R16,EXTBIT		; WAS THERE AN EXTENSION?
	 MOVSI	R14,(SIXBIT /LST/)	; NO
	HLLZM	R14,XE1			; SAVE EXTENSION IN LOOKUP BLOCK
	ENTER	LST,XE			; ENTER FILE NAME IN DIR.
	 JRST	ERRNR			; DIRECTORY FULL
	TLZ	R16,LSTBIT		; INDICATE A GOOD LISTING FILE
	JRST	LPTINI			; INIT LINE OUTPUT AND EXIT

;INITIALIZE A SOURCE FILE
;COLLECTS A DEVICE NAME IN AC R1, A FILE NAME IN XE AND
;AN OPTIONAL FILE NAME EXTENSION. THE DEVICE IS INITIALIZED
;IN ASCII LINE MODE ON CHANNEL 3, AND THE FILE NAME ASSOCIATED
;WITH THE SOURCE FILE IS USED AS THE TITLE ON THE LISTING.

GETSRC:
	TRZ	R16,CKBBIT!CKLBIT	; CLEAR BITS = LOOKING FOR SOURCE
	SETZM	XE
	CALL	GETFIL			; GET A DEVICE NAME AND FILE NAME
	JRST	ERRSE			; COMMAND ERROR IF A NULL
	MOVEM	R1,SRCDEV		; Save device name
	SETZM	CHRCNT			; Zero the character counter for .REQUIRE
GETSR1:
	MOVE	R0,[INIT SRC,1]
	MOVEI	R2,SRCBUF		; GET BUFFER HEADER ADDRESS
	CALL	INISET			; INITIALIZE THE SOURCE DEVICE
	MOVEI	R5,JOBFFS
	EXCH	R5,.JBFF		; SET TO TOP OF INPUT BUFFER
	INBUF	SRC,NUMBUF
	MOVEM	R5,.JBFF		; RESTORE .JBFF
	MOVE	R5,XE3			; LOSING LOOKUP CLOBBERS XE3
	TRZE	R16,EXTBIT		; WAS AN EXPLICIT EXTENSION SEEN?
	JRST	SRC3A+1			; YES, LOOK FOR IT
	MOVSI	R14,(SIXBIT /M11/)
	HLLZM	R14,XE1			; NO, TRY .M11 FIRST
	LOOKUP	SRC,XE
	 CAIA
	  JRST	GOTSRC

	MOVSI	R14,(SIXBIT /P11/)	; TRY P11 SECOND
	HLLZM	R14,XE1
	LOOKUP	SRC,XE
	 CAIA
	  JRST	GOTSRC

	MOVSI	R14,(SIXBIT /MAC/)	; TRY MAC 3RD
	HLLZM	R14,XE1
	LOOKUP	SRC,XE
	 TDZA	R14,R14			; NOT FOUND, TRY BLANK
	  JRST	GOTSRC
SRC3A:	HLLZM	R14,XE1			; SAVE EXTENSION IN LOOKUP BLOCK
	LOOKUP	SRC,XE			; LOOKUP FILE NAME
	 JRST	ERRCF			; FILE NOT FOUND
GOTSRC:	MOVEM	R5,XE3			; Restore the PPN which LOOKUP clobbered
	HRLOM	R14,INPGNM		; SET INPGNM TO 0,,-1
	RETURN				; EXIT


SETP2:					; SET FOR PASS 2
	CALL	ACEXCH			; GET EXEC AC'S
	TRZ	R16,ENDBIT!FFBIT
	MOVE	R5,TTISAV
	MOVEM	R5,TTIPNT		; RESTORE INPUT COMMANDS
	MOVSI	R1,(SIXBIT /DSK/)
	CALL	GETSRC			; GET A SOURCE FILE
	JRST	ACEXCH			; SWAP AC'S AND EXIT
>;IFE TENEX

IFN TENEX,<
	SUBTTL	COMMAND STRING DECODER

; This routine will process a file specification field.
;  It will pick-up the next filename and place the string pointer
;  in R14. Also it will process switches which are asscoiated with
;  the file.
; Returns +1 if there is no file.
; Otherwise it will return +2 with the pointer in R14. And appropriate
;  flags set for the terminating character that was seen.

GETFIL:
	TRZ	R16,SWTWRD		; Look for file name not a switch
	CALL	GETWRD			; Now get the file name
	JRST	[ TRNN	R16,SWTBIT	; Null file, any switches?
		  RETURN		; Nope, return +1
		  JRST	SWTPRC ]	; Else, return thru switch process
	TRNN	R16,SWTBIT		; Good file, but any switches?
	 JRST	CPOPJ1			; Nope, return +2
	PUSH	P,R14			; Better save string pointer
	CALL	SWTPRC			;  before processing switch(es)
	POP	P,R14			; Restore file name pointer
	JRST	CPOPJ1			;  and return +2

; Exec command string dispatching.
;  This routine will pick up the next word in the EXEC tty buffer.
;  It will be stored as a string or as a sixbit symbol depending on the
;  flag SWTWRD in R16. If SWTWRD is set then it will be storing the characters
;  in R14 in sixbit and will terminate as specified in byte table and with
;  the LEFT half-word of the character dispatch table.
;  While for strings it will store the characters in a free area as pointed
;  by PAGPTR. It will use the RIGHT half-word of the dispatch table.
;  In both cases it will return +1 if the next word is null and +2
;  if not with the appropriate flags set.

GETWRD:
	TRZ	R16,SWTBIT!COLBIT!COMBIT
	SETZ	R14,			; Clear output register
	MOVSI	R6,(POINT 7,)		; Assume string
	HRR	R6,PAGPTR		; Now we have complete pointer
	TRNE	R16,SWTWRD		; String or symbol?
	MOVE	R6,[ POINT 6,R14 ]	; Symbol, so need pointer

GETTTI:
	ILDB	R5,R7			; Get next character from buffer
	CAIL	R5,141			; IS CHAR BETWEEN LOWER CASE A
	 CAILE	R5,172			; AND LOWER CASE Z?
	  CAIA				;  No, don't fold
	   SUBI	R5,40			;  Yes, fold 
	MOVE	R10,R5			; Save a copy in R10
	IDIVI	R10,^D8			; Translate to 4-bit code
	ADD	R10,[ POINT 4,BITE, ]	; Create the byte pointer
	IBP	R10			;  and move to proper byte
	SOJGE	R11, .-1		; Test for end
	LDB	R10,R10			; Now we can get the byte
	CAIN	R10,4			; Is it a null?
	JRST	GETTTI			; Yes, get another byte then
	MOVE	R1,DSPTCH(R10)		; Get dispatch addresses
	TRNN	R16,SWTWRD		; String or symbol? 
	JRST	(R1)			; String so use right half
	HLRZ	R1,R1			; Symbol so get left half into right
	JRST	(R1)			;  and goto the correct routine

; Command dispatch table for characters.

DSPTCH:
	XWD	ILCHAR,ILCHAR		; Illegal character
	XWD	STORE,STORE		; Alpha-numeric
	XWD	COLON,COLONT		; Terminator if switch mode, else assume new device
	XWD	STORE,STORE		; Stop if in switch mode, otherwise ok
	XWD	ILCHAR,ILCHAR		; Impossible to get this!
	XWD	LFTARW,LFTARW		; "_", "=", or "left angle bracket"
	XWD	COMMA,COMMA		; ","
	XWD	CARRTN,CARRTN		; "CR"
	XWD	SLASH,SLASH		; "/"
>;IFN TENEX
IFE TENEX,<
	SUBTTL	COMMAND STRING DECODER

; This routine will process a file specification field.
;  It will store the device name in R0 and the file name in XE.
;  Also, it will process the switches that are associated with
;  the file.
;  It returns +1 if no file was given. Otherwise +2.

GETFIL:
	TRZ	R16,DEVBIT		; No device yet
	CALL	GETWRD			; Get a word
	 JRST	CHKNUL			; Check for switches and device name
GTFIL1:	TRNE	R16,COLBIT		; New device?
	JRST	[ TRCE	R16,DEVBIT	; Set flag so it won't go here twice
		   JRST	ERRSE		; Too many devices
		  MOVE	R1,R14		; Set new device
		  JRST	GETFIL+1  ]
	MOVEM	R14,XE			; Save filename
	TRNN	R16,DOTBIT		; Any extensions?
	JRST	GTFIL2			; Nope- continue
	TRO	R16,EXTBIT		; Set extension flag
	CALL	GETWRD			; Yes, get it
	JFCL				; Null is ok
	MOVEM	R14,XE1			; Save it

GTFIL2:	TRNE	R16,BRKBIT		; Process a PPN?
	 CALL	PPNPRC			; Yes - do it
	  CAIA				; Null is expected here
	   JRST	ERRSE			; No more words here
	TRNN	R16,SWTBIT		; Any switches?
	 JRST	GTFIL9
	PUSH	P,R14
	CALL	SWTPRC			; Yes - process them
	POP	P,R14
GTFIL9:	TRNN	R16,COMBIT!ARWBIT	; Better end with comma or arrow
	 JRST	ERRSE			; None, syntax error
	JRST	CPOPJ1			; Yup thats all

CHKNUL:
	TRNE	R16,COLBIT!DOTBIT	; Ended with colon or period?
	 JRST	ERRSE			; Yes, error
	TRNE	R16,BRKBIT		; A PPN to do?
	 JRST	[ CALL PPNPRC		; First process PPN
		   JRST	CHKNUL		; If next word is null then check it out
		  JRST	GTFIL1	]	; If not then it must be a filename
	TRNN	R16,SWTBIT		; Any switches to process?
	 JRST	[ TRNE	R16,DEVBIT	; No, was device given?
		   JRST	CPOPJ1		; Yes, return +2 then
		  RETURN  ]		; Else return +1
	TRNN	R16,CKBBIT!CKLBIT!DEVBIT ; Can't be source or can be new device
	 JRST	ERRSE			; Error if it is
	CALL	SWTPRC			; Process the switch(es)
	TRNN	R16,DEVBIT		; New device given
	 RETURN				; No, just return
	JRST	CPOPJ1			; Else, return +2

;EXEC COMMAND STRING DISPATCHING
; THIS ROUTINE WILL PICK UP THE NEXT WORD IN THE EXEC TTY BUFFER
;  AND PUT ITS SIXBIT VALUE IN R14. A WORD IS TERMINATED BY DELIMITERS
;  AS SPECIFIED IN THE BYTE TABLE.
;  IF THE NEXT WORD IS NULL THEN IT WILL RETURN +1, WITH THE APPROPRIATE
;  DELIMITER FLAG SET.  OTHERWISE IT WILL RETURN +2. IF IT DETECTS A
;  LINE TERMINATOR SUCH AS A CARRIAGE RETURN THEN IT WILL JUMP TO THE
;  STARTING ADDRESS. WORDS THAT ARE MORE THAN SIX CHARACTERS LONG WILL
;  BE TRUNCATED TO SIX.


GETWRD:
	TRZ	R16,SWTBIT!COLBIT!DOTBIT!COMBIT!BRKBIT
	SETZ	R14,			; CLEAR SYMBOL WORD
	MOVE	R6,[POINT 6,R14]


GETCMN:	CALL	GETTTI			; GET NEXT CHARACTER
	JRST	@DSPTCH(R10)		; GO TO CORRECT ROUTINE

GETTTI:	ILDB	R5,TTIPNT		; GET A CHARACTER FROM TTY BUFFER
;  IF THE CHARACTER IS LOWER CASE, FOLD TO UPPER CASE.
	CAIL	R5,141			; IS CHAR BETWEEN LOWER CASE A
	 CAILE	R5,172			; AND LOWER CASE Z?
	  CAIA				;  No, don't fold
	   SUBI	R5,40			;  Yes, fold
	MOVE	R10,R5			; COPY THE BYTE TO AC R10
	IDIVI	R10,8			; TRANSLATE TO 4-BIT CODE
	ADD	R10,[POINT 4,BITE,]	; SET BYTE POINTER
	IBP	R10			; MOVE TO PROPER BYTE
	SOJGE	R11,.-1			; TEST FOR END
	LDB	R10,R10			; OK, FETCH BYTE
	CAIN	R10,4			; IS IT A NULL?
	JRST	GETTTI			; YES, TRY AGAIN
	RETURN				; NO, EXIT

;COMMAND DISPATCH TABLE AND BYTE POINTERS
DSPTCH:
	XWD	0,ERRIC			; ILLEGAL CHARACTER
	XWD	0,STORE			; ALPHA-NUMERIC
	XWD	0,COLON			; <:>
	XWD	0,PERIOD		; <.>
	XWD	0,ERRIC			; SHOULD NEVER GET THIS
	XWD	0,LFTARW		; <_>, "left angle brk", OR <=>
	XWD	0,COMMA			; <,>
	XWD	0,CARRTN		; <CR>
	XWD	0,SLASH			; </>
	XWD	0,BRACKT		; "[" OR "]"
IFN CCLSW,<
	XWD	0,RUNUUO		; <!>
	XWD	0,INDFIL		; <@>
>;IFN CCLSW
IFE CCLSW,<
	XWD	0,ERRIC
	XWD	0,ERRIC
>;IFE CCLSW

>;IFE TENEX

;BYTE TABLE FOR DISPATCHING
;CLASSIFICATION BYTE CODES


;	BYTE		CLASSIFICATION
;	----		--------------


;	00		ILLEGAL CHARACTER
;	01		ALPHA-NUMERIC CHARACTER
;	02		DEVICE DELIMITER, ":"
;	03		FILE EXTENSION DELIMITER, "."
;	04		IGNORED CHARACTER
;	05		OUTPUT SPEC. DELIMITER, "_", "<", OR "="
;	06		FILE DELIMITER, ","
;	07		COMMAND TERMINATOR, <CR>
;	10		ENTER SWITCH MODE, "/"

IFN TENEX,<
; Byte table for Tenex systems:

BITE:
	BYTE	(4)	 4,  ,  ,  ,  ,  , 1,
	BYTE	(4)	  , 4, 7, 4, 4, 7,  ,
	BYTE	(4)	  ,  ,  ,  ,  ,  , 1,
	BYTE	(4)	  ,  , 7, 7,  ,  ,  ,

	BYTE	(4)	 4, 1, 4, 1, 1, 1, 1, 1
	BYTE	(4)	 1, 1,  , 1, 6, 1, 3,10
	BYTE	(4)	 1, 1, 1, 1, 1, 1, 1, 1
	BYTE	(4)	 1, 1, 2, 1, 5, 5, 1,    

	BYTE	(4)	 1, 1, 1, 1, 1, 1, 1, 1
	BYTE	(4)	 1, 1, 1, 1, 1, 1, 1, 1
	BYTE	(4)	 1, 1, 1, 1, 1, 1, 1, 1
	BYTE	(4)	 1, 1, 1, 1,  , 1,  , 5

	BYTE	(4)	  ,  ,  ,  ,  ,  ,  ,
	BYTE	(4)	  ,  ,  ,  ,  ,  ,  ,
	BYTE	(4)	  ,  ,  ,  ,  ,  ,  ,
	BYTE	(4)	  ,  ,  ,  ,  , 7,  , 4
>;IFN TENEX

IFE TENEX,<
;BYTE TABLE FOR 10/50 SYSTEMS:

;	BYTE		CLASSIFICATION
;	----		--------------

;	11		PPN DELIMITER "[" OR "]"
;
;	12		CCL FILE DELIMITER, "!"
;	13		INDIRECT FILE DELIMITER, "@"


BITE:
	BYTE	(4)	 4,  ,  ,  ,  ,  ,  ,
	BYTE	(4)	  , 4, 7, 4, 4, 7,  ,
	BYTE	(4)	  ,  ,  ,  ,  ,  ,  ,
	BYTE	(4)	  ,  , 7, 7,  ,  ,  ,

	BYTE	(4)	 4,12, 4,  ,  ,  ,  ,
	BYTE	(4)	 1, 1,  ,  , 6,  , 3,10
	BYTE	(4)	 1, 1, 1, 1, 1, 1, 1, 1
	BYTE	(4)	 1, 1, 2,  , 5, 5,  ,

	BYTE	(4)	13, 1, 1, 1, 1, 1, 1, 1
	BYTE	(4)	 1, 1, 1, 1, 1, 1, 1, 1
	BYTE	(4)	 1, 1, 1, 1, 1, 1, 1, 1
	BYTE	(4)	 1, 1, 1,11,  ,11,  , 5

	BYTE	(4)	  ,  ,  ,  ,  ,  ,  ,
	BYTE	(4)	  ,  ,  ,  ,  ,  ,  ,
	BYTE	(4)	  ,  ,  ,  ,  ,  ,  ,
	BYTE	(4)	  ,  ,  ,  ,  , 7,  , 4
>;IFE TENEX



IFN TENEX,<
; Left arrow processor


LFTARW:
	TRNN	R16,INFBIT		; Any chars already?
	JRST	[ CAIN	R5,74		; Left angle brkt for delimiter?
		  JRST	STORE		; Yes - store it
		  JRST	.+1 ]		; No, break here
	TRO	R16,ARWBIT		; Else, set flag

INFTST:	TRZN	R16,INFBIT		; Any chars?
	 TRNE	R16,COLBIT		;  and no colon?
	  TRNA				; No - have some information
	   RETURN			; Yes - null file name
	TRNE	R16,SWTWRD		; String?
	JRST	CPOPJ1			; No, just return
	IBP	R6			; Move past a null (place a null byte)
	MOVEI	R5,1(R6)		; New free pointer
	MOVSI	R14,(POINT 7,)		; Re-create string pointer
	HRR	R14,PAGPTR		;  for return
	MOVEM	R5,PAGPTR		; Save new pointer
	JRST	CPOPJ1			; Return + 2

; Colon processing for strings - device terminator

COLONT:	TRZ	R16,INFBIT		; Start of a new field
	TRO	R16,COLBIT		; Flag that we have ":"
	JRST	STRGST			;  and put character away

>;IFN TENEX

IFE TENEX,<
;LEFT ARROW PROCESSOR

LFTARW:
	TRO	R16,ARWBIT		; SET APPROPIATE FLAGS
INFTST:	TRZE	R16,INFBIT		; IS THIS A NULL FILE?
	 JRST	CPOPJ1			; Return + 2
	RETURN				; Return + 1

;PERIOD PROCESSOR

PERIOD:	TRO	R16,DOTBIT		; SET FLAG FOR PERIOD SEEN
	JRST	INFTST			; TEST FOR NULL WORD AND EXIT

BRACKT:
	TRO	R16,BRKBIT		; SET BRACKET BIT
	JRST	INFTST			; EXIT

>;IFE TENEX
;COLON PROCESSOR

COLON:
	TRO	R16,COLBIT		; SET COLON FLAG
	JRST	INFTST			; CHECK FOR NULL WORD AND EXIT


;CARRIAGE RETURN PROCESSOR

CARRTN:	TRNN	R16,NULBIT		; IS THIS JUST A RANDOM CR?
	JRST	NULFIL			; YES, RESTART COMPLETELY
	TRO	R16,ENDBIT		; Set end of line bit
IFE TENEX,<
	TRNN	R16,ARWBIT		; Has left arrow been seen?
	 JRST	ERRSE			;  No - syntax error
>;IFE TENEX
IFN TENEX,<
	TRNE	R16,ARWBIT		; YES, HAS A LEFT ARROW BEEN SEEN?
	JRST	COMMA			; Yes - treat as a comma

; If the user typed filename!<cr> then we will try to run that file.
; Currently default directory is <SUBSYS>

	LDB	R5,R6			; Get last character
	CAIN	R5,"!"			; Right termiantor?
	TRNN	R16,CKBBIT		;  and in right field?
	  JRST	ERRSE			; No - treat as syntax error
	SETZ	R5,			; End with a null byte
	DPB	R5,R6			; Tack it on the string
	MOVEI	R1,E10BLK		; Assume Tenex
	SKIPN	TENFLG			;  and test flag
	MOVEI	R1,E20BLK		; Load if Tops-20
	HRRO	R2,PAGPTR		; Main string pointer
	GTJFN				; Try to get a JFN for this file
	 JRST	JERR			; Error out
	MOVE	[ XWD GETF,R5 ]
	BLT	GETZ			; Move code into AC's
	MOVEI	R4,(R1)			; Save JFN in R4
IFN CCLSW,<
	SKIPE	CCLFLA			; IF CCL
	 AOS	OFSET			; THEN START PROG AT +1 ENTRY
>;IFN CCLSW
	SETO	R1,			; Remove all pages
	MOVSI	R2,(1B0)		; Starting with page 0
	SETZ	R3,			; Just in case
	JRST	R5			; Load it into this fork

GETF:
	PHASE	R5
CLRLP:!	PMAP				; Pmap out a core page
	AOJ	R2,			; Bump to next page
	TRNE	R2,777			; Past the last page?
	 JRST	CLRLP			; No - keep looping
	MOVEI	R1,(R4)			; Reload the JFN
	HRLI	R1,(1B0)		; Current fork
	GET				; Try to get it
	MOVEI	R1,(1B0)		; Start this fork
	GEVEC				; Get this new entry vector
OFSET:!	JRST	(R2)			; Jump to it!
GETZ==	.-1
	DEPHASE
>;IFN TENEX

;COMMA PROCESSOR

COMMA:
	TRO	R16,COMBIT		; SET COMMA FLAG
	JRST	INFTST			; EXIT

; SLASH (/) PROCESSOR

SLASH:
	TRO	R16,SWTBIT		; TURN ON SWITCH FLAG
	TRZ	R16,COLBIT		; Make sure we don't have stray bit on
	JRST	INFTST			; EXIT

; BEGIN OR END A PPN


IFN TENEX,<
; Store the character away either in R14 or a string.

STORE:
	TRO	R16,INFBIT!NULBIT	; Non-null file and line
	TRNN	R16,SWTWRD		; String?
	JRST	STRGST			; Yes, store it
	SUBI	R5,40			; No, make it sixbit
	TLNE	R6,770000		; Don't store if no more room
STRGST:	IDPB	R5,R6			; Plop the character away
	JRST	GETTTI			;  and get next character
>;IFN TENEX
IFE TENEX,<
; HERE WE STORE THE CHARACTER IN R14, BUT FIRST CONVERTING
;  TO SIXBIT.  ANY CHARACTER AFTER THE SIXTH IS LOST.

STORE:
	TRO	R16,INFBIT!NULBIT	; TURN ON BIT FOR CR ROUTINE
	SUBI	R5,40			; CONVERT SIXBIT TO ASCII
	TLNE	R6,770000		; DON'T STORE IF NO ROOM FOR CHAR
	IDPB	R5,R6			; PLOP THE CHARACTER INTO AC R14
	JRST	GETCMN			; RETURN
>;IFE TENEX


; SWITCH PROCESSOR

SWTPRC:
IFN TENEX,<
	TRO	R16,SWTWRD		; Set flag for switch words
>;IFN TENEX
	CALL	GETWRD			; GET THE SWITCH
	 JRST	ERRSE			; NULL SWITCH IS AN ERROR
	TRNE	R14,-1			; ONLY 3 CHARS FOR SWITCH
	 JRST	ERRSE			; TOO MANY CHARS
	HLRZ	R0,R14			; SET-UP FOR TABLE SEARCH
	PUSH	P,R1			; SAVE A COPY OF DEVICE FOR LATER
	MOVE	R1,SWTTBL		; GET SWITCH TABLE ADDRESS
	CALL	TABSRC			; SEARCH IT
	 JRST	ERRBS			; CAN'T FIND SWITCH
	JRST	(R2)			; GO TO CORRECT PROCESSOR

SWTTBL:
	XWD	-<TABEND-SWTTBL>, .+1
	XWD	.CREF,(SIXBIT	/CRF/)
	XWD	.LI,(SIXBIT	/LI/)
	XWD	.NL,(SIXBIT	/NL/)
	XWD	.EN,(SIXBIT	/EN/)
	XWD	.DS,(SIXBIT	/DS/)
	XWD	.FORMT,(SIXBIT	/FO/)
	XWD	.PASS,(SIXBIT	/PA/)
	XWD	.EQ,(SIXBIT	/EQ/)	; EQUATE SWITCH		[ECL1]
IFN CMUSW,<IFN CCLSW,<XWD DUMYSW,(SIXBIT/L/)>>	; Temporary until COMPIL is fixed
TABEND=.				; END OF SWITCH TABLE
	SUBTTL	SWITCH PROCESSING ROUTINES

;The following is a temporary hack due to a bug in COMPIL at CMU:
IFN CMUSW,<
IFN CCLSW,<
DUMYSW:	SKIPE	CCLFLA		; If we came from COMPIL
	 TRNN	R16,CKLBIT	; and it said /L on LISTING file
	  JRST	ERRBS
	JRST	SWTCHK		; then ignore it
>;IFN CCLSW
>;IFN CMUSW

.CREF:
	TRNN	R16,CKBBIT!CKLBIT	; NOT ON SOURCE FILES
	 JRST	ERRWF			; ERROR IF SOURCE
	TRNN	R16,COLBIT		; ANY ARGUMENTS?
	JRST	.CREF2			; nope				[ECL2]
	CALL	GETWRD			; YUP - GET THE ARGUMENT
	 JRST	ERRSE			; OOPS, FORGOT IT?
	TRNE	R14,-1			; IS IT TOO LONG?
	 JRST	ERRSE			; TOO BAD
	HLRZ	R14,R14			; SWAP HALVES
	CAIE	R14,(SIXBIT /NG/)	; ONLY ONE ARGUMENT ALLOWED
	 JRST	ERRSE			; WRONG ONE
.CREF2:	TLZ	R16,CSWBIT		; SET FLAG			[ECL2]
	JRST	SWTCHK			; AND EXIT

; /LI AND /NL PROCESSOR

.NL:	TRO	R16,NLTBIT		; THIS IS /NL NOT /LI
.LI:	TRNE	R16,CKBBIT		; MAKE SURE NOT BINARY FILE
	 JRST	ERRSE			; ERROR IF IT IS
	TRNN	R16,COLBIT		; ARGUMENTS TO COME?
	JRST	NOLARG			; NOPE
GTARG0:	CALL	GETWRD			; YES- GET IT THEN
	 JRST	ERRSE			; MUST HAVE ARG
	TRNE	R14,-1			; CAN'T HAVE MORE THAN 3 CHARS
	 JRST	ERRSE			; ERROR IF SO
	HLRZ	R0,R14			; SET-UP FOR CONVERSION TO M40
	CALL	SIXM40			; CONVERT IT SO WE CAN DO TABLE SEARCH
	MOVE	R1,LISTBL		; TABLE IN WHICH TO SEARCH
	CALL	TABSRC			; LOOK FOR IT
	 JRST	ERRSE			; ILLEGAL ARGUMENT
	MOVE	R3,LIWORD		; GET LIST CONTROL WORD
	TRNE	R16,NLTBIT		; /NL OR /LI?
	 TRZA	R3,(R2)			; CLEAR FLAG (/NL)
	  TRO	R3,(R2)			; SET FLAG (/LI)
	TLO	R3,(R2)			; SET MASK BIT TO FORCE OVERRIDE.
	MOVEM	R3,LIWORD		; SAVE IT
	TRNE	R16,COLBIT		; ANY MORE WITH THIS ATTRIBUTE?
	 JRST	GTARG0			; YES, GET THEM
	CALL	SETLF			; NO - SET GENUINE LISTING FLAGS.

SWTCHK:
	TRZ	R16,DSABIT!NLTBIT	; CLEAN OFF MODE BITS
	POP	P,R1			; RESTORE DEVICE NAME
	TRNE	R16,SWTBIT		; SWITCH TO PROCESS?
	JRST	SWTPRC			; YES
	RETURN				; NO, RETURN 

;	   /LI OR /NL SWITCH WITHOUT QUALIFIER . . .
;	   OVERRIDE LSTCNT'S VALUE AS FOLLOWS:

;	/NL:  FORCE LSTCNT NEGATIVE BY ORING ITS LEFT HALF TO BITS.
;	/LI:  SET LSTCNT'S LEFT HALF TO MATCH IT'S RIGHT HALF.

NOLARG:	MOVE	R0,LSTCNT		; GET CURRENT LIST LEVEL.
	TRZE	R16,NLTBIT		; IS THIS /LI OR /NL?
	JRST	NOLNL			;    /NL -- SET LEFT HALF (NEGATIVE).
	TLZ	R0,-1			;    /LI -- CLEAR LEFT HALF.
	TRNE	R0,400000		; IS RIGHT HALF NEGATIVE?
NOLNL:	TLO	R0,-1			;    YES - FORCE LEFT HALF NEGATIVE.
	MOVEM	R0,LSTCNT		; STUFF RESULT BACK IN CONSECRATED CORE.
	JRST	SWTCHK

; /EN AND /DS

.DS:	TRO	R16,DSABIT		; /DS WAS TYPED
.EN:	TRNE	R16,CKBBIT!CKLBIT	; LOOKING FOR SOURCE?
	 JRST	ERRSE			; NOPE- ERROR
	TRNN	R16,COLBIT		; COLON FOR ARGUMENTS?
	 JRST	ERRSE			; MUST HAVE IT FOR /EN OR /DS
GTARG:	CALL	GETWRD			; GET ARGUMENT
	 JRST	ERRSE			; NULL ARGUMENT NOT ALLOWED
	TRNE	R14,-1			; ARGUMENT CAN'T BE GREATER THAN 3 CHARS
	 JRST	ERRSE			; ERROR IF IT IS
	HLRZ	R0,R14			; ARGUMENT IN R0 FOR SIXM40
	CALL	SIXM40			; CONVERT TO M40
	MOVE	R1,ENATBL		; FIRST WORD OF TABLE
	CALL	TABSRC			; SEARCH IT
	 JRST	ERRSE			; CAN'T FIND IT - ERROR
	MOVE	R3,ENACTL		; GET /EN AND /DS CONTROL WORD
	TRNE	R16,DSABIT		; /DS?
	 TRZA	R3,(R2)			; NO, SET BIT
	  TRO	R3,(R2)			; YES, CLEAR FLAG
	TLO	R3,(R2)			; SET MASK BIT TO SHOW OVERRIDE
	MOVEM	R3,ENWORD		; SAVE FLAG WORD
	TRNE	R16,COLBIT		; ANY MORE ARGUMENTS TO PROCESS?
	 JRST	GTARG			; YES - DO THEM FIRST
	CALL	SETEN			; NO - MERGE ENABLE OPTIONS
	JRST	SWTCHK			; CHECK FOR MORE SWITCHES 


; /EQ PROCESSOR								[ECL1]

.EQ:					; /EQ:V1:V2:...:Vn was typed	[ECL1]
	TRNN	R16,COLBIT		; colon for arguments?		[ECL1]
	 JRST	ERRSE			; no, must have at least 1	[ECL1]
.EQ2:	CALL	GETWRD			; get an argument		[ECL1]
	 JRST	ERRSE			; null arg not allowed		[ECL1]
	PUSH	P,R7			; 				[ECL1]
	MOVE	R0,R14			; in R0 for insrt		[ECL1]
	CALL	SIXM40			; convert			[ECL1]
	CALL	SSRCH			; look for it in symbol table	[ECL1]
	 JFCL				; ignore 'not found'		[ECL1]
	MOVSI	R1,DEFSYM		; give value of zero		[ECL1]
	CALL	INSRT			; insert in symbol table	[ECL1]
	POP	P,R7			;	 			[ECL1]
	TRNE	R16,COLBIT		; another?			[ECL1]
	 JRST	.EQ2			; yes				[ECL1]
	JRST	SWTCHK			; no, check for more switches	[ECL1]

; FORMAT CONTROL

.FORMT:
	TRNN	R16,CKBBIT		; FORMAT IS ONLY FOR BINARY FILES
	 JRST	ERRWF			; ERROR IF OTHERWISE
	TRNN	R16,COLBIT		; AND MUST HAVE ARGS
	 JRST	ERRSE			; ERROR IF NONE
	CALL	GETWRD			; GET THE ARGUMENT
	 JRST	ERRSE			; ERROR IF NONE
	TRNE	R14,-1			; MORE THAN 3 CHARS?
	 JRST	ERRSE			; YES, ERROR
	HLRZ	R1,R14			; GET IT IN RH
	CAIN	R1,(SIXBIT /I/)		; I FOR IMAGE MODE
	 JRST	[ TLO	R15,PSWFLG	;    YES- SET FLAG
		  JRST	SWTCHK ]	;    AND CHECK FOR NEXT SWITCH
	CAIN	R1,(SIXBIT /P/)		; "P" -- Packed output
	 JRST	SWTCHK			;    (Selected by default)

	CAIN	R1,(SIXBIT /NOP/)	; "NOP" -- No padding
	 JRST	SWTCHK			;    (Selected by default)
	CAIN	R1,(SIXBIT /PAD/)	; "PAD" -- Pad between blocks
	 JRST   [ SETOM	PADSWT		;    Set switch to force padding.
		  JRST	SWTCHK	]

	CAIN	R1,(SIXBIT /NAL/)	; "NAL" -- No alignment
	 JRST	SWTCHK			;    (Selected by default)
	CAIN	R1,(SIXBIT /HAL/)	; "HAL" -- Half word alignment
	 JRST   [ MOVEI	R1,1		;    Set alignment mask to 1
		  MOVEM	R1,ALIGNM	;    to align blocks on even bytes
		  JRST	SWTCHK	]	;    (i.e., on PDP-10 half words).
	CAIE	R1,(SIXBIT /WAL/)	; "WAL" -- Word alignment
	 JRST	ERRSE			; . . . Illegal switch value if not WAL
	MOVEI	R1,3			;    Set alignment mask to 3 to align
	MOVEM	R1,ALIGNM		;    blocks on 4-byte boundaries
	JRST	SWTCHK			;    (i.e., on PDP-10 words).

.PASS:
	JRST	ERRBS			; TEMP!!!
IFN STANSW,<

; PROCESS A STANFORD PPN.
;  WHERE SIXBIT VALUE IS STORED RIGHT JUSTIFIED IN EACH HALF
;  WORD IN THE LOOKUP OR ENTER BLOCK.

PPNPRC:
	CAIE	R5,"["			; MUST BEGIN WITH A "["
	 JRST	ERRSE			; ELSE ERROR
	SETZM	XE3			; CLEAR PPN WORD
	CALL	GETWRD			; GET THE FIRST PART OF THE PPN
	 JRST	ERRSE			; ERROR IF NONE
	TRNN	R14,-1			; MORE THAN 3 CHARS
	TRNN	R16,COMBIT		; OR NOT ENDING WITH A COMMA IS AN ERROR
	 JRST	ERRSE			; SYNTAX ERROR
STPPN1:	TLNN	R14,77			; IS IT RIGHT JUSTIFIED YET?
	JRST	[ LSH	R14,-6		; NO, SHIFT OVER 6 BITS
		  JRST	STPPN1  ]	; AND CHECK AGAIN
	HLLM	R14,XE3			; SAVE FIRST PART IN BLOCK
	CALL	GETWRD			; GET NEXT WORD
	 JRST	ERRSE			; ERROR IF NONE
	TRNN	R14,-1			; AGAIN IS IT MORE THAN 3 CHARS?
	TRNN	R16,BRKBIT		; OR NOT ENDING WITH A BRACKET?
	 JRST	ERRSE			; YES, ERROR
	CAIE	R5,"]"			; MAKE SURE IT ENDED WITH A "]"
	 JRST	ERRSE			; ERROR IF IMPROPER ENDING
STPPN2:	TLNN	R14,77			; SEE IF IT IS RIGHT JUSTIFIED
	JRST	[ LSH	R14,-6		; IF NOT THEN SHIFT RIGHT 6 BITS
		  JRST	STPPN2  ]	; AND CHECK AGAIN
	HLRM	R14,XE3			; OK, SAVE IT
	RETURN				; AND RETURN
>;IFN STANSW

; TABLE SEARCH
; TABSRC WILL SEARCH A TABLE FOR A SPECIFIED ENTRY.
;	ARGUMENTS: R0 - DATA TO SEARCH FOR IN RH
;		   R1 - FIRST WORD IN TABLE
;
;	RETURNS:   +1 IF ARGUMENT WAS NOT FOUND IN TABLE SPECIFIED.
;		   +2 IF FOUND, WITH LH OF TABLE ENTRY IN RH OF R2

TABSRC:
	MOVE	R2,(R1)			; GET ADDRESS OF NEXT ENTRY
	CAIN	R0,(R2)			; MATCH?
	 JRST	FND			; YES!!
	AOBJN	R1,TABSRC		; NO, INCREMENT AND LOOP BACK
	RETURN				; COULDN'T FIND IT

FND:	HLRZ	R2,R2			; MOVE IT TO R2
	JRST	CPOPJ1			; RETURN +2



IFE STANSW!TENEX,<
PPNPRC:
	SETZM	XE3			; CLEAR NUMBER
LFTBR1:	HRLZS	XE3			; COMMA, MOVE TO LEFT HALF
LFTBR2:	CALL	GETTTI			; GET NEXT CHAR
	CAIN	R5,"]"			; TERMINAL?
	JRST	GETWRD			; GET THE NEXT WORD FOR GETFIL
	CAIN	R5,","			; SEPARATOR?
	JRST	LFTBR1			; YES
	CAIL	R5,"0"			; TEST FOR OCTAL NUMBER
	CAILE	R5,"7"
IFE CMUSW,< JRST ERRIC >		; IMPROPER CHARACTER
IFN CMUSW,< JRST CMUID >		; CHECK FOR CMU USERID
	HRRZ	R10,XE3			; OK, GET PREVIOUS VALUE
	IMULI	R10,8
	ADDI	R10,-"0"(R5)		; ACCUMULATE NEW NUMBER
	HRRM	R10,XE3
	JRST	LFTBR2
>;IFE STANSW!TENEX
IFN CMUSW,<
CMUID:	MOVE	R10,[POINT 7,CMUSTR]	; POINTER TO ASCII STRING
	SETZM	CMUSTR			; CLEAR STRING LOCATION
	SETZM	CMUSTR+1
	SETZM	CMUSTR+2
	IDPB	R5,R10			; FIRST CHAR OF USERID
	MOVEM	R10,CMUPTR		; STORE POINTER
	MOVEI	R10,6+1+6		; COUNT FOR LOOP
	MOVEM	R10,CMUCTR		; STORE COUNT
CMULOP:	CALL	GETTTI			; GET CHAR
	CAIN	R5,"]"			; END CHAR
	JRST	CMUCVT			; CONVERT USERID TO PPN
	IDPB	R5,CMUPTR		; DEPOSIT CHAR IN STRING
	SOSL	CMUCTR			; DECR COUNTER
	JRST	CMULOP			; REPEAT LOOP
	JRST	ERRUID			; TOO MANY CHARS
CMUCVT:	HRRZI	R10,CMUSTR		; ADDRESS OF STRING
	HRLI	R10,XE3			; DESTINATION OF CONVERTED NUMBER
	CALLI	R10,-2			; CMUDEC UUO
	JRST	ERRUID			; ILLEGAL USERID
	JRST	GETCMN			; DONE
>;IFN CMUSW


IFN TENEX,<
	SUBTTL	Terminal string input

; READIN is a routine that accepts characters from the terminal and deposits
;  them into the buffer that is specified.  All editting functions are provided
;  and also the string is terminated by a character in a list that is specified
;  by the caller.  Editing features are:
;
;	^A, DEL, and ^H are taken to be backspace.
;	^R is taken as re-type the string.
;	^U and ^X are taken as clear the string and start over again.
;
; REREAD is an alternate entry point of READIN.  Its function is to allow
;  the caller to append characters to a given string.
;
; Input:
;	R1	Address of the break character table.
;		In the form of:
;		 R1 --- XWD user data, ASCII character
;
;		This table is terminated with a zero word.
;
;	R2	String pointer to place characters.
;
;	R3	Positive byte count; 0 = unlimited byte count
;
;  For the REREAD entry point these extra registers must be loaded:
;
;	R4	String pointer to be used when retyping entire string.
;	R5	Byte count: # bytes from R2 to R4
;
; Output:
;	R1	Entry from the character table that the string was terminated
;
;	R2	Updated string pointer (break character is NOT deposited).
;
;	R3	Byte count of the string
;
; Note:
;	1. Nulls from the terminal are ignored.
;	2. If the user types more that allowed byte count then all subsequent
;	   input is echoed with a bell.
;	3. The breaking character is not echoed.
REREAD:	PUSH	P,R4		; Save registers so we can
	PUSH	P,R5			;  clobber them
	PUSH	P,R6
	PUSH	P,R7
	PUSH	P,R10
	PUSH	P,R11
	JRST	READ1			; Now enter common routine

READIN:
	PUSH	P,R4			; Save some registers so that we can
	PUSH	P,R5			;  clobber them
	PUSH	P,R6
	PUSH	P,R7
	PUSH	P,R10
	PUSH	P,R11

; Save and init some registers

	SETZ	R5,			; Zero byte count
	MOVE	R4,R2			; Original string pointer to be saved
READ1:
	MOVE	R6,R1			; R6 has the break character table loc
	MOVE	R7,R2			; Current string pointer

; Save current terminal mode word and turn echoing off

	MOVEI	R1,100			; Primary input
	RFMOD				; Read its mode
	PUSH	P,R2			; Save it so that we can restore it
	TRZ	R2,3B25			; No echo please
	SFMOD				; Set it
	MOVEI	R1,(1B0)		; Get primary JFNs for this fork
	GPJFN				; Get them
	AOJ	R2,			; Bump it up one
	MOVE	R11,R2			; Save it in R11
					;  Note: If primary JFNs were the terminal
					;   then R11 has zero.

; Now enter the input loop

RDLOOP:	CALL	PBIN			; Get a character from the terminal
	CAIN	R1,"V"-100		; Quote next character?
	 JRST	READQU			; Yes
	JUMPE	R1,RDLOOP		; Ignore nulls

; Check user specified break table first

	MOVEI	R2,(R6)			; Get address of break table
CHARCK:	SKIPN	R10,(R2)		; Get an entry from the table
	 JRST	READ2			; All done try editing functions
	CAIN	R1,(R10)		; Characters match?
	 JRST	RDEXIT			; Yes - exit
	AOJA	R2,CHARCK		; Next entry

; Since it is not a user break character then check for editing functions

READ2:
	CAMN	R1,BAKCHR		; Is it the back-up character?
	 JRST	BACKUP			; Yes
	CAIN	R1,"H"-100		; Backup?
	 JRST	BACKUP			; Yes
	CAIN	R1,DEL			; Delete for cancel?
	 JRST	CANCEL			; Yes
	CAIE	R1,"U"-100		; Cancel the entire string so far?
	CAIN	R1,"X"-100
	 JRST	CANCEL			; Yes
	CAIN	R1,"R"-100		; Retype string so far?
	 JRST	RETYPE			; Yes

; If we get this far then the character must be placed in the string if
;  there is enough room for it.

	JUMPE	R3,READ3		; Don't check byte counts if not needed
	CAMG	R3,R5			; Do we have room?
	 JRST	DINGB			; No - ring the bell
READ3:	CAIN	R11,			; If not terminal then don't echo
	PBOUT				; Echo the byte
	IDPB	R1,R7			; Put the byte away
	AOJA	R5,RDLOOP		; Count this byte and loop back

; Here we accept the next character as is without any checking because it
; was preceeded with a ^V to indciate quote the next character.

READQU:	JUMPE	R3,RDQUO1		; Don't check byte count
	CAMG	R3,R5			; Too many bytes?
	 JRST	DINGB			; Yes - don't allow this

RDQUO1:	PUSH	P,R3			; Save a register
	MOVEI	R1,(1B0)		; On this fork
	RPCAP				;   get capabilities
	JUMPGE	R2,RDQUO3		; Don't enable ^C but get next character
	PUSH	P,R2			; Save capabilities
	PUSH	P,R3			;  and enabled ones too
	TLO	R3,(1B0)		; Enable ^C
	EPCAP
	MOVEI	R1,-5			; Get terminal interrupt word
	RTIW				;  for entire job
	PUSH	P,R2			; Save it
	SETZ	R2,			; Disable all channels
	STIW				; Set it
	CALL	PBIN			; Get the quoted character
	CAIN	R11,			; Shall we echo it?
	PBOUT				; Echo it
	IDPB	R1,R7			; Save the byte away
	MOVEI	R1,-5			; Reset TIW
	POP	P,R2			;  of entire job
	STIW
	POP	P,R3			; Restore capabilities
	POP	P,R2
	MOVEI	R1,(1B0)		; Current fork
	EPCAP

RDQUO2:	POP	P,R3			; Finally restore R3
	AOJA	R5,RDLOOP		; Bump byte count and continue

RDQUO3:					; Can't enable ^C so forget enabling
	CALL	PBIN			; Get character
	PBOUT				; Echo it
	IDPB	R1,R7			; Store it away
	JRST	RDQUO2			;  and continue
; Get a byte from the primary input and ignore LF after CR's

PBIN:	PBIN				; Get a character
	CAIN	R1,LF			; Linefeed?
	 JRST	[ AOSG	CRLFLG		; Yes - throw it away?
		   JRST	PBIN		; Yes - get next character
		  RETURN  ]		; No - keep this character
	AOS	CRLFLG			; Count as not a LF
	CAIN	R1,CRR			; CR?
	 SETOM	CRLFLG			; Yes - reset flag
	RETURN				; Back to caller
; Here are the editing routines

BACKUP:					; Backup a character in the string
	JUMPE	R5,DINGB		; Ring bell if no more characters left
	MOVEI	R1,"\"			; Back up character
	PBOUT				; Output it
	LDB	R1,R7			; Get character
	PBOUT				;  and output it
	CALL	BKSPTR			; Move the string pointer back on byte
	JRST	RDLOOP			; Subtract from byte count and loop back

; Ring the bell

DINGB:	MOVEI	R1,"G"-100		; Bell character
	PBOUT				; Output it
	JRST	RDLOOP			; Back to input wait

; Re-type entire string so far

RETYPE:
	HRROI	R1,$CRLF		; Output a CR-LF to get a new line
	PSOUT
	JUMPE	R5,RDLOOP		; If no bytes then forget it
	PUSH	P,R3			; Save original byte count
	MOVN	R3,R5			; Get negative byte count
	MOVEI	R1,101			; Primary output
	MOVE	R2,R4			; Origninal string pointer
	SOUT				; Output the string
	POP	P,R3			; Restore original byte count
	JRST	RDLOOP			; Back for more characters

; Cancel the built up string so far

CANCEL:
	HRROI	R1,[ ASCIZ /XXX
/ ]
	PSOUT				; Output string
	MOVE	R7,R4			; Reset string pointer
	SETZ	R5,			; Zero byte count
	JRST	RDLOOP			;  and back to input wait


; Heres where READIN exits back to the caller

RDEXIT:	POP	P,R2			; Get back terminal mode word
	MOVEI	R1,100			; To be set on primary input
	SFMOD				; Set it
	MOVE	R1,R10			; Break table entry word
	MOVE	R2,R7			; Updated string pointer
	MOVE	R3,R5			; Byte count

; Now restore registers and return

	POP	P,R11
	POP	P,R10
	POP	P,R7
	POP	P,R6
	POP	P,R5
	POP	P,R4
	RETURN				; Exit from READIN
>;IFN TENEX

	SUBTTL	CCL Command string decoder

;THE FOLLOWING CODE IS USED FOR PROCESSING THE COMMAND
;STRINGS FOR THE CCL COMMAND FEATURES
IFN CCLSW,<

IFE TENEX,<

DSKNIT:					; INIT DSK FOR CCL
	HRRZ	R0,.JBFF		; USE .JBFF AS START OF CCL BUFFER
	HRRM	R0,CMDPNT		; DUMMY UP BUFFER HEADER
	HRRM	R0,TMPFIL+1		; SET UP TMPCOR READ BLOCK
	SOS	TMPFIL+1		; MAKE IT PROPER IOWD FORMAT
	HRRI	R1,(SIXBIT /P11/)
	HRLM	R1,TMPFIL		; SETUP NAME OF FILE TO BE READ
	MOVNI	R1,200			; AND WORD COUNT
	HRLM	R1,TMPFIL+1		; IN READ BLOCK
	MOVE	R1,[XWD 2,TMPFIL]	; SET UP AC FOR A READ
	TMPCOR	R1,			; READ AND DELETE "FOR" FILE
	JRST	TMPEND			; NO FILE IN CORE TRY DISK
	ADD	R0,R1			; GET END OF FILE
	MOVEM	R0,.JBFF		; UPDATE .JBFF SO FILE ISN'T WIPED OUT
	HRLM	R0,JOBFFI		; SAVE FOR LATER
	IMULI	R1,5			; CALCULATE CHARACTER COUNT
	MOVEM	R1,CMDCNT		; STORE IN BUFFER HEADER
	MOVSI	R1,(POINT 7,,)		; BYTE POINTER
	HLLM	R1,CMDPNT		; BUFFER HEADER NOW SETUP
	SETOM	TMPFLA			; MARK THAT TMPCOR UUO IN PROGRESS
	JRST	CPOPJ1
TMPEND:
	MOVEI	R0,3			; INIT 3 DIGIT COUNTER
	PJOB	R2,			; GET JOB NUMBER
DSKNI1:	IDIVI	R2,^D10			; GET LAST DIGIT
	ADDI	R3,"0"-40		; CONVERT TO SIXBIT
	LSHC	R3,-6			; SLIDE CHAR INTO AC4
	SOJG	R0,DSKNI1		; 3 CHARS YET?
	HRRI	R4,(SIXBIT /P11/)	; YES, GET FILENAME ###P11.TMP
	MOVEM	R4,XE			; SAVE FILE NAME IN LOOKUP DIRECTORY
	MOVSI	R4,(SIXBIT /TMP/)	; SET UP EXTENSION
	MOVEM	R4,XE1			; SAVE EXTENSION IN LOOKUP DIRECTORY
	SETZM	XE3			; ZERO PROJ,PROG #'S

	MOVEI	R0,ALMODE		; ASCII LINE DATA MODE
	MOVSI	R1,(SIXBIT /DSK/)
	MOVEI	R2,CMDBUF		; GET BUFFER HEADER ADDRESS
	OPEN	CMD,R0			; INIT DSK OK?
	JRST	DSKNI2			; NO, TYPE MESSAGE
	LOOKUP	CMD,XE			; LOOKUP ###FOR, TMP ON DISK
	JRST	DSKNI2			; FILE NOT FOUND
	INBUF	CMD,1			; ONE INPUT BUFFER
	MOVE	R0,.JBFF
	HRLM	R0,JOBFFI
	JRST	CPOPJ1			; FILE FOUND, SKIP RETURN
DSKNI2:	MOVE	R0,.JBFF
	HRLM	R0,JOBFFI
	JRST	ERRCF1


GETCM3:	MOVNI	R0,5			; SKIP OVER SEQUENCE NUMBER
	ADDM	R0,CMDCNT		; REDUCE COUNT BY 5 BYTES
	AOS	CMDPNT			; ADVANCE POINTER, FALL THROUGH

GETCMD:	SOSG	CMDCNT			; ANY CHARACTERS LEFT?
	CALL	GETCM1			; NO GET ANOTHER BUFFER FULL
	ILDB	R5,CMDPNT		; GET CHARACTER
	MOVE	R0,@CMDPNT		; CHECK FOR SEQUENCE NUMBER
	TRNE	R0,1
	JRST	GETCM3			; BY-PASS THE SEQUENCE NUMBER
	CAIN	R5,175			; OLD ALTMODE?
	MOVEI	R5,33			; YES, MAKE IT NEW ALTMODE
	CAIL	R5,140			; IS CHARACTER LOWER CASE?
	TRZ	R5,40			; YES, CHANGE TO UPPER CASE
	MOVE	R2,R5
	RETURN				; EXIT WITH CHARACTER

GETCM1:

IFN TEMPC,<
	SKIPE	TMPFLA			; IS A TMPCOR UUO GOING?
	 JRST	GETCM2			; YES, THEN WE ARE DONE?
>;IFN TEMPC
	IN	CMD,
	RETURN				; NO ERRORS OR END OF FILE
	STATZ	CMD,IODATA!IODEV!IOBKTL
	JRST	ERRCMD			; DATA ERRORS
GETCM2:
	JSP	R10,DELFIL		; DELETE FILE
	EXIT


DELFIL:	SKIPE	INDFLA			; DON'T DELETE IF INDIRECT FILE
	JRST	(R10)
	CLOSE	CMD,0			; CLOSE COMMAND FILE
	SETZB	R4,R5
	SETZB	R6,R7
IFN TEMPC,<
	SKIPE	TMPFLA			; TMPCOR BEING USED?
	 JRST	(R10)			; YES, DON'T RENAME FILE?
>;IFN TEMPC
	RENAME	CMD,R4
	JFCL
	JRST	(R10)			; RETURN


RUNUUO:					; PASS PROGRAM CONTROL TO NEXT PROGRAM (LNKX11)
	TRNN	R16,COLBIT		; Device specified?
	MOVSI	R1,(SIXBIT /SYS/)	; IF NO DEVICE, ASSUME SYS:
	TRNN	R16,EXTBIT		; PERIOD TYPED?
	MOVEM	R14,XE			; NO, THEN FILE NAME IS IN R14
	TRNN	R16,EXTBIT		; PERIOD TYPED?
	MOVEI	R14,0			; NO, ASSUME 0 EXTENSION
	HLLZM	R14,XE1			; SAVE IN DIRECTORY
	JSP	R10,DELFIL		; DELETE COMMAND FILE
	MOVE	R0,[XWD 1,R1]		; START INCREMENT,,6 WORD RUN BLOCK ADR
					; R1 = DEVICE
	MOVE	R2,XE			; GET FILENAME
	MOVE	R3,XE1			; GET EXTENSION
	SETZB	R4,R6
	MOVE	R5,XE3			; GET PROJ,PROG
	RUN	R0,			; START NEXT PROGRAM
	JSP	R10,ERROR		; RUN FAILED
	ASCIZ	/LINKAGE ERROR FOR %2%3/

INDFIL:	TRNN	R16,ARWBIT	; NORMAL MODE
	TLNN	R16,BINBIT		; OR BINARY SPECIFIED?
	JRST	ERRIC			; YES, ILLEGAL CHARACTER
	MOVE	R0,[INIT CMD,ALMODE]
	MOVEI	R2,CMDBUF
	CALL	CMDSET
	XWD	INBIT,1_ALMODE		; LEGAL BITS FROM DEVCHR
	TRNE	R16,EXTBIT		; EXTENSION?
	JRST	INDFI1			; YES, DON'T TRY ASSUMPTIONS
	MOVEM	R14,XE			; No, store file name where it belongs
	MOVSI	R14,(SIXBIT /CMD/)
	HLLZM	R14,XE1
	LOOKUP	CMD,XE
	 TDZA	R14,R14			; TRY NULL EXTENSION
	  JRST	INDFI2
INDFI1:	HLLZM	R14,XE1
	LOOKUP	CMD,XE
	 JRST	ERRCF			; CANNOT FIND COMMAND FILE
INDFI2:	SETOM	CCLFLA			; NON-STANDARD COMMAND STRING
	SETOM	INDFLA			; SET INDIRECT FLAG
	INBUF	CMD,1			; SINGLE BUFFER
	MOVE	R14,.JBFF
	HRLM	R14,JOBFFI		; SAVE DATA RESTORE ADDRESS
	JRST NXTCCL
>;IFE TENEX
IFN TENEX,<
DSKNIT:	GJINF
	PUSH	P,R3			; JOB NUMBER
	HRROI	R1,CCLNBF		; POINTER TO CCL COMMAND NAME BUFFER
	HRROI	R2,[ASCIZ /DSK:/]
	SETZ	R3,
	SOUT
	POP	P,R2			; JOB NUMBER
	MOVE	R3,[1B2+1B3+3B17+^D10]
	NOUT				; AS THRE DIGITS
	 JFCL				; Ignore errors
	HRROI	R2,[ASCIZ /M11.TMP/]
	SETZ	R3,
	SOUT
	HRROI	R2,CCLNBF
	MOVSI	R1,100001
	GTJFN
	 JRST [	HRROI	R1,[ASCIZ /Cannot find /]
		JRST	DSKNIE	]
	MOVEM	R1,CCLJFN			; Save the CCL JFN
	MOVE	R2,[7B5+1B19]
	OPENF
	 JRST [	MOVE	R1,CCLJFN
		RLJFN
		 JFCL
		HRROI	R1,[ASCIZ / Cannot open /]
		JRST	DSKNIE	]
	JRST	CPOPJ1

DSKNIE:	PSOUT
	HRROI	R1,CCLNBF
	PSOUT
	HRROI	R1,$CRLF
	PSOUT
	RETURN
>;IFN TENEX

>;IFN CCLSW


	SUBTTL	Print header on page routine


HEADER:	CALL	ACEXCH			; YES, SAVE THE ACCUMULATORS
	PUSH	P,R16			; SAVE CURRENT FLAGS
	MOVEI	R2,FF			; GET A FORM FEED
	CALL	LSTOUT			; OUTPUT IT
	MOVEI	R10,PAGSIZ		; RESET LINE COUNTER REGISTER
	MOVEM	R10,LINCNT		; ...
	SKIPN	TTLFLA			; DO WE HAVE TITLE?
	 JRST	[ MOVE	R0,PRGTTL	; No - get program title
		  CALL	LSTSYM		;  and print it
		  JRST	HEADR1	]	; Merge back
	MOVE	R10,[POINT 7,TTLMSG]	; YES - PRINT OUT WHOLE TITLE
	CALL	LSTASC
HEADR1:	CALL	LSTTAB
	MOVE	R0,TITLE
	CALL	LSTSIX
	CALL	LST3SP
	MOVE	R0,ASMVER		; PRINT VERSION NO.
	CALL	LSTSIX
	CALL	LST3SP

IFE TENEX,<
;THE FOLLOWING SECTION PRINTS THE DATE, WHICH IS FOUND IN
;REGISTER XDATE IN THE FORM
;	((Y-1964)*12 + (M-1))*31 + (D-1)
	MOVE	R10,DATE		; GET THE DATE IN R10
	IDIVI	R10,^D31		; DIVIDE BY 31 DECIMIAL
	ADDI	R11,1
	CALL	DNC			; OUTPUT DAY
	IDIVI	R10,^D12		; DIVIDE BY 12 DECIMAL
	MOVE	R0,MONTH(R11)
	CALL	LSTSIX			; OUTPUT THE MONTH, (M-1) IS IN R12
	MOVEI	R11,^D64(R10)		; GET THE YEAR
	CALL	DNC			; TYPE IT
	CALL	LST3SP			; OUTPUT TAB

;THE FOLLOWING SECTION OF CODE PRINTS THE TIME, WHICH IS
;PICKED UP FROM THE MONITOR AS THE NUMBER OF MILLISECONDS
;SINCE MIDNIGHT. THE FORMAT OF THE TIME PRINTOUT IS HH:MM
	MOVE	R11,MSTIME		; GET THE CURRENT TIME
	IDIVI	R11,^D60*^D1000		; NUMBER OF MIN. SINCE MIDNITE
	IDIVI	R11,^D60		; NUMBER OF HOURS
	PUSH	P,R12			; SAVE MINUTES
	CALL	DNC			; OUTPUT THE HOURS
	MOVEI	R2,":"			; OUTPUT A COLON AFTER THE HOURS
	CALL	LSTDMP			; OUTPUT IT
	POP	P,R11			; PUT MINUTES IN OUTPUT AC
	MOVEI	R2,"0"			; GET AN ASCII ZERO
	CAIG	R11,^D9			; IS IT A ONE-DIGIT NUMBER?
	CALL	LSTDMP			; YES, OUTPUT A ZERO
	CALL	DNC			; OUTPUT THE MINUTES
>;IFE TENEX

IFN TENEX,<
	MOVE	R10,[POINT 7,DATSTR]	; LIST TIME AND DATE.
	CALL	LSTASC
>;IFN TENEX


;THIS  SECTION OF CODING PICKS UP THE WORD "PAGE " AND
;STORES IT IN THE PROPER PLACE IN THE TITLE BUFFER.

	CALL	LST3SP
	MOVE	R0,[SIXBIT /PAGE/]
	CALL	LSTSIX			; PRINT "PAGE"
	MOVEI	R2," "
	CALL	LSTOUT			; SPACE
	AOS	R2,INPGNM		; Increment source-oriented page number.
	AOS	R11,PAGNUM		; Increment actual page number.
	TLNE	RMODE,P1F		; PASS 1?
	 MOVEI	R2,(R11)		;  yes - special case SON
	MOVE	R0,LSTCTL		; Check for source-oriented numbering . . .
	TRNE	R0,LSON			; .list  son in effect?
	 MOVS	R11,R2			;    Yes - Get input-related page number.
					;    No -- Keep output page number.
	HLLM	R11,(P)			; Save page extension, if any.
	TLZ	R11,-1			; Trim down to source or listing page number.
	CALL	DNC			; Convert to decimal and print it.

	HLRZ	R11,(P)			; Retrieve page extension.
	JUMPE	R11,NOPGEX		; ... 0 means there isn't one.
	MOVEI	R2,"-"			; Output the separator for "page-ext".
	CALL	LSTOUT
	CALL	DNC			; Convert & print the extension.
NOPGEX:	CALL	LSTCR			; Terminate the line.


;THE FINAL SECTION OF CODE PICKS UP A SUBTITLE (IF AVAILABLE)
;AND PUTS IT ON THE SECOND LINE OF THE PAGE

	CALL	LSTFIL			; PRINT FILE NAME FIRST
	TLNN	R16,SBTBIT		; DO WE HAVE A SUBTITLE?
	 JRST	NOSBTL			; NONE SEEN
	MOVE	R10,[POINT 7,SUBMSG]	; POINT TO SUBTITLE BUFFER
	CALL	LSTASC			; LIST IT.
NOSBTL:	CALL	LSTCR			; END THE LINE.

	CALL	LSTCR			; SECOND LINE CRLF
	POP	P,R2			; RESTORE FLAGS
	JRST	ACEXCH			; RESTORE F4 REGS AND EXIT

LSTFIL:
IFN TENEX,<
	MOVE	R10,SFILPT		; Load source file name pointer
	CALL	LSTASC			; List it
	JRST	LSTTAB			; List a tab and return
>;IFN TENEX
IFE TENEX,<
	PUSH	P,R0
	MOVE	R0,XE			; GET FILE NAME
	CALL	LSTSIX
	CALL	LST2SP
	HLLZ	R0,XE1			; GET EXTENSION
	CALL	LSTSIX			; LIST IT OUT
	CALL	LSTTAB			; SEPARATE WITH A TAB
	POP	P,R0
	RETURN
>;IFE TENEX


DNC:	IDIVI	R11,^D10		; RECURSIVE SUBROUTINE
	HRLM	R12,0(P)		; SAVE REMAINDER ON PUSHDOWN LIST
	CAIE	R11,			; ALL DONE?
	CALL	DNC			; NO, CALL DNC AGAIN
	HLRZ	R2,0(P)			; RETRIEVE NUMBER FROM PD LIST
	JRST	LSTNUM			; LIST NUMERIC AND EXIT

LSTSIX:	MOVSI	R6,(POINT 6,R0,)
LSTSI1:	ILDB	R2,R6
	JUMPE	R2,CPOPJ
	ADDI	R2," "
	CALL	LSTOUT
	TLNE	R6,770000
	JRST	LSTSI1
	RETURN

IFE TENEX,<
MONTH:	SIXBIT	/-JAN-/
	SIXBIT	/-FEB-/
	SIXBIT	/-MAR-/
	SIXBIT	/-APR-/
	SIXBIT	/-MAY-/
	SIXBIT	/-JUN-/
	SIXBIT	/-JUL-/
	SIXBIT	/-AUG-/
	SIXBIT	/-SEP-/
	SIXBIT	/-OCT-/
	SIXBIT	/-NOV-/
	SIXBIT	/-DEC-/


IFN CCLSW,<
;CALL:	CALL	CMDSET
;	XWD	BITS1,BITS2		;LEGAL BITS ON DEVCHR
;	RETURN

CMDSET:	MOVE	R3,R1			; GET DEVICE NAME
	DEVCHR	R3,
	SETCMM	R3			; COMPLEMENT BITS
	TDNE	R3,@(P)			; WERE ALL BITS ONE?
	JRST	ERRNIT			; NO
	AOS	(P)			; YES, SKIP RETURN
					; FULL THROUGH
>;IFN CCLSW

INISET:	MOVE	R3,[JRST ERRNA]		; ERROR EXIT FOR INIT
	MOVSI	R4,(POPJ P,)
	JRST	R0
>;IFE TENEX

	SUBTTL	EXEC ERROR ROUTINES

IFN TENEX,<
JERR:					; JSYS error message routine
	HRROI	R1,[ASCIZ / /]		; Nothing to print other than error
	ESOUT
JERRTY:	MOVEI	R1,101			; Output to primary output JFN
	HRLOI	R2,(1B0)		; Current fork and last error
	SETZ	R3,			; Standard default
	ERSTR				; Print error message
	 JRST	[ HRROI	R1,[ ASCIZ /Unknown error number/ ]
		  PSOUT			; Output error message
		  JRST	MACN11	]	; Begin all over gain
	JRST	[ HRROI	R1,[ ASCIZ /Error in error routine!
/]
		  PSOUT
		  HALTF			; Halt
		  JRST	MACN11 ]	; Start all over on continue
	HRROI	R1,$CRLF		; Output a CR-LF to get a new line
	PSOUT
	JRST	MACN11			; Error msg printed so start over

JERRPR:					; Print JSYS error and return to caller
	HRROI	R1,[ASCIZ / /]
	ESOUT
	MOVEI	R1,101			; Output to primary output JFN
	HRLOI	R2,(1B0)		; Current fork and last error
	SETZ	R3,			; Standard default
	ERSTR				; Print error message
	JFCL				; Unknown error number
	JRST	[ HRROI	R1,[ ASCIZ /Error in error routine!/ ]
		  PSOUT
		  RETURN  ]
	RETURN				; Back to caller

; Routine to print error message when GTJFN fails

GJFNER:	HRROI	R1,[ ASCIZ / Can't get a JFN for / ]
	ESOUT				; Output the string
	MOVE	R1,R14			; Now load string pointer which GTJFN failed
	PSOUT				; Output it
BECUZ:	HRROI	R1,[ ASCIZ / because / ]
	PSOUT				; Get ready to output error message
	JRST	JERRTY			; Output error string

; OPENF failure error message output routine

OPNERR:	HRROI	R1,[ ASCIZ / Can't open file / ]
	ESOUT				; Get ready to output filename
	MOVEI	R1,101			; Primary output
	MOVEI	R2,(R3)			; Get JFN that it failed on
	SETZ	R3,			; Default output specs.
	JFNS				; Output the filename
	JRST	BECUZ			; Print error message

TABFUL:					; Source JFN table is full
	HRROI	R1,[ ASCIZ / Too many source files!/]
ERROUT:	ESOUT
ERRPCR:	HRROI	R1,$CRLF		; Output a CR-LF to get a new line
	PSOUT
	JRST	MACN11			; Return to start

ILCHAR:					; Illegal character type in command string
	HRROI	R1,[ASCIZ / /]
	ESOUT
	MOVEI	R1,(R5)			; Get the bad character
	PBOUT				;  and print it out to user
	HRROI	R1,[ ASCIZ / is an illegal character./ ]
ERRPRT:	PSOUT				; Output the error message
	JRST	ERRPCR			; End with a CR-LF

ERRBS:	HRROI	R1,[ASCIZ / /]
	ESOUT
	MOVE	R0,R14			; Get bad switch
	CALL	LSTVER			; Print so user knows what was bad
	HRROI	R1,[ ASCIZ / is a bad switch./ ]
	JRST	ERRPRT			; Print and return to start

ERRSE:	HRROI	R1,[ ASCIZ / Syntax error in command string./ ]
	JRST	ERROUT			; Print msg

ERRNC:	HRROI	R1,[ ASCIZ / Impossible error of no more core./ ]
	JRST	ERROUT

ERRWF:	HRROI	R1,[ ASCIZ / / ]
	ESOUT
	MOVE	R0,R14			; Illegal switch for input files
	CALL	LSTVER
	HRROI	R1,[ ASCIZ / is illegal for input files./ ]
	JRST	ERRPRT			; Print it out

ERRTF:	HRROI	R1,[ ASCIZ / Too many input files./ ]
	JRST	ERROUT			; Got .END but still more input files

ERRTB:	HRROI	R1,[ ASCIZ / / ]
	ESOUT
	MOVE	R0,R14			; Illegal switch for binary files
	CALL	LSTVER
	HRROI	R1,[ ASCIZ / is illegal for binary file./ ]
	JRST	ERRPRT
>;IFN TENEX

IFE TENEX,<

ERRCMD:	MOVEI	R10,[ASCIZ /DEVICE INPUT ERROR FOR COMMAND STRING/]
	JRST ERROR

ERRNIT:	MOVEI	R10,[ASCIZ /IMPROPER IO FOR DEVICE %2/]
	JRST ERROR

IFN CCLSW,<
ERRCF1:	SETZM	CCLFLA			; LOOKUP FOR DSK:###P11.TMP FAILED
>;IFN CCLSW


ERRCF:	MOVEI	R10,[ASCIZ /CANNOT FIND %2%3%4/]
	JRST	ERROR

ERRID:	MOVEI	R10,[ASCIZ /INPUT DATA ERROR %2%3%4/]
	JRST	ERROR

ERRBS:	MOVEI	R10,[ASCIZ /%5 IS A BAD SWITCH/]
	JRST	ERROR

ERRIC:	MOVEI	R10,[ASCIZ /%1 IS AN ILLEGAL CHARACTER/]
	JRST	ERROR

ERRNA:	MOVEI	R10,[ASCIZ /%2 IS NOT AVAILABLE/]
	JRST	ERROR

ERRNR:	MOVEI	R10,[ASCIZ /NO ROOM FOR %2%3%4/]
	JRST	ERROR

ERRSE:	MOVEI	R10,[ASCIZ /SYNTAX ERROR IN COMMAND STRING/]
	JRST	ERROR

ERRNC:	MOVEI	R10,[ASCIZ /INSUFFICIENT CORE/]
	JRST	ERROR

ERRWF:	MOVEI	R10,[ASCIZ /%5 ILLEGAL SWITCH FOR INPUT FILES/]
	JRST	ERROR

ERRTF:	MOVEI	R10,[ASCIZ /TOO MANY INPUT FILES/]
	JRST	ERROR

ERRTB:	MOVEI	R10,[ASCIZ /%2 ILLEGAL FOR BINARY OUTPUT/]
	JRST	ERROR

>;IFE TENEX

IFN CMUSW,<
ERRUID:	MOVEI	R10,[ASCIZ /ILLEGAL USERID/]
	JRST	ERROR
>;IFN CMUSW


IFE TENEX,<
ERROR:					; NON-RECOVERABLE ERROR MESSAGE
	PUSH	P,R10			; STACK MESSAGE ADDRESS
	TLNE	R16,MODBIT		; HAVE WE EXEC AC'S?
	CALL	ACEXCH			;  NO, GET THEM
	POP	P,R10			; RESTORE MESSAGE POINTER
	MOVSI	R16,ERRBIT!LSTBIT!BINBIT ; FUDGE FLAGS
	CALL	LSTCR
	MOVEI	R2,"?"
	CALL	LSTOUT
	CALL	LSTSP			; TYPE SPACE
	CALL	LSTMCR
	CALL	LSTCR
	JRST	MACN11
>;IFE TENEX

LSTMCR:	CALL	LSTMSG
	JRST	LSTCR			; LIST MESSAGE AND CRR

LSTMSG:	TLOA	R10,(POINT 7,,)		; SET BYTE POINTER AND SKIP
LSTMS4:	 CALL	LSTOUT			; TYPE CHARACTER
LSTMS5:	ILDB	R2,R10			; GET CHARACTER
	JUMPE	R2,CPOPJ		; TEST FOR END
IFN TENEX,<
	CAIE	R2,"%"			; Special for number print?
	 JRST	LSTMS4			; No - take as a valid character
	ILDB	R2,R10			; Get number following '%'
	CALL	DNC			; Print number
	JRST	LSTMS5			; Back to check next character
>;IFN TENEX
IFE TENEX,<
	CAIE	R2,"%"			; Special?
	 JRST	LSTMS4			; No - take as a valid character
	ILDB	R2,R10
	CALL	@[EXP DNC,ERR1,ERR2,ERR3,ERR4,ERR5]-"0"(R2)
	JRST	LSTMS5			; GET NEXT CHARACTER

ERR1:	CAILE	R5,37
	 JRST	ERR1A
	MOVEI	R2,"^"
	CALL	LSTOUT
	ADDI	R5,100
ERR1A:	MOVE	R2,R5			; GET IMPROPER CHARACTER
	JRST	LSTOUT			; DUMP IT

ERR2:	MOVE	R0,R1			; GET DEVICE NAME
	CALL	LSTSIX			; TYPE IT
	MOVEI	R2,":"
	JRST	LSTOUT			; TYPE ":"

ERR3:	MOVE	R0,XE			; GET FILE NAME
	JRST	LSTSIX			; TYPE IT

ERR4:	HLLZ	R0,XE1			; GET EXTENSION
	JUMPE	R0,CPOPJ		; EXIT IF NULL
	MOVEI	R2,"."
	CALL	LSTOUT			; TYPE "."
	JRST	LSTSIX

ERR5:	HLLZ	R0,R14			; Get illegal switch
	JRST	LSTSIX			;  and output it
>;IFE TENEX

;	**********  LIST AN ASCII STRING  **********

LSTASC:	ILDB	R2,R10			; LOAD NEXT BYTE.
	JUMPE	R2,CPOPJ		; QUIT WHEN FINDING A 0 BYTE.
	CALL	LSTOUT			; OUTPUT THE BYTE.
	JRST	LSTASC
EXIT:
IFN TENEX,<
	SETO	R1,			; Map out the source data page
	MOVE	R2,[ XWD 400000,SPGMAP ]
	SETZ	R3,
	PMAP
	MOVE	R1,LSTJFN		; Get listing file JFN
	CLOSF
	 jfcl
	MOVE	R1,BINJFN		; Finally the binary file
	CLOSF
	 jfcl
	AOS	R2,SJFNIX		; Increment and load source index
	SKIPE	SRCTAB(R2)		; Test if any more files
	 JRST	ERRTF			; Yes, too may input files
EXIT9:	SOS R2,SJFNIX			; CYCLE BACK THROUGH ALL JFNS
	HRRZ R1,SRCTAB(R2)		; GET THE JFN
	CLOSF				; CLOSE ALL THE SOURCES
	 JFCL				; IGNORE ERRORS
	JUMPN R2,EXIT9			; LOOP THRU THEM ALL
IFN CCLSW,<
	SKIPN	CCLFLA
	JRST	MACN11
	JRST	NXTCCL
>;IFN CCLSW
>;IFN TENEX

IFE TENEX,<
	CLOSE	SRC,			; CLOSE THE SOURCE DEVICE
	CLOSE	LST,			; CLOSE THE LISTING FILE
	CLOSE	BIN,			; CLOSE THE BINARY FILE
	TLON	R16,LSTBIT		; WAS THERE A LISTING FILE?
	CALL	LSTTST			; YES, TEST FOR FINAL ERROR
	TLON	R16,BINBIT		; IS THERE A BINARY FILE?
	CALL	BINTST			; YES, TEST FOR FINAL ERROR
	TRNN	R16,ENDBIT		; End of command string?
	 JRST	ERRTF			; No - too many files
IFN CCLSW,<
	SKIPN	CCLFLA			; RESTART IF NOT CCL MODE
	JRST	MACN11
	HLRZ	R0,JOBFFI
	MOVEM	R0,.JBFF		; RESTORE DATA AREA

	RELEAS	LST,0
	RELEAS	BIN,0
	RELEAS	SRC,0
EXIT6:	CALL	GETCMD			; GET NEXT COMMAND CHAR
	CAIL	R5,12			; THROW AWAY REST
	 CAILE	R5,15			; OF LAST LINE
	  CAIA
	   JRST	EXIT6
	MOVSI	R5,070000		; BACK UP BYTE
	ADDM	R5,CMDPNT		; POINTER ONE BYTE
	AOS	CMDCNT
	JRST	NXTCCL			; GO DO NEXT COMMAND
>;IFN CCLSW
>;IFE TENEX
IFE CCLSW,< JRST MACN11 >		; BACK TO BEGINNING

CORSET:					; INIT DYNAMIC MEMORY
;					; I.E. **** INITIALIZE SYMBOL TABLE ****

	HRRZ	R0,.JBREL		; GET TOP OF CORE
	MOVEM	R0,SYMTOP		; SET SAME AS SYMBOL TABLE TOP.
	MOVE	R1,R0			; .. SAVE FOR BLOCK TRANSFER.
	SUBI	R0,PSLEN		; SET INITIAL BOTTOM POINTER.
	MOVEM	R0,SYMBOT		; STORE IT

	HRLI	R0,PERMST		; COPY GENUINE PERMANENT SYMBOLS
	BLT	R0,0(R1)		; (NOT OP CODES!) INTO SYMBOL TABLE.
	JRST	SRCHI			; INITIALIZE THE SYMBOL TABLE AND RETURN


ACEXCH:					; SWAP AC'S
	TLC	R16,MODBIT		; TOGGLE MODE BIT
	EXCH	R0,AC00
	EXCH	R1,AC01
	EXCH	R2,AC02
	EXCH	R3,AC03
	EXCH	R4,AC04
	EXCH	R5,AC05
	EXCH	R6,AC06
	EXCH	R7,AC07
	EXCH	R10,AC10
	EXCH	R11,AC11
	EXCH	R12,AC12
	EXCH	R13,AC13
	EXCH	R14,AC14
	RETURN

;ROUTINE TO OUTPUT RELOCATABLE BINARY


BINWRD:					; OUTPUT BINARY WORD
	TLNE	R16,BINBIT		; BINARY REQUESTED?
	RETURN				;  NO, EXIT
	PUSH	P,R2			; STACK WORD
	CALL	BINBY2			; OUTPUT LOW BYTE
	POP	P,R2
	LSH	R2,-8			; MOVE HIGH INTO LOW
					; FALL THROUGH

BINBYT:					; BINARY OUTPUT
	TLNE	R16,BINBIT		; BINARY REQUESTED?
	RETURN				;  NO, EXIT
BINBY2:
	ANDI	R2,377			; MASK TO 8 BITS
	ADDM	R2,CHKSUM		; UPDATE CHECKSUM
	TLNN	R15,PSWFLG		; PACKED MODE?
	JRST	BINPAK			;  YES
	MOVEM	R2,BINDAT
BINOUT:
IFN TENEX,<
	PUSH	P,R2
	PUSH	P,R1
	MOVE	R1,BINJFN		; Load it with the binary file JFN
	MOVE	R2,BINDAT		; Get word to output
	BOUT				; Dump it
	POP	P,R1
	POP	P,R2
>;IFN TENEX
IFE TENEX,<
	SOSG	BINCNT
	 CALL	BINDMP
	EXCH	R2,BINDAT
	IDPB	R2,BINPNT
	MOVE	R2,BINDAT		;Restore R2
>;IFE TENEX
	SETZM	BINDAT			; Clear the word for a new data
	SETZM	BINPCT			; Reset the packed byte pointer
	RETURN				;  and back to caller

BINPAK:	PUSH	P,R3			; Save a register
	AOS	R3,BINPCT		; Get byte count (mod-4 counter)
	DPB	R2,BINTBL-1(R3)		; Deposit byte according to table
	CAIN	R3,4			; Full word yet?
	 CALL	BINOUT
	POP	P,R3			; Restore the register
	RETURN				; Return to caller

BINTBL:	POINT	8,BINDAT,17
	POINT	8,BINDAT,9
	POINT	8,BINDAT,35
	POINT	8,BINDAT,27

IFE TENEX,<
BINDMP:	OUTPUT	BIN,
BINTST:	STATO	BIN,IODATA!IODEV!IOWRLK
	RETURN
	MOVEI	R10,[ASCIZ /BINARY OUTPUT ERROR/]
	JRST	ERROR			; TYPE ERROR MESSAGE
>;IFE TENEX
	SUBTTL	EXEC ROUTINES USING ASSEMBLER AC'S

LSTSYM:					; LIST SYMBOL
	PUSH	P,R0
	TLNE	R0,200000		; IS THIS A LOCAL SYMBOL?
	JRST	LSTLOC			; -- YES -- DECODE ITS NAME
					; -- NO -- SYMBOL IS IN MOD40
	CALL	M40SIX			; CONVERT TO SIXBIT
	PUSH	P,R1			; STACK A WORKING REGISTER
	MOVSI	R1,(POINT 6,R0)
LSTSY1:	ILDB	R2,R1
	ADDI	R2,40			; CONVERT TO ASCII
	CALL	LSTOUT
	TLNE	R1,770000		; TEST FOR END
	JRST	LSTSY1
LSTRET:	POP	P,R1
	POP	P,R0			; RESTORE ORIGINAL
	RETURN


;	   *****  LIST A LOCAL SYMBOL  *****

;	SYMBOL'S NUMERIC PART IS A 16-BIT NON-ZERO BINARY
;	INTEGER IN THE LEFT HALF OF R0.

LSTLOC:	TLZ	R0,600000		; RESET LOCAL SYMBOL FLAG BIT.
	HLRZ	R0,R0			; ALIGN NUMERIC PART IN RIGHT HALF
	PUSH	P,R1			; SAVE WORKING REGS
	PUSH	P,R3
	MOVEI	R3,6			; INIT BYTE COUNT TO 6
					; FOR COUNT DOWN TO 0.

;	   CONVERT NUMERIC PART OF SYMBOL TO DECIMAL.

	CALL	LSTLNU

	MOVEI	R2,"$"			; SUPPLY "$" SUFFIX
	CALL	LSTOUT
	SOJE	R3,LSTL5		; QUIT IF FIELD IS FULL

LSTL4:	CALL	LSTSP			; PAD TO 6 BYTES WITH SPACES
	SOJG	R3,LSTL4

LSTL5:	POP	P,R3			; RESTORE WORK REGS & RETURN
	JRST	LSTRET
;	    RECURSIVE SUBROUTINE TO PRINT A DECIMAL NUMBER
;	    DECREMENTING A BYTE COUNT IN R3 ....

LSTLNU:	IDIVI	R0,^D10			; GENERATE NEXT DIGIT.
	HRLM	R1,0(P)			; SAVE FOR PRINTING IN REVERSE ORDER.
	CAIE	R0,0			; WAS QUOTIENT 0?
	 CALL	LSTLNU			;    NO -- REPEAT FOR NEXT DIGIT.
	SOJ	R3,			;    YES - DECREMENT BYTE COUNT.
	HLRZ	R2,0(P)			; PICK UP NEXT DIGIT,
	JRST	LSTNUM			; PRINT IT, & POP BACK TO CALLER.

LST3SP:					; LIST SPACES
	CALL	LSTSP
LST2SP:	CALL	LSTSP
LSTSP:	MOVEI	R2,SPACE
	JRST	LSTOUT

LSTNUM:	TROA	R2,"0"			; LIST NUMERIC
	 ADDI	R2,40			; CONVERT SIXBIT TO ASCII
	JRST	LSTOUT

LSTCR:	TDZA	R2,R2			; LIST CR-LF
LSTTAB:	 MOVEI	R2,TAB			; LIST A TAB
LSTOUT:					; LISTING ROUTINE
	TLNN	R16,LSTBIT		; LISTING REQUESTED?
	 CALL	LPTOUT			;  YES
	TLNE	R16,ERRBIT		; ERROR LISTING?
	 TLNE	R16,TTYBIT		;  YES, TO TTY?
	  RETURN			;  NO
	JUMPE	R2,LSTOU1		; BRANCH IF CR-LF
IFN TENEX,<
	EXCH	R1,R2			; Save R1 and get the byte
	PBOUT				; Output the byte
	EXCH	R1,R2			; Restore R1
>;IFN TENEX
IFE TENEX,< OUTCHR R2 >			; LIST CHARACTER
	RETURN				; EXIT

LSTOU1:
IFN TENEX,<
	PUSH	P,R1
	HRROI	R1,[ BYTE(7) CRR,LF,0 ]
	PSOUT
	POP	P,R1
>;IFN TENEX
IFE TENEX,<
	OUTSTR	[BYTE (7) CRR, LF, 0]
>;IFE TENEX
	RETURN				; CR-LF TO TTY


LPTOUT:					; OUTPUT TO LISTING DEVICE
	TRNN	RERR,-1			; Is there an error on this line?
	 SKIPL	LSTCNT			;  or .NLST'd ?
	  TRNA				; No - output this character
	   RETURN			; Yes - return now doing nothing
LPTOUA:	TRZE	R16,HDRBIT		; TIME FOR A HEADING?
	 CALL	HEADER			;  YES
	JUMPE	R2,LPTOU4		; BRANCH IF CR-LF
	CAIN	R2,TAB
	 JRST	LPTOU3			; DON'T LIST TABS IMMEDIATELY
	SKIPG	TABCNT			; ANY TABS TO BE OUTPUT?
	 JRST	LPTOU2			;  NO
	PUSH	P,R2			; YES, STACK CURRENT CHARACTER
LPTOU1:	MOVEI	R2,7
	IORM	R2,COLCNT		; FUDGE COLUMN COUNT
	MOVEI	R2,TAB
	CALL	LPTOU2			; OUTPUT THE TAB
	SOSE	TABCNT			; DECREMENT, ANY MORE?
	 JRST	LPTOU1			; YES
	POP	P,R2			; NO, RESTORE CHARACTER

LPTOU2:	AOSG	COLCNT			; ANY COLUMNS AVAILABLE?
	 JRST	LSTDMP			;  YES
	RETURN				;  NO, EXIT

LPTOU3:	AOS	TABCNT			; TAB, BUMP COUNT
	RETURN

LPTOU4:	MOVEI	R2,CRR			; CR-LF
	CALL	LSTDMP
	MOVEI	R2,LF
	CALL	LSTDMP
	SOSG	LINCNT			; END OF PAGE?
LPTINI:	TRO	R16,HDRBIT		;  YES, SET FLAG
	MOVNI	R2,COLLPT		; SET FOR COLUMN COUNT
	HRRZ	R0,LSTCTL		; LOAD LIST CONTROL FLAGS
	TRNE	R0,LTTM			; IS IT TTY MODE?
	 MOVNI	R2,COLTTY
	MOVEM	R2,COLCNT
	SETZB	R2,TABCNT		; ZERO TAB COUNT AND REGISTER
	RETURN

LSTDMP:
IFN TENEX,<
	TLNE	R16,LSTBIT		; Need to print?
	 RETURN				; No, just return now
	IDPB	R2,LINPTR		; No - save it in the line
	SOSG	LSTBFC			; Full buffer?			[ECL2]
	 JRST	LSTDM1			; yes, dump the buffer		[ECL2]
	CAIE	R2,LF			; Dump the line?
	 RETURN				; Return now
LSTDM1:
	PUSH	P,R1			; Save some registers for SOUT
	PUSH	P,R2
	PUSH	P,R3
	SETZ	R3,			; ASCIZ string to output
	IDPB	R3,LINPTR		; Make it so
	MOVE	R1,LSTJFN		; Load listing JFN
	HRROI	R2,LSTBUF		; Get pointer to the output line buffer
	SOUT				; Dump it
	MOVE	R1,LSTPT1		; Load original string pointer
	MOVEM	R1,LINPTR		; Reset byte pointer
	MOVEI	R1,LSTBFL		; buffer length			[ECL2]
	MOVEM	R1,LSTBFC		; count left			[ECL2]
	POP	P,R3			; Restore clobbered registers
	POP	P,R2
	POP	P,R1
	RETURN				; Exit
>;IFN TENEX
IFE TENEX,<
	SOSG	LSTBCT			; DECREMENT ITEM COUNT
	 CALL	LIST1			; EMPTY ENTIRE BUFFER
	IDPB	R2,LSTPNT		; STORE THE CHARACTER
	CAIN	R2,LF			; IF LINE FEED
	 TLNN	R16,TTYBIT		; AND LISTING IS ON TTY,
	  RETURN
					; DUMP THE BUFFER


LIST1:	TLNE	R16,LSTBIT		; IS LISTING BEING SUPPRESSED?
	 RETURN				; .. YES - JUST RETURN.

	OUTPUT	LST,			; EMPTY A BUFFER
LSTTST:	STATO	LST,IODATA!IODEV!IOWRLK	; CHECK FOR ERRORS
	RETURN				; NO, EXIT
	MOVEI	R10,[ASCIZ /LISTING OUTPUT ERROR/]
	JRST	ERROR			; TYPE MESSAGE
>;IFE TENEX

;	   CODE BETWEEN CHARB AND CHAR SAVES A SEQUENCE NUMBER
;	   OF THE SORT SUPPLIED BY SOS AND SOME OTHER EDITORS.

;	THE SEQUENCE NUMBER IS IDENTIFIED BY FINDING THE LOW ORDER
;	BIT OF A DATA WORD SET TO 1; THE WORD ORDINARILY CONTAINS
;	FIVE 7-BIT BYTES, LEFT ADJUSTED.

CHARB:	MOVEM	R2,SEQNUM		; SAVE SEQUENCE NUMBER
	AOS	SRCPNT			; INCREMENT POINTER PAST WORD
	MOVNI	R14,5			; GET -5
	ADDM	R14,SRCCNT		; SUBTRACT 5 FROM WORD COUNT
IFE TENEX,<
	MOVEI	R14,5
	ADDM	R14,CHRCNT		; Fix total character count
>;IFE TENEX
	TRO	R16,SEQBIT

CHAR:
	JUMPN	R12,CHAR2		; BRANCH IF IN MACRO
CHAR1A:	SOSGE	SRCCNT			; DECREMENT ITEM COUNT
	 JRST	CHAR4			; GET ANOTHER BUFFER IF NECESSARY
IFE TENEX,<
	AOS	CHRCNT			; Total # of characters read in this file
>;IFE TENEX
	ILDB	RBYTE,SRCPNT		; LOAD NEXT BYTE
	MOVE	R2,@SRCPNT		; PICK UP THE WORD CONTAINING IT.
	TRZE	R2,1			; IS SEQUENCE # BIT ON?
	 JRST	CHARB			;    YES - JUST SAVE LINE #.
CHAR1:	LDB	R2,C7PNTR		; MAP CHARACTER TYPE.
	XCT	CHARTB(R2)		; DECIDE WHAT TO DO
	RETURN				; ACCEPT IT

CHAR2:	CALL	READMC			; GET A CHARACTER FROM MACRO TREE
	 JRST	CHAR			;  NULL, TRY AGAIN
	TLO	R16,MEXBIT		; SHOW MACRO EXPANSION IN PROGRESS
	JRST	CHAR1			; CHECK THE CHARACTER

CHAR4:
IFN TENEX,<
	MOVE	R14,R1			; Save R1
	PUSH	P,R3			; Save some other registers
	PUSH	P,R4
CHAR4C:
	SKIPE	R4,SRCFLG		; Are we PMAPing?
	 JRST	CHAR7S			; No - do a SIN
	AOS	R1,SRCPGN		; Increment page number
	MOVE	R2,[ XWD 400000,SPGMAP ]
	MOVSI	R3,160000		; All accesses
	PMAP				; Map it in
	HRRZ	R3,BSIZE		; Get file page count
	CAIN	R3,1(R1)		; Last page mapped in?
	 JRST	[ MOVE	R3,BCOUNT	; Yes - get last page byte count
		  JRST	CHAR4D ]	; Continue on
	CAIG	R3,(R1)			; All pages mapped?
	 JRST	CHAR4A			; Yes - get next file if any
	MOVEI	R3,^D512*5		; Set byte count for a full page
CHAR4D:	MOVEM	R3,SRCCNT		; Save it
	MOVE	R2,[ POINT 7,SPGMAP*^D512, ]
	MOVEM	R2,SRCPNT		; Set new string pointer
CHAR4B:	POP	P,R4			; Restore saved registers
	POP	P,R3
	MOVE	R1,R14			; All restored
	JRST	CHAR1A			; Get next byte
CHAR4A:
	TLNE	R16,REQBIT		; Were we in a .REQUIRE?
	 JRST	REQPOP			; Yes
	AOS	R2,SJFNIX		; Try to get next input file JFN
	SKIPN	R1,SRCTAB(R2)		; Load and test it
	 JRST	CHAR6			; All done
	CALL	SFINIT			; Init this file
	TRO	R16,HDRBIT		; New header page please
	JRST	CHAR4B			; Already mapped so get the bytes
CHAR6:					; No more input file test for end
	TLO	R15,ENDFLG		; Set flag to indicate so
	MOVEI	R14,LF			; End with LF
	POP	P,R4			; Restore saved registers
	POP	P,R3
	MOVE	R1,R14
	RETURN				; Back to caller

CHAR7S:					; Input is not on disk
	MOVE	R1,SRCJFN		; Get source JFN
	JUMPL	R4,CHAR4A		; File is closed so get next file
	TLZ	R4,-1			; Make sure LH is clear
	CAIN	R4,12			; Input from the terminal?
	 JRST	CHARTY			; Yes
	MOVE	R2,[ POINT 36,SPGMAP*1000, ]
	MOVNI	R3,SINLEN		; Get the byte count
	SIN				;  and read it in
	MOVEI	R2,SINLEN(R3)		; Calculate bytes read in
	MOVE	R3,[ POINT 7,SPGMAP*1000, ]
	MOVEM	R3,SRCPNT		; Reset string pointer
	IMULI	R2,5			; 5 bytes per word
	MOVEM	R2,SRCCNT		; Set new byte count of this buffer
	GTSTS				; Get status of the file
	TLNN	R2,(1B8)		; EOF?
	JRST	CHAR4B			; No - continue
	TLO	R1,(1B0)		; Don't release the JFN
	HLLM	R1,SRCFLG		; Set closed file bit
	CLOSF				; Close the file
	 JRST	JERR
	JRST	CHAR4B			;  and continue

; Source input is from the terminal, READIN is called to get the characters.

CHARTY:	MOVEI	R1,ABRKTB		; Load break character table address
	MOVE	R2,[ POINT 7,SPGMAP*1000, ] ; String pointer
	MOVEM	R2,SRCPNT		; Reset source input string pointer
	MOVEI	R3,SINLEN*5		; Maximum length of the string
	CALL	READIN			; Get a string
	HLRZ	R4,R1			; Get address
	JRST	(R4)			; Jump to it

TTYEOF:					; ^Z was typed signaling End-of-File
	PBOUT				; Echo the ^Z
	JUMPE	R3,CHAR4A		; If only ^Z then get next file
	MOVEI	R1,-1			; Mark EOF status in SRCFLG
	HRLM	R1,SRCFLG		;  and drop through

TTYEOL:					; LF or EOL marks end of the line
	HRROI	R1,$CRLF		; Output a CR-LF to get a new line
	PSOUT
	MOVEI	R1,CRR			; End a line with CR-LF
	IDPB	R1,R2			; Tack it on the string
	MOVEI	R1,LF			; LF
	IDPB	R1,R2			; Last byte
	ADDI	R3,2			; Don't forget the 2 bytes
	MOVEM	R3,SRCCNT		; Set the byte count
	JRST	CHAR4B			;  and process them


; Here we must pop off saved pointers and counts to get back to the source
; input that we were using prior to the .REQUIRE

REQPOP:
	MOVE	R4,REQSP		; Get back saved stack pointer
	POP	R4,R1			; Get back PAGE THROW flag
	CAIE	R1,0
	 TRO	R16,HDRBIT		; And if on, throw a page
	POP	R4,INPGNM		; Input page number
	POP	R4,SRCJFN		; Restore JFN of previous source file
	POP	R4,SRCPNT		;  byte pointer in this buffer
	POP	R4,SRCCNT		;  byte count
	POP	R4,SRCPGN		;  JFN,, file page number
	POP	R4,BCOUNT		;  last page byte count
	POP	R4,BSIZE		;  last file page number
	POP	R4,SRCVER		;  source file version number
	POP	R4,SRCFLG		;  type of source file flag word
	POP	R4,R1			;  JFN of the required file

	CAMN	R4,[ IOWD RQSTKL,REQSTK ] ; Back to original SP?
	 TLZ	R16,REQBIT		; Yes - out of .REQUIRE now
	MOVEM	R4,REQSP		; Save stack pointer
	TLNE	R15,P1F			; Are we in pass 1 or 2
	 JRST	REQRS2			; Skip over CLOSF if pass 1
	CLOSF				; Close the file
	 JFCL				; Ignore error
REQRS2:

; Here we should check if the file was on Disk and do the appropriate thing

	MOVE	R1,SRCPGN		; Get JFN,,file page number
	MOVE	R2,[ XWD 400000,SPGMAP ]
	MOVSI	R3,160000		; All access
	PMAP				; Map it in
	MOVSI	R4,DEFSYM		; Define .VRSN. to be the file version number
	HLR	R4,SRCVER		; Get version number
	PUSH	P,R0			; Save R0
	MOVE	R0,[ GENM40 .,V,R,S,N,. ]
	CALL	SSRCH			; Find it in the symbol table
	 JFCL				; Ignore not found return
	MOVE	R1,R4			; Load value
	CALL	INSRT			;  and insert it into the symbol table
	POP	P,R0			; Restore R0

; Now reset filename string

	HRROI	R1,SFILNM		; Get string pointer
	MOVE	R2,SRCJFN		; Then the JFN
	SETZ	R3,			; Default
	JFNS				;  and convert to a string
	JRST	CHAR4B			; Resume
>;IFN TENEX
IFE TENEX,<
	INPUT	SRC,			; CALL MONITIOR FOR A BUFFER
	STATZ	SRC, IODATA+IODEV+IOBKTL+IOWRLK
	JRST	ERRID			; INPUT TRANSMISSION ERROR
	STATO	SRC, IOEOF		; WAS AN END OF FILE REACHED?
	JRST	CHAR			; GET NEXT CHAR
	CLOSE	SRC,

	TLNE	R16,REQBIT		; In a .Require?
	JRST	REQPOP			;    Yes, pop require file.
	TRNN	R16,ENDBIT		; CRR SEEN BY COMMAND SCANNER?
	JRST	CHAR6			;  NO, GET NEXT SOURCE
	TLO	R15,ENDFLG		; YES, FLAG END
	MOVEI	R14,LF			; MAKE IT A LINE
	RETURN

CHAR6:	CALL	ACEXCH			; GET EXEC AC'S
	MOVSI	R1,'DSK'		; LOAD DEFAULT DEVICE NAME
	CALL	GETSRC			; GET THE NEXT SOURCE FILE
	TRO	R16,HDRBIT		; START NEW FILE
	CALL	ACEXCH			; SAVE EXEC AC'S AND RETURN
	JRST	CHAR

REQPOP:	CALL	ACEXCH			; GET EXEC ACS
	MOVE	R2,REQSP		; GET REQUIRE STACK POINTER
	POP	R2,R1			; Get back PAGE THROW flag
	CAIE	R1,0
	 TRO	R16,HDRBIT		; And if on, throw a page
	POP	R2,INPGNM		; Input page number
	POP	R2,CHRCNT		; GET OLD FILE'S CHARACTER COUNT
	POP	R2,XE3			; GET FILE PPN
	POP	R2,XE1			; GET FILE EXTENSION
	POP	R2,XE			; GET FILENAME
	POP	R2,SRCDEV		; GET DEVICE
	MOVE	R1,SRCDEV		; GET TO REG FOR GETSRC
	CAMN	R2,[ IOWD RQSTKL,REQSTK ] ; Back to original source?
	TLZ	R16,REQBIT		; REQUIRE IS NOW OVER
	MOVEM	R2,REQSP		; PUT BACK STACK POINTER
	PUSH	P,R16			; SAVE OLD FLAGS
	TRO	R16,EXTBIT		; FORCE EXPLICIT EXTENSION
	CALL	GETSR1			; DO MOST OF A GETSRC
	POP	P,R16			; GET BACK FLAGS
	CALL	ACEXCH			; GET ASSEMBLER ACS BACK
	MOVE	R2,CHRCNT		; PREPARE TO COUNT-DOWN
REQLP:	INPUT	SRC,			; GET A BUFFER
	STATZ	SRC,IODATA+IODEV+IOBKTL+IOWRLK+IOEOF ; CHECK SUCESS
	JRST	ERRID			; OOPS
	MOVE	R3,R2			; SAVE CURRENT # CHARS TO GO
	SUB	R2,SRCCNT		; SUBTRACT THIS BUFFER
	JUMPG	R2,REQLP		; NO OVERFLOW, KEEP GOING
	SOJ	R2,			; IBP IS FIRST, SO BUMP COUNT
	MOVNM	R2,SRCCNT		; FIX COUNT FOR THIS BUFFER
REQLP1:	IBP	SRCPNT			; INCREMENT BYTE POINTER
	SOJG	R3,REQLP1		; KEEP COUNT HONEST
	JRST	CHAR			; GO BACK FOR MORE
>;IFE TENEX


CHARTB:					; CHARACTER JUMP TABLE
	PHASE	0
	MOVEI	R14,ILLCHR		; ILLEGAL CHARACTER
QJNU:!	JRST	CHAR			; NULL, TRY AGAIN
QJCR:!	JFCL				; END OF STATEMENT
QJVT:!	MOVEI	R14,LF			; VERTICAL TAB
QJSP:!	JFCL				; BLANK
QJPC:!	JFCL				; PRINTING CHARACTER
QJLC:!	JRST	CHFOLD			; LOWER CASE, MAYBE FOLD
	DEPHASE


;	   LOWER CASE CHARACTER -- FOLD INTO UPPER CASE
;	   UNLESS .ENABL LC IS IN EFFECT.

CHFOLD:	TLNN	RMODE,LCFLG		; IS LOWER CASE ENABLED?
	SUBI	R14,40			; NO - FOLD INTO UPPER CASE.
	RETURN
	SUBTTL	ASSEMBLER PROPER

ASSEMB:					; ASSEMBLER PROPER
	TLO	R15,P1F			; SET FOR PASS 1
IFN TENEX,<
	MOVE	R1,[ XWD 21,2 ]		; ^Q for status report
	ATI				; Assign terminal code
>;IFN TENEX
	MOVE	R3,.MAIN.
	MOVEM	R3,PRGTTL		; INIT TITLE
	MOVE	R3,.ABS.
	MOVEM	R3,SECNAM		; INIT ABSOLUTE SECTOR
	CALL	INIPAS			; INITIALIZE PASS ONE
	CALL	BLKINI			; INITIALIZE BINARY OUTPUT
	CALL	LINE			; GO DO PASS ONE.
IFN CCLSW,<
	CALL	PRNAM			; PRINT THIS PROGRAM'S NAME IF CCL
>;IFN CCLSW
	TLZ	R15,P1F			; RESET TO PASS 2
	CALL	SETP2			; RESET INPUT COMMAND STRING
	TRO	R16,HDRBIT		; FORCE PAGE SKIP AFTER TOC.
	CALL	INIPAS
	CALL	LINE			; CALL THE ASSEMBLER (PASS TWO)
	TLNN	R16,BINBIT		; Binary file?
	 SKIPN	R3,BINPCT		;  and non-zero byte count
	  CAIA
	   CALL	BINOUT			; Yes - must output last word
	MOVE	R0,LSTCTL		; LOAD LISTING CONTROL FLAGS
	TLNN	R16,LSTBIT		; If listing's not suppressed
	 TRNN	R0,LSYM			; and symbol table requested
	  CAIA
	   CALL	SYMTB			;   then list symbol table;
					;   else don't.
IFN TENEX,<
	MOVEI	R1,21			; ^Q for status report
	DTI				; De-assign terminal code
>;IFN TENEX
	RETURN


INIPAS:
	MOVEI	R0,OCTRDX		; SET DEFAULT GLOBAL RADIX TO OCTAL
	MOVEM	R0,GLBRDX
	MOVEI	R0,^D8
	MOVEM	R0,RADVAL
	SETZM	LSTCNT			; Reset .list/.nlist level.
	HRLZI	R0,LDEF			; SET DEFAULT LISTING MODES.
	MOVEM	R0,LSTCTL
	CALL	SETLF

	HRLZI	R0,ENDEF		; SET DEFAULT .ENABL MODES.
	TLNE	RMODE,P1F		; IS THIS START OF PASS 2?
	JRST	INEN			;    NO -- JUST SET DEFAULTS.
	TLNE	RMODE,ABSFLG		;    YES - COPY ABS/REL MODE FLAG
	TLO	R0,ABSFLG		; AS PASS 1 LEFT IT.
INEN:	MOVEM	R0,ENACTL		; STORE ENABL FLAGS.
	CALL	SETEN			; MERGE WITH SWITCH OVERRIDES.

	TLNE	R15,ABSFLG		; ABSOLUTE?
	 TDZA	R5,R5			;  YES, SET PC TO ZERO
	  MOVSI	R5,(1B<SUBOFF>)		;  NO, SET TO RELOCATABLE
	SETZM	SECBAS			; CLEAR FIRST WORD
	MOVE	R3,[ XWD SECBAS,SECBAS+1 ]
	BLT	R3,SECBAS+^D255		; CLEAR ALL OF IT
	MOVEI	R0,^D64			; INITIAL VALUE FOR NEXT
	MOVEM	R0,NEXGS		; MACRO-GENERATED LOCAL = 64.
	SETZM	PAGNUM			; Initialize page number
	SETZM	SEQ			; SET LINE SEQ # = 0.
	SETOM	MCALLF			; Initialize .MCALL counter
	SETZM	LSBLOC			; LOCAL SYMBOL BLOCK # = 0.
	SETOM	IRPLVL			; Initialize .IRP(C) calling level
	SETZM	REPLVL
IFN TENEX,<
	MOVE	R0,REQBEG		; Get beginning index
	MOVEM	R0,REQIDX		;  and set it again
>;IFN TENEX
	SETZB	R12,CONLVL		; CLEAR MACRO BLOCK PTR & COND LVL.
	HRRM	R12,LSTCNT		; CLEAR RH OF LIST LEVEL.
	JRST	ENDLI			; EXIT THROUGH END OF LINE ROUTINE


LINE:					; PROCESS ONE LINE
	CALL	GETLIN			; GET A SOURCE LINE
	CALL	STMNT			; PROCESS ONE STATEMENT
	CALL	ENDLR			; PROCESS END OF LINE
	TLZN	R15,ENDFLG		; TEST FOR END STATEMENT
	JRST	LINE			; GET THE NEXT LINE
	JRST	ENDP			; END OF PASS

.MAIN.:	GENM40	.,M,A,I,N,.

.ABS.:	GENM40	., ,A,B,S,.


GETLIN:					; GET THE NEXT SOURCE LINE
	TLZ	R16,NLISLN!MEXBIT!FOLBIT ; RESET LIST-RELATED FLAGS
					; AND INPUT FOLDING OVERRIDE.
	AOS	SEQ			; INCREMENT LINE SEQUENCE #
	MOVEI	R6,1			; SET COUNT TO FIRST CHAR
	MOVE	R13,LINPNT		; SET POINTER
GETLI1:	CALL	CHAR			; GET AN INPUT CHARACTER
	CAIN	R14,FF			; FORM FEED?
	 TROA	R16,FFBIT		;  YES, FLAG AND SKIP
	  CAIN	R14,LF			; OR LINE FEED?
	   JRST	GETLI5			;  YES, END OF LIE
	CAIG	R6,CPL1			; PAST NORMAL END?
	 JRST	GETLI4			;  NO, STORE IT
	CAIE	R6,CPL1+1		; YES - IS THIS THE MAGIC
	 JRST	GETLI3			; COLUMN FOR CDR MODE?

;	   NEXT BYTE IS IN COLUMN 73 OF INPUT LINE.  IF
;	   .ENABL CDR WAS ISSUED, INPUT IS CARD IMAGES; IN
;	   THIS CASE SUPPLY AN END-LOGICAL-LINE CHARACTER
;	   IN ORDER TO TREAT SEQUENCE NUMBERS IN 73-80
;	   AS COMMENTARY INFORMATION.

	TLNN	RMODE,CDRFLG		; READING CARD IMAGES?
	 JRST	GETLI3			; NO - CHECK FOR OVERFLOW.
	MOVEI	R11,ELLCHR		; YES - SET END LINE CHARACTER
	IDPB	R11,R13			;  AND STORE IN BUFFER
	JRST	GETLI4			; ALSO STORE NORMAL CHAR

GETLI3:	CAIGE	R6,CPL3			; NORMAL MODE, SKIP IF OVERFLOW
	 JRST	GETLI4			;  OK, STORE IT
	TRO	R15,ERRL		;  NO, FLAG ERROR
	JRST	GETLI1			; DON'T STORE IN EITHER CASE

GETLI4:	IDPB	R14,R13			; OK, STORE CHARACTER IN BUFFER
	AOJA	R6,GETLI1		; BUMP COUNT AND LOOP

GETLI5:	IDPB	R14,R13			; END OF LINE, STORE
	SETZ	R14,
	IDPB	R14,R13			; STORE NULL FOR EASY REFERENCE
	TLNE	R15,ENDFLG		; PERCHANCE END OF FILE?
	TRO	R15,ERRE		;  YES, FLAG "NO END STATEMENTT"
	MOVE	R13,LINPNT		; SET FOR READ
	JRST	GETNB			; RETURN WITH FIRST NON-BLANK

LINPNT:	POINT	7,LINBUF		; POINTER TO START OF LINE

ENDLR:					; END OF LINE PROCESSOR
	MOVE	R2,[POINT 7,LINBUF,6]	; Initialize FLTCOL to beginning of line
	MOVEM	R2,FLTCOL		; in case there is no comment on this line
	TLNE	R15,P1F
	JRST	ENDLFA			; BYPASS IF PASS 1
	MOVE	R11,RBPTR		; SAVE POINTER TO CURRENT BYTE.
	CALL	SETNB			; SET FIRST NON-BLANK
	JUMPE	R14,ENDLF		; OK IF NULL
	CAIN	R14,";"			; If first non-blank is semi-colon,
	 JRST	[MOVEM R13,FLTCOL	; save comment pointer
		 JRST  ENDLF ]		; and branch o.k.

	SETZ	R11,			; NOT AT A COMMENT - CLEAR R11
					; TO SHOW NO COMMENT
	CAIN	R14,CRR			; CARRIAGE RETURN?
	 CALL	GETCHR			;  YES, BYPASS IT
	CAIE	R14,LF			; IF LINE FEED
	 CAIN	R14,FF			;  OR FORM FEED,
	  CAIA				;  O.K.
	   TRO	R15,ERRQ		; OTHERWISE FLAG Q ERROR

ENDLF:					; ENDL FIN
;	   THE NEXT FEW LINES HANDLE .NLIST COM.  THE CODE
;	   FOLLOWING LOCATION ENDL HAS LEFT R11 AS . . .
;		0 IF FIRST UNPARSED TEXT ISN'T COMMENT, OR
;		BYTE POINTER TO BEGINNING OF COMMENT.

	JUMPE	R11,ENDLFA		; SKIP COM CHECK IF NOT AT COMMENT.
	SETZ	R2,			; PREPARE NULL BYTE IN R2
	MOVE	R0,LSTCTL		; LOAD LISTING CONTROL FLAGS.
	TRNN	R0,LCOM			; ARE COMMENTS BEING LISTED?
	DPB	R2,R11			; NO - STORE NULL AT COM START.

;  WHEN THE LINE IS LISTED LATER THE NULL BYTE IS TAKEN AS A SIGNAL
;  TO STOP LISTING THE LINE.  THE CODE AT ENDL9 HANDLES THIS.

ENDLFA:	SETZM	CODPNT			; INITIALIZE FOR CODE OUTPUT
	CALL	PROCOD			; PROCESS CODE
	 JFCL				;  NO CODE, IGNORE THIS TIME
ENDLC:
	SETOM	BLNKLN			; Assume this line is non-blank
	TRZE	R15,ERRP1		; Print error message on Pass 1?
	 JRST	ENDLC1			; Yes
	TLNE	R15,P1F			; No - is this pass 1?
	 JRST	ENDL11			; Yes - skip this mess

;								[ECL2]
; check here for a completely blank line -- do not want		[ECL2]
; CREF to print a line number if so (looks neater)		[ECL2]
	MOVE	R0,LINPNT		; 			[ECL2]
	ILDB	R2,R0			; get the first character	[ECL2]
	CAIN	R2,CRR			; carriage return?		[ECL2]
	 ILDB	R2,R0			; yes, test next		[ECL2]
	CAIE	R2,LF			; if line feed			[ECL2]
	CAIN	R2,FF			; or form feed			[ECL2]
	 SETZ	R2,			;   don't list if nothing else	[ECL2]
	TDO	R2,PF0			; 			[ECL2]
	TDO	R2,PF1			; 			[ECL2]
	TDO	R2,SEQNUM		; 			[ECL2]
	SETAM	R2,BLNKLN		; BLNKLN is zero if want blank	[ECL2]
	TLNN	R16,CSWBIT		; CREF or MACN11 cref?
	 CALL	CRFLIN			; Output cref stuff
ENDLC1:	TRNN	R15,-1			; ANY ERRORS?
	JRST	ENDL6			;  NO
	AOS	ERRCNT			;  YES, TALLY ERROR COUNT
	TLZ	R16,NLISLN		; OVERRIDE LINE LIST SUPPRESSION
	TLO	R16,ERRBIT		; MESSAGE TO TTY
IFN TENEX,<
	MOVE	R1,SRCJFN		; Get current source file JFN
	CAMN	R1,XESAVE		; Same as before?
	 JRST	ENDL4			; Yes - don't print file name
	MOVEM	R1,XESAVE		; No - save it for next time and print filename
	HRROI	R1,SFILNM		; String pointer to current source file
	PSOUT				; Print it
	HRROI	R1,[ BYTE(7) ":",CRR,LF,0 ]
	PSOUT
>;IFN TENEX
IFE TENEX,<
	MOVE	R0,XE			; GET FILE NAME
	TLNN	R16,TTYBIT
	CAMN	R0,XESAVE
	JRST	ENDL4
	JUMPE	R0,ENDL4
	MOVEM	R0,XESAVE
	MOVSI	R1,(POINT 6,R0,)
ENDL2:	ILDB	R2,R1
	JUMPE	R2,ENDL3
	ADDI	R2,40
	OUTCHR	R2
	TLNE	R1,770000
	JRST	ENDL2
ENDL3:	OUTSTR	[BYTE (7) ":", CRR, LF, 0]
>;IFE TENEX
ENDL4:	HRLZ	R0,R15			; PUT FLAGS IN AC0 LEFT
	MOVE	R1,[POINT 7,[ASCII /ABDEILMOPQRTUNZ/],]
ENDL5:	ILDB	R2,R1			; FETCH CHARACTER
	CAIGE	R0,			; THIS CHARACTER?
	CALL	LSTOUT			;  YES
	LSH	R0,1
	JUMPN	R0,ENDL5		; TEST FOR END
ENDL6:	TLNE	R16,NLISLN		; SUPPRESS LIST OF THIS LINE?
	JRST	ENDL11			; YES - JUST CLEAN UP

	MOVE	R0,LSTCTL		; Get listing mode flags

;	   *** CHECK FOR MACRO EXPANSION LIST MODES ***

;	.LIST	ME		** LIST ALL GENERATED LINES
;	.NLIST ME, .LIST MEB	** LIST LINES WHICH GEN CODE
;	.NLIST ME, .NLIST MEB	** LIST NO EXPANDED LINES

	TLNN	R16,MEXBIT		; IS MACRO EXPANSION IN PROGRESS?
	JRST	ENDL6A			; ** NO - LIST THE LINE
	TRNE	RERR,-1			; ** YES - IF LINE HAD ERRORS
	JRST	ENDL6A			; LIST IT REGARDLESS OF OPTIONS.

	TRNE	R0,LME			; IS .LIST ME IN EFFECT?
	JRST	ENDL6A			; ** YES -  LIST THE LINE
	TRNE	R0,LMEB			; ** NO - .LIST MEB IN EFFECT?
	SKIPN	PF0			; %% YES - LIST IFF CODE WAS GEN'D
	JRST	ENDL11

;	   *** CHECK FOR COMPLETELY BLANK LINE TO BE LISTED ***
;		SUCH A LINE SHOULD BE LISTED AS ONLY CR/LF
;		FOR THE SAKE OF LISTING READABILITY & EFFICIENCY.

ENDL6A:
	SKIPN	BLNKLN			; blank line?			[ECL2]
	 JRST	ENDL9B			; yes				[ECL2]
	TRNN	R16,ASCBIT		; Suppress binary listing?
	 JRST	ENDL6B			; No - don't fiddle with listing mode
	TRNE	R16,EXLBIT		; Continuation of a line?
	 JRST	ENDL11			; Yes - skip all of this then
	PUSH	P,R0			; Save current listing mode
	TRZE	R0,LBIN			; Test binary listing bit and clear it
	 MOVEM	R0,LSTCTL		; Wasn't off so set this mode word
	CALL	PRNTA			; List it
	POP	P,LSTCTL		; Restore listing mode word
	CAIA				; Skip over binary listing call
ENDL6B:	 CALL	PRNTA			; LIST THE OCTAL
	TRNN	R16,SEQBIT		; ANY SEQUENCE NUMBERS ENCOUNTERED?
	 JRST	ENDL8			;  NO

;	   FORMAT A SEQUENCE NUMBER, SUPPLIED BY SOS OR
;	  ONE OF THE OTHER UNFRIENDLY EDITORS.

	CALL	LSTTAB			; OUTPUT A TAB
	MOVE	R0,[POINT 7,SEQNUM,]
ENDL7:	ILDB	R2,R0			; GET A CHARACTER
	JUMPE	R2,ENDL8		; BYPASS IF NULL
	CALL	LSTOUT			; OUTPUT THE NUMBER
	TLNE	R0,760000		; END OF WORD?
	 JRST	ENDL7			;  NO, TRY FOR MORE
ENDL8:	TRNE	RERR,-1			; DID LINE HAVE ERRORS?
	 JRST	ENDL8A			; YES - ALWAYS LIST SOURCE.
	MOVE	R0,LSTCTL		; NO - CHECK FOR .NLIST SRC.
	TRNN	R0,LSRC			; IS SOURCE LIST WANTED?
	 JRST	ENDL10			; NO - SKIP IT.

ENDL8A:	CALL	LSTTAB
	MOVE	R6,LINPNT		; GET SET TO PRINT LINE
ENDL9:	ILDB	R2,R6			; GET ANOTHER CHARACTER
	JUMPE	R2,ENDL10		; GET OUT IF DONE
	CAIN	R2,ILLCHR		; ILLEGAL?
	 MOVEI	R2,"?"			;  YES, REPLACE WITH QM
IFG ELLCHR-15,<
	CAIN	R2,ELLCHR		; END OF LOGICAL LINE CHAR?
	 JRST	ENDL9			;  YES, DON'T LIST
>;IFG ELLCHR-15
IFLE ELLCHR-15,<
	CAIE	R2,ELLCHR		; END OF LOGICAL LINE CHAR DOESN'T GET PRINTED
>;IFLE ELLCHR-15
	 CAIL	R2,12			; DON'T LIST IF BETWEEN LF
	  CAILE	R2,15			;  AND CARRIAGE RETURN
	   CALL	LSTOUT			; LIST A CHARACTER
	JRST	ENDL9				;AND LOOP

ENDL9B:	HRRO	R2,INPGNM		; SEE IF FORMFEED ALREADY PENDING
	AOJE	R2,ENDL10		;  If so, print blank line anyway
	TRNN	R16,FFBIT		; Suppress blank lines of FF only
ENDL10:	 CALL	LSTCR			; END,LIST CR/LF
ENDL11:	CALL	ENDLIF			; SEMI-INIT LINE
	TRO	R16,EXLBIT		; FLAG EXTENSION
	CALL	PROCOD			; PROCESS ADDITIONAL CODE, IF ANY
	 SKIPE	FLTBUF			; None, is there expanded floating to list?
	  CAIA				;   Yes, list on extension line
	   JRST	ENDL12			;   No, no more to list

;	    ******  BINARY EXTENSION PROCESSING  *******

	SKIPE	FLTBUF			; Expanded floating point comment to list?
	 CALL	FLTCOP			;   Yes, copy it into line buffer
	TLO	R16,BEXBIT		; FLAG STATE OF LISTING EXTENSION.
	MOVE	R0,LSTCTL		; CHECK LIST OPTIONS --
	TRNN	R0,LBEX			; ARE BINARY EXTENSIONS TO LIST?
	 TLO	R16,NLISLN		; NO - DON'T LIST EXTENSION LINES.
	JRST	ENDLC			; IN ANY CASE, GENERATE CODE.

ENDL12:	TLNN	R15,P1F			; Ignore if pass 1
	 TRNN	R16,FFBIT		; FORM FEED ENCOUNTERED?
	  JRST	ENDLI			;  NO
	TLNE	R16,MEXBIT		; MACRO EXPANSION IN PROGRESS?
	 JRST	ENDL13			; YES, DON'T BUMP PAGE NUMBER
	AOS	INPGNM			; Skip to next page.
	HLLOS	INPGNM
ENDL13:	TLNN	R16,NLISLN		; Is this line listed?
	 SKIPGE	LSTCNT			;  or .NLIST'd?
	  JRST	ENDLI			;   Yes - don't set header bit
	TRO	R16,HDRBIT		;  THEN SET HEADER BIT
ENDLI:	SETZM	CODPNT
	TRZ	R16,ASCBIT!FFBIT	; Reset ASCII output flag and formfeed bit
ENDLIF:	AND	R5,[PCMASK]		; CLEAN UP PC
	SETZM	GLBPNT			; CLEAR GLOBAL POINTER
	SETZM	PF0			; CLEAR PRINT WORDS
	SETZM	PF1
	SETZM	PF2
	SETZM	PF3
	SETZB	R2,SEQNUM
	SKIPN	FLTBUF			; Don't clobber byte if listing .FLTn
	DPB	R2,[POINT 7,LINBUF,6]	; FLAG LINE
	TRZ	R15,-1
	TRZ	R16,EXLBIT
	TLZ	R16,ERRBIT!LBLBIT!PF1BIT!BEXBIT
	RETURN

STMNT:					; STATEMENT PROCESSOR
	CALL	GETSYM			; TRY FOR SYMBOL
	 JRST	STMNT3			;  NO
	CAIN	R14,":"			; LABEL?
	JRST	LABEL			;  YES
	CAIN	R14,"="			; ASSIGNMENT?
	 JRST	ASGMT			;  YES
	CALL	MSRCH			; TEST FOR MACRO
	 CAIA
	  JRST	STMNT1			; YES
	CALL	OSRCH			; NO, TRY OP TABLE
	 JRST	STMNT2			; TREAT AS EXPRESSION
	TLNE	R16,CSWBIT		; Cross reference on op-codes?
	 JRST	STMNT4			; Cross ref not available for ops.

STMNT1:	PUSH	P,R1
	TLNE	R0,MACBIT		; SPECIAL TEST FOR OPDEFS
	MOVSI	R1,MAOP			;  SET TO MACRO
	CALL	CRFREF			; CREF IT
	POP	P,R1			; RETRIEVE VALUE/TYPE
	LDB	R2,TYPPNT		; RESTORE TYPE
STMNT4:	XCT	STMNJT(R2)		; EXECUTE TABLE

STMNJT:					; STATEMENT JUMP TABLE
	PHASE	0
	JRST	STMNT2			; BASIC SYMBOL
MAOP:!	JRST	CALLM			; MACRO
OCOP:!	JRST	PROPC			; OP CODE
DIOP:!	JRST	0(R1)			; PSEUDO-OP
	DEPHASE

STMNT2:	MOVE	R13,SYMBEG		; NON-OP SYMBOL, RESET CHAR POINTER
STMNT3:	CALL	SETNB			; SET CURRENT CHAR
	CAIE	R14,";"			; IF SEMI-COLON
	CALL	TSTNT			;  OR LINE TERMINATOR,
	 RETURN				;  NULL LINE
	JRST	.WORD			; NEITHER, TREAT AS ".WORD"

LABEL:					; LABEL PROCESSOR
	TLO	R16,LBLBIT		; FORCE PC TO LIST IN
	TLNN	R0,200000		; IS THIS A LOCAL SYMBOL?
	CALL	LOCRES			; NO - RESET LOCAL SYMBOL BLOCK

	MOVEM	RLOC,PF0		; PRINT FIELD 0
	CALL	SSRCH			; SEARCH THE SYMBOL TABLE
	 JRST	LABEL1			;  NOT THERE
	TLNE	R1,REGSYM		; REGISTER?
	JRST	LABEL2			;  YES, ERROR
LABEL1:	TLNN	R1,DEFSYM		; PREVIOUSLY DEFINED?
	TDO	R1,R5			;  NO, SET TO CURRENT PC
	MOVE	R3,R1
	TDC	R3,R5			; COMPARE WITH PC
	TDNN	R3,[PCMASK]		; EQUAL ON MEANINGFUL BITS?
	JRST	LABEL3			;  YES
LABEL2:	TLNN	R15,P1F			; NO, PASS 1?
	 TLNE	R1,MDFSYM		; NO, MULTIPLY DEFINED ALREADY?
	  TLOA	R1,MDFSYM		;  YES, FLAG SYMBOL
	   TRO	R15,ERRP		; NO, PHASE ERROR
	CAIA
LABEL3:	 TLO	R1,LBLSYM!DEFSYM	; OK, FLAG AS LABEL
	CALL	GETNB			; SKIP ":".
	CAIE	RBYTE,":"		; IS NEXT BYTE ANOTHER ":"?
	 JRST	LABEL5			;    NO -- CHECK HALF-KILLED
	TLO	R1,GLBSYM		;    YES - FLAG LABEL AS GLOBAL,
	CALL	GETNB			;	SKIP THE SECOND ":".
LABEL5:	CAIE	RBYTE,"!"		; HALF-KILLED?
	 JRST LABEL4			; NO -- LEAVE IT ALONE
	TLO	R1,HFKSYM		; YES -- MARK HALF-KILLED
	CALL	GETNB			; SKIP PAST IT

LABEL4:	CAMN	R0,M40DOT		; PERCHANCE PC?
	 TROA	R15,ERRM		;  YES, FLAG ERROR AND SKIP
	  CALL	INSRT			; INSERT/UPDATE
	TLNE	R1,MDFSYM		; MULTIPLY DEFINED?
	 TRO	R15,ERRM		;  YES
	CALL	CRFDEF			; CREF IT
	JRST	STMNT			; RETURN TO STATEMENT EVALUATOR

ASGMT:					; ASSIGNMENT PROCESSOR
	PUSH	P,[0]			; SAVE SYMBOL FLAGS (NONE SO FAR)
	PUSH	P,R0			; SAVE SYMBOL ON STACK.
	CALL	GETNB			; GET CHARACTER AFTER "=".
	CAIE	RBYTE,"="		; IS NEXT CHAR ANOTHER "="?
	 JRST	ASGMT4			;    NO -- SYMBOL'S LOCAL.
	HRLZI	R1,GLBSYM
	IORM	R1,-1(P)		; REMEMBER FOR LATER
	CALL	GETNB			; SKIP 2ND "=".
ASGMT4:	CAIE	RBYTE,"!"		; WANT TO HALF-KILL IT?
	 JRST ASGMT3			; NO.
	HRLZI	R1,HFKSYM
	IORM	R1,-1(P)		; REMEMBER FOR LATER
	CALL	GETNB			; SKIP OVER THE !

ASGMT3:	CALL	RELEXP
	JRST	SYMDE1

SYMDEF:	PUSH	P,0(P)
	SETZM	-1(P)
SYMDE1:	MOVE	R3,R10
	TLO	R3,DEFSYM		; BE SURE ZERO PRINTS
	MOVEM	R3,PF1			; SET PRINT FIELD
	POP	P,R0			; RETRIEVE SYMBOL
	CALL	SSRCH			; SEARCH TABLE
	 JFCL				;  NOT THERE YET
	IORM	R1,0(P)			; OR IN THE REMEMBERED FLAGS
	POP	P,R1
	TLNE	R15,HFKFLG		; .5K OPTION ON?
	 TLC	R11,HFKSYM		; INVERT MEANING OF HFK BIT
	TLNE	R1,LBLSYM		; LABEL?
	JRST	ASGMT1			;  YES, ERROR
	AND	R1,[XWD GLBSYM!MDFSYM!HFKSYM,0] ; MASK
	TRNN	R15,ERRU		; ANY UNDEFINED SYMBOLS?
	TLO	R1,DEFSYM		;  NO, FLAG AS DEFINED

	TDOA	R1,R10			; MERGE NEW VALUE
ASGMT1:	 TLOA	R1,MDFSYM		;  ERROR, FLAG AS MULTIPLY DEFINED
	  TLNE	R1,MDFSYM		; EVER MULTIPLY DEFINED?
	   TRO	R15,ERRM		;  YES
	CAMN	R0,M40DOT		; Is location counter being set?
	  JRST	BLKB1			;    Yes - Can't treat as normal symbol.
	CALL	INSRT			;    No -- Insert symbol in sym table,
	JRST	CRFDEF			;	   set cross ref definition,
					;	   return directly from CRFDEF.

BLKB1:	CALL	TSTMAX			; TEST FOR NEW HIGH
	LDB	R2,SUBPNT		; GET CSECT OF EXPR
	LDB	R3,CCSPNT		; GET CSECT OF PC
	CAME	R2,R3			; CURRENT SECTOR?
	JRST	ASGMT2			;  NO, ERROR
	CALL	INSRT			; INSERT SYMBOL IN TABLE
	HRLI	R1,(<RLDT10>B<MODOFF>)	; SET CLASS 10
	JRST	STCODE			; STOW CODE & EXIT

ASGMT2:	TRO	R15,ERRA		;  ERROR, DON'T STORE
	RETURN

PROPC:					; PROCESS OP CODES
	CALL	TSTEVN			; MAKE SURE WE'RE EVEN
	LDB	R2,SUBPNT		; GET CLASS
	HRLI	R1,BC2
	MOVEM	R1,OPCODE		; STORE OP
	SETZM	OFFSET			; CLEAN UP FOR AEXP
	SETZM	ADREXT
	SETZM	ADREXT+1
	XCT	PROPCT(R2)		; EXECUTE TABLE BY SUB-CLASS
	SKIPE	R1,OPCODE		; FETCH OP-CODE
	CALL	STCODE			; STOW CODE
	SKIPE	R1,ADREXT		; EXTENSION?
	CALL	STCODE			;  YES, STORE IT
	SKIPE	R1,ADREXT+1
	CALL	STCODE			; DITTO
	LDB	R1,[POINT 3,OPCODE,35-12]
	JUMPN	R1,PROPC1
	LDB	R1,[POINT 13,OPCODE,35-3]
	CAIN	R1,00012
	 JRST	PROPC2
	TRZ	R1,00070
	CAIN	R1,00402
	 JRST	PROPC2
	RETURN

PROPC1:	CAILE	R1,6
	RETURN
	LDB	R1,[POINT 6,OPCODE,35-6]
	TRNE	R1,70
	RETURN
	LDB	R2,[POINT 6,OPCODE,35]
	XOR	R2,R1
	CAIE	R2,20
	CAIN	R2,40
PROPC2:	TRO	R15,ERRZ
	RETURN

PROPCT:
	PHASE	0
	HALT
OPCL0:!	JFCL
OPCL1:!	CALL	POPCL1
OPCL2:!	CALL	POPCL2
OPCL3:!	CALL	POPCL3
OPCL4:!	CALL	POPCL4
OPCL5:!	CALL	POPCL5
OPCL6:!	CALL	POPCL6
OPCL7:!	CALL	POPCL7
OPCL8:!	CALL	POPCL8
OPCL9:!	CALL	POPCL9
OPCL10:! CALL	POPC10
OPCL11:! CALL	POPC11
OPCL12:! CALL	POPC12
OPCL13:! CALL	POPC13
OPCL14:! CALL	POPC14
	DEPHASE

POPCL1:	CALL	AEXP		; PROCESS ADDRESS EXPRESSION
	DPB	R0,[POINT 6,OPCODE,35]
	RETURN

POPCL2:	CALL	AEXP
	DPB	R0,[POINT 6,OPCODE,35-6]
POP2ND:	CALL	TSTCOM
	CALL	AEXP
	DPB	R0,[POINT 6,OPCODE,35]
	RETURN

POPCL3:	CALL	REGEXP
	DPB	R10,[POINT 3,OPCODE,35]
	RETURN

POPCL4:					; PROCESS BRANCH ON CONDITION
	CALL	EXPRF			; EVALUATE EXPRESSION
	JRST	PBCOP2			;  NULL, ERROR
	SUBI	R10,2(R5)		; COMPUTE E-.-2
	ROT	R10,-1			; /2, ODD BIT TO SIGN
	TRNE	R10,040000		; WAS IT NEG?
	TRO	R10,100000		;   YES-PROPOGATE SIGN.
	TRNE	R10,000200		; NEGATIVE?
	TRC	R10,177400		;  YES, TOGGLE HIGH BITS
	TRNN	R10,177400		; ANY OVERFLOW?
	JUMPGE	R10,PBCOP1		;  NO, BRANCH IF EVEN
PBCOP2:	MOVNI	R10,1			;  YES, SET TO JMP .
	TRO	R15,ERRA		; FLAG ERROR
PBCOP1:	DPB	R10,[POINT 8,OPCODE,35]
	RETURN

POPCL5:	CALL	REGEXP
	DPB	R10,[POINT 3,OPCODE,35-6]
	JRST	POP2ND

POPCL6:	CALL	EXPR			; EVALUATE THE EXPRESSION
	 JFCL				;  NULL, TREAT AS ZERO
	CALL	TSTAR			; TEST ARITHMETIC
	TRZE	R1,177400		; OVERFLOW?
	TRO	R15,ERRA		;  YES
	LDB	R3,MODPNT		; FETCH CLASS
	CAIE	R3,RLDT1		; IF ONE
	CAIN	R3,RLDT15		;  OF FIFTEEN,
	 TRO	R15,ERRA		; RELOCATION ERROR
	CAIE	R3,			; ABSOLUTE?
	 TRO	R3,200			;  NO, MAKE BYTE MODIFICATION
	DPB	R3,MODPNT
	IORM	R1,OPCODE		; MERGE WITH BASIC
	RETURN

POPCL9:					; OLD ASH/ASHC MODES

POPCL7:	CALL	AEXP
	DPB	R0,[POINT 6,OPCODE,35]
	CALL	TSTCOM
	CALL	REGEXP
	DPB	R10,[POINT 3,OPCODE,35-6]
	RETURN

POPCL8:	CALL	REGEXP
	DPB	R10,[POINT 3,OPCODE,35-6]
	CALL	TSTCOM
	CALL	EXPR
	 TRO	R15,ERRA
	MOVE	R1,R5
	ADDI	R1,2
	MOVEI	R0,1			; AVOID FLAG FROM EXPRMI BY
	MOVEM	R0,RELLVL		; SET RELOC LEVEL TO 1.
	CALL	EXPRMI
	 TRO	R15,ERRA
	CALL	ABSTST
	TRNE	R10,177601		; EVEN AND IN BOUNDS?
	TRO	R15,ERRA		;  NO, ERROR
	LSH	R10,-1
	DPB	R10,[POINT 6,OPCODE,35]
	RETURN

POPC10:	CALL	ABSEXP
	TRNE	R10,177700
	TRO	R15,ERRT
	DPB	R10,[POINT 6,OPCODE,35]
	RETURN

POPC11:	CAIE	R14,"#"
	JRST	POPC1B
	PUSH	P,R13
	CALL	GETNB
	MOVEI	R3,1
	MOVEM	R3,FLTLEN		; SET LENGTH FOR ROUNDING
	CALL	FLTG
	POP	P,R0
	TLNE	R15,FLTFLG
	JRST	POPC1A
	HRRZ	R10,FLTNUM
	TLO	R10,BC2
	AOS	R2,OFFSET
	MOVEM	R10,ADREXT-1(R2)
	MOVEI	R0,27
	JRST	POPC1C

POPC1A:	MOVE	R13,R0
	CALL	SETCHR
POPC14:					; NEW CLASS 14
POPC1B:	CALL	AEXP
POPC1C:	DPB	R0,[POINT 6,OPCODE,35]
	CALL	TSTCOM
	CALL	REGEXP
	TRNE	R10,177774
	TRO	R15,ERRA
	DPB	R10,[POINT 2,OPCODE,35-6]
	RETURN

POPC12:	CALL	REGEXP
	TRNE	R10,177774
	TRO	R15,ERRA
	DPB	R10,[POINT 2,OPCODE,35-6]
	JRST	POP2ND

POPC13:	CALL	ABSEXP
	TRNE	R10,177770
	TRO	R15,ERRA
	DPB	R10,[POINT 3,OPCODE,35]
	RETURN

TSTCOM:
	CAIN	R14,","
	JRST	GETNB
	TRO	R15,ERRA
	POP	P,0(P)
	RETURN

	SUBTTL	EXPRESSION HANDLERS

AEXP:					; "A" EXPRESSION EVALUATOR
	PUSH	P,[0]			; STACK INITIAL VALUE
AEXP01:	CALL	SETNB			; GET A NON-BLANK
	CAIN	R14,"#"
	JRST	AEXP02
	CAIN	R14,"%"
	JRST	AEXP04
	CAIN	R14,"("
	JRST	AEXP06
	CAIN	R14,"-"
	JRST	AEXP07
	CAIN	R14,"@"
	JRST	AEXP08
	JRST	AEXP10			; NO UNARIES, PROCESS BASIC EXPRESSION


;   AEXP2A FORCES MODE 3 ADDRESS GENERATION INSTEAD OF
;   MODE 6.  CONTROL REACHES AEXP2A FROM THE AEXP10 BLOCK
;   IF A .ENABL AMA DIRECTIVE IS IN EFFECT.

AEXP2A:	TRO	R0,37			; SET MODE 3 WITH PC
	PUSH	P,R0			; STACK IT.
	JRST	AEXP2B			; CONTINUE AS IF "@#" EXPR

AEXP02:					; #
	CALL	GETNB			; BYPASS UNARY OP
	CALL	EXPRF			; EVALUATE EXPRESSION
	 TRO	R15,ERRQ		;  NULL, ERROR
AEXP2B:	CALL	TSTAR			; TEST ARITHMETIC
	POP	P,R0			; RETRIEVE PRESET VALUE
	TRO	R0,27			; SET BITS
	AOS	R2,OFFSET		; GET OFFSET
	MOVEM	R1,ADREXT-1(R2)		; STORE ADDRESS
	RETURN				; EXIT

AEXP04:					; %
	CALL	REGEXP			; EVALUATE REG EXPRESSION
	POP	P,R0			; RETRIEVE CODE
AEXP05:	TRZE	R10,-10			; ANY OVERFLOW?
	 TROA	R15,ERRR		;  YES, FLAG ERROR AND SKIP
	  TRO	R0,00(R10)		; SET BITS
	RETURN				; EXIT

AEXP06:					; (
	CALL	AEXP20			; EVALUATE PARENTHESES
	SETZ	R1,			; ZERO IN CASE OF INDEX
	CAIE	R14,"+"			; FINAL "+" SEEN?
	JRST	AEXP13			;  NO, GO SEE IF (R) OR @(R)?
	POP	P,R0			; YES, RETRIEVE CODE
	TRO	R0,20(R10)		; SET BITS
	JRST	GETNB			; BYPASS DELIMITER AND EXIT

AEXP13:	POP	P,R0			; GET CODE
	TRON	R0,10			; IS "@" SET?
	JRST	AEXP05			; NO-REGISTER MODE
	PUSH	P,R0			; YES-INDEX MODE
	JRST	AEXP12


AEXP07:					; -(
	MOVEM	R13,SYMBEG		; SAVE POINTER IN CASE OF FAILURE
	CALL	GETNB			; GET THE NEXT NON-BLANK
	CAIE	R14,"("			; PARENTHESIS?
	 JRST	AEXP09			;  NO, TREAT AS EXPRESSION
	CALL	AEXP20			; YES, EVALUATE
	POP	P,R0			; RETRIEVE CODE
	TRO	R0,40(R10)		; SET BITS
	RETURN				; EXIT

AEXP08:					; @
	POP	P,R0			; RETRIEVE BASIC CODE
	TROE	R0,10			; SET INDIRECT BIT, WAS IT BEFORE?
	TRO	R15,ERRQ		;  YES, FLAG ERROR
	PUSH	P,R0			; RE-STACK CODE
	CALL	GETNB			; BYPASS CHARACTER
	JRST	AEXP01			; GO BACK TO BEGINNING

AEXP09:					; -( FAILURE
	MOVE	R13,SYMBEG		; GET POINTER TO "-"
	CALL	SETNB			; RESTORE CHARACTER
AEXP10:					; NO UNARIES
	CALL	EXPR			; EVALUATE EXPRESSION
	 TRO	R15,ERRQ		;  NULL, ERROR
	CAIN	R14,"("			; ANOTHER EXPRESSION?
	JRST	AEXP11			;  YES, BRANCH
	POP	P,R0			; RETRIEVE CODE
	TLNE	R10,REGSYM		; REGISTER EXPRESSION?
	JRST	AEXP05			;  YES, TREAT AS %

	TRNE	R0,10			; IS MODE ALREADY DEFERRED?
	JRST	AEXP1E			;    YES -- HAS TO BE MODE 7.
	TLNE	RMODE,AMAFLG		; .ENABL AMA IN EFFECT?
	JRST	AEXP2A			; YES - FORCE ABS MODE ADDRESS

AEXP1E:	TRO	R0,67			; SET BITS FOR INDEXED BY PC.
	MOVE	R1,R10
	LDB	R2,SUBPNT		; GET RELOCATION
	HRLI	R1,BC2			; TWO DATA BYTES
	MOVEI	R3,RLDT6		; ASSUME EXTERNAL
	TLNE	R10,GLBSYM
	JRST	AEXP1B			;  TRUE, OK AS IS
	LDB	R6,CCSPNT		; FETCH CURRENT SEG
	CAME	R2,R6			; SAME SEG?
	JRST	AEXP1A			;  NO, FURTHER TESTING REQUIRED
	SUBI	R10,4(R5)		; YES, COMPUTE OFFSET
	SKIPE	OFFSET			; THIRD WORD?
	SUBI	R10,2			;  YES, TWO MORE FOR GOOD MEASURE
	DPB	R10,[POINT 16,R1,35]	; STORE RESULT
	JRST	AEXP1D			; BRANCH TO EXIT

AEXP1A:	MOVEI	R3,RLDT3	; OK FOR QUICKIE?
	JUMPE	R2,AEXP1C		;  YES, IF TO ABS SEG
	MOVE	R4,SECNAM(R2)
	AOS	R2,GLBPNT
	MOVEM	R4,GLBBUF(R2)		; STORE IN GLOBAL TEMP
	MOVEI	R3,RLDT16		; TYPE #16
AEXP1B:	DPB	R2,SUBPNT		; STORE GLOBAL BUFFER POINTER
AEXP1C:	DPB	R3,MODPNT		; STORE MODE
AEXP1D:	AOS	R2,OFFSET
	MOVEM	R1,ADREXT-1(R2)
	RETURN


AEXP11:					; E1(E2)
	TLNE	R10,REGSYM		; REGISTER EXPRESSION?
	TRO	R15,ERRR		;  YES, ERROR
	PUSH	P,R10			; STACK E1
	CALL	AEXP20			; PROCESS EXPRESSION
	POP	P,R1			; RETRIEVE E1
AEXP12:	DPB	R10,[POINT 3,0(P),35]	; STORE REG
	MOVE	R10,R1
	CALL	TSTAR			; TEST MODE
	AOS	R2,OFFSET
	MOVEM	R1,ADREXT-1(R2)		; STORE ADDRESS
	POP	P,R0			; RETRIEVE CODE BITS
	TRO	R0,60			; COMPLETE CODE
	RETURN				; EXIT

AEXP20:					; ()
	CALL	GETNB			; BYPASS PAREN
	CALL	REGEXP			; EVALUATE REGISTER EXPRESSION
	CAIE	R14,")"			; PROPER DELIMITER?
	 TROA	R15,ERRQ		;  NO, FLAG ERROR AND SKIP
	  CALL	GETNB			;  YES, BYPASS CHARACTER
	JRST	SETNB			; RETURN WITH NON-BLANK DELIMITER

TSTAR:					; TEST ADDITIVE RELOCATION  (0,1,5,15)
	MOVE	R1,R10			; COPY TO FINAL AC
	LDB	R2,SUBPNT		; GET RELOCATION
	HRLI	R1,BC2			; SET FOR TWO BYTES
	JUMPE	R2,CPOPJ		; EXIT IF ABS
	MOVEI	R3,RLDT5		; ASSUME EXTERNAL
	TLNE	R10,GLBSYM		; GLOBAL?
	JRST	TSTAR1			;  YES
	MOVEI	R3,RLDT1
	LDB	R6,CCSPNT
	CAMN	R2,R6			; CURRENT SECTOR?
	JRST	TSTAR2			;  YES
	MOVE	R6,SECNAM(R2)
	AOS	R2,GLBPNT
	MOVEM	R6,GLBBUF(R2)		; STORE SECTOR NAME
	MOVEI	R3,RLDT15		; TYPE 15
TSTAR1:	DPB	R2,SUBPNT
TSTAR2:	DPB	R3,MODPNT
	RETURN
EXPR:					; EXPRESSION PROCESSOR, REGISTER ALLOWED

EXPRF:					; EXPRESSION FIN, NO REGISTERS ALLOWED
	MOVE	R2,GLBRDX		; GET GLOBAL RADIX
	TLNE	R15,HOVFLG		; CHECK IF HEX OVERRIDE ENABLED
	TRO	R2,HEXENB		;  YES, SET HEXENB IN LOCRDX
RADEXP:	MOVEM	R2,LOCRDX		; MOVE TO LOCAL RADIX
	SETZB	R6,RELLVL		; CLEAR RELOCATION LEVEL COUNT
	CALL	EXPR0			; GO EVALUATE EXPRESSION
	 RETURN				;  NULL, EXIT
	SOSLE	RELLVL			; RELOCATION LEVEL .GT. 1?
	 TRO	RERR,ERRA		;  YES, FLAG ERROR
CPOPJ1:	AOS	(P)			; Return + 2
CPOPJ:	RETURN				; Back to caller

EXPR0:					; EXPRESSION PROCESSOR
	PUSH	P,LOCRDX		; SAVE CURRENT RADIX
	CALL	TERM			; GET THE FIRST TERM
	 JRST	EXPEX			;  NULL, GO EXIT
	POP	P,LOCRDX		; RESTORE RADIX
	CALL	EXPRPX			; SET RELOCATION LEVEL
EXPR1:	LDB	R2,C4PNTR		; MAP NEXT CHAR USING COLUMN 4
	XCT	EXPRJT(R2)		; EXECUTE TABLE TO SAVE OP ADDR
	CALL	GETNB			; GET THE NEXT NON-BLANK CHAR
EXPR2:	HRLM	R2,0(P)			; AND SAVE OP ADDRESS
	PUSH	P,R10			; STACK CURRENT VALUE
	PUSH	P,LOCRDX		; SAVE CURRENT RADIX
	CALL	TERM			; GET NEXT TERM
	 TRO	RERR,ERRQ		;  NULL, FLAG ERROR
	POP	P,LOCRDX		; RESTORE RADIX
	POP	P,R1			; GET PREVIOUS VALUE
	HLRZ	R2,0(P)			;  AND OPERATOR
	CALL	0(R2)			; PERFORM OPERATOR
	 TRO 	RERR,ERRA		;  IF ERROR, FLAG IT
	TRZ	R10,600000		; CLEAR ANY OVERFLOW
	JRST	EXPR1			; TEST FOR MORE

EXPR3:					; OPERATOR POSSIBLY OMITTED
	TRO	RERR,ERRQ		; FLAG ERROR: MISSING OP
	MOVEI	R2,EXPRPL		; SIMULATE "+"
	JRST	EXPR2			; CONTINUE

EXPEX:	POP 	P,LOCRDX		; RESTORE RADIX
	RETURN				; EXIT


EXPRJT:					; EXPRESSION JUMP TABLE
	PHASE	0
	JRST	CPOPJ1			; NOT AN OP NOR TERM; EXIT
EXTE:!	JRST	EXPR3			; POSSIBLE TERM; SIMULATE "+"
EXPL:!	MOVEI	R2,EXPRPL		; +
EXMI:!	MOVEI	R2,EXPRMI		; -
EXOR:!	MOVEI	R2,EXPROR		; !
EXAN:!	MOVEI	R2,EXPRAN		; &
EXMU:!	MOVEI	R2,EXPRMU		; *
EXDV:!	MOVEI	R2,EXPRDV		; /
EXSH:!	MOVEI	R2,EXPRSH		; _ (LOGICAL SHIFT)
	DEPHASE


EXPRPL:					; +
	TDZA	R6,R6			; ZERO FOR ADD
EXPRMI:					; -
	 HRROI	R6,1			; ONE FOR SUBTRACT
	CALL	EXPRPX			; UPDATE RELOCATION COUNT
EXPRP1:	LDB	R2,SUBPNT		; GET RELOCATION
	EXCH	R10,R1
	LDB	R3,SUBPNT
	TLNE	R1,REGSYM
	 TLO	R10,REGSYM		; TRANSFER REGISTER FLAG
	JUMPE	R3,EXPRM1		; BRANCH IF SUBTRACTING ABS
	TLON	R6,-1			; NOT ABS, FIRST-TIME ADDITION?
	 JRST	EXPRP1			;  YES, REVERSE
	TLNN	R1,GLBSYM		; IF EITHER IS GLOBAL,
	 TLNE	R10,GLBSYM
	  JRST	EXPRM2			;  ERROR
	CAME	R2,R3			; LAST CHANCE, BOTH SAME RELOCATION
	 JRST	EXPRM2			;  FORGET IT
	SKIPN	RELLVL			; IF BACK TO ZERO,
	 TLZ	R10,(PFMASK)		; MAKE ABSOLUTE
EXPRM1:	AOS	0(P)			; INDICATE GOOD RESULT
EXPRM2:	XCT	[EXP <ADDM R10,R1>,<SUBM R10,R1>](R6) ; PERFORM OP
	DPB	R1,[POINT 16,R10,35]	; STORE TRIMMED RESULT
	RETURN				; EXIT

EXPRPX:					; UPDATE RELOCATION LEVEL
	TLNE	R10,(PFMASK)		; IF ABS,
	TLNE	R10,GLBSYM		;  OR GLOBAL,
	RETURN				;  NO ACTION
	XCT	[EXP <AOSA RELLVL>,<SOSGE RELLVL>](R6)
	 TRO	R15,ERRA		;  NEGATIVE COUNT, ERROR
	RETURN

EXPROR:	JSP	R3,EXPXCT		; !
	 IOR	R10,R1

EXPRAN:	JSP	R3,EXPXCT		; &
	 AND	R10,R1

EXPRMU:	JSP	R3,EXPXCT		; *
	 IMUL	R10,R1

EXPRDV:	JSP	R3,EXPXCT		; /
	 IDIV	R10,R1

EXPRSH:	JSP	R3,EXPXCT		; _
	CALL	[ ANDI	R10,177777	; get rid of extended sign
		  LSH	R10,0(R1) 	; so this is a logical shift
		  RETURN ]


EXPXCT:	PUSH	P,0(R3)			; STACK INSTRUCTION
	CALL	EXPXC1			; TEST FOR ABSOLUTE
	EXCH	R10,R1
	CALL	EXPXC1			; DITTO FOR OTHER
	POP	P,R3			; FETCH INSTRUCTION
	XCT	R3			; EXECUTE IT
	ANDI	R10,177777		; MAKE ABSOLUTE
	JRST	CPOPJ1			; GOOD EXIT

EXPXC1:	CALL	ABSTST			; TEST FOR ABSOLUTE
	LSH	R10,^D<36-16>
	ASH	R10,-^D<36-16>		; EXTEND SIGN
	RETURN


REGEXP:					; REGISTER EXPRESSION
	CALL	EXPR
	 TRO	R15,ERRA		;  NULL, ERROR
REGTST:	TDZE	R10,[<GLBSYM>B17!377B<SUBOFF>!177770]
	TRO	R15,ERRR		;  ERROR
	RETURN

ABSEXP:					; ABSOLUTE EXPRESSION
	CALL	EXPR
	 TRO	R15,ERRA
ABSTST:	TLZE	R10,(<GLBSYM>B17!377B<SUBOFF>)
	TRO	R15,ERRA		; ERROR IF GLOBAL OR RELOCATABLE
	ANDI	R10,177777
	RETURN

RELEXP:					; RELOCATABLE EXPRESSION
	CALL	EXPR
	 TRO	R15,ERRA
	TLNE	R10,GLBSYM		; NO GLOBALS ALLOWED
	JRST	ABSTST			; LET ABS FLAG IT
	RETURN

TERPL:	CALL	GETNB			; (SKIP + SIGN)

TERM:					; TERM PROCESSOR
	SETZB	R10,R1			; RETURN VALUE IN R10
	CALL	GETSYM			; TRY FOR SYMBOL
	 JRST	TERM4			;  NOT A SYMBOL
	CALL	SSRCH			; SEARCH TABLE
	 JRST	TERM2			;  NOT THERE
	TLNE	R1,MDFSYM		; MULTIPLY DEFINED?
	TRO	R15,ERRD		;  YES
	TLNN	R1,DEFSYM!GLBSYM	; UNDEFINED?
	TRO	R15,ERRU		;  YES
	MOVE	R3,R1			; GET AN EXTRA COPY
	TLZ	R1,776000-REGSYM	; CLEAR ALL BUT REGISTER BIT
	TLNN	R3,DEFSYM		; DEFINED?
	TLNN	R3,GLBSYM		;  NO, GLOBAL?
	JRST	TERM1			;  LOCAL
	TLO	R1,GLBSYM		; JUST GLOBAL
	AOS	R6,GLBPNT		; GLOBAL
	MOVEM	R0,GLBBUF(R6)		; SAVE NAME
	DPB	R6,SUBPNT		; SAVE NUMBER IN RELOCATION
TERM1:	CALL	CRFREF			; CREF IT
	MOVE	R10,R1			; RESULT TO R10
	JRST	CPOPJ1			; GOOD EXIT

TERM2:	CALL	OSRCH			; TRY OP CODES
	 JRST	TERM3			;  NO
	CAIE	R2,OCOP			; PSEUDO-OP?
	JRST	TERM3			;  YES
	TLNN	R16,CSWBIT		; Should we cref it?
	 CALL	CRFREF			;  Yes - CREF can have op-codes
	HRRZ	R10,R1			; YES, TREAT AS NUMERIC
	JRST	CPOPJ1			; GOOD EXIT

TERM3:	CALL	SSRCH			; NOT YET DEFINED
	 CALL	INSRT			; INSERT
	TRO	R15,ERRU		; FLAG ERROR
	JRST	CPOPJ1			; RETURN WITH ZERO

TERM4:	LDB	R2,C5PNTR		; NON-SYMBOLIC
	XCT	TERMJT(R2)		; EXECUTE TABLE
	CALL	SETNB			; RETURN NON-BLANK
	JRST	CPOPJ1			; GOOD EXIT

TERMJT:					; TERM JUMP TABLE
	PHASE	0
	RETURN				; NULL RETURN
TEIG:!	JRST	TERPL			; IGNORE (+)
TE2C:!	CALL	TERM2C			; - (2'S COMPLEMENT)
TEUP:!	CALL	TERMUP			; ^
TEEX:!	CALL	TERMEX			; < (EXPRESSION FOLLOWS)
TESQ:!	CALL	TERMSQ			; '
TEDQ:!	CALL	TERMDQ			; "
TEPC:!	CALL	TERMPC			; %
TENM:!	CALL	TERMNM			; 0-9
TEHX:!	CALL	TERMNM			; A-F (IF HEX ENABLED)
	DEPHASE

TERMNM:					; NUMERIC TERM
	PUSH	P,R6			; SAVE R6.
	MOVE	R6,LOCRDX		; GET RADIX
	SETZB	R0,R1			; CLEAR ACCUMULATORS
	SETZB	R2,R3
	SETZB	R10,R11

TERMN1:	CAILE	R14,"9"			; CHECK IF NUMERIC
	JRST	TERMN6			;  NO, GO CHECK IF HEX
	ASH	R10,1			; SHIFT BINARY AC ONE PLACE
	ADDI	R10,-"0"(R14)		; ADD NUMERIC VALUE OF DIGIT
	ASH	R1,2			; SHIFT QUATERNARY AC ONE PLACE
	ADDI	R1,-"0"(R14)		; ADD
	ASH	R2,3			; SHIFT OCTAL
	ADDI	R2,-"0"(R14)
	IMULI	R3,^D10			; DECIMAL
	ADDI	R3,-"0"(R14)
	ASH	R0,4			; HEXADECIMAL
	ADDI	R0,-"0"(R14)
TERMN2:	CAMGE	R11,R14			; LARGEST DIGIT SO FAR?
	MOVE	R11,R14			;  YES, SAVE IT
	CALL	GETCHR			; GET THE NEXT CHARACTER
	CAIL	R14,"0"			; CHECK IF NUMERIC
	JRST	TERMN1			;  POSSIBLY, GO CHECK FURTHER
TERMN3:	CAIE	R14,"."			;  NO, CHECK DECIMAL POINT
	JRST	TERMN7
	HRRI	R6,DECRDX		;    YES, CHANGE RADIX TO DECIMAL
	CALL	GETNB			;    GOBBLE UP "."

TERMN7:	TRNE	R6,OCTRDX		; CHECK IF RADIX OCTAL
	 JRST	TERMNO			;  YES, PROCESS ACCORDINGLY
	TRNE	R6,DECRDX		; DECIMAL
	 JRST	TERMND
	TRNE	R6,HEXRDX		; HEXADECIMAL
	 JRST	TERMNH
	TRNE	R6,QUARDX		; QUATERNARY
	 JRST	TERMNQ
	CAIG	R11,"1"			; BINARY: CHECK IF ALL DIGITS < 2
	 JRST	TERMN8			;  YES, JUMP OUT
	TRO	RERR,ERRN		;  NO, FLAG ERROR
TERMNQ:	MOVE	R10,R1			; MOVE QUATERNARY IN
	CAIG	R11,"3"			; CHECK IF ALL DIGITS < 4
	 JRST	TERMN8			;  YES, JUMP OUT
	TRO	RERR,ERRN		;  NO, FLAG ERROR
TERMNO:	MOVE	R10,R2			; MOVE OCTAL IN
	CAIG	R11,"7"			; CHECK IF ALL DIGITS < 8
	 JRST	TERMN8			;  YES, JUMP OUT
	TRO	RERR,ERRN		;  NO, FLAG ERROR
TERMND:	MOVE	R10,R3			; MOVE DECIMAL IN
	CAIG	R11,"9"			; CHECK IF ALL DIGITS <= 9
	 JRST	TERMN8			;  YES, JUMP OUT
	TRO	RERR,ERRN		;  NO, FLAG ERROR
TERMNH:	MOVE	R10,R0			; MOVE HEXADECIMAL IN
TERMN8:	TDZE	R10,[-1B19]		; OVERFLOW?
	 TRO	RERR,ERRT		;  YES, FLAG TRUNCATION ERROR
	POP	P,R6			; RESTORE R6.
	RETURN				; EXIT

TERMN6:	CAIL	R14,"A"			; TEST IF LEGAL HEX DIGIT
	 CAILE	R14,"F"
	  JRST	TERMN3			;  NO, GO FINISH UP
	ASH	R0,4			;  YES, SHIFT HEXADECIMAL AC ONE PLACE
	ADDI	R0,-"A"+^D10(R14)	; ADD NUMERIC VALUE OF DIGIT
	JRST	TERMN2			; REJOIN NUMERIC LOOP

TERMPC:					; %
	CALL	GETNB			; BYPASS PERCENT
	CALL	TERM			; GET A TERM
	 TRO	R15,ERRR		;  ERROR IF NULL
	CALL	REGTST			; TEST VALID REGISTER TERM
	TLO	R10,REGSYM		; FLAG IT
	RETURN				; EXIT


TERMDQ:					; """
	TLO	R16,FOLBIT		; OVERRIDE INPUT FOLDING.
	CALL	GETNT			; GET THE NEXT NON-TERMINATOR
	 JRST	TERMQE			;  END OF LINE, ERROR
	MOVE	R10,R14			; GET THE CHARACTER
	CALL	GETNT			; TRY ONE MORE
	 JRST	TERMQE			;  ERROR
	DPB	R14,[POINT 8,R10,35-8]	; STORE IN UPPER
	TLZ	R16,FOLBIT		; RESET FOLDING OVERRIDE.
	JRST	GETNB			; RETURN WITH NEXT NON-BLANK


TERMSQ:					; "'"
	TLO	R16,FOLBIT		; OVERRIDE INPUT FOLDING.
	CALL	GETNT			; GET NON-TERMINATOR
	 JRST	TERMQE			;  TERMINATOR, ERROR
	MOVE	R10,R14			; FETCH CHARACTER
	TLZ	R16,FOLBIT		; RESET FOLDING OVERRIDE.
	JRST	GETNB			; RETURN NON-BLANK

TERMQE:	TRO	R15,ERRQ		; RAN OUT OF CHARACTERS
	RETURN

TERM2C:					; "-"
	CALL	GETNB			; GOBBLE	"-"
	CALL	TERM			; GET A TERM
	 TRO	RERR,ERRQ		;  ERROR IF NULL
	MOVN	R0,R10			; TAKE 2'S COMPLEMENT
	TRZ	R0,600000
	HRR	R10,R0			; PUT 16 BITS OF IT IN R10
	RETURN				; EXIT

TERMEX:					; "<"
	PUSH	P,RELLVL		; Save current relocation level on stack.
	SETZM	RELLVL			; Start nested expression at reloc level 0.
	SETZ	r6,			; Clear possible record of "-" preceding "<".
	CALL	GETNB			; GOBBLE "<"
	CALL	EXPR0			; GET AN EXPRESSION
	 TRO	RERR,ERRQ		;  ERROR IF NULL
	POP	P,RELLVL		; Restore relocation level.
	CAIE	R14,">"			; CHECK FOR CLOSING ">"
	 TROA	RERR,ERRQ		;  NO, FLAG ERROR
	  JRST	GETNB			;  YES, GOBBLE ">" & EXIT

TERMUP:					; "^" UNARY OPERATOR PROCESSOR
	SETZ	R0,			; CLEAR AC
	CALL	GETCHR			; GET THE NEXT CHARACTER
	LDB	R2,C9PNTR		; MAP CHARACTER USING COLUMN 9
	CALL	GETCHR			; GOBBLE THE CHARACTER
	XCT	UPARJT(R2)		; EXECUTE TABLE
	CAIE	R0,			; RADIX MODIFICATION?
	HRRM	R0,LOCRDX		;  YES, CHANGE IT
	CALL	TERM			; GET A TERM
	 TRO	RERR,ERRQ		;  ERROR IF NULL
	RETURN				; EXIT

UPARJT:	PHASE	0			; UP-ARROW JUMP TABLE
	TRO	RERR,ERRQ		; UNDEFINED OPERATOR: FLAG ERROR
UPARC:!	JRST	TERM1C			; ^C - ONE'S COMPLEMENT
UPARF:!	JRST	TERMFL			; ^F - FLOATING POINT
UPARR:!	JRST	TERM50			; ^R - RADIX 50
UPARB:!	HRRZI	R0,BINRDX		; ^B - BINARY RADIX
UPARO:!	HRRZI	R0,OCTRDX		; ^O - OCTAL RADIX
UPARD:!	HRRZI	R0,DECRDX		; ^D - DECIMAL RADIX
UPARH:!	HRRZI	R0,HEXRDX!HEXENB	; ^H - HEXADECIMAL RADIX
	DEPHASE

TERM1C:					; ^C
	CALL	TERM			; GET A TERM
	 TRO	RERR,ERRQ		;  ERROR IF NULL
	TRC	R10,177777		; TAKE ONE'S COMPLEMENT
	RETURN				; EXIT

TERMFL:					; ^F - FLOATING POINT CONSTANT
	CALL	SETNB			; IGNORE LEADING BLANKS
	HRRZI	R0,1
	MOVEM	R0,FLTLEN		; SET FLOATING LENGTH TO ONE
	CALL	FLTG			; EVALUATE F.P. CONSTANT
	TLNE	RERR,FLTFLG		; ANY ERRORS?
	TRO	RERR,ERRA		;  YES, FLAG ERROR
	MOVE	R10,FLTNUM		; PUT RESULT IN R10
	RETURN				; EXIT

TERM50:	SETZ	R0,			; CLEAR ACCUMULATOR
	MOVSI	R1,(POINT 6,R0,17)	; SET POINTER
TERM51:	CALL	TSTNT			; CHECK NON-TERMINATOR
	 JRST	TERM53			;  END IF EOL
	MOVEI	R3,-40(R14)		; GET A SIXBIT COPY
	LDB	R2,ANPNTR		; MAP CHARACTER FOR TYPE
	CAIN	R2,.HEX			; O.K. IF A-F
	 JRST	TERM52
	CAIE	R2,.ALP			; OR G-Z OR . OR $
	 CAIN	R2,.NUM			; OR 0-9
	  CAIA
	   JUMPN R3,TERM53		; OR SPACE, ELSE END
TERM52:	IDPB	R3,R1			; ACCUMULATE THE CHARACTER
	CALL	GETCHR			; GET THE NEXT CHARACTER
	TLNE	R1,770000		; FINISHED WITH 3 CHARACTERS?
	 JRST	TERM51			;  NO, PROCESS NEXT CHARACTER

TERM53:	CALL	SIXM40			; CONVERT SIXBIT TO RAD50
	HRRZ	R10,R0			; PUT VALUE IN R10
	JRST	SETNB			; EXIT WITH NEXT NON-BLANK

	SUBTTL	SYMBOL/CHARACTER HANDLERS


;	ORDINARY SYMBOLS ARE A SEQUENCE OF ALPHAMERIC CHARACTERS
;	BEGINNING WITH AN ALPHABETIC CHARACTER; "." AND "$"
;	ARE CONSIDERED ALPHABETIC.

;	LOCAL SYMBOLS ARE A DECIMAL INTEGER FOLLOWED BY
;	A "$".  THE INTEGER'S VALUE MUST BE IN THE RANGE
;	[1,65535].

;	IF GETSYM FAILS TO FIND A SYMBOL, IT RETURNS TO 0(P)
;	WITH R0 = 0.

;	IF THE NEXT NONBLANK TEXT IS A SYMBOL, GETSYM RETURNS TO
;	1(P) WITH THE SYMBOL'S MOD40 EQUIVALENT IN R0.
;	ANY CHARACTERS AFTER THE SIXTH IN THE SYMBOL ARE SKIPPED.

;	FOR LOCAL SYMBOLS, THE VALUE RETURNED (IN R0) IS . . .

;		LEFT HALF:  INTEGER PART OF SYMBOL (16 BITS);
;				HIGH ORDER BITS ARE 0 & 1 (200000)
;		RIGHT HALF:  BLOCK NUMBER OF CURRENT LOCAL SYMBOL BLOCK


GETSYM:					; GET A SYMBOL
	CALL	SETNB			; BYPASS LEADING BLANKS
	MOVEM	R13,SYMBEG		; SAVE START FOR RESCAN
	MOVSI	R1,(POINT 6,R0,)	; SET POINTER
	TDZA	R0,R0			; CLEAR AC AND SKIP
GETSY1:	 CALL	GETCHR			; GET NEXT CHARACTER
	LDB	R2,ANPNTR		; MAP CHARACTER TYPE
	XCT	GETSYT(R2)		; EXECUTE TABLE
GETSY0:	SUBI	R14,40			; VALID, CONVERT TO SIXBIT
	TLNE	R1,770000		; ARE WE FULL?
	IDPB	R14,R1			;  NO, STORE CHARACTER
	JRST	GETSY1

GETSY2:	JUMPE	R0,CPOPJ		; EXIT IF EMPTY
	MOVEM	RBYTE,SYMDEL		; SAVE SYMBOL DELIMITER FOR PARSERS.
	CALL	SETNB			; SYMBOL, RETURN NON-BLANK
	CALL	SIXM40			; CONVERT TO MOD40
	JRST	CPOPJ1			; EXIT +1

GETSY3:	SETCM	R3,LOCRDX		; GET LOCAL RADIX COMPLEMENTED
	TRNE	R3,HEXRDX!HEXENB	; CHECK HEX RADIX AND HEX ENABLED
	JRST	GETSY0			;  NO, CONTINUE WITH SYMBOL
	RETURN				;  YES, EXIT EMPTY

GETSYT:					; GETSYM TABLE
	PHASE	0
	JRST	GETSY2			; NON-ALPHA/NUMERIC
.TAB:!	JRST	GETSY2			; BLANK
.ALP:!	JFCL				; ALPHA, O.K.
.NUM:!	JUMPE	R0,GETLSY		; NUMERIC => LOCAL SYM IF 1ST BYTE
.HEX:!	JUMPE	R0,GETSY3		; A-F O.K. IF NOT FIRST
	DEPHASE

;	*******  GET A LOCAL SYMBOL  *******

;	IF THE NUMERIC PART DOESN'T END WITH A "$", THIS
;	CAN'T BE A LOCAL SYMBOL.  IN THAT CASE RESTORE
;	THE ORIGINAL SOURCE INPUT POINTER & RETURN SAYING
;	NO SYMBOL WAS FOUND.

;	INITIAL ENTRY TO THIS BLOCK OF CODE IS AT GETLSY.


GETL1:	CALL	GETCHR			; GET NEXT BYTE
	LDB	R2,ANPNTR		; LOAD ITS TYPE
	XCT	GETLTS(R2)		; -- CHECK TYPE

	IMULI	R0,^D10			; TYPE IS NUMERIC -- ACCUMULATE
GETLSY:	SUBI	R14,"0"			; BINARY INTEGER.
	ADD	R0,R14
	JRST	GETL1


GETLDO:	CAIE	R14,"$"			; TYPE IS ALPHA -- IS THIS "$"?
	JRST	GETLNS			; NO -- CAN'T BE LOCAL SYM
	CALL	GETCHR			; YES -- SKIP THIS BYTE

	CAIE	R0,			; INSURE THAT INTEGER IS
	CAIL	R0,^D65536		; IN [1,65535]
	TRO	RERR,ERRT		; GIVE A T FLAG IF IT ISN'T
	TRZ	R0,400000		; FORCE HIGH ORDER BIT OFF,
	TRO	R0,200000		; LOW ORDER BIT ON.

	HRL	R0,R0			; COPY INTEGER TO LEFT HALF,
	HRR	R0,LSBLOC		; LS BLOCK # TO RIGHT HALF.
	JRST	CPOPJ1			; RETURN.


;	   --- FOUND A DISTINCTLY UNKOSHER CHARACTER BEFORE
;	   COMING ACROSS A "$".  UNDECIDE THAT THIS IS A SYMBOL.

GETLNS:	MOVE	R13,SYMBEG		; RESTORE INPUT POINTER
	LDB	R14,R13			; RELOAD FIRST BYTE.
	SETZ	R0			; RETURN 0
	RETURN


GETLTS:
	JRST	GETLNS			; NON ALPHA-NUMERIC
	JRST	GETLNS			; BLANK OR TAB
	JRST	GETLDO			; ALPHABETIC (HOPEFULLY $)
	JFCL				; NUMERIC
	JRST	GETLNS			; A-F

GETNB:					; GET NON-BLANK CHARACTER
	IBP	RBPTR			; INDEX BYTE POINTER
SETNB:					; SET TO NON-BLANK CHARACTER
	CALL	SETCHR			; SET CHARACTER IN RBYTE
	CAIE	RBYTE,SPACE		; IF SPACE
	 CAIN	RBYTE,TAB		;  OR TAB;
	  JRST	GETNB			;  BYPASS
	RETURN				; OTHERWISE EXIT

SETCHI:	TRO	RERR,ERRI		; SET I FLAG FOR ILLEGAL CHAR.
					; DROP THRU TO GETCHR TO SKIP IT.

GETCHR:					; GET THE NEXT CHARACTER
	IBP	RBPTR			; INDEX BYTE POINTER
SETCHR:					; SET THE CURRENT CHAR IN RBYTE
	LDB	RBYTE,RBPTR		; PICK IT UP
	LDB	R4,C6PNTR		; LOAD CHARACTER'S TYPE.
	XCT	SCHTAB(R4)		; CHECK FOR LOWER CASE & THINGS.
	RETURN


SCHTAB:
	PHASE	0
	JFCL				; IGNORE RANDOM CHARACTERS.
SCIL:!	JRST	SETCHI			; ILLCHR - ISSUE I FLAG & SKIP BYTE.
SCEL:!	JRST	GETEOL			; ELLCHR - SKIP TO END OF LINE.
SCLC:!	JRST	FOLTST			; LOWER CASE - FOLD UNLESS OVERRIDDEN
SCLE:!	JFCL				; LINE END (CR, LF, FF, NUL) - IGNORE
SCSE:!	JFCL				; SEPARATOR (, ;, BLANK, TAB) - IGNORE
	DEPHASE

GETEOL:	CALL	GETNT			; SKIP TO END OF LINE.
	RETURN				; .... FOUND IT: RETURN.
	JRST	GETEOL			; .... NOT THERE YET: KEEP GOING.

FOLTST:	TLNN	R16,FOLBIT		; IS FOLDING OVERRIDEN AT PRESENT?
	SUBI	RBYTE,40		;    NO -- FOLD INTO UPPER CASE.
	RETURN				; RETURN WITH BYTE, FOLDED OR NOT.

GETNT:					; GET NON-TERMINATOR.
	CALL	GETCHR			; GET NEXT BYTE.

TSTNT:					; TEST FOR NON-TERMINATOR.
	LDB	R4,C6PNTR		; LOAD CURRENT BYTE'S TYPE.
	CAIE	R4,SCLE			; IS IT END-OF-LINE OF ANY SORT?
	AOS	(P)			;    NO -- RETURN + 2.
	RETURN				;    YES - RETURN + 1.


TSTNSP:					; TEST FOR NON-SEPARATOR
	LDB	R4,C6PNTR		; GET CHARACTER TYPE.
	CAIE	R4,SCSE			; IS IT SEPARATOR?
	AOS	(P)			;    NO -- RETURN + 2.
	RETURN				;    YES - RETURN + 1.

;			---  MACARG  ---

;	.. SUBROUTINE TO GET A MACRO-TYPE ARGUMENT.  THE ARGUMENT
;	IS A CHARACTER STRING WHICH MAY BE DELIMITED IN ANY OF
;	THREE WAYS:

;	   STRING@	WHERE "@" REPRESENTS ",", ";", BLANK, TAB,
;			OR ANY END-OF-LINE DELIMITER.
;			Leading and trailing blanks are tossed out.

;	^\STRING\	WHERE "\" IS ANY CHARACTER EXCEPT AN END-OF-LINE.

;	<STRING>	[STRING MAY INCLUDE NESTED "<...>" CONSTRUCTIONS]

;	   MACARG STORES "STRING" BEGINNING AT LOCATION ARGSTR
;	   IN ASCIZ FORMAT, AND STORES THE NUMBER OF BYTES IN THE STRING
;	   IN ARGLEN.

MACART:	TDZA	R10,R10			; FLAG MACRO CALL ENTRY;

;	   WHEN ENTERED VIA MACART, THE ARGUMENT BEING PARSED IS
;	   WRITTEN INTO A MACRO CALL BLOCK.

MACARG: TRO	R10,1			; FLAG NON-MACRO CALL ENTRY.
	PUSH	P,R3			; SAVE WORK REGISTERS.
	PUSH	P,R4
	SETZM	ARGLEN			; INIT STRING LENGTH TO 0.
	MOVE	R3,[POINT 7,ARGSTR]	; POINT TO SPACE FOR ARG STRING.

	CALL	SETNB			; GET 1ST NONBLANK BYTE.
	CALL	TSTNT			; IS IT END OF LINE?
	 JRST	MAREXA			;    YES - ARGUMENT IS NULL.

	CAIN	RBYTE,"<"		; IS STRING BRACKETED?
	JRST	MARBRA
	CAIN	RBYTE,"^"		; IS IT "^" CONSTRUCTION?
	JRST	MARAR


;	   STRING OF FIRST TYPE; COLLECT UP TO A SEPARATOR.

MARSTR:	CALL	TSTNSP			; CHECK FOR A SEPARATOR.
	 JRST	[ CALL SETNB		; Move to first non-blank
		  JRST	MAREXA	]	;  before returning

;	   ** CHARACTER ISN'T A DELIMITER;  APPEND IT TO THE STRING
;	      BEING COLLECTED & INCREMENT ITS LENGTH.

	CALL	SMB			; STORE THE CHARACTER.
	CALL	GETNT			; GET NEXT BYTE
	JRST	MAREXA			; .. END OF LINE => QUIT.
	JRST	MARSTR			; GO BACK TO CHECK NEW BYTE.


MARERR:	TRO	RERR,ERRQ		; <<<< UNEXPECTED END OF LINE

MAREX:	CALL	TSTNT			; IS STRING DELIMITED BY END OF LINE?
	 CAIA				;    YES -- DON'T SKIP DELIMITER.
	  CALL	GETNB			;    NO --- SKIP DELIMITER.
MAREXA:	SETZ	R4,			; APPEND A 0 BYTE TO THE STRING.
	IDPB	R4,R3
	POP	P,R4			; RESTORE REGISTER CONTENTS.
	POP	P,R3
	RETURN				; ... RETURN TO CALLER ...



;	"^\....\"

MARAR:	CALL	GETNT			; SKIP "^".
	JRST	MARERR			; CAN'T TOLERATE END OF LINE HERE.
	MOVE	R1,RBYTE		; SAVE DELIMITER IN R1.

MARARB:	CALL	GETNT			; GET NEXT BYTE OF STRING.
	JRST	MARERR			; .. CAN'T BE END OF LINE.
	CAMN	RBYTE,R1		; IS THIS THE DELIMITER?
	JRST	MAREX			;   YES - QUIT HERE.
	CALL	SMB			;   NO -- STORE THE BYTE.
	JRST	MARARB			; KEEP ON TRUCKIN'



;	"<.....>"

MARBRA:	MOVEI	R1,1			; SET BRACKET LEVEL TO 1.

MARB:	CALL	GETNT			; GET NEXT BYTE.
	 JRST	MARERR			; .. CAN'T BE END OF LINE.
	CAIN	RBYTE,"<"		; IS IT NESTED MACRO ARG?
	 AOJA	R1,MARBS		;    YES .. INCR NEST LEVEL
	CAIE	RBYTE,">"		; IS IT END OF A BRACKETED STRING?
	 JRST	MARBS			;    NO  .. JUST A STRING BYTE.
	SOJLE	R1,MAREX		;    YES .. DECR NEST LEVEL
					; BUT QUIT AT OUTERMOST ">"

MARBS:	CALL	SMB			; APPEND BYTE TO THE STRING.
	JRST	MARB			; GO BACK FOR MORE.


SMB:	IDPB	RBYTE,R3		; STORE NEXT BYTE IN ARG STRING.
	AOS	ARGLEN			; INCREMENT STRING LENGTH.
	TRNN	R10,1			; BUILDING A CALL BLOCK?
	CALL	WCIMT			;    YES - ALSO WRITE INTO TREE.
	RETURN

	SUBTTL	PSEUDO-OPS

.END:					; "END" PSEUDO-OP
	SKIPN	CONLVL			; IF IN CONDITIONAL
	SKIPE	REPLVL			;  OR REPEAT,
	TRO	R15,ERRE		;  FLAG ERROR
	TLO	R15,ENDFLG		; FLAG "END SEEN"
	TLZ	R16,SBTBIT		; TURN OFF SUBTITLE SWITCH
	CALL	EXPRF			; EVALUATE THE ADDRESS
	MOVEI	R10,1			;  NULL, FORCE ODD VECTOR
	MOVEM	R10,PF1
	MOVEM	R10,ENDVEC
	TRNE	R15,ERRU		; ANY UNDEFINED SYMBOLS?
	TRO	R15,ERRP1		;  YES, PASS ONE ERROR
	RETURN

OPCERR:					; ILLEGAL OP CODE
	TRO	R15,ERRO
	RETURN


TSTEVN:					; TEST FOR EVEN
	TRNN	R5,1			; ARE WE EVEN?
	RETURN				;  YES, JUST EXIT
	TRO	R15,ERRB		; NO, FLAG ERROR AND EVEN THINGS UP
	PUSH	P,R1
	CALL	.EVEN
	POP	P,R1
	RETURN

.EVEN:					; "EVEN" PSEUDO OP
	TRNN	R5,1			; EVEN?
	RETURN				;  YES, NO SEQUENCE BREAK
PCMOD:	AOS	R1,R5			; GET PC
	HRLI	R1,(<RLDT10>B<MODOFF>)	; FLAG AS CLASS 10
	JRST	STCODE


.ODD:					; "ODD" PSEUDO-OP
	TRNE	RLOC,1			; IS LOCATION ALREADY ODD?
	RETURN				; YES - NOTHING TO DO
	JRST	PCMOD			; NO - INCR PC LIKE .EVEN


.LIMIT:					; ".LIMIT" PSEUDO-OP
	TLNE	R15,ABSFLG		; ABS MODE?
	RETURN				;  YES, IGNORE IT
	CALL	TSTEVN			; NO, MAKE SURE WE'RE EVEN
	MOVSI	R1,BC2(<RLDT11>B<MODOFF>)
	CALL	STCODE
	MOVSI	R1,BC2
	JRST	STCODE			; GENERATE TWO WORDS

ABS0:	TLO	R15,ABSFLG		; SET ABSOLUTE FLAG
	TLZ	R5,(PFMASK)		; CLEAR RELOCATION
	RETURN

ASECT:	MOVE	R0,.ABS.		; FUDGE FOR ABS
	SETZ	R11,			; Set for PSECT
	JRST	CSECT1			; BRANCH AROUND TEST

PSECT:	MOVEI	R11,440			; Mark as being a PSECT
	JRST	CSECTA			; Merge

CSECT:	SETZ	R11,			; No PSECT
CSECTA:	CALL	LOCRES			; START NEW LOCAL SYMBOL BLOCK
	TLNE	R15,ABSFLG		; ABS MODE?
	JRST	OPCERR			; YES, ERROR
	CALL	GETSYM			; TRY FOR A SYMBOL
	 JFCL				;  DEFAULT OR ABS
	CAIE	R11,			; If PSECT then get operands
	 CALL	PSCOPS			; Get operands
CSECT1:	CALL	TSTMAX			; TEST MAX PC
	MOVSI	R10,-^D256		; INIT FOR SEARCH
CSECT2:	CAMN	R0,SECNAM(R10)		; MATCH?
	JRST	CSECT3			;  YES
	TRNE	R10,-2			; IF POINTING AT ONE
	SKIPE	SECNAM(R10)		; OR SLOT IS FULL,
	AOBJN	R10,CSECT2		; LOOP
	JUMPL	R10,CSECT3		; BRANCH IF GOOD
	TRO	R15,ERRA		; END, ERROR
	RETURN

CSECT3:	MOVEM	R0,SECNAM(R10)		; SAVE NAME
	MOVE	R1,R5			; GET CURRENT PC
	LDB	R2,SUBPNT		; CURRENT RELOCATION
	HRRM	R1,SECBAS(R2)		; STORE CURRENT
	HRRZ	R5,SECBAS(R10)		; GET NEW ONE
	MOVEM	R11,SECFLG(R10)		; Save flag
	DPB	R10,CCSPNT		; MAKE SURE RELOCATION IS SET
	MOVE	R1,R5

	AOS	R2,GLBPNT
	MOVEM	R0,GLBBUF(R2)		; STORE NAME
	ANDI	R1,177777
	DPB	R2,SUBPNT		; STORE POINTER
	MOVEI	R3,RLDT7
	DPB	R3,MODPNT		; SET CLASS 7
	JRST	STCODE


TSTMAX:	LDB	R3,CCSPNT		; GET CURRENT SEC
	HLRZ	R4,SECBAS(R3)		; MAX FOR THIS ONE
	CAIGE	R4,(R5)			; NEW MAX?
	 HRLM	R5,SECBAS(R3)		;  YES
	RETURN
PSCOPS:	PUSH	P,R0		; SAVE SECTION NAME
	IBP	RBPTR			; GO PAST COMMA
	MOVE	R0,[XWD PSCRTN,PSCTBL]	; SET UP FOR CALL TO PARSE
	CALL	ARGSET			; ARGUMENTS PLEASE
	 JFCL
	POP	P,R0			; GET BACK SECTION NAME
	RETURN				; LOVE IT

PSCRTN:	CALL	PSCSUB			; CALL THIS FOR EACH ARGUMENT

PSCSUB:	TRNE	R2,400			; IS THIS A SET OR A CLEAR
	 TDOA	R11,R2			; SET THE BIT
	  TDZ	R11,R2			; CLEAR THE BIT RETURN
	RETURN


PSCTBL:
	XWD	.-EPSTBL-1,.+1		; PSECT ARGUMENT TABLE
	ARG	H,G,H,1			; CORE ALLOCATION
	ARG	L,O,W,401
	ARG	N,R,M,2			; LIBRARY
	ARG	L,I,B,402
	ARG	C,O,N,4			; OVERLAY
	ARG	O,V,R,404
	ARG	R,W,,20			; READ-WRITE/READ-ONLY
	ARG	R,O,,420
	ARG	A,B,S,40		; ABSOLUTE/RELOCATABLE
	ARG	R,E,L,440
	ARG	L,C,L,100		; LOCAL/GLOBAL
	ARG	G,B,L,500
	ARG	I,,,200			; INSTRUCTION/DATA SPACE
	ARG	D,,,600
IFN CMUSW,<
	ARG	P,G,M,1			; PROGRAM/GRAPHICS SPACE
	ARG	G,R,A,401
>;IFN CMUSW
EPSTBL:

.IDENT:					; IDENTIFY PROGRAM
	SETZ	R0,
	MOVSI	R1,(POINT 6,R0,)	; CREATE POINTER
	CALL	SETNB
	CAIL	R14,41
	 CAILE	R14,137
	  JRST	.IDERR			; NOT A LEGAL DELIMITER
	CAIN	R14,";"
	 JRST	.IDERR			; MUST HAVE SOMETHING 
	MOVE	R10,R14			; SAVE DELIMITER
.IDNT2:	CALL	GETNT
	 JRST	.IDCON			; EOL SO GO CONVERT TO MOD40
	CAMN	R10,R14			; DELIMITER?
	 JRST	.IDCON			; YES - CONVERT
	CAIN	R14,";"
	 JRST	.IDCON
	TLNN	R1,770000
	 JRST	.IDNT4
	MOVEI	R3,-40(R14)		; SAVE A SIXBIT COPY
	LDB	R2,ANPNTR		; TEST FOR LEGAL
	CAIN	R2,.HEX			; MOD40 CHARACTER
	 JRST	.IDNT3
	CAIE	R2,.ALP
	 CAIN	R2,.NUM
	  CAIA
	   JUMPN R3,.IDERR		; IF NOT SPACE THEN ERROR
.IDNT3:	IDPB	R3,R1			; STORE AWAY THE CHAR
	JRST	.IDNT2			; GET MORE

.IDNT4:	CALL	GETNT
	 JRST	.IDCON
	CAIE	R14,";"
	 CAMN	R10,R14
	  CAIA
	   TRO	RERR,ERRQ		; MORE THAN 6 CHAR IN VERSION -FLAG Q ERROR
.IDCON:	CALL	SIXM40			; GET A MOD40 COPY
	MOVEM	R0,PRGVER		; SAVE THE VERSION
.IDNT5:	JUMPE	R14,CPOPJ
.IDNT6:	CALL	GETNB
	 JUMPN	R14,.IDNT6
	RETURN

.IDERR:	TRO	RERR,ERRO
	JRST	.IDNT5



.RAD50:					; RADIX 50
	CALL	TSTEVN			; SET UP PC TO STORE WORDS.
	SETZ	R0,			; INIT RESULT VALUE = 0.
	MOVEI	R1,3			; 3 BYTES TO GO IN CURRENT WORD.

;	   PARSE NEXT FIELD OF THE OPERAND.

.RADFL:	CAIN	RBYTE,"<"		; IS THIS A BRACKETED EXPR?
	JRST	RABRAC			;     YES - EVALUATE IT.
	JRST	RADARB			;     NO -- THIS IS ARBITRARY DELIM.

;	   END OF FIELD . . .

.RADFE:	CALL	GETNT			; SKIP FIELD DELIMITER.
	JRST	.RAFLU			; .. FLUSH AT END OF OPERAND.
	CAIN	RBYTE,";"
	JRST	.RAFLU
	CAIE	RBYTE," "		; IF NEXT BYTE IS BLANK OR TAB,
	CAIN	RBYTE,TAB		; JUST SKIP OVER IT.
	JRST	.RADFE
	JRST	.RADFL			; .. FOUND ANOTHER OPERAND ...

;	   ";" OR END OF LINE ENCOUNTERED -- FORCE OUT ANY
;	   PARTIALLY ASSEMBLED WORD OF RAD50 GOODIES.  IF OPERAND
;	   WAS EXPLICITLY NULL, OUTPUT 1 WORD OF 0.

.RAFLU:	CAIE	R1,3			; IS CURRENT WORD EMPTY?
	JRST	.RAFLL			;    NO -- PAD & STORE IT.
	SKIPE	CODPNT			;    YES - DO SAME ANYWAY IF
	RETURN				;	IT'S THE ENTIRE OPERAND.

.RAFLL:	SETZ	R10,			; APPEND 0'S TO PARTIAL WORD
	CALL	RABOUT			; UNTIL RABOUT FILLS & STORES IT.
	JRST	.RAFLU




;	   "<EXPR1,EXPR2,...,EXPRN>" ....
;	   EVALUATE EACH EXPRESSION AND USE IT AS THE ENCODED
;	   VALUE OF A BYTE.

RABRAC:	PUSH	P,R0			; SAVE WORD UNDER CONSTRUCTION
	PUSH	P,R1			; & BYTE COUNTER.
	CALL	GETNB			; SKIP "<" OR ",".
	CALL	EXPR			; EVALUATE NEXT EXPRESSION.
	TRO	RERR,ERRQ		; ... NULL OR INVALID

	CAIGE	R10,50			; IS RESULT TOO LARGE?
	JRST	RABRDY			;    NO -- KEEP IT.
	SETZ	R10,			;    YES - FORCE IT TO 0
	TRO	RERR,ERRT		; & FLAG TRUNCATION ERROR.

RABRDY:	POP	P,R1			; RESTORE WORK REGS.
	POP	P,R0
	CALL	RABOUT			; ENCODE EXPR VALUE.
	CAIN	RBYTE,","		; DOES ANOTHER EXPR FOLLOW?
	JRST	RABRAC			;    YES - GO GET IT.
	CAIE	RBYTE,">"		;    NO -- IS END LEGIT?
	TRO	RERR,ERRQ		;	NO... QUESTIONABLE SYNTAX.
	JRST	.RADFE			;	YES.. END OF FIELD.




;	   "/[TEXT]/" ... TEXT WITH AN ARBITRARY DELIMITER

RADARB:	MOVE	R3,RBYTE		; SAVE DELIMITER.

RADARN:	CALL	GETNT			; GET NEXT CHARACTER.
	JRST	ASCQ			; ... UNEXPECTED END OF LINE
	CAMN	RBYTE,R3		; IS THIS THE DELIMITER AGAIN?
	JRST	.RADFE			;    YES - END OF FIELD
	MOVEI	R10,-40(RBYTE)		;    NO -- CONVERT BYTE TO SIXBIT,
	HLRZ	R10,RADTBL(R10)		;    THEN TO RAD50 VALUE.

	JUMPN	R10,RADBOK		; NON-ZERO ENCODED VALUE IS VALID
	CAIE	RBYTE," "		;    OTHERWISE - VALID ONLY IF
	 TRO	RERR,ERRA		;	IT'S A BLANK.

RADBOK:	CALL	RABOUT			; ENCODE THIS BYTE.
	JRST	RADARN			; GO BACK FOR THE NEXT ONE.



;	   SUBROUTINE RABOUT "OUTPUTS" ONE RAD50 BYTE.  IT ENCODES
;	   BYTES INTO A WORD & STORES THE WORD WHEN IT BECOMES FULL.

RABOUT:	IMULI	R0,50			; MULTIPLY PREVIOUS VALUE BY RADIX.
	ADD	R0,R10			; ADD CURRENT BYTE VALUE.
	SOJG	R1,RABPAR		; DECREMENT BYTE COUNT.

	MOVE	R1,R0			; *** WORD'S FULL - STORE IT ***
	HRLI	R1,BC2			; INDICATE 16-BIT VALUE.
	CALL	STCODE			; STUFF IT.
	SETZ	R0,			; NEW WORD VALUE = 0,
	MOVEI	R1,3			; NEW BYTE COUNT = 3.
RABPAR:	RETURN

.RADIX:					; ".RADIX n" PSEUDO-OP
	MOVEI	R2,DECRDX		; SET RADIX TO 10 TO EVALUATE OPERAND
	CALL	RADEXP			; EVALUATE OPERAND
	 JRST	.RAD8			;  DEFAULT NULL TO OCTAL
	SETZ	R0,			; CLEAR AC
	CAIN	R10,^D2			; CHECK IF n=2
	MOVEI	R0,BINRDX		;  YES, SET BINARY RADIX
	CAIN	R10,^D4			; CHECK IF n=4
	MOVEI	R0,QUARDX		;  YES, SET QUATERNARY RADIX
.RAD8:	CAIN	R10,^D8			; CHECK IF n=8
	MOVEI	R0,OCTRDX		;  YES, SET OCTAL RADIX
	CAIN	R10,^D10		; CHECK IF n=10
	MOVEI	R0,DECRDX		;  YES, SET DECIMAL RADIX
	CAIN	R10,^D16		; CHECK IF n=16
	MOVEI	R0,HEXRDX		;  YES, SET HEXADECIMAL RADIX
	JUMPE	R0,.RADER		; JUMP IF NOT LEGAL RADIX
	HRRM	R0,GLBRDX		; SET THE NEW RADIX
	MOVEM	R10,RADVAL		; SAVE ITS NUMERIC VALUE TOO!!!
	RETURN				; EXIT GOOD
QERR:					; OTHER ROUTINES DO THIS TOO.
.RADER:	TRO	RERR,ERRQ		; ERROR IF n NOT ONE OF 2,4,8,10,16
	RETURN				; EXIT W/O CHANGING RADIX


MCALL2:	MOVE	R6,LSTCTL
	SKIPL	LSTCNT			; Unless we aren't listing
	 TRNN	R6,LSON			; use SON to determine whether to throw page in .MCALL
.INSERT:  TDZA	R6,R6			; Clear page throw flag
.REQUIRE:  HRLZI R6,P1F			; Set page throw flag
	TDZ	R6,RMODE		; IF PASS 1, THEN NO THROW
	TLNN	RMODE,NSFFLG		; Are nonstandard features enabled?
	 JRST	OPCERR			;    No -- Treat as invalid op code.
					;    Yes . . .

IFN TENEX,<
	MOVE	R14,R13			; Load string pointer to the filename
	ADD	R14,[070000,,0]		; Backup one charcter
	TLNE	R14,400000		; Overflow?
	 SUB	R14,[430000,,1]		;  yes - got to previous word
	CALL	TRYJFN			; Try to get a JFN for it
	 JRST	[ TRO	R15,ERRU	; Can't find the file
		  RETURN  ]		; Exit now
	TLO	R16,REQBIT		; Say that we in a .REQUIRE
	AOS	R3,REQIDX		; Bump and load counter
	TLNE	R15,P1F			; Pass 1 or 2?
	 JRST	REQSAV			; Pass 1 - save the world
	RLJFN				; Release JFN since we already have one
	 JFCL				; Ignore errors
	SOS	R2,SRCIDX		; Release slot in the JFN table
	SETZM	SRCTAB(R2)		;  by zeroing it
	MOVE	R1,SRCTAB(R3)		; Load the JFN from the source table

; Now we are ready to get input from a new file so we must save the status,
;  byte count, JFN, and other stuff about the previous source file.

REQSAV:
	MOVE	R4,REQSP		; Get require stack pointer
	PUSH	R4,R1			; Save the JFN
	PUSH	R4,SRCFLG		; Type of source file
	PUSH	R4,SRCVER		; File version number
	PUSH	R4,BSIZE		; Last file page to map in
	PUSH	R4,BCOUNT		; Byte count on the last file page
	PUSH	R4,SRCPGN		; JFN,, current file page number
	PUSH	R4,SRCCNT		; Current byte count
	PUSH	R4,SRCPNT		; Current byte pointer
	PUSH	R4,SRCJFN		; Current source file JFN
	PUSH	R4,INPGNM		; Input page number
	PUSH	R4,R6			; Save PAGE THROW flag
	MOVEM	R4,REQSP		; Save the stack pointer

; Now we can initialize the new source file

	CALL	SFINIT			; Init the new file
	CAIE	R6,			; Don't do page throw if .INSERT
	TRO	R16,HDRBIT		; If .REQUIRE or .INCLUDE then page throw
	JRST	GETEOL			; Go to end of the line and return
>;IFN TENEX
IFE TENEX,<

	SKIPA	R11,[POINT 7,ARGSTR]
REQ1:	 CALL	GETCHR			; Get next character.
	CALL	TSTNT			; End of line?
	 CAIA
	  CAIN	R14,";"			;   Or semicolon?
	   JRST	REQPSH			; Yes, got input

	IDPB	R14,R11			; Put byte away
	JRST	REQ1			; Around we go again

REQPSH:	MOVEI	R14,15			; Put end of line char in buffer
	IDPB	R14,R11			; for GETSRC
	CALL	ACEXCH			; Get exec ACs
	MOVE	R2,REQSP		; Get stack pointer
	PUSH	R2,SRCDEV		; Stack device
	PUSH	R2,XE			; Stack filename
	PUSH	R2,XE1			; Stack extension
	PUSH	R2,XE3			; Stack PPN
	PUSH	R2,CHRCNT		; # of char read in this file
	PUSH	R2,INPGNM		; Input page number
	PUSH	R2,AC06			; Stack PAGE THROW flag
	MOVEM	R2,REQSP		; Save pointer
	CLOSE	SRC,			; Close old source file
	PUSH	P,TTIPNT		; Save pointer to command string
	MOVE	R11,[POINT 7,ARGSTR]	; Get pointer
	MOVEM	R11,TTIPNT		; New string for GETTI to look at
	PUSH	P,R16			; Save the flags
	TRZ	R16,ENDBIT		; Haven't seen end, have you?
	CALL	GETSRC			; Get a new source file
	POP	P,R16			; Get back old flags
	POP	P,TTIPNT		; Get back old command string pointer
	CALL	ACEXCH			; Get back assembler ACs
	TLO	R16,REQBIT		; Say that we in a .REQUIRE
	CAIE	R6,			; If .REQUIRE or .INCLUDE then page throw
	 TRO	R16,HDRBIT		; New page please
	JRST	GETEOL			; Go to end of the line and return
>;IFE TENEX

.OPDEF:					; .OPDEF HANDLER
	TLNN	R15,NSFFLG		; NONSTANDARD FEATURES ENABLED?
	TRO	R15,ERRO		;  NO, FLAG ERROR
	CALL	GETSYM			; GET THE NAME
	 JRST	.OPDE2			;  NULL, ERROR
	CAIE	R14,","			; TEST FOR COMMA
	JRST	.OPDE2			;  MISSING
	CALL	GETNB			; BYPASS COMMA
	PUSH	P,R0			; STACK NAME
	CALL	GETSYM			; GET THE TYPE
	 JRST	.OPDE1			;  NOT A SYMBOL, ERROR
	CAIE	R14,","
	JRST	.OPDE1			; MISSING COMMA
	CALL	GETNB			; BYPASS COMMA
	CALL	OSRCH			; SEARCH THE OP-CODE TABLE
	 JRST	.OPDE1			;  NOT THERE
	CAIE	R2,OCOP			; OP CODE?
	JRST	.OPDE1			;  NO, ERROR
	PUSH	P,R1			; OK, STACK TYPE
	CALL	ABSEXP			; COMPUTE BASIC VALUE
	POP	P,R0			; RETRIEVE TYPE
	DPB	R10,[POINT 16,R0,35]	; STORE NEW VALUE
	EXCH	R0,0(P)			; EXCHANGE FOR NAME
	CALL	MSRCH			; SET SEARCH INDEX
	 JFCL				; Don't worry if its defined already
	POP	P,R1			; RETRIEVE VALUE
	TLZ	R1,(MDMASK)		; MASK MODE BITS
	CALL	INSRT			; INSERT IN TABLE
	MOVSI	R1,MAOP			; CREF AS MACRO
	JRST	CRFDEF			; CREF AND EXIT

.OPDE1:	POP	P,0(P)			; PRUNE STACK
.OPDE2:	TRO	R15,ERRA		; FLAG ERROR
	RETURN				; EXIT


.GLOB2:	CALL	GETNB
.GLOBL:	TLNE	R15,ABSFLG		; .GLOBL PSEUDO-OP
	 JRST	OPCERR
	CALL	GETSYM			; GET A SYMBOL
	 JRST	.GLOB1			;  NULL, ERROR
.GLOB3:	CAMN	R0,M40DOT		; MESSING WITH PC?
	 JRST	.GLOB1			;  YES, ERROR
	CALL	SSRCH			; OK, SEARCH TABLE
	 JFCL
	TLNE	R1,REGSYM		; REGISTER SYMBOL?
	 TLOA	R1,MDFSYM		;  YES, ERROR
	  TLOA	R1,GLBSYM		; NO, FLAG GLOBAL
	   TRO	R15,ERRR		;  YES, FLAG REGISTER ERROR
	CALL	INSRT			; INSERT IN TABLE
	CALL	CRFREF			; Record reference for cross ref.
	 CAIA
.GLOB1:	  TRO	R15,ERRA		; ERROR FROM ABOVE
	CAIN	R14,","			; IS IT TERMINATED BY ","?
	 JRST	.GLOB2			;  Yes, insist on another symbol
	CALL	GETSYM			; See if there is another symbol
	 RETURN				;  No -- we must be done
	JRST	.GLOB3			;  Yes -- LOOP

.TITLE:					; TITLE PSEUDO-OP
	PUSH	P,R13			; SAVE POINTER
	PUSH	P,R14			; SAVE CHARACTER
	MOVE	R11,[POINT 7,TTLMSG]
	TLOA	R16,FOLBIT		; DON'T FOLD TITLE INTO UPPER CASE.
					;  AND SKIP ILDB THIS FIRST TIME
TTLP:	 CALL	GETCHR			; GET A CHAR
	CALL	TSTNT			; END OF LINE?
	 JRST	TTLEND			; YES, FINISH IT UP
	IDPB	R14,R11			; STORE CHAR IN BUFFER
	JRST	TTLP			; BACK AGAIN

TTLEND:	SETZ	R0,
	IDPB	R0,R11			; NULL BYTE INDICATES END
	TLZ	R16,FOLBIT		; RESUME FOLDING FOR GETSYM.
	POP	P,R14			; RESTORE CHAR
	POP	P,R13			; RESTORE POINTER
	CALL	GETSYM			; GET THE SYMBOL
	 JRST	[ TRO	R15,ERRA	; Can't get the symbol - flag error
		  JRST	TTLRT	]
	MOVEM	R0,PRGTTL		; OK, STORE TITLE
IFN CCLSW,<
	CALL	PRNAM
>;IFN CCLSW
	SETOM	TTLFLA			; SET FLAG
TTLRT:	JUMPE	R14,CPOPJ		; EXIT IF END OF LINE
	CALL	GETNB			; AVOID Q ERROR
	 JRST	TTLRT
	RETURN

.PDP10:
.EOT:
	RETURN

IFN CCLSW,<
PRNAM:
	SKIPN	TTLFLA			; ONLY PRINT PROGRAM NAME ONCE
	SKIPN	CCLFLA			; ONLY PRINT IF CCL MODE
	RETURN
	PUSH	P,R16			; SAVE FLAG STATUS
	MOVSI	R16,ERRBIT!LSTBIT!BINBIT ; TO ALLOW TTY OUTPUT
	MOVE	R0,PRGTTL		; GET PROGRAM TITLE
	CALL	M40SIX			; CONVERT MOD40 TO SIXBIT
	CALL	LSTSIX
	CALL	LSTCR
	POP	P,R16
	RETURN
>;IFN CCLSW
.ASCIZ:	TDZA	R2,R2			; ".ASCIZ" DIRECTIVE
.ASCII:	 MOVEI	R2,1			; ".ASCII" DIRECTIVE

	TLO	R16,FOLBIT		; OVERRIDE FOLDING TO COLLECT ASCII.
	MOVE	R0,LSTCTL		; Get listing control flags
	TRNN	R0,LASC			; List binary bytes?
	 TRO	R16,ASCBIT		; No - set flag
	PUSH	P,RLOC			; SAVE CURRENT PC VALUE.

.ASCI1:	CALL	ASCOP			; PROCESS AN OPERAND.
.ASCI3:	CALL	GETNT			; CHECK NEXT CHARACTER.
	 JRST	.ASCI2			; ** END OF LINE
	CAIN	RBYTE,";"		; ** NOT EOL - IS IT START OF COMMENT?
	 JRST	.ASCI2			; .. YES - QUIT HERE.
	CAIE	RBYTE," "		; .. NO -- BLANK OR TAB?
	 CAIN	RBYTE,TAB
	  JRST	.ASCI3			;    YES - SKIP IT.
	JRST	.ASCI1			;    NO - HANDLE CONCATENATED OPERAND.


;	   END OF OPERAND FIELD.  APPEND A 0 BYTE IF OPERATION
;	   IS .ASCIZ.

.ASCI2:	SETZ	RBYTE,			; READY A 0 BYTE.
	CAIN	R2,			; WHICH DIRECTIVE IS THIS?
	 CALL	ASCOUT			; ** .ASCIZ - OUTPUT THE 0.
	POP	P,RLOC			; Restore original PC
	RETURN				;  and exit


; ----------  PROCESS AN OPERAND  ------------

ASCOP:	CAIN	RBYTE,"<"		; IS OPERAND IN BRACKETS?
	 JRST	ASCEXP			; YES - IT'S A NUMBER.
	MOVE	R3,RBYTE		; NO - SAVE DELIMITER BYTE.

ASCTEX:	CALL	GETNT			; GET NEXT BYTE.
	 JRST	ASCTER			; END OF LINE ISN'T LEGAL.
	CAMN	RBYTE,R3		; IS THIS THE DELIMITER?
	 RETURN				; YES -- QUIT HERE.
	CALL	ASCOUT			; NO -- STORE THE BYTE.
	JRST	ASCTEX


ASCTER:	TRO	RERR,ERRA		; ** ILLEGAL END OF LINE **
	POP	P,0(P)			; TIDY UP THE STACK.
	JRST	.ASCI2			; DO A KOSHER EXIT.



;  Process one or more expressions of the form:
;    <e1,e2,e3,....,eN>

ASCEXP:	PUSH	P,R2			; SAVE .ASCII/.ASCIZ FLAG.
	TLZ	R16,FOLBIT		; RESUME FOLDING INPUT.

ASCNXT:	CALL	GETNB			; SKIP "<" OR ",".
	CALL	EXPR			; DECIPHER AN EXPRESSION
	 JRST	[ POP	P,R2		; Restore flag
		  JRST	ASCQ  ]		;  and set a Q flag
	PUSH	P,R14			; SAVE THE TERMINATING DELIMITER.
	MOVE	R14,R10			; COPY BINARY RESULT TO BYTE REG,
	TRCN	R14,177400		; Overflow test and complement bits
	 JRST	ASCQ0			; No overflow
	TRZE	R14,777000		; TEST FOR BAD MAGNITUDE.
	 TRO	RERR,ERRT		; :: FLAG A TRUNCATION ERROR ::

ASCQ0:	CALL	ASCOUT			; STORE THIS BYTE.
	POP	P,R14			; RELOAD NUMBER'S DELIMITER.
	CAIN	R14,","			; "," => GET ANOTHER NUMBER.
	 JRST	ASCNXT

	TLO	R16,FOLBIT		; QUIT FOLDING INPUT AGAIN.
	POP	P,R2			; RESTORE .ASCII/.ASCIZ FLAG.
	CAIE	R14,">"			; WAS ENDING DELIM PROPER?
ASCQ:	 TRO	RERR,ERRQ		; -- NO - QUESTIONABLE SYNTAX.
	RETURN




;  STORE NEXT BYTE.

ASCOUT:	MOVE	R1,R14			; COPY BYTE TO BE STORED TO PARM REG.
	HRLI	R1,BC1			; SHOW BYTE COUNT = 1.
	CALL	STCODE			; STORE THE BYTE.
	AOJA	RLOC,CPOPJ		; INCREMENT PC AND RETURN.
.PAGE:					; FORCE A PAGE EJECT
	SKIPL	LSTCNT			; If .NLIST is in effect don't do it
	 TLNE	RMODE,P1F		; IS THIS PASS 2?
	  RETURN				; NO - TAKE NO ACTION.
	MOVE	R0,LSTCTL		; Get listing mode flags
	TLNE	R16,MEXBIT		; If in macro expansion and
	 TRNE	R0,LME			;  listing is suppressed then skip
	  TRO	R16,HDRBIT		; New page
	TRNN	R0,LLD			; IS .NLIST LD IN EFFECT?
	 TLO	R16,NLISLN		; YES -- DON'T LIST .PAGE
	RETURN




.SBHED:					; SUBHEADING DIRECTIVE
	TDZA	R2,R2			; CLEAR R2 TO FLAG .SBHED ENTRY.
.SBTTL:					; "SUBTITLE" PSEUDO-OP
	 SETO	R2,			; SET R2 TO BITS TO FLAG .SBTTL ENTRY.
	TLO	R16,FOLBIT		; DON'T FOLD INPUT.
	TLNE	RMODE,P1F		; IS THIS PASS 1?
	 JRST	SBP1			; YES - JUST LIST STUFF

;	   ----------  PASS 2 PROCESSING  -----------

	SKIPA	R11,[POINT 7,SUBMSG]	; OBTAIN POINTER TO BUFFER
SBLP:	 CALL	GETCHR			; GET NEXT CHARACTER.
	CALL	TSTNT			; END OF LINE SEEN?
	JRST	SBEND			; YES, GET OUT
	IDPB	R14,R11			; PUT BYTE AWAY
	JRST	SBLP			; DO ANOTHER
SBEND:	MOVEI	0			; END OF SUBTITLE
	IDPB	R11			; IS A ZERO BYTE
	TLO	R16,SBTBIT		; MARK THAT WE HAVE SEEN A SBTTL
	CAIN	R2,			; Skip if .SBTTL and not .SBHED
	 TRO	R16,HDRBIT		; Request header on next output
	RETURN



;	   -------------  PASS 1 PROCESSING  ---------------

SBP1:	MOVE	R0,LSTCTL		; IS TOC LISTING ENABLED?
	TRNE	R0,LTOC
	 SKIPGE	LSTCNT
	  RETURN				; NO - QUIT.
	TLOE	R16,SBTBIT		; YES - SUBHEAD ALREADY SET?
	 JRST	SBTOCL

;   SUPPLY 'TABLE OF CONTENTS' AS SUBTITLE.

	MOVE	R0,[XWD TOCSUB,SUBMSG]	; COPY TOC PROSE
	BLT	R0,SUBMSG+SBMEND-TOCSUB	; INTO SUBTITLE BUFFER
	TRO	R16,HDRBIT		; FORCE PAGE SKIP

;   LIST OPERAND FIELD OF .SBTTL DIRECTIVE

SBTOCL:	CALL	FORSEQ			; FORMAT SEQUENCE # FIELD.
SBSEQ:	CALL	LPTOUT			; LIST A BYTE.
	ILDB	R2,R6			; GET NEXT BYTE OF FORMATTED SEQ.
	JUMPN	R2,SBSEQ		; REPEAT UNTIL FINDING 0.

	CALL	LSTTAB			; FOLLOW WITH 2 TABS.
	CALL	LSTTAB

	CALL	SETCHR			; LOAD FIRST BYTE OF SUBTITLE

SBTOCN:	MOVE	R2,R14			; COPY BYTE TO R2 FOR LPTOUA
	CALL	TSTNT			; CHECK FOR END OF LINE
	JRST	SBENDL			; <- RET 0 - END OR NULL
					; <- RET 1 - PART OF TEXT
	CALL	LPTOUA			; PRINT NEXT BYTE
SBTGNX:	CALL	GETCHR			; SCAN TO FOLLOWING BYTE.
	JRST	SBTOCN

SBENDL:	JUMPE	R2,SBTGNX		; IGNORE A NULL BYTE
	TDZ	R2,R2			; END OF LINE -- PRINT CR/LF
	CALL	LPTOUA
	RETURN


TOCSUB:	ASCIZ	/		Table  of  Contents/
SBMEND=	.


;	============  .LIST & .NLIST  ============

.LIST:	MOVE	R0,[XWD LISSET,LISTBL]	; CALL SUBROUTINE TO PARSE
	CALL	ARGSET			; ARGUMENT FIELD
	AOSA	LSTCNT			; ** NO ARGS -- INCREMENT LIST LEVEL
	RETURN
	JRST	LISTYP


.NLIST:	MOVE	R0,[XWD LISRES,LISTBL]	; CALL ARG PARSER
	CALL	ARGSET
	SOSA	LSTCNT			; ** NO ARGS -- DECREMENT LIST LEVEL
	RETURN

LISTYP:	HRRZ	R0,LSTCTL		; EITHER .LIST OR .NLIST HAD NO ARGS
	TRNN	R0,LLD			; SHOULD IT BE LISTED?
	TLO	R16,NLISLN		; NO - SET "UNLIST LINE" FLAG
	RETURN



LISSET:	CALL	LSSSUB			; /// EXECUTED BY ARGSET ///
LISRES:	CALL	LSRSUB			; /// EXECUTED BY ARGSET ///


LSSSUB:	HRLZ	R2,R2			; MOVE MODE BIT TO LH.
	IORM	R2,LSTCTL		; OR IT ON IN MEMORY.
	JRST	SETLF			; SET LIST FLAGS & RETURN.

LSRSUB:	HRLZ	R2,R2			; MOVE MODE BIT TO LH.
	ANDCAM	R2,LSTCTL		; CLEAR IT IN MEMORY.
					; SET LIST FLAGS & RETURN.

;	    SETLF SETS THE EFFECTIVE LISTING MODE FLAGS
;	    IN THE RIGHT HALF OF LSTCTL TO ACCOUNT FOR
;	    DIRECTIVES IN THE SOURCE AND OVERRIDES IN
;	    THE COMMAND STRING.  IT'S CALLED BY INITIALIZATION,
;	    SWITCH PROCESSING, AND THE TWO SUBROUTINES ABOVE.

;	    NOTE THAT THE MANIPULATIONS BELOW DEAL WITH ONLY
;	    THE RIGHT HALF OF R0 & R1.  THE LEFT HALF GOES
;	    ALONG FOR THE RIDE, BUT NEVER GETS STORED.

SETLF:	MOVS	R0,LIWORD		; LOAD OVERRIDE MASK.
	HLRZ	R1,LSTCTL		; LOAD SOURCE MODES.
	ANDCAM	R0,R1			; CLEAR OVERRIDDEN BITS.
	AND	R0,LIWORD		; R0 = OVERRIDDEN BITS TO BE
	IOR	R1,R0			; FORCED ON.
	HRRM	R1,LSTCTL		; STORE FINAL RESULT.
	RETURN

LISTBL:	XWD	-<LISTBX-LISTBL>,.+1	; -<# args>,<1st arg addr>
	ARG	B,E,X,LBEX		; TABLE OF .LIST & .NLIST OPERANDS
	ARG	B,I,N,LBIN
	ARG	C,O,M,LCOM
	ARG	C,N,D,LCND
	ARG	L,D, ,LLD
	ARG	L,O,C,LLOC
	ARG	M,C, ,LMC
	ARG	M,D, ,LMD
	ARG	M,E, ,LME
	ARG	M,E,B,LMEB
	ARG	S,E,Q,LSEQ
	ARG	S,O,N,LSON
	ARG	S,R,C,LSRC
	ARG	S,Y,M,LSYM
	ARG	T,O,C,LTOC
	ARG	T,T,M,LTTM
	ARG	A,S,C,LASC
	ARG	F,L,C,LFLC
LISTBX=.
;	===========  .ENABL  &  .DSABL  ============

.ENABL:
	PUSH	P,RMODE			; SAVE MODE FLAGS
	MOVE	R0,[XWD ENASET,ENATBL]	; LOAD PARMS & CALL ARGSET
	CALL	ARGSET			; TO SET FLAGS
	TRO	RERR,ERRQ		; NO PARMS => Q ERROR

	POP	P,R0			; RETRIEVE OLD FLAGS
	XOR	R0,RMODE		; R0 = BITS TURNED ON BY .ENABL
	TLNE	R0,ABSFLG		; WAS ABS MODE SET?
	TLZ	RLOC,(PFMASK)		; YES - RESET RELOCATION
	RETURN


.DSABL:
	MOVE	R0,[XWD ENARES,ENATBL]
	CALL	ARGSET			; CALL SUBR TO INTERPRET ARGS
	TRO	RERR,ERRQ		; NONE => Q ERROR
	RETURN


ENASET:	CALL	ENSSUB			; ** EXECUTED TO ENABLE A MODE **
ENARES:	CALL	ENRSUB			; ** EXECUTED TO DISABLE A MODE **


ENSSUB:	HRLZ	R2,R2			; SET AN ENABL OPTION BIT.
	IORM	R2,ENACTL		; STORE IN ENACTL LH.
	tlne	r2,Lsbflg		; Was a local symbol block enabled?
	call	Locras			;    Yes - Reset local symbol block.
	JRST	SETEN			; RETURN VIA SETEN.

ENRSUB:	HRLZ	R2,R2			; CLEAR AN ENABL OPTION BIT.
	ANDCAM	R2,ENACTL		; STORE IN ENACTL LH.
					; RETURN VIA SETEN.


;	   SETEN SETS THE EFFECTIVE ENABL MODE BITS IN ENACTL
;	   AND IN RMODE (R15) IN ESSENTIALLY THE SAME WAY
;	   SETLF SETS LISTING MODES.  THE ONLY DIFFERENCE IS
;	   IN COPYING THE RESULTING BIT VALUES INTO RMODE.

SETEN:	MOVS	R0,ENWORD		; GET OVERRIDE OPTION BITS.
	HLRZ	R1,ENACTL		; LOAD OPTIONS SET IN SOURCE.
	ANDCAM	R0,R1			; CLEAR OVERRIDDEN BITS.
	AND	R0,ENWORD		; R0 = BITS TO FORCE ON.
	IOR	R1,R0			; ... FORCE THEM.
	HRRM	R1,ENACTL		; STORE RESULT.
	TLZ	RMODE,ENMASK		; CLEAR ALL ENABL BITS IN RMODE.
	TLO	RMODE,0(R1)		; SET THOSE WHICH ARE STILL ON.
	RETURN


ENATBL:	XWD	-<ENAEND-ENATBL>,.+1	; .ENABL/.DSABL ARGUMENTS
	ARG	A,B,S,ABSFLG
	ARG	A,M,A,AMAFLG
	ARG	C,D,R,CDRFLG
	ARG	F,P,T,FPTFLG
	ARG	G,B,L,GBLFLG
	ARG	.,5,K,HFKFLG
	ARG	H,O,V,HOVFLG
	ARG	I,S,D,ISDFLG
	ARG	L,C, ,LCFLG
	ARG	L,S,B,LSBFLG
	ARG	N,S,F,NSFFLG
	ARG	P,N,C,PNCFLG
	ARG	R,E,G,REGFLG
ENAEND=.

;	************  .ERROR AND .PRINT  *************

.ERROR:	TRO	RERR,ERRP		; FLAG LINE WITH "P" (!)

.PRINT:	TLNE	RMODE,P1F		; IGNORE .ERROR & .PRINT
	RETURN				; ON PASS 1

	TLO	R16,LBLBIT!PF1BIT!ERRBIT ; PRINT LOC & EXPR VALUE
	MOVEM	RLOC,PF0		; ON BOTH TTY & LISTING

;	LIST EXPRESSION VALUE, IF ONE EXISTS

	CALL	EXPR			; EVALUATE EXPRESSION, IF ANY.
	 CAIA				; NO EXPRESSION - LEAVE PF1=0
	  MOVEM	R10,PF1			; STORE EXPR VALUE IN PRINT FIELD 1

	RETURN				; LET ENDL DO THE REST.

.BYTE:					; "BYT" PSEUDO-OP
	PUSH	P,R5			; STACK PC
.BYTE1:	CALL	EXPRF			; EVALUATE EXPRESSION
	 JFCL				;  ACCEPT NULLS
	TRCN	R10,177400		; OVERFLOW?
	JRST	.BYTE2			;  NO.
					; HIGH BITS ARE NOW COMPLEMENTED.
	TRZE	R10,177400		; MASK TO 8 BITS.
					; ANY OVERFLOW
	 TRO	R15,ERRT		; YES, FLAG IT
.BYTE2:	CALL	TSTAR
	LDB	R2,MODPNT		; GET CLASS
	CAIE	R2,RLDT1
	CAIN	R2,RLDT15		; IF RELOCATABLE,
	 TRO	R15,ERRA		;  ERROR
	TLC	R1,BC1!BC2		; RESET TO ONE BYTE
	CAIE	R2,			; Absolute?
	 TLO	R1,(1B0)		; No - make it byte modification
	CALL	STCODE			; Yes - stow the code away
	CAIE	R14,","			; ANY MORE
	JRST	.WORDX			;  NO, EXIT
	CALL	GETNB			; BYPASS COMMA
	AOJA	R5,.BYTE1		; INCREMENT PC AND LOOP


.WORD:					; "WORD" PSEUDO-OP
	CALL	TSTEVN
	PUSH	P,R5			; STACK PC
.WORD1:	CALL	EXPRF			; EVALUATE EXPRESSION
	 JFCL				;  ACCEPT NULLS
	CALL	TSTAR
	CALL	STCODE
	CAIE	R14,","			; END OF STRING?
	JRST	.WORDX			;  YES, EXIT
	CALL	GETNB			; BYPASS COMMA
	ADDI	R5,2			; INCREMENT PC
	JRST	.WORD1			; GO FOR MORE

.WORDX:	POP	P,R5			; RESTORE ORIGINAL PC
	RETURN

.BLKW:	TDZA	R3,R3			; "BLKW" PSEUDO-OP - R3 = 0

.BLKB:					; "BLKB" PSEUDO-OP
	 HRLZI	R3,DEFSYM		; R3 = DEFSYM
	PUSH	P,R3			; SAVE WORD/BYTE FLAG (R3)
	CALL	EXPR			; EVALUATE EXPRESSION
	TRO	R10,1			; DEFAULT NULL EXPR TO 1
	CALL	ABSTST			; TEST IF ABSOLUTE EXPRESSION
	POP	P,R3			; RESTORE WORD/BYTE FLAG
	TLO	R16,LBLBIT!PF1BIT	; FORCE LOC & EXPR TO PRINT
	MOVEM	RLOC,PF0		; STORE LOC TO PRINT
	MOVEM	R10,PF1			; STORE EXPR TO PRINT

	TLON	R3,DEFSYM		; CHECK IF THIS IS .BLKW
	LSH	R10,1			;    YES, MULT 2*EXPR
	ORM	R3,PF1			; MAKE SURE ZERO PRINTS
	ADD	R5,R10			; INCREMENT PC AS CALCULATED
	MOVE	R1,R5			; GET PC
	HRLI	R1,(<RLDT10>B<MODOFF>)	; FLAG AS CLASS 10
	JRST	STCODE			; STOW CODE & EXIT

.ROUND:	TLZA	R15,FPTFLG		; CLEAR TRUNCATION FLAG
.TRUNC:	 TLO	R15,FPTFLG		; SET TRUNCATION FLAG
	RETURN

.FLT2:	SKIPA	R3,[2]			; TWO WORD FLOATING
.FLT4:	 MOVEI	R3,4			; FOUR WORD FLOATING
	MOVEM	R3,FLTLEN		; SET LENGTH FOR ROUNDING
.FLTC:	CALL	FLTG			; PROCESS FLOATING POINT
	TLNE	R15,FLTFLG		; ANY ERRORS?
	TRO	R15,ERRA		;  YES
	MOVN	R6,FLTLEN		; SET NEGATIVE OF LENGTH
	HRLZS	R6			; SET INDEX
.FLTC1:	MOVE	R1,FLTNUM(R6)		; GET A VALUE
	HRLI	R1,BC2
	CALL	STCODE			; STORE IT
	AOBJN	R6,.FLTC1		; LOOP IF MORE
	CAIE	R14,","			; MULTIPLE?
	JRST	.FLTC2			;  NO
	CALL	GETNB			; YES, MOVE PAST COMMA
	JRST	.FLTC			; GET ANOTHER

.FLTC2:	MOVE	R3,LSTCTL		; Get listing control flags
	TRNN	R3,LFLC			; Are we to list the expanded floating comment?
	RETURN				;  No, skip the rest of this
					;  Yes, generate " (S EEE MMMMMMMMM)" comment
	HRROI	R3,774000
	MOVE	R6,FLTLEN
	CAIN	R6,2			; TWO WORD?
	ANDM	R3,FLTLST		;  YES, TRUNCATE
	MOVE	R1,[POINT 7,FLTBUF]	; SET POINTER TO BUFFER
	MOVEI	R2,SPACE
	IDPB	R2,R1			; STORE SPACE
	MOVEI	R2,"("
	IDPB	R2,R1			;  AND "("
	LDB	R0,[POINT 9,FLTNUM,35-16+9]
	MOVEI	R2,"0"
	TRZE	R0,400			; SIGN BIT?
	MOVEI	R2,"1"			;  YES
	IDPB	R2,R1
	MOVEI	R2,SPACE
	IDPB	R2,R1
	MOVSI	R3,(POINT 3,R0,35-9)
.FLTC3:	ILDB	R2,R3			; STORE EXPONENT
	ADDI	R2,"0"
	IDPB	R2,R1
	TLNE	R3,770000
	JRST	.FLTC3
	MOVEI	R2,SPACE
	IDPB	R2,R1
	MOVE	R3,[POINT 3,FLTLST]	; GET SET TO LIST FRACTION
	MOVEI	R0,^D9			; ASSUME DOUBLE WORD
	CAIE	R6,2
	MOVEI	R0,^D19
.FLTC4:	ILDB	R2,R3
	ADDI	R2,"0"
	IDPB	R2,R1
	SOJG	R0,.FLTC4		; LOOP IF NOT END
	MOVEI	R2,")"			; STORE END CHARACTERS
	IDPB	R2,R1
	MOVEI	R2,CRR
	IDPB	R2,R1
	MOVEI	R2,LF
	IDPB	R2,R1
	IDPB	R0,R1			; STORE NULL
	RETURN



;	   Routine to copy FLTBUF to LINBUF such that the expanded floating
;	   comment will line up with the comment on the .FLTn, if any.

FLTCOP:	MOVE	R0,LINPNT		; Point to start of line buffer
FLTLP1:	ILDB	R2,R0			; Pick up next byte from line buffer
	CAMN	R0,FLTCOL		; Is this the comment column?
	JRST	FLTCO1			;  Yes, start copying FLTBUF
					;  No, replace all non-TABs with SPACEs
	CAIE	R2,TAB			; Is this character a TAB?
	MOVEI	R2,SPACE		;  No, replace it with a SPACE
	DPB	R2,R0			; Replace SPACE or TAB in line buffer
	JRST	FLTLP1			; Do all of them

FLTCO1:	MOVEI	R2,";"			; Put in a semi-colon
	DPB	R2,R0			; in comment column
	MOVE	R1,[POINT 7,FLTBUF]	; Point to the expanded floating point
FLTLP2:	ILDB	R2,R1			; Get a byte from FLTBUF
	IDPB	R2,R0			; and put it in LINBUF
	JUMPN	R2,FLTLP2		; Loop up to the NUL
	SETZM	FLTBUF			; Empty the FLTBUF now
	RETURN
FLTG:
	TLZ	R15,FLTFLG		; CLEAR ERROR FLAG
	SETZB	R0,FLTNUM
	SETZB	R1,FLTNUM+1
	SETZB	R2,FLTNUM+2
	SETZB	R3,FLTNUM+3
	SETZM	FLTLST			; CLEAR FOR EXPANDED LISTING
	SETZM	FLTLST+1
	CAIN	R14,"-"
	TLO	R0,(1B0)
	EXCH	R0,FLTNUM
	SKIPL	FLTNUM
	CAIN	R14,"+"
FLTG2:	CALL	GETCHR
	CAIL	R14,"0"
	CAILE	R14,"9"
	JRST	FLTG3
	TLNE	R0,760000
	AOJA	R3,FLTG2
	ASHC	R0,1
	MOVEM	R0,FLTTMP
	MOVEM	R1,FLTTMP+1
	ASHC	R0,2
	ADD	R0,FLTTMP
	ADD	R1,FLTTMP+1
	ADDI	R1,-"0"(R14)
	TLZE	R1,(1B0)
	ADDI	R0,1
	AOBJP	R3,FLTG2

FLTG3:	CAIE	R14,"."
	JRST	FLTG4
	TRNE	R2,400000
	TLO	R15,FLTFLG
	MOVEI	R2,400000(R3)
	JRST	FLTG2

FLTG4:	CAIN	R3,
	TLO	R15,FLTFLG
	TRZN	R2,400000
	HRRZ	R2,R3
	HLRZS	R3
	SUB	R2,R3
	CAIE	R14,"E"
	JRST	FLTG6
	CALL	GETCHR

	PUSH	P,R0
	PUSH	P,R1
	SETZB	R0,R1
	CAIN	R14,"-"
	SOSA	R1
	CAIN	R14,"+"
FLTG5:	CALL	GETCHR
	CAIL	R14,"0"
	CAILE	R14,"9"
	JRST	FLTG5A
	IMULI	R0,^D10
	ADDI	R0,-"0"(R14)
	JRST	FLTG5

FLTG5A:	CAIE	R1,
	MOVNS	R0
	ADD	R2,R0
	POP	P,R1
	POP	P,R0
FLTG6:	CAIN	R1,0
	 JUMPE	R0,FLTG12
	TDZA	R3,R3
FLTG7:	 ASHC	R0,1
	TLNN	R0,200000
	 SOJA	R3,FLTG7
	JUMPL	R2,FLTG9
FLTG8:	SOJL	R2,FLTG10
	MOVEM	R0,FLTTMP
	MOVEM	R1,FLTTMP+1
	ASHC	R0,-2
	ADD	R0,FLTTMP
	ADD	R1,FLTTMP+1
	TLZE	R1,(1B0)
	ADDI	R0,1
	TLNE	R0,(1B0)
	CALL	FLTG20
	ADDI	R3,3
	JRST	FLTG8

FLTG9:	CAML	R0,[^D10B4]
	CALL	FLTG20
	PUSH	P,R1+1
	DIV	R0,[^D10B4]
	DIV	R1,[^D10B4]
	POP	P,R1+1
	SUBI	R3,4
	AOJL	R2,FLTG9
FLTG10:	PUSH	P,R3			; STACK EXPONENT
	MOVSI	R2,(1B<16-7>)		; SET ONE WORD ROUNDING BIT
	SETZ	R3,			; CLEAR LOW ORDER
	SKIPA	R4,FLTLEN		; GET LENGTH AND SKIP
	 ASHC	R2,-^D16		; MOVE ROUNDING MASK
	SOJG	R4,.-1
	TDNN	R0,R2			; TEST FOR ROUNDING REQUIRED
	TDNE	R1,R3
	TLNE	R15,FPTFLG		; YES, "ROUND" MODE?
	JRST	FLTG11			; NO, FORGET ROUNDING
	ASHC	R2,1			; SHIFT BIT UP ONE
	ADD	R0,R2
	ADD	R1,R3			; ADD IN BIT
FLTG11:	POP	P,R3			; RESTORE EXPONENT
	TLZE	R1,(1B0)		; OVERFLOW, LOW ORDER?
	ADDI	R0,1			;  YES, ADD TO UPPER
	TLNE	R0,(1B0)		; OVERFLOW, HIGH ORDER?
	CALL	FLTG20			;  YES, CORRECT
	LSH	R1,1			; MOVE OVER SIGN BIT
	MOVEM	R0,FLTLST		; STORE FOR EXPANDED LISTING
	MOVEM	R1,FLTLST+1
	LSHC	R0,-7			; MAKE ROOM FOR EXPONENT
	ADDI	R3,^D<35+35+128>
	DPB	R3,[POINT 8,R0,8]
	LDB	R2,[POINT 8,R0,8]
	CAME	R2,R3			; OVER/UNDER FLOW?
	TRO	R15,ERRT		;  YES
FLTG12:	IOR	R0,FLTNUM
	MOVSI	R2,-4
FLTG13:	LDB	R3,[POINT 16,R0,15]
	MOVEM	R3,FLTNUM(R2)
	LSHC	R0,^D16
	AOBJN	R2,FLTG13
	JRST	SETNB

FLTG20:	LSH	R1,1
	LSHC	R0,-1
	LSH	R1,-1
	AOJA	R3,CPOPJ

	SUBTTL	ASSEMBLER DIRECTIVE ARGUMENT INTERPRETER

;	SUBROUTINE ARGSET PARSES THE REMAINING INPUT ON THE LINE,
;	CHECKING FOR ARGUMENTS SPECIFIED IN A TABLE SUPPLIED BY
;	THE CALLER.  WHEN IT FINDS ONE, IT EXECUTES AN INSTRUCTION
;	SUPPLIED BY THE CALLER WITH A VALUE FROM THE TABLE IN R2.

;	INPUT TO ARGSET:

;	R0 HIGH ORDER HALFWORD = ADDRESS OF INSTRUCTION TO EXECUTE
;		WHEN A PROPER ARG IS FOUND
;	R0 LOW ORDER HALFWORD = ADDRESS OF ARGUMENT TABLE

;	CALL IS VIA "CALL  ARGSET"

;	RETURNS:

;	0(P) -- NO ARGUMENTS FOUND
;	1(P) -- ONE OR MORE ARGUMENTS WERE FOUND

;	IF AN INVALID ARGUMENT APPEARS IN THE SOURCE LINE
;	ARGSET SETS "ERRQ" TO GENERATE A Q FLAG.


;	FORMAT OF ARG TABLE:

;	WORD 0:		XWD -(# OF ENTRIES IN TABLE),.+1
;	WORDS 1-N :	VALUE,ARGCODE
;
;		VALUE IS ANY VALUE DESIRED (LIKELY A BIT MASK)
;			TO BE LOADED IN R2 WHEN THE ARG IS FOUND
;			& THE CALLER'S INSTRUCTION IS EXECUTED.

;		ARGCODE IS THE ARGUMENT IN MOD40 FORMAT


ARGSET:	PUSH	P,R0			; SAVE CALLER'S PARMS
	CALL	GETSYM			; DECODE NEXT SYMBOL
	 CAIA				; - SKIP IF NONE
	  JRST	ARSER			; EXIT TO SEARCH TABLE

	POP	P,R0			; **** NO ARGUMENT -- POP STACK
	RETURN				; & RETURN TO CALLER


;	*** SCAN FOR NEXT ARGUMENT ***

ARNEX:	IBP	RBPTR			; SKIP ","
	CALL	GETSYM			; TRY FOR ANOTHER SYMBOL
	JRST	AREXIT			; NONE -- QUIT HERE

;	SEARCH ARGUMENT TABLE FOR THE SYMBOL JUST FOUND

ARSER:	TRZE	R0,			; IS SYMBOL LONGER THAN 3 CHARS?
	JRST	ARBAD			; YES -- INVALID ARGUMENT
	MOVSS	R0,			; NO -- MOVE SYM TO RIGHT HALF
	HRRZ	R1,0(P)			; LOAD TABLE LOC, THEN
	MOVE	R1,0(R1)		; LOOP CONTROL WORD INTO R1

ARSERL:	MOVE	R3,0(R1)		; LOAD ARG VALUE FROM TABLE
	CAIN	R0,(R3)			; DOES OPERAND MATCH?
	JRST	ARFOUN			; YES
	AOBJN	R1,ARSERL		; NO - KEEP SEARCHING

ARBAD:	TRO	RERR,ERRQ		; INVALID ARG -- SET Q FLAG
	JRST	AREXIT			; & QUIT

ARFOUN:	HLRZ	R2,R3			; FOUND ARG -- LOAD VALUE
	HLRZ	R1,0(P)			; FROM TABLE & EXECUTE
	XCT	0(R1)			; CALLER'S INSTRUCTION

	LDB	R0,RBPTR		; CHECK NEXT SOURCE BYTE
	CAIN	R0,","			; TEST FOR ","
	JRST	ARNEX			; "," => GET ANOTHER ARG

AREXIT:	POP	P,R0			; RETURN AFTER FINDING AN ARG
	JRST	CPOPJ1

	SUBTTL	REPEAT HANDLER

REPEA0:					; "REPEAT" PSEUDO-OP
	CALL	MDLTST			; TEST MD LISTING MODE
	CALL	ABSEXP			; EVALUATE EXPRESSION
	TRNE	R15,ERRU		; ANY UNDEFINED ERRORS?
	TRO	R15,ERRP1		;  YES, MENTION ON PASS 1
	LSH	R10,+^D<36-16>		; ADJUST SIGN TO 36 BITS
	ASH	R10,-^D<36-16>
	CAIN	R10,1			; IF SINGLE,
	JRST	BEGR0			;  PROCESS IN LINE
	PUSH	P,R10			; STACK EXPRESSION
	CALL	ENDLR			; LIST LINE
	CALL	GETBLK			; MULTIPLE, SDT FOR STORAGE
	PUSH	P,MWPNTR		; SAVE STARTING BLOCK ADDRESS
	MOVEI	R11,3
	ADDM	R11,MWPNTR		; POINT PAST POINTER STORAGE
	SETZ	R7,			; ZERO LEVEL COUNT
REPEA1:	CALL	GETMLI			; GET THE NEXT SOURCE LINE
	 JRST	REPEA3			;  END OF FILE
	CAMN	R0,.REPTX		; .REPT in this repeat?
	 AOJA	R7,REPEA2		;  Yes - increment and jump
	CAMN	R0,.IRPOP		; Also check for .IRP
	 AOJA	R7,REPEA2
	CAMN	R0,.IRCOP		;   .IRPC
	 AOJA	R7,REPEA2
	CAME	R0,.ENDMX		; CHECK FOR EITHER .ENDM OR .ENDR
	CAMN	R0,.ENDRX
	SOJL	R7,REPEA3		;  DECREMENT AND BRANCH IF END
REPEA2:	TLO	R16,FOLBIT		; DON'T FOLD LC TO UC IN DEFINITION.
	SKIPA	RBPTR,LINPNT		; POINT TO START OF LINE.
	 CALL	WCIMT			; WRITE CHAR IN MACRO TREE
	CALL	GETCHR			; GET THE NEXT CHARACTER
	JUMPN	R14,.-2			; TEST FOR CR
	CALL	ENDLR			; LIST THE LINE
	TLNN	R15,ENDFLG		; SKIP IF EOF SEEN
	JRST	REPEA1			; TRY THE NEXT LINE

REPEA3:	MOVEI	R14,QUEREP		; END, SET TO CLOSE
	CALL	WTIMT			; WRITE FLAG AND "REPEAT END"
	POP	P,R11			; RETRIEVE STARTING POINTER
	MOVEI	R10,-1(R11)		; SET FOR PUSH
	PUSH	R10,R12			; STORE READ POINTER
	PUSH	R10,REPPNT		;  REPEAT POINTER
	PUSH	R10,REPEXP		;  AND REPEAT EXPRESSION
	MOVEM	R11,REPPNT		; SET NEW REPEAT POINTER
	POP	P,REPEXP		;  AND REPEAT COUNT
;	JRST	REPEND


REPEND:					; REPEAT END
	MOVE	R12,REPPNT		; ASSUME ANOTHER ITERATION
	ADDI	R12,3			; POINT PAST POINTERS
	SOSL	REPEXP			; END?
	 RETURN				;  NO
REPFIN:	MOVE	R1,REPPNT		;  YES, GET SET TO CLEAN UP
	HRROI	R10,2(R1)		; POINT TO TOP POINTER
	POP	R10,REPEXP		; REPLACE STORED ITEMS
	POP	R10,REPPNT
	POP	R10,R12
	JRST	REMMAC			; Garbage collect and return


;    REPEATS CAN BE ENDED BY EITHER A .ENDM OR A .ENDR;
;	   .ENDM'S WHICH END A MACRO ARE PROCESSED ONLY BY
;	   THE MACRO DEFINITION PROCESSOR -- WHEN THE STATEMENT
;	   PROCESSOR FINDS A .ENDM, AND DISPATCHES TO LOCATION
;	  .ENDM, IT MUST BE THE END OF A REPEAT.

.ENDM:

ENDR0:					;  ".ENDR" PSEUDO-OP
	SKIPG	REPLVL			; IN REPEAT?
	JRST	OPCERR			;  NO, ERROR
	SOSA	REPLVL			; YES, DECREMENT LEVEL COUNT
BEGR0:	AOS	REPLVL			; REPEAT ONCE
	RETURN

	SUBTTL	REPEAT/CONDITIONAL ROUTINES

.IFNDF:	TDZA	R2,R2
.IFDF:	 SETO	R2,			; SET TRUE
	SETOB	R3,R4			; SET RESULT AND CHAR TRUE (&)
.IFDF1:	PUSH	P,R4			; STACK CURRENT RESULTS
	PUSH	P,R3
	PUSH	P,R2
	CALL	GETSYM			; GET THE NEXT SYMBOL
	 TROA	R15,ERRA		;  NOT THERE, ERROR AND SKIP
	  CALL	SSRCH			; SEARCH THE SYMBOL TABLE
	    SETZB R0,R1			;  NOT THERE OR GETSYM ERROR
	CAIE	R0,			; DON'T CREF NULL
	 CALL	CRFREF
	TLNE	R1,MDFSYM
	 TRO	R15,ERRD		; FLAG IF MULTI-DEFINED SYM
	TLNN	R1,DEFSYM		; FLAGGED AS DEFINED?
	 TDZA	R1,R1			;  NO, CLEAR TO ZERO
	  SETO	R1,			;  YES, SET TRUE
	POP	P,R2			; RETRIEVE REGISTERS
	POP	P,R3
	POP	P,R4
	XCT	[EXP <AND R3,R1>, <IOR R3,R1>]+1(R4)
	MOVE	R4,R2			; ANTICIPATE END
	EQV	R4,R3
	HRLI	R4,1			; MARK PNZ
	CAIN	R14,"&"			; TEST FOR OPS
	MOVE	R4,R2
	CAIN	R14,"!"
	SETCM	R4,R2
	JUMPG	R4,@[EXP BEGC0, FALSE]+1(R4)
	IBP	RBPTR			; FOUND OP, BYPASS IT
	JRST	.IFDF1			; LOOP

JMPER:
	MOVE	R1,CONDX+1(R3)
	JRST	0(R1)

.IIF:	TLO	R16,IIFBIT		; MARK .IIF ENTRY TO CONDITIONAL STUFF

.IF:	CALL	GETSYM			; GET CONDITION
	 TROA	R15,ERRA		; NO CONDITION
	  CAIN	RBYTE,","		; WAS DELIMITER A COMMA?
	   CALL	GETNB			;    YES - SKIP IT.

	MOVSI	R3,-<CONDY-CONDX>	; SET FOR SCAN
	TRNN	R3,1			; IGNORE ODD LOCATIONS
	CAME	R0,CONDX(R3)		; MATCH
	 AOBJN	R3,.-2			; NO
	JUMPL	R3,JMPER
.IFBAD:	TRO	R15,ERRA		; CONDITION DIDN'T MATCH
	RETURN

.IFB:					; IF BLANK CONDITIONAL
	SKIPG	MACLVL			; IN MACRO EXPANSION
	JRST	OPCERR			; NO!
	CALL	MACARG			; PARSE THE ARGUMENT.
	SKIPN	ARGLEN			; FIELD WAS BLANK IF PARSED LENGTH = 0.
	JRST	BEGC0			; IT WAS BLANK
	JRST	FALSE			; NOT BLANK


.IFNB:
	SKIPG	MACLVL			; IN MACRO EXPANSION
	JRST	OPCERR			; NO!
	CALL	MACARG			; GET THE ARGUMENT.
	SKIPN	ARGLEN			; IS ITS LENGTH 0?
	JRST	FALSE			; ARG WAS BLANK
	JRST	BEGC0

.IFT:					; GENERATING CODE UNDER .IFTF OR .IFF
	SKIPG	CONLVL			; EXPANDING A MACRO
	JRST	OPCERR
	MOVE	R1,.IFFLG
	TRNN	R1,TRUE			; SKIP IF TRUE

	JRST	.IFIF			; LAST CONDITION WAS FALSE
	JRST	BEGC01			; LAST CONDITION WAS TRUE


.IFTF:					; GENERATING CODE UNDER .IFT,.IFF
	SKIPG	CONLVL			; EXPANDING A MACRO
	JRST	OPCERR			; NO
	JRST	BEGC01			; Yes - test if this should list



.IFF:					; GENERATING CODE UNDER .IFTF, .IFT
	SKIPG	CONLVL			; EXPANDING MACRO
	JRST	OPCERR			; NO
	MOVE	R1,.IFFLG		; RELOAD LAST CONDITION WORD
	TRNN	R1,TRUE			; TEST LAST CONDITION RESULT
	JRST	BEGC01			; Last condition false
	JRST	.IFIF			; LAST CONDITION WAS TRUE


FALSE:					; GET HERE WHEN OUTER LEVEL
					; IS FALSE
	TLZE	R16,IIFBIT		; IS THIS A .IIF DIRECTIVE?
	JRST	GETEOL			;    YES - JUST FLUSH THE LINE.

	AOS	CONLVL			; COULD GET OUT ON .IFF THEN .ENDC
	MOVE	R1,.IFFLG
	LSH	R1,1			; SHIFT IN 0
	MOVEM	R1,.IFFLG		; MEANS FALSE

.IFIF:					; USED DURING 0 LEVEL OF NO CODE
					; GENERATION
	CALL	CNLTST			; TEST FOR .NLIST
	CALL	ENDLR			; LIST THE LINE
	CALL	GETMLI			; GET NEXT LINE
	RETURN				; EOF SEEN
	MOVSI	R3,-<.IFY-.IFX>		; SET FOR SCAN
	TRNN	R3,1			; IGNORE IF ODD LOCATION
	CAME	R0,.IFX(R3)
	AOBJN	R3,.-2
	CAIG	R3,			; GREATER IF NO MATCH
	JRST	TESTIF			; IT'S AN IF
	CAMN	R0,.ENDCX		; NOT IF, IS IT ENDC
	JRST	ENDC0			; YES IT WAS .ENDC
	CALL	TSTNT			; TERMINATOR
	JRST	.IFIF			; YES
	CALL	GETNT			; NO, GET ONE
	JRST	.IFIF			; GOT IT
	JRST	.-2


FAL:					; PREVIOUS CONDITION WAS FALSE
	CAMN	R0,.IFFX		; .IFF WHEN IN FALSE

	JRST	BEGC01			; YES -- GO GENERATE CODE
	CAMN	R0,.IFTX
	JRST	.IFIF
	JRST	..NOGO			; NO -- RETURN


TRU:					; LAST CONDITION WAS TRUE
	CAMN	R0,.IFTX		; .IFT WHEN IN TRUE
	JRST	BEGC01			; YES,GENERATE CODE
	CAMN	R0,.IFFX
	JRST	.IFIF
	JRST	..NOGO


TESTIF:					; UNDER FALSE, FOUND .IFF, .IFT,
					; OR .IFTF, .IF CONDITION
	CAMN	R0,.IFTFX		; .IFTF
	JRST	BEGC01			; YES
	MOVE	R1,.IFFLG
	TRNN	R1,TRUE			; ARE WE IN A TRUE CONDITION
	JRST	FAL
	JRST	TRU			; IN TRUE
..NOGO:	AOS	UNSLVL			; LEVEL COUNTER
	CALL	UNSCO2			; FIND .ENDC
	RETURN				; EOF SEEN
	JRST	.IFIF			; RETURN AFTER .ENDC MATCHING



IFZ0:	JSP	R3,IF0
	 CAIE	R10,

IFNZ0:	JSP	R3,IF0
	 CAIN	R10,

IFG0:	JSP	R3,IF0
	 CAIG	R10,

IFGE0:	JSP	R3,IF0
	 CAIGE	R10,

IFL0:	JSP	R3,IF0
	 CAIL	R10,

IFLE0:	JSP	R3,IF0
	 CAILE	R10,

IF0:	PUSH	P,0(R3)			; STACK INSTRUCTION
	CALL	ABSEXP			; VALUATE EXPRESSION
	LSH	R10,+^D<36-16>		; ADJUST SIGN
	ASH	R10,-^D<36-16>
	POP	P,R3			; RETRIEVE INSTRUCTION
	XCT	R3			; EXECUTE IT
	 JRST	FALSE			;  DIDN'T MAKE IT
	JRST	BEGC0			; SATISFIED


; ISI extensions to .IF -- under control of non-standard features.
;
;	.IF EQV	addr-expr,addr-expr
;
;	   True if the address expressions have the same type (absolute,
;	   relocatable, etc.), the same addressing mode, and the same
;	   value, e.g. #ZERO and #0 are equivalent if ZERO=0. 
;	   **** Globals are never equivalent ****
;
;
;	.IF NQV addr-expr,addr-expr
;
;	   The negative of EQV.
;
;
;	.IF ABS addr-expr
;
;	   True if the address expression is absolute, i.e. the expression
;	   contains no globals, and only differences between relocatable
;	   symbols if any.

.IFEQV:					; .IF EQV  --  are two address expressions
					;  equivalent (same mode, value and type)
	TLNN	RMODE,NSFFLG		; are non-standard features enabled?
	JRST	.IFBAD			;  no, go flag as an error and return
	CALL	EQVCK			; check if equivalent
	JRST	FALSE			; .. no
	JRST	BEGC0			; .. yes

.IFNQV:					; .IF NQV  --  not equivalent
	TLNN	RMODE,NSFFLG		; are non-standard features enabled?
	JRST	.IFBAD			;  no, go flag as an error and return
	CALL	EQVCK			; check if equivalent
	JRST	BEGC0			; .. no
	JRST	FALSE			; .. yes

EQVCK:	SETZM	OFFSET			; clear AEXT index for AEXP
	CALL	AEXP			; evaluate an address expression
	PUSH	P,R0			; save addressing mode (e.g. 27)
	PUSH	P,R10			; save value and type (rel,abs,glb,etc.)
	CAIN	RBYTE,","		; is delimiter a comma?
	CALL	GETNB			;  yes, skip it
	SETZM	OFFSET			; get next absolute expression
	CALL	AEXP			; evaluate the next address expression
	POP	P,R3			; get the first expression value
	XOR	R10,R3			; check if same as second value,
	TLZ	R10,DEFSYM!LBLSYM	; but ignore difference between label, symbol
	POP	P,R3			; get back first addressing mode
	JUMPN	R10,CPOPJ		; return +1 if value and type the same
	CAME	R0,R3			; are addressing modes the same?
	 RETURN				;  no, return +1
	JRST	CPOPJ1			;  yes, return +2 -- equivalent expressions

.IFABS:					; .IF ABS -- check address expr. absolute
	TLNN	RMODE,NSFFLG		; are non-standard features enabled?
	JRST	.IFBAD			;  no, go flag as an error and return
	SETZM	OFFSET			; clear AEXT index for AEXP
	CALL	AEXP			; evaluate an address expression
	CAIE	R0,27			; is addressing mode 27 (e.g. #expression)
	JRST	FALSE			;  no, then not absolute address expression
	TLZE	R10,(<GLBSYM>B17!PFMASK) ; is it absolute?
	 JRST	FALSE			;  no, take false exit
	JRST	BEGC0			;  yes, continue with conditional

.IFDIF:					; .IF DIF -- ARE ARGS DIFFERENT?
	CALL	IDNDIF			; COMPARE 2 STRINGS.
	JRST	BEGC0			; .. DIFFERENT
	JRST	FALSE			; .. IDENTICAL


.IFIDN:					; .IF IDN -- ARE ARGS IDENTICAL?
	CALL	IDNDIF			; COMPARE 2 STRINGS.
	JRST	FALSE			; .. DIFFERENT
	JRST	BEGC0			; .. IDENTICAL


IDNDIF:	CALL	MACARG			; GET A MACRO-TYPE ARGUMENT.
	MOVE	R3,[XWD ARGLEN,SECLEN]  ; COPY IT TO A SAFE PLACE.
	MOVE	R1,ARGLEN		; MOVE (# BYTES)/4 + 2 WORDS.
	LSH	R1,-2
	BLT	R3,SECSTR+1(R1)

	CAIN	RBYTE,","		; WAS ARGUMENT DELIMITER A COMMA?
	CALL	GETNB			;     YES - SKIP IT.

	CALL	MACARG			; GET ANOTHER ARGUMENT.
	MOVE	R0,ARGLEN		; DOES LENGTH OF EACH ARG MATCH?
	CAME	R0,SECLEN
	RETURN				;   .. NO - RETURN +1.

	MOVE	R3,[POINT 7,ARGSTR]	; PREPARE TO COMPARE.
	MOVE	R4,[POINT 7,SECSTR]

IDNCMP:	ILDB	R1,R3			; LOAD NEXT BYTE OF PRIMARY AND
	ILDB	R2,R4			; SECONDARY STRINGS.
	JUMPE	R1,CPOPJ1		; ** END OF STRING - RETURN +2
	CAMN	R1,R2			; DO BYTES MATCH?
	JRST	IDNCMP			;   YES - KEEP COMPARING.
	RETURN				;   NO -- RETURN +1.



UNSCON:	SETZM	UNSLVL			; CLEAR LEVEL COUNT
UNSCO1:	CALL	CNLTST			; TEST FOR .NLIST CND
	CALL	ENDLR			; LIST THE LINE
	CALL	GETMLI			; GET THE NEXT LINE
	 RETURN				; EOF SEEN
	MOVSI	R3,-<.IFY-.IFX>		; SET FOR SCAN
	TRNN	R3,1			; IGNORE IF ODD LOCATION
	CAME	R0,.IFX(R3)		; SKIP IF MATCH
	AOBJN	R3,.-2			; LOOP IF NOT END
	CAIGE	R3,			; END, SKIP IF NO MATCH
	JRST	CHKADDR			; DON'T INCR FOR .IFF,ETC
	CAMN	R0,.ENDCX		; "ENDC"?
	SOSLE	UNSLVL			;  YES, SKIP IF NOT NESTED
	JRST	UNSCO2			; TRY FOR MORE.
	JRST	CPOPJ1			; GOOD, RETURN+1

UNSCO2:	CALL	TSTNT			; TEST FOR TERMINATION
	 JRST	UNSCO1			;  YES
	CALL	GETNT			; NO, GET ONE
	 JRST	UNSCO1
	JRST	.-2


CHKADD:	CAMN	R0,.IFFX		; .IFF
	JRST	UNSCO2			; YES, DON'T LOOK FOR .ENDC
	CAMN	R0,.IFTX		; .IFT
	JRST	UNSCO2			; YES, DON'T LOOK FOR .ENDC
	CAMN	R0,.IFTFX		; .IFTF
	JRST	UNSCO2			; YES, DON'T LOOK FOR .ENDC
	AOS	UNSLVL			; IT WAS .IF COND, LOOK FOR .ENDC
	JRST	UNSCO2



ENDC0:					;  ".ENDC"
	SKIPG	CONLVL			; ARE WE IN A CONDITIONAL?
	JRST	OPCERR			;  NO, ERROR
	MOVE	R1,.IFFLG
	LSH	R1,-1
	MOVEM	R1,.IFFLG

	SOS	CONLVL			; YES, DECREMENT LEVEL
	JRST	BEGC01

BEGC0:	TLZE	R16,IIFBIT		; IS THIS AN IMMEDIATE IF?
	JRST	IMII			;    YES -- EXPAND REST OF LINE.
	AOS	CONLVL			; INCREMENT LEVEL
	MOVE	R1,.IFFLG
	LSH	R1,1
	TRO	R1,TRUE
	MOVEM	R1,.IFFLG

BEGC01:	CALL	CNLTST			; TEST FOR .NLIST CND
	RETURN

IMII:	CALL	SETNB			; SUCCESSFUL IMMEDIATE IF . . .
	CAIN	RBYTE,","		; WAS DELIMITER A COMMA?
	CALL	GETNB			;    YES -- SKIP IT.
	JRST	STMNT			; ASSEMBLE REST OF LINE.


GETMLI:					; GET MACRO-TYPE LINE

	CALL	GETLIN			; GET A BASIC LINE
	CALL	MDLTST			; TEST MD LISTING MODE
GETML1:	CALL	GETSYM			; TRY FOR A SYMBOL
	JRST	GETML2			;  NO	
	CAIE	R14,":"			; LABEL?
	JRST	GETML2			;  NO
	CALL	GETNB			; YES, GET ANOTHER
	JRST	GETML1

GETML2:	TLNE	R15,ENDFLG		; EOF SEEN?
	RETURN				;  YES, BAD EXIT
	JRST	CPOPJ1			; GOOD EXIT

;    SUBROUTINE MDLTST CHECKS THE MACRO DEFINITION LISTING
;	  CONTROL FLAG; IF IT ISN'T SET, .NLIST MD MUST BE
;	  IN EFFECT:  SET NLISLN FLAG TO SUPPRESS LISTING
;	  OF THIS LINE.

MDLTST:	PUSH	P,R0			; SAVE FOR .IF'S
	MOVE	R0,LSTCTL		; LOAD LISTING CONTROL FLAGS
	TRNN	R0,LMD			; MD TO BE LISTED?
	TLO	R16,NLISLN		; NO - SUPPRESS LINE ON LISTING
	POP	P,R0			; FOR .IF'S
	RETURN


;   SUBROUTINE CNLTST CHECKS THE LISTING CONTROL FLAG
;	  WHICH GOVERNS LISTING OF UNEXPANDED CONDITIONAL
;	  CODE AND ALL .IF'S & .ENDC'S.  THIS FLAG IS 0 IF
;	  .NLIST CND IS IN EFFECT; IF THIS IS THE CASE,
;	  CNLTST SETS THE NLISLN FLAG TO SUPPRESS
;	  LISTING OF THE CURRENT LINE.

CNLTST:	PUSH	P,R0
	MOVE	R0,LSTCTL		; LOAD LISTING CONTROL FLAGS.
	TRNN	LCND			; .NLIST CND IN EFFECT?
	TLO	R16,NLISLN		; YES - SUPPRESS LINE LISTING
	POP	P,R0
	RETURN
	SUBTTL	MACRO-RELATED  ASSEMBLER  DIRECTIVES

.NARG:					;  ==== .NARG ====
	SKIPG	MACLVL			; IS A MACRO EXPANDING?
	JRST	OPCERR			; NO -- ISSUE AN 'O' FLAG.

	CALL	GETSYM			; GET SYMBOL TO BE SET.
	JRST	QERR			;   -- DISGUSTING SYNTAX IF NONE.
	PUSH	P,R0			; STACK THE SYMBOL FOR LATER USE.

	MOVE	R3,CALPNT		; LOCATE CURRENT CALL BLOCK.
	HLRZ	R10,3(R3)		; LOAD THE ARG COUNT.
	JRST	SYMDEF			; EQUATE SYMBOL TO ARG COUNT.



.NCHR:					;  ======  .NCHR  ======
	CALL	GETSYM			; GET SYMBOL TO ASSIGN A VALUE TO.
	JRST	QERR			;  -- THERE'S GOTTA BE ONE!
	PUSH	P,R0			; SAVE ITS NAME FOR SYMDEF.

	CALL	SETNB			; IS DELIMITER A COMMA?
	CAIN	RBYTE,","
	CALL	GETNB			;    YES - SKIP IT.
	CALL	MACARG			; GET A MACRO-TYPE ARGUMENT.
	MOVE	R10,ARGLEN		; LOAD LENGTH (# OF CHARACTERS)
	JRST	SYMDEF			; & ASSIGN IT TO THE SYMBOL.


.NTYPE:					; =====  .NTYPE  =====
	SKIPG	MACLVL			; IS A MACRO EXPANDING?
	 TLNE	RMODE,NSFFLG		;    NO -- CHECK FOR NONSTANDARD FEATURES
	  CAIA				;    YES - SKIP ERROR
	   JRST	OPCERR			;       NO - ISSUE AN 'O' FLAG.

	CALL	GETSYM			; GET SYMBOL TO BE SET
	 JRST	QERR			; -- SYNTAX ERROR IF NONE.
	PUSH	P,R0			; STACK THE SYMBOL FOR SYMDEF.

	CALL	SETNB			; IS SYMBOL DELIMITER A COMMA?
	CAIN	RBYTE,","
	 CALL	GETNB			;    YES -- SKIP IT.

	SETZM	OFFSET			; CLEAR AEXT INDEX FOR AEXP.
	CALL	AEXP			; EVALUATE AN ADDRESS EXPRESSION.
	MOVE	R10,R0			; LOAD ADDRESS MODE VALUE (6 BITS)
	JRST	SYMDEF			;   & ASSIGN IT TO SYMBOL.

.NKIND:					; =====  .NKIND  ===== (ISI extension)
	TLNN	RMODE,NSFFLG		; are non-standard features enabled?
	JRST	OPCERR			;  no, go flag as an error and return
	CALL	GETSYM			; get symbol to be set
	JRST	QERR			;  -- syntax error if none
	PUSH	P,R0			; stack the symbol for SYMDEF
	CALL	SETNB			; get the next character
	CAIN	RBYTE,","		; is it comma?
	CALL	GETNB			;  yes, skip it
	SETZM	OFFSET			; clear AEXT index for AEXP
	CALL	AEXP			; evaluate an address expression
	TLZ	R10,MDFSYM		; clear MDFSYM bit
	TLNE	R10,(PFMASK)		; is this symbol relocatable?
	TLO	R10,MDFSYM		;  yes, use MDFSYM bit to indicate so.
	LSH	R10,-<^D35-4>		; shift so DEFSYM to MDFSYM are in 31 to 35
	JRST	SYMDEF			; and assign result to symbol

.NVAL:					; =====  .NVAL  ===== (ISI extension)
	TLNN	RMODE,NSFFLG		; are non-standard features enabled?
	JRST	OPCERR			;  no, go flag as an error and return
	CALL	GETSYM			; get symbol to be set
	JRST	QERR			;  -- syntax error if none
	PUSH	P,R0			; stack the symbol for SYMDEF
	CALL	SETNB			; get the next character
	CAIN	RBYTE,","		; is it comma?
	CALL	GETNB			;  yes, skip it
	SETZM	OFFSET			; clear AEXT index for AEXP
	CALL	AEXP			; evaluate an address expression
	ANDI	R10,177777		; extract only the value from the expression
	JRST	SYMDEF			; and assign result to symbol
	SUBTTL	MACRO HANDLERS

;	  ... MACRO STORAGE BLOCK FORMATS ...


;		    CALL BLOCK

;	0 -- SAVED INPUT POINTER (FROM R12)
;	1 -- SAVED MACRO CALL POINTER (CALPNT)
;	2 -- BYTE POINTER TO MACRO PROTOTYPE
;	3LH -- ARGUMENT COUNT (# ARGS ACTUALLY SUPPLIED)
;	3RH -- LAST CHARACTER READ
;	4 -- ?????
;	5 & FOLLOWING ... ARGUMENT LIST AS AN ASCII STRING



;		MACRO  PROTOTYPE  TEXT

;	0 -- REFERENCE COUNT
;	1 -- NUMBER OF DUMMY ARGUMENTS
;	2 -- BIT MASK INDICATING WHICH ARGS WERE PRECEDED BY "?"
;	3 & FOLLOWING ... PROTOTYPE TEXT AS AN ASCII STRING



;		IRP ARGUMENT VALUE BLOCK

;	0 -- BYTE POINTER TO START OF ARGUMENT STRING
;	1 -- IRP TYPE FLAG:  0 FOR .IRP, 1 FOR .IRPC
;	2 & FOLLOWING ... ARGUMENTS AS A SINGLE ASCIZ STRING


;	<<<<<<< .IRP & .IRPC  >>>>>>>

;		.... ADD A COMMENT BLOCK HERE ....

.IRP:	TDZA	R10,R10			; FLAG .IRP INVOCATION.
.IRPC:	 MOVEI	R10,1			; FLAG .IRPC INVOCATION.
	PUSH	P,R10			; SAVE ENTRY FLAG ON STACK

	CALL	MDLTST			; TEST MACRO DEF LISTING MODE.
	SETZM	MACNAM			; ACT LIKE NAMELESS MACRO.
	CALL	GETSYM			; GET NAME OF THE ARGUMENT.
	 TRO	RERR,ERRQ		;    QUESTIONABLE SYNTAX IF NONE.
	MOVEM	R0,ARGLST		; SAVE ARG NAME.

; Save the current macro level count in case .MEXIT is executed so that we
;  know what level to return

	MOVE	R1,MACLVL		; Get current level
	MOVE	R11,IRPLVL		; Get last .IRP(C) level info
	HRLM	R11,MCLIRP(R1)		; Save it
	MOVEM	R1,IRPLVL		; New .IRP(C) called level

	CAIN	RBYTE,","		; IS ARG DELIM A COMMA?
	CALL	GETNB			;    YES - SKIP IT.

;	   SAVE ARGUMENT STRING, THEN READ .IRP BLOCK DEFINITION.

	CALL	GETBLK			; GET SPACE FOR ARG BLOCK.
	POP	P,R1			; RETRIEVE IRP/IRPC FLAG.
	PUSH	P,CALPNT		; SAVE CURRENT CALL BLOCK POINTER.
	HRRZ	R10,MWPNTR		; GET ADDR OF ARG BLOCK.
	PUSH	P,R10			; SAVE FOR LATER USE.

	MOVEM	R1,1(R10)		; STORE IRP/IRPC FLAG IN BLOCK.
	MOVEI	R0,2			; SET INITIAL BYTE POINTER
	ADD	R0,MWPNTR		;     FOR ARGUMENT TEXT.
	MOVEM	R0,MWPNTR
	IBP	R0
	MOVEM	R0,0(R10)

	TLO	R16,FOLBIT		; SUPPRESS CASE FOLDING.
	CALL	MACARG			; GET THE ARGUMENT FIELD.
	MOVE	R10,[POINT 7,ARGSTR]	; POINT TO IT.

;	   COPY ARGUMENT FIELD TO ARGUMENT VALUE BLOCK.

IRPA:	ILDB	RBYTE,R10		; Get first argument byte.
	MOVEM	RBYTE,ARGDEL		; Save it as first delimiter value.

;	   The initial setting of ARGDEL is 0 if no arguments are
;	   supplied (".irp  dummy,<>", for instance), else nonzero.

	CAIA				; Enter loop.
IRPB:	 ILDB	RBYTE,R10		; GET NEXT ARG BYTE.
	IDPB	RBYTE,MWPNTR		; WRITE IT IN ARG BLOCK.
	JUMPN	RBYTE,IRPB		; REPEAT TIL END OF ASCIZ STRING.

	CALL	DEFIRP			; DRAG IN THE IRP DEFINITION.
	PUSH	P,R1			; SAVE ITS ADDRESS ON STACK.
	SETOM	0(R1)			; DELETE DEFINITION AFTER LAST CALL.

;	   -- CURRENT STACK CONTENTS:

;	0(P)  -  ADDRESS OF DEFINITION BLOCK.
;	-1(P)  -  ADDRESS OF IRP ARGUMENT VALUE BLOCK.
;	-2(P)  -  CONTENTS OF CALPNT (POINTER TO CALL BLOCK
;			OF A MACRO THAT INVOKED .IRP)


;	   GENERATE A CALL BLOCK FOR EACH ARGUMENT.


IRPNAR:	HRRZ	R1,-1(P)		; LOCATE ARG BLOCK.
	MOVE	RBPTR,0(R1)		; POINT TO NEXT PROSE TO PARSE.
	SKIPE	1(R1)			; WHICH BRAND OF IRP IS THIS?
	JRST	IRPCAR

;					; ///// .IRP /////
	SKIPN	ARGDEL			; WAS PREVIOUS ARG DELIM 0?
	JRST	IRPGO			;    YES - IT WAS THE LAST.
	HRRZ	R1,0(P)			; RETRIEVE DEFINITION ADDR.
	CALL	IRPAR			; LET CALL BLOCK GENERATOR
	HRRZ	R1,-1(P)		; PARSE THE ARGUMENT.
	MOVEM	RBPTR,0(R1)		; STORE UPDATED ARG POINTER.
	JRST	IRPREQ			; REQUEUE CALL BLOCK JUST GEND.


;					; ///// .IRPC  /////
IRPCAR:	LDB	RBYTE,RBPTR		; GET ARGUMENT BYTE.
	JUMPE	RBYTE,IRPGO		; QUIT IF IT'S THE ARG DELIMITER.
	IBP	RBPTR			; POINT TO NEXT BYTE.
	LSH	RBYTE,^D29		; CONVERT CURRENT BYTE TO
	MOVEM	RBYTE,ARGSTR		; ASCIZ STRING FORMAT & STORE.

	MOVEM	RBPTR,0(R1)		; SAVE UPDATED BYTE POINTER.
	HRRZ	R1,0(P)			; LOAD ADDR OF DEFINITION BLOCK.
	MOVE	RBPTR,[POINT 7,ARGSTR,^D6] ; POINT TO THE ARGUMENT.
	CALL	IRPCAL			; GENERATE CALL BLOCK.


;	   REQUEUE CALL BLOCK JUST GENERATED, UNLESS IT WAS FOR
;	   THE FIRST ARGUMENT.  THE CALL BLOCK GENERATOR STACKS
;	   THEM, SO THE ORDER OF ARGUMENT SUBSTITUTION WOULD BE
;	   RIGHT TO LEFT WITHOUT THIS MANIPULATION.

IRPREQ:	MOVE	R0,-2(P)		; LOCATE FIRST NON-IRP CALL BLOCK.
	MOVE	R1,CALPNT		; LOCATE BLOCK JUST GENERATED.
	MOVE	R2,1(R1)		; LOCATE ITS SUCCESSOR.

	CAMN	R0,R2			; IS SUCCESSOR 1ST NON-IRP?
	JRST	IRPNAR			;    YES - NO ACTION NEEDED
					;    (THIS WAS 1ST ARGUMENT)

	MOVEM	R2,CALPNT		; DEQUEUE THE NEW BLOCK.
	MOVEM	R0,1(R1)		; LINK IT TO 1ST NON-IRP.

;	   SCAN CALL BLOCK QUEUE FOR SPOT TO INSERT THE NEW ONE;
;	   IT SHOULD BE INSERTED BETWEEN IRP-GENERATED BLOCKS
;	   AND THE FIRST NON-IRP-GENERATED BLOCK.

	CAIA				; DON'T MISS 1ST BLOCK.
IRPQSR:	 MOVE	R2,1(R2)		; LOCATE NEXT BLOCK
	CAME	R0,1(R2)		; DOES IT POINT TO NON-IRP BLK?
	 JRST	IRPQSR			;   NO - KEEP SEARCHING.

	MOVEM	R1,1(R2)		; INSERT NEW BLOCK IN QUEUE.
	MOVE	R0,0(R1)		; SWAP SAVED INPUT POINTERS
	MOVE	R3,0(R2)		; IN NEW BLOCK & BLOCK JUST FOUND.
	MOVEM	R0,0(R2)
	MOVEM	R3,0(R1)
	JRST	IRPNAR			; GO BACK FOR NEXT ARG.


;	   ALL CALL BLOCKS READY ... START EXPANDING.

IRPGO:
	MOVE	R0,MACLVL		; Get current level this is the highest
	MOVE	R1,IRPLVL		; Get starting level; use it as an index
	HRRM	R0,MCLIRP(R1)		; Save the max level of this .IRP(C)
	MOVEM	R0,IRPMAX		; Set max level for this .IRP(C)
	POP	P,R0			; POP DEFINITION LOC OFF STACK
	POP	P,R1			; POP ARG BLOCK OFF.
	POP	P,			; GET RID OF SAVED CALPNT.
	JRST	REMMAC			; DELETE ARG BLOCK & RETURN.

; The current implementation of .MCALL will insert the file SYSMAC.SML
;  through the .INSERT routine, but only on the first .MCALL per pass.

.MCALL:
	CALL	GETEOL			; IGNORE ARGUMENTS
	AOSE	MCALLF			; Have we already done .MCALL?
	 RETURN				;  yes -- return
	PUSH	P,RBPTR			; Save the input pointer
	MOVE	RBPTR,[ POINT 7,[ ASCIZ /SYSMAC.SML/ ], ]
	ILDB	RBYTE,RBPTR		; Get the first character
	CALL	MCALL2			; Try to use specified file
	POP	P,RBPTR			; Restore original input pointer
	RETURN
					;    and return

DEFIRP:					; ENTRY FROM .IRP TO MACRO DEFINITION
	CALL	GETBLK			; GET A BLOCK FOR DEFINITION.
	PUSH	P,MWPNTR		; SAVE POINTER TO IT ON STACK.
	MOVEI	R1,3			; SKIP TO TEXT STORAGE AREA.
	ADDM	R1,MWPNTR
	MOVEI	R7,1			; INDICATE 1 ARGUMENT.
	JRST	DEF02			; ENTER DEFINITION PROCESSING
					; IN THE MIDDLE.


DEFIN0:					; .MACRO DIRECTIVE
	CALL	MDLTST			; ACT ON MD LISTING MODE
	CALL	GETSYM			; GET ITS NAME
	 JRST	DEFERR			;  ERROR, EXIT
	MOVEM	R0,MACNAM		; SAVE MACRO NAME IN NEST NAME TBL
	CALL	GETBLK			; OK, GET A BLOCK FROM STORAGE
	CALL	MSRCH			; SEE IF ALREADY DEFINED
	 MOVSI	R1,MAOP			; NOT THERE, FLAG AS MACRO
	TLNN	R1,MAOP			; Was this really a MACRO?
	 MOVSI	R1,MAOP			; No - re-defining an .OPDEF
	TRNE	R1,-1			; PREVIOUSLY DEFINED?
	CALL	DECMAC			;  YES, DECREMENT REFERENCE
	HRR	R1,MWPNTR		; GET POINTER TO START OF BLOCK
	CALL	INSRT			; INSERT/DELETE IN SYMBOL TABLE
	CALL	CRFDEF
	PUSH	P,MWPNTR		; STACK POINTER TO START OF BLOCK
	MOVEI	R1,3
	ADDM	R1,MWPNTR		; MOVE PAST REFERENCE LEVEL AND ARG COUNT
	TDZ	R7,R7			; SET ARG COUNT = 0
	SETZM	MARMAS			; CLEAR PROTOTYPE ARGUMENT MASK.


	CALL	SETNB			; CHECK FOR "," AFTER MACRO NAME.
	CAIN	R14,","			; IS IT ","?
DEF01:	CALL	GETNB			; MOVE PAST COMMA
DEF01B:					; 				[ECL3]

	CAIE	RBYTE,"?"		; IS NEXT BYTE "?"?
	JRST	DEF01A			;    NO -- THIS IS A MUNDANE ARGUMENT.
					;    YES - THIS ARG MAY REQUIRE AN
					; AUTOMATICALLY GENNED SYMBOL.
	MOVEI	R0,1			; SET A BIT IN THE ARG MASK CORRESPONDING
	ROT	R0,0(R7)		; TO THE RELATIVE POSITION OF THIS ARG.
	IORM	R0,MARMAS
	CALL	GETCHR			; SKIP THE "?".

DEF01A:	CALL	GETSYM			; GET AN ARG
	 JRST	DEF02			;  NOT THERE
	MOVEM	R0,ARGLST(R7)		; STORE IN LIST
	ADDI	R7,1			; BUMP POINTER
	CAIN	R14,","			; ANY MORE?
	 JRST	DEF01			;  YES

; the following is to make .MACRO allow blanks or tabs		[ECL3]
;   between arguments						[ECL3]
	CAIE	R14,";"			; statement ends on semi-colon	[ECL3].
	 CAIN	R14,CRR			; or cariage return		[ECL3]
	  JRST	DEF02			; 			[ECL3]
	CAIE	R14,LF			; or line feed			[ECL3]
	 CAIN	R14,FF			; or form feed			[ECL3]
	  JRST	DEF02			; 			[ECL3]
	JRST	DEF01B			; failing to find an end of 	[ECL3]
					; line, we assume the next	[ECL3]
					; is a new arg separated from	[ECL3]
					; the previous one by blanks	[ECL3]
					; and/or tabs. Treat like a	[ECL3]
					; comma already skipped.		[ECL3]

DEF02:	PUSH	P,R7			; STACK ARG COUNT
	SETZM	ARGLST(R7)		; MARK END
	CALL	ENDLR			; LIST THE LINE
	SETZ	R7,			; INIT LEVEL COUNT

;	CODE FROM DEF03 TO DEF04 IS CONCERNED WITH
;	KEEPING TRACK OF .MACRO/.ENDM PAIRS IN POTENTIALLY
;	NESTED MACRO DEFINITIONS.

;	WHEN A .MACRO DIRECTIVE IS FOUND, THE NESTING LEVEL
;	IN R7 IS INCREMENTED, AND THE MACRO NAME IS RECORDED
;	IN MACNAM(R7).  R7 = 0 FOR THE OUTERMOST MACRO.
;	.REPT, .IRP, AND .IRPC ARE TREATED AS NAMELESS MACRO
;	DEFINITIONS (I.E., .MACRO WITHOUT AN OPERAND).


;	WHEN A .ENDM IS FOUND THE ACTION DEPENDS ON ITS OPERAND.
;	-- .ENDR IS TREATED AS A SYNONYM FOR .ENDM.

;	NO OPERAND:  THE NESTING LEVEL (R7) IS DECREMENTED.
;		IF IT GOES NEGATIVE, THE OUTERMOST (I.E., CURRENT)
;		MACRO DEFINITION IS TERMINATED.

;	SYMBOLIC OPERAND:  THE SYMBOL IS MATCHED WITH NAMES IN
;		MACNAM.  WHEN ONE MATCHES, THE NESTING LEVEL IS
;		A) DECREMENTED (DEC'S WAY), OR
;		B) SET TO THE OFFSET OF THE MACRO NAME IN MACNAM.
;		   THIS TERMINATES MACRO DEFINITIONS WITH HIGHER
;		   NESTING LEVELS WHICH ARE STILL OPEN.

;		THE LATTER ACTION IS TAKEN ONLY IF NONSTANDARD
;		FEATURES ARE ENABLED.


DEF03:	CALL	GETMLI			; GET THE NEXT LINE
	 JRST	DEF13			;  EOF SEEN
	CAME	R0,.MACRY
	 CAMN	R0,.MACRX
	  AOJA	R7,DEF03B		; INCREMENT
	CAME	R0,.REPTX		; IS IT .REPT?
	 CAMN	R0,.IRPOP		; .IRP?
	  AOJA	R7,DEF03D		; YES - INCR CALL LEVEL
	CAMN	R0,.IRCOP		; IS IT .IRPC?
	 AOJA	R7,DEF03D		; YES - LIKE .IRP (ETC)
	CAME	R0,.ENDMX
	 CAMN	R0,.ENDRX		; IS OP .ENDR?
	  CAIA				; .ENDM OR .ENDR
	   JRST	DEF04			; NOT .MACRO OR .ENDM - SKIP

	CALL	GETSYM			; .ENDM -- GET ITS OPERAND, IF ANY
	JRST	DEF03A			; NO OPERAND -- JUST POP NEST LEVEL

;  -- PROCESS A .ENDM SPECIFYING A SPECIFIC MACRO TO TERMINATE.

	MOVE	R1,R7			; COPY NEST LEVEL TO SPARE REG

	CAMN	R0,MACNAM(R1)		; IS THIS THE .ENDM OPERAND?
	 JRST	DEF03C			; YES - GO TO POPPER
	SOJGE	R1,.-2			; NO - BACK UP TO HIER LEVEL

	TRO	RERR,ERRA		; NO SUCH MACRO IS OPEN . . .
	JRST	DEF03A			; GIVE IT AN "A" FLAG.

;  -- NESTED .MACRO FOUND - ADD ITS NAME TO TABLE & INCR NEST LEVEL.

DEF03B:	CALL	GETSYM			; GET MACRO NAME
DEF03D:	 SETZ	R0,			; NAMELESS .MACRO!.REPT!.IRP!.IRPC
					; MACRO DIRECTIVES WITHOUT MACRO NAMES
					;  WILL BE FLAGGED WHEN THE MACRO IS
					;  DEFINED; IN THIS CASE THAT HAPPENS
					;  WHEN AN OUTER MACRO IS CALLED.
	MOVEM	R0,MACNAM(R7)		; STORE NAME IN NESTED NAME TABLE
	JRST	DEF04

;  -- MODIFY NESTING LEVEL FOR A .ENDM WHICH TERMINATES
;	  A SPECIFIC MACRO.

DEF03C:	TLNE	RMODE,NSFFLG		; NONSTANDARD FEATURES ENABLED?
	 MOVE	R7,R1			; YES - SET, THEN POP, NEST LEVEL
DEF03A:	SOJL	R7,DEF13		; END IF MINUS
DEF04:	MOVE	R13,LINPNT		; SET TO START OF LINE
	TLO	R16,FOLBIT		; LEAVE LOWER CASE INTACT.
DEF05:	CALL	GETCHR			; GET THE NEXT CHARACTER
DEF06:	CAIE	R14,"'"			; CONCATENATION CHARACTER?
	 JRST	DEF06C			;  NO, BRANCH AROUND
DEF06A:	CALL	GETCHR			; YES, GET THE NEXT CHARACTER
	CAIE	R14,"'"			; MULTIPLE?
	 JRST	DEF06B			;  NO
	CALL	WCIMT			; YES, SAVE ONLY ONE
	JRST	DEF06A			; TEST FOR MORE
DEF06B:	TLO	R15,CONFLG		; FLAG THE CONCATENATION CHARACTER
DEF06C:	MOVE	R0,RBYTE		; COPY BYTE IN CASE IT'S LOWER CASE.
	CAIL	RBYTE,140		; IF NECESSARY, FOLD THE ORIGINAL
	 SUBI	RBYTE,40		; BYTE INTO UPPER CASE TO CHECK ITS TYPE.

;	   **** ADD A NEW COLUMN TO CHJTBL SOME DAY SOON ****

	LDB	R2,ANPNTR		; MAP
	JUMPE	R14,DEF12		; BRANCH IF END OF LINE
	CAIE	R2,.ALP			; IF ALPHA
	CAIN	R2,.NUM			;  OR NUMERIC
	JRST	DEF07			;  BRANCH
	CAIN	R2,.HEX			; SOME ALPHAS ARE TYPED
	JRST	DEF07			; AS HEX DIGITS.

	MOVE	RBYTE,R0		; RESTORE UNFOLDED BYTE.
	CALL	WCIMT			; WRITE IN TREE
	JRST	DEF05			; TRY FOR ANOTHER

DEF07:	TLZ	R16,FOLBIT		; TURN FOLDING ON AGAIN . . .
	SETZ	R0,			; POSSIBLE ARGUMENT
	MOVSI	R3,(POINT 6,R0,)
	MOVEM	R13,SYMBEG		; SAVE START JUST IN CASE
DEF08:	SUBI	R14,40			; CONVERT TO SIXBIT
	TLNE	R3,770000
	IDPB	R14,R3			;  YES, DO SO
	CALL	GETCHR			; GET THE NEXT CHARACTER
	LDB	R2,ANPNTR		; MAP
	CAIE	R2,.ALP			; IF ALPHA
	CAIN	R2,.NUM			;  OR NUMERIC
	JRST	DEF08			;  BRANCH
	CAIN	R2,.HEX
	JRST	DEF08
	CALL	SIXM40
	SETZ	R2,			; INIT SEARCH INDEX
DEF09:	SKIPN	ARGLST(R2)		; TEST FOR END
	JRST	DEF10			;  YES
	CAME	R0,ARGLST(R2)		; NO, HAVE WE A MATCH?
	AOJA	R2,DEF09		;  NO,TRY THE NEXT SLOT

;	** FOUND MATCH -- IDENTIFY DUMMY SYMBOL IN THE PROTOTYPE TEXT.

	TLZ	R15,CONFLG		; REMOVE POSSIBLE CONCATENATION CHARACTER
	MOVEI	R14,101(R2)		; SET DUMMY SYMBOL POINTER
	CALL	WTIMT			; WRITE IN TREE
	TLO	R16,FOLBIT		; TURN OFF FOLDING AGAIN.
	CALL	SETCHR			; SET CHARACTER
	CAIN	R14,"'"			; CONCATENATION CHARACTER?
	JRST	DEF05			;  YES, BYPASS IT
	JRST	DEF06			;  NO, PROCESS IT

DEF10:	MOVE	R13,SYMBEG		; MISSED, RESET POINTER
	TLO	R16,FOLBIT		; QUIT FOLDING AGAIN.
	CALL	SETCHR			; RESET CHARACTER
DEF11:	MOVE	R0,RBYTE		; SAVE UNFOLDED BYTE, THEN
	CAIL	RBYTE,140		; FOLD TO UPPER CASE TO CHECK
	SUBI	RBYTE,40		; ITS TYPE.
	LDB	R2,ANPNTR		; MAP
	MOVE	RBYTE,R0		; RESTORE UNFOLDED COPY OF BYTE.
	CAIE	R2,.ALP			; IF ALPHA
	CAIN	R2,.NUM			;  OR NUMERIC
	JRST	DEF11A
	CAIE	R2,.HEX
	JRST	DEF06			; ELSE BRANCH
DEF11A:	CALL	WCIMT			; OK, WRITE IN TREE
	CALL	GETCHR			; GET NEXT CHAR
	JRST	DEF11			; TEST IT

DEF12:	CALL	ENDLR			; LIST IT
	TLNN	R15,ENDFLG		; SKIP IF EOF SEEN
	JRST	DEF03			; GET THE NEXT LINE

DEF13:
	MOVEI	R14,QUEMAC		; FINISHED, SET "END OF MACRO DEFINITION"
	CALL	WTIMT			; WRITE IT, WITH QUE, IN TREE
	POP	P,R2			; RETRIEVE COUNT
	POP	P,R1			;  AND POINTER TO START OF BLOCK
	SETZM	0(R1)			; ZERO LEVEL COUNT
	HRRZM	R2,1(R1)		; STORE ARG COUNT IN SECOND RUNG
	MOVE	R0,MARMAS		; STORE "?" ARG BIT MASK
	MOVEM	R0,2(R1)		; IN THIRD WORD.
	RETURN


DEFERR:
	TRO	R15,ERRQ
	RETURN

CALLM:
	MOVE	R0,LSTCTL		; LOAD LIST CONTROL FLAGS
	TRNN	R0,LMC			; .NLIST MC IN EFFECT?
	JRST	[ TLO	R16,NLISLN	; Yes - suppress list of this line
		  JRST	IRPCAL	]	;  and continue
	TRNN	R0,LME			; Should we print PC?
	SKIPN	MACLVL			; No - but first level always gets printed
	MOVEM	RLOC,PF0		; Set PC for printout

IRPCAL:	TLZA	R16,IRPBIT		; ENTRY FROM .IRPC --
IRPAR:	 TLO	R16,IRPBIT		; ENTRY FROM .IRP --
	TLO	R16,FOLBIT		; DON'T FOLD ARG VALUES.
	PUSH	P,R1			; SAVE POINTER TO DEFINITION BLOCK
	AOS	(R1)			; Increment the reference count
	MOVE	R7,1(R1)		; GET ARGUMENT COUNT
	MOVE	R0,2(R1)		; GET "?" ARGUMENT BIT MASK,
	MOVEM	R0,MARMAS		; SAVE IT IN MARMAS.
	CALL	GETBLK			; GET A BLOCK FROM FREE STORAGE
	PUSH	P,MWPNTR		; SAVE THE STARTING ADDRESS
	SETZM	ARGCNT			; -- CLEAR ARGUMENT COUNT.
	MOVEI	R0,5
	ADDM	R0,MWPNTR		; MOVE BYTE POINTER PAST WORD STORAGE
	MOVEI	R14,QUEARG
	CALL	WTIMT			; INITIALIZE ARGUMENT LIST
	JUMPE	R7,MAC50		; TEST FOR NO ARGS

MAC10:	SETZM	ARGLEN			; PRESUME ARG WILL BE OMITTED.
	CALL	SETNB			; SET NON-BLANK
	CAIE	R14,";"			; IF SEMI-COLON
	CALL	TSTNT			;  OR TERMINATOR,
	 JRST	MAC50A			;  NO MORE ARGUMENTS.

	AOS	ARGCNT			; INCREMENT ARGUMENT COUNT.
	CAIN	R14,","			; IS NEXT BYTE A COMMA?
	JRST	MAC40			;    YES -- EXPLICITLY NULL ARG.

	CAIN	R14,"\"
	JRST	MAC70			; EXPRESSION TO ASCII CONVERSION
	CALL	MACART			; PARSE A MACRO ARG & STORE IN
					; THE MACRO CALL BLOCK.
	TLNN	R16,IRPBIT		; IS THIS A .IRP?
	JRST	MAC40			;    NO -- MARK END OF ARGUMENT.
	CAIN	RBYTE,","		;    YES - SKIP COMMA, IF ANY.
	IBP	RBPTR			; KEEP DELIMITER IN RBYTE!
	JRST	MAC50A			; QUIT AFTER PRECISELY 1 ARG.
MAC40:					; END-OF-ARGUMENT PROCESSING
	SKIPG	ARGLEN			; WAS ARGUMENT NULL?
	CALL	GENSYM			;    YES - GENERATE A LOCAL SYMBOL
					;    IF NECESSARY.
	PUSH	P,RBYTE			; SAVE ARGUMENT DELIMITER.
	MOVEI	RBYTE,QUEARG
	CALL	WTIMT			; MARK END OF ARGUMENT
	POP	P,RBYTE			; RESTORE DELIMITER BYTE.
	CAIN	RBYTE,","		; IS IT A COMMA?
	IBP	RBPTR			;    YES - SKIP IT.
	SOJG	R7,MAC10		; BRANCH IF MORE ARGS

MAC50A:	MOVEM	RBYTE,ARGDEL		; SAVE ARG DELIMITER (FOR .IRP)

MAC50:					; END OF LINE PROCESSOR
	PUSH	P,ARGCNT		; Save arg counter
	AOS	ARGCNT			; INCREMENT ARG COUNT FOR SYM GENERATOR.
	CALL	GENSYM			; GEN A LOCAL SYMBOL IF NECESSARY.
	MOVEI	R14,QUEARG
	CALL	WTIMT			; PAD MISSING ARGS
	SOJGE	R7,MAC50+1
	POP	P,ARGCNT		; Restore arg count
	POP	P,R10			; GET POINTER TO CALL BLOCK.
	MOVEM	R12,0(R10)		; SAVE CURRENT READ POINTER
	MOVE	R1,CALPNT
	MOVEM	R1,1(R10)		; SAVE CURRENT CALL BLOCK POINTER
	MOVEM	R10,CALPNT		; SET NEW POINTER
	POP	P,R12			; GET POINTER TO BASIC BLOCK
	HRLI	R12,(POINT 7,,)		; FORM A BYTE POINTER
	MOVEM	R12,2(R10)		; SAVE IT FOR DECMAC
	HRRM	R14,3(R10)		; SAVE LAST CHARACTER READ
	MOVE	R14,ARGCNT		; SAVE ARGUMENT COUNT
	HRLM	R14,3(R10)		; IN MACRO CALL BLOCK.
	ADDI	R12,3			; POINT PAST WORD STORAGE

;	   SAVE REPEAT AND CONDITIONAL NESTING LEVELS
;	   FOR LATER USE IF A .MEXIT IS ISSUED.

	AOS	R14,MACLVL		; Increment and load macro call level
	MOVE	R0,REPLVL		; SAVE .REPT LEVEL
	MOVEM	R0,MCLREP(R14)
	MOVE	R0,CONLVL		; SAVE NEXTED CONDITIONAL LEVEL
	MOVEM	R0,MCLCON(R14)
	MOVE	R0,UNSLVL		; SAVE UNSATISFIED COND LEVEL
	MOVEM	R0,MCLUNS(R14)

	LDB	RBYTE,RBPTR		; RESTORE LAST CHARACTER.
	RETURN


MAC70:					; "\"
	CALL	GETNB			; BYPASS UNARY OP
	PUSH	P,R7			; PROTECT ARG COUNT
	TLZ	R16,FOLBIT		; FOLD TO UPPER CASE FOR EXPR EVALUATION.
	CALL	ABSEXP			; EVALUATE THE EXPRESSION
	TLO	R16,FOLBIT		; CEASE FOLDING AGAIN.
	CALL	MAC71			; CONVERT TO ASCII
	POP	P,R7			; RESTORE ARG COUNT
	CALL	SETNB			;  AND LAST CHARACTER

MAC70A:	CAIE	R4,SCLE			; IS EXPR DELIMITER A VALID ARG
	CAIN	R4,SCSE			; DELIMITER? (",", BLANK, ";", OR EOL)
	JRST	MAC40			;    YES - DO END-OF-AR PROCESSING.
	TRO	RERR,ERRQ		;    NO -- FLAG QUESTIONABLE SYNTAX
	CALL	GETNB			; AND SKIP TO VALID DELIMITER.
	JRST	MAC70A



MAC71:	IDIV	R10,RADVAL		; DIVIDE NUMBER BY DEFAULT RADIX.
	HRLM	R11,0(P)
	CAIE	R10,			; TEST FOR END
	CALL	MAC71
	HLRZ	R14,0(P)
	ADDI	R14,"0"			; FORM TEXT
	CAILE	R14,"9"			; CHECK FOR HEX DIGITS A-F.
	ADDI	R14,"A"-"9"-1
	JRST	WCIMT			; WRITE INTO SKELETON
;	   SUBROUTINE GENSYM GENERATES A LOCAL SYMBOL IN THE
;	   RANGE OF 64$ - 127$ IF AN OMITTED ARGUMENT WAS FLAGGED
;	   WITH A "?" IN THE MACRO PROTOTYPE.

GENSYM:	MOVEI	R0,1			; TRANSLATE FROM ARGUMENT #
	MOVE	R1,ARGCNT		; TO A MASK BIT.
	ROT	R0,-1(R1)
	TDNN	R0,MARMAS		; DOES THIS ONE WANT A SYMBOL?
	RETURN				;    NO -- IT'S HAPPY TO BE NULL.
					;    YES - .... GROAN.

	MOVE	R0,NEXGS		; GET VALUE FOR NEXT GENERATED SYMBOL.
	TRZE	R0,777400		; DON'T LET IT EXCEED 127!
	TRO	RERR,ERRT		; * FLAG TRUNCATION ERROR IF IT DOES.
	AOS	NEXGS			; SET NEW VALUE FOR NEXT SYMBOL.

	PUSH	P,RBYTE			; SAVE CURRENT SOURCE BYTE.
	CALL	LOCVRT			; CONVERT NUMERIC PART OF LOCAL SYMBOL.
	MOVEI	RBYTE,"$"		; APPEND "$".
	CALL	WCIMT			; WRITE IT IN CALL BLOCK.
	POP	P,RBYTE			; REFURBISH USED REGISTER.
	RETURN

;	   LOCVRT IS YET ANOTHER VARIANT ON THE UBIQUITOUS
;	   RECURSIVE SUBROUTINE THAT CONVERTS AN INTEGER
;	   TO DECIMAL.  THIS ONE STUFFS ITS DIGITS INTO
;	   THE MACRO CALL BLOCK AS A PARAMETER VALUE.

LOCVRT:	IDIVI	R0,^D10			; PICK OFF THE NEXT DIGIT.
	HRLM	R1,0(P)			; SAVE IT ON THE STACK.
	CAIE	R0,0			; HAS QUOTIENT VANISHED?
	 CALL	LOCVRT			;    NO -- DO IT AGAIN.
	HLRZ	RBYTE,0(P)		;    YES - RETRIEVE THE DIGIT.
	TRO	RBYTE,"0"		; TRANSLATE IT TO ASCII.
	JRST	WCIMT			; WRITE IN MACRO TREE & RETURN.
;		##########  .MEXIT  ###########

;	.MEXIT RESTORES THE LEVEL COUNTERS FOR REPEATS,
;	CONDITIONALS, AND UNSATISFIED CONDITIONALS TO
;	THEIR VALUES AT THE MACRO CALL.  IT LISTS
;	THE REMAINING MACRO LINES AND ENTERS .ENDM PROCESSING.


.MEXIT:	SKIPG	R14,MACLVL		; IS A MACRO EXPANDING?
	 JRST	[ SKIPN	REPPNT		;  No - how about .REPT expansion?
		   JRST	OPCERR		;   No - then its a real error
		  SKIPE	CONLVL		;   Yes - fudge conditional level
		   SOS	CONLVL		; Go back 1 if necessary
		  JRST	REPFIN	]	; Exit out of this loop

	MOVE	R0,MCLREP(R14)		; RESTORE REPEAT LEVEL
	MOVEM	R0,REPLVL
	MOVE	R2,MCLCON(R14)		; RESTORE COND LEVEL
	EXCH	R2,CONLVL		; Store new level and get old
	SUB	R2,CONLVL		; Get the difference
	JUMPLE	R2,.MEXTA		; Skip if there is none
	MOVE	R0,.IFFLG		; Get conditional flags
	MOVNI	R2,(R2)			; Negate the difference
	LSH	R0,(R2)			;  and restore flags
	MOVEM	R0,.IFFLG		; Save the flags
.MEXTA:	MOVE	R0,MCLUNS(R14)		; RESTORE UNSATISFIED LEVEL
	MOVEM	R0,UNSLVL

;  R14 should have the level at which to stop.  If .IRP(C) is not in progress
;  then R14 will be decremented by 1.  Else R14 will be loaded the level at
;  which the last .IRP(C) was called.

	SKIPGE	IRPLVL			; Any .IRP(C)'s in progress?
	 SOJA	R14,.MEXT1		;  No - decrement R14 and go
	CAMLE	R14,IRPMAX		;  Yes - Was this in .IRP(C) ?
	 SOJA	R14,.MEXT1		;   No - decrement R14 and proceed
	MOVE	R14,IRPLVL		;   Yes - load level we have to reach
.MEXT1:	MOVEM	R14,MLSAVE		; SAVE MACLVL

MEXLST:	CALL	ENDLR			; LIST NEXT LINE.
	CALL	GETLIN			; GET ITS SUCCESSOR.
	MOVE	R0,MACLVL
	CAMG	R0,MLSAVE		; DID MACLVL CHANGE?
	 JRST	STMNT			;   Yes - process this line 1st, return
	CALL	GETEOL			;   No -- Position to end of line.
	JRST	MEXLST			; Continue until exiting this level.
	SUBTTL	MACRO STORAGE HANDLERS

WTIMT:					; WRITE TWO CHARACTERS IN MACRO TREE
	PUSH	P,R14			; STACK CURRENT CHARACTER
	MOVEI	R14,RUBOUT		; SET FLAG CHARACTER
	CALL	WCIMT			; WRITE IT
	POP	P,R14			; RESTORE CHARCTER AND FALL THROUGH

WCIMT:					; WRITE CHARACTER IN MACRO TREE
	TLZE	R15,CONFLG		; CONCATENATION CHARACTER PENDING?
	JRST	WCIMT2			;  YES, WRITE IT OUT
	IBP	MWPNTR			; POINT TO ACTUAL WORD
	SKIPN	@MWPNTR			; END OF BLOCK?
	JRST	WCIMT1			;  YES, GET ANOTHER
	DPB	R14,MWPNTR		; NO, STORE BYTE
	RETURN				; EXIT

WCIMT1:	PUSH	P,MWPNTR		; READ A NEW BLOCK, SAVE CURRENT POINTER
	CALL	GETBLK			; GET IT
	HRRZ	R11,MWPNTR		; GET START OF NEW BLOCK
	EXCH	R11,0(P)		; EXCHANGE WITH POINTER TO LAST
	POP	P,0(R11)		; STORE VECTOR
	JRST	WCIMT			; TRY AGAIN

WCIMT2:	PUSH	P,R14			; STACK CURRENT CHARACTER
	MOVEI	R14,"'"
	CALL	WCIMT			; WRITE CONCATENATION CHARACTER
	POP	P,R14			; RESTORE CHARACTER
	JRST	WCIMT			; CONTINUE


;	   GBLOCK gets a block of storage from the area
;	   used for macro info, but initializes it differently.
;	   It clears the entire block.

;	   At return the block's start address is in R2;
;	   All other registers are intact.

GBLOCK:	SKIPE	R2,NEXT			; Garbage collected block available?
	  JRST	GBLK1			;    Yes - Use it.
	MOVEI	R2,WPB			;    No -- Get virgin memory.
	ADDB	R2,.JBFF		; Allocate the new block.
	CAML	R2,SYMBOT		; Does it overlap the symbol table?
	 CALL	GETCOR			;  Yes - try to get some more
	MOVEI	R2,-<WPB-1>(R2)		;    No -- Point to block's first word.
	SETZM	WPB-1(R2)		; Clear link field in last word.

GBLK1:	PUSH	P,WPB-1(R2)		; Dequeue block from garbage list,
	POP	P,NEXT			; if that's where it is.

	HRLI	R2,-WPB			; Clear entire block.
	SETZM	0(R2)
	AOBJN	R2,.-1

	MOVEI	R2,-WPB(R2)		; Set R2 to block's bottom address.
	RETURN				; Return.





GETBLK:					; GET A BLOCK FOR MACRO STORAGE
	SKIPE	R11,NEXT		; ANY REMNANTS OF GARBAGE COLLECTION?
	JRST	GETBL1			;  YES, RE-USE
	PUSH	P,R7			;  NO, SAVE REGISTER
	MOVEI	R7,WPB
	ADDB	R7,.JBFF		; UPDATE FREE LOCATION POINTER
	CAML	R7,SYMBOT		; ANY ROOM?
	CALL	GETCOR			;  NO, GET MORE CORE
	MOVEI	R11,-<WPB-1>(R7)	; POINT TO START OF BLOCK
	POP	P,R7			; RESTORE
	SETZM	WPB-1(R11)		; CLEAR VECTOR
GETBL1:	HRLI	R11,(POINT 7,,)		; FORM BYTE POINTER
	MOVEM	R11,MWPNTR		; SET NEW BYTE POINTER
	HRLI	R11,-<WPB-1>		; GET SET TO INITIALIZE BLOCK
	SETOM	0(R11)			; CLEAR ENTRY
	AOBJN	R11,.-1			; SET ALL EXCEPT LAST TO -1
	PUSH	P,0(R11)		; GET TOP
	POP	P,NEXT			; SET FOR NEXT BLOCK
	SETZM	0(R11)			; CLEAR LAST WORD
	RETURN				; EXIT
READMC:					; READ MACRO CHARACTER
	CALL	READMB			; GET A MACRO BYTE
	CAIE	R14,RUBOUT		; SPECIAL?
	 JRST	CPOPJ1			;  NO, JUST EXIT
	CALL	READMB			; YES, GET TYPE
	TRZE	R14,100			; SYMBOLIC?
	JRST	GETDS			;  YES
	JRST	.(R14)			;  NO, TRANSFER ON TYPE

	PHASE	1
QUEMAC:! JRST	MACEND			; END OF MACRO
QUEARG:! JRST	DSEND			; END OF MACRO ARGUMENT
QUEREP:! JRST	REPEND			; END OF REPEAT
	DEPHASE


READMB:					; READ MACRO BYTE
	ILDB	R14,R12			; GET CHARACTER
	JUMPN	R14,CPOPJ		; EXIT IF NON-NULL
	MOVE	R12,0(R12)		; END OF BLOCK, GET LINK
	HRLI	R12,(POINT 7,,)		; SET ASCII BYTE POINTER
	JRST	READMB			; TRY AGAIN


GETDS:					; GET DUMMY SYMBOL
	MOVE	R11,CALPNT		; GET POINTER TO CALL BLOCK
	MOVEM	R12,4(R11)		; SAVE CURRENT READ POINTER
	MOVE	R12,R11			; SET NEW READ POINTER
	ADDI	R12,5			; MOVE PAST WORDS
	MOVE	R11,R14			; GET ARG NUMBER
	ANDI	R11,37
GETDS1:	PUSH	P,R11			; STACK WORKING REGISTER
GETDS2:	CALL	READMB			; GET A MACRO BYTE
	CAIE	R14,RUBOUT		; FLAGGED?
	JRST	GETDS2			;  NO, TRY AGAIN
	CALL	READMB			; YES, BYPASS END CODE
	POP	P,R11			; RESTORE WORKING REGISTER
	SOJG	R11,GETDS1		; TEST FOR COMPLETION
	RETURN				;  YES, EXIT


DSEND:					; DUMMY SYMBOL END
	MOVE	R12,CALPNT		; GET POINTER TO CALL BLOCK
	MOVE	R12,4(R12)		; RESTORE PREVIOUS READ POINTER
	RETURN				; EXIT


MACEND:					; END OF MACRO CALL
	MOVE	R10,CALPNT		; IN CASE WE GOT WIPED
	MOVE	R12,0(R10)		; RESET PREVIOUS READ POINTER
	MOVE	R1,1(R10)
	MOVEM	R1,CALPNT		; LIKEWISE
	MOVE	R1,2(R10)		; GET POINTER TO BASIC BLOCK
	CALL	DECMAC			; DECREMENT THE REFERENCE
	HRRZ	R14,3(R10)		; RESTORE LAST CHARACTER
	MOVE	R1,R10
	CALL	REMMAC			; RETURN THIS BLOCK FOR DEPOSIT
	SOS	R14,MACLVL		; DECREMENT MACRO CALL DEPTH LEVEL
	SKIPGE	IRPLVL			; Inside a .IRP(C) ?
	 RETURN				;  No - back to caller
	CAME	R14,IRPLVL		;  Yes - back to original level?
	 JRST	[ CAML	R14,IRPMAX	;   No - inside max level?
		   RETURN		;    No - back to caller now
		  MOVEM	R14,IRPMAX	;    Yes - re-load max level
		  RETURN	]	; Else set new max
	MOVE	R11,MCLIRP(R14)		;   Yes - get info about it
	HLREM	R11,IRPLVL		; Set new .IRP(C) calling level
	HRRM	R11,IRPMAX		; Also set new level max
	RETURN				; FINIS

DECMAC:					; DECREMENT MACRO STORAGE
	SOSL	0(R1)			; TEST FOR END
	RETURN				;  NO, EXIT

REMMAC:					; REMOVE MACRO STORAGE
	PUSH	P,R1			; SAVE POINTER
	HRLS	R1			; SAVE CURRENT POINTER
	HRR	R1,WPB-1(R1)		; GET NEXT LINK
	TRNE	R1,-1			; TEST FOR END (NULL)
	JRST	.-3			;  NO
	HLRZS	R1			; YES, GET RETURN POINTER
	HRL	R1,NEXT			; GET CURRENT START OF CHAIN
	HLRM	R1,WPB-1(R1)		; STORE AT TOP
	POP	P,R1			; RESTORE BORROWED REGISTER
	HRRZM	R1,NEXT			; SET NEW START
	RETURN				; EXIT

	SUBTTL	LISTING ROUTINES

;	PRNTA LISTS ASSEMBLER - GENERATED INFORMATION
;	AT THE LEFT SIDE OF EACH LINE:

;	 -- LINE NUMBER FIELD
;	 -- LOCATION (UNLESS .NLIST LOC IS IN EFFECT)
;	 -- BINARY CODE (UNLESS .NLIST BIN IS IN EFFECT)

;		.. THREE WORDS OF BINARY CODE ARE LISTED
;		   IF TTM LISTING MODE IS NOT IN EFFECT.
;		.. ONE WORD OF BINARY CODE IS LISTED
;		   IF TTM LISTING MODE IS IN EFFECT

;	PRNTA IS CALLED FROM ONLY ONE PLACE (A LOCATION
;	BETWEEN ENDL6 AND ENDL7).

PRNTA:					; PRINT BASIC LINE OCTAL

	MOVE	R0,LSTCTL		; ****  SEQ # FIELD  ****
	TLNE	R16,CSWBIT		; supress cref or		[ECL2]
	 TRNN	R0,LSEQ			; SEQUENCE # TO BE LISTED?
	  JRST	PRNTA0			; NO - JUST TAB TO LOC FIELD
	TLNE	R16,BEXBIT		; YES - LIST SEQ UNLESS THIS
	 JRST	PRNTA0			; IS A BINARY EXTENSION LINE.

;	   ===========  LIST LINE SEQUENCE NUMBER  ===========

	CALL	FORSEQ			; FORMAT THE FIELD.
PRNSEQ:	CALL	LSTOUT			; LIST A BYTE OF IT.
	ILDB	R2,R6			; GET NEXT BYTE
	JUMPN	R2,PRNSEQ		; REPEAT UNTIL FINDING 0 BYTE.

PRNTA0:	CALL	LSTTAB			; LIST A TAB

	MOVE	R0,LSTCTL		;    **** LOCATION FIELD ****
	TRNN	R0,LLOC			; IS LOC TO BE LISTED?
	 JRST	PRNTA1			; NO - GO TO NEXT FIELD.
					; YES - PRINT LOC IF IT WAS GENERATED.
	SKIPE	R10,PF0			; FIRST FIELD TO BE PRINTED?
	CALL	PRNTWB			;  YES
	CALL	LSTTAB			; OUTPUT TAB

PRNTA1:	MOVE	R0,LSTCTL		;    **** BINARY FIELD ****
	TRNN	R0,LBIN			; BINARY TO BE LISTED?
	 JRST	PRNTA2			; No - fill fields with tabs
					; YES - LIST WHATEVER WAS GENERATED.
	SKIPE	R10,PF1			; PRINT PF1
	CALL	PRNTWB
	HRRZ	R0,LSTCTL
	TRNE	R0,LTTM			; TELETYPE?
	RETURN				;  YES, THROUGH FOR NOW
	CALL	LSTTAB
	SKIPE	R10,PF2
	CALL	PRNTWB			;  NO, LIST 2 MORE WORDS.
	CALL	LSTTAB
	SKIPE	R10,PF3
	CALL	PRNTWB
	RETURN				; EXIT

PRNTA2:
	CALL	LSTTAB			; Tab across PF1
	MOVE	R0,LSTCTL		; Get listing mode
	TRNN	R0,LTTM			; Teletype mode?
	 CALL	LSTTAB			; No - fill with a tab
	RETURN				; Yes- return

PRNTWB:					; PRINT WORD OR BYTE
	LDB	R3,[POINT 2,R10,17]
	CAIE	R3,1
	 JRST	PRNTWD			;  YES
	CALL	LSTSP			; LIST THREE SPACES
	CALL	LSTSP
	CALL	LSTSP
	MOVE	R3,[POINT 3,R10,26]
	ANDI	R10,377
	JRST	PRNTWF

PRNTWD:	MOVE	R3,[POINT 3,R10,17]
PRNTWF:	ILDB	R2,R3
	PUSH	P,R3
	CALL	LSTNUM			; LIST NUMBER
	POP	P,R3
	TLNE	R3,770000
	JRST	PRNTWF
	MOVEI	R2,"'"
	TLNE	R10,GLBSYM
	MOVEI	R2,"G"
	TLNE	R10,(PFMASK)		; RELOCATABLE?
	 JRST	LSTOUT			;  YES
	RETURN
;	   ===========  SUBROUTINE  FORSEQ  -==============

;	FORMAT A SEQUENCE NUMBER FOR AN OUTPUT LINE.
;	   THE BINARY LINE SEQUENCE NUMBER IS LOCATION SEQ;
;	   THE FORMATTED VERSION IS LOCATION FSEQ.

;	   IF THE LINE WAS EXPANDED FROM A MACRO, PRINT THE
;	   MACRO CALL NESTING LEVEL TO THE LEFT OF THE LINE
;	   NUMBER.

;	AT RETURN, . . .

;	   FSEQ CONTAINS AN ASCIZ-STYLE STRING,
;	   R6 CONTAINS A POINTER TO ITS FIRST BYTE,
;	   R2 CONTAINS THE FIRST BYTE.


FORSEQ:	SETZM	FSEQ			; CLEAR FORMATTED STRING FIELDS.
	SETZB	R2,FSEQ+1		; R2 = 0 TO COUNT BYTES.
	MOVE	R0,SEQ			; LOAD BINARY SEQUENCE NUMBER.

;   SEQUENCE NUMBER CONVERSION IS BINARY TO DECIMAL, ONE BYTE
;   AT A TIME VIA REPEATED DIVISION BY 10.  BYTES ARE PUSHED
;   ONTO THE STACK IN ASCENDING ORDER OF SIGNIFICANCE.

FSCVT:	IDIVI	R0,^D10			; DIVIDE TO GET (#/10, # MOD 10).
	TRO	R1,"0"			; CONVERT DIGIT TO ASCII.
	PUSH	P,R1			; PUSH IT ONTO THE STACK.
	AOJ	R2,			; INCREMENT DIGIT COUNT.
	JUMPN	R0,FSCVT		; REPEAT UNTIL QUOTIENT GOES TO 0.

;	   R2 = # OF SIGNIFICANT DIGITS.  FIGURE OUT HOW MANY
;	   BLANKS TO FORMAT IN ORDER TO RIGHT-JUSTIFY THE SEQUENCE
;	   NUMBER.  .  .

;		# OF BLANKS = 7 - M - S - E, WHERE
;			M = # OF DIGITS IN MACRO LEVEL
;			S = # OF SIGNIFICANT DIGITS
;			E = # OF ERROR FLAGS PRINTED

;	   S IS IN R2;  COMPUTE 7-E IN R0 BY COUNTING THE NUMBER
;	   OF BITS ON IN RERR (RIGHT HALF OF R15).

	MOVEI	R3,7
	TLNN	R16,MEXBIT		; IS THIS LINE FROM A MACRO EXPANSION?
	JRST	FSNM			;    NO -- JUST FORMAT SEQ NUM.
	MOVE	R0,MACLVL		;    YES - LOAD CALL NESTING LEVEL.
	PUSH	P,R2			; KEEP R2 KOSHER &
	CALL	LSTLNU			; PRINT MACLVL WITH A BORROWED SUBR.
	POP	P,R2

FSNM:	HRRZ	R6,RERR			; SET R6 TO ERROR FLAGS.
	JUMPE	R6,FSCDUN		; DONE IF NO BITS ON.

;	   THE FOLLOWING LOOP IS ITERATED ONCE FOR EACH
;	   1 BIT IN R6.  R6 IS DESTROYED IN THE PROCESS
;	   OF COUNTING ITS BITS.

FSCNT:	SOJ	R3,			; DECREMENT BLANK COUNT.
	MOVN	R1,R6			; A XOR (-A) TURNS OFF LOW BIT,
	XOR	R1,R6			; WHEREVER IT MAY BE.
	AND	R1,R6			; RECONSTRUCT HIGH ORDER BITS.
	MOVE	R6,R1			; COPY BACK FOR NEXT ITERATION.
	JUMPN	R6,FSCNT		; REPEAT UNLESS NO BITS REMAIN.

;	   END OF BIT COUNT -- R3 = 7-M-E.

FSCDUN:	MOVE	R6,[POINT 7,FSEQ]	; LOAD SEQ FIELD POINTER.
	SUB	R3,R2			; BLANK COUNT = (7-E)-S.
	JUMPLE	R2,FSDIGT		; BEWARE GOBS OF FLAGS!
	MOVEI	R1," "			; LOAD LITERAL BLANK TO DEPOSIT.

FSLEAD:	IDPB	R1,R6			; SUPPLY A LEADING BLANK.
	SOJG	R3,FSLEAD		; REPEAT TIL COUNT IS EXHAUSTED.

;	   POP SIGNIFICANT DIGITS OFF THE STACK (IN DESCENDING
;	   ORDER OF SIGNIFICANCE) & APPEND TO FSEQ.

FSDIGT:	POP	P,R1			; GET NEXT DIGIT.
	IDPB	R1,R6			; STORE IN FSEQ.
	SOJG	R2,FSDIGT		; REPEAT TIL ALL DIGITS DONE.

;	   LOAD REGS WITH BYTE & BYTE POINTER, THEN RETURN.

	MOVE	R6,[POINT 7,FSEQ]	; LOAD PTR TO START OF FIELD.
	ILDB	R2,R6			; LOAD FIRST BYTE.
	RETURN

	SUBTTL	OCTAL OUTPUT ROUTINES

STCODE:					; STOW CODE
	PUSH	P,R3
	AOS	R3,CODPNT		; INCREMENT INDEX
	MOVEM	R1,CODBUF-1(R3)		; STORE
	POP	P,R3
	RETURN

PROCOD:					; PROCESS CODE
	MOVE	R6,CODPNT		; FETCH INDEX
	SKIPN	R1,CODBUF(R6)		; NULL?
	RETURN				;  YES, EXIT NULL
	SETZM	CODBUF(R6)
	CALL	PROWRD			; PROCESS WORD
	MOVE	R6,PFT0			; TRANSFER PRINT STUFF
	TLZN	R16,LBLBIT		; ** PF0 IS ALREADY SET IF
					; ** LBLBIT IS 1.
	MOVEM	R6,PF0
	MOVE	R6,PFT1
	TLNN	R16,PF1BIT		; IF PF1BIT SET, PRINT VALUE
					; STORED IN PF1 BY SOME WEIRDO DIRECTIVE
	MOVEM	R6,PF1
	AOS	R6,CODPNT		; INCREMENT INDEX
	HRRZ	R0,LSTCTL		; IF TELETYPE FORMAT
	TRNN	R0,LTTM
	SKIPN	R1,CODBUF(R6)		;  IF EMPTY,
	JRST	CPOPJ1			;  EXIT GOOD
	SETZM	CODBUF(R6)
	CALL	PROWRD
	MOVE	R6,PFT1
	MOVEM	R6,PF2
	AOS	R6,CODPNT		; MORE OF SAME
	SKIPN	R1,CODBUF(R6)
	JRST	CPOPJ1
	SETZM	CODBUF(R6)
	CALL	PROWRD
	MOVE	R6,PFT1
	MOVEM	R6,PF3
	AOS	CODPNT
	JRST	CPOPJ1


PROWRD:					; PROCESS WORD
	SETZM	PFT0			; CLEAR TEMP PRINT BUFFERS
	SETZM	PFT1
	LDB	R2,MODPNT		; GET CLASS
	ANDI	R2,177			; MASK OUT BYTE BIT
	MOVE	R10,RLDTBL(R2)		; GET PROPER TABLE ENTRY
	MOVE	R3,R5			; GET A COPY OF THE PC
	TLO	R3,DEFSYM		; WITH DEFINED BIT SET
	TLNE	R1,BC1!BC2		; CODE TO BE GENNED?
	MOVEM	R3,PFT0			;  YES, PRINT LOCATION
	MOVE	R4,R10			; FLAGS TO R4
	DPB	R1,[POINT 36-8,R4,35]	; REMAINDER FROM R1
	CAIN	R2,RLDT1		; SPECIAL IF CLASS 1
	 TLO	R4,(1B<SUBOFF>)
	CAIE	R2,RLDT7		; IF CLASS 7 OR 10
	 CAIN	R2,RLDT10
	  MOVE	R4,R3			;  USE PREVIOUS PC
	MOVEM	R4,PFT1			; SET TEMP PRINT FIELD 1

	TLNE	RMODE,PNCFLG		; IS OBJECT OUTPUT BEING SUPPRESSED?
	TLNE	R15,P1F!ABSFLG		; PASS ONE?
	JRST	PROWR3			;  YES, BRANCH
	LDB	R3,TYPPNT		; GET BYTE COUNT
	CAIN	R2,RLDT11		; TYPE 11?
	MOVEI	R3,4			;  YES, ALL IN ONE BUFFER
	ADD	R3,BYTCNT
	HRRZ	R4,R10
	ADD	R4,RLDCNT
	CAIG	R3,RLDLEN
	CAILE	R4,RLDLEN		; ROOM TO STORE?
	CALL	BLKDMP			;  NO, DUP CURRENT BUFFER
	SKIPN	BYTCNT			; BUFFER EMPTY?
	TLNN	R1,BC1!BC2		;  YES, ANY CODE?
	JRST	PROWR1			; OK, BYPASS
	MOVEI	R2,BKT3
	CALL	BSWORD			;  NO, STORE BLOCK TYPE
	MOVE	R2,R5
	CALL	BSWORD			; STORE CURRENT ADDRESS
PROWR1:	LDB	R2,MODPNT		; GET THE TYPE
	JUMPE	R2,PROWR3		; BRANCH IF ABSOLUTE
	CALL	RLDSTB			; STORE IT
	TLNN	R1,BC1!BC2		; CODE?
	 TDZA	R2,R2			;  NO, SET ZERO
	  MOVE	R2,BYTCNT		; YES, SET BYTE POINT FOR REFERENCE
	CALL	RLDSTB
	LDB	R2,SUBPNT
	JUMPE	R2,PROWR2		; BRANCH IF NOT EXTERNAL/REL
	MOVS	R2,GLBBUF(R2)		; GET GLOBAL NAME
	CALL	RLDSTW
	HLRZS	R2
	CALL	RLDSTW			;  AND LEFT HALF

PROWR2:	MOVEI	R2,(R1)			; GET VALUE
	SKIPGE	R1			; Byte modification?
	 ANDI	R2,377			; Yes - leave only 8 bits
	TLNE	R10,1			; No - should we store the value?
	 CALL	RLDSTW			;  YES
PROWR3:	MOVE	R2,R1			; GET BASIC VALUE
	TLNE	R2,BC1!BC2		; CODE?
	 CALL	BYTOUT			;  YES
	LSH	R2,-^D8			; SHIFT HIGH ORDER BYTE DOWN
	TLNE	R1,BC2			; WORD?
	 CALL	BYTOUT			;  YES, OUTPUT HIGH BYTE
	TLNN	R1,BC1!BC2		; CODE?
	 CALL	BLKDMP			;  NO, SPECIAL.  DUMP THE BUFFER
	RETURN

RLDSTW:
	PUSH	P,R2
	CALL	RLDSTB
	LSH	R2,-^D8
	CALL	RLDSTB
	POP	P,R2
	RETURN

RLDSTB:	AOS	R3,RLDCNT
	MOVEM	R2,RLDBLK-1(R3)
	RETURN

RLDTBL:
	PHASE	0
RLDT0:!	XWD	DEFSYM!	0,	0
RLDT1:!	XWD	DEFSYM!	1,	4
RLDT2:!	XWD	0!	0,	6
RLDT3:!	XWD	DEFSYM!	1,	4
RLDT4:!	XWD	0!	0,	6
RLDT5:!	XWD	GLBSYM!	1,	10
RLDT6:!	XWD	GLBSYM!	1,	10
RLDT7:!	XWD	0!	1,	10
RLDT10:! XWD	DEFSYM!	1,	4
RLDT11:! XWD	DEFSYM!	0,	2
RLDT12:! XWD	0!	0,	0
RLDT13:! XWD	0!	0,	0
RLDT14:! XWD	0!	0,	0
RLDT15:! XWD	DEFSYM!	1,	10
RLDT16:! XWD	DEFSYM!	1,	10
RLDT17:! XWD	0!	0,	0
	DEPHASE

ENDP:					; END OF PASS ROUTINES
	CALL	TSTMAX			; BE SURE TO TRAP MAX PC
	LDB	R2,CCSPNT
	HRRM	R5,SECBAS(R2)		; SET HIGH LOCATION
	TLNN	R15,P1F			; PASS 1?
	 JRST	ENDP20			;  NO

;	   IF .ENABL GBL IS IN EFFECT, SCAN THE SYMBOL TABLE
;	   FOR UNDEFINED NAMES & RE-TYPE THEM AS GLOBAL.

	TLNN	RMODE,GBLFLG		; IS .ENABL GBL IN EFFECT?
	 JRST	ENDSB			;    NO -- LEAVE SYM TAB AS IS.
					;    YES - SCAN FOR UNDEFINED SYMS.
	SETZ	R7,			; CLEAR INDEX INTO TABLE.

ENDUS:	ADDI	R7,4			; ADVANCE TO NEXT SYMBOL.
	CAML	R7,SYMLEN		; IS THIS THE END?
	 JRST	ENDSB			;    YES - ALL DONE.
					;    NO -- CHECK NEXT SYMBOL.
	MOVE	R0,@VALPNT		; LOAD SYMBOL'S DEFINITION.
	TLNN	R0,DEFSYM		; IS IT DEFINED?
	 TLO	R0,GLBSYM		;    NO -- MARK IT GLOBAL.
	MOVEM	R0,@VALPNT		; STORE NEW DEFINITION.
	JRST	ENDUS			; GO BACK FOR NEXT SYMBOL.

ENDSB:	CALL	SETBIN			; SET BINARY (OBJ OR BIN)
	TLNE	R15,ABSFLG		; YES, ABSOLUTE?
	 RETURN				;  YES, NO ACTION
	MOVE	R0,PRGTTL		; GET PROGRAM TITLE
	SETZ	R1,
	CALL	HDROUD			; OUTPUT DOUBLE WORD

	MOVE	R0,PRGVER		; Get version, if any, set by .Ident
	JUMPE	R0,ENDPA		;    ... Proceed if none was given.
	MOVSI	R1,3000			; Set type 6,
	CALL	HDROUD			; Output it.

ENDPA:	SETZ	R6,			; INIT SECTOR COUNT
ENDP11:	SETZ	R7,			; INIT FOR TABLE SEARCH
	MOVE	R0,SECNAM(R6)		; GET SECTOR NAME
	HLRZ	R1,SECBAS(R6)		; GET ITS LENGTH
	HRLI	R1,450			; ASSUME RELOCATABLE
	CAIN	R6,			; YES?
	 MOVSI	R1,410			;  NO, ABS

	HRLZ	R2,SECFLG(R6)		; Get flags for this section.
	JUMPE	R2,ENDPO		; Zero means ASECT/CSECT
	HRLI	R1,2400			; Nonzero means psect.
	IOR	R1,R2			; Set flag bits.
ENDPO:	CALL	HDROUD			; OUTPUT IT
ENDP12:	CALL	GETSTE			; GET THE NEXT SYMBOL TABLE ENTRY
	 JRST	ENDP15			;  END, BRANCH
	TLNN	R1,GLBSYM		; GLOBAL?
	 JRST	ENDPLS			;    NO -- PUT IT IN ISD IF WANTED.
	LDB	R2,SUBPNT		; GET RELOCATION
	MOVSI	R3,2150			; ASSUME REL
	JUMPN	R6,ENDP13		; BRANCH IF TRUE
	MOVSI	R3,2100			; NO, ASSUME EXTERNAL
	TLNN	R1,DEFSYM		; TRUE?
	 JRST	ENDP14			;  YES
	TLOA	R3,10			; INTERNAL
ENDP13:	 TLNE	R1,DEFSYM		; IF EXTERNAL
	  CAME	R2,R6			;  OR NON-MATCH
	   JRST	ENDP12
ENDP14:	HLL	R1,R3
	JRST	ENDPO			; OUTPUT IT & TRY FOR MORE.

ENDP15:	ADDI	R6,1			; MOVE TO NEXT SECTOR
	SKIPN	SECNAM(R6)		; IF NON-NULL
	CAIN	R6,1			;  OR SECTOR 1,
	 JRST	ENDP11			; PROCESS
	MOVE	R1,ENDVEC		; GET END VECTOR
	LDB	R2,SUBPNT		; ISOLATE ITS RELOCATION
	MOVE	R0,SECNAM(R2)		; GET THE NAME
	HRLI	R1,1410			; ASSUME ABSOLUTE
	CAIE	R2,
	TLO	R1,40			; NO, RELOCATABLE
	CALL	HDROUD			; OUTPUT IT
	CALL	BLKDMP			; DUMP THE BLOCK
	MOVEI	R2,BKT2
	CALL	BSWORD			; SET BLOCK TYPE
	CALL	BLKDMP			; DUMP THE BUFFER
	MOVEI	R2,BKT4			; OUTPUT A DUMMY CSECT
	CALL	BSWORD
	MOVEI	R2,RLDT7
	CALL	BSWORD
	SETZ	R2,
	CALL	BSWORD
	CALL	BSWORD
	CALL	BSWORD
	JRST	BLKDMP			; DUMP THE BUFFER AND EXIT

;	   SYM TABLE SCAN FOUND LOCAL SYMBOL;  IF .ENABL ISD
;	   IS IN EFFECT, PUT OUT AN INTERNAL SYMBOL DEFINITION
;	   ENTRY IN THE GSD.

ENDPLS:	TLNE	RMODE,ISDFLG		; ISD ENTRIES WANTED?
	TLNN	R1,DEFSYM		; ... AND SYMBOL DEFINED?
	 JRST	ENDP12			;    NO -- GO BACK FOR NEXT SYMBOL.
	LDB	R2,SUBPNT		;    YES - FIND OUT IF THIS
	CAMN	R2,R6			; IS THE SAME PSECT.
	TLNE	R0,200000		; ALSO, DON'T OUTPUT LOCAL SYMBOLS.
	 JRST	ENDP12

	MOVSI	R3,1000			; SET ENTRY TYPE = ISD, FLAGS = 0.
	TLNE	R1,REGSYM		; IS THIS A REGISTER?
	 TLO	R3,1			;    YES - SET FLAG BIT 0.
	TLNE	R1,HFKSYM		; Is this symbol half killed?
	 TLO	R3,2			; Yes - set flag bit 1

	HLL	R1,R3			; COPY ENTRY TYPE & FLAGS,
	JRST	ENDPO			; PUT OUT THE ENTRY.



ENDP20:	CALL	BLKDMP			; END OF PASS 2
	MOVE	R2,ENDVEC		; GET THE VECTOR
	TLNN	R15,ABSFLG		; ABSOLUTE?
	 MOVEI	R2,BKT6			;  NO, SET BLOCK TYPE
	CALL	BSWORD			; STORE IT
	JRST	BLKDMP			; DUMP THE BUFFER AND EXIT


HDROUD:					;OUTPUT DOUBLE WORD
	MOVE	R2,BYTCNT
	CAILE	R2,RLDLEN-^D8+2		; ROOM?
	 CALL	BLKDMP			;  NO
	MOVEI	R2,BKT1
	SKIPN	BYTCNT			; BUFFER INITIALIZED?
	 CALL	BSWORD			;  NO, DO SO
	MOVE	R2,R0			; FIRST WORD
	CALL	HDROUW
	MOVE	R2,R1

HDROUW:	PUSH	P,R2
	HLRZ	R2,0(P)			; LEFT HALF
	CALL	HDROUH
	POP	P,R2

HDROUH:	PUSH	P,R2
	CALL	BSBYTE
	LDB	R2,[POINT 8,0(P),35-8]
	CALL	BSBYTE
	POP	P,R2
	RETURN

BYTOUT:					; OUTPUT A BYTE OF CODE
	TLNE	R15,P1F			; PASS 1
	 AOJA	R5,CPOPJ		;  YES, JUST INCREMENT AND EXIT
	TLNN	R15,ABSFLG		; ABS MODE?
	 JRST	BYTOU1			;  NO
	MOVE	R3,BYTCNT		; YES GET BYTE COUNT
	CAIGE	R3,DATLEN+2		; OUT OF ROOM?
	CAME	R5,CURADR		;  OR A SEQUENCE BREAK?
	 CALL	BLKDMP			;  YES, DUMP THE BUFFER
	SKIPE	BYTCNT			; DO WE NEED INITIALIZATION?
	 JRST	BYTOU1			;  NO, STORE IT
	PUSH	P,R2			; STACK CURRENT CHARACTER
	MOVE	R2,R5			; GET PC
	CALL	BSWORD			; STORE IT
	MOVEM	R5,CURADR		; NEW SEQUENCE BREAK TEST
	POP	P,R2			; RETRIEVE BYTE
BYTOU1:	CALL	BSBYTE			; STORE THE BYTE
	AOS	CURADR			; UPDATE CURRENT ADDRESS
	AOJA	R5,CPOPJ		; INCREMENT CLC AND EXIT

BSWORD:					; BINARY STORAGE OF WORD
	PUSH	P,R2
	CALL	BSBYTE			; STORE LOW ORDER
	LSH	R2,-8			; SHIFT DOWN HIGH ORDER
	CALL	BSBYTE			; STORE IT
	POP	P,R2			; RESTORE WORD
	RETURN				;  AND EXIT

BSBYTE:					; BINARY STORAGE OF BYTE
	AOS	R3,BYTCNT		; INCREMENT AND FETCH THE BYTE COUNT
	MOVEM	R2,DATBLK-1(R3)		; STORE CURRENT BYTE IN BUFFER
	RETURN

BLKDMP:					; DUMP THE CURRENT BLOCK
	SKIPN	BYTCNT			; IS IT EMPTY?
	 JRST	RLDDMP			;  YES, TEST FOR REL BLOCK
	PUSH	P,R1			; GET A COUPLE OF SCRATCH REGISTERS
	PUSH	P,R2
	PUSH	P,R3			; Plus another one
	MOVEI	R2,01			; BLOCK TYPE ONE
	CALL	BINWRD			; OUTPUT FLAG WORD
	MOVE	R2,BYTCNT		; FETCH BYTE COUNT
	ADDI	R2,4			; FUDGE FOR HEADER
	CALL	BINWRD			; OUTPUT IT
	HRLZ	R3,BYTCNT		; GET BYTE COUNT
	MOVNS	R3			; NEGATE BYTE CT
	MOVE	R2,DATBLK(R3)		; GET AN ITEM FROM THE DATA BLOCK
	CALL	BINBYT			; DUMP IT
	AOBJN	R3,.-2			; RECYCLE IF NOT DONE
	MOVN	R2,CHKSUM		; GET NEG OF CHECKSUM.
	CALL	BINBYT			; DUMP IT

;	   Finished with a block -- Supply padding after it if
;	   the command dialog mentioned /FO:PAD.  This is presumed
;	   to be of negligible use to people who aren't eyeballing
;	   paper tapes.

	SETZ	R2,			; Preload padding value (null),
					;    used for both padding & alignment.
	SKIPN	PADSWT			; Is padding wanted?
	 JRST	ALIGN			;    No -- Skip to alignment check.
					;    Yes - Pick suitable length for padding.
	MOVEI	R3,^D6			; Assume absolute obj file
	TLNN	R15,ABSFLG
	MOVEI	R3,^D8
PAD:	CALL	BINBYT			; DUMP SOME BLANK TAPE
	SOJG	R3,PAD


;	   If output is in packed format supply whatever padding
;	   is needed to align the next block as specified in the
;	   alignment mask, which is set by /FO switch options.
;	   Mask values are:

;		0 -- No alignment required	(/FO:NAL -- the default)
;		1 -- Half word alignment	(/FO:HAL)
;		3 -- Full word alignment	(/FO:WAL)

ALIGN:	TLNE	R15,PSWFLG		; Is output in packed format?
	 JRST	PADDON			;    No -- It's already aligned in 10 words.
	MOVE	R3,BINPCT		;    Yes - Get byte number.
	AND	R3,ALIGNM		; And it with alignment mask to check boundary.
	TLNN	R16,BINBIT
	 JUMPG	R3,PAD			; Repeat until reaching proper boundary.

PADDON:	POP	P,R3
	POP	P,R2			; RESTORE REGISTERS
	POP	P,R1

RLDDMP:
	SKIPN	RLDCNT
	 JRST	BLKINI
	PUSH	P,R1
	PUSH	P,R2
	HRLZ	R1,RLDCNT
	CALL	BLKINI
	MOVEI	R2,BKT4
	CALL	BSWORD
	MOVNS	R1
	MOVE	R2,RLDBLK(R1)
	CALL	BSBYTE
	AOBJN	R1,.-2
	CALL	BLKDMP
	POP	P,R2
	POP	P,R1

BLKINI:					; CODE BLOCK INITIALIZATION
	SETZM	BYTCNT			; CLEAR BYTE COUNT
	SETZM	RLDCNT
	RETURN				; EXIT
	SUBTTL	MEMORY MANAGEMENT

GETCOR:					; GET CORE
IFN TENEX,< JRST ERRNC >		; Fatal error if Tenex!!
IFE TENEX,<
	PUSH	P,R0			; GET A COULPLE OF WORKING REGISTERS
	PUSH	P,R1
	HRRO	R1,.JBREL		; GET TOP OF CURRENT CORE
	MOVEI	R0,CORINC(R1)		; COMPUTE NEXT K
	CORE	R0,			; MAKE A REQUEST
	 JRST	ERRNC			; FORGET IT!
	MOVEI	R0,1(R1)
	SUB	R0,SYMBOT		; COMPUTE NUMBER OF ITEMS TO BE MOVED
	POP	R1,CORINC(R1)		; POP ITEM UP ONE K
	SOJG	R0,.-1			; TEST FOR COMPLETION
	MOVEI	R1,CORINC		; UPDATE POINTERS
	ADDM	R1,SYMBOT
	ADDM	R1,SYMPNT
	ADDM	R1,VALPNT
	ADDM	R1,SYMTOP
	ADDM	R1,CR1PNT
	ADDM	R1,CR2PNT
	POP	P,R1			; RESTORE REGISTERS
	POP	P,R0
	RETURN				; EXIT
>;IFE TENEX

	SUBTTL	SYMBOL TABLE HANDLERS

;	   Symbol table entry format:

;	@SYMPNT			Symbol in rad50 format
;				Bit 0 = 1 => symbol is macro name

;	@VALPNT			Left half:	Attribute bits
;				Right half:	Value

;	   Remaining two words contain cross-ref info:

;	@CR1PNT			Left half:	Line # of symbol definition
;				Right half:	Line # of first reference

;	@CR2PNT			Left half:	Line # of second reference
;				Right half:	Link to reference block

;	   0 in any cross-ref field => "none".


MSRCH:	TLOA	R0,MACBIT
SSRCH:					; SYMBOL SEARCH
	 TLZ	R0,MACBIT
	CAMN	R0,M40DOT		; Is this symbol "."?
	 JRST	SSRCH5			;    Yes - It's an exception.

	MOVE	R7,DELTA		; SET OFFSET FOR INDEX
	MOVE	R2,R7
	ASH	R2,-1			; SET INCREMENT
SSRCH1:	CAMGE	R0,@SYMPNT		; ARE WE LOOKING ABOVE SYMBOL?
	JRST	SSRCH2			;  YES, MOVE DOWN
	CAMG	R0,@SYMPNT		; NO, POSSIBLY AT IT?
	 JRST	SSRCH4			;  YES
	TDOA	R7,R2			;  NO, INCREMENT INDEX
SSRCH2:	 SUB	R7,R2			; DECREMENT INDEX
	ASH	R2,-1			; DECREMENT DELTA
	CAIG	R2,1			; Is DELTA too small now?
	 JRST	SSRCH3			;    Yes - No such symbol defined.
	CAMG	R7,SYMLEN		;    No -- Out of bounds?
	 JRST	SSRCH1			;	 No -- Check this entry.
	JRST	SSRCH2			;	 Yes - Move back down.

SSRCH3:	SETZB	R1,R2
	SUBI	R7,2			; Set index to start (not middle!)
	RETURN				; of entry and take not-found exit.

SSRCH5:	MOVE	R1,R5			; "." lookup:  Return PC value.
	TLOA	R1,DEFSYM		; Always mark . as defined.
SSRCH4:	 MOVE	R1,@VALPNT		; FOUND, FETCH VALUE
	LDB	R2,TYPPNT		; SET TYPE POINTER
	JRST	CPOPJ1			; EXIT +1
INSRT:					; INSERT ITEM IN SYMBOL TABLE
	CAMN	R0,M40DOT		; PC?
	JRST	INSRT2			;  YES
	CAMN	R0,@SYMPNT		; IS IT HERE ALREADY?
	JRST	INSRT1			;  YES
	MOVNI	R6,4			; NO, PREPARE TO INSERT
	ADDB	R6,SYMBOT		; DECREMENT POINTER TO BOTTOM OF TABLE
	CAMG	R6,.JBFF		; ARE WE INTRUDING ON THE MACROS?
	CALL	GETCOR			;  YES, GET MORE CORE
	MOVE	R6,SYMBOT
	HRLI	R6,4(R6)		; SET UP BLT
	BLT	R6,@SYMPNT		; MOVE LOWER SYMBOLS DOWN
	CALL	SRCHI			; RE-INITIALIZE THE POINTERS
	ADDI	R7,4			; COMPENSATE FOR SHIFT
	MOVEM	R0,@SYMPNT		; STORE SYMBOL
INSRT1:	MOVEM	R1,@VALPNT		; STORE VALUE
	RETURN

INSRT2:	MOVE	R5,R1			; ".", SET PC
	AND	R5,[PCMASK]		; MAKE SURE ITS CLEAN
	RETURN




;	   RESET CURRENT LOCAL SYMBOL BLOCK DUE TO FINDING
;	   A LABEL DEFINITION OR .CSECT DIRECTIVE, UNLESS
;	   .ENABL LSB HAS BEEN ISSUED TO PROLONG CURRENT BLOCK.


LOCRES:	TLNE	RMODE,LSBFLG		; .ENABL LSB IN EFFECT?
	RETURN				;    YES - DON'T DO ANYTHING.
Locras:	AOS	LSBLOC			;    NO -- INCREMENT BLOCK NUMBER
	MOVEI	R1,^D64			; RESET VALUE OF NEXT LOCAL SYMBOL
	MOVEM	R1,NEXGS		;     TO GENERATE IN A MACRO CALL.
	RETURN				; RETURN


CRFLIN:					; OUTPUT CREF LINE INFO
	TLNN	R15,P1F			; IF PASS 1
	TLNE	R16,CSWBIT!LSTBIT	;  OR CREF NOT REQUESTED
	RETURN				;  EXIT
	TRNE	R16,EXLBIT		; Is this an extension line?
	 RETURN				;  Yes - return now
	TRZE	R16,HDRBIT		; TIME FOR HEADER?
	CALL	HEADER			;  YES
	MOVEI	R2,RUBOUT		; OK, RUBOUT "B"
	CALL	LSTDMP
	MOVEI	R2,"B"
	CALL	LSTDMP
	MOVE	R2,LSTCTL		; Get listing controls
	TRNN	R2,LSEQ			; Use MACN11 sequence numbers?
	 JRST	CRFLI8			; No - let CREF do them

;now output the line number to CREF				[ECL2]

	MOVEI	R2,17			; code for line number		[ECL2]
	CALL	LSTDMP			; output it 			[ECL2]
	SETZ	R2,			; to count digits		[ECL2]
	MOVE	R0,SEQ			; get the line number		[ECL2]
CRFLI5:	IDIVI	R0,^D10			; get a digit			[ECL2]
	TRO	R1,"0"			; make it ASCII			[ECL2]
	PUSH	P,R1			; stack it			[ECL2]
	AOJ	R2,			; count one more		[ECL2]
	JUMPN	R0,CRFLI5		; until quotient=0		[ECL2]
	CALL	LSTDMP			; output r2=#chars in num	[ECL2]
	MOVE	R6,R2			; save count			[ECL2]
CRFLI6:	POP	P,R2			; get a digit			[ECL2]
	CALL	LSTDMP			; output it			[ECL2]
	SOJN	R6,CRFLI6		; each one			[ECL2]
;								[ECL2]
CRFLI8:	MOVSI	R6,-CRFLEN		; SET FOR SCAN
CRFLI1:	SKIPN	CRFNAM(R6)		; END?
	JRST	CRFLI4			;  YES
	MOVE	R2,CRFTYP(R6)		; NO, GET TYPE
	TLNN	R2,-1			; DEFINITION?
	SKIPA	R2,CRFTBL(R2)		; NO
	HLRZ	R2,CRFTBL(R2)		; YES, USE LEFT HALF
	HRLM	R2,0(P)			; SAVE ON STACK
	LDB	R2,[POINT 9,0(P),8]	; GET FIRST CONTROL
	CAIE	R2,			; SKIP IF NULL
	CALL	LSTDMP			; OUTPUT IT
	MOVE	R0,CRFNAM(R6)		; GET THE NAME
	CALL	M40SIX			; CONVERT TO SIXBIT
	PUSH	P,R0			; SAVE A COPY
	MOVEI	R2,1			; SET TO COUNT CHARACTERS
CRFLI2:	LSH	R0,6			; SHIFT ONE CHARACTER
	CAIE	R0,			; ALL FINISHED?
	AOJA	R2,CRFLI2		;  NO, INCREMENT AND LOOP
	CALL	LSTDMP			; YES, OUTPUT CHARACTER COUNT
	POP	P,R3			; RETRIEVE THE NAME
CRFLI3:	SETZ	R2,			; CLEAR HIGH REGISTER
	LSHC	R2,6			; SHIFT NEXT CHARACTER IN
	ADDI	R2,40			; CONVERT TO ASCII
	CALL	LSTDMP			; OUTPUT IT
	JUMPN	R3,CRFLI3		; LOOP IF MORE TO COME
	LDB	R2,[POINT 9,0(P),17]	; FETCH TRAILING CHARACTER
	CAIE	R2,
	CALL	LSTDMP			; OUTPUT IF NON-NULL
CRFLI4:	SETZM	CRFNAM(R6)		; CLEAR NAME
	SETZM	CRFTYP(R6)		;  AND TYPE
	AOBJN	R6,CRFLI1		; TEST FOR MORE
	MOVEI	R2,RUBOUT		; FINISHED, NOW RUBOUT "C"
	CALL	LSTDMP
	MOVEI	R2,"C"
	TRNE	R15,-1			; any errors?			[ECL2]
	 JRST	LSTDMP			; yes, want to list reguardless	[ECL2]
	TLNE	R16,NLISLN		; supress list of this line?	[ECL2]
	 JRST	CRFNL1			; yes, no line number		[ECL2]
	MOVE	R0,LSTCTL		; listing mode			[ECL2]
	TLNE	R16,MEXBIT		; outside of macro expans, or	[ECL2]
	TRNE	R0,LME			; .LIST ME in effect ?		[ECL2]
	 JRST	CRFLI7			; YES				[ECL2]
	TRNE	R0,LMEB			; list meb in effect?		[ECL2]
	SKIPN	PF0			; yes, list iff code was gen'd	[ECL2]
	 JRST	CRFNL1			; don't list			[ECL2]
CRFLI7:	SKIPL	LSTCNT			; no list if list level negative[ECL2]
	SKIPN	BLNKLN			; blank line?			[ECL2]
CRFNL1:	MOVEI	R2,"D"			; yes, don't have cref do line#	[ECL2]
	JRST	LSTDMP			; LIST AND EXIT

CRFTBL:
	PHASE	0
	BYTE	(9)  1, 2, 1, 0
MAOP:!	BYTE	(9)  6, 0, 5, 0
OCOP:!	BYTE	(9)  0, 0, 3, 0
DIOP:!	BYTE	(9)  0, 0, 3, 0
	DEPHASE

SRCHI:					; INITIALIZE FOR SEARCH
	PUSH	P,R1			; STACK WORKING REGISTERS
	PUSH	P,R2
	MOVE	R1,SYMTOP		; GET THE TOP LOCATION
	SUB	R1,SYMBOT		; COMPUTE THE DIFFERENCE
	MOVEM	R1,SYMLEN		; SAVE IT
	MOVEI	R2,1			; SET LOW BIT
	LSH	R2,1			; SHIFT OVER ONE
	TDZ	R1,R2			; CLEAR CORRESPONDING ONE
	JUMPN	R1,.-2			; TEST FOR ALL BITS CLEARED
	MOVEM	R2,DELTA		; END, SAVE LEADING BIT FOR SEARCH OFFSET
	MOVE	R1,SYMBOT		; GET THE BASE
	HRLI	R1,(Z (R7))		; SET INDEX
	MOVEM	R1,SYMPNT		; SET SYMBOL POINTER
	SUBI	R1,1
	MOVEM	R1,VALPNT		; SET VALUE POINTER
	SUBI	R1,1
	MOVEM	R1,CR1PNT		; Set pointer to 1st cross ref word.
	SUBI	R1,1
	MOVEM	R1,CR2PNT		; Set pointer to 2nd cross ref word.
	POP	P,R2			; RESTORE REGISTERS
	POP	P,R1
	RETURN				; EXIT


;		   Enter line number of a symbol definition
;		   in cross ref info within symbol table entry.

CRFDEF:
	TLNN	R15,P1F			; Do this only on pass 2
	TLNE	R16,LSTBIT		; Do we have a listing file?
	 RETURN				; No - don't have to to CREF stuff
	TLNN	R16,CSWBIT		; Use CREF?
	 JRST	CREFDF			; Yes - use old routine
	MOVE	R0,SEQ			; Get current line number.
	HRLM	R0,@CR1PNT		; Set in definition field (left half)
	RETURN				; of 1st CREF word.



;		   Enter line number of a reference
;		   in a symbol's cross ref list.

CRFREF:
	TLNN	R16,LSTBIT		; Have a listing file?
	TLNE	R15,P1F			; Is this pass 2?
	 RETURN				;    No -- Don't bother with ref's.
	CAMN	R0,M40DOT		; Is this symbol "."?
	 RETURN				;    Yes - Don't record its references.

	TLNN	R16,CSWBIT		; Use CREF or MACN11 cref?
	 JRST	CREFRF			;  Wants to run CREF later
	PUSH	P,R1			; Save volatile registers.
	PUSH	P,R2

	MOVE	R1,@CR1PNT		; Retrieve 1st cref word.
	TRNE	R1,-1			; Is 1st reference slot empty?
	  JRST	CREF1			;    No -- Check second.
	HRR	R1,SEQ			;    Yes - Set it to
	MOVEM	R1,@CR1PNT		;	   current line number.
	JRST	CRET			; Return.

CREF1:	MOVE	R1,@CR2PNT		; Retrieve 2nd cref word.
	TLNE	R1,-1			; Is 2nd ref slot empty?
	  JRST	CREF2			;    No -- Look for 1st ref block.
	HRL	R1,SEQ			; Yes - Set it to current line #.
	MOVEM	R1,@CR2PNT
	JRST	CRET			; Return.

CREF2:	HRRZ	R2,R1			; Set R2 = addr(1st cref block).
	JUMPN	R2,CREF3		;    Proceed if one exists.

;	   Symbol table entry doesn't have any reference blocks linked
;	   to it.  Allocate the first one and set last half word of
;	   cref info in the symtab entry to point to it.

	CALL	GBLOCK			; Get a block for reference info.
	HRR	R1,R2			; Set new block loc in symtab link.
	MOVEM	R1,@CR2PNT
	JRST	CREF9			; Set first entry in new block.

CREF3:	HRLI	R2,-<WPB-1>		; Scan all but last word of ref block.

CREF4:	MOVE	R1,0(R2)		; Get next word.
	TLNE	R1,-1			; Is 1st (left) slot open?
	  JRST	CREF5			;    No -- Try right half.
	HRL	R1,SEQ			;    Yes - Set it.
	MOVEM	R1,0(R2)
	JRST	CRET			; Return.

CREF5:	TRNE	R1,-1			; Is 2nd (right) slot open?
	  JRST	CREF6			;    No -- Try next word.
	HRR	R1,SEQ			;    Yes - Set it.
	MOVEM	R1,0(R2)
	JRST	CRET			; Return.

CREF6:	AOBJN	R2,CREF4		; Advance to next word.

;	   This block's full:  Get next.

	MOVE	R1,R2			; Save current block address in R1.
	SKIPE	R2,0(R2)		; Get loc of next block, if any.
	  JRST	CREF3			;    .. Got one:  Search it.
	CALL	GBLOCK			;    .. None:  Get a new one.
	HRRM	R2,0(R1)		; Set link to new block in old one.

CREF9:	MOVE	R1,SEQ			; Set first entry in a new block
	HRLM	R1,0(R2)		; to current line number.
CRET:	POP	P,R2			; Restore volatile registers.
	POP	P,R1
	RETURN				; Return.

CREFDF:	TDZA	R3,R3			; Set for definition flag
CREFRF:	 SETO	R3,			; Set reference flag
	TLNE	R15,P1F			; Pass 1?
	 RETURN				; Yes - do nothing
	TLNE	R0,200000		; local symbol ?		[ECL2]
	 RETURN				; yes, too hard to cref		[ECL2]
	PUSH	P,R1			; GET WORKING REGISTERS
	PUSH	P,R2
	PUSH	P,R4
	LDB	R2,TYPPNT		; ISOLATE SYMBOL TYPE
	MOVSI	R1,-CRFLEN		; SET FOR SCAN
CRFRE1:	SKIPN	CRFNAM(R1)		; EMPTY SLOT?
	JRST	CRFRE2			;  YES
	HRRZ	R4,CRFTYP(R1)		; NO, GET TYPE
	CAMN	R0,CRFNAM(R1)		; TEST NAME
	CAME	R4,R2			;  AND TYPE
	AOBJN	R1,CRFRE1		;  NOT A MATCH
	JUMPG	R1,CRFRE3		; EXIT IF OUT OF ROOM
CRFRE2:	MOVEM	R0,CRFNAM(R1)		; STORE NAME
	HRRM	R2,CRFTYP(R1)		;  AND TYPE
	CAIN	R3,			; DEFINITION?
	HRROS	CRFTYP(R1)		;  YES, SET LEFT HALF
CRFRE3:	POP	P,R4			; RESTORE REGISTERS
	POP	P,R2
	POP	P,R1
	RETURN
SYMTB:					; LIST THE SYMBOL TABLE
	SETZ	R7,			; Set initial table index = 0.
	TLO	R16,SBTBIT		; Indicate subtitle present.
	TRO	R16,HDRBIT		; Force a page skip.
	MOVE	R1,[ POINT 7,SUBMSG, ]	; Set subhead string.
	TLNN	R16,CSWBIT		; Does he want cref table?
	 JRST	SYMTBX			; No - plain symbol table
	MOVE	R2,[ POINT 7,[ ASCIZ /Cross-reference Table/ ], ]
SYMTB0:	ILDB	R3,R2			; Get a byte from the string
	JUMPE	R3,SYMTB1		; Exit if no more
	IDPB	R3,R1			; Stow the byte away
	JRST	SYMTB0			;  and keep looping
SYMTB1:	IDPB	R3,R1			; Tack on the null byte
	MOVE	R10,[ POINT 7,[ ASCIZ /Symbol	Defined	Value	References/ ], ]
	SKIPE	SECNAM+2		; Any named sections?
	 MOVE	R10,[ POINT 7,[ ASCIZ /Symbol	Defined	Value		References/ ], ]
	CALL	LSTASC			; List the header line
	CALL	LSTCR			; List a CR

	MOVE	R0,SEQ			; Check on number of significant
	CALL	NSIG			; digits in last sequence number.
	MOVEM	R4,SEQND		; Save to compute line # padding count.

; Calculate number of fields that can be printed on a listing line

	MOVEI	R2,^D100		; # of positions left on LPT type line
	HRRZ	R0,LSTCTL		; Get listing control
	TRNE	R0,LTTM			; TTY output mode?
	 MOVEI	R2,^D47			; Yes - load # of positions left
	IDIVI	R2,2(R4)		; No - calculate # of fileds; account
					;      for 2 spaces as separators
	SKIPE	SECNAM+2		; Any named sections?
	 SUBI	R2,1			; Yes - name will be printed
	MOVEM	R2,CRFFLD		; No - save field count


SYMTBE:	CALL	LSTCR			; Terminate current line.
	CALL	GETSTE			; Get next symbol table entry.
	 JRST	SYMPPC			;  No more - print PC and quit
	TLNE	R0,200000		; Local symbol?
	 JRST	SYMPPC			;  Yes - print PC and quit

	CALL	LSTSYM			; List the symbol itself.

	CALL	LSTTAB			; Tab to definition field.
	HLRZ	R0,@CR1PNT		; Get definition line number.
	CAIE	R0,			;    0 => undefined symbol.
	 CALL	LSTLN			; List definition line #.

	CALL	LSTTAB			; Tab to value field.
	CALL	LSTVAL			; List its value
	JUMPN	R2,SYMTB4		; Jump if section name printed
	SKIPE	SECNAM+2		; None printed but are there any in
					;  the entire module?
	 CALL	LSTTAB			; Yes - account for section name
SYMTB4:
	MOVE	R10,CRFFLD		; Load field count

;	   List references to this symbol.

	HRRZ	R0,@CR1PNT		; Get first reference.
	JUMPE	R0,SYMTBE		;    0 => no ref's:  Done with symbol.
	CALL	LSTTAB			; Tab to first ref field.
	HRRZ	R0,@CR1PNT		; Retrieve 1st ref line number.
	CALL	LSTLN			; List it.

	HLRZ	R0,@CR2PNT		; Check second reference.
	JUMPE	R0,SYMTBE		;    0 => No more for this symbol.
	CALL	LST2SP			; Separate with spaces
	HLRZ	R0,@CR2PNT		; Restore ref line number.
	CALL	LSTLN			; List it.

	HRRZ	R0,@CR2PNT		; Get link to first ref block.
	JUMPE	R0,SYMTBE		;    None => done with symbol.
	SUBI	R10,1			; Account for 1 ref on line.


SYMTB2:	MOVE	R11,R0			; Set pointer & counter
	HRLI	R11,-<WPB-1>		; to scan ref block.

SYMTB3:	HLRZ	R0,0(R11)		; Check left half of current word.
	JUMPE	R0,SYMTBE		;    Empty => no more for this symbol.
	SOJLE	R10,[ CALL SYMRLE	; If no more room then start a new line
		      JRST .+2	]
	CALL	LST2SP			; Separate with spaces
	HLRZ	R0,0(R11)		; Retrieve current reference.
	CALL	LSTLN			; List it.

	HRRZ	R0,0(R11)		; Repeat same procedure
	JUMPE	R0,SYMTBE		; for reference in right half
	SOJLE	R10,[ CALL SYMRLE	; If no more room then start a new line
		      JRST .+2	]
	CALL	LST2SP			; Separate with spaces
	HRRZ	R0,0(R11)
	CALL	LSTLN

	AOBJN	R11,SYMTB3		; Advance to next word.

;	   Block's full:  Find next block, if any.

	MOVE	R0,0(R11)		; Get link to next ref block.
	JUMPN	R0,SYMTB3		;    One exists:  Scan it.
	JRST	SYMTBE			;    No more:  End for this symbol.


;	   Filled a line with references & there's another to print.

SYMRLE:	CALL	LSTCR			; Terminate current line.
	CALL	LSTTAB			; Output tabs to get over to 1st
	CALL	LSTTAB			;  reference field
	CALL	LSTTAB
	SKIPE	SECNAM+2		; Section names?
	 CALL	LSTTAB			; Yes - move over one more
	MOVE	R10,CRFFLD		; No - load field count
	RETURN				; Back to caller



GETSTE:					; GET SYMBOL TABLE ENTRY
	ADDI	R7,4			; MOVE UP four
	CAML	R7,SYMLEN		; TEST FOR END
	RETURN				;  YES, EXIT
	MOVE	R0,@SYMPNT
	MOVE	R1,@VALPNT
	LDB	R2,TYPPNT
	JUMPN	R2,GETSTE		; BYPASS IF OP
	JRST	CPOPJ1			; OK, PERFORM SKIP-RETURN

LSTVAL:					; List symbol value
	TLNN	R1,DEFSYM		; Defined?
	 JRST	LSTVUD			; No - output special stuff
	MOVE	R10,R1			; Copy symbol value into R10
	CALL	PRNTWD			; Yes - output its value
	LDB	R10,SUBPNT		; Get sector number
	CAILE	R10,1			; Special?
	 JRST	LSTSNM			; No - output the name
	TLNN	R1,GLBSYM		; Global symbol?
	 TLNE	R1,(PFMASK)		;  or relocatable?
	  JRST	LSTVA1			; Yes - already have a character
	MOVEI	R2,"%"			; Assume its a register
	TLNN	R1,REGSYM		; Is it?
	 MOVEI	R2,SPACE		; No - pad with a space
	CALL	LSTOUT			; Yes - append with "%" or " "
LSTVA1:	SETZ	R2,			; No - return with sector name flag
	RETURN				; Back to caller

LSTSNM:
	CALL	LSTSP			; Separator
	MOVE	R0,SECNAM(R10)		; Get name
	CALL	LSTSYM			;  and print it
	SETO	R2,			; Set sector name flag
	RETURN				; Back with flag set

LSTVUD:					; List undefined value
	MOVE	R0,[ '******' ]		; Indicate unknown value
	CALL	LSTSIX			; Print it
	MOVEI	R2,"G"			; Assume its global
	TLNN	R1,GLBSYM		; Is it really global?
	 MOVEI	R2,"U"			; No - mark as undefined
	CALL	LSTOUT			; Print it
	SETZ	R2,			; Set no name printed flag
	RETURN				; Back to caller
;	   Compute number of significant decimal digits for
;	   the number in R0.

;	   At return R4 = digit count, R0 = 0.

NSIG:	SETZ	R4,			; Initial digit count = 0.

NSIG1:	AOJ	R4,			; Increment digit count.
	IDIVI	R0,^D10			; Divide # or last quotient by 10.
	JUMPN	R0,NSIG1		; Repeat if quotient > 0.

	RETURN




;	   List a "middle-adjusted" line number:
;	   This means supplying minimal padding on left to align
;	   rightmost digits of each line number with rightmost
;	   digit of largest line number.

LSTLN:	PUSH	P,R1			; Save symbol value
	PUSH	P,R0			; Save number to be listed.
	CALL	NSIG			; Get # of significant digits in it.

	SUB	R4,SEQND		; Padding count =
	JUMPE	R4,LSTLN2		; # digits in largest line number
	MOVNS	R4			; - # digits in this line number.
	MOVEI	R2," "			; Load padding byte for output calls.

LSTLN1:	CALL	LSTOUT			; List a leading blank.
	SOJG	R4,LSTLN1		; Iterate to suit padding count.

LSTLN2:	POP	P,R0			; Restore line number to output.
	CALL	LSTLNU			; List it
	POP	P,R1			; Restore symbol value
	RETURN				; Back to caller
; Print the old-style symbol table.  Since this code is executed when the
;  user requests a file to be CREF'd then a cross-reference table would be
;  redundant.


SYMTBX:
	MOVE	R2,[ POINT 7,[ ASCIZ /Symbol table/ ], ]
SYMTX0:	ILDB	R3,R2			; Get a byte from the string
	JUMPE	R3,SYMTX1		; Exit if no more
	IDPB	R3,R1			; Stow the byte away
	JRST	SYMTX0			;  and keep looping
SYMTX1:	IDPB	R3,R1			; Tack on the null byte
SYMBP1:	MOVEI	R6,SPL			; SET "SYMBOLS PER LINE"
	HRRZ	R0,LSTCTL		; TTY?
	TRNE	R0,LTTM
	MOVEI	R6,SPLTTY		;  YES, REDUCE
SYMBP2:	CALL	GETSTE			; GET THE NEXT SYMBOL TABLE ENTRY
	 JRST	SYMPPC			;  END
	TLNE	R0,200000		; Local symbol?
	 JRST	SYMPPC			; Yes - print PC and exit
	CALL	LSTSTE			; LIST SYMBOL TABLE ENTRY
	SOJG	R6,SYMBP2		; TEST FOR MORE ITEMS ON LINE
	CALL	LSTCR
	JRST	SYMBP1			; START NEW LINE

; Print the PC in the current CSECT and print the lengths of all the CSECTs

SYMPPC:
	CALL	LSTCR			; New line first
	MOVE	R0,M40DOT
	MOVE	R1,R5			; PRINT PC
	TLO	R1,DEFSYM
	CALL	LSTSTE
	CALL	LSTCR			; New line
	CALL	LSTCR
	MOVE	R7,[XWD -^D<256-2>,1]	; Start with blank CSECT
	MOVE	R0,[ GENM40 ., ,B,L,K,. ] ; Use . BLK. as the name
	JRST	SYMPP1			; Jump into loop

SYMBP4:	SKIPN	SECNAM(R7)
	 JRST	SYMTEX			; Exit
	MOVE	R0,SECNAM(R7)
SYMPP1:	CALL	LSTSYM			; List the sector name
	CALL	LSTTAB			; Tab over
	HLRZ	R10,SECBAS(R7)
	CALL	PRNTWD			; List the length of it
	CALL	LSTCR
	AOBJN	R7,SYMBP4
SYMTEX:	TLZ	R16,SBTBIT		; Turn off the subtitle
	RETURN

LSTSTE:					; LIST SYMBOL TABLE ENTRY
	CALL	LSTSYM			; LIST IT
	CALL	LSTSP
	MOVEI	R2,"="
	TLNE	R1,LBLSYM
	MOVEI	R2,SPACE
	CALL	LSTOUT
	CALL	LSTSP			; Separator
	CALL	LSTVAL			; List the value
	JRST	LSTTAB			; Output tab and exit
;	CONVERTS 6 SIXBIT CHARACTERS IN R0 TO 6 RAD50 CHARACTERS
;	IN R0 AS 3 CHARCTERS IN A 16 BIT WORD IN EACH HALFWORD.

SIXM40:					; SIXBIT TO MOD40
	PUSH	P,R1
	PUSH	P,R2
	PUSH	P,R3			; STACK REGISTERS
	SETZ	R1,
	MOVSI	R3,(POINT 6,R0)
SIXM41:	ILDB	R2,R3			; GET A CHARACTER
	HLRZ	R2,RADTBL(R2)		; MAP
	IMULI	R1,50
	ADD	R1,R2
	TLNE	R3,770000		; FINISHED?
	 JRST	SIXM41			;  NO
	IDIVI	R1,50*50*50		; YES, SPLIT INTO HALVES
	HRLZ	R0,R1			; HIGH ORDER
	HRR	R0,R2			;  AND LOW ORDER
	POP	P,R3			; RESTORE REGISTERS
	POP	P,R2
	POP	P,R1
	RETURN

;	INVERSE OF SIXM40

M40SIX:					; MOD40 TO SIXBIT
	PUSH	P,R1
	PUSH	P,R2
	LDB	R1,[POINT 16,R0,17]
	IMULI	R1,50*50*50		; MERGE
	HRRZS	R0
	ADD	R0,R1
	SETZ	R2,			; ACCUMULATOR
M40SI1:	IDIVI	R0,50
	HRRZ	R1,RADTBL(R1)		; MAP
	LSHC	R1,-6			; MOVE INTO COLLECTOR
	JUMPN	R0,M40SI1		; TEST FOR END
	MOVE	R0,R2
	POP	P,R2
	POP	P,R1
	RETURN

IFN TENEX,<
; Status interrupt routine...

STATUS:
	PUSH	P,R1
	PUSH	P,R2
	PUSH	P,R3			; Save a few registers
	HRROI	R1,[ ASCIZ / Pass / ]
	PSOUT				; Print which pass its on
	MOVEI	R2,2			; Assume pass 2
	TLNE	R15,P1F			; Is it?
	MOVEI	R2,1			; No - set to pass 1
	MOVEI	R1,101			; Primary output
	MOVEI	R3,^D10			; Decimal
	NOUT				; Print it
	 JFCL
	HRROI	R2,[ ASCIZ / - File: / ]
	SETZ	R3,			; ASCIZ string
	SOUT
	MOVE	R2,SRCJFN		; Load source JFN
	JFNS				; Print it
	HRROI	R2,[ ASCIZ / Line: / ]
	SOUT				; Print line number now
	MOVE	R2,SEQ			; Get line number
	MOVEI	R3,^D10			; Decimal
	NOUT				; Print it
	 JFCL
	MOVEI	R2,CRR			; New line
	BOUT
	MOVEI	R2,LF
	BOUT
	POP	P,R3			; Restore registers
	POP	P,R2
	POP	P,R1
	DEBRK				; Back to interrupted program
	 0
>;IFN TENEX

RADTBL:
	XWD	<$==0>,	0
	XWD	0,		"A"-40
	XWD	0,		"B"-40
	XWD	0,		"C"-40
	XWD	<$$==33>,	"D"-40
	XWD	0,		"E"-40
	XWD	0,		"F"-40
	XWD	0,		"G"-40

	XWD	0,		"H"-40
	XWD	0,		"I"-40
	XWD	0,		"J"-40
	XWD	0,		"K"-40
	XWD	0,		"L"-40
	XWD	0,		"M"-40
	XWD	<$.==34>,	"N"-40
	XWD	0,		"O"-40

	XWD	<$0==36>,	"P"-40
	XWD	<$1==37>,	"Q"-40
	XWD	<$2==40>,	"R"-40
	XWD	<$3==41>,	"S"-40
	XWD	<$4==42>,	"T"-40
	XWD	<$5==43>,	"U"-40
	XWD	<$6==44>,	"V"-40
	XWD	<$7==45>,	"W"-40

	XWD	<$8==46>,	"X"-40
	XWD	<$9==47>,	"Y"-40
	XWD	0,		"Z"-40
	XWD	0,		"$"-40
	XWD	0,		"."-40
	XWD	0,		0
	XWD	0,		"0"-40
	XWD	0,		"1"-40

	XWD	0,		"2"-40
	XWD	<$A==1>,	"3"-40
	XWD	<$B==2>,	"4"-40
	XWD	<$C==3>,	"5"-40
	XWD	<$D==4>,	"6"-40
	XWD	<$E==5>,	"7"-40
	XWD	<$F==6>,	"8"-40
	XWD	<$G==7>,	"9"-40

	XWD	<$H==10>,	0
	XWD	<$I==11>,	0
	XWD	<$J==12>,	0
	XWD	<$K==13>,	0
	XWD	<$L==14>,	0
	XWD	<$M==15>,	0
	XWD	<$N==16>,	0
	XWD	<$O==17>,	0

	XWD	<$P==20>,	0
	XWD	<$Q==21>,	0
	XWD	<$R==22>,	0
	XWD	<$S==23>,	0
	XWD	<$T==24>,	0
	XWD	<$U==25>,	0
	XWD	<$V==26>,	0
	XWD	<$W==27>,	0

	XWD	<$X==30>,	0
	XWD	<$Y==31>,	0
	XWD	<$Z==32>,	0
	XWD	0,		0
	XWD	0,		0
	XWD	0,		0
	XWD	0,		0
	XWD	0,		0
OSRCH:					; OP TABLE SEARCH
	TLZ	R0,MACBIT		; CLEAR POSSIBLE MACRO BIT
	MOVEI	R2,1B^L<OPTTOP-OPTBOT>	; SET UP OFFSET AND DELTA
	MOVEI	R1,1B^L<OPTTOP-OPTBOT>/2
OSRCH1:	CAMN	R0,OPTBOT-2(R2)		; ARE WE LOOKING AT IT?
	 JRST	OSRCH3			;  YES
	CAML	R0,OPTBOT-2(R2)		; TEST FOR DIRECTION OF NEXT MOVE
	 TDOA	R2,R1			; ADD
OSRCH2:	  SUB	R2,R1			; SUBTRACT
	ASH	R1,-1			; HALVE DELTA
	JUMPE	R1,OSRCH4		; EXIT IF END
	CAILE	R2,OPTTOP-OPTBOT	; YES, ARE WE OUTOF BOUNDS?
	 JRST	OSRCH2			; YES, MOVE DOWN
	JRST	OSRCH1			; NO, TRY AGAIN

OSRCH3:	MOVE	R1,OPTBOT-1(R2)		; FOUND, PLACE VALUE IN R2
	LDB	R2,TYPPNT
	TLNN	R15,P1F			; IF PASS 1
	CAIE	R2,OCOP			;  OR PSEUDO-OP
	JRST	CPOPJ1			; EXIT
	PUSH	P,R1			; STACK RESULT
IFN MD20SW,<
	TLNE	R1,776000		; Is it greater than model 20?
	 TRO	R15,ERRZ		; Yes - flag error
>;IFN MD20SW
	MOVSI	R2,-8			; SET FOR EIGHT BITS
	TLNE	R1,(1B0)		; THIS BIT SET?
	AOS	OPCCNT(R2)		;  YES
	LSH	R1,1			; SHIFT BITS
	AOBJN	R2,.-3			; TEST FOR END
	POP	P,R1			; YES, RESTORE RESULT
	LDB	R2,TYPPNT
	JRST	CPOPJ1

OSRCH4:	SETZB	R1,R2
	RETURN

TYPOFF==	^D17			; PACKING PARAMETERS
SUBOFF==	^D15
MODOFF==	^D7

BC1==	1
BC2==	2

DEFSYM==	400000			; DEFINED SYMBOL
LBLSYM==	200000			; LABEL
REGSYM==	100000			; REGISTER
GLBSYM==	040000			; GLOBAL
MDFSYM==	020000			; MULTIPLY-DEFINED FLAG
HFKSYM==	010000			; Half killed symbol

TYPPNT:	POINT	2,R1,TYPOFF		; TYPE POINTER
SUBPNT:	POINT	8,R1,SUBOFF		; SUB-TYPE POINTER
CCSPNT:	POINT	8,R5,SUBOFF		; CURRENT CSECT POINTER
MODPNT:	POINT	8,R1,MODOFF

MOD45==	400000				; Model 45 instructions
MODEIS==200000				; Extented instruction set instruction
MOD40==	100000				; Model 40 instructions
MODMMG==040000				; Memory management instructions
MOD45F==020000				; Model 45's floating point instructions
MOD40F==010000				; Model 40's floating point instructions
MODLSI==004000				; LSI-11 instructions

MACBIT== 400000

MDMASK== 377B<MODOFF>
PFMASK== 377B<SUBOFF>
ADMASK== 177777
PCMASK== PFMASK!ADMASK

M40DOT:	GENM40	.

	SUBTTL	PREDEFINED SYMBOLS (PROTOTYPE SYMBOL TABLE)

	DEFINE	PERSYM	(A,B,C,D,E,F,FLAGS,VALUE)
<
	XWD	0
	XWD	0
	XWD	FLAGS,VALUE
	GENM40	A,B,C,D,E,F
>;PERSYM

PERMST:
	XWD	400000,000000		; TABLE BOTTOM MARKER

	PERSYM	A,C,0, , , ,	DEFSYM!REGSYM!HFKSYM, 0 ; AC0

	PERSYM	A,C,1, , , ,	DEFSYM!REGSYM!HFKSYM, 1	; AC1

	PERSYM	A,C,2, , , ,	DEFSYM!REGSYM!HFKSYM, 2	; AC2

	PERSYM	A,C,3, , , ,	DEFSYM!REGSYM!HFKSYM, 3	; AC3

	PERSYM	A,C,4, , , ,	DEFSYM!REGSYM!HFKSYM, 4	; AC4

	PERSYM	A,C,5, , , ,	DEFSYM!REGSYM!HFKSYM, 5	; AC5

	PERSYM	P,C, , , , , 	DEFSYM!REGSYM, 7	; PC

	PERSYM	R,0, , , , , 	DEFSYM!REGSYM, 0	; R0

	PERSYM	R,1, , , , , 	DEFSYM!REGSYM, 1	; R1

	PERSYM	R,2, , , , , 	DEFSYM!REGSYM, 2	; R2

	PERSYM	R,3, , , , , 	DEFSYM!REGSYM, 3	; R3

	PERSYM	R,4, , , , , 	DEFSYM!REGSYM, 4	; R4

	PERSYM	R,5, , , , , 	DEFSYM!REGSYM, 5	; R5

	PERSYM	R,6, , , , , 	DEFSYM!REGSYM, 6	; R6

	PERSYM	R,7, , , , , 	DEFSYM!REGSYM, 7	; R7

	PERSYM	S,P, , , , , 	DEFSYM!REGSYM, 6	; SP

	PERSYM	.,M,A,C,N,.,	DEFSYM!HFKSYM, VERMAJ	; .MACN.

	XWD	0			; \
	XWD	0			;  \	end-of-table
	XWD	0			;  /	   marker
	XWD	377777,777777		; /

PSLEN=	.-PERMST-1			; LENGTH OF PREDEFINED SYMBOLS
	SUBTTL	OP CODE TABLE

	DEFINE	OPCDEF	(A,B,C,D,E,F,MOD,CLASS,VALUE)
<
	GENM40	A,B,C,D,E,F
	XWD	MOD!<CLASS>B33!OCOP,VALUE
>;OPCDEF

	DEFINE	DIRDEF	(A,B,C,D,E,F,ADDRESS)
<
	GENM40	A,B,C,D,E,F
IFDEF  ADDRESS,< XWD DIOP,ADDRESS >
IFNDEF ADDRESS,< XWD DIOP,NHY >
>;DIRDEF

NHY:	TRO	R15,ERRQ		;NOT HERE YET
	RETURN	

OPTBOT:					; OP TABLE BOTTOM

	OPCDEF	A,B,S,D, , ,	MOD45F,	OPCL1,	170600

	OPCDEF	A,B,S,F, , ,	MOD45F,	OPCL1,	170600

	OPCDEF	A,D,C, , , ,	    0,	OPCL1,	005500

	OPCDEF	A,D,C,B, , ,	    0,	OPCL1,	105500

	OPCDEF	A,D,D, , , ,	    0,	OPCL2,	060000

	OPCDEF	A,D,D,D, , ,	MOD45F,	OPCL11,	172000

	OPCDEF	A,D,D,F, , ,	MOD45F,	OPCL11,	172000

	OPCDEF	A,S,H, , , ,	MODEIS,	OPCL9,	072000

	OPCDEF	A,S,H,C, , ,	MODEIS,	OPCL9,	073000

	OPCDEF	A,S,L, , , ,	    0,	OPCL1,	006300

	OPCDEF	A,S,L,B, , ,	    0,	OPCL1,	106300

	OPCDEF	A,S,R, , , ,	    0,	OPCL1,	006200

	OPCDEF	A,S,R,B, , ,	    0,	OPCL1,	106200

	OPCDEF	B,C,C, , , ,	    0,	OPCL4,	103000

	OPCDEF	B,C,S, , , ,	    0,	OPCL4,	103400

	OPCDEF	B,E,Q, , , ,	    0,	OPCL4,	001400

	OPCDEF	B,G,E, , , ,	    0,	OPCL4,	002000

	OPCDEF	B,G,T, , , ,	    0,	OPCL4,	003000

	OPCDEF	B,H,I, , , ,	    0,	OPCL4,	101000

	OPCDEF	B,H,I,S, , ,	    0,	OPCL4,	103000

	OPCDEF	B,I,C, , , ,	    0,	OPCL2,	040000

	OPCDEF	B,I,C,B, , ,	    0,	OPCL2,	140000

	OPCDEF	B,I,S, , , ,	    0,	OPCL2,	050000

	OPCDEF	B,I,S,B, , ,	    0,	OPCL2,	150000

	OPCDEF	B,I,T, , , ,	    0,	OPCL2,	030000

	OPCDEF	B,I,T,B, , ,	    0,	OPCL2,	130000

	OPCDEF	B,L,E, , , ,	    0,	OPCL4,	003400

	OPCDEF	B,L,O, , , ,	    0,	OPCL4,	103400

	OPCDEF	B,L,O,S, , ,	    0,	OPCL4,	101400

	OPCDEF	B,L,T, , , ,	    0,	OPCL4,	002400

	OPCDEF	B,M,I, , , ,	    0,	OPCL4,	100400

	OPCDEF	B,N,E, , , ,	    0,	OPCL4,	001000

	OPCDEF	B,P,L, , , ,	    0,	OPCL4,	100000

	OPCDEF	B,P,T, , , ,	    0,	OPCL0,	000003

	OPCDEF	B,R, , , , ,	    0,	OPCL4,	000400

	OPCDEF	B,V,C, , , ,	    0,	OPCL4,	102000

	OPCDEF	B,V,S, , , ,	    0,	OPCL4,	102400

	OPCDEF	C,C,C, , , ,	    0,	OPCL0,	000257

	OPCDEF	C,F,C,C, , ,	MOD45F,	OPCL0,	170000

	OPCDEF	C,L,C, , , ,	    0,	OPCL0,	000241

	OPCDEF	C,L,N, , , ,	    0,	OPCL0,	000250

	OPCDEF	C,L,R, , , ,	    0,	OPCL1,	005000

	OPCDEF	C,L,R,B, , ,	    0,	OPCL1,	105000

	OPCDEF	C,L,R,D, , ,	MOD45F,	OPCL1,	170400

	OPCDEF	C,L,R,F, , ,	MOD45F,	OPCL1,	170400

	OPCDEF	C,L,V, , , ,	    0,	OPCL0,	000242

	OPCDEF	C,L,Z, , , ,	    0,	OPCL0,	000244

	OPCDEF	C,M,P, , , ,	    0,	OPCL2,	020000

	OPCDEF	C,M,P,B, , ,	    0,	OPCL2,	120000

	OPCDEF	C,M,P,D, , ,	MOD45F,	OPCL11,	173400

	OPCDEF	C,M,P,F, , ,	MOD45F,	OPCL11,	173400

	OPCDEF	C,N,Z, , , ,	    0,	OPCL0,	000254

	OPCDEF	C,O,M, , , ,	    0,	OPCL1,	005100

	OPCDEF	C,O,M,B, , ,	    0,	OPCL1,	105100

	OPCDEF	D,E,C, , , ,	    0,	OPCL1,	005300

	OPCDEF	D,E,C,B, , ,	    0,	OPCL1,	105300

	OPCDEF	D,I,V, , , ,	MODEIS,	OPCL7,	071000

	OPCDEF	D,I,V,D, , ,	MOD45F,	OPCL11,	174400

	OPCDEF	D,I,V,F, , ,	MOD45F,	OPCL11,	174400

	OPCDEF	E,M,T, , , ,	    0,	OPCL6,	104000

	OPCDEF	F,A,D,D, , ,	MOD40F,	OPCL3,	075000

	OPCDEF	F,D,I,V, , ,	MOD40F,	OPCL3,	075030

	OPCDEF	F,M,U,L, , ,	MOD40F,	OPCL3,	075020

	OPCDEF	F,S,U,B, , ,	MOD40F,	OPCL3,	075010

	OPCDEF	H,A,L,T, , ,	    0,	OPCL0,	000000

	OPCDEF	I,N,C, , , ,	    0,	OPCL1,	005200

	OPCDEF	I,N,C,B, , ,	    0,	OPCL1,	105200

	OPCDEF	I,O,T, , , ,	    0,	OPCL0,	000004

	OPCDEF	J,M,P, , , ,	    0,	OPCL1,	000100

	OPCDEF	J,S,R, , , ,	    0,	OPCL5,	004000

	OPCDEF	L,D,C,D,F, ,	MOD45F,	OPCL11,	177400

	OPCDEF	L,D,C,F,D, ,	MOD45F,	OPCL11,	177400

	OPCDEF	L,D,C,I,D, ,	MOD45F,	OPCL14,	177000

	OPCDEF	L,D,C,I,F, ,	MOD45F,	OPCL14,	177000

	OPCDEF	L,D,C,L,D, ,	MOD45F,	OPCL14,	177000

	OPCDEF	L,D,C,L,F, ,	MOD45F,	OPCL14,	177000

	OPCDEF	L,D,D, , , ,	MOD45F,	OPCL11,	172400

	OPCDEF	L,D,E,X,P, ,	MOD45F,	OPCL14,	176400

	OPCDEF	L,D,F, , , ,	MOD45F,	OPCL11,	172400

	OPCDEF	L,D,F,P,S, ,	MOD45F,	OPCL1,	170100

	OPCDEF	L,D,S,C, , ,	MOD45F,	OPCL0,	170004

	OPCDEF	L,D,U,B, , ,	MOD45F,	OPCL0,	170003

	OPCDEF	M,A,R,K, , ,	MOD40,	OPCL10,	006400

	OPCDEF	M,F,P,D, , ,	MOD45,	OPCL1,	106500

	OPCDEF	M,F,P,I, , ,	MODMMG,	OPCL1,	006500

	OPCDEF	M,F,P,S, , ,	MODLSI,	OPCL1,	106700

	OPCDEF	M,O,D,D, , ,	MOD45F,	OPCL11,	171400

	OPCDEF	M,O,D,F, , ,	MOD45F,	OPCL11,	171400

	OPCDEF	M,O,V, , , ,	    0,	OPCL2,	010000

	OPCDEF	M,O,V,B, , ,	    0,	OPCL2,	110000

	OPCDEF	M,T,P,D, , ,	MOD45,	OPCL1,	106600

	OPCDEF	M,T,P,I, , ,	MODMMG,	OPCL1,	006600

	OPCDEF	M,T,P,S, , ,	MODLSI,	OPCL1,	106400

	OPCDEF	M,U,L, , , ,	MODEIS,	OPCL7,	070000

	OPCDEF	M,U,L,D, , ,	MOD45F,	OPCL11,	171000

	OPCDEF	M,U,L,F, , ,	MOD45F,	OPCL11,	171000

	OPCDEF	N,E,G, , , ,	    0,	OPCL1,	005400

	OPCDEF	N,E,G,B, , ,	    0,	OPCL1,	105400

	OPCDEF	N,E,G,D, , ,	    0,	OPCL1,	170700

	OPCDEF	N,E,G,F, , ,	    0,	OPCL1,	170700

	OPCDEF	N,O,P, , , ,	    0,	OPCL0,	000240

	OPCDEF	R,E,S,E,T, ,	    0,	OPCL0,	000005

	OPCDEF	R,O,L, , , ,	    0,	OPCL1,	006100

	OPCDEF	R,O,L,B, , ,	    0,	OPCL1,	106100

	OPCDEF	R,O,R, , , ,	    0,	OPCL1,	006000

	OPCDEF	R,O,R,B, , ,	    0,	OPCL1,	106000

	OPCDEF	R,T,I, , , ,	    0,	OPCL0,	000002

	OPCDEF	R,T,S, , , ,	    0,	OPCL3,	000200

	OPCDEF	R,T,T, , , ,	MOD40,	OPCL0,	000006

	OPCDEF	S,B,C, , , ,	    0,	OPCL1,	005600

	OPCDEF	S,B,C,B, , ,	    0,	OPCL1,	105600

	OPCDEF	S,C,C, , , ,	    0,	OPCL0,	000277

	OPCDEF	S,E,C, , , ,	    0,	OPCL0,	000261

	OPCDEF	S,E,N, , , ,	    0,	OPCL0,	000270

	OPCDEF	S,E,T,D, , ,	MOD45F,	OPCL0,	170011

	OPCDEF	S,E,T,F, , ,	MOD45F,	OPCL0,	170001

	OPCDEF	S,E,T,I, , ,	MOD45F,	OPCL0,	170002

	OPCDEF	S,E,T,L, , ,	MOD45F,	OPCL0,	170012

	OPCDEF	S,E,V, , , ,	    0,	OPCL0,	000262

	OPCDEF	S,E,X, , , ,	MOD40,	OPCL1,	006700

	OPCDEF	S,E,Z, , , ,	    0,	OPCL0,	000264

	OPCDEF	S,O,B, , , ,	MOD40,	OPCL8,	077000

	OPCDEF	S,P,L, , , ,	MOD45,	OPCL13,	000230

	OPCDEF	S,T,A,0, , ,	MOD45F,	OPCL0,	170005

	OPCDEF	S,T,B,0, , ,	MOD45F,	OPCL0,	170006

	OPCDEF	S,T,C,D,F, ,	MOD45F,	OPCL12,	176000

	OPCDEF	S,T,C,D,I, ,	MOD45F,	OPCL12,	175400

	OPCDEF	S,T,C,D,L, ,	MOD45F,	OPCL12,	175400

	OPCDEF	S,T,C,F,D, ,	MOD45F,	OPCL12,	176000

	OPCDEF	S,T,C,F,I, ,	MOD45F,	OPCL12,	175400

	OPCDEF	S,T,C,F,L, ,	MOD45F,	OPCL12,	175400

	OPCDEF	S,T,D, , , ,	MOD45F,	OPCL12,	174000

	OPCDEF	S,T,E,X,P, ,	MOD45F,	OPCL12,	175000

	OPCDEF	S,T,F, , , ,	MOD45F,	OPCL12,	174000

	OPCDEF	S,T,F,P,S, ,	MOD45F,	OPCL1,	170200

	OPCDEF	S,T,Q,0, , ,	MOD45F,	OPCL0,	170007

	OPCDEF	S,T,S,T, , ,	MOD45F,	OPCL1,	170300

	OPCDEF	S,U,B, , , ,	    0,	OPCL2,	160000

	OPCDEF	S,U,B,D, , ,	MOD45F,	OPCL11,	173000

	OPCDEF	S,U,B,F, , ,	MOD45F,	OPCL11,	173000

	OPCDEF	S,W,A,B, , ,	    0,	OPCL1,	000300

	OPCDEF	S,X,T, , , ,	MOD40,	OPCL1,	006700

	OPCDEF	T,R,A,P, , ,	    0,	OPCL6,	104400

	OPCDEF	T,S,T, , , ,	    0,	OPCL1,	005700

	OPCDEF	T,S,T,B, , ,	    0,	OPCL1,	105700

	OPCDEF	T,S,T,D, , ,	MOD45F,	OPCL1,	170500

	OPCDEF	T,S,T,F, , ,	MOD45F,	OPCL1,	170500

	OPCDEF	W,A,I,T, , ,	    0,	OPCL0,	000001

	OPCDEF	X,O,R, , , ,	MOD40,	OPCL5,	074000

	DIRDEF	.,A,B,S, , ,	ABS0

	DIRDEF	.,A,S,C,I,I,	.ASCII

	DIRDEF	.,A,S,C,I,Z, 	.ASCIZ

	DIRDEF	.,A,S,E,C,T,	ASECT

	DIRDEF	.,B,L,K,B, , 	.BLKB

	DIRDEF	.,B,L,K,W, , 	.BLKW

	DIRDEF	.,B,Y,T,E, ,	.BYTE

	DIRDEF	.,C,S,E,C,T,	CSECT

	DIRDEF	.,D,S,A,B,L, 	.DSABL

	DIRDEF	.,E,N,A,B,L, 	.ENABL

	DIRDEF	.,E,N,D, , ,	.END

.ENDCX:	DIRDEF	.,E,N,D,C, ,	ENDC0

.ENDMX:	DIRDEF	.,E,N,D,M, ,	.ENDM

.ENDRX:	DIRDEF	.,E,N,D,R, ,	ENDR0

	DIRDEF	.,E,O,T, , ,	.EOT

	DIRDEF	.,E,R,R,O,R, 	.ERROR

	DIRDEF	.,E,V,E,N, ,	.EVEN


	DIRDEF	.,F,L,T,2, ,	.FLT2

	DIRDEF	.,F,L,T,4, ,	.FLT4

	DIRDEF	.,G,L,O,B,L,	.GLOBL

	DIRDEF	.,I,D,E,N,T,	.IDENT

.IFX:
	DIRDEF	.,I,F, , , , 	.IF

	DIRDEF	.,I,F,D,F, ,	.IFDF

	DIRDEF	.,I,F,E,Q, ,	IFZ0

.IFFX:	DIRDEF	.,I,F,F, , , 	.IFF

	DIRDEF	.,I,F,G, , ,	IFG0

	DIRDEF	.,I,F,G,E, ,	IFGE0

	DIRDEF	.,I,F,G,T, ,	IFG0

	DIRDEF	.,I,F,L, , ,	IFL0

	DIRDEF	.,I,F,L,E, ,	IFLE0

	DIRDEF	.,I,F,L,T, ,	IFL0

	DIRDEF	.,I,F,N,D,F,	.IFNDF

	DIRDEF	.,I,F,N,E, ,	IFNZ0

	DIRDEF	.,I,F,N,Z, ,	IFNZ0

.IFTX:	DIRDEF	.,I,F,T, , ,	.IFT

.IFTFX:	DIRDEF	.,I,F,T,F, ,	.IFTF

	DIRDEF	.,I,F,Z, , ,	IFZ0
.IFY:

	DIRDEF	.,I,I,F, , ,	.IIF

	DIRDEF	.,I,N,C,L,U,	.REQUIRE

	DIRDEF	.,I,N,S,E,R,	.INSERT

.IRPOP:	DIRDEF	.,I,R,P, , ,	.IRP

.IRCOP:	DIRDEF	.,I,R,P,C, ,	.IRPC

	DIRDEF	.,L,I,M,I,T,	.LIMIT

	DIRDEF	.,L,I,S,T, , 	.LIST

.MACRX:	DIRDEF	.,M,A,C,R, ,	DEFIN0

.MACRY:	DIRDEF	.,M,A,C,R,O,	DEFIN0

	DIRDEF	.,M,C,A,L,L,	.MCALL

	DIRDEF	.,M,E,X,I,T,	.MEXIT

	DIRDEF	.,N,A,R,G, ,	.NARG

	DIRDEF	.,N,C,H,R, ,	.NCHR

	DIRDEF	.,N,K,I,N,D,	.NKIND

	DIRDEF	.,N,L,I,S,T, 	.NLIST

	DIRDEF	.,N,T,Y,P,E,	.NTYPE

	DIRDEF	.,N,V,A,L,,	.NVAL

	DIRDEF	.,O,D,D, , ,	.ODD

	DIRDEF	.,O,P,D,E,F,	.OPDEF

	DIRDEF	.,P,A,G,E, ,	.PAGE

	DIRDEF	.,P,D,P,1,0,	.PDP10

	DIRDEF	.,P,R,I,N,T,	.PRINT

	DIRDEF	.,P,S,E,C,T,	PSECT

	DIRDEF	.,R,A,D,I,X,	.RADIX

	DIRDEF	.,R,A,D,5,0,	.RAD50

.REPTX:	DIRDEF	.,R,E,P,T, ,	REPEA0

	DIRDEF	.,R,O,U,N,D,	.ROUND

	DIRDEF	.,R,E,Q,U,I,	.REQUIRE

	DIRDEF	.,S,B,H,E,D,	.SBHED

	DIRDEF	.,S,B,T,T,L, 	.SBTTL

	DIRDEF	.,T,I,T,L,E,	.TITLE

	DIRDEF	.,T,R,U,N,C,	.TRUNC

	DIRDEF	.,W,O,R,D, ,	.WORD

OPTTOP:	-1B36				;OP TABLE TOP

CONDX:
	DIRDEF	A,B,S,,,,.IFABS
	DIRDEF	B,,,,,,.IFB
	DIRDEF	D,F,,,,,.IFDF
	DIRDEF	D,I,F,,,,.IFDIF
	DIRDEF	E,Q,,,,,IFZ0
	DIRDEF	E,Q,V,,,,.IFEQV
	DIRDEF	G,,,,,,IFG0
	DIRDEF	G,E,,,,,IFGE0
	DIRDEF	G,T,,,,,IFG0
	DIRDEF	I,D,N,,,,.IFIDN
	DIRDEF	L,,,,,,IFL0
	DIRDEF	L,E,,,,,IFLE0
	DIRDEF	L,T,,,,,IFL0
	DIRDEF	N,B,,,,,.IFNB
	DIRDEF	N,D,F,,,,.IFNDF
	DIRDEF	N,E,,,,,IFNZ0
	DIRDEF	N,Q,V,,,,.IFNQV
	DIRDEF	N,Z,,,,,IFNZ0
	DIRDEF	Z,,,,,,	IFZ0
CONDY:

	SUBTTL	CHARACTER DISPATCH ROUTINES

C1PNTR:	POINT	4,CHJTBL(R14), 3
C2PNTR:	POINT	4,CHJTBL(R14), 7
C3PNTR:	POINT	4,CHJTBL(R14),11
C4PNTR:	POINT	4,CHJTBL(R14),15
C5PNTR:	POINT	4,CHJTBL(R14),19
C6PNTR:	POINT	4,CHJTBL(R14),23
C7PNTR:	POINT	4,CHJTBL(R14),27
C8PNTR:	POINT	4,CHJTBL(R14),31
C9PNTR:	POINT	4,CHJTBL(R14),35

ANPNTR=	C8PNTR


CHJTBL:					;CHARACTER JUMP TABLE
	PHASE	0


	BYTE	(4)	    ,    ,    ,    ,    ,SCLE,QJNU,    ,    	; NULL
	BYTE	(4)	    ,    ,    ,    ,    ,SCIL,QJPC,    ,    	; ^A
	BYTE	(4)	    ,    ,    ,    ,    ,SCEL,QJPC,    ,    	; ^B
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^C
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^D
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^E
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^F
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^G

	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^H
TAB:!	BYTE	(4)	    ,    ,    ,    ,    ,SCSE,QJSP,.TAB,    	; TAB
LF:!	BYTE	(4)	    ,    ,    ,    ,    ,SCLE,QJCR,    ,    	; LF
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJVT,    ,    	;
FF:!	BYTE	(4)	    ,    ,    ,    ,    ,SCLE,QJCR,    ,    	; FF
CRR:!	BYTE	(4)	    ,    ,    ,    ,    ,SCLE,QJCR,    ,    	; CR
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^N
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^O

	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^P
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^Q
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^R
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^S
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^T
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^U
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^V
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^W

	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^X
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^Y
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^Z
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,	; ESC
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^\
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^]
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ^^
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJCR,    ,    	; EOL

SPACE:	BYTE	(4)	    ,    ,    ,    ,    ,SCSE,QJSP,.TAB,    	; SPACE
	BYTE	(4)	    ,    ,    ,EXOR,    ,    ,QJPC,    ,    	; !
	BYTE	(4)	    ,    ,    ,EXTE,TEDQ,    ,QJPC,    ,    	; "
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; #
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; $
	BYTE	(4)	    ,    ,    ,EXTE,TEPC,    ,QJPC,    ,    	; %
	BYTE	(4)	    ,    ,    ,EXAN,    ,    ,QJPC,    ,    	; &
	BYTE	(4)	    ,    ,    ,EXTE,TESQ,    ,QJPC,    ,    	; '

	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; (
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; )
	BYTE	(4)	    ,    ,    ,EXMU,    ,    ,QJPC,    ,    	; *
	BYTE	(4)	    ,    ,    ,EXPL,TEIG,    ,QJPC,    ,    	; +
	BYTE	(4)	    ,    ,    ,    ,    ,SCSE,QJPC,    ,    	; ,
	BYTE	(4)	    ,    ,    ,EXMI,TE2C,    ,QJPC,    ,    	; -
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; .
	BYTE	(4)    	    ,    ,    ,EXDV,    ,    ,QJPC,    ,    	; /

	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 0
	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 1
	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 2
	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 3
	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 4
	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 5
	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 6
	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 7

	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 8
	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 9
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; :
	BYTE	(4)	    ,    ,    ,    ,    ,SCSE,QJPC,    ,    	; ;
	BYTE	(4)	    ,    ,    ,EXTE,TEEX,    ,QJPC,    ,    	; <
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; =
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; >
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ?

	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; @
	BYTE	(4)	    ,    ,    ,EXTE,TEHX,    ,QJPC,.HEX,    	; A
	BYTE	(4)	    ,    ,    ,EXTE,TEHX,    ,QJPC,.HEX,UPARB	; B
	BYTE	(4)	    ,    ,    ,EXTE,TEHX,    ,QJPC,.HEX,UPARC	; C
	BYTE	(4)	    ,    ,    ,EXTE,TEHX,    ,QJPC,.HEX,UPARD	; D
	BYTE	(4)	    ,    ,    ,EXTE,TEHX,    ,QJPC,.HEX,    	; E
	BYTE	(4)	    ,    ,    ,EXTE,TEHX,    ,QJPC,.HEX,UPARF	; F
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; G

	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,UPARH	; H
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; I
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; J
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; K
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; L
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; M
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; N
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,UPARO	; O

	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; P
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; Q
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,UPARR   ; R
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; S
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; T
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; U
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; V
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; W

	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; X
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; Y
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; Z
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; [
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; \
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ]
	BYTE	(4)	    ,    ,    ,EXTE,TEUP,    ,QJPC,    ,    	; ^
	BYTE	(4)	    ,    ,    ,EXSH,    ,    ,QJPC,    ,    	; _

	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; `
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; a
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; b
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; c
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; d
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; e
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; f
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; g

	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; h
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; i
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; j
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; k
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; l
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; m
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; n
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; o

	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; p
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; q
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; r
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; s
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; t
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; u
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; v
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; w

	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; x
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; y
	BYTE	(4)	    ,    ,    ,    ,    ,SCLC,QJLC,    ,    	; z
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; {
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; |
ALTMOD:	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; }
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ~
RUBOUT:	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJNU,    ,    	;

	DEPHASE
	SUBTTL	Pure data area and literals

IFN TENEX,<

ALEV:	SRET1				; LOCS TO STORE PC'S
	SRET2
	SRET3

ACHN:	0				; Channel 0 and 1 are not used
	0
	XWD	1,STATUS		; STATUS INTERRUPT ROUTINE
	REPEAT	^D33,<	0>		; REST ARE INACTIVE

; Assembler break character table

ABRKTB:	XWD	TTYEOF,"Z"-100		; End terminal input with a ^Z
	XWD	TTYEOL,EOL		; End a line with a EOL
	XWD	TTYEOL,LF		;  or a LF
	XWD	TTYEOL,CRR		;  or a CR
	 0				; End of table


; Exec command string character break table

EBRKTB:	XWD	FLDDEL,"X"-100		; ^X for deleting last name field
	XWD	CTRLW,"W"-100		; ^W for deleting last field
	XWD	RECOG,"F"-100		; Filename lookup
	XWD	RECOG,ESC		; Same
	XWD	HLTMAC,"Z"-100		; Halt MACN11
	XWD	RSPACE," "		; Space is ignored but echoed
	XWD	FINI,EOL		; End of command line
	XWD	FINI,LF			; Same
	XWD	FINI,CRR		; Same
	 0				; End of table

E10BLK:	XWD	100000,0		; Old file
	XWD	377777,377777		; Nothing for input or output
	0				; No default device name
	XWD	-1,[ ASCIZ /SUBSYS/ ]	; Default directory
	0
	XWD	-1,[ ASCIZ /SAV/ ]	; Default extension
	EXP	0,0,0			; Fill out the table

E20BLK:	XWD	100000,0		; Old file
	XWD	377777,377777		; Nothing for input or output
	XWD	-1,[ ASCIZ /SYS/ ]	; Default device name
	0				; No directory
	0
	XWD	-1,[ ASCIZ /EXE/ ]	; Default extension
	EXP	0,0,0			; Fill it out

>;IFN TENEX

$CRLF:	BYTE(7)CRR,LF,0


	LIT

	SUBTTL	Impure data area

IFN TwoSgs,< RELOC 0 >			;LOW SEG
IFN TENEX,<
	DATSPG==<<.-1>/^D512>+1		; Calculate this page number
	LOC	DATSPG*^D512
>

PDPSTK:	BLOCK	PDPLEN

BZCOR:					; BEGINNING OF CORE TO BE INITIALIZED TO ZERO
.IFFLG: BLOCK	1

					; ** Object file format controls:
PADSWT:	BLOCK	1			; Padding switch:  0 for none, non-0 for some.
ALIGNM:	BLOCK	1			; Alignment mask for packing into PDP-10 words

SYMPNT:	BLOCK	1			; Pointer to symbol mnemonic, rad50 fmt
VALPNT:	BLOCK	1			; Pointer to symbol value & attributes
CR1PNT:	BLOCK	1			; Pointer to symbol's 1st cross ref word
CR2PNT:	BLOCK	1			; Pointer to symbol's 2nd cross ref word

SYMBOT:	BLOCK	1			; BASE OF SYMBOL TABLE
SYMTOP:	BLOCK	1			; TOP OF SYMBOL TABLE
SYMLEN:	BLOCK	1			; LENGTH OF SYMBOL TABLE
DELTA:	BLOCK	1			; BINARY SEARCH OFFSET

MWPNTR:	BLOCK	1			; MACRO WRITE POINTER
NEXT:	BLOCK	1			; GARBAGE COLLECTION CHAIN
REPEXP:	BLOCK	1			; REPEAT EXPRESSION
REPPNT:	BLOCK	1			; REPEAT POINTER

REPLVL:	BLOCK	1			; REPEAT LEVEL COUNTER
CONLVL:	BLOCK	1			; CONDITIONAL LEVEL COUNTER
UNSLVL:	BLOCK	1			; UNSATISFIED CONDITIONAL NESTING LEVEL

SYMBEG:	BLOCK	1			; POINTER TO START OF SYMBOL FOR RESCAN PURPOSES

RUNTIM:	BLOCK	1			; RUN TIME

CMDSTR:BLOCK	1			; COMMAND STRING POINTER

LINBUF:	BLOCK	CPL3/5+2		; SOURCE LINE BUFFER

CURADR:	BLOCK	1			; CURRENT DATA BLOCK ADDRESS
BYTCNT:	BLOCK	1			; BYTE COUNT
CHKSUM:	BLOCK	1			; CHECK SUM
DATBLK:	BLOCK	DATLEN+10		; DATA BLOCK
RLDBLK:	BLOCK	RLDLEN+10
RLDCNT:	BLOCK	1
RELLVL:	BLOCK	1			; RELOCATION LEVEL
FLTLST:	BLOCK	2			; FOR EXPANDED FLT PNT LISTING
FLTBUF:	BLOCK	^D8			; DITTO
FLTCOL:	BLOCK	1			; Pointer into LINBUF where exp flt pt should go


SEQNUM:	BLOCK	1			; SEQUENCE NUMBER

AC00:	BLOCK	1			; AC EXCHANGE BLOCK
AC01:	BLOCK	1
AC02:	BLOCK	1
AC03:	BLOCK	1
AC04:	BLOCK	1
AC05:	BLOCK	1
AC06:	BLOCK	1
AC07:	BLOCK	1
AC10:	BLOCK	1
AC11:	BLOCK	1
AC12:	BLOCK	1
AC13:	BLOCK	1
AC14:	BLOCK	1

IFE TENEX,<
DATE:	BLOCK	1			; DATE FOR HEADER
MSTIME:	BLOCK	1			; CURRENT TIME IN MILLISECONDS

BINNAM:	BLOCK	2
>;IFE TENEX
IFN TENEX,<

TMPJFN:	BLOCK	1			; JFN for file lookup routine
SRCTAB:	BLOCK	MAXJFN			; Table of source JFN's.
SJFNIX:	BLOCK	1			; Index into source JFN table
SRCIDX:	BLOCK	1			; Current index into SRCTAB

REQBEG:	BLOCK	1			; First index of .REQUIRE files
REQIDX:	BLOCK	1			; Index into SRCTAB pointing to a .REQUIRE file
>;IFN TENEX
PAGNUM:	BLOCK	1			; PAGE NUMBER
INPGNM:	BLOCK	1			; Input file page number
ERRCNT:	BLOCK	1			; ERROR COUNT


ARGCNT:	BLOCK	1			; MACRO ARGUMENT COUNTER
CALPNT:	BLOCK	1			; POINTER TO CURRENT MACRO CALL BLOCK
MACLVL:	BLOCK	1			; MACRO NESTING LEVEL
MARMAS:	BLOCK	1			; MACRO ARGUMENT BIT MASK (FOR "?")
ARGLST:	BLOCK	^D65			; TEMP STORAGE FOR MACRO ARGUMENTS
MACNAM:	BLOCK	MACNES			; NESTED MACRO DEFINITION NAME TABLE
MCLREP=	MACNAM				; SAVED REPEAT LEVEL TABLE
MCLCON:	BLOCK	MACNES			; SAVED CONDITIONAL LEVEL TABLE
MCLUNS:	BLOCK	MACNES			; SAVED UNSATISFIED LEVEL TABLE
MCLIRP:	BLOCK	MACNES			; Nested .IRP(C) information:
					;  LH: Previous .IRP(C) level,
					;  RH: Maximum level of current .IRP(C)
NEXGS:	BLOCK	1			; NUMERIC VALUE OF NEXT
					; MACRO-GENERATED LOCAL SYMBOL
OPCODE:	BLOCK	1			; STORAGE FOR OP CODE
OPCCNT:	BLOCK	^D8
LSBLOC:	BLOCK	1			; LOCAL SYMBOL BLOCK NUMBER

PF0:	BLOCK	1
PF1:	BLOCK	1
PF2:	BLOCK	1
PF3:	BLOCK	1

PFT0:	BLOCK	1
PFT1:	BLOCK	1

CODPNT:	BLOCK	1
CODBUF:	BLOCK	^D100

OFFSET:	BLOCK	1			; 0 OF 1, FOR CEXT1 OR CEXT2
ADREXT:	BLOCK	2
TABCNT:	BLOCK	1
COLCNT:	BLOCK	1
BLNKLN:	BLOCK	1			; BLANK-LINE FLAG FOR CREF	[ECL2]
CRFNAM:	BLOCK	CRFLEN			; CREF NAME STORAGE
CRFTYP:	BLOCK	CRFLEN			; CREF TYPE STORAGE

FLTTMP:	BLOCK	2			; FLOATING POINT TEMP
FLTNUM:	BLOCK	4			; FLOATING POINT NUMBERS
FLTLEN:	BLOCK	1			; FLOATING LENGTH

SECBAS:	BLOCK	^D256
SECNAM:	BLOCK	^D256
SECFLG:	BLOCK	^D256

GLBPNT:	BLOCK	1
GLBBUF:	BLOCK	40

PRGTTL:	BLOCK	1
PRGVER:	BLOCK	1			; Program version, set by .Ident
ENDVEC:	BLOCK	1

IFN TEMPC,<
TMPFIL:	BLOCK	2			; TMPCOR UUO ARGUMENT BLOCK
>;IFN TEMPC
TTLFLA:	BLOCK	1			; =-1 IF PROGRAM NAME TYPED



IFE TENEX,<
JOBFFS:	BLOCK	204*NUMBUF		; SOURCE BUFFER
TTISAV:	BLOCK	1			; TTI POINTER SAVE

XE:	BLOCK	1			; EXEC LOOKUP BLOCK
XE1:	BLOCK	1
XE2:	BLOCK	1
XE3:	BLOCK	1
TTIPNT:	BLOCK	1
;THE FOLLOWING ARE BUFFER HEADER BLOCKS  -- DO NOT SPLIT THEM!!!!!
BINBUF:	BLOCK	3
BINPNT=BINBUF+1
BINCNT=BINBUF+2

LSTBUF:	BLOCK	3
LSTPNT=LSTBUF+1
LSTBCT=LSTBUF+2

SRCDEV:	BLOCK	1			; Source device name
>;IFE TENEX
XESAVE:	BLOCK	1			; FILE NAME STORAGE FOR TTY ERROR MESSAGES
BINDAT:	BLOCK	1
BINPCT:	BLOCK	1			; Binary byte count for packed mode

SRCBUF:	BLOCK	3
SRCPNT=SRCBUF+1
SRCCNT=SRCBUF+2

LINCNT:	BLOCK	1			; EXEC LINE COUNTER
IFN CMUSW,<
CMUSTR:	BLOCK	3			; STORAGE FOR CMUDEC USERID
CMUCTR:	BLOCK	1			;   CONVERSION
CMUPTR:	BLOCK	1
>;IFN CMUSW
LSTCNT:	BLOCK	1			; LIST LEVEL COUNT
SUBMSG:	BLOCK	30			; SUBTITLE BUFFER AREA
TTLMSG:	BLOCK	30			; TITLE AREA
SEQ:	BLOCK	1			; LINE SEQUENCE NUMBER (BINARY)
FSEQ:	BLOCK	2			; FORMATTED LINE SEQUENCE NUMBER
SEQND:	BLOCK	1			; # significant digits in line sequence number
CRFFLD:	BLOCK	1			; # of fields than can be printed on
					; a listing line
LIWORD:	BLOCK	1			; LISTING OVERRIDE FLAGS
ENWORD:	BLOCK	1			; ENABLE OVERRIDE FLAGS

;	**** CORE CLEARED BY INITIALIZATION ENDS HERE ****

EZCOR:

LSTCTL:	BLOCK	1			; LISTING CONTROL FLAGS
ENACTL:	BLOCK	1
IFN CCLSW,<
CCLFLA:	BLOCK	1			; CCL MODE FLAG, =-1 IF CCL MODE
IFE TENEX,<
TMPFLA:	BLOCK	1			; TMPCOR UUO IN PROGRESS FLAG
INDFLA:	BLOCK	1			; INDIRECT FILE IN USE FLAG
JOBFFI:	BLOCK	1			; POINT TO RESTORE .JBFF
CMDBUF:	BLOCK	3			; BUFFER HEADER FOR CMD FILE INPUT
CMDPNT=CMDBUF+1				; BYTE POINTER
CMDCNT=CMDBUF+2				; BYTE COUNT
>;IFE TENEX
IFN TENEX,<
CCLJFN:	BLOCK	1			; CCL JFN
CCLNBF:	BLOCK	3			; TO BUILD DSK:XXXM11.TMP
>;IFN TENEX
>;IFN CCLSW
RADVAL:	BLOCK	1			; VALUE OF GLOBAL RADIX
					; (GLBRDX CONTAINS FLAGS!)
GLBRDX:	BLOCK	1			; GLOBAL RADIX (SET BY .RADIX)
LOCRDX:	BLOCK	1			; LOCAL RADIX
SYMDEL:	BLOCK	1			; SYMBOL DELIMITER, SAVED BY GETSYM
ARGDEL:	BLOCK	1			; MACRO (.IRP) ARGUMENT DELIMITER
IRPLVL:	BLOCK	1			; .IRP(C) level count
IRPMAX:	BLOCK	1			; Maximum level of this .IRP(C)
MLSAVE:	BLOCK	1			; MACRO LEVEL SAVED BY .MEXIT

REQSP:	BLOCK	1			; Require stack pointer
REQSTK:	BLOCK	RQSTKL			; Require stack space

CRLFLG:	BLOCK	1			; -1 = Last character was a CR
MCALLF:	BLOCK	1			; (Count of .MCALLs this pass)-1


IFN TENEX,<
.JBFF:	BLOCK	1			; First free core location
.JBREL:	BLOCK	1			; Last address in this address space
BAKCHR:	BLOCK	1			; Back-up character for terminal editting
SRCVER:	BLOCK	1			; Version number of the current source file
TMPPTR:	BLOCK	1			; File lookup string pointer
DATSTR:	BLOCK	^D8			; DATE & TIME AS ASCIZ STRING
SFILNM:	BLOCK	^D20			; Source file name string area
SFILPT:	POINT	7,SFILNM,		; String pointer to above
BSIZE:	BLOCK	1			; Byte size and page count for a source file
BCOUNT:	BLOCK	1			; Byte count for the source file
SRCPGN:	BLOCK	1			; Input JFN,,fork page for source files
SRCFLG:	BLOCK	1			; Source PMAPable flag
					; Bit 0=1 means the file has been closed
SRET1:	BLOCK	1			; RETURN SPACE FOR PC
SRET2:	BLOCK	1			;  SAME FOR ALL THREE LEVELS
SRET3:	BLOCK	1			; SAME

TENFLG:	BLOCK	1			; Non-zero implies Tenex
					;     zero implies Tops-20

BINFIL:	BLOCK	1			; String pointer to binary file
BINJFN:	BLOCK	1			; JFN for binary file
LSTJFN:	BLOCK	1			; JFN for listing file
SRCJFN:	BLOCK	1			; Current source JFN
CMDPAG:	BLOCK	1			; Page pointer in which command string is stored
PAGPTR:	BLOCK	1			; Pointer of next free loc for ASCII strings and etc.
BINBLK:	XWD	400000,0		; Output file
	BLOCK	^D8			; GTJFN table for binary file look-up
LSTBLK:	XWD	400000,0		; Output file
	BLOCK	^D8			;   "     "    "  listing  "     "
SRCBLK:	XWD	100000,0		; Old file only
	BLOCK	^D8			;   "     "    "  source   "     "
EBLK:	SRCBLK
	BINBLK
	LSTBLK

LSTBUF:	BLOCK	50			; Output line buffer area	[ECL2]
LSTBFL=<.-LSTBUF>*5-1			; number of characters buffer	[ECL2]
					;   will hold			[ECL2]
LSTBFC:	BLOCK	1			; count of chars left in lstbuf	[ECL2]
LSTPT1:	POINT	7,LSTBUF,		; Point to begining of the string
LINPTR:	BLOCK	1			; Changing string pointer
>;IFN TENEX
IFE TENEX,<
CHRCNT:	BLOCK	1
>;IFE TENEX

ARGLEN:	BLOCK	1			; LENGTH OF MACRO-TYPE ARGUMENT
ARGSTR:	BLOCK	^D100			; SPACE FOR ARG AS ASCIZ STRING

SECLEN:	BLOCK	1			; LENGTH OF SECONDARY ARGUMENT
SECSTR:	BLOCK	^D100			; SPACE FOR SAME

; HERE IS SOME PATCH AREA SPACE.....

PAT:	0
PATCH:	BLOCK	^D100

ZZZZZZ:

IFN TwoSgs,< RELOC >

	END	MACN11			; ....MACN11
