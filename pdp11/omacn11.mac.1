;<RAVELING>MACN11.MAC;7     8-MAR-74 17:14:23	EDIT BY RAVELING

;	1.  FIXED BUG IN NUMBER CONVERSION DUE TO LOCAL
;		SYMBOL CHECKING.
;	2.  FIXED BUG IN LOCAL SYMBOL PROCESSING (LOCAL SYMBOL
;		BLOCK NUMBER WASN'T RESET BEFORE PASS 2).

;<RAVELING>MACN11.MAC;6     8-MAR-74 14:55:20	EDIT BY RAVELING
;<RAVELING>MACN11.MAC;5    15-FEB-74 22:18:31	EDIT BY RAVELING
;<RAVELING>MACN11.MAC;4    14-FEB-74 20:59:45	EDIT BY RAVELING
;<RAVELING>MACN11.MAC;3     1-FEB-74 20:53:04	EDIT BY RAVELING
;<RAVELING>MACN11.MAC;2    16-JAN-74 21:13:36	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;58    14-JAN-74 10:11:56	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;57    14-JAN-74 07:11:10	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;56     9-JAN-74 08:47:11	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;55     4-JAN-74 17:02:31	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;54    28-DEC-73 20:34:17	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;53    28-DEC-73 13:51:54	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;52    14-DEC-73 19:08:02	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;51    28-NOV-73 15:50:49	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;50    26-NOV-73 21:33:46	EDIT BY CASNER
;<RAVELING>MACX11.MAC;49    26-NOV-73 18:24:30	EDIT BY CASNER
;<RAVELING>MACX11.MAC;44    31-OCT-73 17:46:51	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;43    25-OCT-73 18:30:31	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;41    24-OCT-73 21:12:50	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;40    23-OCT-73 19:45:43	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;39    19-OCT-73 18:08:33	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;38    19-OCT-73 16:36:11	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;37    18-OCT-73 19:17:42	EDIT BY RAVELING
;<RAVELING>MACX11.MAC;36    18-OCT-73 18:35:03	EDIT BY RAVELING
	TITLE	MACN11	V000	20-JAN-73
;	COPYRIGHT 1969,1970,1971, DIGITAL EQUIPMENT CORPORATION.

;	MODIFICATIONS BY . . .

;	-- CMU

;	-- USC-ISI  (PAUL RAVELING & STEVE CASNER)
;	-- SCRL	    (DAVE RETZ & SHARI)


	IFNDEF	NONREN,	<TWOSEG>

	LOC	137
	010
	IFNDEF	NONREN,	<RELOC 400000>
	IFDEF	NONREN,	<RELOC>

TITLE:	SIXBIT	/MACN11/
ASMVER:	SIXBIT	/V000  /

	ENTRY		START

	EXTERNAL	JOBREL,	JOBFF
;	CCLSW=1 GIVES NEW COMMAND LANGUAGE FEATURES
	IFNDEF	CCLSW,<CCLSW==1>	;NORMALLY ASSEMBLE WITH CCL FEATURES
	IFE	CCLSW,<TEMPC==0>	;TMPCOR UUO FLAG
	IFNDEF	TEMPC,<TEMPC==1>	;NORMALLY USE CCL WITH TMPCOR UUO
	IFNDEF CMUSW,<CMUSW=1>		;FOR CMU MODS

	SUBTTL	VARIABLE PARAMETERS

	PAGSIZ=	^D54		; NUMBER OF LINES ON A PAGE

	NUMBUF=	2		; NUMBER OF BUFFERS PER DEVICE

	CORINC=	2000		; CORE INCREMENT

	SPL=	4		; SYMBOLS PER LINE (SYMBOL TABLE LISTING)

	SPLTTY=	3		; SYMBOLS PER LINE (TTY)

	DATLEN=	^D350		; DATA BLOCK LENGTH

	RLDLEN=	^D40

	WPB=	10		; MACRO BLOCK SIZE
	MACNES=	^D32		; MACRO NESTING LIMIT

	CPL1=	^D72		; CHARACTERS PER LOGICAL LINE
	CPL2=	^D83		; CHARACTERS PER PHYSICAL LINE
	CPL3=	^D144		; CHARACTERS PER .PDP10 LINE

	PDPLEN=	100		;  PUSH-DOWN POINTER LENGTH

	CRFLEN=	^D36		; CREF SYMBOLS/LINE MAX

	COLLPT=	^D128		;CPL LPT

	COLTTY=	^D72		;CPL TTY

TRUE=   1
BKT1=	1
BKT2=	2
BKT3=	3
BKT4=	4
BKT6=	6

	SUBTTL	ACCUMULATOR ASSIGNMENTS

	%00=	0		; ACCUMULATION OF SIXBIT SYMBOL, SCRATCH
	%01=	1		; SYMBOL VALUE AND FLAGS SET BY SRCH.  SCRATCH
	%02=	2		; SCRATCH
	%03=	3		; UNIVERSAL SCRATCH
	%04=	4		; UNIVERSAL SCRATCH +1
	%05=	5		; LOCATION COUNTER
	%06=	6		; SCRATCH
	%07=	7		; SYMBOL TABLE SEARCH INDEX
	%10=	10		; EXPRESSION OR TERM VALUE, SCRATCH
	%11=	11		; SCRATCH
	%12=	12		; MACRO STORAGE BYTE POINTER
	%13=	13		; LINE BUFFER BYTE POINTER
	%14=	14		; CURRENT CHARACTER (ASCII)
	%15=	15		; LH - ASSEMBLER FLAGS,  RH - ERROR FLAGS
	%16=	16		; EXEC FLAGS
	%17=	17		; PUSH-DOWN POINTER


;	ALTERNATE SYMBOLIC AC ASSIGNMENTS ----

RLOC=	5		; LOCATION COUNTER
RBPTR=	13		; BYTE POINTER
RMODE=	15		; MODE FLAG REGISTER (LEFT  HALF)
RERR=	15		; ERROR FLAG REGISTER (RIGHT HALF)
RLINK=	17		; STACK PTR FOR SUBROUTINE LINKAGE

	SUBTTL	FLAG REGISTERS

				; %16 - LH

	LSTBIT=	000001		; 1- SUPRESS LISTING OUTPUT
	BINBIT=	000002		; 1- SUPRESS BINARY OUTPUT
	CSWBIT= 000004		; 1- SUPRESS CROSS REFERENCE
	NSWBIT=	000040		; 1- SUPRESS ERRORS ON TTY
	RSWBIT=	000100		; 1- REPRODUCE SOURCE
	TTYBIT=	000200		; 1- LISTING IS ON TTY
	ERRBIT=	000400		; 1- ERROR MESSAGES ENABLED
	SBTBIT= 001000		; 1- SUBTITLE AVAILABLE
	NLISLN= 002000		; 1- SUPPRESS LIST OF CURRENT LINE
	LBLBIT= 004000		; 1- STATEMENT IS LABELED (MAY BE
				;    USED TO FORCE PRINTING LOC)
	PF1BIT= 010000		; 1- PRINT PF1 AS IS, INSTEAD OF
				;    A WORD FROM CODBUF
	MEXBIT= 020000		; 1- MACRO EXPANSION IN PROGRESS
	BEXBIT= 040000		; 1- BINARY EXTENSION LINE BEING LISTED
	LOHBIT= 100000		; 1- LAST OUTPUT WAS PAGE HEADER


				; %16 - RH

	ARWBIT=	000001		; 1- LEFT ARROW SEEN
	EXTBIT=	000002		; 1- EXPLICIT EXTENSION SEEN
	SWTBIT=	000004		; 1- ENTER SWITCH MODE
	INFBIT=	000010		; 1- VALID INFORMATION SEEN
	FFBIT=	000020		; 1- FORM-FEED SEEN
	ENDBIT=	000400		; 1- END OF ALL INPUT FILES
	SLABIT=	001000		; 1- SWITCH MODE ENTERED WITH A </>
	NULBIT=	010000		; 1- NON-NULL COMMAND STRING
	HDRBIT=	040000		; 1- TIME FOR NEW LISTING PAGE
	SEQBIT=	100000		; 1- SEQUENCE NUMBER SEEN
	MODBIT=	200000		; 1- USER MODE AC'S SET


				; %15 - LH

	CDRFLG= 000001		; 1- CARD READER INPUT (73-80 IGNORED)
	LCFLG=  000002		; 1- LOWER CASE INPUT
	LSBFLG= 000004		; 1- LOCAL SYMBOL BLOCK ENABLED
	PNCFLG= 000010		; 1- BINARY OUTPUT ENABLED
	ENDFLG=	000020		; 1- END OF SOURCE ENCOUNTERED
	RSWFLG=	000040		; 1- LINE TO BE SUPPRESSED IN REDUCTION
	AMAFLG= 000100		; 1- ABS MODE ADDRESSING
	CONFLG=	000200		; 1- CONCATENATION CHARACTER SEEN
	EXTFLG=	000400		; 1- EXTENSION LINE
	TRNFLG=	001000		; 1- TRUNCATION MODE
	P10FLG=	002000		; 1- .PDP10 MODE
	HOVFLG=	004000		; 1- CAUSES SYMBOL BEGINNING WITH A-F
				;    TO BE INTERPRETED AS A HEX
				;    CONSTANT, IF RADIX=16
	ABSFLG=	010000		; 1- ABSOLUTE OBJECT
	XSWFLG=	020000		; 1- RECREATE OBJECT
	FLTFLG=	040000		; 1- ERROR ENCOUNTERED IN FLOATING ROUTINE
	PSWFLG=	100000		; 1- IMAGE (UNPACKED) MODE
	NSFBIT= 200000		; 1- NONSTANDARD FEATURES ENABLED
	P1F=	400000		; 1- PASS 1 IN PROGRESS

TTL	MISCELLANEOUS PARAMETERS

	TTYDEV=	000010		; 1- DEVICE IS A TTY
	PTRDEV=	000200		; 1- DEVICE IS A PTR
	LPTDEV=	040000		; 1- DEVICE IS A LPT
	CDRDEV=	100000		; 1- DEVICE IS A CDR

	IODATA= 200000		; 1- IO DATA ERROR
	IODEV=  100000		; 1- IO PARITY ERROR
	IOWRLK= 400000		; 1- IO WRITE LOCK ERROR
	IOBKTL=	040000		; 1- IO BLOCK TOO LARGE
	IOEOF=	020000		; 1- END OF FILE ON IO DEVICE


				; DEVICE PARAMETERS

	BIN=	1
	LST=	2
	SRC=	3
	CMD=	4

	ILLCHR=	1		;ILLEGAL CHARACTER SUBSTITUTE
	ELLCHR=	2		;END OF LOGICAL LINE CHARACTER
	INBIT=	2		;DEVICE CAN DO INPUT
	ALMODE=	1		;ASCII LINE MODE


;	-------- LISTING CONTROL FLAGS -----------
;		FLAG WORD IS LSTCTL

LBEX=	000001		; BINARY EXTENSIONS
LBIN=	000002		; BINARY CODE
LCOM=	000004		; COMMENTS
LCND=	000010		; UNSATISFIED CONDITIONS
LLD=	000020		; LISTING DIRECTIVES WITHOUT ARGUMENTS
LLOC=	000040		; LOCATION COUNTER
LMC=	000100		; MACRO CALLS
LMD=	000200		; MACRO DEFINITIONS
LME=	000400		; MACRO EXPANSIONS
LMEB=	001000		; MACRO EXPANSION BINARY CODE
LSEQ=	002000		; SOURCE SEQUENCE NUMBERS
LSRC=	004000		; SOURCE CODE
LSYM=	010000		; SYMBOL TABLE
LTOC=	020000		; TABLE OF CONTENTS
LTTM=	040000		; TELETYPE MODE

LDEF=	777777-LLD-LME-LMEB-LTTM	; *****  DEFAULT LIST MODES  *****

BINRDX=	1	;BIT DEFINITIONS FOR GLBRDX CONTROL WORD
QUARDX=	2
OCTRDX=	4
DECRDX=	10
HEXRDX=	20
HEXENB=	40	;ENABLES HEX CONSTANTS TO START WITH A-F,
		;  SO CONSEQUENTLY SYMBOLS CAN'T

				; OPDEFS

	OPDEF	RESET	[CALLI	 0]
	OPDEF	DEVCHR	[CALLI	 4]
	OPDEF	CORE	[CALLI	11]
	OPDEF	EXIT	[CALLI	12]
	OPDEF	DATE	[CALLI	14]
	OPDEF	APRENB	[CALLI	16]
	OPDEF	MSTIME	[CALLI	23]
	OPDEF	RUNTIM	[CALLI	27]
	OPDEF	ZBINK	[CLOSE BIN,]

	OPDEF	OUTCHR	[TTCALL 1,]
	OPDEF	OUTSTR	[TTCALL 3,]
	OPDEF	INCHWL	[TTCALL 4,]


	DEFINE	GENM40	(A,B,C,D,E,F)	;GEN MOD 40
<
	XWD	$'A*50*50+$'B*50+$'C , $'D*50*50+$'E*50+$'F
>

	DEFINE	ARG	(A,B,C,VALUE)	; ARG TABLE GENERATOR
<
	XWD	VALUE,$'A*50*50+$'B*50+$'C
>

	SUBTTL	EXEC

START:				;MAIN ENTRY POINT
IFN CCLSW,<
	TDZA	0,0		;NORMAL ENTRY, CLEAR CCL FLAG
	SETOM	0		;CCL ENTRY, SET FLAG
	MOVEM	0,CCLFLA	;SAVE FLAG
>
NULFIL:	RESET			;RESET ALL I/O
	HRRZ	%00,JOBFF
	ADDI	%00,204*NUMBUF*2+200+200	;ACCOUNT FOR POSSIBLE CCL FILES
	CORE	%00,
	 HALT	.
	MOVE	%17,[IOWD PDPLEN,PDPSTK]
IFN CCLSW,<
	SKIPE	CCLFLA
	PUSHJ	%17,DSKNIT	;INIT DSK: FOR COMMAND FILE
				;SKIP RETURN
>
	OUTCHR	["*"]
NXTCCL:
	MOVE	%00,[XWD BZCOR,BZCOR+1]
	SETZB	%01,BZCOR
	BLT	%00,EZCOR-1
	RUNTIM	%01,
	MOVEM	%01,RUNTIM
	DATE	%00,
	MOVEM	%00,DATE	;SAVE DATE
	MSTIME	%00,
	MOVEM	%00,MSTIME	;  AND TIME
	PUSHJ	%17,CORSET	;SET UPPER CORE
	MOVSI	%16,BINBIT!LSTBIT!CSWBIT
	SETZ	%15,		;CLEAR ASSEMBLER FLAG REGISTER
	TLO	RMODE,PNCFLG	; SET PUNCH MODE FLAG (DON'T SUPPRESS OUTPUT)
	MOVE	%01,JOBFF
	HRLI	%01,(POINT 7,)
	MOVEM	%01,TTIPNT
START1:
IFN CCLSW,<
	SKIPE	CCLFLA
	PUSHJ	%17,GETCMD	;READ A CHARACTER FROM COMMAND FILE
	SKIPN	CCLFLA
>
	INCHWL	%02
	IDPB	%02,%01
	CAIE	%02,LF
	CAIN	%02,ALTMOD
	TDZA	%02,%02
	JRST	START1
	IDPB	%02,%01
	MOVEI	%01,1(%01)
	MOVEM	%01,JOBFF
	MOVSI	%01,(SIXBIT /DSK/)
	PUSHJ	%17,GETBIN	;INITIALIZE THE BINARY FILE
	MOVSI	%01,(SIXBIT /DSK/)
	TRNN	%16,ARWBIT	;GO ON TO SOURCE IF _ HAS BEEN SEEN
	PUSHJ	%17,GETLST	;INITIALIZE THE LISTING FILE

	MOVE	%05,TTIPNT
	MOVEM	%05,TTISAV	;SAVE TTI POINTER
	MOVSI	%01,(SIXBIT /DSK/)
	PUSHJ	%17,GETSRC	;INITIALIZE THE SOURCE FILE
	MOVEI	%10,[ASCIZ ./R REQUIRES LISTING FILE.]
	TLNE	%16,LSTBIT	;IF NO LISTING FILE
	TLNN	%16,RSWBIT	;  BUT /R SEEN,
	CAIA
	JRST	ERROR		;  ERROR
IFN CCLSW,<
	SKIPE	CCLFLA
	OUTSTR	[ASCIZ /MACN11: /]	;ANNOUNCE YOURSELF
>

	SKIPN	CCLFLA
	OUTSTR	[BYTE (7) CRR, LF, 0]	;CONFIRM ALL'S WELL
	PUSHJ	%17,ACEXCH	;SAVE EXEC AC'S
	PUSHJ	RLINK,ASSEMB	; CALL THE ASSEMBLER

IFN CCLSW,<
	SKIPN	CCLFLA
>
	PUSHJ	%17,LSTCR	;SKIP ONE LINE
	PUSHJ	%17,ACEXCH	;SWAP AC'S
IFN CCLSW,<
	EXTERNAL	JOBERR
	HRRZ	%11,ERRCNT
	ADDM	%11,JOBERR	;UPDATE ERROR COUNT
	JUMPN	%11,START2	;DON'T PRINT 0 ERRORS
	SKIPE	CCLFLA		;IF CCL MODE
	JRST EXIT
>
START2:	PUSH	%17,%16
	TLO	%16,ERRBIT
	TLZ	%16,NSWBIT	;BE SURE TO TYPE FINAL MESSAGE
	PUSHJ	%17,LSTCR	;SKIP A LINE
	MOVEI	%02,"?"		;ASSUME ERROR
	SKIPE	%11,ERRCNT	;TEST ERRORS, LOAD %11
	PUSHJ	%17,LSTOUT
	MOVEI	%10,[ASCIZ / ERRORS DETECTED: 5/]
	PUSHJ	%17,LSTMCR
	PUSHJ	%17,LSTCR
	POP	%17,%00
IFN CCLSW,<
	SKIPE	CCLFLA		;SKIP REST IF CCL MODE
	JRST	EXIT
>
	AND	%00,[XWD NSWBIT,0]
	IOR	%16,%00
	TRO	%16,HDRBIT
	MOVE	%11,OPCCNT+1	;PRINT NUMBER OF INSTRUCTIONS
	CAMN	%11,OPCCNT
	JRST	START7		;DON'T PRINT SUMMARY IF NOTHING SPECIAL
	MOVEI	%10,[ASCIZ \ TOTAL # OF PST ACCESSES = 5\]
	PUSHJ	%17,LSTMCR
	SKIPA	%10,[POINT 7,[ASCIZ \ TOTAL # OF 11/45\]]
	PUSHJ	%17,LSTOUT
	ILDB	%02,%10
	JUMPN	%02,.-2
	MOVE	%11,OPCCNT+1
	SUB	%11,OPCCNT
	MOVEI	%10,[ASCIZ \ INSTRUCTIONS = 5\]
	PUSHJ	%17,LSTMCR
START7:	SETZ	%11,
	RUNTIM	%11,		;GET RUNTIM
	SUB	%11,RUNTIM	;DEDUCT STARTING TIME
	IDIVI	%11,^D1000	;CONVERT TO SECONDS
	MOVEI	%10,[ASCIZ / RUN-TIME:  5 SECONDS/]
	PUSHJ	%17,LSTMCR
	HRRZ	%11,JOBREL	;GET TOP OF COR
	ASH	%11,-^D10	;CONVERT TO "K"
	ADDI	%11,1		;BE HONEST ABOUT IT
	MOVEI	%10,[ASCIZ / CORE USED:  5K/]
	PUSHJ	%17,LSTMCR	;LIST MESSAGE
	SKIPN	%11,P10CNT	;P10 USED?
	JRST	START8		;  NO
	SKIPA	%10,[POINT 7,[ASCIZ / .PDP10/]]
	PUSHJ	%17,LSTOUT
	ILDB	%02,%10
	JUMPN	%02,.-2
	MOVEI	%10,[ASCIZ / USAGE:  5/]
	PUSHJ	%17,LSTMCR
START8:	PUSHJ	%17,LSTCR
	JRST	EXIT		;CLOSE OUT

	SUBTTL	FILE INITIALIZATION

;INITIALIZE A BINARY FILE
;COLLECTS A DEVICE NAME IN AC %01, A FILE NAME IN XE, AND
;AN OPTIONAL FILE NAME EXTENSION, THE DEVICE IS INITIALIZED IN
;BINARY MODE ON CHANNEL ONE, WITH EITHER ONE OR TWO BUFFERS.

GETBIN:	MOVSI	%13,(Z BIN,)	;SET SWITCH AC
	PUSHJ	%17,GETNAM	;GET A DEVICE NAME AND FILE NAME
	POPJ	%17,		;NULL FILE EXIT
	MOVE	%00,%01		;GET AN EXTRA COPY OF THE DEVICE
	DEVCHR	%00,		;TEST ITS CHARACTERISTICS
	TLNE	%00,TTYDEV!PTRDEV!LPTDEV!CDRDEV
	JRST	ERRTB		;ILLEGAL FOR BINARY
	MOVE	%00,[INIT BIN,10]	;INIT IMAGE MODE
	MOVSI	%02,BINBUF	;GET BUFFER HEADER ADDRESS
	PUSHJ	%17,INISET	;INITIALIZE THE BINARY DEVICE
	OUTBUF	BIN,NUMBUF
	TLNE	%13,777000	;IS THERE A SWITCH TO PROCESS?
	XCT	%13		;EXECUTE THE ASSEMBLED UUO
	MOVE	%03,XE
	MOVEM	%03,BINNAM	;SAVE BINARY NAME
	TRZE	%16,EXTBIT	;WAS THERE AN EXTENSION
	HLLOM	%14,BINNAM+1	;  YES, SAVE IT
	TLZ	%16,BINBIT	;INDICATE GOOD BINARY FILE
	POPJ	%17,		;EXIT

SETBIN:				;SET BIN (END OF PASS 1)
	TLNE	%16,BINBIT	;ANY BINARY?
	POPJ	%17,		;  NO, EXIT
	PUSHJ	%17,ACEXCH	;YES, GET EXEC AC'S
	MOVE	%03,BINNAM
	MOVEM	%03,XE		;SET UP BINARY NAME
	MOVSI	%03,(SIXBIT /OBJ/)
	TLNE	%15,ABSFLG	;ABS MODE?
	MOVSI	%03,(SIXBIT /BIN/)	;  YES
	SKIPE	BINNAM+1	;WAS THERE AN EXPLICIT EXTENSION?
	MOVE	%03,BINNAM+1	;  YES, FORGET THE ABOVE
	HLLZM	%03,XE1		;SET IN LOOKUP BLOCK
	SETZM	XE2		;ZERO REMAINDER
	SETZM	XE3
	ENTER	BIN,XE		;ENTER FILE NAME IN DIRECTORY
	 JRST	ERRNR		;DIRECTORY FULL
	JRST	ACEXCH		;TOGGLE AC'S AND EXIT

;INITIALIZE A LISTING FILE
;COLLECTS A DEVICE NAME IN AC %01, A FILE NAME IN XE AND
;AN OPTIONAL FILENAME EXTENSION, THE DEVICE IS INITIALIZED IN
;ASCII LINE MODE ON CHANNEL 2, IF THE DEVICE IS A TTY, THE
;TTYLST FLAG IS SET TO 1, AND THE INBUF/OUTBUF INDEX IS INCREMENTED.

GETLST:	MOVSI	%13,(Z LST,)	;SET SWITCH AC
	SETZM	XE
	PUSHJ	%17,GETNAM	;GET A DEVICE AND FILE NAME
	TLNN	%16,CSWBIT
	CAIA
	POPJ	%17,
	TLNE	%16,CSWBIT
	JRST	GETLS2		;NORMAL
	MOVE	%03,[SIXBIT /CREF/]
	SKIPN	XE		;EXPLICIT CREF NAME?
	MOVEM	%03,XE		;  NO, GIVE IT DEFAULT
	TRON	%16,EXTBIT	;EXPLICIT EXTENSION?
	MOVSI	%14,(SIXBIT /CRF/)	;  NO, SUPPLY ONE
GETLS2:	MOVE	%00,[INIT LST,1]
	MOVSI	%02,LSTBUF	;GET BUFFER HEADER ADDRESS
	PUSHJ	%17,INISET	;INITIALIZE LISTING FILE
	MOVE	%00,%01
	DEVCHR	%00,		;GET DEVICE CHARACTERISTICS
	TLNE	%00,TTYDEV	;IS IT A TTY?
	TLO	%16,TTYBIT	;SET FLAG
	OUTBUF	LST,NUMBUF
	TLNE	%13,777000	;IS THERE A SWITCH TO PROCESS?
	XCT	%13		;EXECUTE THE ASSEMBLED UUO
	TRZN	%16,EXTBIT	;WAS THERE AN EXTENSION?
	MOVSI	%14,(SIXBIT /LST/)	;NO
	HLLZM	%14,XE1		;SAVE EXTENSION IN LOOKUP BLOCK
	ENTER	LST,XE		;ENTER FILE NAME IN DIR.
	JRST	ERRNR		;DIRECTORY FULL
	TLZ	%16,LSTBIT	;INDICATE A GOOD LISTING FILE
	TLNN	%16,TTYBIT	; TOGGLE MODE?
	JRST	LPTINI		;  - NO
	HRRZI	%02,LTTM	;   - YES
	XORM	%02,LSTCTL
	JRST	LPTINI		;INIT LINE OUTPUT AND EXIT

;INITIALIZE A SOURCE FILE
;COLLECTS A DEVICE NAME IN AC %01, A FILE NAME IN XE AND
;AN OPTIONAL FILE NAME EXTENSION. THE DEVICE IS INITIALIZED
;IN ASCII LINE MODE ON CHANNEL 3, AND THE FILE NAME ASSOCIATED
;WITH THE SOURCE FILE IS USED AS THE TITLE ON THE LISTING.

GETSRC:	MOVSI	%13,(Z SRC,)	;SET SWITCH AC
	SETZM	XE
	PUSHJ	%17,GETNAM	;GET A DEVICE NAME AND FILE NAME
	JRST	ERRSE		;COMMAND ERROR IF A NULL
	MOVE	%00,[INIT SRC,1]
	MOVEI	%02,SRCBUF	;GET BUFFER HEADER ADDRESS
	PUSHJ	%17,INISET	;INITIALIZE THE SOURCE DEVICE
	MOVEI	%05,JOBFFS
	EXCH	%05,JOBFF	;SET TO TOP OF INPUT BUFFER
	INBUF	SRC,NUMBUF
	MOVEM	%05,JOBFF	;RESTORE JOBFF
	TLNE	%13,777000	;IS THERE A SWITCH TO PROCESS?
	XCT	%13		;EXECUTE THE ASSEMBLED UUO
	TRZE	%16,EXTBIT	;WAS AN EXPLICIT EXTENSION SEEN?
	JRST	SRC3A		;YES, LOOK FOR IT
	MOVSI	%14,(SIXBIT /M11/)
	HLLZM	%14,XE1		;NO, TRY .M11 FIRST
	LOOKUP	SRC,XE
	 CAIA
	POPJ	%17,

	MOVSI	%14,(SIXBIT /P11/)	; TRY P11 SECOND
	HLLZM	%14,XE1
	LOOKUP	SRC,XE
	CAIA
	POPJ	RLINK,

	MOVSI	%14,(SIXBIT /MAC/)	; TRY MAC 3RD
	HLLZM	%14,XE1
	LOOKUP	SRC,XE
	TDZA	%14,%14		;NOT FOUND, TRY BLANK
	POPJ	%17,		;FOUND
SRC3A:	HLLZM	%14,XE1		;SAVE EXTENSION IN LOOKUP BLOCK
	HLLZM	%14,EXTSAV	;SAVE EXTENSION FOR HEADER
	LOOKUP	SRC,XE		;LOOKUP FILE NAME
	JRST	ERRCF		;FILE NOT FOUND
	POPJ	%17,		;EXIT


SETP2:				;SET FOR PASS 2
	PUSHJ	%17,ACEXCH	;GET EXEC AC'S
	TRZ	%16,ENDBIT!FFBIT
	MOVE	%05,TTISAV
	MOVEM	%05,TTIPNT	;RESTORE INPUT COMMANDS
	MOVSI	%01,(SIXBIT /DSK/)
	PUSHJ	%17,GETSRC	;GET A SOURCE FILE
	JRST	ACEXCH		;SWAP AC'S AND EXIT

	SUBTTL	COMMAND STRING DECODER

;EXEC COMMAND STRING DISPATCHING
;THIS ROUTINE PICKS UP CHARACTERS FROM THE EXEC TTY BUFFER AND
;DISPATCHES TO THE PROPER ROUTINE DEPENDING ON THE TYPE OF
;CHARACTER. A TABLE OF BYTES AND BYTE POINTERS ALLOWS EACH CHARAC-
;TER IN THE ASCII SET TO BE TREATED INDIVIDUALLY.


GETNAM:	SETZ	%14,		;CLEAR SYMBOL WORD
	MOVE	%06,[POINT 6,%14]


GETCMN:	PUSHJ	%17,GETTTI	;GET NEXT CHARACTER
	CAIN	%05,"["		;PROJECT-PROGRAMMER PAIR?
	JRST	LFTBRA		;YES
	CAIGE	%10,4		;MODIFY CODE IF .GE. 4
	TRNN	%16,SWTBIT	;MODIFY IF SWITCH IS ON
	ADDI	%10,4		;CHANGE DISPATCH BY ADDING 4
	HRRZ	%02,DSPTCH(%10)	;LOAD RIGHT HALF DISPATCH
	CAIL	%10,10		;SKIP IF CORRECT
	HLRZ	%02,DSPTCH-10(%10);OTHERWISE, GET LEFT HALF DSPTCH
	JRST	@%02		;GO TO CORRECT ROUTINE

GETTTI:	ILDB	%05,TTIPNT	;GET A CHARACTER FROM TTY BUFFER
;  IF THE CHARACTER IS LOWER CASE, FOLD TO UPPER CASE.
	CAIGE	%05,141		; IS CHAR < LOWER CASE A?
	JRST	GETNLC		; YES - NOT LC
	CAIG	%05,172		; NO - CK FOR > LOWER CASE Z
	SUBI	%05,40		; **  FOLD  **

GETNLC:	MOVE	%10,%05		; COPY THE BYTE TO AC %10
	IDIVI	%10,8		; TRANSLATE TO 4-BIT CODE
	ADD	%10,[POINT 4,BITE,]	;SET BYTE POINTER
	IBP	%10		;MOVE TO PROPER BYTE
	SOJGE	%11,.-1		;TEST FOR END
	LDB	%10,%10		;OK, FETCH BYTE
	CAIN	%10,4		;IS IT A NULL?
	JRST	GETTTI		;YES, TRY AGAIN
	POPJ	%17,		;NO, EXIT

;COMMAND DISPATCH TABLE AND BYTE POINTERS
DSPTCH:	XWD	GETCMN,	ERRBS	;IGNORED CHAR, BAD CHAR(SWITCH)
	XWD	SWTCH,	SWTCHA	;<(>, LETTER(SWITCH MODE)
	XWD	COLON,	ERRBS	;<:>, NUMBER(SWITCH MODE)
	XWD	PERIOD,	SWTCHE	;<.>,<)>ESCAPE SWITCH MODE
	XWD	LFTARW,	ERRIC	;<_>, "<", OR <=>, BAD CHAR (NORMAL MODE)
	XWD	COMMA,	STORE	;<,>,ALPHABETICH CHAR (NORMAL)
	XWD	CARRTN,	STORE	;<CR>,NUMERIC CHAR (NORMAL)
	XWD	SLASH,	ERRIC	;</>, <)> ILLEGAL ESCAPE
IFN CCLSW,<
	XWD	RUNUUO,0	;<!>
	XWD	INDFIL,0	;<@>
>
IFE CCLSW,<
	XWD	ERRIC,0
	XWD	ERRIC,0
>

;BYTE TABLE FOR DISPATCHING
;CLASSIFICATION BYTE CODES


;	BYTE	DISP	CLASSIFICATION


;	00	00	ILLEGAL CHARACTER, SWITCH MODE
;	01	01	ALPHABETIC CHARACTER, SWITCH MODE
;	02	02	NUMERIC CHARACTER, SWTICH MODE
;	03	03	SWITCH MODE ESCAPE, SWITCH MODE


;	00	04	ILLEGAL CHARACTER, NORMAL MODE
;	01	05	ALPHABETIC CHARACTER, NORMAL MODE
;	02	06	NUMERIC CHARACTER, NORMAL MODE
;	03	07	SWITCH MODE ESCAPE, NORMAL MODE


;	04	10	IGNORED CHARACTER
;	05	11	ENTER SWITCH MODE WITH A <(>
;	06	12	DEVICE DELIMITER, <:>
;	07	13	FILE EXTENSION DELIMITER, <.>
;	10	14	OUTPUT SPEC. DELIMITER, <_>, "<", OR <=>
;	11	15	FILE DELIMITER, <,>
;	12	16	COMMAND TERMINATOR, <CR>
;	13	17	ENTER SWITCH MODE WITH </>
;	14	20	CCL FILE DELIMITER <!>
;	15	21	INDIRECT FILE DELIMITER <@>


;BYTE TABLE:

BITE:
	BYTE	(4)	 4,  ,  ,  ,  ,  ,  ,  
	BYTE	(4)	  , 4,12, 4, 4,12,  ,  
	BYTE	(4)	  ,  ,  ,  ,  ,  ,  ,  
	BYTE	(4)	  ,  ,12,12,  ,  ,  ,  

	BYTE	(4)	 4,14, 4,  ,  ,  ,  ,  
	BYTE	(4)	 5, 3,  ,  ,11,  , 7,13 
	BYTE	(4)	 2, 2, 2, 2, 2, 2, 2, 2
	BYTE	(4)	 2, 2, 6,  ,10,10,  ,14  

	BYTE	(4)	15, 1, 1, 1, 1, 1, 1, 1
	BYTE	(4)	 1, 1, 1, 1, 1, 1, 1, 1
	BYTE	(4)	 1, 1, 1, 1, 1, 1, 1, 1
	BYTE	(4)	 1, 1, 1,  ,  ,  ,  ,10

	BYTE	(4)	  ,  ,  ,  ,  ,  ,  ,  
	BYTE	(4)	  ,  ,  ,  ,  ,  ,  ,  
	BYTE	(4)	  ,  ,  ,  ,  ,  ,  ,  
	BYTE	(4)	  ,  ,  ,  ,  ,12,  , 4

;LEFT ARROW PROCESSOR
LFTARW:	TRO	%16,ARWBIT	;SET APPROPIATE FLAGS
	TRNN	%16,EXTBIT	;IS THIS A FILE NAME EXTENSION?
	MOVEM	%14,XE		;NO, ITS A FILE NAME
	TRZE	%16,INFBIT	;IS THIS A NULL FILE?
CPOPJ1:	AOS	(%17)		;GOOD EXIT
CPOPJ:	POPJ	%17,		;...

;PERIOD PROCESSOR
PERIOD:	TRO	%16,EXTBIT	;SET FLAG FOR EXPLICIT EXTENSION
	MOVEM	%14,XE		;SAVE THE FILE NAME
	JRST	GETNAM		;RE-ENTER THE GETNAM ROUTINE

;COLON PROCESSOR
COLON:	MOVE	%01,%14		;SET UP NEW DEVICE NAME
	JRST	GETNAM		;RETURN FOR MORE COMMAND

;COMMA PROCESSOR
COMMA:	TRZN	%16,INFBIT	;IS THIS A NULL FILE?
	TRNE	%16,ARWBIT	;ONLY LOOK FOR THEM IF NO _
	SKIPA			;NOT A NULL FILE
	POPJ	%17,		;NULL FILE, EXIT
COMMA1:	TRNN	%16,EXTBIT	;DO WE HAVE A FILE NAME EXTENSION?
	MOVEM	%14,XE		;NO, IT WAS A FILE NAME
	JRST	CPOPJ1		;GOOD EXIT

;CARRIAGE RETURN PROCESSOR
CARRTN:	TRNN	%16,NULBIT	;IS THIS JUST A RANDOM CR?
	JRST	NULFIL		;YES, RESTART COMPLETELY
	TRO	%16,ENDBIT	;IS THIS A NORMAL MODE COMMAND?
	TRNN	%16,ARWBIT	;YES, HAS A LEFT ARROW BEEN SEEN?
	JRST	ERRSE		;NO, SYNTAX ERROR
	JRST	COMMA1		;YES, TREAT IT LIKE A COMMA

;THE FOLLOWING TWO ROUTINES HANDLE ALPHANUMERIC CHARACTERS
;FOUND IN THE COMMAND STRING. IN NORMAL MODE, THE CHARACTER
;IS DEPOSITED TO FORM A SIXBIT SYMBOL. IN SWITCH MODE, THE
;PROPER INSTRUCTION IS EXECUTED WITH THE AID OF A DISPATCH
;TABLE. THEN, IF SWITCH MODE WAS ENTERED WITH A SLASH, THE
;EXEC EXITS FROM SWITCH MODE.


STORE:	TRO	%16,INFBIT!NULBIT;TURN ON BITS FOR CR ROUTINE
	SUBI	%05,40		;CONVERT SIXBIT TO ASCII
	TLNE	%06,770000	;DON'T STORE IF NO ROOM FOR CHAR
	IDPB	%05,%06		;PLOP THE CHARACTER INTO AC %14
	JRST	GETCMN		;RETURN

SWTCHA:	MOVEI	%11,-"A"(%05)
	MOVE	%10,[POINT 4,BYTAB]
	IBP	%10
	SOJGE	%11,.-1
	LDB	%11,%10
	JUMPE	%11,ERRBS
	CAIG	%11,SWTABA-SWTAB;THIS SWITCH LEGAL FOR INPUT?
	TRNN	%16,ARWBIT	;  NO, ERROR IF "_" SEEN
	CAIA			;OK
	JRST	ERRWF		;  ERROR, SWITCH IN WRONG FIELD
	XCT	SWTAB-1(%11)
	JRST	ERRBS
	TRZE	%16,SLABIT	;CALLED BY A SLASH?
	TRZ	%16,SWTBIT	;YES, EXIT FROM SWITCH MODE
	JRST	GETCMN		;NO, RETURN FOR MORE CHARACTERS


;THE FOLLOWING THREE ROUTINES HANDLE THE CONTROL CHARACTERS
;IN THE COMMAND STRING WHICH CAUSE THE EXEC TO ENTER INTO AND
;EXIT FROM SWITCH MODE. THERE ARE TWO TYPES OF SWITCH MODE,
;DEPENDING ON WHETHER IT IS ENTERED WITH A </> OR A <(>.


SLASH:	TRO	%16,SLABIT	;TURN ON THE SPECIAL SWITCH MODE
SWTCH:	TROA	%16,SWTBIT	;TURN ON NORMAL SWITCH MODE
SWTCHE:	TRZ	%16,SWTBIT	;TURN OFF THE NORMAL SWITCH MODE
	JRST	GETCMN		;RETURN FOR MORE CHARACTERS

;DISPATCH TABLE FOR SWITCHES


	DEFINE	SETSW	(LETTER, INSTRUCTION) <
	INSTRUCTION
	Y=<"LETTER"-"A">-^D9*<X=<"LETTER"-"A">/^D9>
	SETCOD	\X,Y>

	DEFINE	SETCOD	(X,Y)
	<BYTAB'X=BYTAB'X!<.-SWTAB>B<4*Y+3>>

BYTAB0=	0
BYTAB1=	0
BYTAB2=	0

SWTAB:

	SETSW	C,<TLZA  %16,CSWBIT>

	SETSW	A,<TLOA  %15,ABSFLG>

	SETSW	I,<TLOA  %15,PSWFLG>

SWTABA:
	SETSW	N,<TLOA  %16,NSWBIT>

BYTAB:	+BYTAB0
	+BYTAB1
	+BYTAB2

LFTBRA:	SETZM	XE3		;CLEAR NUMBER
LFTBR1:	HRLZS	XE3		;COMMA, MOVE TO LEFT HALF
LFTBR2:	PUSHJ	%17,GETTTI	;GET NEXT CHAR
	CAIN	%05,"]"		;TERMINAL?
	JRST	GETCMN		;YES, EXIT
	CAIN	%05,","		;SEPARATOR?
	JRST	LFTBR1		;YES
	CAIL	%05,"0"		;TEST FOR OCTAL NUMBER
	CAILE	%05,"7"
IFE CMUSW,<JRST	ERRIC		;IMPROPER CHARACTER>
IFN CMUSW,<JRST	CMUID		;CHECK FOR CMU USERID>
	HRRZ	%10,XE3		;OK, GET PREVIOUS VALUE
	IMULI	%10,8
	ADDI	%10,-"0"(%05)	;ACCUMULATE NEW NUMBER
	HRRM	%10,XE3
	JRST	LFTBR2
IFN CMUSW,<
CMUID:	MOVE	%10,[POINT 7,CMUSTR]	;POINTER TO ASCII STRING
	SETZM	CMUSTR		;CLEAR STRING LOCATION
	SETZM	CMUSTR+1
	IDPB	%05,%10		;FIRST CHAR OF USERID
	MOVEM	%10,CMUPTR	;STORE POINTER
	MOVEI	%10,7		;COUNT FOR LOOP
	MOVEM	%10,CMUCTR	;STORE COUNT
CMULOP:	PUSHJ	%17,GETTTI	;GET CHAR
	CAIN	%05,"]"	;END CHAR
	JRST	CMUCVT		;CONVERT USERID TO PPN
	IDPB	%05,CMUPTR	;DEPOSIT CHAR IN STRING
	SOSL	CMUCTR		;DECR COUNTER
	JRST	CMULOP		;REPEAT LOOP
	JRST	ERRUID		;TOO MANY CHARS
CMUCVT:	HRRZI	%10,CMUSTR	;ADDRESS OF STRING
	HRLI	%10,XE3		;DESTINATION OF CONVERTED NUMBER
	CALLI	%10,-2		;CMUDEC UUO
	JRST	ERRUID		;ILLEGAL USERID
	JRST	GETCMN		;DONE
>



;THE FOLLOWING CODE IS USED FOR PROCESSING THE COMMAND
;STRINGS FOR THE CCL COMMAND FEATURES
IFN CCLSW,<


DSKNIT:				;INIT DSK FOR CCL
IFN	TEMPC,<
	HRRZ	%00,JOBFF	;USE JOBFF AS START OF CCL BUFFER
	HRRM	%00,CMDPNT	;DUMMY UP BUFFER HEADER
	HRRM	%00,TMPFIL+1	;SET UP TMPCOR READ BLOCK
	SOS	TMPFIL+1	;MAKE IT PROPER IOWD FORMAT
	HRRI	%01,(SIXBIT /P11/)
	HRLM	%01,TMPFIL	;SETUP NAME OF FILE TO BE READ
	MOVNI	%01,200		;AND WORD COUNT
	HRLM	%01,TMPFIL+1	;IN READ BLOCK
	MOVE	%01,[XWD 2,TMPFIL]	;SET UP AC FOR A READ
	TMPCOR	%01,		;READ AND DELETE "FOR" FILE
	JRST	TMPEND		;NO FILE IN CORE TRY DISK
	ADD	%00,%01		;GET END OF FILE
	MOVEM	%00,JOBFF	;UPDATE JOBFF SO FILE ISN'T WIPED OUT
	HRLM	%00,JOBFFI	;SAVE FOR LATER
	IMULI	%01,5		;CALCULATE CHARACTER COUNT
	MOVEM	%01,CMDCNT	;STORE IN BUFFER HEADER
	MOVSI	%01,(POINT 7,,)	;BYTE POINTER
	HLLM	%01,CMDPNT	;BUFFER HEADER NOW SETUP
	SETOM	TMPFLA		;MARK THAT TMPCOR UUO IN PROGRESS
	JRST	CPOPJ1
TMPEND:
	MOVEI	%00,3		;INIT 3 DIGIT COUNTER
	PJOB	%02,		;GET JOB NUMBER
DSKNI1:	IDIVI	%02,^D10	;GET LAST DIGIT
	ADDI	%03,"0"-40	;CONVERT TO SIXBIT
	LSHC	%03,-6		;SLIDE CHAR INTO AC4
	SOJG	%00,DSKNI1	;3 CHARS YET?
	HRRI	%04,(SIXBIT /P11/)	;YES, GET FILENAME ###P11.TMP
	MOVEM	%04,XE		;SAVE FILE NAME IN LOOKUP DIRECTORY
	MOVSI	%04,(SIXBIT /TMP/)	;SET UP EXTENSION
	MOVEM	%04,XE1		;SAVE EXTENSION IN LOOKUP DIRECTORY
	SETZM	XE3		;ZERO PROJ,PROG #'S

	MOVEI	%00,ALMODE	;ASCII LINE DATA MODE
	MOVSI	%01,(SIXBIT /DSK/)
	MOVEI	%02,CMDBUF	;GET BUFFER HEADER ADDRESS
	OPEN	CMD,%00		;INIT DSK OK?
	JRST	DSKNI2		;NO, TYPE MESSAGE
	LOOKUP	CMD,XE		;LOOKUP ###FOR, TMP ON DISK
	JRST	DSKNI2		;FILE NOT FOUND
	INBUF	CMD,1		;ONE INPUT BUFFER
	MOVE	%00,JOBFF
	HRLM	%00,JOBFFI
	JRST	CPOPJ1		;FILE FOUND, SKIP RETURN
DSKNI2:	MOVE	%00,JOBFF
	HRLM	%00,JOBFFI
	JRST	ERRCF1


GETCM3:	MOVNI	%00,5		;SKIP OVER SEQUENCE NUMBER
	ADDM	%00,CMDPNT	;REDUCE COUNT BY 5 BYTES
	AOS	CMDPNT		;ADVANCE POINTER, FALL THROUGH

GETCMD:	SOSG	CMDCNT		;ANY CHARACTERS LEFT?
	PUSHJ	%17,GETCM1	;NO GET ANOTHER BUFFER FULL
	ILDB	%05,CMDPNT	;GET CHARACTER
	MOVE	%00,@CMDPNT	;CHECK FOR SEQUENCE NUMBER
	TRNE	%00,1
	JRST	GETCM3		;BY-PASS THE SEQUENCE NUMBER
	CAIN	%05,175		;OLD ALTMODE?
	MOVEI	%05,33		;YES, MAKE IT NEW ALTMODE
	CAIL	%05,140		;IS CHARACTER LOWER CASE?
	TRZ	%05,40		;YES, CHANGE TO UPPER CASE
	MOVE	%02,%05
	POPJ	%17,		;EXIT WITH CHARACTER

GETCM1:

IFN	TEMPC,<
	SKIPE	TMPFLA		;IS A TMPCOR UUO GOING?
	JRST	GETCM2		;YES, THEN WE ARE DONE?
>
	IN	CMD,
	POPJ	%17,		;NO ERRORS OR END OF FILE
	STATZ	CMD,IODATA!IODEV!IOBKTL
	JRST	ERRCMD		;DATA ERRORS
GETCM2:
	JSP	%10,DELFIL	;DELETE FILE
	EXIT


DELFIL:	SKIPE	INDFLA		;DON'T DELETE IF INDIRECT FILE
	JRST	(%10)
	CLOSE	CMD,0		;CLOSE COMMAND FILE
	SETZB	%04,%05
	SETZB	%06,%07
IFN	TEMPC,<
	SKIPE	TMPFLA		;TMPCOR BEING USED?
	JRST	(%10)		;YES, DON'T RENAME FILE?
>
	RENAME	CMD,%04
	JFCL
	JRST	(%10)		;RETURN


RUNUUO:			;PASS PROGRAM CONTROL TO NEXT PROGRAM (LNKX11)
	SKIPN	%01
	MOVSI	%01,(SIXBIT /SYS/)	;IF NO DEVICE, ASSUME SYS:
	TRNN	%16,EXTBIT	;PERIOD TYPED?
	MOVEM	%14,XE		;NO, THEN FILE NAME IS IN %14
	TRNN	%16,EXTBIT	;PERIOD TYPED?
	MOVEI	%14,0		;NO, ASSUME 0 EXTENSION
	HLLZM	%14,XE1		;SAVE IN DIRECTORY
	JSP	%10,DELFIL	;DELETE COMMAND FILE
	MOVE	%00,[XWD 1,%01]	;START INCREMENT,,6 WORD RUN BLOCK ADR
				;%01 = DEVICE
	MOVE	%02,XE		;GET FILENAME
	MOVE	%03,XE1		;GET EXTENSION
	SETZB	%04,%06
	MOVE	%05,XE3		;GET PROJ,PROG
	RUN	%00,		;START NEXT PROGRAM
	JSP	%10,ERROR	;RUN FAILED
	ASCIZ	/LINKAGE ERROR FOR 23/

INDFIL:	TRNN	%16,EXTBIT	;SET UP THE FILENAME IF NECESSARY
	MOVEM	%14,XE
	TRNN	%16,ARWBIT	;NORMAL MODE
	TLNN	%16,BINBIT	;OR BINARY SPECIFIED?
	JRST	ERRIC		;YES, ILLEGAL CHARACTER
	MOVE	%00,[INIT CMD,ALMODE]
	SKIPN	%01		;INIT CMD FOR @ FILE
	MOVSI	%01,(SIXBIT /DSK/)
	MOVEI	%02,CMDBUF
	PUSHJ	%17,CMDSET
	XWD	INBIT,1_ALMODE	;LEGAL BITS FROM DEVCHR
	TRZE	%16,EXTBIT	;EXTENSION?
	JRST	INDFI1		;YES, DON'T TRY ASSUMPTIONS
	MOVSI	%14,(SIXBIT /CMD/)
	HLLZM	%14,XE1
	LOOKUP	CMD,XE
	TDZA	%14,%14		;TRY NULL EXTENSION
	JRST	INDFI2
INDFI1:	HLLZM	%14,XE1
	LOOKUP	CMD,XE
	JRST	ERRCF		;CANNOT FIND COMMAND FILE
INDFI2:	SETOM	CCLFLA		;NON-STANDARD COMMAND STRING
	SETOM	INDFLA		;SET INDIRECT FLAG
	INBUF	CMD,1		;SINGLE BUFFER
	MOVE	%14,JOBFF
	HRLM	%14,JOBFFI	;SAVE DATA RESTORE ADDRESS
	JRST NXTCCL

>

ER:	PUSHJ	%17,ACEXCH	;YES, SAVE THE ACCUMULATORS
	PUSH	%17,%16		;SAVE CURRENT FLAGS
	TLO	%16,NSWBIT!LOHBIT ; NO TTY OUTPUT, FLAG HDR OUT
	MOVEI	%02,FF		;GET A FORM FEED
	PUSHJ	%17,LSTDMP	;OUTPUT IT
	MOVEI	%10,PAGSIZ+3	;RESET LINE COUNTER REGISTER
	MOVEM	%10,LINCNT	;...
	MOVE	%00,PRGTTL
	PUSHJ	%17,LSTSYM	;LIST PROGRAM TITLE
	PUSHJ	%17,LSTTAB
	MOVE	%00,TITLE
	PUSHJ	%17,LSTSIX
	PUSHJ	%17,LST3SP
	MOVE	%00,ASMVER	;PRINT VERSION NO.
	PUSHJ	%17,LSTSIX
	PUSHJ	%17,LST3SP

;THE FOLLOWING SECTION PRINTS THE DATE, WHICH IS FOUND IN
;REGISTER XDATE IN THE FORM
;	((Y-1964)*12 + (M-1))*31 + (D-1)
	MOVE	%10,DATE	;GET THE DATE IN %10
	IDIVI	%10,^D31	;DIVIDE BY 31 DECIMIAL
	ADDI	%11,1
	PUSHJ	%17,DNC		;OUTPUT DAY
	IDIVI	%10,^D12	;DIVIDE BY 12 DECIMAL
	MOVE	%00,MONTH(%11)
	PUSHJ	%17,LSTSIX	;OUTPUT THE MONTH, (M-1) IS IN %12
	MOVEI	%11,^D64(%10)	;GET THE YEAR
	PUSHJ	%17,DNC		;TYPE IT
	PUSHJ	%17,LST3SP	;OUTPUT TAB

;THE FOLLOWING SECTION OF CODE PRINTS THE TIME, WHICH IS
;PICKED UP FROM THE MONITOR AS THE NUMBER OF MILLISECONDS
;SINCE MIDNIGHT. THE FORMAT OF THE TIME PRINTOUT IS HH:MM
	MOVE	%11,MSTIME	;GET THE CURRENT TIME
	IDIVI	%11,^D60*^D1000	;NUMBER OF MIN. SINCE MIDNITE
	IDIVI	%11,^D60	;NUMBER OF HOURS
	PUSH	%17,%12		;SAVE MINUTES
	PUSHJ	%17,DNC		;OUTPUT THE HOURS
	MOVEI	%02,":"		;OUTPUT A COLON AFTER THE HOURS
	PUSHJ	%17,LSTDMP	;OUTPUT IT
	POP	%17,%11		;PUT MINUTES IN OUTPUT AC
	MOVEI	%02,"0"		;GET AN ASCII ZERO
	CAIG	%11,^D9		;IS IT A ONE-DIGIT NUMBER?
	PUSHJ	%17,LSTDMP	;YES, OUTPUT A ZERO
	PUSHJ	%17,DNC		;OUTPUT THE MINUTES


;THIS  SECTION OF CODING PICKS UP THE WORD "PAGE " AND
;STORES IT IN THE PROPER PLACE IN THE TITLE BUFFER.
	PUSHJ	%17,LST3SP
	MOVE	%00,[SIXBIT /PAGE/]
	PUSHJ	%17,LSTSIX	;PRINT "PAGE"
	MOVEI	%02," "
	PUSHJ	%17,LSTDMP	;SPACE
	MOVE	%11,PAGNUM	;GET PAGE NUMBER
	PUSHJ	%17,DNC		;CONVERT TO DECIMAL AND PRINT
	MOVEI	%10,[ASCIZ //]	;ASSUME NO EXTENSION
	AOSE	%11,PAGEXT	;INCREMENT, PICK UP, AND TEST
	MOVEI	%10,[ASCIZ /-5/]
	PUSHJ	%17,LSTMSG	;LIST IT
	PUSHJ	%17,LSTCR

;THE FINAL SECTION OF CODE PICKS UP A SUBTITLE (IF AVAILABLE)
;AND PUTS IT ON THE SECOND LINE OF THE PAGE
	TLNN	%16,SBTBIT	;DO WE HAVE A SUBTITLE?
	JRST	NOSBTL		;NONE SEEN
	MOVEI	%10,SUBMSG	;GET ADDRESS OF SUBTITLE BUFFER
	PUSHJ	%17,LSTMSG	;AND PRINT IT
	PUSHJ	RLINK,LSTCR	; END THE LINE.

NOSBTL:	PUSHJ	%17,LSTCR	;SECOND LINE CRLF
	POP	%17,%02		;RESTORE FLAGS
	TLNN	%02,NSWBIT
	TLZ	%16,NSWBIT
	JRST	ACEXCH		;RESTORE F4 REGS AND EXIT

DNC:	IDIVI	%11,^D10	;RECURSIVE SUBROUTINE
	HRLM	%12,0(%17)	;SAVE REMAINDER ON PUSHDOWN LIST
	SKIPE	%11		;ALL DONE?
	PUSHJ	%17,DNC		;NO, CALL DNC AGAIN
	HLRZ	%02,0(%17)	;RETRIEVE NUMBER FROM PD LIST
	JRST	LSTNUM		;LIST NUMERIC AND EXIT

LSTSIX:	MOVSI	%06,(POINT 6,%00,)
LSTSI1:	ILDB	%02,%06
	JUMPE	%02,CPOPJ
	ADDI	%02," "
	PUSHJ	%17,LSTOUT
	TLNE	%06,770000
	JRST	LSTSI1
	POPJ	%17,

MONTH:	SIXBIT	/-JAN-/
	SIXBIT	/-FEB-/
	SIXBIT	/-MAR-/
	SIXBIT	/-APR-/
	SIXBIT	/-MAY-/
	SIXBIT	/-JUN-/
	SIXBIT	/-JUL-/
	SIXBIT	/-AUG-/
	SIXBIT	/-SEP-/
	SIXBIT	/-OCT-/
	SIXBIT	/-NOV-/
	SIXBIT	/-DEC-/

;CALL:	PUSHJ	%17,CMDSET
;	XWD	BITS1,BITS2	;LEGAL BITS ON DEVCHR
;	RETURN

CMDSET:	MOVE	%03,%01		;GET DEVICE NAME
	DEVCHR	%03,
	SETCMM	%03		;COMPLEMENT BITS
	TDNE	%03,@(%17)	;WERE ALL BITS ONE?
	JRST	ERRNIT		;NO
	AOS	(%17)		;YES, SKIP RETURN
				;FULL THROUGH


INISET:	MOVE	%03,[JRST ERRNA];ERROR EXIT FOR INIT
	MOVSI	%04,(POPJ %17,)
	JRST	%00

	SUBTTL	EXEC ERROR ROUTINES

ERRCMD:	MOVEI	%10,[ASCIZ /DEVICE INPUT ERROR FOR COMMAND STRING/]
	JRST ERROR

ERRNIT:	MOVEI	%10,[ASCIZ /IMPROPER IO FOR DEVICE 2/]
	JRST ERROR

IFN CCLSW,<
ERRCF1:	SETZM	CCLFLA		;LOOKUP FOR DSK:###P11.TMP FAILED
>


ERRCF:	MOVEI	%10,[ASCIZ /CANNOT FIND 234/]
	JRST	ERROR

ERRID:	MOVEI	%10,[ASCIZ /INPUT DATA ERROR 234/]
	JRST	ERROR

ERRBS:	MOVEI	%10,[ASCIZ /1 IS A BAD SWITCH/]
	JRST	ERROR

ERRIC:	MOVEI	%10,[ASCIZ /1 IS AN ILLEGAL CHARACTER/]
	JRST	ERROR

ERRNA:	MOVEI	%10,[ASCIZ /2 IS NOT AVAILABLE/]
	JRST	ERROR

ERRNR:	MOVEI	%10,[ASCIZ /NO ROOM FOR 234/]
	JRST	ERROR

ERRSE:	MOVEI	%10,[ASCIZ /SYNTAX ERROR IN COMMAND STRING/]
	JRST	ERROR

ERRNC:	MOVEI	%10,[ASCIZ /INSUFFICIENT CORE/]
	JRST	ERROR

ERRWF:	MOVEI	%10,[ASCIZ /1 ILLEGAL SWITCH FOR INPUT/]
	JRST	ERROR

ERRTF:	MOVEI	%10,[ASCIZ /TOO MANY INPUT FILES/]
	JRST	ERROR

ERRTB:	MOVEI	%10,[ASCIZ /2 ILLEGAL FOR BINARY OUTPUT/]
	JRST	ERROR

IFN CMUSW,<
ERRUID:	MOVEI	%10,[ASCIZ /ILLEGAL USERID/]
	JRST	ERROR
>

R:				;NON-RECOVERABLE ERROR MESSAGE
	PUSH	%17,%10		;STACK MESSAGE ADDRESS
	TRNE	%16,MODBIT	;HAVE WE EXEC AC'S?
	PUSHJ	%17,ACEXCH	;  NO, GET THEM
	POP	%17,%10		;RESTORE MESSAGE POINTER
	MOVSI	%16,ERRBIT!LSTBIT!BINBIT	;FUDGE FLAGS
	PUSHJ	%17,LSTCR
	MOVEI	%02,"?"
	PUSHJ	%17,LSTOUT
	PUSHJ	%17,LSTSP	;TYPE SPACE
	PUSHJ	%17,LSTMCR
	PUSHJ	%17,LSTCR
	JRST	START

LSTMCR:	PUSHJ	%17,LSTMSG
	JRST	LSTCR		;LIST MESSAGE AND CRR

LSTMSG:	TLOA	%10,(POINT 7,,)	;SET BYTE POINTER AND SKIP
LSTMS4:	PUSHJ	%17,LSTOUT	;TYPE CHARACTER
LSTMS5:	ILDB	%02,%10		;GET CHARACTER
	JUMPE	%02,CPOPJ	;TEST FOR END
	CAIL	%02,"1"		;TEST FOR SWITCH
	CAILE	%02,"5"
	JRST	LSTMS4		;NO, TYPE THE CHARACTER
	PUSHJ	%17,@[EXP ERR1,ERR2,ERR3,ERR4,DNC]-"1"(%02)
	JRST	LSTMS5		;GET NEXT CHARACTER

ERR1:	MOVE	%02,%05		;GET IMPROPER CHARACTER
	JRST	LSTOUT		;DUMP IT

ERR2:	MOVE	%00,%01		;GET DEVICE NAME
	PUSHJ	%17,LSTSIX	;TYPE IT
	MOVEI	%02,":"
	JRST	LSTOUT		;TYPE ":"

ERR3:	MOVE	%00,XE		;GET FILE NAME
	JRST	LSTSIX		;TYPE IT

ERR4:	HLLZ	%00,XE1		;GET EXTENSION
	JUMPE	%00,CPOPJ	;EXIT IF NULL
	MOVEI	%02,"."
	PUSHJ	%17,LSTOUT	;TYPE "."
	JRST	LSTSIX

:	CLOSE	SRC,		;CLOSE THE SOURCE DEVICE
	CLOSE	LST,		;CLOSE THE LISTING FILE
	CLOSE	BIN,		;CLOSE THE BINARY FILE
	TLON	%16,LSTBIT	;WAS THERE A LISTING FILE?
	PUSHJ	%17,LSTTST	;YES, TEST FOR FINAL ERROR
	TLON	%16,BINBIT	;IS THERE A BINARY FILE?
	PUSHJ	%17,BINTST	;YES, TEST FOR FINAL ERROR
	TRNN	%16,ENDBIT	;END OF COMMAND STRING?
	JRST	ERRTF		;  NO, MARK ERROR
IFN CCLSW,<
	SKIPN	CCLFLA		;RESTART IF NOT CCL MODE
	JRST	START
	HLRZ	%00,JOBFFI
	MOVEM	%00,JOBFF	;RESTORE DATA AREA

	RELEAS	LST,0
	RELEAS	BIN,0
	RELEAS	SRC,0
EXIT6:	PUSHJ	%17,GETCMD	;GET NEXT COMMAND CHAR
	CAIL	%05,12		;THROW AWAY REST
	CAILE	%05,15		;OF LAST LINE
	CAIA
	JRST	EXIT6
	MOVSI	%05,070000	;BACK UP BYTE
	ADDM	%05,CMDPNT	;POINTER ONE BYTE
	AOS	CMDCNT
	JRST	NXTCCL		;GO DO NEXT COMMAND
>
IFE CCLSW,<
	JRST	START		;BACK TO BEGINNING

>

CORSET:				;INIT DYNAMIC MEMORY
	HRRZ	%00,JOBREL	;GET TOP OF CORE
	MOVEM	%00,SYMTOP
	SUBI	%00,2		;GET POINTER TO BOTTOM OF TABLE
	MOVEM	%00,SYMBOT	;STORE IT
	MOVSI	%00,(1B0)
	MOVEM	%00,@SYMBOT	;STORE LOWER BUMPER
	SETCAM	%00,@SYMTOP	;  AND UPPER BUMPER
	JRST	SRCHI		;INITIALIZE THE SYMBOL TABLE AND RETURN


ACEXCH:				;SWAP AC'S
	TRC	%16,MODBIT	;TOGGLE MODE BIT
	EXCH	%00,AC00
	EXCH	%01,AC01
	EXCH	%02,AC02
	EXCH	%03,AC03
	EXCH	%04,AC04
	EXCH	%05,AC05
	EXCH	%06,AC06
	EXCH	%07,AC07
	EXCH	%10,AC10
	EXCH	%11,AC11
	EXCH	%12,AC12
	EXCH	%13,AC13
	EXCH	%14,AC14
	POPJ	%17,

;ROUTINE TO OUTPUT RELOCATABLE BINARY


BINWRD:				;OUTPUT BINARY WORD
	PUSH	%17,%02		;STACK WORD
	PUSHJ	%17,BINOUT	;OUTPUT LOW BYTE
	POP	%17,%02
	LSH	%02,-8		;MOVE HIGH INTO LOW
				;FALL THROUGH

BINOUT:				;BINARY OUTPUT
	ANDI	%02,377		;MASK TO 8 BITS
	ADDM	%02,CHKSUM	;UPDATE CHECKSUM
BINOU2:	TLNE	%16,BINBIT	;BINARY REQUESTED?
	POPJ	%17,		;  NO, EXIT
	TLNN	%15,PSWFLG	;PACKED MODE?
	JRST	BINOU3		;  YES
	SOSG	BINCNT
	PUSHJ	%17,BINDMP
	IDPB	%02,BINPNT
	POPJ	%17,

BINOU3:	PUSH	%17,%03
	SOSLE	BINPCT
	JRST	BINOU4
	PUSHJ	%17,BINDMP
	MOVE	%03,BINCNT
	IMULI	%03,4
	MOVEM	%03,BINPCT
BINOU4:	MOVN	%03,BINPCT
	ANDI	%03,3
	JUMPN	%03,BINOU5
	SOS	BINCNT
	IBP	BINPNT
BINOU5:	DPB	%02,BINTBL(%03)
	POP	%17,%03
	POPJ	%17,

BINDMP:	OUTPUT	BIN,
BINTST:	STATO	BIN,IODATA!IODEV!IOWRLK
	POPJ	%17,
	MOVEI	%10,[ASCIZ /BINARY OUTPUT ERROR/]
	JRST	ERROR		;TYPE ERROR MESSAGE

BINTBL:
	POINT	8,@BINPNT,17
	POINT	8,@BINPNT, 9
	POINT	8,@BINPNT,35
	POINT	8,@BINPNT,27

	SUBTTL	EXEC ROUTINES USING ASSEMBLER AC'S

LSTSYM:				;LIST SYMBOL
	PUSH	%17,%00
	TLNN	%00,777600	; IS THIS A LOCAL SYMBOL?
	JRST	LSTLOC		; -- YES -- DECODE ITS NAME
				; -- NO -- SYMBOL IS IN MOD40
	PUSHJ	%17,M40SIX	;CONVERT TO SIXBIT
	PUSH	%17,%01		;STACK A WORKING REGISTER
	MOVSI	%01,(POINT 6,%00)
LSTSY1:	ILDB	%02,%01
	ADDI	%02,40		;CONVERT TO ASCII
	PUSHJ	%17,LSTOUT
	TLNE	%01,770000	;TEST FOR END
	JRST	LSTSY1
LSTRET:	POP	%17,%01
	POP	%17,%00		;RESTORE ORIGINAL
	POPJ	%17,


;	   *****  LIST A LOCAL SYMBOL  *****

;	SYMBOL'S NUMERIC PART IS A 7-BIT NON-ZERO BINARY
;	INTEGER IN THE LEFT HALF OF R0.

LSTLOC:	HLRZ	%00,%00		; ALIGN NUMERIC PART IN RIGHT HALF
	PUSH	RLINK,%01	; SAVE WORKING REGS
	PUSH	RLINK,%03
	MOVEI	%03,6		; INIT BYTE COUNT TO 6
				; FOR COUNT DOWN TO 0.

;	   CONVERT NUMERIC PART OF SYMBOL TO DECIMAL.

LSTL1:	IDIVI	%00,^D100	; PICK OFF 1ST DIGIT.
	JUMPN	%00,LSTL2
	EXCH	%00,%01		; DIGIT 1 = 0 -- CHECK 2ND DIGIT
	IDIVI	%00,^D10
	JUMPN	%00,LSTL3
	JRST	%00,LSTLAS	; DIGIT 2 = 0 -- LIST LAST DIGIT

LSTL2:	MOVE	%02,%00
	PUSHJ	RLINK,LSTNUM	; LIST HUNDREDS DIGIT.
	EXCH	%00,%01
	SOS	%03
	IDIVI	%00,^D10	; DIVIDE TO GET LAST 2 DIGITS.

LSTL3:	MOVE	%02,%00
	PUSHJ	RLINK,LSTNUM	; LIST TENS DIGIT
	SOS	%03

LSTLAS:	MOVE	%02,%01		; LIST UNITS DIGIT.
	PUSHJ	RLINK,LSTNUM
	SOS	%03

	MOVEI	%02,"$"		; SUPPLY "$" SUFFIX
	PUSHJ	RLINK,LSTOUT
	SOS	%03

LSTL4:	PUSHJ	RLINK,LSTSP	; PAD TO 6 BYTES WITH SPACES
	SOJG	%03,LSTL4

	POP	RLINK,%03	; RESTORE WORK REGS & RETURN
	JRST	LSTRET
LST3SP:				;LIST SPACES
	PUSHJ	%17,LSTSP
LST2SP:	PUSHJ	%17,LSTSP
LSTSP:	MOVEI	%02,SPACE
	JRST	LSTOUT

LSTNUM:	TROA	%02,"0"		;LIST NUMERIC
LSTASC:	ADDI	%02,40		;CONVERT SIXBIT TO ASCII
	JRST	LSTOUT

LSTCR:	TDZA	%02,%02		;LIST CR-LF
LSTTAB:	MOVEI	%02,TAB		;LIST A TAB
LSTOUT:				;LISTING ROUTINE
	TLNN	%16,LSTBIT!RSWBIT	;LISTING REQUESTED?
	PUSHJ	%17,LPTOUT	;  YES
	TLNE	%16,ERRBIT	;ERROR LISTING?
	TLNE	%16,NSWBIT!TTYBIT	;  YES, TO TTY?
	POPJ	%17,		;  NO
	JUMPE	%02,LSTOU1	;BRANCH IF CR-LF
	OUTCHR	%02		;LIST CHARACTER
	POPJ	%17,		;EXIT

LSTOU1:	OUTSTR	[BYTE (7) CRR, LF, 0]
	POPJ	%17,		;CR-LF TO TTY

LPTOUT:				;OUTPUT TO LISTING DEVICE
	SKIPGE	LSTCNT		;IF LIST LEVEL IS NEGATIVE
	POPJ	17,		;THEN DON'T LIST
LPTOUA:	TRZE	%16,HDRBIT	;TIME FOR A HEADING?
	PUSHJ	%17,HEADER	;  YES
	JUMPE	%02,LPTOU4	;BRANCH IF CR-LF
	CAIN	%02,TAB
	JRST	LPTOU3		;DON'T LIST TABS IMMEDIATELY
	SKIPG	TABCNT		;ANY TABS TO BE OUTPUT?
	JRST	LPTOU2		;  NO
	PUSH	%17,%02		;YES, STACK CURRENT CHARACTER
LPTOU1:	MOVEI	%02,7
	IORM	%02,COLCNT	;FUDGE COLUMN COUNT
	MOVEI	%02,TAB
	PUSHJ	%17,LPTOU2	;OUTPUT THE TAB
	SOSE	TABCNT		;DECREMENT, ANY MORE?
	JRST	LPTOU1		;YES
	POP	%17,%02		;NO, RESTORE CHARACTER

LPTOU2:	AOSG	COLCNT		;ANY COLUMNS AVAILABLE?
	JRST	LSTDMP		;  YES
	POPJ	%17,		;  NO, EXIT

LPTOU3:	AOS	TABCNT		;TAB, BUMP COUNT
	POPJ	%17,

LPTOU4:	MOVEI	%02,CRR		;CR-LF
	PUSHJ	%17,LSTDMP
	MOVEI	%02,LF
	PUSHJ	%17,LSTDMP
	SOSG	LINCNT		;END OF PAGE?
LPTINI:	TRO	%16,HDRBIT	;  YES, SET FLAG
	MOVNI	%02,COLLPT	;SET FOR COLUMN COUNT
	HRRZ	%00,LSTCTL	; LOAD LIST CONTROL FLAGS
	TRNE	%00,LTTM	; IS IT TTY MODE?
	MOVNI	%02,COLTTY
	MOVEM	%02,COLCNT
	SETZB	%02,TABCNT	;ZERO TAB COUNT AND REGISTER
	POPJ	%17,

LSTDMP:	SOSG	LSTBCT		;DECREMENT ITEM COUNT
	PUSHJ	%17,LIST1	;EMPTY ENTIRE BUFFER
	IDPB	%02,LSTPNT	;STORE THE CHARACTER
	CAIN	%02,LF		;IF LINE FEED
	TLNN	%16,TTYBIT	;AND LISTING IS ON TTY,
	POPJ	%17,
				;DUMP THE BUFFER


LIST1:	TLNE	%16,LSTBIT	; IS LISTING BEING SUPPRESSED?
	POPJ	RLINK,		; .. YES - JUST RETURN.

	OUTPUT	LST,		;EMPTY A BUFFER
LSTTST:	STATO	LST,IODATA!IODEV!IOWRLK	;CHECK FOR ERRORS
	POPJ	%17,		;NO, EXIT
	MOVEI	%10,[ASCIZ /LISTING OUTPUT ERROR/]
	JRST	ERROR		;TYPE MESSAGE

;	   CODE BETWEEN CHARB AND CHAR SAVES A SEQUENCE NUMBER
;	   OF THE SORT SUPPLIED BY SOS AND SOME OTHER EDITORS.

;	THE SEQUENCE NUMBER IS IDENTIFIED BY FINDING THE LOW ORDER
;	BIT OF A DATA WORD SET TO 1; THE WORD ORDINARILY CONTAINS
;	FIVE 7-BIT BYTES, LEFT ADJUSTED.

CHARB:	MOVEM	%14,SEQNUM	;SAVE SEQUENCE NUMBER
	AOS	SRCPNT		;INCREMENT POINTER PAST WORD
	MOVNI	%14,5		;GET -5
	ADDM	%14,SRCCNT	;SUBTRACT 5 FROM WORD COUNT
	TRO	%16,SEQBIT

CHAR:	JUMPN	%12,CHAR2	;BRANCH IF IN MACRO
	SOSGE	SRCCNT		;DECREMENT ITEM COUNT
	JRST	CHAR4		;GET ANOTHER BUFFER IF NECESSARY
	IBP	SRCPNT		;INCREMENT THE BYTE POINTER
	MOVE	%14,@SRCPNT	;PICK UP AN ENTIRE WORD FROM BUFFER
	TRZE	%14,1		;IS THE SEQUENCE NUMBER BIT ON?
	JRST	CHARB		;YES, SKIP AROUND IT
	LDB	%14,SRCPNT	;NO, PICK UP A GOOD CHARACTER
CHAR1:	LDB	%02,C7PNTR	;MAP
	XCT	CHARTB(%02)	;DECIDE WHAT TO DO
	POPJ	%17,		;ACCEPT IT

CHAR2:	PUSHJ	%17,READMC	;GET A CHARACTER FROM MACRO TREE
	 JRST	CHAR		;  NULL, TRY AGAIN
	TLO	%16,MEXBIT	; SHOW MACRO EXPANSION IN PROGRESS
	JRST	CHAR1		; CHECK THE CHARACTER

CHAR4:	INPUT	SRC,		;CALL MONITIOR FOR A BUFFER
	STATZ	SRC, IODATA+IODEV+IOBKTL+IOWRLK
	JRST	ERRID		;INPUT TRANSMISSION ERROR
	STATO	SRC, IOEOF	;WAS AN END OF FILE REACHED?
	JRST	CHAR		;GET NEXT CHAR
CHAR5:	CLOSE	SRC,
	TRNN	%16,ENDBIT	;CRR SEEN BY COMMAND SCANNER?
	JRST	CHAR6		;  NO, GET NEXT SOURCE
	TLO	%15,ENDFLG	;YES, FLAG END
	MOVEI	%14,LF		;MAKE IT A LINE
	POPJ	%17,

CHAR6:	PUSHJ	%17,ACEXCH	;GET EXEC AC'S
	PUSHJ	%17,GETSRC	;GET THE NEXT SOURCE FILE
	TRO	%16,HDRBIT	;START NEW FILE
	PUSHJ	%17,ACEXCH	;SAVE EXEC AC'S AND RETURN
	JRST	CHAR


CHARTB:				;CHARACTER JUMP TABLE
	PHASE	0
	MOVEI	%14,ILLCHR	;ILLEGAL CHARACTER
QJNU:	JRST	CHAR		;NULL, TRY AGAIN
QJCR:	JFCL			;END OF STATEMENT
QJVT:	MOVEI	%14,LF		;VERTICAL TAB
QJSP:	JFCL			;BLANK
QJPC:	JFCL			;PRINTING CHARACTER
QJLC:	PUSHJ	RLINK,CHFOLD	; LOWER CASE, MAYBE FOLD
	DEPHASE


;	   LOWER CASE CHARACTER -- FOLD INTO UPPER CASE
;	   UNLESS .ENABL LC IS IN EFFECT.

CHFOLD:	TLNN	RMODE,LCFLG	; IS LOWER CASE ENABLED?
	SUBI	%14,40		; NO - FOLD INTO UPPER CASE.
	POPJ	RLINK,

TTL	ASSEMBLER PROPER
;	THESE ARE THE LISTING ERROR FLAGS.

ERRA=	400000
ERRB=	200000
ERRD=	100000
ERRE=	040000
ERRI=	020000
ERRL=	010000
ERRM=	004000
ERRO=	002000
ERRP=	001000
ERRQ=	000400
ERRR=	000200
ERRT=	000100
ERRU=	000040
ERRN=	000020
ERRZ=	000010		;MARGINAL INSTRUCTION

LISTP1=	000002		; LIST ON PASS 1, EVEN WITHOUT ERROR
ERRP1=	000001

ASSEMB:				;ASSEMBLER PROPER
	TLO	%15,P1F		;SET FOR PASS 1
	MOVE	%03,.MAIN.
	MOVEM	%03,PRGTTL	;INIT TITLE
	MOVE	%03,.ABS.
	MOVEM	%03,SECNAM	;INIT ABSOLUTE SECTOR
	PUSHJ	%17,INIPAS	;INITIALIZE PASS ONE
	PUSHJ	%17,BLKINI	;INITIALIZE BINARY OUTPUT
	PUSHJ	%17,LINE	;GO DO PASS ONE.
IFN CCLSW,<
	PUSHJ	%17,PRNAM	;PRINT THIS PROGRAM'S NAME IF CCL
>
	TLZ	%15,P1F		;RESET TO PASS 2
	TRO	%16,HDRBIT	; FORCE PAGE SKIP AFTER TOC.
	PUSHJ	%17,SETP2	;RESET INPUT COMMAND STRING
	PUSHJ	%17,INIPAS
	PUSHJ	%17,LINE	;CALL THE ASSEMBLER (PASS TWO)

	TLNE	%16,LSTBIT!RSWBIT	;LISTING?
	MOVE	%00,LSTCTL	; LOAD LISTING CONTROL FLAGS
	TRNE	%00,LSYM	; SYM TAB BIT SET?
	PUSHJ	RLINK,SYMTB	; YES - LIST SYMBOL TABLE.
	POPJ	RLINK,


INIPAS:
	MOVEI	%00,OCTRDX	;SET DEFAULT GLOBAL RADIX TO OCTAL
	MOVEM	%00,GLBRDX
	MOVEI	%00,LDEF	; SET DEFAULT LISTING MODES
	MOVEM	%00,LSTCTL
	TLO	RMODE,NSFBIT	; ENABLE NONSTANDARD FEATURES
	TLZ	%15,TRNFLG!AMAFLG!LSBFLG	; CLEAR A FEW MODE FLAGS
	TLNE	%15,ABSFLG	;ABSOLUTE?
	TDZA	%05,%05		;  YES, SET PC TO ZERO
	MOVSI	%05,(1B<SUBOFF>)	;  NO, SET TO RELOCATABLE
	MOVSI	%03,-^D256
	SETZM	SECBAS(%03)	;INIT SECTOR BASES
	AOBJN	%03,.-1
	SETZ	%12,
	MOVEI	%00,1
	MOVEM	%00,PAGNUM	;INITIALIZE PAGE NUMBER
	SETOM	PAGEXT		;  AND EXTENSION
	SETZM	SEQ		; SET LINE SEQ # = 0.
	SETZM	LSBLOC		; LOCAL SYMBOL BLOCK # = 0.
	SETZM	REPLVL
	SETZM	CONLVL
	SETZM	LSTCNT		; RESET LIST LEVEL
	SETZM	P10CNT		;CLEAR ".PDP10" COUNT
	JRST	ENDLI		;EXIT THROUGH END OF LINE ROUTINE


LINE:				;PROCESS ONE LINE
	PUSHJ	%17,GETLIN	;GET A SOURCE LINE
	PUSHJ	%17,STMNT	;PROCESS ONE STATEMENT
	PUSHJ	%17,ENDL	;PROCESS END OF LINE
	TLZN	%15,ENDFLG	;TEST FOR END STATEMENT
	JRST	LINE		;GET THE NEXT LINE
	JRST	ENDP		;END OF PASS

.MAIN.:	GENM40	.,M,A,I,N,.

.ABS.:	GENM40	., ,A,B,S,.

GETLIN:				;GET THE NEXT SOURCE LINE
	TLZ	%16,NLISLN!MEXBIT  ; RESET LIST-RELATED FLAGS.
	SKIPE	FLTBUF		;SPREAD FLOATING TO LIST?
	JRST	GETLI7		;  YES
	AOS	SEQ		; INCREMENT LINE SEQUENCE #
	MOVEI	%06,1		;SET COUNT TO FIRST CHAR
	MOVE	%13,LINPNT	;SET POINTER
GETLI1:	PUSHJ	%17,CHAR	;GET AN INPUT CHARACTER
	CAIN	%14,FF		;FORM FEED?
	TROA	%16,FFBIT	;  YES, FLAG AND SKIP
	CAIN	%14,LF		;OR LINE FEED?
	JRST	GETLI5		;  YES, END OF LIE
	CAIG	%06,CPL1	;PAST NORMAL END?
	JRST	GETLI4		;  NO, STORE IT
	CAIE	%06,CPL1+1	; YES - IS THIS THE MAGIC
	JRST	GETLI3		; COLUMN FOR CDR MODE?

;	   NEXT BYTE IS IN COLUMN 73 OF INPUT LINE.  IF
;	   .ENABL CDR WAS ISSUED, INPUT IS CARD IMAGES; IN
;	   THIS CASE SUPPLY AN END-LOGICAL-LINE CHARACTER
;	   IN ORDER TO TREAT SEQUENCE NUMBERS IN 73-80
;	   AS COMMENTARY INFORMATION.

	TLNN	RMODE,CDRFLG	; READING CARD IMAGES?
	JRST	GETLI3		; NO - CHECK FOR OVERFLOW.
	MOVEI	%11,ELLCHR	; YES - SET END LINE CHARACTER
	IDPB	%11,%13		;  AND STORE IN BUFFER
	JRST	GETLI4		;ALSO STORE NORMAL CHAR

GETLI3:	CAIGE	%06,CPL3	;NORMAL MODE, SKIP IF OVERFLOW
	JRST	GETLI4		;  OK, STORE IT
	TRO	%15,ERRL	;  NO, FLAG ERROR
	JRST	GETLI1		;DON'T STORE IN EITHER CASE

GETLI4:	IDPB	%14,%13		;OK, STORE CHARACTER IN BUFFER
	AOJA	%06,GETLI1	;BUMP COUNT AND LOOP

GETLI5:	IDPB	%14,%13		;END OF LINE, STORE
	SETZ	%14,
	IDPB	%14,%13		;STORE NULL FOR EASY REFERENCE
GETLI6:	SETZM	FLTBUF		;BE SURE FLTBUF IS CLEAR
	TLNE	%15,ENDFLG	;PERCHANCE END OF FILE?
	TRO	%15,ERRE	;  YES, FLAG "NO END STATEMENTT"
	MOVE	%13,LINPNT	;SET FOR READ
	JRST	GETNB		;RETURN WITH FIRST NON-BLANK

GETLI7:	MOVE	%06,[XWD FLTBUF,LINBUF]	;FLOATING TO LIST
	BLT	%06,LINBUF+^D10	;  MOVE IT
	JRST	GETLI6		;EXIT NORMAL

LINPNT:	POINT	7,LINBUF,	;POINTER TO START OF LINE

ENDLR:				;SUPPRESS IF /R
	TLO	%15,RSWFLG	;SET LOCAL FLAG

ENDL:				;END OF LINE PROCESSOR
	TLZ	%16,LOHBIT	; RESET HEADER PRINTED FLAG
	TLNE	%15,P1F
	JRST	ENDLFA		;BYPASS IF PASS 1
	MOVE	%11,RBPTR	; SAVE POINTER TO CURRENT BYTE.
	PUSHJ	%17,SETNB	;SET FIRST NON-BLANK
	CAIE	%14,0		;IF NULL
	CAIN	%14,";"		;OR SEMI-COLON
	JRST	ENDL1		;  BRANCH O.K.

	SETZ	%11,		; NOT AT A COMMENT - CLEAR %11
				; TO SHOW NO COMMENT
	CAIN	%14,CRR		;CARRIAGE RETURN?
	PUSHJ	%17,GETCHR	;  YES, BYPASS IT
	CAIE	%14,LF		;IF LINE FEED
	CAIN	%14,FF		;  OR FORM FEED,
	CAIA			;  O.K.
	TRO	%15,ERRQ	;OTHERWISE FLAG Q ERROR
ENDL1:	TLNN	%16,RSWBIT	;TEST FOR REPRODUCTION OF SOURCE LINE
	JRST	ENDLF		;  NOT REQUESTED
	TLNE	%15,RSWFLG	;IF LINE SHOULD BE REPRODUCED
	SKIPE	LBLPNT		;  OR IF LABEL ENCOUNTERED
	CAIA			;SKIP
	JRST	ENDLF		;  ELSE SKIP
	SKIPA	%01,LINPNT	;SET TO LIST SOURCE
ENDL1A:	PUSHJ	%17,LSTDMP	;LIST A CHARACTER
	ILDB	%02,%01		;GET THE NEXT CHARACTER
	CAIN	%02,ELLCHR	;END OF LOGICAL LINE CHAR?
	JRST	ENDL1A		;  YES, DON'T LIST
	TLNE	%15,RSWFLG	;UNCONDITIONAL?
	CAME	%01,LBLPNT	;  NO, LABELS FINISHED?
	JUMPN	%02,ENDL1A	;OK, BRANCH IF NOT END
	JUMPE	%02,ENDLF	;BRANCH IF END OF LINE
	PUSHJ	%17,LSTDMP	;LIST COLON
	MOVEI	%02,CRR
	PUSHJ	%17,LSTDMP	;CR/LF
	MOVEI	%02,LF
	PUSHJ	%17,LSTDMP

ENDLF:				;ENDL FIN
;	   THE NEXT FEW LINES HANDLE .NLIST COM.  THE CODE
;	   FOLLOWING LOCATION ENDL HAS LEFT %11 AS . . .
;		0 IF FIRST UNPARSED TEXT ISN'T COMMENT, OR
;		BYTE POINTER TO BEGINNING OF COMMENT.

	JUMPE	%11,ENDLFA	; SKIP COM CHECK IF NOT AT COMMENT.
	SETZ	%02,		; PREPARE NULL BYTE IN %02
	MOVE	%00,LSTCTL	; LOAD LISTING CONTROL FLAGS.
	TRNN	%00,LCOM	; ARE COMMENTS BEING LISTED?
	DPB	%02,%11		; NO - STORE NULL AT COM START.

;  WHEN THE LINE IS LISTED LATER THE NULL BYTE IS TAKEN AS
;  A SIGNAL TO STOP LISTING THE LINE.  THE CODE IMMEDIATELY
;  PRECEDING LOCATION ENDL10 HANDLES THIS.

ENDLFA:	SETZM	CODPNT		;INITIALIZE FOR CODE OUTPUT
	PUSHJ	%17,PROCOD	;PROCESS CODE
	 JFCL			;  NO CODE, IGNORE THIS TIME
ENDLC:	TRZN	%15,ERRP1!LISTP1	; LIST ON PASS 1?
	TLNN	%15,P1F		;  NO, ARE WE IN PASS2?
	CAIA			;  YES, LIST THIS LINE
	JRST	ENDL11		;PASS 1, NO ERRORS, DON'T LIST
	PUSHJ	%17,CRFLIN	;OUTPUT CREF
	TRNN	%15,-1		;ANY ERRORS?
	JRST	ENDL6		;  NO

	AOS	ERRCNT		;  YES, TALLY ERROR COUNT
	TLZ	%16,NLISLN	; OVERRIDE LINE LIST SUPPRESSION
	TLO	%16,ERRBIT	;MESSAGE TO TTY
	MOVE	%00,XE		;GET FILE NAME
	TLNN	%16,NSWBIT!TTYBIT
	CAMN	%00,XESAVE
	JRST	ENDL4
	JUMPE	%00,ENDL4
	MOVEM	%00,XESAVE
	MOVSI	%01,(POINT 6,%00,)
ENDL2:	ILDB	%02,%01
	JUMPE	%02,ENDL3
	ADDI	%02,40
	OUTCHR	%02
	TLNE	%01,770000
	JRST	ENDL2
ENDL3:	OUTSTR	[BYTE (7) ":", CRR, LF, 0]
ENDL4:	HRLZ	%00,%15		;PUT FLAGS IN AC0 LEFT
	MOVE	%01,[POINT 7,[ASCII /ABDEILMOPQRTUNZ/],]
ENDL5:	ILDB	%02,%01		;FETCH CHARACTER
	SKIPGE	%00		;THIS CHARACTER?
	PUSHJ	%17,LSTOUT	;  YES
	LSH	%00,1
	JUMPN	%00,ENDL5	;TEST FOR END
ENDL6:	TLNE	%16,NLISLN	; SUPPRESS LIST OF THIS LINE?
	JRST	ENDL11		; YES - JUST CLEAN UP
	MOVE	%00,LINPNT	;TEST FOR NO MORE LISTING
	ILDB	%02,%00		;GET THE FIRST CHARACTER
	CAIN	%02,CRR		;CARRIAGE RETURN?
	ILDB	%02,%00		;  YES, TEST NEXT
	CAIE	%02,LF		;IF LINE FEED
	CAIN	%02,FF		;  OR FORM FEED,
	SETZ	%02,		;DON'T LIST IF NOTHING ELSE
	TDO	%02,PF0
	TDO	%02,PF1
	TDO	%02,SEQNUM
	JUMPE	%02,ENDL10	;BRANCH IF NOTHING TO LIST

;	   *** CHECK FOR MACRO EXPANSION LIST MODES ***

;	.LIST	ME		** LIST ALL GENERATED LINES
;	.NLIST ME, .LIST MEB	** LIST LINES WHICH GEN CODE
;	.NLIST ME, .NLIST MEB	** LIST NO EXPANDED LINES

	TLNN	%16,MEXBIT	; IS MACRO EXPANSION IN PROGRESS?
	JRST	ENDL6A		; ** NO - LIST THE LINE
	TRNE	RERR,-1		; ** YES - IF LINE HAD ERRORS
	JRST	ENDL6A		; LIST IT REGARDLESS OF OPTIONS.
	MOVE	%00,LSTCTL	; // CHECK LISTING MODE //

	TRNE	%00,LME		; IS .LIST ME IN EFFECT?
	JRST	ENDL6A		; ** YES -  LIST THE LINE
	TRNE	%00,LMEB	; ** NO - .LIST MEB IN EFFECT?
	SKIPN	PF0		; %% YES - LIST IFF CODE WAS GEN'D
	JRST	ENDL11

ENDL6A:	PUSHJ	%17,PRNTA	;LIST THE OCTAL
	TRNN	%16,SEQBIT	;ANY SEQUENCE NUMBERS ENCOUNTERED?
	JRST	ENDL8		;  NO

;	   FORMAT A SEQUENCE NUMBER, SUPPLIED BY SOS OR
;	  ONE OF THE OTHER UNFRIENDLY EDITORS.

	PUSHJ	%17,LSTTAB	;OUTPUT A TAB
	MOVE	%00,[POINT 7,SEQNUM,]
ENDL7:	ILDB	%02,%00		;GET A CHARACTER
	JUMPE	%02,ENDL8	;BYPASS IF NULL
	PUSHJ	%17,LSTOUT	;OUTPUT THE NUMBER
	TLNE	%00,760000	;END OF WORD?
	JRST	ENDL7		;  NO, TRY FOR MORE

8:	TRNE	RERR,-1		; DID LINE HAVE ERRORS?
	JRST	ENDL8A		; YES - ALWAYS LIST SOURCE.
	MOVE	%00,LSTCTL	; NO - CHECK FOR .NLIST SRC.
	TRNN	%00,LSRC	; IS SOURCE LIST WANTED?
	JRST	ENDL10		; NO - SKIP IT.

ENDL8A:	PUSHJ	%17,LSTTAB
	SKIPA	%06,LINPNT	;GET SET TO PRINT LINE
ENDL9:	PUSHJ	%17,LSTOUT	;LIST A CHARACTER
ENDL9A:	ILDB	%02,%06		;GET ANOTHER CHARACTER
	CAIN	%02,ELLCHR	;END OF LOGICAL LINE CHAR?
	JRST	ENDL9A		;  YES, DON'T LIST
	CAIN	%02,ILLCHR	;ILLEGAL?
	MOVEI	%02,"?"		;  YES, REPLACE WITH QM
	CAIL	%02,12		;DON'T LIST IF BETWEEN LF
	CAILE	%02,15		;  AND CARRIAGE RETURN
	JUMPN	%02,ENDL9	;TEST FOR END
	JUMPN	%02,ENDL9A	;BRANCH IF CR-LF
ENDL10:	PUSHJ	%17,LSTCR	;END,LIST CR/LF
ENDL11:	PUSHJ	%17,ENDLIF	;SEMI-INIT LINE
	TLO	%15,EXTFLG	;FLAG EXTENSION
	PUSHJ	%17,PROCOD	;PROCESS ADDITIONAL CODE, IF ANY
	JRST	ENDL12		; NONE

;	    ******  BINARY EXTENSION PROCESSING  *******

	TLO	%16,BEXBIT	; FLAG STATE OF LISTING EXTENSION.
	MOVE	%00,LSTCTL	; CHECK LIST OPTIONS --
	TRNN	%00,LBEX	; ARE BINARY EXTENSIONS TO LIST?
	TLO	%16,NLISLN	; NO - DON'T LIST EXTENSION LINES.
	JRST	ENDLC		; IN ANY CASE, GENERATE CODE.

ENDL12:	TRZN	%16,FFBIT	;FORM FEED ENCOUNTERED?
	JRST	ENDLI		;  NO
	AOS	PAGNUM		;YES, BUMP PAGE NUMBER
	SETOM	PAGEXT		;  AND CLEAR EXTENSION
	TLNN	RMODE,P1F	;  IF THIS IS PASS 2 . . .
	TRO	%16,HDRBIT	;SET HEADER BIT
ENDLI:	SETZM	CODPNT
ENDLIF:	AND	%05,[PCMASK]	;CLEAN UP PC
	SETZM	GLBPNT		;CLEAR GLOBAL POINTER
	SETZM	PF0		;CLEAR PRINT WORDS
	SETZM	PF1
	SETZM	PF2
	SETZM	PF3
	SETZM	LBLPNT
	SETZB	%02,SEQNUM
	DPB	%02,[POINT 7,LINBUF,6]	;FLAG LINE
	TRZ	%15,-1
	TLZ	%15,RSWFLG!EXTFLG
	TLZ	%16,ERRBIT!LBLBIT!PF1BIT!BEXBIT
	POPJ	%17,

T:				;STATEMENT PROCESSOR
	PUSHJ	%17,GETSYM	;TRY FOR SYMBOL
	 JRST	STMNT3		;  NO
	CAIN	%14,":"		;LABEL?
	JRST	LABEL		;  YES
	CAIN	%14,"="		;ASSIGNMENT?
	JRST	ASGMT		;  YES
	PUSHJ	%17,MSRCH	;TEST FOR MACRO
	 CAIA
	JRST	STMNT1		;YES
	PUSHJ	%17,OSRCH	;NO, TRY OP TABLE
	 JRST	STMNT2		;TREAT AS EXPRESSION
STMNT1:	PUSH	%17,%01
	TLNE	%00,MACBIT	;SPECIAL TEST FOR OPDEFS
	MOVSI	%01,MAOP	;  SET TO MACRO
	PUSHJ	%17,CRFREF	;CREF IT
	POP	%17,%01		;RETRIEVE VALUE/TYPE
	LDB	%02,TYPPNT	;RESTORE TYPE
	XCT	STMNJT(%02)	;EXECUTE TABLE

STMNJT:				;STATEMENT JUMP TABLE
	PHASE	0
	JRST	STMNT2		;BASIC SYMBOL
MAOP:	JRST	CALLM		;MACRO
OCOP:	JRST	PROPC		;OP CODE
DIOP:	JRST	0(%01)		;PSEUDO-OP
	DEPHASE

STMNT2:	MOVE	%13,SYMBEG	;NON-OP SYMBOL, RESET CHAR POINTER
STMNT3:	PUSHJ	%17,SETNB	;SET CURRENT CHAR
	CAIE	%14,";"		;IF SEMI-COLON
	PUSHJ	%17,TSTNT	;  OR LINE TERMINATOR,
	 POPJ	%17,		;  NULL LINE
	JRST	.WORD		;NEITHER, TREAT AS ".WORD"

LABEL:				;LABEL PROCESSOR
	TLO	%16,LBLBIT	; FORCE PC TO LIST IN
	TLNE	%00,777600	; IS THIS A LOCAL SYMBOL?
	PUSHJ	RLINK,LOCRES	; NO - RESET LOCAL SYMBOL BLOCK

	MOVEM	RLOC,PF0	; PRINT FIELD 0
	PUSHJ	%17,SSRCH	;SEARCH THE SYMBOL TABLE
	 JRST	LABEL1		;  NOT THERE
	TLNE	%01,REGSYM	;REGISTER?
	JRST	LABEL2		;  YES, ERROR
LABEL1:	TLNN	%01,DEFSYM	;PREVIOUSLY DEFINED?
	TDO	%01,%05		;  NO, SET TO CURRENT PC
	MOVE	%03,%01
	TDC	%03,%05		;COMPARE WITH PC
	TDNN	%03,[PCMASK]	;EQUAL ON MEANINGFUL BITS?
	JRST	LABEL3		;  YES
LABEL2:	TLNN	%15,P1F		;NO, PASS 1?
	TLNE	%01,MDFSYM	;NO, MULTIPLY DEFINED ALREADY?
	TLOA	%01,MDFSYM	;  YES, FLAG SYMBOL
	TRO	%15,ERRP	;NO, PHASE ERROR
	CAIA
LABEL3:	TLO	%01,LBLSYM!DEFSYM	;OK, FLAG AS LABEL
	CAMN	%00,M40DOT	;PERCHANCE PC?
	TROA	%15,ERRM	;  YES, FLAG ERROR AND SKIP
	PUSHJ	%17,INSRT	;INSERT/UPDATE
	TLNE	%01,MDFSYM	;MULTIPLY DEFINED?
	TRO	%15,ERRM	;  YES
	PUSHJ	%17,CRFDEF	;CREF IT
	MOVEM	%13,LBLPNT	;SAVE IN EVENT OF FLUSH
	PUSHJ	%17,GETNB	;MOVE PAST COLON
	JRST	STMNT		;RETURN TO STATEMENT EVALUATOR

ASGMT:				;ASSIGNMENT PROCESSOR
	PUSH	%17,%00		;STACK SYMBOL
	PUSHJ	%17,GETNB	;MOVE PAST EQUALS SIGN
	PUSHJ	%17,RELEXP
	MOVE	%03,%10
	TLO	%03,DEFSYM	;BE SURE ZERO PRINTS
	MOVEM	%03,PF1		;SET PRINT FIELD
	POP	%17,%00		;RETRIEVE SYMBOL
	PUSHJ	%17,SSRCH	;SEARCH TABLE
	 JFCL			;  NOT THERE YET
	TLNE	%01,LBLSYM	;LABEL?
	JRST	ASGMT1		;  YES, ERROR
	AND	%01,[XWD GLBSYM!MDFSYM,0]	;MASK
	TRNN	%15,ERRU	;ANY UNDEFINED SYMBOLS?
	TLO	%01,DEFSYM	;  NO, FLAG AS DEFINED
	TDOA	%01,%10		;MERGE NEW VALUE
ASGMT1:	TLO	%01,MDFSYM	;  ERROR, FLAG AS MULTIPLY DEFINED
	TLNE	%01,MDFSYM	;EVER MULTIPLY DEFINED?
	TRO	%15,ERRM	;  YES
	PUSHJ	%17,CRFDEF	;CREF IT
	CAME	%00,M40DOT	;SKIP IF LOCATION COUNTER
	JRST	INSRT		;INSERT AND EXIT
BLKB1:	PUSHJ	%17,TSTMAX	;TEST FOR NEW HIGH
	LDB	%02,SUBPNT	; GET CSECT OF EXPR
	LDB	%03,CCSPNT	; GET CSECT OF PC
	CAME	%02,%03		;CURRENT SECTOR?
	JRST	ASGMT2		;  NO, ERROR
	PUSHJ	%17,INSRT	; INSERT SYMBOL IN TABLE
	HRLI	%01,(<RLDT10>B<MODOFF>) ; SET CLASS 10
	JRST	STCODE		; STOW CODE & EXIT

ASGMT2:	TRO	%15,ERRA!ERRP1	;  ERROR, DON'T STORE
	POPJ	%17,

PROPC:				;PROCESS OP CODES
	PUSHJ	%17,TSTEVN	;MAKE SURE WE'RE EVEN
	LDB	%02,SUBPNT	;GET CLASS
	HRLI	%01,BC2
	MOVEM	%01,OPCODE	;STORE OP
	SETZM	OFFSET		;CLEAN UP FOR AEXP
	SETZM	ADREXT
	SETZM	ADREXT+1
	XCT	PROPCT(%02)	;EXECUTE TABLE BY SUB-CLASS
	SKIPE	%01,OPCODE	;FETCH OP-CODE
	PUSHJ	%17,STCODE	;STOW CODE
	SKIPE	%01,ADREXT	;EXTENSION?
	PUSHJ	%17,STCODE	;  YES, STORE IT
	SKIPE	%01,ADREXT+1
	PUSHJ	%17,STCODE	;DITTO
	LDB	%01,[POINT 3,OPCODE,35-12]
	JUMPN	%01,PROPC1
	LDB	%01,[POINT 13,OPCODE,35-3]
	CAIN	%01,00012
	JRST	PROPC2
	TRZ	%01,00070
	CAIN	%01,00402
	JRST	PROPC2
	POPJ	%17,

PROPC1:	CAILE	%01,6
	POPJ	%17,
	LDB	%01,[POINT 6,OPCODE,35-6]
	TRNE	%01,70
	POPJ	%17,
	LDB	%02,[POINT 6,OPCODE,35]
	XOR	%02,%01
	CAIE	%02,20
	CAIN	%02,40
PROPC2:	TRO	%15,ERRZ
	POPJ	%17,

PROPCT:
	PHASE	0
	HALT
OPCL0:	JFCL
OPCL1:	PUSHJ	%17,POPCL1
OPCL2:	PUSHJ	%17,POPCL2
OPCL3:	PUSHJ	%17,POPCL3
OPCL4:	PUSHJ	%17,POPCL4
OPCL5:	PUSHJ	%17,POPCL5
OPCL6:	PUSHJ	%17,POPCL6
OPCL7:	PUSHJ	%17,POPCL7
OPCL8:	PUSHJ	%17,POPCL8
OPCL9:	PUSHJ	%17,POPCL9
OPCL10:	PUSHJ	%17,POPC10
OPCL11:	PUSHJ	%17,POPC11
OPCL12:	PUSHJ	%17,POPC12
OPCL13:	PUSHJ	%17,POPC13
OPCL14:	PUSHJ	%17,POPC14
	DEPHASE

POPCL1:	PUSHJ	%17,AEXP	;PROCESS ADDRESS EXPRESSION
	DPB	%00,[POINT 6,OPCODE,35]
	POPJ	%17,

POPCL2:	PUSHJ	%17,AEXP
	DPB	%00,[POINT 6,OPCODE,35-6]
POP2ND:	PUSHJ	%17,TSTCOM
	PUSHJ	%17,AEXP
	DPB	%00,[POINT 6,OPCODE,35]
	POPJ	%17,

POPCL3:	PUSHJ	%17,REGEXP
	DPB	%10,[POINT 3,OPCODE,35]
	POPJ	%17,

POPCL4:				;PROCESS BRANCH ON CONDITION
	PUSHJ	%17,EXPRF	;EVALUATE EXPRESSION
	JRST	PBCOP2		;  NULL, ERROR
	SUBI	%10,2(%05)	;COMPUTE E-.-2
	ROT	%10,-1		;/2, ODD BIT TO SIGN
	TRNE	%10,040000	;WAS IT NEG?
	TRO	%10,100000	;   YES-PROPOGATE SIGN.
	TRNE	%10,000200	;NEGATIVE?
	TRC	%10,177400	;  YES, TOGGLE HIGH BITS
	TRNN	%10,177400	;ANY OVERFLOW?
	JUMPGE	%10,PBCOP1	;  NO, BRANCH IF EVEN
PBCOP2:	MOVNI	%10,1		;  YES, SET TO JMP .
	TRO	%15,ERRA	;FLAG ERROR
PBCOP1:	DPB	%10,[POINT 8,OPCODE,35]
	POPJ	%17,

POPCL5:	PUSHJ	%17,REGEXP
	DPB	%10,[POINT 3,OPCODE,35-6]
	JRST	POP2ND

POPCL6:	PUSHJ	%17,EXPR	;EVALUATE THE EXPRESSION
	 JFCL			;  NULL, TREAT AS ZERO
	PUSHJ	%17,TSTAR	;TEST ARITHMETIC
	TRZE	%01,177400	;OVERFLOW?
	TRO	%15,ERRA	;  YES
	LDB	%03,MODPNT	;FETCH CLASS
	CAIE	%03,RLDT1	;IF ONE
	CAIN	%03,RLDT15	;  OF FIFTEEN,
	TRO	%15,ERRA	;RELOCATION ERROR
	SKIPE	%03		;ABSOLUTE?
	TRO	%03,200		;  NO, MAKE BIT MODIFICATION
	DPB	%03,MODPNT
	IORM	%01,OPCODE	;MERGE WITH BASIC
	POPJ	%17,

L9:				;OLD ASH/ASHC MODES

POPCL7:	PUSHJ	%17,AEXP
	DPB	%00,[POINT 6,OPCODE,35]
	PUSHJ	%17,TSTCOM
	PUSHJ	%17,REGEXP
	DPB	%10,[POINT 3,OPCODE,35-6]
	POPJ	%17,

POPCL8:	PUSHJ	%17,REGEXP
	DPB	%10,[POINT 3,OPCODE,35-6]
	PUSHJ	%17,TSTCOM
	PUSHJ	%17,EXPR
	 TRO	%15,ERRA
	MOVE	%01,%05
	ADDI	%01,2
	MOVEI	%00,1		; AVOID FLAG FROM EXPRMI BY
	MOVEM	%00,RELLVL	; SET RELOC LEVEL TO 1.
	PUSHJ	%17,EXPRMI
	 TRO	%15,ERRA
	PUSHJ	%17,ABSTST
	TRNE	%10,177601	;EVEN AND IN BOUNDS?
	TRO	%15,ERRA	;  NO, ERROR
	LSH	%10,-1
	DPB	%10,[POINT 6,OPCODE,35]
	POPJ	%17,

POPC10:	PUSHJ	%17,ABSEXP
	TRNE	%10,177700
	TRO	%15,ERRT
	DPB	%10,[POINT 6,OPCODE,35]
	POPJ	%17,

POPC11:	CAIE	%14,"#"
	JRST	POPC1B
	PUSH	%17,%13
	PUSHJ	%17,GETNB
	MOVEI	%03,1
	MOVEM	%03,FLTLEN	;SET LENGTH FOR ROUNDING
	PUSHJ	%17,FLTG
	POP	%17,%00
	TLNE	%15,FLTFLG
	JRST	POPC1A
	HRRZ	%10,FLTNUM
	TLO	%10,BC2
	AOS	%02,OFFSET
	MOVEM	%10,ADREXT-1(%02)
	MOVEI	%00,27
	JRST	POPC1C

POPC1A:	MOVE	%13,%00
	PUSHJ	%17,SETCHR
POPC14:				;NEW CLASS 14
POPC1B:	PUSHJ	%17,AEXP
POPC1C:	DPB	%00,[POINT 6,OPCODE,35]
	PUSHJ	%17,TSTCOM
	PUSHJ	%17,REGEXP
	TRNE	%10,177774
	TRO	%15,ERRA
	DPB	%10,[POINT 2,OPCODE,35-6]
	POPJ	%17,

POPC12:	PUSHJ	%17,REGEXP
	TRNE	%10,177774
	TRO	%15,ERRA
	DPB	%10,[POINT 2,OPCODE,35-6]
	JRST	POP2ND

POPC13:	PUSHJ	%17,ABSEXP
	TRNE	%10,177770
	TRO	%15,ERRA
	DPB	%10,[POINT 3,OPCODE,35]
	POPJ	%17,

TSTCOM:
	CAIN	%14,","
	JRST	GETNB
	TRO	%15,ERRA
	POP	%17,0(%17)
	POPJ	%17,

	SUBTTL	EXPRESSION HANDLERS

AEXP:				;"A" EXPRESSION EVALUATOR
	PUSH	%17,[0]		;STACK INITIAL VALUE
AEXP01:	PUSHJ	%17,SETNB	;GET A NON-BLANK
	CAIN	%14,"#"
	JRST	AEXP02
	CAIN	%14,"%"
	JRST	AEXP04
	CAIN	%14,"("
	JRST	AEXP06
	CAIN	%14,"-"
	JRST	AEXP07
	CAIN	%14,"@"
	JRST	AEXP08
	JRST	AEXP10		;NO UNARIES, PROCESS BASIC EXPRESSION


;   AEXP2A FORCES MODE 3 ADDRESS GENERATION INSTEAD OF
;   MODE 6.  CONTROL REACHES AEXP2A FROM THE AEXP10 BLOCK
;   IF A .ENABL AMA DIRECTIVE IS IN EFFECT.

AEXP2A:	TRO	%00,37		; SET MODE 3 WITH PC
	JRST	AEXP2B		; CONTINUE AS IF "@#" EXPR

AEXP02:				; #
	PUSHJ	%17,GETNB	;BYPASS UNARY OP
	PUSHJ	%17,EXPRF	;EVALUATE EXPRESSION
	 TRO	%15,ERRQ	;  NULL, ERROR
	PUSHJ	%17,TSTAR	;TEST ARITHMETIC
	POP	%17,%00		;RETRIEVE PRESET VALUE
	TRO	%00,27		;SET BITS
AEXP2B:	AOS	%02,OFFSET	;GET OFFSET
	MOVEM	%01,ADREXT-1(%02)	;STORE ADDRESS
	POPJ	%17,		;EXIT

AEXP04:				; %
	PUSHJ	%17,REGEXP	;EVALUATE REG EXPRESSION
	POP	%17,%00		;RETRIEVE CODE
AEXP05:	TRZE	%10,-10		;ANY OVERFLOW?
	TROA	%15,ERRR	;  YES, FLAG ERROR AND SKIP
	TRO	%00,00(%10)	;SET BITS
	POPJ	%17,		;EXIT

AEXP06:				; (
	PUSHJ	%17,AEXP20	;EVALUATE PARENTHESES
	SETZ	%01,		;ZERO IN CASE OF INDEX
	CAIE	%14,"+"		;FINAL "+" SEEN?
	JRST	AEXP13		;  NO, GO SEE IF (R) OR @(R)?
	POP	%17,%00		;YES, RETRIEVE CODE
	TRO	%00,20(%10)	;SET BITS
	JRST	GETNB		;BYPASS DELIMITER AND EXIT

AEXP13:	POP	%17,%00	;GET CODE
	TRON	%00,10	;IS "@" SET?
	JRST	AEXP05	;NO-REGISTER MODE
	PUSH	%17,%00	;YES-INDEX MODE
	JRST	AEXP12

AEXP07:				; -(
	MOVEM	%13,SYMBEG	;SAVE POINTER IN CASE OF FAILURE
	PUSHJ	%17,GETNB	;GET THE NEXT NON-BLANK
	CAIE	%14,"("		;PARENTHESIS?
	JRST	AEXP09		;  NO, TREAT AS EXPRESSION
	PUSHJ	%17,AEXP20	;YES, EVALUATE
	POP	%17,%00		;RETRIEVE CODE
	TRO	%00,40(%10)	;SET BITS
	POPJ	%17,		;EXIT

AEXP08:				; @
	POP	%17,%00		;RETRIEVE BASIC CODE
	TROE	%00,10		;SET INDIRECT BIT, WAS IT BEFORE?
	TRO	%15,ERRQ	;  YES, FLAG ERROR
	PUSH	%17,%00		;RE-STACK CODE
	PUSHJ	%17,GETNB	;BYPASS CHARACTER
	JRST	AEXP01		;GO BACK TO BEGINNING

AEXP09:				; -( FAILURE
	MOVE	%13,SYMBEG	;GET POINTER TO "-"
	PUSHJ	%17,SETNB	;RESTORE CHARACTER
AEXP10:				; NO UNARIES
	PUSHJ	%17,EXPR	;EVALUATE EXPRESSION
	 TRO	%15,ERRQ	;  NULL, ERROR
	CAIN	%14,"("		;ANOTHER EXPRESSION?
	JRST	AEXP11		;  YES, BRANCH
	POP	%17,%00		;RETRIEVE CODE
	TLNE	%10,REGSYM	;REGISTER EXPRESSION?
	JRST	AEXP05		;  YES, TREAT AS %

	TLNE	RMODE,AMAFLG	; .ENABL AMA IN EFFECT?
	JRST	AEXP2A		; YES - FORCE ABS MODE ADDRESS

	TRO	%00,67		;SET BITS FOR INDEXED BY PC.
	MOVE	%01,%10
	LDB	%02,SUBPNT	;GET RELOCATION
	HRLI	%01,BC2		;TWO DATA BYTES
	MOVEI	%03,RLDT6	;ASSUME EXTERNAL
	TLNE	%10,GLBSYM
	JRST	AEXP1B		;  TRUE, OK AS IS
	LDB	%04,CCSPNT	;FETCH CURRENT SEG
	CAME	%02,%04		;SAME SEG?
	JRST	AEXP1A		;  NO, FURTHER TESTING REQUIRED
	SUBI	%10,4(%05)	;YES, COMPUTE OFFSET
	SKIPE	OFFSET		;THIRD WORD?
	SUBI	%10,2		;  YES, TWO MORE FOR GOOD MEASURE
	DPB	%10,[POINT 16,%01,35]	;STORE RESULT
	JRST	AEXP1D		;BRANCH TO EXIT

AEXP1A:	MOVEI	%03,RLDT3	;OK FOR QUICKIE?
	JUMPE	%02,AEXP1C	;  YES, IF TO ABS SEG
	MOVE	%04,SECNAM(%02)
	AOS	%02,GLBPNT
	MOVEM	%04,GLBBUF(%02)	;STORE IN GLOBAL TEMP
	MOVEI	%03,RLDT16	;TYPE #16
AEXP1B:	DPB	%02,SUBPNT	;STORE GLOBAL BUFFER POINTER
AEXP1C:	DPB	%03,MODPNT	;STORE MODE
AEXP1D:	AOS	%02,OFFSET
	MOVEM	%01,ADREXT-1(%02)
	POPJ	%17,


AEXP11:				; E1(E2)
	TLNE	%10,REGSYM	;REGISTER EXPRESSION?
	TRO	%15,ERRR	;  YES, ERROR
	PUSH	%17,%10		;STACK E1
	PUSHJ	%17,AEXP20	;PROCESS EXPRESSION
	POP	%17,%01		;RETRIEVE E1
AEXP12:	DPB	%10,[POINT 3,0(%17),35]	;STORE REG
	MOVE	%10,%01
	PUSHJ	%17,TSTAR	;TEST MODE
	AOS	%02,OFFSET
	MOVEM	%01,ADREXT-1(%02)	;STORE ADDRESS
	POP	%17,%00		;RETRIEVE CODE BITS
	TRO	%00,60		;COMPLETE CODE
	POPJ	%17,		;EXIT

AEXP20:				;()
	PUSHJ	%17,GETNB	;BYPASS PAREN
	PUSHJ	%17,REGEXP	;EVALUATE REGISTER EXPRESSION
	CAIE	%14,")"		;PROPER DELIMITER
	TROA	%15,ERRQ	;  NO, FLAG ERROR AND SKIP
	PUSHJ	%17,GETNB	;  YES, BYPASS CHARACTER
	JRST	SETNB		;RETURN WITH NON-BLANK DELIMITER

TSTAR:				;TEST ADDITIVE RELOCATION  (0,1,5,15)
	MOVE	%01,%10		;COPY TO FINAL AC
	LDB	%02,SUBPNT	;GET RELOCATION
	HRLI	%01,BC2		;SET FOR TWO BYTES
	JUMPE	%02,CPOPJ	;EXIT IF ABS
	MOVEI	%03,RLDT5	;ASSUME EXTERNAL
	TLNE	%10,GLBSYM	;GLOBAL?
	JRST	TSTAR1		;  YES
	MOVEI	%03,RLDT1
	LDB	%04,CCSPNT
	CAMN	%02,%04		;CURRENT SECTOR?
	JRST	TSTAR2		;  YES
	MOVE	%04,SECNAM(%02)
	AOS	%02,GLBPNT
	MOVEM	%04,GLBBUF(%02)	;STORE SECTOR NAME
	MOVEI	%03,RLDT15	;TYPE 15
TSTAR1:	DPB	%02,SUBPNT
TSTAR2:	DPB	%03,MODPNT
	POPJ	%17,
EXPR:				;EXPRESSION PROCESSOR, REGISTER ALLOWED

EXPRF:				;EXPRESSION FIN, NO REGISTERS ALLOWED
	MOVE	%02,GLBRDX	;GET GLOBAL RADIX
	TLNE	%15,HOVFLG	;CHECK IF HEX OVERRIDE ENABLED
	TRO	%02,HEXENB	;  YES, SET HEXENB IN LOCRDX
RADEXP:	MOVEM	%02,LOCRDX	;MOVE TO LOCAL RADIX
	SETZB	%04,RELLVL	;CLEAR RELOCATION LEVEL COUNT
	SETZM	RECLVL		;CLEAR RECURSION LEVEL COUNT
	PUSHJ	RLINK,EXPR0	;GO EVALUATE EXPRESSION
	 POPJ	RLINK,		;  NULL, EXIT
	SOSL	RECLVL		;RECURSION LEVEL .GT. 0?
	TRO	RERR,ERRQ	;  YES, FLAG ERROR
	SOSLE	RELLVL		;RELOCATION LEVEL .GT. 1?
	TRO	RERR,ERRA	;  YES, FLAG ERROR
	JRST	CPOPJ1		;EXIT GOOD

EXPR0:				;EXPRESSION PROCESSOR
	PUSH	RLINK,LOCRDX	;SAVE CURRENT RADIX
	PUSHJ	RLINK,TERM	;GET THE FIRST TERM
	 JRST	EXPEX		;  NULL, GO EXIT
	POP	RLINK,LOCRDX	;RESTORE RADIX
	PUSHJ	RLINK,EXPRPX	;SET RELOCATION LEVEL
EXPR1:	LDB	%02,C4PNTR	;MAP NEXT CHAR USING COLUMN 4
	XCT	EXPRJT(%02)	;EXECUTE TABLE TO SAVE OP ADDR
	PUSHJ	RLINK,GETNB	;GET THE NEXT NON-BLANK CHAR
EXPR2:	HRLM	%02,0(RLINK)	;AND SAVE OP ADDRESS
	PUSH	RLINK,%10	;STACK CURRENT VALUE
	PUSH	RLINK,LOCRDX	;SAVE CURRENT RADIX
	PUSHJ	RLINK,TERM	;GET NEXT TERM
	 TRO	RERR,ERRQ	;  NULL, FLAG ERROR
	POP	RLINK,LOCRDX	;RESTORE RADIX
	POP	RLINK,%01	;GET PREVIOUS VALUE
	HLRZ	%02,0(RLINK)	;  AND OPERATOR
	PUSHJ	RLINK,0(%02)	;PERFORM OPERATOR
	 TRO 	RERR,ERRA	;  IF ERROR, FLAG IT
	TRZ	%10,600000	;CLEAR ANY OVERFLOW
	JRST	EXPR1		;TEST FOR MORE

EXPR3:				;OPERATOR POSSIBLY OMITTED
	TRO	RERR,ERRQ	;FLAG ERROR: MISSING OP
	MOVEI	%02,EXPRPL	;SIMULATE "+"
	JRST	EXPR2		;CONTINUE

EXPEX:	POP 	RLINK,LOCRDX	;RESTORE RADIX
	POPJ	RLINK,		;EXIT


EXPRJT:				;EXPRESSION JUMP TABLE
	PHASE	0
	JRST	CPOPJ1			;NOT AN OP NOR TERM; EXIT
EXTE:	JRST	EXPR3			;POSSIBLE TERM; SIMULATE "+"
EXPL:	MOVEI	%02,EXPRPL		; +
EXMI:	MOVEI	%02,EXPRMI		; -
EXOR:	MOVEI	%02,EXPROR		; !
EXAN:	MOVEI	%02,EXPRAN		; &
EXMU:	MOVEI	%02,EXPRMU		; *
EXDV:	MOVEI	%02,EXPRDV		; /
	DEPHASE

EXPRPL:				; +
	TDZA	%04,%04		;ZERO FOR ADD
EXPRMI:				; -
	HRROI	%04,1		;ONE FOR SUBTRACT
	PUSHJ	%17,EXPRPX	;UPDATE RELOCATION COUNT
EXPRP1:	LDB	%02,SUBPNT	;GET RELOCATION
	EXCH	%10,%01
	LDB	%03,SUBPNT
	TLNE	%01,REGSYM
	TLO	%10,REGSYM	;TRANSFER REGISTER FLAG
	JUMPE	%03,EXPRM1	;BRANCH IF SUBTRACTING ABS
	TLON	%04,-1		;NOT ABS, FIRST-TIME ADDITION?
	JRST	EXPRP1		;  YES, REVERSE
	TLNN	%01,GLBSYM	;IF EITHER IS GLOBAL,
	TLNE	%10,GLBSYM
	JRST	EXPRM2		;  ERROR
	CAME	%02,%03		;LAST CHANCE, BOTH SAME RELOCATION
	JRST	EXPRM2		;  FORGET IT
	SKIPN	RELLVL		;IF BACK TO ZERO,
	TLZ	%10,(PFMASK)	;MAKE ABSOLUTE
EXPRM1:	AOS	0(%17)		;INDICATE GOOD RESULT
EXPRM2:	XCT	[EXP <ADDM %10,%01>,<SUBM %10,%01>](%04) ;PERFORM OP
	DPB	%01,[POINT 16,%10,35]	;STORE TRIMMED RESULT
	POPJ	%17,		;EXIT

EXPRPX:				;UPDATE RELOCATION LEVEL
	TLNE	%10,(PFMASK)	;IF ABS,
	TLNE	%10,GLBSYM	;  OR GLOBAL,
	POPJ	%17,		;  NO ACTION
	XCT	[EXP <AOSA RELLVL>,<SOSGE RELLVL>](%04)
	 TRO	%15,ERRA	;  NEGATIVE COUNT, ERROR
	POPJ	%17,

EXPROR:	JSP	%03,EXPXCT	; !
	 IOR	%10,%01

EXPRAN:	JSP	%03,EXPXCT	; &
	 AND	%10,%01

EXPRMU:	JSP	%03,EXPXCT	; *
	 IMUL	%10,%01

EXPRDV:	JSP	%03,EXPXCT	; /
	 IDIV	%10,%01


EXPXCT:	PUSH	%17,0(%03)	;STACK INSTRUCTION
	PUSHJ	%17,EXPXC1	;TEST FOR ABSOLUTE
	EXCH	%10,%01
	PUSHJ	%17,EXPXC1	;DITTO FOR OTHER
	POP	%17,%03		;FETCH INSTRUCTION
	XCT	%03		;EXECUTE IT
	ANDI	%10,177777	;MAKE ABSOLUTE
	JRST	CPOPJ1		;GOOD EXIT

EXPXC1:	PUSHJ	%17,ABSTST	;TEST FOR ABSOLUTE
	LSH	%10,^D<36-16>
	ASH	%10,-^D<36-16>	;EXTEND SIGN
	POPJ	%17,

REGEXP:				;REGISTER EXPRESSION
	PUSHJ	%17,EXPR
	 TRO	%15,ERRA	;  NULL, ERROR
REGTST:	TDZE	%10,[<GLBSYM>B17!377B<SUBOFF>!177770]
	TRO	%15,ERRR	;  ERROR
	POPJ	%17,

ABSEXP:				;ABSOLUTE EXPRESSION
	PUSHJ	%17,EXPR
	 TRO	%15,ERRA
ABSTST:	TLZE	%10,(<GLBSYM>B17!377B<SUBOFF>)
	TRO	%15,ERRA	;ERROR IF GLOBAL OR RELOCATABLE
	ANDI	%10,177777
	POPJ	%17,

RELEXP:				;RELOCATABLE EXPRESSION
	PUSHJ	%17,EXPR
	 TRO	%15,ERRA
RELTST:	TLNE	%10,GLBSYM	;NO GLOBALS ALLOWED
	JRST	ABSTST		;LET ABS FLAG IT
	POPJ	%17,

TERPL:	PUSHJ	RLINK,GETNB	; (SKIP + SIGN)

TERM:				;TERM PROCESSOR
	SETZB	%10,%01		;RETURN VALUE IN %10
	PUSHJ	%17,GETSYM	;TRY FOR SYMBOL
	 JRST	TERM4		;  NOT A SYMBOL
	PUSHJ	%17,SSRCH	;SEARCH TABLE
	 JRST	TERM2		;  NOT THERE
	TLNE	%01,MDFSYM	;MULTIPLY DEFINED?
	TRO	%15,ERRD	;  YES
	TLNN	%01,DEFSYM!GLBSYM	;UNDEFINED?
	TRO	%15,ERRU	;  YES
	MOVE	%03,%01		;GET AN EXTRA COPY
	TLZ	%01,776000-REGSYM	;CLEAR ALL BUT REGISTER BIT
	TLNN	%03,DEFSYM	;DEFINED?
	TLNN	%03,GLBSYM	;  NO, GLOBAL?
	JRST	TERM1		;  LOCAL
	TLO	%01,GLBSYM	;JUST GLOBAL
	AOS	%04,GLBPNT	;GLOBAL
	MOVEM	%00,GLBBUF(%04)	;SAVE NAME
	DPB	%04,SUBPNT	;SAVE NUMBER IN RELOCATION
TERM1:	PUSHJ	%17,CRFREF	;CREF IT
	MOVE	%10,%01		;RESULT TO %10
	JRST	CPOPJ1		;GOOD EXIT

TERM2:	PUSHJ	%17,OSRCH	;TRY OP CODES
	 JRST	TERM3		;  NO
	CAIE	%02,OCOP	;PSEUDO-OP?
	JRST	TERM3		;  YES
	PUSHJ	%17,CRFREF
	HRRZ	%10,%01		;YES, TREAT AS NUMERIC
	JRST	CPOPJ1		;GOOD EXIT

TERM3:	PUSHJ	%17,SSRCH	;NOT YET DEFINED
	 PUSHJ	%17,INSRT	;INSERT
	TRO	%15,ERRU	;FLAG ERROR
	JRST	CPOPJ1		;RETURN WITH ZERO

TERM4:	LDB	%02,C5PNTR	;NON-SYMBOLIC
	XCT	TERMJT(%02)	;EXECUTE TABLE
	PUSHJ	%17,SETNB	;RETURN NON-BLANK
	JRST	CPOPJ1		;GOOD EXIT


TERMJT:				;TERM JUMP TABLE
	PHASE	0
	POPJ	%17,		;NULL RETURN
TEIG:	JRST	TERPL		; IGNORE (+)
TE2C:	PUSHJ	RLINK,TERM2C	; - (2'S COMPLEMENT)
TEUP:	PUSHJ	RLINK,TERMUP	; ^
TEEX:	PUSHJ	RLINK,TERMEX	; < (EXPRESSION FOLLOWS)
TESQ:	PUSHJ	%17,TERMSQ	; '
TEDQ:	PUSHJ	%17,TERMDQ	; "
TEPC:	PUSHJ	%17,TERMPC	; %
TENM:	PUSHJ	%17,TERMNM	; 0-9
TEHX:	PUSHJ	RLINK,TERMNM	; A-F (IF HEX ENABLED)
	DEPHASE

TERMNM:				;NUMERIC TERM
	MOVE	%06,LOCRDX	;GET RADIX
	SETZB	%00,%01		;CLEAR ACCUMULATORS
	SETZB	%02,%03
	SETZB	%10,%11

TERMN1:	CAILE	%14,"9"		;CHECK IF NUMERIC
	JRST	TERMN6		;  NO, GO CHECK IF HEX
	ASH	%10,1		;SHIFT BINARY AC ONE PLACE
	ADDI	%10,-"0"(%14)	;ADD NUMERIC VALUE OF DIGIT
	ASH	%01,2		;SHIFT QUATERNARY AC ONE PLACE
	ADDI	%01,-"0"(%14)	;ADD
	ASH	%02,3		;SHIFT OCTAL
	ADDI	%02,-"0"(%14)
	IMULI	%03,^D10	;DECIMAL
	ADDI	%03,-"0"(%14)
	ASH	%00,4		;HEXADECIMAL
	ADDI	%00,-"0"(%14)
TERMN2:	CAMGE	%11,%14		;LARGEST DIGIT SO FAR?
	MOVE	%11,%14		;  YES, SAVE IT
	PUSHJ	RLINK,GETCHR	;GET THE NEXT CHARACTER
	CAIL	%14,"0"		;CHECK IF NUMERIC
	JRST	TERMN1		;  POSSIBLY, GO CHECK FURTHER
TERMN3:	CAIE	%14,"."		;  NO, CHECK DECIMAL POINT
	JRST	TERMN4
	HRRI	%06,DECRDX	;    YES, CHANGE RADIX TO DECIMAL
	PUSHJ	RLINK,GETNB	;    GOBBLE UP "."
	JRST	TERMN7		;    GO PROCESS DECIMAL CONSTANT
TERMN4:	CAIE	%14,"$"		;CHECK FOR LOCAL SYMBOL
	JRST	TERMN7		;  NO, GO PROCESS AS CONSTANT
	PUSHJ	GETNB		;  YES, GOBBLE UP "$"
	CAIG	%11,"9"		;CHECK IF DECIMAL NUMBER
	JRST	TERMN5		;  NO, GO FLAG ERROR
	CAILE	%03,127		;CHECK IF DECIMAL AC < 127
	JRST	TERMN5		;  NO, GO FLAG ERROR
;;;;;	PUSHJ	RLINK,LOCSYM	;LOOK UP LOCAL SYMBOL
TERMN5:	 TRO	RERR,ERRU	;  FLAG IF UNDEFINED
	MOVE	%10,%01		;RETURN VALUE IN %10
	POPJ	RLINK,

TERMN6:	CAIL	%14,"A"		;TEST IF LEGAL HEX DIGIT
	CAILE	%14,"F"
	JRST	TERMN3		;  NO, GO FINISH UP
	ASH	%00,4		;  YES, SHIFT HEXADECIMAL AC ONE PLACE
	ADDI	%00,-"A"+^D10(%14)	;ADD NUMERIC VALUE OF DIGIT
	JRST	TERMN2		;REJOIN NUMERIC LOOP

TERMN7:	TRNE	%06,OCTRDX	;CHECK IF RADIX OCTAL
	JRST	TERMNO		;  YES, PROCESS ACCORDINGLY
	TRNE	%06,DECRDX	;DECIMAL
	JRST	TERMND
	TRNE	%06,HEXRDX	;HEXADECIMAL
	JRST	TERMNH
	TRNE	%06,QUARDX	;QUATERNARY
	JRST	TERMNQ
	CAIG	%11,"1"		;BINARY: CHECK IF ALL DIGITS < 2
	JRST	TERMN8		;  YES, JUMP OUT
	TRO	RERR,ERRN	;  NO, FLAG ERROR
TERMNQ:	MOVE	%10,%01		;MOVE QUATERNARY IN
	CAIG	%11,"3"		;CHECK IF ALL DIGITS < 4
	JRST	TERMN8		;  YES, JUMP OUT
	TRO	RERR,ERRN	;  NO, FLAG ERROR
TERMNO:	MOVE	%10,%02		;MOVE OCTAL IN
	CAIG	%11,"7"		;CHECK IF ALL DIGITS < 8
	JRST	TERMN8		;  YES, JUMP OUT
	TRO	RERR,ERRN	;  NO, FLAG ERROR
TERMND:	MOVE	%10,%03		;MOVE DECIMAL IN
	CAIG	%11,"9"		;CHECK IF ALL DIGITS <= 9
	JRST	TERMN8		;  YES, JUMP OUT
	TRO	RERR,ERRN	;  NO, FLAG ERROR
TERMNH:	MOVE	%10,%00		;MOVE HEXADECIMAL IN
TERMN8:	TDZE	%10,[-1B19]	;OVERFLOW?
	TRO	RERR,ERRT	;  YES, FLAG TRUNCATION ERROR
	POPJ	RLINK,		;EXIT

TERMPC:				; %
	PUSHJ	%17,GETNB	;BYPASS PERCENT
	PUSHJ	%17,TERM	;GET A TERM
	 TRO	%15,ERRR	;  ERROR IF NULL
	PUSHJ	%17,REGTST	;TEST VALID REGISTER TERM
	TLO	%10,REGSYM	;FLAG IT
	POPJ	%17,		;EXIT

TERMDQ:				; """
	PUSHJ	%17,GETNT	;GET THE NEXT NON-TERMINATOR
	 JRST	TERMQE		;  END OF LINE, ERROR
	MOVE	%10,%14		;GET THE CHARACTER
	PUSHJ	%17,GETNT	;TRY ONE MORE
	 JRST	TERMQE		;  ERROR
	DPB	%14,[POINT 8,%10,35-8]	;STORE IN UPPER
	PUSHJ	%17,GETNB	;RETURN WITH NEXT NON-BLANK
	POPJ	%17,


TERMSQ:				; "'"
	PUSHJ	%17,GETNT	;GET NON-TERMINATOR
	 JRST	TERMQE		;  TERMINATOR, ERROR
	MOVE	%10,%14		;FETCH CHARACTER
	PUSHJ	%17,GETNB	;RETURN NON-BLANK
	POPJ	%17,

TERMQE:	TRO	%15,ERRQ	;RAN OUT OF CHARACTERS
	POPJ	%17,

TERM2C:				;"-"
	PUSHJ	RLINK,GETNB	;GOBBLE	"-"
	PUSHJ	RLINK,TERM	;GET A TERM
	 TRO	RERR,ERRQ	;  ERROR IF NULL
	MOVN	%00,%10		;TAKE 2'S COMPLEMENT
	TRZ	%00,600000
	HRR	%10,%00		;PUT 16 BITS OF IT IN %10
	POPJ	RLINK,		;EXIT

TERMEX:				;"<"
	PUSHJ	RLINK,GETNB	;GOBBLE "<"
	PUSHJ	RLINK,EXPR0	;GET AN EXPRESSION
	 TRO	RERR,ERRQ	;  ERROR IF NULL
	CAIE	%14,">"		;CHECK FOR CLOSING ">"
	TROA	RERR,ERRQ	;  NO, FLAG ERROR
	PUSHJ	RLINK,GETNB	;  YES, GOBBLE ">"
	POPJ	RLINK,		;EXIT

TERMUP:				;"^" UNARY OPERATOR PROCESSOR
	SETZ	%00,		;CLEAR AC
	PUSHJ	RLINK,GETCHR	;GET THE NEXT CHARACTER
	LDB	%02,C9PNTR	;MAP CHARACTER USING COLUMN 9
	PUSHJ	RLINK,GETNB	;GOBBLE THE CHARACTER
	XCT	UPARJT(%02)	;EXECUTE TABLE
	SKIPE	%00		;RADIX MODIFICATION?
	HRRM	%00,LOCRDX	;  YES, CHANGE IT
	PUSHJ	RLINK,TERM	;GET A TERM
	 TRO	RERR,ERRQ	;  ERROR IF NULL
	POPJ	RLINK,		;EXIT

UPARJT:	PHASE	0		;UP-ARROW JUMP TABLE
	TRO	RERR,ERRQ	;UNDEFINED OPERATOR: FLAG ERROR
UPARC:	JRST	TERM1C		;^C - ONE'S COMPLEMENT
UPARF:	JRST	TERMFL		;^F - FLOATING POINT
UPARB:	HRRZI	%00,BINRDX	;^B - BINARY RADIX
UPARO:	HRRZI	%00,OCTRDX	;^O - OCTAL RADIX
UPARD:	HRRZI	%00,DECRDX	;^D - DECIMAL RADIX
UPARH:	HRRZI	%00,HEXRDX!HEXENB;^H - HEXADECIMAL RADIX
	DEPHASE

TERM1C:				;^C
	PUSHJ	RLINK,TERM	;GET A TERM
	 TRO	RERR,ERRQ	;  ERROR IF NULL
	TRC	%10,177777	;TAKE ONE'S COMPLEMENT
	POPJ	RLINK,		;EXIT

TERMFL:				;^F - FLOATING POINT CONSTANT
	HRRZI	%00,1
	MOVEM	%00,FLTLEN	;SET FLOATING LENGTH TO ONE
	PUSHJ	RLINK,FLTG	;EVALUATE F.P. CONSTANT
	TLNE	RERR,FLTFLG	;ANY ERRORS?
	TRO	RERR,ERRA	;  YES, FLAG ERROR
	MOVE	%10,FLTNUM	;PUT RESULT IN %10
	POPJ	RLINK,		;EXIT

	SUBTTL	SYMBOL/CHARACTER HANDLERS


;	ORDINARY SYMBOLS ARE A SEQUENCE OF ALPHAMERIC CHARACTERS
;	BEGINNING WITH AN ALPHABETIC CHARACTER; "." AND "$"
;	ARE CONSIDERED ALPHABETIC.

;	LOCAL SYMBOLS ARE A DECIMAL INTEGER FOLLOWED BY
;	A "$".  THE INTEGER'S VALUE MUST BE IN THE RANGE
;	[1,127].

;	IF GETSYM FAILS TO FIND A SYMBOL, IT RETURNS TO 0(RLINK)
;	WITH R0 = 0.

;	IF THE NEXT NONBLANK TEXT IS A SYMBOL, GETSYM RETURNS TO
;	1(RLINK) WITH THE SYMBOL'S MOD40 EQUIVALENT IN R0.
;	ANY CHARACTERS AFTER THE SIXTH IN THE SYMBOL ARE SKIPPED.

;	FOR LOCAL SYMBOLS, THE VALUE RETURNED (IN R0) IS . . .

;		LEFT HALF:  INTEGER PART OF SYMBOL (7 BITS);
;				HIGH ORDER BITS ARE 0
;		RIGHT HALF:  BLOCK NUMBER OF CURRENT LOCAL SYMBOL BLOCK


GETSYM:				;GET A SYMBOL
	PUSHJ	%17,SETNB	;BYPASS LEADING BLANKS
	MOVEM	%13,SYMBEG	;SAVE START FOR RESCAN
	MOVSI	%01,(POINT 6,%00,)	;SET POINTER
	TDZA	%00,%00		;CLEAR AC AND SKIP
GETSY1:	PUSHJ	%17,GETCHR	;GET NEXT CHARACTER
	LDB	%02,ANPNTR	;MAP CHARACTER TYPE
	XCT	GETSYT(%02)	;EXECUTE TABLE
GETSY0:	SUBI	%14,40		;VALID, CONVERT TO SIXBIT
	TLNE	%01,770000	;ARE WE FULL?
	IDPB	%14,%01		;  NO, STORE CHARACTER
	JRST	GETSY1

GETSY2:	JUMPE	%00,CPOPJ	;EXIT IF EMPTY
	PUSHJ	%17,SETNB	;SYMBOL, RETURN NON-BLANK
	PUSHJ	%17,SIXM40	;CONVERT TO MOD40
	JRST	CPOPJ1		;EXIT +1

GETSY3:	SETCM	%03,LOCRDX	;GET LOCAL RADIX COMPLEMENTED
	TRNE	%03,HEXRDX!HEXENB ;CHECK HEX RADIX AND HEX ENABLED
	JRST	GETSY0		;  NO, CONTINUE WITH SYMBOL
	POPJ	RLINK,		;  YES, EXIT EMPTY

GETSYT:				;GETSYM TABLE
	PHASE	0
	JRST	GETSY2		;NON-ALPHA/NUMERIC
.TAB:	JRST	GETSY2		;BLANK
.ALP:	JFCL			;ALPHA, O.K.
.NUM:	JUMPE	%00,GETLSY	; NUMERIC => LOCAL SYM IF 1ST BYTE
.HEX:	JUMPE	%00,GETSY3	;A-F O.K. IF NOT FIRST
	DEPHASE

;	*******  GET A LOCAL SYMBOL  *******

;	IF THE NUMERIC PART DOESN'T END WITH A "$", THIS
;	CAN'T BE A LOCAL SYMBOL.  IN THAT CASE RESTORE
;	THE ORIGINAL SOURCE INPUT POINTER & RETURN SAYING
;	NO SYMBOL WAS FOUND.

;	INITIAL ENTRY TO THIS BLOCK OF CODE IS AT GETLSY.


GETL1:	PUSHJ	RLINK,GETCHR		; GET NEXT BYTE
	LDB	%02,ANPNTR		; LOAD ITS TYPE
	XCT	GETLTS(%02)		; -- CHECK TYPE

	IMULI	%00,^D10	; TYPE IS NUMERIC -- ACCUMULATE
GETLSY:	SUBI	%14,60			; BINARY INTEGER.
	ADD	%00,%14
	JRST	GETL1


GETLDO:	CAIE	%14,"$"		; TYPE IS ALPHA -- IS THIS "$"?
	JRST	GETLNS			; NO -- CAN'T BE LOCAL SYM
	PUSHJ	RLINK,GETCHR		; YES -- SKIP THIS BYTE

	SKIPE	%00			; INSURE THAT INTEGER IS
	CAIL	%00,^D128		; IN [1,127]
	TRO	RERR,ERRT		; GIVE A T FLAG IF IT ISN'T
	TRZ	%00,777600		; ENFORCE MAX = 127.

	HRL	%00,%00			; COPY INTEGER TO LEFT HALF,
	HRR	%00,LSBLOC		; LS BLOCK # TO RIGHT HALF.
	JRST	CPOPJ1			; RETURN.


;	   --- FOUND A DISTINCTLY UNKOSHER CHARACTER BEFORE
;	   COMING ACROSS A "$".  UNDECIDE THAT THIS IS A SYMBOL.

GETLNS:	MOVE	%13,SYMBEG		; RESTORE INPUT POINTER
	LDB	%14,%13			; RELOAD FIRST BYTE.
	SETZ	%00			; RETURN 0
	POPJ	RLINK,


GETLTS:
	JRST	GETLNS		; NON ALPHA-NUMERIC
	JRST	GETLNS		; BLANK OR TAB
	JRST	GETLDO		; ALPHABETIC (HOPEFULLY $)
	JFCL			; NUMERIC
	JRST	GETLNS		; A-F

GETNB:				;GET NON-BLANK CHARACTER
	IBP	%13		;INDEX BYTE POINTER
SETNB:				;SET TO NON-BLANK CHARACTER
	PUSHJ	%17,SETCHR	;SET CHARACTER IN %14
	CAIE	%14,SPACE	;IF SPACE
	CAIN	%14,TAB		;  OR TAB;
	JRST	GETNB		;  BYPASS
	POPJ	%17,		;OTHERWISE EXIT


GETCHR:				;GET THE NEXT CHARACTER
	IBP	%13		;INDEX BYTE POINTER
SETCHR:				;SET THE CURRENT CHAR IN %14
	LDB	%14,%13		;PICK IT UP
	CAIN	%14,ILLCHR	;ILLEGAL CHARACTER?
	JRST	SETCH2		;  YES, ERROR
	CAIL	%14,141		; IS IT LOWER CASE?
	SUBI	%14,40		; YES -- FOLD TO UPPER CASE.
	CAIN	%14,ELLCHR	;END OF LOGICAL LINE?
SETCH1:	PUSHJ	%17,GETNT	;  YES, MOVE TO CR
	 POPJ	%17,		;  OK, EXIT
	JRST	SETCH1		;KEEP MOVING

SETCH2:	TRO	%15,ERRI	;FLAG ERROR
	JRST	GETCHR		;AND IGNORE CHARACTER

GETNT:				;GET NON-TERMINATOR
	PUSHJ	%17,GETCHR	;GET THE NEXT CHARACTER
TSTNT:				;TEST FOR NON-TERMINATOR
	CAIE	%14,CRR
	CAIN	%14,LF		;CRR OR LF?
	POPJ	%17,		;  YES, EXIT IN LINE
	CAIE	%14,FF
	CAIN	%14,0		;FF OR NULL?
	POPJ	%17,		;  YES
	JRST	CPOPJ1		;NO, SKIP-EXIT

	SUBTTL	PSEUDO-OPS

.END:				;"END" PSEUDO-OP
	SKIPN	CONLVL		;IF IN CONDITIONAL
	SKIPE	REPLVL		;  OR REPEAT,
	TRO	%15,ERRE	;  FLAG ERROR
	TLO	%15,ENDFLG	;FLAG "END SEEN"
	TLZ	%16,SBTBIT	;TURN OFF SUBTITLE SWITCH
	PUSHJ	%17,EXPRF	;EVALUATE THE ADDRESS
END2:	 MOVEI	%10,1		;  NULL, FORCE ODD VECTOR
	MOVEM	%10,PF1
	MOVEM	%10,ENDVEC
	TRNE	%15,ERRU	;ANY UNDEFINED SYMBOLS?
	TRO	%15,ERRP1	;  YES, PASS ONE ERROR
	POPJ	%17,

OPCERR:				;ILLEGAL OP CODE
	TRO	%15,ERRO
	POPJ	%17,


TSTEVN:				;TEST FOR EVEN
	TRNN	%05,1		;ARE WE EVEN?
	POPJ	%17,		;  YES, JUST EXIT
	TRO	%15,ERRB	;NO, FLAG ERROR AND EVEN THINGS UP
	PUSH	%17,%01
	PUSHJ	%17,.EVEN
	POP	%17,%01
	POPJ	%17,

.EVEN:				;"EVEN" PSEUDO OP
	TRNN	%05,1		;EVEN?
	POPJ	%17,		;  YES, NO SEQUENCE BREAK
PCMOD:	AOS	%01,%05		;GET PC
	HRLI	%01,(<RLDT10>B<MODOFF>)	;FLAG AS CLASS 10
	JRST	STCODE


.ODD:				; "ODD" PSEUDO-OP
	TRNE	RLOC,1		; IS LOCATION ALREADY ODD?
	POPJ	RLINK,		; YES - NOTHING TO DO
	JRST	PCMOD		; NO - INCR PC LIKE .EVEN


.LIMIT:				; ".LIMIT" PSEUDO-OP
	TLNE	%15,ABSFLG	;ABS MODE?
	POPJ	%17,		;  YES, IGNORE IT
	PUSHJ	%17,TSTEVN	;NO, MAKE SURE WE'RE EVEN
	MOVSI	%01,BC2(<RLDT11>B<MODOFF>)
	PUSHJ	%17,STCODE
	MOVSI	%01,BC2
	JRST	STCODE		;GENERATE TWO WORDS

ABS0:	TLO	%15,ABSFLG!RSWFLG	;SET ABSOLUTE FLAG
	TLZ	%05,(PFMASK)	;CLEAR RELOCATION
	POPJ	%17,

ASECT:	MOVE	%00,.ABS.	;FUDGE FOR ABS
	JRST	CSECT1		;BRANCH AROUND TEST

CSECT:	PUSHJ	RLINK,LOCRES	; START NEW LOCAL SYMBOL BLOCK
	TLNE	%15,ABSFLG	;ABS MODE?
	JRST	OPCERR		; YES, ERROR
	PUSHJ	%17,GETSYM	;TRY FOR A SYMBOL
	 JFCL			;  DEFAULT OR ABS
CSECT1:	PUSHJ	%17,TSTMAX	;TEST MAX PC
	MOVSI	%10,-^D256	;INIT FOR SEARCH
CSECT2:	CAMN	%00,SECNAM(%10)	;MATCH?
	JRST	CSECT3		;  YES
	TRNE	%10,-2		;IF POINTING AT ONE
	SKIPE	SECNAM(%10)	;OR SLOT IS FULL,
	AOBJN	%10,CSECT2	;LOOP
	JUMPL	%10,CSECT3	;BRANCH IF GOOD
	TRO	%15,ERRA	;END, ERROR
	POPJ	%17,

CSECT3:	MOVEM	%00,SECNAM(%10)	;SAVE NAME
	MOVE	%01,%05		;GET CURRENT PC
	LDB	%02,SUBPNT	;CURRENT RELOCATION
	HRRM	%01,SECBAS(%02)	;STORE CURRENT
	HRRZ	%05,SECBAS(%10)	;GET NEW ONE
	DPB	%10,CCSPNT	;MAKE SURE RELOCATION IS SET
	MOVE	%01,%05

	AOS	%02,GLBPNT
	MOVEM	%00,GLBBUF(%02)	;STORE NAME
	ANDI	%01,177777
	DPB	%02,SUBPNT	;STORE POINTER
	MOVEI	%03,RLDT7
	DPB	%03,MODPNT	;SET CLASS 7
	JRST	STCODE


TSTMAX:	LDB	%03,CCSPNT	;GET CURRENT SEC
	HLRZ	%04,SECBAS(%03)	;MAX FOR THIS ONE
	CAIGE	%04,0(%05)	;NEW MAX?
	HRLM	%05,SECBAS(%03)	;  YES
	POPJ	%17,

.RAD50:				;RADIX 50
	PUSHJ	%17,TSTEVN
	PUSHJ	%17,.RAD55	;SET AC AND POINTER
	CAIL	%14,41		;TEST DELIMITER BOUNDS
	CAILE	%14,137
	JRST	.RAD52		;  ILLEGAL
	CAIN	%14,";"
	JRST	.RAD52
	MOVE	%10,%14		;OK, SAVE A COPY
.RAD51:	PUSHJ	%17,GETNT	;GET NON-TERMINATOR
	 JRST	.RAD54		;  EOL
	CAIN	%14,";"
	JRST	.RAD54		;LOGICAL EOL
	CAMN	%14,%10		;END?
	JRST	.RAD53		;  YES
	TLNN	%01,770000	;TIME TO DUMP A WORD?
	PUSHJ	%17,.RAD54	;  YES
	MOVEI	%03,-40(%14)	;GET A SIXBIT COPY
	LDB	%02,ANPNTR
	CAIN	%02,.HEX	; CHECK FOR ALPHANUMERICS
	JRST	.RAD56
	CAIE	%02,.ALP	;IF NOT ALPHA
	CAIN	%02,.NUM	;  OR NUMERIC
	CAIA
	JUMPN	%03,.RAD52	;  ERROR (UNLESS BLANK)
.RAD56:	IDPB	%03,%01		;DO SO
	JRST	.RAD51		;GET THE NEXT CHARACTER

.RAD52:	TROA	%15,ERRA	;ERROR
.RAD53:	PUSHJ	%17,GETNB	;GOOD, RETURN NON-BLANK
	SKIPN	CODPNT		;MULTI-WORD?
	JRST	.RAD54		;  NO
	TLNN	%15,P10FLG	;YES, ".PDP10" MODE?
	TROA	%15,ERRO	;  NO, FLAG ERROR
	AOS	P10CNT		;YES, BUMP COUNT
.RAD54:	PUSHJ	%17,SIXM40	;CONVERT
	MOVE	%01,%00
	HRLI	%01,BC2		;TWO BYTES, ABSOLUTE
	PUSHJ	%17,STCODE	;STORE CODE
.RAD55:	SETZ	%00,		;CLEAR ACCUM
	MOVSI	%01,(POINT 6,%00,17)	;SET POINTER
	POPJ	%17,

.RADIX:				;".RADIX n" PSEUDO-OP
	MOVEI	%02,DECRDX	;SET RADIX TO 10 TO EVALUATE OPERAND
	PUSHJ	RLINK,RADEXP	;EVALUATE OPERAND
	 JRST	.RAD8		;  DEFAULT NULL TO OCTAL
	SETZ	%00,		;CLEAR AC
	CAIN	%10,^D2		;CHECK IF n=2
	MOVEI	%00,BINRDX	;  YES, SET BINARY RADIX
	CAIN	%10,^D4		;CHECK IF n=4
	MOVEI	%00,QUARDX	;  YES, SET QUATERNARY RADIX
.RAD8:	CAIN	%10,^D8		;CHECK IF n=8
	MOVEI	%00,OCTRDX	;  YES, SET OCTAL RADIX
	CAIN	%10,^D10	;CHECK IF n=10
	MOVEI	%00,DECRDX	;  YES, SET DECIMAL RADIX
	CAIN	%10,^D16	;CHECK IF n=16
	MOVEI	%00,HEXRDX	;  YES, SET HEXADECIMAL RADIX
	JUMPE	%00,.RADER	;JUMP IF NOT LEGAL RADIX
	HRRM	%00,GLBRDX	;SET THE NEW RADIX
	POPJ	RLINK,		;EXIT GOOD
.RADER:	TRO	RERR,ERRQ	;ERROR IF n NOT ONE OF 2,4,8,10,16
	POPJ	RLINK,		;EXIT W/O CHANGING RADIX

EF:				;.OPDEF HANDLER
	TLNN	%15,P10FLG	;PDP10 MODE?
	TRO	%15,ERRO	;  NO, FLAG ERROR
	TLO	%15,RSWFLG	;FLUSH, IF REQUESTED
	AOS	P10CNT		;FLAG ".PDP10" USAGE
	PUSHJ	%17,GETSYM	;GET THE NAME
	 JRST	.OPDE2		;  NULL, ERROR
	CAIE	%14,","		;TEST FOR COMMA
	JRST	.OPDE2		;  MISSING
	PUSHJ	%17,GETNB	;BYPASS COMMA
	PUSH	%17,%00		;STACK NAME
	PUSHJ	%17,GETSYM	;GET THE TYPE
	 JRST	.OPDE1		;  NOT A SYMBOL, ERROR
	CAIE	%14,","
	JRST	.OPDE1		;MISSING COMMA
	PUSHJ	%17,GETNB	;BYPASS COMMA
	PUSHJ	%17,OSRCH	;SEARCH THE OP-CODE TABLE
	 JRST	.OPDE1		;  NOT THERE
	CAIE	%02,OCOP	;OP CODE?
	JRST	.OPDE1		;  NO, ERROR
	PUSH	%17,%01		;OK, STACK TYPE
	PUSHJ	%17,ABSEXP	;COMPUTE BASIC VALUE
	POP	%17,%00		;RETRIEVE TYPE
	DPB	%01,[POINT 16,%00,35]	;STORE NEW VALUE
	EXCH	%00,0(%17)	;EXCHANGE FOR NAME
	PUSHJ	%17,MSRCH	;SET SEARCH INDEX
	 JFCL			;  MOX NIX IF FOUND
	POP	%17,%01		;RETRIEVE VALUE
	TLZ	%01,(MDMASK)	;MASK MODE BITS
	PUSHJ	%17,INSRT	;INSERT IN TABLE
	MOVSI	%01,MAOP	;CREF AS MACRO
	JRST	CRFDEF		;CREF AND EXIT

.OPDE1:	POP	%17,0(%17)	;PRUNE STACK
.OPDE2:	TRO	%15,ERRA	;FLAG ERROR
	POPJ	%17,		;EXIT

BL:				;.GLOBL PSEUDO-OP
	TLNE	%15,ABSFLG
	JRST	OPCERR
	PUSHJ	%17,GETSYM	;GET A SYMBOL
	 JRST	.GLOB1		;  NULL, ERROR
	CAMN	%00,M40DOT	;MESSING WITH PC?
	JRST	.GLOB1		;  YES, ERROR
	PUSHJ	%17,SSRCH	;OK, SEARCH TABLE
	 JFCL
	PUSHJ	%17,CRFREF
	TLNE	%01,REGSYM	;REGISTER SYMBOL?
	TLOA	%01,MDFSYM	;  YES, ERROR
	TLOA	%01,GLBSYM	;NO, FLAG GLOBAL
	TRO	%15,ERRR	;  YES, FLAG REGISTER ERROR
	PUSHJ	%17,INSRT	;INSERT IN TABLE
	CAIA
.GLOB1:	 TRO	%15,ERRA	;ERROR FROM ABOVE
	CAIE	%14,","		;MORE TO COME?
	POPJ	%17,		; NO, EXIT
	PUSHJ	%17,GETNB	;YES, BYPASS COMMA
	JRST	.GLOBL		;LOOP

.TITLE:				;TITLE PSEUDO-OP
	PUSHJ	%17,GETSYM	;GET THE SYMBOL
	 TROA	%15,ERRA	;  NULL, FLAG ERROR AND SKIP
	MOVEM	%00,PRGTTL	;OK, STORE TITLE
IFN CCLSW,<
	PUSHJ	%17,PRNAM
>
	JUMPE	%14,CPOPJ	;EXIT IF END OF LINE
FLSHLN:					;FLUSH LINE !!!!!!!!!!!!!!!!!!!
	PUSHJ	%17,GETNB	;AVOID Q ERROR
	JRST	.-2
	POPJ	%17,

.PDP10:	TLO	%15,P10FLG!RSWFLG	;PDP10 MODE
.EOT:
	POPJ	%17,

IFN CCLSW,<
PRNAM:
	SKIPN	TTLFLA		;ONLY PRINT PROGRAM NAME ONCE
	SKIPN	CCLFLA		;ONLY PRINT IF CCL MODE
	POPJ	%17,
	SETOM	TTLFLA		;FLAG THAT NAME ALREADY PRINTED
	PUSH	%17,%16		;SAVE FLAG STATUS
	MOVSI	%16,ERRBIT!LSTBIT!BINBIT	;TO ALLOW TTY OUTPUT
	MOVE	%00,PRGTTL	;GET PROGRAM TITLE
	PUSHJ	%17,M40SIX	;CONVERT MOD40 TO SIXBIT
	PUSHJ	%17,LSTSIX
	PUSHJ	%17,LSTCR
	POP	%17,%16
	POPJ	%17,
>

.ASCIZ:	TDZA	%02,%02		; ".ASCIZ" DIRECTIVE
.ASCII:	MOVEI	%02,1		; ".ASCII" DIRECTIVE

	PUSH	RLINK,RLOC	; SAVE CURRENT PC VALUE.

.ASCI1:	PUSHJ	RLINK,ASCOP	; PROCESS AN OPERAND.
	PUSHJ	RLINK,GETNT	; CHECK NEXT CHARACTER.
	JRST	.ASCI2		; ** END OF LINE
	CAIE	%14," "		; ** NOT EOL - IS IT BLANK OR TAB?
	CAIN	%14,TAB
	JRST	.ASCI2		; YES - QUIT HERE.
	JRST	.ASCI1		; NO - HANDLE CONCATENATED OPERAND.


;	   END OF OPERAND FIELD.  APPEND A 0 BYTE IF OPERATION
;	   IS .ASCIZ.

.ASCI2:	SETZ	%14,		; READY A 0 BYTE.
	SKIPN	%02		; WHICH DIRECTIVE IS THIS?
	PUSHJ	RLINK,ASCOUT	; ** .ASCIZ - OUTPUT THE 0.

	JRST	.WORDX		; RESTORE PC VALUE ON EXIT.



; ----------  PROCESS AN OPERAND  ------------

ASCOP:	CAIN	%14,"<"		; IS OPERAND IN BRACKETS?
	JRST	ASCNUM		; YES - ITS A NUMBER.
	MOVE	%03,%14		; NO - SAVE DELIMITER BYTE.

ASCTEX:	PUSHJ	RLINK,GETNT	; GET NEXT BYTE.
	JRST	ASCTER		; END OF LINE ISN'T LEGAL.
	CAMN	%14,%03		; IS THIS THE DELIMITER?
	POPJ	RLINK,		; YES -- QUIT HERE.
	PUSHJ	RLINK,ASCOUT	; NO -- STORE THE BYTE.
	JRST	ASCTEX


ASCTER:	TRO	RERR,ERRA	; ** ILLEGAL END OF LINE **
	POP	RLINK,0(RLINK)	; TIDY UP THE STACK.
	JRST	.ASCI2		; DO A KOSHER EXIT.



;   ------  PROCESS A NUMBER OR SEQUENCE OF NUMBERS
;  -------  IN THE FORM "<#1,#2,...,#N>".

ASCNUM:	PUSH	RLINK,%02	; SAVE .ASCII/.ASCIZ FLAG.

ASCNXT:	PUSHJ	RLINK,GETNB	; SKIP "<" OR ",".
	PUSHJ	RLINK,TERMNM	; DECIPHER A NUMBER.
	PUSH	RLINK,%14	; SAVE THE TERMINATING DELIMITER.
	MOVE	%14,%10		; COPY BINARY RESULT TO BYTE REG,
	TRZE	%14,777000	;	TEST FOR BAD MAGNITUDE.
	TRO	RERR,ERRT	;	:: FLAG A TRUNCATION ERROR ::

	PUSHJ	RLINK,ASCOUT	; STORE THIS BYTE.
	POP	RLINK,%14	; RELOAD NUMBER'S DELIMITER.
	CAIN	%14,","		; "," => GET ANOTHER NUMBER.
	JRST	ASCNXT

	POP	RLINK,%02	; RESTORE .ASCII/.ASCIZ FLAG.
	CAIE	%14,">"		; WAS ENDING DELIM PROPER?
	TRO	RERR,ERRQ	; -- NO - QUESTIONABLE SYNTAX.
	POPJ	RLINK,




;  STORE NEXT BYTE.

ASCOUT:	MOVE	%01,%14		; COPY BYTE TO BE STORED TO PARM REG.
	HRLI	%01,BC1		; SHOW BYTE COUNT = 1.
	PUSHJ	RLINK,STCODE	; STORE THE BYTE.
	AOJA	RLOC,CPOPJ	; INCREMENT PC AND RETURN.


.PAGE:				; FORCE A PAGE EJECT
	TLNE	RMODE,P1F	; IS THIS PASS 2?
	POPJ	RLINK,		; NO - TAKE NO ACTION.
	TRO	%16,HDRBIT	; YES - GET A NEW PAGE
	MOVE	%00,LSTCTL	; GET LISTING FLAGS.
	TRNN	%00,LLD		; IS .NLIST LD IN EFFECT?
	TLO	%16,NLISLN	; YES -- DON'T LIST .PAGE
	POPJ	RLINK,


.SBTTL:				;"SUBTITLE" PSEUDO-OP
	TLNE	RMODE,P1F	; IS THIS PASS 1?
	JRST	SBP1		; YES - JUST LIST STUFF

;	   ----------  PASS 2 PROCESSING  -----------

	MOVE	%11,[POINT 7,SUBMSG]	;OBTAIN POINTER TO BUFFER
	JRST	.+2		;BYPASS ILDB FIRST TIME THRU
SBLP:	PUSHJ	RLINK,GETCHR	; GET NEXT CHARACTER.
	PUSHJ	%17,TSTNT	;END OF LINE SEEN?
	JRST	SBEND		;YES, GET OUT
	IDPB	%14,%11		;PUT BYTE AWAY
	JRST	SBLP		;DO ANOTHER
SBEND:	MOVEI	0		;END OF SUBTITLE
	IDPB	%11		;IS A ZERO BYTE
	TLO	%16,SBTBIT	;MARK THAT WE AHVE SEEN A SBTTL
	TLNN	RMODE,NSFBIT	; ** FORCE PAGE EJECT ONLY IF
	POPJ	RLINK,		; ** NONSTANDARD FUNCTIONS ENABLED
	TLNN	%16,LOHBIT	; ** AND LAST OUTPUT WASN'T HEADER
	TRO	%16,HDRBIT
	POPJ	RLINK,



;	   -------------  PASS 1 PROCESSING  ---------------

SBP1:	MOVE	%00,LSTCTL	; IS TOC LISTING ENABLED?
	TRNN	%00,LTOC
	POPJ	RLINK,		; NO - QUIT.
	TLOE	%16,SBTBIT	; YES - SUBHEAD ALREADY SET?
	JRST	SBTOCL

;   SUPPLY 'TABLE OF CONTENTS' AS SUBTITLE.

	MOVE	%00,[XWD TOCSUB,SUBMSG] ; COPY TOC PROSE
	BLT	%00,SUBMSG+SBMEND-TOCSUB	; INTO SUBTITLE BUFFER
	TRO	%16,HDRBIT	; FORCE PAGE SKIP

;   LIST OPERAND FIELD OF .SBTTL DIRECTIVE

SBTOCL:	PUSHJ	RLINK,FORSEQ	; FORMAT SEQUENCE # FIELD.
SBSEQ:	PUSHJ	RLINK,LPTOUA	; LIST A BYTE.
	ILDB	%02,%06		; GET NEXT BYTE OF FORMATTED SEQ.
	JUMPN	%02,SBSEQ	; REPEAT UNTIL FINDING 0.

	MOVEI	%02,TAB		; FOLLOW WITH A TAB.
	PUSHJ	RLINK,LPTOUA
	PUSHJ	RLINK,LPTOUA

	PUSHJ	RLINK,SETCHR	; LOAD FIRST BYTE OF SUBTITLE

SBTOCN:	MOVE	%02,%14		; COPY BYTE TO %02 FOR LPTOUA
	PUSHJ	RLINK,TSTNT	; CHECK FOR END OF LINE
	JRST	SBENDL		; <- RET 0 - END OR NULL
				; <- RET 1 - PART OF TEXT
	PUSHJ	RLINK,LPTOUA	; PRINT NEXT BYTE
SBTGNX:	PUSHJ	RLINK,GETCHR	; SCAN TO FOLLOWING BYTE.
	JRST	SBTOCN

SBENDL:	JUMPE	%02,SBTGNX	; IGNORE A NULL BYTE
	TDZ	%02,%02		; END OF LINE -- PRINT CR/LF
	PUSHJ	RLINK,LPTOUA
	POPJ	RLINK,


TOCSUB:	ASCIZ	/		TABLE  OF  CONTENTS/
SBMEND=	.

============  .LIST & .NLIST  ============

.LIST:	MOVE	%00,[XWD LISSET,LISTBL]	; CALL SUBROUTINE TO PARSE
	PUSHJ	RLINK,ARGSET		; ARGUMENT FIELD
	AOSA	LSTCNT		; ** NO ARGS -- INCREMENT LIST LEVEL
	POPJ	RLINK,
	JRST	LISTYP


.NLIST:	MOVE	%00,[XWD LISRES,LISTBL]	; CALL ARG PARSER
	PUSHJ	RLINK,ARGSET
	SOSA	LSTCNT		; ** NO ARGS -- DECREMENT LIST LEVEL
	POPJ	RLINK,

LISTYP:	HRRZ	%00,LSTCTL	; EITHER .LIST OR .NLIST HAD NO ARGS
	TRNN	%00,LLD		; SHOULD IT BE LISTED?
	TLO	%16,NLISLN	; NO - SET "UNLIST LINE" FLAG
	POPJ	RLINK,



LISSET:	PUSHJ	RLINK,LSSSUB	; /// EXECUTED BY ARGSET ///
LISRES:	PUSHJ	RLINK,LSRSUB	; /// EXECUTED BY ARGSET ///

LSSSUB:	TSNN	%02,LSTCTL	; SET LIST FLAG, UNLESS IT WAS
	IORM	%02,LSTCTL	; OVERRIDEN BY COMMAND LINE.
	POPJ	RLINK,

LSRSUB:	TSNN	%02,LSTCTL	; RESET LIST FLAG, UNLESS
	ANDCAM	%02,LSTCTL	; OVERRIDEN BY COMMAND LINE.
	POPJ	RLINK,


LISTBL:	XWD	-17,.+1			; 15 ARGS IN LISTBL
	ARG	B,E,X,LBEX		; TABLE OF .LIST & .NLIST OPERANDS
	ARG	B,I,N,LBIN
	ARG	C,O,M,LCOM
	ARG	C,N,D,LCND
	ARG	L,D, ,LLD
	ARG	L,O,C,LLOC
	ARG	M,C, ,LMC
	ARG	M,D, ,LMD
	ARG	M,E, ,LME
	ARG	M,E,B,LMEB
	ARG	S,E,Q,LSEQ
	ARG	S,R,C,LSRC
	ARG	S,Y,M,LSYM
	ARG	T,O,C,LTOC
	ARG	T,T,M,LTTM
;	===========  .ENABL  &  .DSABL  ============

.ENABL:
	PUSH	RLINK,RMODE		; SAVE MODE FLAGS
	MOVE	%00,[XWD ENASET,ENATBL]	; LOAD PARMS & CALL ARGSET
	PUSHJ	RLINK,ARGSET		; TO SET FLAGS

	TRO	RERR,ERRQ		; NO PARMS => Q ERROR
	POP	RLINK,%00		; RETRIEVE OLD FLAGS
	XOR	%00,RMODE		; R0 = BITS TURNED ON BY .ENABL
	TLNE	%00,ABSFLG		; WAS ABS MODE SET?
	TLZ	RLOC,(PFMASK)		; YES - RESET RELOCATION
	POPJ	RLINK,


.DSABL:
	MOVE	%00,[XWD ENARES,ENATBL]
	PUSHJ	RLINK,ARGSET		; CALL SUBR TO INTERPRET ARGS
	TRO	RERR,ERRQ		; NONE => Q ERROR
	POPJ	RLINK,


ENASET:	TLO	RMODE,0(%02)	; ** EXECUTED TO ENABLE A MODE **
ENARES:	TLZ	RMODE,0(%02)	; ** EXECUTED TO DISABLE A MODE **

ENATBL:	XWD	-11,.+1			; .ENABL/.DSABL ARGUMENTS
	ARG	A,B,S,ABSFLG
	ARG	A,M,A,AMAFLG
	ARG	C,D,R,CDRFLG
	ARG	F,P,T,TRNFLG
	ARG	H,O,V,HOVFLG
	ARG	L,C, ,LCFLG
	ARG	L,S,B,LSBFLG
	ARG	N,S,F,NSFBIT
	ARG	P,N,C,PNCFLG

;	************  .ERROR AND .PRINT  *************

.ERROR:	TRO	RERR,ERRP	; FLAG LINE WITH "P" (!)

.PRINT:	TLNE	RMODE,P1F	; IGNORE .ERROR & .PRINT
	POPJ	RLINK,		; ON PASS 1

	TLO	%16,LBLBIT!PF1BIT!ERRBIT  ; PRINT LOC & EXPR VALUE
	MOVEM	RLOC,PF0		; ON BOTH TTY & LISTING

;	LIST EXPRESSION VALUE, IF ONE EXISTS

	PUSHJ	RLINK,EXPR	; EVALUATE EXPRESSION, IF ANY.
	CAIA			; NO EXPRESSION - LEAVE PF1=0
	MOVEM	%10,PF1		; STORE EXPR VALUE IN PRINT FIELD 1

	LDB	%14,RBPTR	; LOAD NEXT INPUT BYTE
				; (NOTE THAT EXPR ADVANCED TO
				; THE NEXT NONBLANK BYTE)
	CAIE	%14,";"		; DOES COMMENTARY TEXT START HERE?
	POPJ	RLINK,		; NO - LET ENDL SET Q FLAG.

;	   ALTER LINE IN BUFFER SO THAT ONLY TEXT FOLLOWING
;	   THE ";" PRINTS.  THIS IS ACCOMPLISHED BY OVERLAYING
;	   ALL CHARACTERS PRECEDING THE ";" WITH "ELLCHR", THE
;	   END LOGICAL LINE CHARACTER, WHICH ENDL SKIPS DURING
;	   LISTING.

	MOVEI	%00,ELLCHR	; LOAD BYTE TO OVERLAY LINE WITH
	MOVE	%01,LINPNT	; LOAD POINTER TO START OF LINE.

PROVLY:	DPB	%00,%01		; OVERLAY NEXT BYTE.
	IBP	%01		; ADVANCE BYTE POINTER.
	CAME	%01,RBPTR	; HAS IT REACHED ";" YET?
	JRST	PROVLY		; NO - CONTINUE OVERLAYING.

	POPJ	RLINK,		; DONE - RETURN.

E:				;"BYT" PSEUDO-OP
	PUSH	%17,%05		;STACK PC
.BYTE1:	PUSHJ	%17,EXPRF	;EVALUATE EXPRESSION
	 JFCL			;  ACCEPT NULLS
	TRCN	%10,177400	;OVERFLOW?
	JRST	.+3		;  NO.
				;HIGH BITS ARE NOW COMPLEMENTED.
	TRZE	%10,177400	;MASK TO 8 BITS.
				;ANY OVERFLOW
	TRO	%15,ERRT	;YES, FLAG IT
	PUSHJ	%17,TSTAR
	LDB	%02,MODPNT	;GET CLASS
	CAIE	%02,RLDT1
	CAIN	%02,RLDT15	;IF RELOCATABLE,
	TRO	%15,ERRA	;  ERROR
	TLC	%01,BC1!BC2	;RESET TO ONE BYTE
	PUSHJ	%17,STCODE
	CAIE	%14,","		;ANY MORE
	JRST	.WORDX		;  NO, EXIT
	PUSHJ	%17,GETNB	;BYPASS COMMA
	AOJA	%05,.BYTE1	;INCREMENT PC AND LOOP


.WORD:				;"WORD" PSEUDO-OP
	PUSHJ	%17,TSTEVN
	PUSH	%17,%05		;STACK PC
.WORD1:	PUSHJ	%17,EXPRF	;EVALUATE EXPRESSION
	 JFCL			;  ACCEPT NULLS
	PUSHJ	%17,TSTAR
	PUSHJ	%17,STCODE
	CAIE	%14,","		;END OF STRING?
	JRST	.WORDX		;  YES, EXIT
	PUSHJ	%17,GETNB	;BYPASS COMMA
	ADDI	%05,2		;INCREMENT PC
	JRST	.WORD1		;GO FOR MORE

.WORDX:	POP	%17,%05		;RESTORE ORIGINAL PC
	POPJ	%17,


.BLKW:	TDZA	%03,%03		; "BLKW" PSEUDO-OP - %03 = 0

.BLKB:				;"BLKB" PSEUDO-OP
	HRLZI	%03,DEFSYM	; %03 = DEFSYM
	PUSH	RLINK,%03	; SAVE WORD/BYTE FLAG (%03)
	PUSHJ	RLINK,EXPR	;EVALUATE EXPRESSION
	TRO	%10,1		;DEFAULT NULL EXPR TO 1
	PUSHJ	RLINK,ABSTST	;TEST IF ABSOLUTE EXPRESSION
	POP	RLINK,%03	; RESTORE WORD/BYTE FLAG
	TLO	%16,LBLBIT!PF1BIT ; FORCE LOC & EXPR TO PRINT
	MOVEM	RLOC,PF0	; STORE LOC TO PRINT
	MOVEM	%10,PF1		; STORE EXPR TO PRINT

	TLON	%03,DEFSYM	; CHECK IF THIS IS .BLKW
	LSH	%10,1		;    YES, MULT 2*EXPR
	ORM	%03,PF1		; MAKE SURE ZERO PRINTS
	ADD	%05,%10		; INCREMENT PC AS CALCULATED
	MOVE	%01,%05		; GET PC
	HRLI	%01,(<RLDT10>B<MODOFF>) ; FLAG AS CLASS 10
	JRST	STCODE		; STOW CODE & EXIT

.ROUND:	TLZA	%15,TRNFLG	;CLEAR TRUNCATION FLAG
.TRUNC:	TLO	%15,TRNFLG	;SET TRUNCATION FLAG
	POPJ	%17,

.FLT2:	SKIPA	%03,[2]		;TWO WORD FLOATING
.FLT4:	MOVEI	%03,4		;FOUR WORD FLOATING
	MOVEM	%03,FLTLEN	;SET LENGTH FOR ROUNDING
.FLTC:	PUSHJ	%17,FLTG	;PROCESS FLOATING POINT
	TLNE	%15,FLTFLG	;ANY ERRORS?
	TRO	%15,ERRA	;  YES
	MOVN	%06,FLTLEN	;SET NEGATIVE OF LENGTH
	HRLZS	%06		;SET INDEX
.FLTC1:	MOVE	%01,FLTNUM(%06)	;GET A VALUE
	HRLI	%01,BC2
	PUSHJ	%17,STCODE	;STORE IT
	AOBJN	%06,.FLTC1	;LOOP IF MORE
	CAIE	%14,","		;MULTIPLE?
	JRST	.FLTC2		;  NO
	PUSHJ	%17,GETNB	;YES, MOVE PAST COMMA
	JRST	.FLTC		;GET ANOTHER

.FLTC2:	TLNN	%15,P10FLG	;".PDP10" MODE?
	POPJ	%17,		;  NO, LEAVE
	HRROI	%03,774000
	MOVE	%06,FLTLEN
	CAIN	%06,2		;TWO WORD?
	ANDM	%03,FLTLST	;  YES, TRUNCATE
	MOVE	%01,[POINT 7,FLTBUF]	;SET POINTER TO BUFFER
	MOVEI	%02,";"
	IDPB	%02,%01		;STORE ";"
	MOVEI	%02,"("
	IDPB	%02,%01		;  AND "("
	LDB	%00,[POINT 9,FLTNUM,35-16+9]
	MOVEI	%02,"0"
	TRZE	%00,400		;SIGN BIT?
	MOVEI	%02,"1"		;  YES
	IDPB	%02,%01
	MOVEI	%02,SPACE
	IDPB	%02,%01
	MOVSI	%03,(POINT 3,%00,35-9)
.FLTC3:	ILDB	%02,%03		;STORE EXPONENT
	ADDI	%02,"0"
	IDPB	%02,%01
	TLNE	%03,770000
	JRST	.FLTC3
	MOVEI	%02,SPACE
	IDPB	%02,%01
	MOVE	%03,[POINT 3,FLTLST]	;GET SET TO LIST FRACTION
	MOVEI	%00,^D9		;ASSUME DOPBLE WORD
	CAIE	%06,2
	MOVEI	%00,^D19
.FLTC4:	ILDB	%02,%03
	ADDI	%02,"0"
	IDPB	%02,%01
	SOJG	%00,.FLTC4	;LOOP IF NOT END
	MOVEI	%02,")"		;STORE END CHARACTERS
	IDPB	%02,%01
	MOVEI	%02,CRR
	IDPB	%02,%01
	MOVEI	%02,LF
	IDPB	%02,%01
	IDPB	%00,%01		;STORE NULL
	POPJ	%17,

:
	TLZ	%15,FLTFLG	;CLEAR ERROR FLAG
	SETZB	%00,FLTNUM
	SETZB	%01,FLTNUM+1
	SETZB	%02,FLTNUM+2
	SETZB	%03,FLTNUM+3
	SETZM	FLTLST		;CLEAR FOR EXPANDED LISTING
	SETZM	FLTLST+1
	CAIN	%14,"-"
	TLO	%00,(1B0)
	EXCH	%00,FLTNUM
	SKIPL	FLTNUM
	CAIN	%14,"+"
FLTG2:	PUSHJ	%17,GETCHR
	CAIL	%14,"0"
	CAILE	%14,"9"
	JRST	FLTG3
	TLNE	%00,760000
	AOJA	%03,FLTG2
	ASHC	%00,1
	MOVEM	%00,FLTTMP
	MOVEM	%01,FLTTMP+1
	ASHC	%00,2
	ADD	%00,FLTTMP
	ADD	%01,FLTTMP+1
	ADDI	%01,-"0"(%14)
	TLZE	%01,(1B0)
	ADDI	%00,1
	AOBJP	%03,FLTG2

FLTG3:	CAIE	%14,"."
	JRST	FLTG4
	TRNE	%02,400000
	TLO	%15,FLTFLG
	MOVEI	%02,400000(%03)
	JRST	FLTG2

FLTG4:	SKIPN	%03
	TLO	%15,FLTFLG
	TRZN	%02,400000
	HRRZ	%02,%03
	HLRZS	%03
	SUB	%02,%03
	CAIE	%14,"E"
	JRST	FLTG6
	PUSHJ	%17,GETCHR

	PUSH	%17,%00
	PUSH	%17,%01
	SETZB	%00,%01
	CAIN	%14,"-"
	SOSA	%01
	CAIN	%14,"+"
FLTG5:	PUSHJ	%17,GETCHR
	CAIL	%14,"0"
	CAILE	%14,"9"
	JRST	FLTG5A
	IMULI	%00,^D10
	ADDI	%00,-"0"(%14)
	JRST	FLTG5

FLTG5A:	SKIPE	%01
	MOVNS	%00
	ADD	%02,%00
	POP	%17,%01
	POP	%17,%00
FLTG6:	CAIN	%01,0
	JUMPE	%00,FLTG12
	TDZA	%03,%03
FLTG7:	ASHC	%00,1
	TLNN	%00,200000
	SOJA	%03,FLTG7
	JUMPL	%02,FLTG9
FLTG8:	SOJL	%02,FLTG10
	MOVEM	%00,FLTTMP
	MOVEM	%01,FLTTMP+1
	ASHC	%00,-2
	ADD	%00,FLTTMP
	ADD	%01,FLTTMP+1
	TLZE	%01,(1B0)
	ADDI	%00,1
	TLNE	%00,(1B0)
	PUSHJ	%17,FLTG20
	ADDI	%03,3
	JRST	FLTG8

FLTG9:	CAML	%00,[^D10B4]
	PUSHJ	%17,FLTG20
	PUSH	%17,%01+1
	DIV	%00,[^D10B4]
	DIV	%01,[^D10B4]
	POP	%17,%01+1
	SUBI	%03,4
	AOJL	%02,FLTG9
FLTG10:	PUSH	%17,%03		;STACK EXPONENT
	MOVSI	%02,(1B<16-7>)	;SET ONE WORD ROUNDING BIT
	SETZ	%03,		;CLEAR LOW ORDER
	SKIPA	%04,FLTLEN	;GET LENGTH AND SKIP
	ASHC	%02,-^D16	;MOVE ROUNDING MASK
	SOJG	%04,.-1
	TDNN	%00,%02		;TEST FOR ROUNDING REQUIRED
	TDNE	%01,%03
	TLNE	%15,TRNFLG	;YES, "ROUND" MODE?
	JRST	FLTG11		  ;NO, FORGET ROUNDING
	ASHC	%02,1		;SHIFT BIT UP ONE
	ADD	%00,%02
	ADD	%01,%03		;ADD IN BIT
FLTG11:	POP	%17,%03		;RESTORE EXPONENT
	TLZE	%01,(1B0)	;OVERFLOW, LOW ORDER?
	ADDI	%00,1		;  YES, ADD TO UPPER
	TLNE	%00,(1B0)	;OVERFLOW, HIGH ORDER?
	PUSHJ	%17,FLTG20	;  YES, CORRECT
	LSH	%01,1		;MOVE OVER SIGN BIT
	MOVEM	%00,FLTLST	;STORE FOR EXPANDED LISTING
	MOVEM	%01,FLTLST+1
	LSHC	%00,-7		;MAKE ROOM FOR EXPONENT
	ADDI	%03,^D<35+35+128>
	DPB	%03,[POINT 8,%00,8]
	LDB	%02,[POINT 8,%00,8]
	CAME	%02,%03		;OVER/UNDER FLOW?
	TRO	%15,ERRT	;  YES
FLTG12:	IOR	%00,FLTNUM
	MOVSI	%02,-4
FLTG13:	LDB	%03,[POINT 16,%00,15]
	MOVEM	%03,FLTNUM(%02)
	LSHC	%00,^D16
	AOBJN	%02,FLTG13
	JRST	SETNB

FLTG20:	LSH	%01,1
	LSHC	%00,-1
	LSH	%01,-1
	AOJA	%03,CPOPJ

	SUBTTL	ASSEMBLER DIRECTIVE ARGUMENT INTERPRETER

;	SUBROUTINE ARGSET PARSES THE REMAINING INPUT ON THE LINE,
;	CHECKING FOR ARGUMENTS SPECIFIED IN A TABLE SUPPLIED BY
;	THE CALLER.  WHEN IT FINDS ONE, IT EXECUTES AN INSTRUCTION
;	SUPPLIED BY THE CALLER WITH A VALUE FROM THE TABLE IN R2.

;	INPUT TO ARGSET:

;	R0 HIGH ORDER HALFWORD = ADDRESS OF INSTRUCTION TO EXECUTE
;		WHEN A PROPER ARG IS FOUND
;	R0 LOW ORDER HALFWORD = ADDRESS OF ARGUMENT TABLE

;	CALL IS VIA "PUSHJ RLINK,ARGSET"

;	RETURNS:

;	0(RLINK) -- NO ARGUMENTS FOUND
;	1(RLINK) -- ONE OR MORE ARGUMENTS WERE FOUND

;	IF AN INVALID ARGUMENT APPEARS IN THE SOURCE LINE
;	ARGSET SETS "ERRQ" TO GENERATE A Q FLAG.


;	FORMAT OF ARG TABLE:

;	WORD 0:		XWD -(# OF ENTRIES IN TABLE),.+1
;	WORDS 1-N :	VALUE,ARGCODE
;
;		VALUE IS ANY VALUE DESIRED (LIKELY A BIT MASK)
;			TO BE LOADED IN R2 WHEN THE ARG IS FOUND
;			& THE CALLER'S INSTRUCTION IS EXECUTED.

;		ARGCODE IS THE ARGUMENT IN MOD40 FORMAT


ARGSET:	PUSH	RLINK,%00	; SAVE CALLER'S PARMS
	PUSHJ	RLINK,GETSYM		; DECODE NEXT SYMBOL
	CAIA				; - SKIP IF NONE
	JRST	ARSER			; EXIT TO SEARCH TABLE

	POP	RLINK,%00	;**** NO ARGUMENT -- POP STACK
	POPJ	RLINK,			; & RETURN TO CALLER


;	*** SCAN FOR NEXT ARGUMENT ***

ARNEX:	IBP	RBPTR			; SKIP ","
	PUSHJ	RLINK,GETSYM		; TRY FOR ANOTHER SYMBOL
	JRST	AREXIT			; NONE -- QUIT HERE

;	SEARCH ARGUMENT TABLE FOR THE SYMBOL JUST FOUND

ARSER:	TRZE	%00,			; IS SYMBOL LONGER THAN 3 CHARS?
	JRST	ARBAD			; YES -- INVALID ARGUMENT
	MOVSS	%00,			; NO -- MOVE SYM TO RIGHT HALF
	HRRZ	%01,0(RLINK)		; LOAD TABLE LOC, THEN
	MOVE	%01,0(%01)		; LOOP CONTROL WORD INTO %01

ARSERL:	HRRZ	%03,0(%01)		; LOAD ARG VALUE FROM TABLE
	CAMN	%03,%00			; DOES OPERAND MATCH?
	JRST	ARFOUN			; YES
	AOBJN	%01,ARSERL		; NO - KEEP SEARCHING

ARBAD:	TRO	RERR,ERRQ		; INVALID ARG -- SET Q FLAG
	JRST	AREXIT			; & QUIT

ARFOUN:	HLRZ	%02,0(%01)		; FOUND ARG -- LOAD VALUE
	HLRZ	%01,0(RLINK)		; FROM TABLE & EXECUTE
	XCT	0(%01)			; CALLER'S INSTRUCTION

	LDB	%00,RBPTR		; CHECK NEXT SOURCE BYTE
	CAIN	%00,","			; TEST FOR ","
	JRST	ARNEX			; "," => GET ANOTHER ARG

AREXIT:	POP	RLINK,%00		; RETURN AFTER FINDING AN ARG
	JRST	CPOPJ1

	SUBTTL	REPEAT HANDLER

REPEA0:				;"REPEAT" PSEUDO-OP
	PUSHJ	RLINK,MDLTST	; TEST MD LISTING MODE
	PUSHJ	%17,ABSEXP	;EVALUATE EXPRESSION
	TRNE	%15,ERRU	;ANY UNDEFINED ERRORS?
	TRO	%15,ERRP1	;  YES, MENTION ON PASS 1
	LSH	%10,+^D<36-16>	;ADJUST SIGN TO 36 BITS
	ASH	%10,-^D<36-16>
	CAIN	%10,1		;IF SINGLE,
	JRST	BEGR0		;  PROCESS IN LINE
	PUSH	%17,%10		;STACK EXPRESSION
	PUSHJ	%17,ENDLR	;LIST LINE
	PUSHJ	%17,GETBLK	;MULTIPLE, SDT FOR STORAGE
	PUSH	%17,MWPNTR	;SAVE STARTING BLOCK ADDRESS
	MOVEI	%11,3
	ADDM	%11,MWPNTR	;POINT PAST POINTER STORAGE
	SETZ	%07,		;ZERO LEVEL COUNT
REPEA1:	PUSHJ	%17,GETMLI	;GET THE NEXT SOURCE LINE
	 JRST	REPEA3		;  END OF FILE
	CAMN	%00,.REPTX
	AOJA	%07,REPEA2	;  INCREMENT AND BRANCH
	CAME	%00,.ENDMX	; CHECK FOR EITHER .ENDM OR .ENDR
	CAMN	%00,.ENDRX
	SOJL	%07,REPEA3	;  DECREMENT AND BRANCH IF END
REPEA2:	SKIPA	%13,LINPNT	;POINT TO START OF LINE
	PUSHJ	%17,WCIMT	;WRITE CHAR IN MACRO TREE
	PUSHJ	%17,GETCHR	;GET THE NEXT CHARACTER
	JUMPN	%14,.-2		;TEST FOR CR
	PUSHJ	%17,ENDLR	;LIST THE LINE
	TLNN	%15,ENDFLG	;SKIP IF EOF SEEN
	JRST	REPEA1		;TRY THE NEXT LINE

REPEA3:	TLO	%15,RSWFLG	;FLUSH THIS LINE
	MOVEI	%14,QUEREP	;END, SET TO CLOSE
	PUSHJ	%17,WTIMT	;WRITE FLAG AND "REPEAT END"
	POP	%17,%11		;RETRIEVE STARTING POINTER
	MOVEI	%10,-1(%11)	;SET FOR PUSH
	PUSH	%10,%12		;STORE READ POINTER
	PUSH	%10,REPPNT	;  REPEAT POINTER
	PUSH	%10,REPEXP	;  AND REPEAT EXPRESSION
	MOVEM	%11,REPPNT	;SET NEW REPEAT POINTER
	POP	%17,REPEXP	;  AND REPEAT COUNT
;	JRST	REPEND

REPEND:				;REPEAT END
	MOVE	%12,REPPNT	;ASSUME ANOTHER ITERATION
	ADDI	%12,3		;POINT PAST POINTERS
	SOSL	REPEXP		;END?
	POPJ	%17,		;  NO
	MOVE	%01,REPPNT	;  YES, GET SET TO CLEAN UP
	HRROI	%10,2(%01)	;POINT TO TOP POINTER
	POP	%10,REPEXP	;REPLACE STORED ITEMS
	POP	%10,REPPNT
	POP	%10,%12
	PUSHJ	%17,REMMAC	;GARBAGE COLLECT
	POPJ	%17,		;EXIT


;    REPEATS CAN BE ENDED BY EITHER A .ENDM OR A .ENDR;
;	   .ENDM'S WHICH END A MACRO ARE PROCESSED ONLY BY
;	   THE MACRO DEFINITION PROCESSOR -- WHEN THE STATEMENT
;	   PROCESSOR FINDS A .ENDM, AND DISPATCHES TO LOCATION
;	  .ENDM, IT MUST BE THE END OF A REPEAT.

.ENDM:

ENDR0:				;  ".ENDR" PSEUDO-OP
	SKIPG	REPLVL		;IN REPEAT?
	JRST	OPCERR		;  NO, ERROR
	SOSA	REPLVL		;YES, DECREMENT LEVEL COUNT
BEGR0:	AOS	REPLVL		;REPEAT ONCE
	TLO	%15,RSWFLG	;FLUSH THIS LINE
	POPJ	%17,

	SUBTTL	REPEAT/CONDITIONAL ROUTINES

.IFNDF:	TDZA	%02,%02
.IFDF:	SETO	%02,		;SET TRUE
	SETOB	%03,%04		;SET RESULT AND CHAR TRUE (&)
.IFDF1:	PUSH	%17,%04		;STACK CURRENT RESULTS
	PUSH	%17,%03
	PUSH	%17,%02
	PUSHJ	%17,GETSYM	;GET THE NEXT SYMBOL
	 TROA	%15,ERRA	;  NOT THERE, ERROR AND SKIP
	PUSHJ	%17,SSRCH	;SEARCH THE SYMBOL TABLE
	 SETZ	%01,		;  NOT THERE OR GETSYM ERROR
	SKIPE	%00		;DON'T CREF NULL
	PUSHJ	%17,CRFREF
	TLNE	%01,MDFSYM
	TRO	%15,ERRD	;FLAG IF MULTI-DEFINED SYM
	TLNN	%01,DEFSYM	;FLAGGED AS DEFINED?
	TDZA	%01,%01		;  NO, CLEAR TO ZERO
	SETO	%01,		;  YES, SET TRUE
	POP	%17,%02		;RETRIEVE REGISTERS
	POP	%17,%03
	POP	%17,%04
	XCT	[EXP <AND %03,%01>, <IOR %03,%01>]+1(%04)
	MOVE	%04,%02		;ANTICIPATE END
	EQV	%04,%03
	HRLI	%04,1		;MARK PNZ
	CAIN	%14,"&"		;TEST FOR OPS
	MOVE	%04,%02
	CAIN	%14,"!"
	SETCM	%04,%02
	JUMPG	%04,@[EXP BEGC0, FALSE]+1(%04)
	PUSHJ	%17,GETNB	;FOUND OP, BYPASS IT
	JRST	.IFDF1		;LOOP


JMPER:	
	MOVE	%01,CONDX+1(%03)
	JRST	0(%01)

.IF:
	PUSHJ	%17,GETSYM	;GET CONDITION
	TROA	%15,ERRA	;NO CONDITION
	MOVSI	%03,-<CONDY-CONDX>	;SET FOR SCAN
	TRNN	%03,1		;IGNORE ODD LOCATIONS
	CAME	%00,CONDX(%03)	;MATCH
	AOBJN	%03,.-2		;NO
	SKIPG	%03
	JRST	JMPER
	TROA	%15,ERRA	;CONDITION DIDN'T MATCH
	POPJ	%17,





.IFB:				;IF BLANK CONDITIONAL
	SKIPG	MACLVL		;IN MACRO EXPANSION
	JRST	OPCERR		;NO!
	PUSHJ	%17,SETNB	;GET NEXT NON BLANK CHAR
	CAIN	%14,015		;IF CR THEN IT WAS BLANK
	JRST	BEGC0		;IT WAS BLANK
	PUSHJ	%17,GETEOL	;FIND THE END OF LINE
	JRST	FALSE		;NOT BLANK


.IFNB:
	SKIPG	MACLVL		;IN MACRO EXPANSION
	JRST	OPCERR		;NO!
	PUSHJ	%17,SETNB	;PAST BLANKS
	CAIN	%14,015		;IS NEXT CHAR A CR
	JRST	FALSE		;ARG WAS BLANK
	PUSHJ	%17,GETEOL	;NOT BLANK GET END OF LINE
	JRST	BEGC0


GETEOL:
	PUSHJ	%17,GETNB	;GET THE NEXT CHARACTER
	CAIE	%14,015		;CR FOR END OF LINE
	JRST	GETEOL		;NO
	POPJ	%17,		;YES RETURN






.IFT:				;GENERATING CODE UNDER .IFTF OR .IFF
	SKIPG	CONLVL		;EXPANDING A MACRO
	JRST	OPCERR
	MOVE	%01,.IFFLG
	TRNN	%01,TRUE	;SKIP IF TRUE

	JRST	.IFIF		;LAST CONDITION WAS FALSE
	JRST	BEGC01		;LAST CONDITION WAS TRUE


.IFTF:				;GENERATING CODE UNDER .IFT,.IFF
	SKIPG	CONLVL		;EXPANDING A MACRO
	JRST	OPCERR		;NO
	POPJ	%17,		;CODE GOES



.IFF:				;GENERATING CODE UNDER .IFTF, .IFT
	SKIPG	CONLVL		;EXPANDING MACRO
	JRST	OPCERR		;NO
	MOVE	%01,.IFFLG	; RELOAD LAST CONDITION WORD
	TRNN	%01,TRUE	;TEST LAST CONDITION RESULT
	POPJ	%17,		;LAST CONDITION FALSE
	JRST	.IFIF		;LAST CONDITION WAS TRUE


FALSE:				;GET HERE WHEN OUTER LEVEL
				;IS FALSE
	AOS	CONLVL		;COULD GET OUT ON .IFF THEN .ENDC
	MOVE	%01,.IFFLG
	LSH	%01,1		;SHIFT IN 0
	MOVEM	%01,.IFFLG	;MEANS FALSE

.IFIF:				;USED DURING 0 LEVEL OF NO CODE
				;GENERATION
	PUSHJ	%17,CNLTST	;TEST FOR .NLIST
	PUSHJ	%17,ENDLR	;LIST THE LINE
	PUSHJ	%17,GETMLI	;GET NEXT LINE
	POPJ	%17,		;EOF SEEN
	MOVSI	%03,-<.IFY-.IFX>	;SET FOR SCAN
	TRNN	%03,1		;IGNORE IF ODD LOCATION
	CAME	%00,.IFX(%03)
	AOBJN	%03,.-2
	SKIPG	%03		;GREATER IF NO MATCH
	JRST	TESTIF		;IT'S AN IF
	CAMN	%00,.ENDCX		;NOT IF, IS IT ENDC
	JRST	ENDC0		;YES IT WAS .ENDC
	PUSHJ	%17,TSTNT		;TERMINATOR
	JRST	.IFIF		;YES
	PUSHJ	%17,GETNT		;NO, GET ONE
	JRST	.IFIF		;GOT IT
	JRST	.-2


FAL:				;PREVIOUS CONDITION WAS FALSE
	CAMN	%00,.IFFX		;.IFF WHEN IN FALSE

	JRST	BEGC01		;YES -- GO GENERATE CODE
	CAMN	%00,.IFTX
	JRST	.IFIF
	JRST	..NOGO		;NO -- RETURN


TRU:				;LAST CONDITION WAS TRUE
	CAMN	%00,.IFTX	;.IFT WHEN IN TRUE
	JRST	BEGC01		;YES,GENERATE CODE
	CAMN	%00,.IFFX
	JRST	.IFIF
	JRST	..NOGO


TESTIF:				;UNDER FALSE, FOUND .IFF, .IFT,
				;OR .IFTF, .IF CONDITION
	CAMN	%00,.IFTFX	;.IFTF
	JRST	BEGC01		;YES
	MOVE	%01,.IFFLG
	TRNN	%01,TRUE	;ARE WE IN A TRUE CONDITION
	JRST	FAL
	JRST	TRU		;IN TRUE
..NOGO:	AOS	UNSLVL		;LEVEL COUNTER
	PUSHJ	%17,UNSCO2	  ;FIND .ENDC
	POPJ	%17,		;EOF SEEN
	JRST	.IFIF		;RETURN AFTER .ENDC MATCHING



IFZ0:	JSP	%03,IF0
	 SKIPE	%10

IFNZ0:	JSP	%03,IF0
	 SKIPN	%10

IFG0:	JSP	%03,IF0
	 SKIPG	%10

IFGE0:	JSP	%03,IF0
	 SKIPGE	%10

IFL0:	JSP	%03,IF0
	 SKIPL	%10

IFLE0:	JSP	%03,IF0
	 SKIPLE	%10

IF0:	PUSH	%17,0(%03)	;STACK INSTRUCTION
	PUSHJ	%17,ABSEXP	;VALUATE EXPRESSION
	LSH	%10,+^D<36-16>	;ADJUST SIGN
	ASH	%10,-^D<36-16>
	POP	%17,%03		;RETRIEVE INSTRUCTION
	XCT	%03		;EXECUTE IT
	 JRST	FALSE		;  DIDN'T MAKE IT
	JRST	BEGC0		;SATISFIED


ERREX:
	TRO	%15,ERRQ	;FLAG ERROR
	POPJ	%17,		;IGNORE POSSIBLE CONDITIONAL

TWOSYM:				;USED BY .IF IDN AND .IF DIF
				;TO PICK UP BOTH SYMBOLS IN REG
				;REG0 AND REG3
	PUSHJ	%17,GETSYM	;GET NAME OF FIRST SYMBOL
	POPJ	%17,		;NO SYMBOL THERE, FALSE CONDITION
	CAIE	%14,","		;TEST FOR COMMA
	JRST	ERREX		;NO COMMA, SYNTAX ERROR
	PUSHJ	%17,GETNB	;GET NON-BLANK CHARACTER
	PUSH	%17,%00		;STACK THE NAME FROM GETSYM
	PUSHJ	%17,GETSYM	;GET NAME OF SECOND SYMBOL
	JRST	ERR		;NO SECOND SYMBOL
	POP	%17,%03		;GET THE SAVED SYMBOL
	JRST	CPOPJ1		;RETURNS +1

ERR:	POP	%17,%00		;GET STACK BACK IN SHAPE
	POPJ	%17,		;FALSE CONDITION



.IFIDN:				;.IF IDN--ARE MACRO ARGS IDENTICAL
	SKIPG	MACLVL		;EXPANDING A MACRO
	JRST	OPCERR		;NOPE
	PUSHJ	%17,TWOSYM	;GET BOTH SYMBOLS
	JRST	FALSE		;ERROR OR A MISSING ARG
	CAME	%00,%03		;ARE ARGS IDENTICAL?
	JRST	FALSE		;NOPE
	JRST	BEGC0		;YEP


.IFDIF:				;.IF DIF -- ARE MACRO ARGS DIFFERENT
	SKIPG	MACLVL		;EXPANDING A MACRO
	JRST	OPCERR	;NOPE
	PUSHJ	%17,TWOSYM	;GET BOTH SYMBOLS
	JRST	FALSE
	CAMN	%00,%03		;ARE ARGS DIFFERENT
	JRST	FALSE
	JRST	BEGC0	;YEP

ON:	SETZM	UNSLVL		;CREAR LEVEL COUNT
UNSCO1:	PUSHJ	RLINK,CNLTST	; TEST FOR .NLIST CND
	PUSHJ	%17,ENDLR	;LIST THE LINE
	PUSHJ	%17,GETMLI	;GET THE NEXT LINE
	 POPJ	%17,		;EOF SEEN
	MOVSI	%03,-<.IFY-.IFX>	;SET FOR SCAN
	TRNN	%03,1		;IGNORE IF ODD LOCATION
	CAME	%00,.IFX(%03)	;SKIP IF MATCH
	AOBJN	%03,.-2		;LOOP IF NOT END
	SKIPGE	%03		;END, SKIP IF NO MATCH
	JRST	CHKADDR		;DON'T INCR FOR .IFF,ETC
	CAMN	%00,.ENDCX	;"ENDC"?
	SOSLE	UNSLVL		;  YES, SKIP IF NOT NESTED
	JRST	UNSCO2		;TRY FOR MORE
	TLO	%15,RSWFLG	;THROUGH, FLUSH THIS LINE
	JRST	CPOPJ1			;GOOD, RETURN+1

UNSCO2:	PUSHJ	%17,TSTNT	;TEST FOR TERMINATION
	 JRST	UNSCO1		;  YES
	PUSHJ	%17,GETNT	;NO, GET ONE
	 JRST	UNSCO1
	JRST	.-2


CHKADD:	CAMN	%00,.IFFX	;.IFF
	JRST	UNSCO2		;YES, DON'T LOOK FOR .ENDC
	CAMN	%00,.IFTX	;.IFT
	JRST	UNSCO2		;YES, DON'T LOOK FOR .ENDC
	CAMN	%00,.IFTFX	;.IFTF
	JRST	UNSCO2		;YES, DON'T LOOK FOR .ENDC
	AOS	UNSLVL		;IT WAS .IF COND, LOOK FOR .ENDC
	JRST	UNSCO2



ENDC0:				;  ".ENDC"
	SKIPG	CONLVL		;ARE WE IN A CONDITIONAL?
	JRST	OPCERR		;  NO, ERROR
	MOVE	%01,.IFFLG
	LSH	%01,-1
	MOVEM	%01,.IFFLG

	SOS	CONLVL		;YES, DECREMENT LEVEL
	JRST	BEGC01
BEGC0:	AOS	CONLVL		;INCREMENT LEVEL
	MOVE	%01,.IFFLG
	LSH	%01,1
	TRO	%01,TRUE
	MOVEM	%01,.IFFLG

BEGC01:	PUSHJ	RLINK,CNLTST	; TEST FOR .NLIST CND
	TLO	%15,RSWFLG	;FLUSH THIS LINE
	POPJ	%17,


GETMLI:				;GET MACRO-TYPE LINE

	PUSHJ	RLINK,GETLIN	; GET A BASIC LINE
	PUSHJ	RLINK,MDLTST	; TEST MD LISTING MODE
GETML1:	PUSHJ	%17,GETSYM	;TRY FOR A SYMBOL
	JRST	GETML2		;  NO	
	CAIE	%14,":"		;LABEL?
	JRST	GETML2		;  NO
	PUSHJ	%17,GETNB	;YES, GET ANOTHER
	JRST	GETML1

GETML2:	TLNE	%15,ENDFLG	;EOF SEEN?
	POPJ	%17,		;  YES, BAD EXIT
	JRST	CPOPJ1		;GOOD EXIT

;    SUBROUTINE MDLTST CHECKS THE MACRO DEFINITION LISTING
;	  CONTROL FLAG; IF IT ISN'T SET, .NLIST MD MUST BE
;	  IN EFFECT:  SET NLISLN FLAG TO SUPPRESS LISTING
;	  OF THIS LINE.

MDLTST:	PUSH	%17,%00		;SAVE FOR .IF'S
	MOVE	%00,LSTCTL	;LOAD LISTING CONTROL FLAGS
	TRNN	%00,LMD		; MD TO BE LISTED?
	TLO	%16,NLISLN	; NO - SUPPRESS LINE ON LISTING
	POP	%17,%00		;FOR .IF'S
	POPJ	RLINK,


;   SUBROUTINE CNLTST CHECKS THE LISTING CONTROL FLAG
;	  WHICH GOVERNS LISTING OF UNEXPANDED CONDITIONAL
;	  CODE AND ALL .IF'S & .ENDC'S.  THIS FLAG IS 0 IF
;	  .NLIST CND IS IN EFFECT; IF THIS IS THE CASE,
;	  CNLTST SETS THE NLISLN FLAG TO SUPPRESS
;	  LISTING OF THE CURRENT LINE.

CNLTST:	PUSH	%17,%00
	MOVE	%00,LSTCTL	;LOAD LISTING CONTROL FLAGS.
	TRNN	LCND		; .NLIST CND IN EFFECT?
	TLO	%16,NLISLN	; YES - SUPPRESS LINE LISTING
	POP	%17,%00
	POPJ	RLINK,

	SUBTTL	MACRO HANDLERS

.MCALL:	JRST	GETEOL		; !!! TEMPORARY?!! !!

DEFIN0:				; .MACRO DIRECTIVE
	PUSHJ	RLINK,MDLTST	; ACT ON MD LISTING MODE
	PUSHJ	%17,GETSYM	;GET ITS NAME
	 JRST	DEFERR		;  ERROR, EXIT
	MOVEM	%00,MACNAM	; SAVE MACRO NAME IN NEST NAME TBL
	PUSHJ	%17,GETBLK	;OK, GET A BLOCK FROM STORAGE
	PUSHJ	%17,MSRCH	;SEE IF ALREADY DEFINED
	 MOVSI	%01,MAOP	;NOT THERE, FLAG AS MACRO
	TRNE	%01,-1		;PREVIUSLY DEFINED?
	PUSHJ	%17,DECMAC	;  YES, DECREMENT REFERENCE
	HRR	%01,MWPNTR	;GET POINTER TO START OF BLOCK
	PUSHJ	%17,INSRT	;INSERT/DELETE IN SYMBOL TABLE
	PUSHJ	%17,CRFDEF
	PUSH	%17,MWPNTR	;STACK POINTER TO START OF BLOCK
	MOVEI	%01,2
	ADDM	%01,MWPNTR	;MOVE PAST REFERENCE LEVEL AND ARG COUNT
	TDZ	%07,%07		; SET ARG COUNT = 0


	PUSHJ	RLINK,SETNB	; CHECK FOR "," AFTER MACRO NAME.
	CAIN	%14,","		; IS IT ","?
DEF01:	PUSHJ	%17,GETNB	;MOVE PAST COMMA
	PUSHJ	%17,GETSYM	;GET AN ARG
	 JRST	DEF02		;  NOT THERE
	MOVEM	%00,ARGLST(%07)	;STORE IN LIST
	ADDI	%07,1		;BUMP POINTER
	CAIN	%14,","		;ANY MORE?
	JRST	DEF01		;  YES

DEF02:	PUSH	%17,%07		;STACK ARG COUNT
	SETZM	ARGLST(%07)	;MARK END
	PUSHJ	%17,ENDLR	;LIST THE LINE
	SETZ	%07,		;INIT LEVEL COUNT

;	CODE FROM DEF03 TO DEF04 IS CONCERNED WITH
;	KEEPING TRACK OF .MACRO/.ENDM PAIRS IN POTENTIALLY
;	NESTED MACRO DEFINITIONS.

;	WHEN A .MACRO DIRECTIVE IS FOUND, THE NESTING LEVEL
;	IN %07 IS INCREMENTED, AND THE MACRO NAME IS RECORDED
;	IN MACNAM(%07).  %07 = 0 FOR THE OUTERMOST MACRO.
;	.REPT, .IRP, AND .IRPC ARE TREATED AS NAMELESS MACRO
;	DEFINITIONS (I.E., .MACRO WITHOUT AN OPERAND).


;	WHEN A .ENDM IS FOUND THE ACTION DEPENDS ON ITS OPERAND.
;	-- .ENDR IS TREATED AS A SYNONYM FOR .ENDM.

;	NO OPERAND:  THE NESTING LEVEL (%07) IS DECREMENTED.
;		IF IT GOES NEGATIVE, THE OUTERMOST (I.E., CURRENT)
;		MACRO DEFINITION IS TERMINATED.

;	SYMBOLIC OPERAND:  THE SYMBOL IS MATCHED WITH NAMES IN
;		MACNAM.  WHEN ONE MATCHES, THE NESTING LEVEL IS
;		A) DECREMENTED (DEC'S WAY), OR
;		B) SET TO THE OFFSET OF THE MACRO NAME IN MACNAM.
;		   THIS TERMINATES MACRO DEFINITIONS WITH HIGHER
;		   NESTING LEVELS WHICH ARE STILL OPEN.

;		THE LATTER ACTION IS TAKEN ONLY IF NONSTANDARD
;		FEATURES ARE ENABLED.


DEF03:	PUSHJ	%17,GETMLI	;GET THE NEXT LINE
	 JRST	DEF13		;  EOF SEEN
	CAME	%00,.MACRY
	CAMN	%00,.MACRX
	AOJA	%07,DEF03B	;INCREMENT
	CAME	%00,.REPTX	; IS IT .REPT?
	CAMN	%00,.IRPOP	; .IRP?
	AOJA	%07,DEF03D	; YES - INCR CALL LEVEL
	CAMN	%00,.IRCOP	; IS IT .IRPC?
	AOJA	%07,DEF03D	; YES - LIKE .IRP (ETC)
	CAME	%00,.ENDMX
	CAMN	%00,.ENDRX	; IS OP .ENDR?
	CAIA			; .ENDM OR .ENDR
	JRST	DEF04		; NOT .MACRO OR .ENDM - SKIP

	PUSHJ	RLINK,GETSYM	; .ENDM -- GET ITS OPERAND, IF ANY
	JRST	DEF03A		; NO OPERAND -- JUST POP NEST LEVEL

;  -- PROCESS A .ENDM SPECIFYING A SPECIFIC MACRO TO TERMINATE.

	MOVE	%01,%07		; COPY NEST LEVEL TO SPARE REG

	CAMN	%00,MACNAM(%01)	; IS THIS THE .ENDM OPERAND?
	JRST	DEF03C		; YES - GO TO POPPER
	SOJGE	%01,.-2		; NO - BACK UP TO HIER LEVEL

	TRO	RERR,ERRA	; NO SUCH MACRO IS OPEN . . .
	JRST	DEF03A		; GIVE IT AN "A" FLAG.

;  -- NESTED .MACRO FOUND - ADD ITS NAME TO TABLE & INCR NEST LEVEL.

DEF03B:	PUSHJ	RLINK,GETSYM	; GET MACRO NAME
DEF03D:	SETZ	%00		; NAMELESS .MACRO!.REPT!.IRP!.IRPC
	; MACRO DIRECTIVES WITHOUT MACRO NAMES WILL BE FLAGGED
	; WHEN THE MACRO IS DEFINED; IN THIS CASE THAT HAPPENS
	; WHEN AN OUTER MACRO IS CALLED.
	MOVEM	%00,MACNAM(%07)	; STORE NAME IN NESTED NAME TABLE
	JRST	DEF04

;  -- MODIFY NESTING LEVEL FOR A .ENDM WHICH TERMINATES
;	  A SPECIFIC MACRO.

DEF03C:	TLNE	RMODE,NSFBIT	; NONSTANDARD FEATURES ENABLED?
	MOVE	%07,%01		; YES - SET, THEN POP, NEST LEVEL
DEF03A:	SOJL	%07,DEF13	;END IF MINUS
DEF04:	MOVE	%13,LINPNT	;SET TO START OF LINE
DEF05:	PUSHJ	%17,GETCHR	;GET THE NEXT CHARACTER
DEF06:	CAIE	%14,"'"		;CONCATENATION CHARACTER?
	JRST	DEF06C		;  NO, BRANCH AROUND
DEF06A:	PUSHJ	%17,GETCHR	;YES, GET THE NEXT CHARACTER
	CAIE	%14,"'"		;MULTIPLE?
	JRST	DEF06B		;  NO
	PUSHJ	%17,WCIMT	;YES, SAVE ONLY ONE
	JRST	DEF06A		;TEST FOR MORE
DEF06B:	TLO	%15,CONFLG	;FLAG THE CONCATENATION CHARACTER
DEF06C:	LDB	%02,ANPNTR	;MAP
	JUMPE	%14,DEF12	;BRANCH IF END OF LINE
	CAIE	%02,.ALP	;IF ALPHA
	CAIN	%02,.NUM	;  OR NUMERIC
	JRST	DEF07		;  BRANCH
	CAIN	%02,.HEX	; SOME ALPHAS ARE TYPED
	JRST	DEF07		; AS HEX DIGITS.
	PUSHJ	%17,WCIMT	;WRITE IN TREE
	JRST	DEF05		;TRY FOR ANOTHER

7:	SETZ	%00,		;POSSIBLE ARGUMENT
	MOVSI	%03,(POINT 6,%00,)
	MOVEM	%13,SYMBEG	;SAVE START JUST IN CASE
DEF08:	SUBI	%14,40		;CONVERT TO SIXBIT
	TLNE	%03,770000
	IDPB	%14,%03		;  YES, DO SO
	PUSHJ	%17,GETCHR	;GET THE NEXT CHARACTER
	LDB	%02,ANPNTR	;MAP
	CAIE	%02,.ALP	;IF ALPHA
	CAIN	%02,.NUM	;  OR NUMERIC
	JRST	DEF08		;  BRANCH
	CAIN	%02,.HEX
	JRST	DEF08
	PUSHJ	%17,SIXM40
	SETZ	%02,		;INIT SEARCH INDEX
DEF09:	SKIPN	ARGLST(%02)	;TEST FOR END
	JRST	DEF10		;  YES
	CAME	%00,ARGLST(%02)	;NO, HAVE WE A MATCH?
	AOJA	%02,DEF09	;  NO,TRY THE NEXT SLOT
	TLZ	%15,CONFLG	;REMOVE POSSIBLE CONCATENATION CHARACTER
	MOVEI	%14,101(%02)	;SET DUMMY SYMBOL POINTER
	PUSHJ	%17,WTIMT	;WRITE IN TREE
	PUSHJ	%17,SETCHR	;SET CHARACTER
	CAIN	%14,"'"		;CONCATENATION CHARACTER?
	JRST	DEF05		;  YES, BYPASS IT
	JRST	DEF06		;  NO, PROCESS IT

DEF10:	MOVE	%13,SYMBEG	;MISSED, RESET POINTER
	PUSHJ	%17,SETCHR	;RESET CHARACTER
DEF11:	LDB	%02,ANPNTR	;MAP
	CAIE	%02,.ALP	;IF ALPHA
	CAIN	%02,.NUM	;  OR NUMERIC
	JRST	DEF11A
	CAIE	%02,.HEX
	JRST	DEF06		;ELSE BRANCH
DEF11A:	PUSHJ	%17,WCIMT	;OK, WRITE IN TREE
	PUSHJ	%17,GETCHR	;GET NEXT CHAR
	JRST	DEF11		;TEST IT

DEF12:	PUSHJ	%17,ENDLR	;LIST IT
	TLNN	%15,ENDFLG	;SKIP IF EOF SEEN
	JRST	DEF03		;GET THE NEXT LINE

DEF13:
	MOVEI	%14,QUEMAC	;FINISHED, SET "END OF MACRO DEFINITION"
	PUSHJ	%17,WTIMT	;WRITE IT, WITH QUE, IN TREE
	POP	%17,%02		;RETRIEVE COUNT
	POP	%17,%01		;  AND POINTER TO START OF BLOCK
	SETZM	0(%01)		;ZERO LEVEL COUNT
	HRRZM	%02,1(%01)	;STORE ARG COUNT IN SECOND RUNG
	TLO	%15,RSWFLG	;FLUSH THIS LINE
	POPJ	%17,


DEFERR:
	TRO	%15,ERRQ
	POPJ	%17,

CALLM:
	MOVE	%00,LSTCTL		; LOAD LIST CONTROL FLAGS
	TRNN	%00,LMC			; .NLIST MC IN EFFECT?
	TLO	%16,NLISLN		; YES - SUPPRESS LIST OF THIS LINE

	PUSH	%17,%01		;SAVE POINTER
	PUSHJ	%17,INCMAC	;INCREMENT THE REFERENCE COUNT
	MOVE	%07,1(%01)	;GET ARGUMENT COUNT
	PUSHJ	%17,GETBLK	;GET A BLOCK FROM FREE STORAGE
	PUSH	%17,MWPNTR	;SAVE THE STARTING ADDRESS
	MOVEI	%00,5
	ADDM	%00,MWPNTR	;MOVE BYTE POINTER PAST WORD STORAGE
	MOVEI	%14,QUEARG
	PUSHJ	%17,WTIMT	;INITIALIZE ARGUMENT LIST
	JUMPE	%07,MAC50	;TEST FOR NO ARGS

MAC10:	PUSHJ	%17,SETNB	;SET NON-BLANK
	CAIN	%14,","		;COMMA?
	JRST	MAC40		;  YES, BRANCH
	CAIE	%14,";"		;IF SEMI-COLON
	PUSHJ	%17,TSTNT	;  OR TERMINATOR,
	 JRST	MAC50		;  BRANCH

	CAIN	%14,"^"		;FIRST CHAR, TEST UNARY OPS
	JRST	MAC60		;  DELIMITED STRING
	CAIN	%14,"<"		; BRACKETS MAY ALSO ENCLOSE
	JRST	MAC60A		;  DELIMITED STRING
	CAIN	%14,"\"
	JRST	MAC70		;EXPRESSION TO ASCII CONVERSION
MAC21:	PUSHJ	%17,WCIMT	;NOTHING SPECIAL, WRITE IN TREE
	PUSHJ	%17,GETCHR	;GET THE NEXT CHARACTER
	CAIN	%14,","		;COMMA?
	JRST	MAC40		;  YES, BRANCH
	CAIE	%14,";"		;IF SEMI-COLON
	PUSHJ	%17,TSTNT	;  OR TERMINATOR,
	 JRST	MAC50		;  BRANCH
	CAIE	%14,SPACE	;TEST FOR TRAILING SPACES
	CAIN	%14,TAB
	CAIA			;  YES
	JRST	MAC21		;NO, WRITE IN TREE

MAC30:	PUSHJ	%17,GETNB	;TEST ARG DELIMITER
MAC31:	CAIN	%14,","		;COMMA?
	JRST	MAC40		;  YEE, ANOTHER ARG
	CAIE	%14,";"		;IF SEMI-COLON
	PUSHJ	%17,TSTNT	;  OR TERMINATOR,
	 JRST	MAC50		;  BRANCH
	TRO	%15,ERRQ	;NONE, ERROR
	JRST	MAC30		;NON-DELIMITER, TRY THE NEXT ONE

MAC40:				;COMMA PROCESSOR
	MOVEI	%14,QUEARG
	PUSHJ	%17,WTIMT	;MARK END OR ARGUMENT
	PUSHJ	%17,GETCHR	;BYPASS COMMA
	SOJG	%07,MAC10	;BRANCH IF MORE ARGS

MAC50:				;END OF LINE PROCESSOR
	MOVEI	%14,QUEARG
	PUSHJ	%17,WTIMT	;PAD MISSING ARGS
	SOJGE	%07,.-1
	POP	%17,%10		;GET CALL BLOCK POINTER
	MOVEM	%12,0(%10)	;SAVE CURRENT READ POINTER
	MOVE	%01,CALPNT
	MOVEM	%01,1(%10)	;SAVE CURRENT CALL BLOCK POINTER
	MOVEM	%10,CALPNT	;SET NEW POINTER
	POP	%17,%12		;GET POINTER TO BASIC BLOCK
	HRLI	%12,(POINT 7,,)	;FORM A BYTE POINTER
	MOVEM	%12,2(%10)	;SAVE IT FOR DECMAC
	MOVEM	%14,3(%10)	;SAVE LAST CHARACTER READ
	ADDI	%12,2		;POINT PAST WORD STORAGE
	AOS	MACLVL

;	   SAVE REPEAT AND CONDITIONAL NESTING LEVELS
;	   FOR LATER USE IF A .MEXIT IS ISSUED.

	MOVE	%14,MACLVL	; LOAD MACRO CALL LEVEL
	MOVE	%00,REPLVL	; SAVE .REPT LEVEL
	MOVEM	%00,MCLREP(%14)
	MOVE	%00,CONLVL	; SAVE NEXTED CONDITIONAL LEVEL
	MOVEM	%00,MCLCON(%14)
	MOVE	%00,UNSLVL	; SAVE UNSATISFIED COND LEVEL
	MOVEM	%00,MCLUNS(%14)

	PUSHJ	%17,SETCHR	;RESTORE LAST CHARACTER
	TLO	%15,RSWFLG	;FLUSH THIS LINE
	POPJ	%17,


MAC60A:	MOVEI	%00,">"		; "<...>" <=> "^/.../"
	JRST	MAC61

MAC60:				;"^" PROCESSOR
	PUSHJ	%17,GETCHR	;BYPASS UNARY OP
	PUSHJ	%17,TSTNT	;TERMINATOR?
	 JRST	MAC62		;  YES,ERROR
	CAIE	%14,SPACE	;BLANK?
	CAIN	%14,TAB
	TRO	%15,ERRQ	;  YES, ERROR
	MOVE	%00,%14		;SAVE ARBITRARY DELIMITER
MAC61:	PUSHJ	%17,GETNT	;GET NON-TERMINATOR
	 JRST	MAC62		;  END OF LINE, ERROR
	CAMN	%14,%00		;TEST FOR DELIMITER
	JRST	MAC30		;  YES, TEST FOR COMMA
	PUSHJ	%17,WCIMT	;NO, WRITE CHARACTER IN TREE
	JRST	MAC61		;TRY ANOTHER

MAC62:	TRO	%15,ERRQ	;CARRIAGE RETURN IN TEXT, ERROR
	JRST	MAC50


MAC70:				;"\"
	PUSHJ	%17,GETNB	;BYPASS UNARY OP
	PUSH	%17,%07		;PROTECT ARG COUNT
	PUSHJ	%17,ABSEXP	;EVALUATE THE EXPRESSION
	PUSHJ	%17,MAC71	;CONVERT TO ASCII
	POP	%17,%07		;RESTORE ARG COUNT
	PUSHJ	%17,SETNB	;  AND LAST CHARACTER
	JRST	MAC31		;TEST FOR COMMA

MAC71:	IDIVI	%10,^D8
	HRLM	%11,0(%17)
	SKIPE	%10		;TEST FOR END
	PUSHJ	%17,MAC71
	HLRZ	%14,0(%17)
	ADDI	%14,"0"		;FORM TEXT
	JRST	WCIMT		;WRITE INTO SKELETON
;		##########  .MEXIT  ###########

;	.MEXIT RESTORES THE LEVEL COUNTERS FOR REPEATS,
;	CONDITIONALS, AND UNSATISFIED CONDITIONALS TO
;	THEIR VALUES AT THE MACRO CALL.  IT LISTS
;	THE REMAINING MACRO LINES AND ENTERS .ENDM PROCESSING.


.MEXIT:	SKIPG	MACLVL		; IS A MACRO EXPANDING?
	JRST	OPCERR		; NO - FLAG THE LINE.

	MOVE	%14,MACLVL	; LOAD LEVEL OF NESTED CALLS
	MOVE	%00,MCLREP(%14)	; RESTORE REPEAT LEVEL
	MOVEM	%00,REPLVL
	MOVE	%00,MCLCON(%14)	; RESTORE COND LEVEL
	MOVEM	%00,CONLVL
	MOVE	%00,MCLUNS(%14)	; RESTORE UNSATISFIED LEVEL
	MOVEM	%00,UNSLVL


;	   LIST REMAINING LINES OF MACRO.  NOTE THAT
;	   .ENDM PROCESSING (MACEND) IS ENTERED FROM
;	   READMC, WHICH IS CALLED BY CHAR2 IN CHAR,
;	   WHICH IS CALLED BY GETLIN.  THE MACRO'S END
;	   IS DETECTED FROM HERE BY WATCHING FOR
;	   MACEND'S DECREMENT OF MACLVL.

	MOVEM	%14,MLSAVE		; SAVE MACLVL

MEXLST:	PUSHJ	RLINK,ENDLR		; LIST NEXT LINE.
	PUSHJ	RLINK,GETLIN		; GET ITS SUCCESSOR.
	PUSHJ	RLINK,GETEOL		; POSITION TO END OF LINE.
	MOVE	%00,MACLVL
	CAMN	%00,MLSAVE		; DID MACLVL CHANGE?
	JRST	MEXLST			; NO - CONTINUE LISTING.
	POPJ	RLINK,			; YES - RETURN.



MACEND:				;END OF MACRO CALL
	MOVE	%10,CALPNT	;IN CASE WE GOT WIPED
	MOVE	%12,0(%10)	;RESET PREVIOUS READ POINTER
	MOVE	%01,1(%10)
	MOVEM	%01,CALPNT	;LIKEWISE
	MOVE	%01,2(%10)	;GET POINTER TO BASIC BLOCK
	PUSHJ	%17,DECMAC	;DECREMENT THE REFERENCE
	MOVE	%14,3(%10)	;RESTORE LAST CHARACTER
	MOVE	%01,%10
	PUSHJ	%17,REMMAC	;RETURN THIS BLOCK FOR DEPOSIT
	SOS	MACLVL		;DECREMENT MACRO LEVEL COUNT
	POPJ	%17,		;FINIS

	SUBTTL	MACRO STORAGE HANDLERS

WTIMT:				;WRITE TWO CHARACTERS IN MACRO TREE
	PUSH	%17,%14		;STACK CURRENT CHARACTER
	MOVEI	%14,RUBOUT	;SET FLAG CHARACTER
	PUSHJ	%17,WCIMT	;WRITE IT
	POP	%17,%14		;RESTORE CHARCTER AND FALL THROUGH

WCIMT:				;WRITE CHARACTER IN MACRO TREE
	TLZE	%15,CONFLG	;CONCATENATION CHARACTER PENDING?
	JRST	WCIMT2		;  YES, WRITE IT OUT
	IBP	MWPNTR		;POINT TO ACTUAL WORD
	SKIPN	@MWPNTR		;END OF BLOCK?
	JRST	WCIMT1		;  YES, GET ANOTHER
	DPB	%14,MWPNTR	;NO, STORE BYTE
	POPJ	%17,		;EXIT

WCIMT1:	PUSH	%17,MWPNTR	;NEAD A NEW BLOCK, SAVE CURRENT POINTER
	PUSHJ	%17,GETBLK	;GET IT
	HRRZ	%11,MWPNTR	;GET START OF NEW BLOCK
	EXCH	%11,0(%17)	;EXCHANGE WITH POINTER TO LAST
	POP	%17,0(%11)	;STORE VECTOR
	JRST	WCIMT		;TRY AGAIN

WCIMT2:	PUSH	%17,%14		;STACK CURRENT CHARACTER
	MOVEI	%14,"'"
	PUSHJ	%17,WCIMT	;WRITE CONCATENATION CHARACTER
	POP	%17,%14		;RESTORE CHARACTER
	JRST	WCIMT		;CONTINUE


GETBLK:				;GET A BLOCK FOR MACRO STORAGE
	SKIPE	%11,NEXT	;ANY REMNANTS OF GARBAGE COLLECTION?
	JRST	GETBL1		;  YES, RE-USE
	PUSH	%17,%07		;  NO, SAVE REGISTER
	MOVEI	%07,WPB
	ADDB	%07,JOBFF	;UPDATE FREE LOCATION POINTER
	CAML	%07,SYMBOT	;ANY ROOM?
	PUSHJ	%17,GETCOR	;  NO, GET MORE CORE
	MOVEI	%11,-<WPB-1>(%07)	;POINT TO START OF BLOCK
	POP	%17,%07		;RESTORE
	SETZM	WPB-1(%11)	;CLEAR VECTOR
GETBL1:	HRLI	%11,(POINT 7,,)	;FORM BYTE POINTER
	MOVEM	%11,MWPNTR	;SET NEW BYTE POINTER
	HRLI	%11,-<WPB-1>	;GET SET TO INITIALIZE BLOCK
	SETOM	0(%11)		;CLEAR ENTRY
	AOBJN	%11,.-1		;SET ALL EXCEPT LAST TO -1
	PUSH	%17,0(%11)	;GET TOP
	POP	%17,NEXT	;SET FOR NEXT BLOCK
	SETZM	0(%11)		;CLEAR LAST WORD
	POPJ	%17,		;EXIT
READMC:				;READ MACRO CHARACTER
	PUSHJ	%17,READMB	;GET A MACRO BYTE
	CAIE	%14,RUBOUT	;SPECIAL?
	 JRST	CPOPJ1		;  NO, JUST EXIT
	PUSHJ	%17,READMB	;YES, GET TYPE
	TRZE	%14,100		;SYMBOLIC?
	JRST	GETDS		;  YES
	JRST	.(%14)		;  NO, TRANSFER ON TYPE

	PHASE	1
QUEMAC:	JRST	MACEND		;END OF MACRO
QUEARG:	JRST	DSEND		;END OF MACRO ARGUMENT
QUEREP:	JRST	REPEND		;END OF REPEAT
	DEPHASE


READMB:				;READ MACRO BYTE
	ILDB	%14,%12		;GET CHARACTER
	JUMPN	%14,CPOPJ	;EXIT IF NON-NULL
	MOVE	%12,0(%12)	;END OF BLOCK, GET LINK
	HRLI	%12,(POINT 7,,)	;SET ASCII BYTE POINTER
	JRST	READMB		;TRY AGAIN


GETDS:				;GET DUMMY SYMBOL
	MOVE	%11,CALPNT	;GET POINTER TO CALL BLOCK
	MOVEM	%12,4(%11)	;SAVE CURRENT READ POINTER
	MOVE	%12,%11		;SET NEW READ POINTER
	ADDI	%12,5		;MOVE PAST WORDS
	MOVE	%11,%14		;GET ARG NUMBER
	ANDI	%11,37
GETDS1:	PUSH	%17,%11		;STACK WORKING REGISTER
GETDS2:	PUSHJ	%17,READMB	;GET A MACRO BYTE
	CAIE	%14,RUBOUT	;FLAGGED?
	JRST	GETDS2		;  NO, TRY AGAIN
	PUSHJ	%17,READMB	;YES, BYPASS END CODE
	POP	%17,%11		;RESTORE WORKING REGISTER
	SOJG	%11,GETDS1	;TEST FOR COMPLETION
	POPJ	%17,		;  YES, EXIT


DSEND:				;DUMMY SYMBOL END
	MOVE	%12,CALPNT	;GET POINTER TO CALL BLOCK
	MOVE	%12,4(%12)	;RESTORE PREVIOUS READ POINTER
	POPJ	%17,		;EXIT

INCMAC:				;INCREMENT MACRO STORAGE
	AOS	0(%01)
	POPJ	%17,

DECMAC:				;DECREMENT MACRO STORAGE
	SOSL	0(%01)		;TEST FOR END
	POPJ	%17,		;  NO, EXIT

REMMAC:				;REMOVE MACRO STORAGE
	PUSH	%17,%01		;SAVE POINTER
	HRLS	%01		;SAVE CURRENT POINTER
	HRR	%01,WPB-1(%01)	;GET NEXT LINK
	TRNE	%01,-1		;TEST FOR END (NULL)
	JRST	.-3		;  NO
	HLRZS	%01		;YES, GET RETURN POINTER
	HRL	%01,NEXT	;GET CURRENT START OF CHAIN
	HLRM	%01,WPB-1(%01)	;STORE AT TOP
	POP	%17,%01		;RESTORE BORROWED REGISTER
	HRRZM	%01,NEXT	;SET NEW START
	POPJ	%17,		;EXIT

TTL	LISTING ROUTINES

;	PRNTA LISTS ASSEMBLER - GENERATED INFORMATION
;	AT THE LEFT SIDE OF EACH LINE:

;	 -- LINE NUMBER FIELD (CURRENTLY BLANK, MAY BE SET BY CREF)
;	 -- LOCATION (UNLESS .NLIST LOC IS IN EFFECT)
;	 -- BINARY CODE (UNLESS .NLIST BIN IS IN EFFECT)

;		.. THREE WORDS OF BINARY CODE ARE LISTED
;		   IF TTM LISTING MODE IS NOT IN EFFECT.
;		.. ONE WORD OF BINARY CODE IS LISTED
;		   IF TTM LISTING MODE IS IN EFFECT

;	PRNTA IS CALLED FROM ONLY ONE PLACE (A LOCATION
;	BETWEEN ENDL6 AND ENDL7).

PRNTA:				;PRINT BASIC LINE OCTAL

	MOVE	%00,LSTCTL	;	****  SEQ # FIELD  ****
	TRNN	%00,LSEQ	; SEQUENCE # TO BE LISTED?
	JRST	PRNTA0		; NO - JUST TAB TO LOC FIELD
	TLNE	%16,BEXBIT	; YES - LIST SEQ UNLESS THIS
	JRST	PRNTA0		; IS A BINARY EXTENSION LINE.
;	   ===========  LIST LINE SEQUENCE NUMBER  ===========

	PUSHJ	RLINK,FORSEQ		; FORMAT THE FIELD.
PRNSEQ:	PUSHJ	RLINK,LSTOUT		; LIST A BYTE OF IT.
	ILDB	%02,%06			; GET NEXT BYTE
	JUMPN	%02,PRNSEQ		; REPEAT UNTIL FINDING 0 BYTE.

PRNTA0:	PUSHJ	%17,LSTTAB	;LIST A TAB

	MOVE	%00,LSTCTL	;    **** LOCATION FIELD ****
	TRNN	%00,LLOC	; IS LOC TO BE LISTED?
	JRST	PRNTA1		; NO - GO TO NEXT FIELD.
				; YES - PRINT LOC IF IT WAS GENERATED.
	SKIPE	%10,PF0		;FIRST FIELD TO BE PRINTED?
	PUSHJ	%17,PRNTWB	;  YES
	PUSHJ	%17,LSTTAB	;OUTPUT TAB

PRNTA1:	MOVE	%00,LSTCTL	;    **** BINARY FIELD ****
	TRNN	%00,LBIN	; BINARY TO BE LISTED?
	POPJ	RLINK,		; NO -- DONE
				; YES - LIST WHATEVER WAS GENERATED.
	SKIPE	%10,PF1		;PRINT PF1
	PUSHJ	%17,PRNTWB
	HRRZ	%00,LSTCTL
	TRNE	%00,LTTM	; TELETYPE?
	POPJ	%17,		;  YES, THROUGH FOR NOW
	PUSHJ	%17,LSTTAB
	SKIPE	%10,PF2
	PUSHJ	%17,PRNTWB	;  NO, LIST 2 MORE WORDS.
	PUSHJ	%17,LSTTAB
	SKIPE	%10,PF3
	PUSHJ	%17,PRNTWB
	POPJ	%17,		;EXIT


PRNTWB:				;PRINT WORD OR BYTE
	LDB	%03,[POINT 2,%10,17]
	CAIE	%03,1
	JRST	PRNTWD		;  YES

PRNTBY:				;PRINT BYTE
	PUSHJ	%17,LSTSP	;LIST THREE SPACES
	PUSHJ	%17,LSTSP
	PUSHJ	%17,LSTSP
	MOVE	%03,[POINT 3,%10,26]
	ANDI	%10,377
	JRST	PRNTWF

PRNTWD:	MOVE	%03,[POINT 3,%10,17]
PRNTWF:	ILDB	%02,%03
	PUSH	%17,%03
	PUSHJ	%17,LSTNUM	;LIST NUMBER
	POP	%17,%03
	TLNE	%03,770000
	JRST	PRNTWF
	MOVEI	%02,"'"
	TLNE	%10,GLBSYM
	MOVEI	%02,"G"
	TDNE	%10,[PFMASK]	;RELOCATABLE?
	PUSHJ	%17,LSTOUT	;  YES
	POPJ	%17,

;	   ===========  SUBROUTINE  FORSEQ  -==============

;	FORMAT A SEQUENCE NUMBER FOR AN OUTPUT LINE.
;	   THE BINARY LINE SEQUENCE NUMBER IS LOCATION SEQ;
;	   THE FORMATTED VERSION IS LOCATION FSEQ.

;	AT RETURN, . . .

;	   FSEQ CONTAINS AN ASCIZ-STYLE STRING,
;	   %06 CONTAINS A POINTER TO ITS FIRST BYTE,
;	   %02 CONTAINS THE FIRST BYTE.


FORSEQ:	SETZM	FSEQ		; CLEAR FORMATTED STRING FIELDS.
	SETZB	%02,FSEQ+1	; %02 = 0 TO COUNT BYTES.
	MOVE	%00,SEQ		; LOAD BINARY SEQUENCE NUMBER.

;   SEQUENCE NUMBER CONVERSION IS BINARY TO DECIMAL, ONE BYTE
;   AT A TIME VIA REPEATED DIVISION BY 10.  BYTES ARE PUSHED
;   ONTO THE STACK IN ASCENDING ORDER OF SIGNIFICANCE.

FSCVT:	IDIVI	%00,^D10	; DIVIDE TO GET (#/10, # MOD 10).
	TRO	%01,"0"		; CONVERT DIGIT TO ASCII.
	PUSH	RLINK,%01	; PUSH IT ONTO THE STACK.
	AOS	%02		; INCREMENT DIGIT COUNT.
	JUMPN	%00,FSCVT	; REPEAT UNTIL QUOTIENT GOES TO 0.

;	   %02 = # OF SIGNIFICANT DIGITS.  FIGURE OUT HOW MANY
;	   BLANKS TO FORMAT IN ORDER TO RIGHT-JUSTIFY THE SEQUENCE
;	   NUMBER.  .  .

;		# OF BLANKS = 7 - S - E,   WHERE
;			S = # OF SIGNIFICANT DIGITS
;			E = # OF ERROR FLAGS PRINTED

;	   S IS IN %02;  COMPUTE 7-E IN %00 BY COUNTING THE NUMBER
;	   OF BITS ON IN RERR (RIGHT HALF OF %15).


	MOVEI	%00,7		; COUNT FROM 7 DOWN IN %00.
	HRRZ	%06,RERR	; SET %06 TO ERROR FLAGS.
	JUMPE	%06,FSCDUN	; DONE IF NO BITS ON.

;	   THE FOLLOWING LOOP IS ITERATED ONCE FOR EACH
;	   1 BIT IN %06.  %06 IS DESTROYED IN THE PROCESS
;	   OF COUNTING ITS BITS.

FSCNT:	SOS	%00		; DECREMENT BLANK COUNT.
	MOVN	%01,%06		; A XOR (-A) TURNS OFF LOW BIT,
	XOR	%01,%06		; WHEREVER IT MAY BE.
	AND	%01,%06		; RECONSTRUCT HIGH ORDER BITS.
	MOVE	%06,%01		; COPY BACK FOR NEXT ITERATION.
	JUMPN	%06,FSCNT	; REPEAT UNLESS NO BITS REMAIN.

;	   END OF BIT COUNT -- %00 = 7-E.

FSCDUN:	MOVE	%06,[POINT 7,FSEQ] ; LOAD SEQ FIELD POINTER.
	SUB	%00,%02		; BLANK COUNT = (7-E)-S.
	JUMPLE	%02,FSDIGT	; BEWARE GOBS OF FLAGS!
	MOVEI	%01," "		; LOAD LITERAL BLANK TO DEPOSIT.

FSLEAD:	IDPB	%01,%06		; SUPPLY A LEADING BLANK.
	SOJG	%00,FSLEAD	; REPEAT TIL COUNT IS EXHAUSTED.

;	   POP SIGNIFICANT DIGITS OFF THE STACK (IN DESCENDING
;	   ORDER OF SIGNIFICANCE) & APPEND TO FSEQ.

FSDIGT:	POP	RLINK,%01	; GET NEXT DIGIT.
	IDPB	%01,%06		; STORE IN FSEQ.
	SOJG	%02,FSDIGT	; REPEAT TIL ALL DIGITS DONE.

;	   LOAD REGS WITH BYTE & BYTE POINTER, THEN RETURN.

	MOVE	%06,[POINT 7,FSEQ] ; LOAD PTR TO START OF FIELD.
	ILDB	%02,%06		; LOAD FIRST BYTE.
	POPJ	RLINK,

	SUBTTL	OCTAL OUTPUT ROUTINES

STCODE:				;STOW CODE
	PUSH	%17,%03
	AOS	%03,CODPNT	;INCREMENT INDEX
	MOVEM	%01,CODBUF-1(%03)	;STORE
	POP	%17,%03
	POPJ	%17,

PROCOD:				;PROCESS CODE
	MOVE	%06,CODPNT	;FETCH INDEX
	SKIPN	%01,CODBUF(%06)	;NULL?
	POPJ	%17,		;  YES, EXIT NULL
	SETZM	CODBUF(%06)
	PUSHJ	%17,PROWRD	;PROCESS WORD
	MOVE	%06,PFT0	;TRANSFER PRINT STUFF
	TLZN	%16,LBLBIT	; ** PF0 IS ALREADY SET IF
				; ** LBLBIT IS 1.
	MOVEM	%06,PF0
	MOVE	%06,PFT1
	TLNN	%16,PF1BIT	; IF PF1BIT SET, PRINT VALUE
			; STORED IN PF1 BY SOME WEIRDO DIRECTIVE
	MOVEM	%06,PF1
	AOS	%06,CODPNT	;INCREMENT INDEX
	HRRZ	%00,LSTCTL	; IF TELETYPE FORMAT
	TRNN	%00,LTTM
	SKIPN	%01,CODBUF(%06)	;  IF EMPTY,
	JRST	CPOPJ1		;  EXIT GOOD
	SETZM	CODBUF(%06)
	PUSHJ	%17,PROWRD
	MOVE	%06,PFT1
	MOVEM	%06,PF2
	AOS	%06,CODPNT	;MORE OF SAME
	SKIPN	%01,CODBUF(%06)
	JRST	CPOPJ1
	SETZM	CODBUF(%06)
	PUSHJ	%17,PROWRD
	MOVE	%06,PFT1
	MOVEM	%06,PF3
	AOS	CODPNT
	JRST	CPOPJ1

PROWRD:				;PROCESS WORD
	SETZM	PFT0		;CLEAR TEMP PRINT BUFFERS
	SETZM	PFT1
	LDB	%02,MODPNT	;GET CLASS
	ANDI	%02,177		;MASK OUT BYTE BIT
	MOVE	%10,RLDTBL(%02)	;GET PROPER TABLE ENTRY
	MOVE	%03,%05		;GET A COPY OF THE PC
	TLO	%03,DEFSYM	;WITH DEFINED BIT SET
	TLNE	%01,BC1!BC2	;CODE TO BE GENNED?
	MOVEM	%03,PFT0	;  YES, PRINT LOCATION
	MOVE	%04,%10		;FLAGS TO %04
	DPB	%01,[POINT 36-8,%04,35]	;REMAINDER FROM %01
	CAIN	%02,RLDT1	;SPECIAL IF CLASS 1
	TLO	%04,(1B<SUBOFF>)
	CAIE	%02,RLDT7	;IF CLASS 7 OR 10
	CAIN	%02,RLDT10
	MOVE	%04,%03		;  USE PREVIOUS PC
	MOVEM	%04,PFT1	;SET TEMP PRINT FIELD 1
	TLNE	%15,P1F!ABSFLG		;PASS ONE?
	JRST	PROWR3		;  YES, BRANCH
	LDB	%03,TYPPNT	;GET BYTE COUNT
	CAIN	%02,RLDT11	;TYPE 11?
	MOVEI	%03,4		;  YES, ALL IN ONE BUFFER
	ADD	%03,BYTCNT
	HRRZ	%04,%10
	ADD	%04,RLDCNT
	CAIG	%03,RLDLEN
	CAILE	%04,RLDLEN	;ROOM TO STORE?
	PUSHJ	%17,BLKDMP	;  NO, DUP CURRENT BUFFER
	SKIPN	BYTCNT		;BUFFER EMPTY?
	TLNN	%01,BC1!BC2	;  YES, ANY CODE?
	JRST	PROWR1		;OK, BYPASS
	MOVEI	%02,BKT3
	PUSHJ	%17,BSWORD	;  NO, STORE BLOCK TYPE
	MOVE	%02,%05
	PUSHJ	%17,BSWORD	;STORE CURRENT ADDRESS
PROWR1:	LDB	%02,MODPNT	;GET THE TYPE
	JUMPE	%02,PROWR3	;BRANCH IF ABSOLUTE
	PUSHJ	%17,RLDSTB	;STORE IT
	TLNN	%01,BC1!BC2	;CODE?
	TDZA	%02,%02		;  NO, SET ZERO
	MOVE	%02,BYTCNT	;YES, SET BYTE POINT FOR REFERENCE
	PUSHJ	%17,RLDSTB
	LDB	%02,SUBPNT
	JUMPE	%02,PROWR2	;BRANCH IF NOT EXTERNAL/REL
	MOVS	%02,GLBBUF(%02)	;GET GLOBAL NAME
	PUSHJ	%17,RLDSTW
	HLRZS	%02
	PUSHJ	%17,RLDSTW	;  AND LEFT HALF

PROWR2:	MOVE	%02,%01		;GET VALUE
	TLNE	%10,1		;SHOULD WE STORE?
	PUSHJ	%17,RLDSTW	;  YES
PROWR3:	MOVE	%02,%01		;GET BASIC VALUE
	TLNE	%02,BC1!BC2	;CODE?
	PUSHJ	%17,BYTOUT	;  YES
	LSH	%02,-^D8	;SHIFT HIGH ORDER BYTE DOWN
	TLNE	%01,BC2		;WORD?
	PUSHJ	%17,BYTOUT	;  YES, OUTPUT HIGH BYTE
	TLNN	%01,BC1!BC2	;CODE?
	PUSHJ	%17,BLKDMP	;  NO, SPECIAL.  DUMP THE BUFFER
	POPJ	%17,

RLDSTW:
	PUSH	%17,%02
	PUSHJ	%17,RLDSTB
	LSH	%02,-^D8
	PUSHJ	%17,RLDSTB
	POP	%17,%02
	POPJ	%17,

RLDSTB:	AOS	%03,RLDCNT
	MOVEM	%02,RLDBLK-1(%03)
	POPJ	%17,

RLDTBL:
	PHASE	0

RLDT0:	XWD	DEFSYM!	0,	0
RLDT1:	XWD	DEFSYM!	1,	4
RLDT2:	XWD	0!	0,	6
RLDT3:	XWD	DEFSYM!	1,	4
RLDT4:	XWD	0!	0,	6
RLDT5:	XWD	GLBSYM!	1,	10
RLDT6:	XWD	GLBSYM!	1,	10
RLDT7:	XWD	0!	1,	10
RLDT10:	XWD	DEFSYM!	1,	4
RLDT11:	XWD	DEFSYM!	0,	2
RLDT12:	XWD	0!	0,	0
RLDT13:	XWD	0!	0,	0
RLDT14:	XWD	0!	0,	0
RLDT15:	XWD	DEFSYM!	1,	10
RLDT16:	XWD	DEFSYM!	1,	10
RLDT17:	XWD	0!	0,	0
	DEPHASE

ENDP:				;END OF PASS ROUTINES
	PUSHJ	%17,TSTMAX	;BE SURE TO TRAP MAX PC
	LDB	%02,CCSPNT
	HRRM	%05,SECBAS(%02)	;SET HIGH LOCATION
	TLNN	%15,P1F		;PASS 1?
	JRST	ENDP20		;  NO
	PUSHJ	%17,SETBIN	;SET BINARY (OBJ OR BIN)
	TLNE	%15,ABSFLG	;YES, ABSOLUTE?
	POPJ	%17,		;  YES, NO ACTION
	MOVE	%00,PRGTTL	;GET PROGRAM TITLE
	SETZ	%01,
	PUSHJ	%17,HDROUD	;OUTPUT DOUBLE WORD
	SETZ	%06,		;INIT SECTOR COUNT
ENDP11:	SETZ	%07,		;INIT FOR TABLE SEARCH
	MOVE	%00,SECNAM(%06)	;GET SECTOR NAME
	HLRZ	%01,SECBAS(%06)	;GET ITS LENGTH
	HRLI	%01,450		;ASSUME RELOCATABLE
	SKIPN	%06		;YES?
	MOVSI	%01,410		;  NO, ABS
	PUSHJ	%17,HDROUD	;OUTPUT IT
ENDP12:	PUSHJ	%17,GETSTE	;GET THE NEXT SYMBOL TABLE ENTRY
	 JRST	ENDP15		;  END, BRANCH
	TLNN	%01,GLBSYM	;GLOBAL?
	JRST	ENDP12		;  NO, FORGET IT
	LDB	%02,SUBPNT	;GET RELOCATION
	MOVSI	%03,2150	;ASSUME REL
	JUMPN	%06,ENDP13	;BRANCH IF TRUE
	MOVSI	%03,2100	;NO, ASSUME EXTERNAL
	TLNN	%01,DEFSYM	;TRUE?
	JRST	ENDP14		;  YES
	TLO	%03,10		;INTERNAL
ENDP13:	TLNE	%01,DEFSYM	;IF EXTERNAL
	CAME	%02,%06		;  OR NON-MATCH
	JRST	ENDP12
ENDP14:	HLL	%01,%03
	PUSHJ	%17,HDROUD	;OUTPUT IT
	JRST	ENDP12		;TRY FOR MORE

ENDP15:	ADDI	%06,1		;MOVE TO NEXT SECTOR
	SKIPN	SECNAM(%06)	;IF NON-NULL
	CAIN	%06,1		;  OR SECTOR 1,
	JRST	ENDP11		;PROCESS
	MOVE	%01,ENDVEC	;GET END VECTOR
	LDB	%02,SUBPNT	;ISOLATE ITS RELOCATION
	MOVE	%00,SECNAM(%02)	;GET THE NAME
	HRLI	%01,1410	;ASSUME ABSOLUTE
	SKIPE	%02
	TLO	%01,40		;NO, RELOCATABLE
	PUSHJ	%17,HDROUD	;OUTPUT IT
	PUSHJ	%17,BLKDMP	;DUMP THE BLOCK
	MOVEI	%02,BKT2
	PUSHJ	%17,BSWORD	;SET BLOCK TYPE
	PUSHJ	%17,BLKDMP	;DUMP THE BUFFER
	MOVEI	%02,BKT4	;OUTPUT A DUMMY CSECT
	PUSHJ	%17,BSWORD
	MOVEI	%02,RLDT7
	PUSHJ	%17,BSWORD
	SETZ	%02,
	PUSHJ	%17,BSWORD
	PUSHJ	%17,BSWORD
	PUSHJ	%17,BSWORD
	JRST	BLKDMP		;DUMP THE BUFFER AND EXIT


ENDP20:	PUSHJ	%17,BLKDMP	;END OF PASS 2
	MOVE	%02,ENDVEC	;GET THE VECTOR
	TLNN	%15,ABSFLG	;ABSOLUTE?
	MOVEI	%02,BKT6	;  NO, SET BLOCK TYPE
	PUSHJ	%17,BSWORD	;STORE IT
	JRST	BLKDMP		;DUMP THE BUFFER AND EXIT

HDROUD:				;OUTPUT DOUBLE WORD
	MOVE	%02,BYTCNT
	CAILE	%02,RLDLEN-^D8+2	;ROOM?
	PUSHJ	%17,BLKDMP	;  NO
	MOVEI	%02,BKT1
	SKIPN	BYTCNT		;BUFFER INITIALIZED?
	PUSHJ	%17,BSWORD	;  NO, DO SO
	MOVE	%02,%00		;FIRST WORD
	PUSHJ	%17,HDROUW
	MOVE	%02,%01

HDROUW:	PUSH	%17,%02
	HLRZ	%02,0(%17)	;LEFT HALF
	PUSHJ	%17,HDROUH
	POP	%17,%02

HDROUH:	PUSH	%17,%02
	PUSHJ	%17,HDROUB
	LDB	%02,[POINT 8,0(%17),35-8]
	PUSHJ	%17,HDROUB
	POP	%17,%02
	POPJ	%17,

HDROUB:	JRST	BSBYTE

BYTOUT:				;OUTPUT A BYTE OF CODE
	TLNE	%15,P1F		;PASS 1
	AOJA	%05,CPOPJ	;  YES, JUST INCREMENT AND EXIT
	TLNN	%15,ABSFLG	;ABS MODE?
	JRST	BYTOU1		;  NO
	MOVE	%03,BYTCNT	;YES GET BYTE COUNT
	CAIGE	%03,DATLEN+2	;OUT OF ROOM?
	CAME	%05,CURADR	;  OR A SEQUENCE BREAK?
	PUSHJ	%17,BLKDMP	;  YES, DUMP THE BUFFER
	SKIPE	BYTCNT		;DO WE NEED INITIALIZATION?
	JRST	BYTOU1		;  NO, STORE IT
	PUSH	%17,%02		;STACK CURRENT CHARACTER
	MOVE	%02,%05		;GET PC
	PUSHJ	%17,BSWORD	;STORE IT
	MOVEM	%05,CURADR	;NEW SEQUENCE BREAK TEST
	POP	%17,%02		;RETRIEVE BYTE
BYTOU1:	PUSHJ	%17,BSBYTE	;STORE THE BYTE
	AOS	CURADR		;UPDATE CURRENT ADDRESS
	AOJA	%05,CPOPJ	;INCREMENT CLC AND EXIT

BSWORD:				;BINARY STORAGE OF WORD
	PUSH	%17,%02
	PUSHJ	%17,BSBYTE	;STORE LOW ORDER
	LSH	%02,-8		;SHIFT DOWN HIGH ORDER
	PUSHJ	%17,BSBYTE	;STORE IT
	POP	%17,%02		;RESTORE WORD
	POPJ	%17,		;  AND EXIT

BSBYTE:				;BINARY STORAGE OF BYTE
	AOS	%03,BYTCNT	;INCREMENT AND FETCH THE BYTE COUNT
	MOVEM	%02,DATBLK-1(%03)	;STORE CURRENT BYTE IN BUFFER
	POPJ	%17,

BLKDMP:				;DUMP THE CURRENT BLOCK
	SKIPN	BYTCNT		;IS IT EMPTY?
	JRST	RLDDMP		;  YES, TEST FOR REL BLOCK
	PUSH	%17,%01		;GET A COUPLE OF SCRATCH REGISTERS
	PUSH	%17,%02
BLKDM1:	MOVEI	%02,01		;BLOCK TYPE ONE
	PUSHJ	%17,BINWRD	;OUTPUT FLAG WORD
	MOVE	%02,BYTCNT	;FETCH BYTE COUNT
	ADDI	%02,4		;FUDGE FOR HEADER
	PUSHJ	%17,BINWRD	;OUTPUT IT
	HRLZ	%01,BYTCNT	;GET BYTE COUNT
	MOVNS	%01		;NEGATE BYTE CT
	MOVE	%02,DATBLK(%01)	;GET AN ITEM FROM THE DATA BLOCK
	PUSHJ	%17,BINOUT	;DUMP IT
	AOBJN	%01,.-2		;RECYCLE IF NOT DONE
	MOVN	%02,CHKSUM	;GET NEG OF CHECKSUM.
	PUSHJ	%17,BINOUT	;DUMP IT
	SETZ	%02,		;FINISHED WITH BLOCK
	MOVEI	%01,^D6
	TLNN	%15,ABSFLG
	MOVEI	%01,^D8
	PUSHJ	%17,BINOUT	;DUMP SOME BLANK TAPE
	SOJG	%01,.-1
	POP	%17,%02		;RESTORE REGISTERS
	POP	%17,%01

RLDDMP:
	SKIPN	RLDCNT
	JRST	BLKINI
	PUSH	%17,%01
	PUSH	%17,%02
	HRLZ	%01,RLDCNT
	PUSHJ	%17,BLKINI
	MOVEI	%02,BKT4
	PUSHJ	%17,BSWORD
	MOVNS	%01
	MOVE	%02,RLDBLK(%01)
	PUSHJ	%17,BSBYTE
	AOBJN	%01,.-2
	PUSHJ	%17,BLKDMP
	POP	%17,%02
	POP	%17,%01

BLKINI:				;CODE BLOCK INITIALIZATION
	SETZM	BYTCNT		;CLEAR BYTE COUNT
	SETZM	RLDCNT
	POPJ	%17,		;EXIT

	SUBTTL	MEMORY MANAGEMENT

GETCOR:				;GET CORE
	PUSH	%17,%00		;GET A COULPLE OF WORKING REGISTERS
	PUSH	%17,%01
	HRRO	%01,JOBREL	;GET TOP OF CURRENT CORE
	MOVEI	%00,CORINC(%01)	;COMPUTE NEXT K
	CORE	%00,		;MAKE A REQUEST
	 JRST	ERRNC		;FORGET IT!
	MOVEI	%00,1(%01)
	SUB	%00,SYMBOT	;COMPUTE NUMBER OF ITEMS TO BE MOVED
	POP	%01,CORINC(%01)	;POP ITEM UP ONE K
	SOJG	%00,.-1		;TEST FOR COMPLETION
	MOVEI	%01,CORINC	;UPDATE POINTERS
	ADDM	%01,SYMBOT
	ADDM	%01,SYMPNT
	ADDM	%01,VALPNT
	ADDM	%01,SYMTOP
	POP	%17,%01		;RESTORE REGISTERS
	POP	%17,%00
	POPJ	%17,		;EXIT

	SUBTTL	SYMBOL TABLE HANDLERS

MSRCH:	TLOA	%00,MACBIT
SSRCH:				;SYMBOL SEARCH
	TLZ	%00,MACBIT
	CAMN	%00,M40DOT	;PC?
	JRST	SSRCH3		;  YES
	MOVE	%07,DELTA	;SET OFFSET FOR INDEX
	MOVE	%02,%07
	ASH	%02,-1		;SET INCREMENT
SSRCH1:	CAMGE	%00,@SYMPNT	;ARE WE LOOKING ABOVE SYMBOL?
	JRST	SSRCH2		;  YES, MOVE DOWN
	CAMG	%00,@SYMPNT	;NO, POSSIBLY AT IT?
	JRST	SSRCH4		;  YES
	TDOA	%07,%02		;  NO, INCREMENT INDEX
SSRCH2:	SUB	%07,%02		;DECREMENT INDEX
	ASH	%02,-1		;DECREMENT DELTA
	CAMG	%07,SYMLEN	;ARE WE OUT OF BOUNDS?
	JUMPN	%02,SSRCH1	;  NO, BRANCH IF NOT THROUGH
	JUMPN	%02,SSRCH2	;  YES, MOVE DOWN IF NOT THROUGH
	SETZB	%01,%02
	SOJA	%07,CPOPJ	;NOT FOUND, SET INDEX AND EXIT NORMAL

SSRCH3:	MOVE	%01,%05
	TLOA	%01,DEFSYM	;SET PC AS DEFINED
SSRCH4:	MOVE	%01,@VALPNT	;FOUND, FETCH VALUE
	LDB	%02,TYPPNT	;SET TYPE POINTER
	JRST	CPOPJ1		;EXIT +1

INSRT:				;INSERT ITEM IN SYMBOL TABLE
	CAMN	%00,M40DOT	;PC?
	JRST	INSRT2		;  YES
	CAMN	%00,@SYMPNT	;IS IT HERE ALREADY?
	JRST	INSRT1		;  YES
	MOVNI	%06,2		;NO, PREPARE TI INSERT
	ADDB	%06,SYMBOT	;DECREMENT POINTER TO BOTTOM OF TABLE
	CAMG	%06,JOBFF	;ARE WE INTRUDING ON THE MACROS?
	PUSHJ	%17,GETCOR	;  YES, GET MORE CORE
	MOVE	%06,SYMBOT
	HRLI	%06,2(%06)	;SET UP BLT
	BLT	%06,@SYMPNT	;MOVE LOWER SYMBOLS DOWN
	PUSHJ	%17,SRCHI	;RE-INITIALIZE THE POINTERS
	ADDI	%07,2		;COMPENSATE FOR SHIFT
	MOVEM	%00,@SYMPNT	;STORE SYMBOL
INSRT1:	MOVEM	%01,@VALPNT	;STORE VALUE
	POPJ	%17,

INSRT2:	MOVE	%05,%01		;".", SET PC
	AND	%05,[PCMASK]	;MAKE SURE ITS CLEAN
	POPJ	%17,




;	   RESET CURRENT LOCAL SYMBOL BLOCK DUE TO FINDING
;	   A LABEL DEFINITION OR .CSECT DIRECTIVE, UNLESS
;	   .ENABL LSB HAS BEEN ISSUED TO PROLONG CURRENT BLOCK.


LOCRES:	TLNN	RMODE,LSBFLG	; .ENABL LSB IN EFFECT?
	AOS	LSBLOC		; NO - INCREMENT BLOCK NUMBER
	POPJ	RLINK,		; RETURN

CRFDEF:	TDZA	%03,%03		;CREF DEFINITION
CRFREF:	HRROI	%03,-1		;CREF REFERENCE
	TLNN	%15,P1F		;IF PASS 1
	TLNE	%16,CSWBIT!LSTBIT	;  OR CREF NOT REQUESTED
	POPJ	%17,		;EXIT
	PUSH	%17,%01		;GET WORKING REGISTERS
	PUSH	%17,%02
	PUSH	%17,%04
	LDB	%02,TYPPNT	;ISOLATE SYMBOL TYPE
	MOVSI	%01,-CRFLEN	;SET FOR SCAN
CRFRE1:	SKIPN	CRFNAM(%01)	;EMPTY SLOT?
	JRST	CRFRE2		;  YES
	HRRZ	%04,CRFTYP(%01)	;NO, GET TYPE
	CAMN	%00,CRFNAM(%01)	;TEST NAME
	CAME	%04,%02		;  AND TYPE
	AOBJN	%01,CRFRE1	;  NOT A MATCH
	JUMPG	%01,CRFRE3	;EXIT IF OUT OF ROOM
CRFRE2:	MOVEM	%00,CRFNAM(%01)	;STORE NAME
	HRRM	%02,CRFTYP(%01)	;  AND TYPE
	SKIPN	%03		;DEFINITION?
	HRROS	CRFTYP(%01)	;  YES, SET LEFT HALF
CRFRE3:	POP	%17,%04		;RESTORE REGISTERS
	POP	%17,%02
	POP	%17,%01
	POPJ	%17,

CRFLIN:				;OUTPUT CREF LINE INFO
	TLNN	%15,P1F!EXTFLG		;IF PASS 1
	TLNE	%16,CSWBIT!LSTBIT	;  OR CREF NOT REQUESTED
	POPJ	%17,		;  EXIT
	TRZE	%16,HDRBIT	;TIME FOR HEADER?
	PUSHJ	%17,HEADER	;  YES
	MOVEI	%02,RUBOUT	;OK, RUBOUT "B"
	PUSHJ	%17,LSTDMP
	MOVEI	%02,"B"
	PUSHJ	%17,LSTDMP
	MOVSI	%06,-CRFLEN	;SET FOR SCAN
CRFLI1:	SKIPN	CRFNAM(%06)	;END?
	JRST	CRFLI4		;  YES
	MOVE	%02,CRFTYP(%06)	;NO, GET TYPE
	TLNN	%02,-1		;DEFINITION?
	SKIPA	%02,CRFTBL(%02)	;NO
	HLRZ	%02,CRFTBL(%02)	;YES, USE LEFT HALF
	HRLM	%02,0(%17)	;SAVE ON STACK
	LDB	%02,[POINT 9,0(%17),8]	;GET FIRST CONTROL
	SKIPE	%02		;SKIP IF NULL
	PUSHJ	%17,LSTDMP	;OUTPUT IT
	MOVE	%00,CRFNAM(%06)	;GET THE NAME
	PUSHJ	%17,M40SIX	;CONVERT TO SIXBIT
	PUSH	%17,%00		;SAVE A COPY
	MOVEI	%02,1		;SET TO COUNT CHARACTERS
CRFLI2:	LSH	%00,6		;SHIFT ONE CHARACTER
	SKIPE	%00		;FINI?
	AOJA	%02,CRFLI2	;  NO, INCREMENT AND LOOP
	PUSHJ	%17,LSTDMP	;YES, OUTPUT CHARACTER COUNT
	POP	%17,%03		;RETRIEVE THE NAME
CRFLI3:	SETZ	%02,		;CLEAR HIGH REGISTER
	LSHC	%02,6		;SHIFT NEXT CHARACTER IN
	ADDI	%02,40		;CONVERT TO ASCII
	PUSHJ	%17,LSTDMP	;OUTPUT IT
	JUMPN	%03,CRFLI3	;LOOP IF MORE TO COME
	LDB	%02,[POINT 9,0(%17),17]	;FETCH TRAILING CHARACTER
	SKIPE	%02
	PUSHJ	%17,LSTDMP	;OUTPUT IF NON-NULL
CRFLI4:	SETZM	CRFNAM(%06)	;CLEAR NAME
	SETZM	CRFTYP(%06)	;  AND TYPE
	AOBJN	%06,CRFLI1	;TEST FOR MORE
	MOVEI	%02,RUBOUT	;FINISHED, NOW RUBOUT "C"
	PUSHJ	%17,LSTDMP
	MOVEI	%02,"C"
	JRST	LSTDMP		;LIST AND EXIT

CRFTBL:
	PHASE	0
	BYTE	(9)  1, 2, 1, 0
MAOP:	BYTE	(9)  6, 0, 5, 0
OCOP:	BYTE	(9)  0, 0, 3, 0
DIOP:	BYTE	(9)  0, 0, 3, 0
	DEPHASE

SRCHI:				;INITIALIZE FOR SEARCH
	PUSH	%17,%01		;STACK WORKING REGISTERS
	PUSH	%17,%02
	MOVE	%01,SYMTOP	;GET THE TOP LOCATION
	SUB	%01,SYMBOT	;COMPUTE THE DIFFERENCE
	MOVEM	%01,SYMLEN	;SAVE IT
	MOVEI	%02,1		;SET LOW BIT
	LSH	%02,1		;SHIFT OVER ONE
	TDZ	%01,%02		;CLEAR CORRESPONDING ONE
	JUMPN	%01,.-2		;TEST FOR ALL BITS CLEARED
	MOVEM	%02,DELTA	;END, SAVE LEADING BIT FOR SEARCH OFFSET
	MOVE	%01,SYMBOT	;GET THE BASE
	HRLI	%01,(Z (%07))	;SET INDEX
	MOVEM	%01,SYMPNT	;SET SYMBOL POINTER
	SUBI	%01,1
	MOVEM	%01,VALPNT	;SET VALUE POINTER
	POP	%17,%02		;RESTORE REGISTERS
	POP	%17,%01
	POPJ	%17,		;EXIT

B:				;LIST THE SYMBOL TABLE
	SETZ	%07,		;INITIALIZE POINTER
	TRO	%16,HDRBIT	;FLAG NEW PAGE

SYMTB1:	MOVEI	%06,SPL		;SET "SYMBOLS PER LINE"
	HRRZ	%00,LSTCTL	; TTY?
	TRNE	%00,LTTM
	MOVEI	%06,SPLTTY	;  YES, REDUCE
SYMTB2:	PUSHJ	%17,GETSTE	;GET THE NEXT SYMBOL TABLE ENTRY
	 JRST	SYMTB3		;  END
	PUSHJ	%17,LSTSTE	;LIST SYMBOL TABLE ENTRY
	SOJG	%06,SYMTB2	;TEST FOR MORE ITEMS ON LINE
	PUSHJ	%17,LSTCR
	JRST	SYMTB1		;START NEW LINE

SYMTB3:	MOVE	%00,M40DOT
	MOVE	%01,%05		;PRINT PC
	TLO	%01,DEFSYM
	PUSHJ	%17,LSTSTE
	PUSHJ	%17,LSTCR
	PUSHJ	%17,LSTCR
	MOVE	%07,[XWD -^D<256-2>,2]
SYMTB4:	SKIPN	SECNAM(%07)
	POPJ	%17,
	MOVE	%00,SECNAM(%07)
	HLRZ	%01,SECBAS(%07)
	DPB	%07,SUBPNT	;SET SECTOR
	TLO	%01,LBLSYM	;SUPPRESS "="
	PUSHJ	%17,LSTSTE
	PUSHJ	%17,LSTCR
	AOBJN	%07,SYMTB4
	POPJ	%17,

GETSTE:				;GET SYMBOL TABLE ENTRY
	ADDI	%07,2		;MOVE UP TWO
	CAML	%07,SYMLEN	;TEST FOR END
	POPJ	%17,		;  YES, EXIT
	MOVE	%00,@SYMPNT
	MOVE	%01,@VALPNT
	LDB	%02,TYPPNT
	JUMPN	%02,GETSTE	;BYPASS IF OP
	JRST	CPOPJ1		;OK, PERFORM SKIP-RETURN

LSTSTE:				;LIST SYMBOL TABLE ENTRY
	PUSHJ	%17,LSTSYM	;LIST IT
	PUSHJ	%17,LSTSP
	MOVEI	%02,"="
	TLNE	%01,LBLSYM
	MOVEI	%02,SPACE
	PUSHJ	%17,LSTOUT
	MOVEI	%02,"%"
	TLNN	%01,REGSYM	;REGISTER?
	MOVEI	%02,SPACE	;  NO
	PUSHJ	%17,LSTOUT
	TLNE	%01,GLBSYM
	TLNE	%01,DEFSYM
	SKIPA	%10,[POINT 3,%01,17]
	MOVE	%10,[POINT 6,[SIXBIT /******/]]
LSTST1:	ILDB	%02,%10
	CAIG	%02,7
	TROA	%02,"0"
	ADDI	%02,40
	PUSHJ	%17,LSTOUT
	TLNE	%10,760000
	JRST	LSTST1
	LDB	%10,SUBPNT
	MOVEI	%02,SPACE
	JUMPL	%07,LSTST2
	SKIPE	%10
	MOVEI	%02,"R"
LSTST2:	PUSHJ	%17,LSTOUT
	MOVEI	%02,SPACE
	JUMPL	%07,LSTST3
	TLNN	%01,DEFSYM
	MOVEI	%02,"U"
	TLNE	%01,GLBSYM
	MOVEI	%02,"G"
LSTST3:	PUSHJ	%17,LSTOUT
	CAIG	%10,1
	JRST	LSTTAB
	LDB	%02,[POINT 3,%10,35-6]
	PUSHJ	%17,LSTNUM
	LDB	%02,[POINT 3,%10,35-3]
	PUSHJ	%17,LSTNUM
	LDB	%02,[POINT 3,%10,35]
	PUSHJ	%17,LSTNUM
	JRST	LSTTAB		;OUTPUT A TAB AND EXIT

SIXM40:				;SIXBIT TO MOD40
	PUSH	%17,%01
	PUSH	%17,%02
	PUSH	%17,%03		;STACK REGISTERS
	SETZ	%01,
	MOVSI	%03,(POINT 6,%00)
SIXM41:	ILDB	%02,%03		;GET A CHARACTER
	HLRZ	%02,RADTBL(%02)	;MAP
	IMULI	%01,50
	ADD	%01,%02
	TLNE	%03,770000	;FINISHED?
	JRST	SIXM41		;  NO
	IDIVI	%01,50*50*50	;YES, SPLIT INTO HALVES
	HRLZ	%00,%01		;HIGH ORDER
	HRR	%00,%02		;  AND LOW ORDER
	POP	%17,%03		;RESTORE REGISTERS
	POP	%17,%02
	POP	%17,%01
	POPJ	%17,

M40SIX:				;MOD40 TO SIXBIT
	PUSH	%17,%01
	PUSH	%17,%02
	LDB	%01,[POINT 16,%00,17]
	IMULI	%01,50*50*50	;MERGE
	HRRZS	%00
	ADD	%00,%01
	SETZ	%02,		;ACCUMULATOR
M40SI1:	IDIVI	%00,50
	HRRZ	%01,RADTBL(%01)	;MAP
	LSHC	%01,-6		;MOVE INTO COLLECTOR
	JUMPN	%00,M40SI1	;TEST FOR END
	MOVE	%00,%02
	POP	%17,%02
	POP	%17,%01
	POPJ	%17,

RADTBL:
	XWD	<$=0>,	0
	XWD	0,	"A"-40
	XWD	0,	"B"-40
	XWD	0,	"C"-40
	XWD	<$$=33>,	"D"-40
	XWD	0,	"E"-40
	XWD	0,	"F"-40
	XWD	0,	"G"-40

	XWD	0,	"H"-40
	XWD	0,	"I"-40
	XWD	0,	"J"-40
	XWD	0,	"K"-40
	XWD	0,	"L"-40
	XWD	0,	"M"-40
	XWD	<$.=34>,	"N"-40
	XWD	0,	"O"-40

	XWD	<$0=36>,	"P"-40
	XWD	<$1=37>,	"Q"-40
	XWD	<$2=40>,	"R"-40
	XWD	<$3=41>,	"S"-40
	XWD	<$4=42>,	"T"-40
	XWD	<$5=43>,	"U"-40
	XWD	<$6=44>,	"V"-40
	XWD	<$7=45>,	"W"-40

	XWD	<$8=46>,	"X"-40
	XWD	<$9=47>,	"Y"-40
	XWD	0,	"Z"-40
	XWD	0,	"$"-40
	XWD	0,	"."-40
	XWD	0,	0
	XWD	0,	"0"-40
	XWD	0,	"1"-40

	XWD	0,	"2"-40
	XWD	<$A=1>,	"3"-40
	XWD	<$B=2>,	"4"-40
	XWD	<$C=3>,	"5"-40
	XWD	<$D=4>,	"6"-40
	XWD	<$E=5>,	"7"-40
	XWD	<$F=6>,	"8"-40
	XWD	<$G=7>,	"9"-40

	XWD	<$H=10>,	0
	XWD	<$I=11>,	0
	XWD	<$J=12>,	0
	XWD	<$K=13>,	0
	XWD	<$L=14>,	0
	XWD	<$M=15>,	0
	XWD	<$N=16>,	0
	XWD	<$O=17>,	0

	XWD	<$P=20>,	0
	XWD	<$Q=21>,	0
	XWD	<$R=22>,	0
	XWD	<$S=23>,	0
	XWD	<$T=24>,	0
	XWD	<$U=25>,	0
	XWD	<$V=26>,	0
	XWD	<$W=27>,	0

	XWD	<$X=30>,	0
	XWD	<$Y=31>,	0
	XWD	<$Z=32>,	0
	XWD	0,	0
	XWD	0,	0
	XWD	0,	0
	XWD	0,	0
	XWD	0,	0

OSRCH:				;OP TABLE SEARCH
	TLZ	%00,MACBIT	;CLEAR POSSIBLE MACRO BIT
	MOVEI	%02,1B^L<OPTTOP-OPTBOT>	;SET UP OFFSET AND DELTA
	MOVEI	%01,1B^L<OPTTOP-OPTBOT>/2
OSRCH1:	CAMN	%00,OPTBOT-2(%02)	;ARE WE LOOKING AT IT?
	JRST	OSRCH3		;  YES
	CAML	%00,OPTBOT-2(%02)	;TEST FOR DIRECTION OF NEXT MOVE
	TDOA	%02,%01		;ADD
OSRCH2:	SUB	%02,%01		;SUBTRACT
	ASH	%01,-1		;HALVE DELTA
	JUMPE	%01,OSRCH4	;EXIT IF END
	CAILE	%02,OPTTOP-OPTBOT	;YES, ARE WE OUTOF BOUNDS?
	JRST	OSRCH2		;YES, MOVE DOWN
	JRST	OSRCH1		;NO, TRY AGAIN

OSRCH3:	MOVE	%01,OPTBOT-1(%02)	;FOUND, PLACE VALUE IN %02
	LDB	%02,TYPPNT
	TLNN	%15,P1F		;IF PASS 1
	CAIE	%02,OCOP	;  OR PSEUDO-OP
	JRST	CPOPJ1		; EXIT
	PUSH	%17,%01		;STACK RESULT
	MOVSI	%02,-8		;SET FOR EIGHT BITS
	TLNE	%01,(1B0)	;THIS BIT SET?
	AOS	OPCCNT(%02)	;  YES
	LSH	%01,1		;SHIFT BITS
	AOBJN	%02,.-3		;TEST FOR END
	POP	%17,%01		;YES, RESTORE RESULT
	LDB	%02,TYPPNT
	JRST	CPOPJ1

OSRCH4:	SETZB	%01,%02
	POPJ	%17,

TYPOFF=	^D17			;PACKING PARAMETERS
SUBOFF=	^D15
MODOFF=	^D7

BC1=	1
BC2=	2

DEFSYM=	400000			;DEFINED SYMBOL
LBLSYM=	200000			;LABEL
REGSYM=	100000			;REGISTER
GLBSYM=	040000			;GLOBAL
MDFSYM=	020000			;MULTIPLY-DEFINED FLAG

TYPPNT:	POINT	2,%01,TYPOFF	;TYPE POINTER
SUBPNT:	POINT	8,%01,SUBOFF	;SUB-TYPE POINTER
CCSPNT:	POINT	8,%05,SUBOFF	;CURRENT CSECT POINTER
MODPNT:	POINT	8,%01,MODOFF

MOD20=	400000
MOD40=	200000

MACBIT=	400000

MDMASK=	377B<MODOFF>
PFMASK=	377B<SUBOFF>
ADMASK=	177777
PCMASK=	PFMASK!ADMASK

M40DOT:	GENM40	.

	SUBTTL	PERMANENT SYMBOL TABLE

	DEFINE	OPCDEF	(A,B,C,D,E,F,MOD,CLASS,VALUE)
<
	GENM40	A,B,C,D,E,F
	XWD	MOD!<CLASS>B33!OCOP,VALUE
>

	DEFINE	DIRDEF	(A,B,C,D,E,F,ADDRESS)
<
	GENM40	A,B,C,D,E,F
IFDEF	ADDRESS <
	XWD	DIOP,ADDRESS
>
IFNDEF	ADDRESS <
	XWD	DIOP,NHY
>
>

NHY:	TRO	%15,ERRQ		;NOT HERE YET
	POPJ	%17,

	OPTBOT:				;OP TABLE BOTTOM

	OPCDEF	A,B,S,D, , ,	MOD40,	OPCL1,	170600

	OPCDEF	A,B,S,F, , ,	MOD40,	OPCL1,	170600

	OPCDEF	A,D,C, , , ,	MOD20!MOD40,	OPCL1,	005500

	OPCDEF	A,D,C,B, , ,	MOD20!MOD40,	OPCL1,	105500

	OPCDEF	A,D,D, , , ,	MOD20!MOD40,	OPCL2,	060000

	OPCDEF	A,D,D,D, , ,	MOD40,	OPCL11,	172000

	OPCDEF	A,D,D,F, , ,	MOD40,	OPCL11,	172000

	OPCDEF	A,S,H, , , ,	MOD40,	OPCL9,	072000

	OPCDEF	A,S,H,C, , ,	MOD40,	OPCL9,	073000

	OPCDEF	A,S,L, , , ,	MOD20!MOD40,	OPCL1,	006300

	OPCDEF	A,S,L,B, , ,	MOD20!MOD40,	OPCL1,	106300

	OPCDEF	A,S,R, , , ,	MOD20!MOD40,	OPCL1,	006200

	OPCDEF	A,S,R,B, , ,	MOD20!MOD40,	OPCL1,	106200


	OPCDEF	B,C,C, , , ,	MOD20!MOD40,	OPCL4,	103000

	OPCDEF	B,C,S, , , ,	MOD20!MOD40,	OPCL4,	103400

	OPCDEF	B,E,Q, , , ,	MOD20!MOD40,	OPCL4,	001400

	OPCDEF	B,G,E, , , ,	MOD20!MOD40,	OPCL4,	002000

	OPCDEF	B,G,T, , , ,	MOD20!MOD40,	OPCL4,	003000


	OPCDEF	B,H,I, , , ,	MOD20!MOD40,	OPCL4,	101000

	OPCDEF	B,H,I,S, , ,	MOD20!MOD40,	OPCL4,	103000

	OPCDEF	B,I,C, , , ,	MOD20!MOD40,	OPCL2,	040000

	OPCDEF	B,I,C,B, , ,	MOD20!MOD40,	OPCL2,	140000

	OPCDEF	B,I,S, , , ,	MOD20!MOD40,	OPCL2,	050000

	OPCDEF	B,I,S,B, , ,	MOD20!MOD40,	OPCL2,	150000

	OPCDEF	B,I,T, , , ,	MOD20!MOD40,	OPCL2,	030000

	OPCDEF	B,I,T,B, , ,	MOD20!MOD40,	OPCL2,	130000

	OPCDEF	B,L,E, , , ,	MOD20!MOD40,	OPCL4,	003400

	OPCDEF	B,L,O, , , ,	MOD20!MOD40,	OPCL4,	103400

	OPCDEF	B,L,O,S, , ,	MOD20!MOD40,	OPCL4,	101400

	OPCDEF	B,L,T, , , ,	MOD20!MOD40,	OPCL4,	002400

	OPCDEF	B,M,I, , , ,	MOD20!MOD40,	OPCL4,	100400

	OPCDEF	B,N,E, , , ,	MOD20!MOD40,	OPCL4,	001000

	OPCDEF	B,P,L, , , ,	MOD20!MOD40,	OPCL4,	100000

	OPCDEF	B,P,T, , , ,	MOD20!MOD40,	OPCL0,	000003

	OPCDEF	B,R, , , , ,	MOD20!MOD40,	OPCL4,	000400

	OPCDEF	B,V,C, , , ,	MOD20!MOD40,	OPCL4,	102000


	OPCDEF	B,V,S, , , ,	MOD20!MOD40,	OPCL4,	102400

	OPCDEF	C,C,C, , , ,	MOD20!MOD40,	OPCL0,	000257

	OPCDEF	C,F,C,C, , ,	MOD40,	OPCL0,	170000

	OPCDEF	C,L,C, , , ,	MOD20!MOD40,	OPCL0,	000241

	OPCDEF	C,L,N, , , ,	MOD20!MOD40,	OPCL0,	000250

	OPCDEF	C,L,R, , , ,	MOD20!MOD40,	OPCL1,	005000

	OPCDEF	C,L,R,B, , ,	MOD20!MOD40,	OPCL1,	105000

	OPCDEF	C,L,R,D, , ,	MOD40,	OPCL1,	170400

	OPCDEF	C,L,R,F, , ,	MOD40,	OPCL1,	170400

	OPCDEF	C,L,V, , , ,	MOD20!MOD40,	OPCL0,	000242

	OPCDEF	C,L,Z, , , ,	MOD20!MOD40,	OPCL0,	000244

	OPCDEF	C,M,P, , , ,	MOD20!MOD40,	OPCL2,	020000

	OPCDEF	C,M,P,B, , ,	MOD20!MOD40,	OPCL2,	120000

	OPCDEF	C,M,P,D, , ,	MOD40,	OPCL11,	173400

	OPCDEF	C,M,P,F, , ,	MOD40,	OPCL11,	173400

	OPCDEF	C,N,Z, , , ,	MOD20!MOD40,	OPCL0,	000254

	OPCDEF	C,O,M, , , ,	MOD20!MOD40,	OPCL1,	005100

	OPCDEF	C,O,M,B, , ,	MOD20!MOD40,	OPCL1,	105100


	OPCDEF	D,E,C, , , ,	MOD20!MOD40,	OPCL1,	005300

	OPCDEF	D,E,C,B, , ,	MOD20!MOD40,	OPCL1,	105300



	OPCDEF	D,I,V, , , ,	MOD40,	OPCL7,	071000

	OPCDEF	D,I,V,D, , ,	MOD40,	OPCL11,	174400

	OPCDEF	D,I,V,F, , ,	MOD40,	OPCL11,	174400

	OPCDEF	E,M,T, , , ,	MOD20!MOD40,	OPCL6,	104000

	OPCDEF	H,A,L,T, , ,	MOD20!MOD40,	OPCL0,	000000


	OPCDEF	I,N,C, , , ,	MOD20!MOD40,	OPCL1,	005200

	OPCDEF	I,N,C,B, , ,	MOD20!MOD40,	OPCL1,	105200

	OPCDEF	I,O,T, , , ,	MOD20!MOD40,	OPCL0,	000004

	OPCDEF	J,M,P, , , ,	MOD20!MOD40,	OPCL1,	000100

	OPCDEF	J,S,R, , , ,	MOD20!MOD40,	OPCL5,	004000

	OPCDEF	L,D,C,D,F, ,	MOD40,	OPCL11,	177400

	OPCDEF	L,D,C,F,D, ,	MOD40,	OPCL11,	177400

	OPCDEF	L,D,C,I,D, ,	MOD40,	OPCL14,	177000

	OPCDEF	L,D,C,I,F, ,	MOD40,	OPCL14,	177000

	OPCDEF	L,D,C,L,D, ,	MOD40,	OPCL14,	177000

	OPCDEF	L,D,C,L,F, ,	MOD40,	OPCL14,	177000

	OPCDEF	L,D,D, , , ,	MOD40,	OPCL11,	172400

	OPCDEF	L,D,E,X,P, ,	MOD40,	OPCL14,	176400

	OPCDEF	L,D,F, , , ,	MOD40,	OPCL11,	172400

	OPCDEF	L,D,F,P,S, ,	MOD40,	OPCL1,	170100

	OPCDEF	L,D,S,C, , ,	MOD40,	OPCL0,	170004

	OPCDEF	L,D,U,B, , ,	MOD40,	OPCL0,	170003

	OPCDEF	M,A,R,K, , ,	MOD40,	OPCL10,	006400

	OPCDEF	M,F,P,D, , ,	MOD40,	OPCL1,	106500

	OPCDEF	M,F,P,I, , ,	MOD40,	OPCL1,	006500

	OPCDEF	M,O,D,D, , ,	MOD40,	OPCL11,	171400

	OPCDEF	M,O,D,F, , ,	MOD40,	OPCL11,	171400

	OPCDEF	M,O,V, , , ,	MOD20!MOD40,	OPCL2,	010000


	OPCDEF	M,O,V,B, , ,	MOD20!MOD40,	OPCL2,	110000

	OPCDEF	M,T,P,D, , ,	MOD40,	OPCL1,	106600

	OPCDEF	M,T,P,I, , ,	MOD40,	OPCL1,	006600

	OPCDEF	M,U,L, , , ,	MOD40,	OPCL7,	070000

	OPCDEF	M,U,L,D, , ,	MOD40,	OPCL11,	171000

	OPCDEF	M,U,L,F, , ,	MOD40,	OPCL11,	171000


	OPCDEF	N,E,G, , , ,	MOD20!MOD40,	OPCL1,	005400

	OPCDEF	N,E,G,B, , ,	MOD20!MOD40,	OPCL1,	105400

	OPCDEF	N,E,G,D, , ,	MOD40,	OPCL1,	170700

	OPCDEF	N,E,G,F, , ,	MOD40,	OPCL1,	170700

	OPCDEF	N,O,P, , , ,	MOD20!MOD40,	OPCL0,	000240


	OPCDEF	R,E,S,E,T, ,	MOD20!MOD40,	OPCL0,	000005

	OPCDEF	R,O,L, , , ,	MOD20!MOD40,	OPCL1,	006100

	OPCDEF	R,O,L,B, , ,	MOD20!MOD40,	OPCL1,	106100

	OPCDEF	R,O,R, , , ,	MOD20!MOD40,	OPCL1,	006000

	OPCDEF	R,O,R,B, , ,	MOD20!MOD40,	OPCL1,	106000

	OPCDEF	R,T,I, , , ,	MOD20!MOD40,	OPCL0,	000002


	OPCDEF	R,T,S, , , ,	MOD20!MOD40,	OPCL3,	000200

	OPCDEF	R,T,T, , , ,	MOD40,	OPCL0,	000006

	OPCDEF	S,B,C, , , ,	MOD20!MOD40,	OPCL1,	005600

	OPCDEF	S,B,C,B, , ,	MOD20!MOD40,	OPCL1,	105600

	OPCDEF	S,C,C, , , ,	MOD20!MOD40,	OPCL0,	000277

	OPCDEF	S,E,C, , , ,	MOD20!MOD40,	OPCL0,	000261

	OPCDEF	S,E,N, , , ,	MOD20!MOD40,	OPCL0,	000270

	OPCDEF	S,E,T,D, , ,	MOD40,	OPCL0,	170011

	OPCDEF	S,E,T,F, , ,	MOD40,	OPCL0,	170001

	OPCDEF	S,E,T,I, , ,	MOD40,	OPCL0,	170002

	OPCDEF	S,E,T,L, , ,	MOD40,	OPCL0,	170012

	OPCDEF	S,E,V, , , ,	MOD20!MOD40,	OPCL0,	000262

	OPCDEF	S,E,X, , , ,	MOD40,	OPCL1,	006700

	OPCDEF	S,E,Z, , , ,	MOD20!MOD40,	OPCL0,	000264

	OPCDEF	S,O,B, , , ,	MOD40,	OPCL8,	077000

	OPCDEF	S,P,L, , , ,	MOD40,	OPCL13,	000230

	OPCDEF	S,T,A,0, , ,	MOD40,	OPCL0,	170005

	OPCDEF	S,T,B,0, , ,	MOD40,	OPCL0,	170006

	OPCDEF	S,T,C,D,F, ,	MOD40,	OPCL12,	176000

	OPCDEF	S,T,C,D,I, ,	MOD40,	OPCL12,	175400

	OPCDEF	S,T,C,D,L, ,	MOD40,	OPCL12,	175400

	OPCDEF	S,T,C,F,D, ,	MOD40,	OPCL12,	176000

	OPCDEF	S,T,C,F,I, ,	MOD40,	OPCL12,	175400

	OPCDEF	S,T,C,F,L, ,	MOD40,	OPCL12,	175400

	OPCDEF	S,T,D, , , ,	MOD40,	OPCL12,	174000

	OPCDEF	S,T,E,X,P, ,	MOD40,	OPCL12,	175000

	OPCDEF	S,T,F, , , ,	MOD40,	OPCL12,	174000

	OPCDEF	S,T,F,P,S, ,	MOD40,	OPCL1,	170200

	OPCDEF	S,T,Q,0, , ,	MOD40,	OPCL0,	170007

	OPCDEF	S,T,S,T, , ,	MOD40,	OPCL1,	170300

	OPCDEF	S,U,B, , , ,	MOD20!MOD40,	OPCL2,	160000

	OPCDEF	S,U,B,D, , ,	MOD40,	OPCL11,	173000

	OPCDEF	S,U,B,F, , ,	MOD40,	OPCL11,	173000


	OPCDEF	S,W,A,B, , ,	MOD20!MOD40,	OPCL1,	000300

	OPCDEF	S,X,T, , , ,	MOD20!MOD40,	OPCL1,	006700

	OPCDEF	T,R,A,P, , ,	MOD20!MOD40,	OPCL6,	104400


	OPCDEF	T,S,T, , , ,	MOD20!MOD40,	OPCL1,	005700

	OPCDEF	T,S,T,B, , ,	MOD20!MOD40,	OPCL1,	105700

	OPCDEF	T,S,T,D, , ,	MOD40,	OPCL1,	170500

	OPCDEF	T,S,T,F, , ,	MOD40,	OPCL1,	170500

	OPCDEF	W,A,I,T, , ,	MOD20!MOD40,	OPCL0,	000001

	OPCDEF	X,O,R, , , ,	MOD40,	OPCL5,	074000


	DIRDEF	.,A,B,S, , ,	ABS0

	DIRDEF	.,A,S,C,I,I,	.ASCII

	DIRDEF	.,A,S,C,I,Z, 	.ASCIZ

	DIRDEF	.,A,S,E,C,T,	ASECT

	DIRDEF	.,B,L,K,B, , 	.BLKB

	DIRDEF	.,B,L,K,W, , 	.BLKW

	DIRDEF	.,B,Y,T,E, ,	.BYTE

	DIRDEF	.,C,S,E,C,T,	CSECT

	DIRDEF	.,D,S,A,B,L, 	.DSABL

	DIRDEF	.,E,N,A,B,L, 	.ENABL

	DIRDEF	.,E,N,D, , ,	.END

.ENDCX:	DIRDEF	.,E,N,D,C, ,	ENDC0

.ENDMX:	DIRDEF	.,E,N,D,M, ,	.ENDM

.ENDRX:	DIRDEF	.,E,N,D,R, ,	ENDR0

	DIRDEF	.,E,O,T, , ,	.EOT

	DIRDEF	.,E,R,R,O,R, 	.ERROR

	DIRDEF	.,E,V,E,N, ,	.EVEN


	DIRDEF	.,F,L,T,2, ,	.FLT2

	DIRDEF	.,F,L,T,4, ,	.FLT4

	DIRDEF	.,G,L,O,B,L,	.GLOBL

	DIRDEF	.,I,D,E,N,T,	.IDENT

.IFX:
	DIRDEF	.,I,F, , , , 	.IF

	DIRDEF	.,I,F,D,F, ,	.IFDF

	DIRDEF	.,I,F,E,Q, ,	IFZ0

.IFFX:	DIRDEF	.,I,F,F, , , 	.IFF

	DIRDEF	.,I,F,G, , ,	IFG0

	DIRDEF	.,I,F,G,E, ,	IFGE0

	DIRDEF	.,I,F,G,T, ,	IFG0

	DIRDEF	.,I,F,L, , ,	IFL0

	DIRDEF	.,I,F,L,E, ,	IFLE0

	DIRDEF	.,I,F,L,T, ,	IFL0

	DIRDEF	.,I,F,N,D,F,	.IFNDF

	DIRDEF	.,I,F,N,E, ,	IFNZ0

	DIRDEF	.,I,F,N,Z, ,	IFNZ0

.IFTX:	DIRDEF	.,I,F,T, , ,	.IFT

.IFTFX:	DIRDEF	.,I,F,T,F, ,	.IFTF

	DIRDEF	.,I,F,Z, , ,	IFZ0
.IFY:

	DIRDEF	.,I,I,F, , ,	.IIF

.IRPOP:	DIRDEF	.,I,R,P, , ,	.IRP

.IRCOP:	DIRDEF	.,I,R,P,C, ,	.IRPC

	DIRDEF	.,L,I,M,I,T,	.LIMIT

	DIRDEF	.,L,I,S,T, , 	.LIST

.MACRX:	DIRDEF	.,M,A,C,R, ,	DEFIN0

.MACRY:	DIRDEF	.,M,A,C,R,O,	DEFIN0

	DIRDEF	.,M,C,A,L,L,	.MCALL

	DIRDEF	.,M,E,X,I,T,	.MEXIT

	DIRDEF	.,N,A,R,G, ,	.NARG

	DIRDEF	.,N,C,H,R, ,	.NCHR

	DIRDEF	.,N,L,I,S,T, 	.NLIST

	DIRDEF	.,N,T,Y,P,E,	.NTYPE

	DIRDEF	.,O,D,D, , ,	.ODD

	DIRDEF	.,O,P,D,E,F,	.OPDEF

	DIRDEF	.,P,A,G,E, ,	.PAGE

	DIRDEF	.,P,D,P,1,0,	.PDP10

	DIRDEF	.,P,R,I,N,T,	.PRINT

	DIRDEF	.,R,A,D,I,X,	.RADIX

	DIRDEF	.,R,A,D,5,0,	.RAD50

.REPTX:	DIRDEF	.,R,E,P,T, ,	REPEA0

	DIRDEF	.,R,O,U,N,D,	.ROUND

	DIRDEF	.,S,B,T,T,L, 	.SBTTL

	DIRDEF	.,T,I,T,L,E,	.TITLE

	DIRDEF	.,T,R,U,N,C,	.TRUNC

	DIRDEF	.,W,O,R,D, ,	.WORD

OPTTOP:	-1B36			;OP TABLE TOP

CONDX:
	DIRDEF	B,,,,,,.IFB
	DIRDEF	D,F,,,,,.IFDF
	DIRDEF	D,I,F,,,,.IFDIF
	DIRDEF	E,Q,,,,,IFZ0
	DIRDEF	G,,,,,,IFG0
	DIRDEF	G,E,,,,,IFGE0
	DIRDEF	G,T,,,,,IFGE0
	DIRDEF	I,D,N,,,,.IFIDN
	DIRDEF	L,,,,,,IFL0
	DIRDEF	L,E,,,,,IFLE0
	DIRDEF	L,T,,,,,IFL0
	DIRDEF	N,B,,,,,.IFNB
	DIRDEF	N,D,F,,,,.IFNDF
	DIRDEF	N,E,,,,,IFNZ0
	DIRDEF	N,Z,,,,,IFNZ0
	DIRDEF	Z,,,,,,	IFZ0
CONDY:

	SUBTTL	CHARACTER DISPATCH ROUTINES

C1PNTR:	POINT	4,CHJTBL(%14), 3
C2PNTR:	POINT	4,CHJTBL(%14), 7
C3PNTR:	POINT	4,CHJTBL(%14),11
C4PNTR:	POINT	4,CHJTBL(%14),15
C5PNTR:	POINT	4,CHJTBL(%14),19
C6PNTR:	POINT	4,CHJTBL(%14),23
C7PNTR:	POINT	4,CHJTBL(%14),27
C8PNTR:	POINT	4,CHJTBL(%14),31
C9PNTR:	POINT	4,CHJTBL(%14),35

ANPNTR=	C8PNTR

CHJTBL:				;CHARACTER JUMP TABLE
	PHASE	0


	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJNU,    ,    	; NULL
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;

	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
TAB:	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJSP,.TAB,    	; TAB
LF:	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJCR,    ,    	; LF
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJVT,    ,    	;
FF:	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJCR,    ,    	; FF
CRR:	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJCR,    ,    	; CR
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;

	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;

	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJNU,    ,    	; EOF
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;

SPACE:	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJSP,.TAB,    	; SPACE
	BYTE	(4)	    ,    ,    ,EXOR,    ,    ,QJPC,    ,    	; !
	BYTE	(4)	    ,    ,    ,EXTE,TEDQ,    ,QJPC,    ,    	; "
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; #
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; $
	BYTE	(4)	    ,    ,    ,EXTE,TEPC,    ,QJPC,    ,    	; %
	BYTE	(4)	    ,    ,    ,EXAN,    ,    ,QJPC,    ,    	; &
	BYTE	(4)	    ,    ,    ,EXTE,TESQ,    ,QJPC,    ,    	; '

	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; (
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; )
	BYTE	(4)	    ,    ,    ,EXMU,    ,    ,QJPC,    ,    	; *
	BYTE	(4)	    ,    ,    ,EXPL,TEIG,    ,QJPC,    ,    	; +
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ,
	BYTE	(4)	    ,    ,    ,EXMI,TE2C,    ,QJPC,    ,    	; -
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; .
	BYTE	(4)    	    ,    ,    ,EXDV,    ,    ,QJPC,    ,    	; /

	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 0
	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 1
	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 2
	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 3
	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 4
	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 5
	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 6
	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 7

	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 8
	BYTE	(4)	    ,    ,    ,EXTE,TENM,    ,QJPC,.NUM,    	; 9
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; :
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ;
	BYTE	(4)	    ,    ,    ,EXTE,TEEX,    ,QJPC,    ,    	; <
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; =
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; >
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ?

	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; @
	BYTE	(4)	    ,    ,    ,EXTE,TEHX,    ,QJPC,.HEX,    	; A
	BYTE	(4)	    ,    ,    ,EXTE,TEHX,    ,QJPC,.HEX,UPARB	; B
	BYTE	(4)	    ,    ,    ,EXTE,TEHX,    ,QJPC,.HEX,UPARC	; C
	BYTE	(4)	    ,    ,    ,EXTE,TEHX,    ,QJPC,.HEX,UPARD	; D
	BYTE	(4)	    ,    ,    ,EXTE,TEHX,    ,QJPC,.HEX,    	; E
	BYTE	(4)	    ,    ,    ,EXTE,TEHX,    ,QJPC,.HEX,UPARF	; F
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; G

	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,UPARH	; H
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; I
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; J
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; K
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; L
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; M
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; N
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,UPARO	; O

	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; P
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; Q
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; R
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; S
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; T
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; U
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; V
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; W

	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; X
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; Y
	BYTE	(4)	    ,    ,    ,EXTE,    ,    ,QJPC,.ALP,    	; Z
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; [
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; \
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; ]
	BYTE	(4)	    ,    ,    ,EXTE,TEUP,    ,QJPC,    ,    	; ^
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJPC,    ,    	; _

E	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;

	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;

	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;

	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJLC,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
ALTMOD:	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
	BYTE	(4)	    ,    ,    ,    ,    ,    ,    ,    ,    	;
RUBOUT:	BYTE	(4)	    ,    ,    ,    ,    ,    ,QJNU,    ,    	;

	DEPHASE

	LIT

	SUBTTL	IMPURE AREA

	IFNDEF	NONREN,	<RELOC 0>		;LOW SEG

PDPSTK:	BLOCK	PDPLEN

BZCOR:				;BEGINNING OF CORE TO BE INITIALIZED TO ZERO
.IFFLG: BLOCK	1

SYMPNT:	BLOCK	1		;POINTER TO SYMBOL TABLE MNEMONIC
VALPNT:	BLOCK	1		;POINTER TO SYMBOL TABLE VALUE

SYMBOT:	BLOCK	1		;BASE OF SYMBOL TABLE
SYMTOP:	BLOCK	1		;TOP OF SYMBOL TABLE
SYMLEN:	BLOCK	1		;LENGTH OF SYMBOL TABLE
DELTA:	BLOCK	1		;BINARY SEARCH OFFSET

MWPNTR:	BLOCK	1		;MACRO WRITE POINTER
NEXT:	BLOCK	1		;GARBAGE COLLECTION CHAIN
REPEXP:	BLOCK	1		;REPEAT EXPRESSION
REPPNT:	BLOCK	1		;REPEAT POINTER

REPLVL:	BLOCK	1		;REPEAT LEVEL COUNTER
CONLVL:	BLOCK	1		;CONDITIONAL LEVEL COUNTER
UNSLVL:	BLOCK	1		;UNSATISFIED CONDITIONAL NESTING LEVEL

SYMBEG:	BLOCK	1		;POINTER TO START OF SYMBOL FOR RESCAN PURPOSES

RUNTIM:	BLOCK	1		;RUN TIME

LINBUF:	BLOCK	CPL3/5+2		;SOURCE LINE BUFFER


CURADR:	BLOCK	1		;CURRENT DATA BLOCK ADDRESS
BYTCNT:	BLOCK	1		;BYTE COUNT
CHKSUM:	BLOCK	1		;CHECK SUM
DATBLK:	BLOCK	DATLEN+10	;DATA BLOCK
RLDBLK:	BLOCK	RLDLEN+10
RLDCNT:	BLOCK	1
RELLVL:	BLOCK	1		;RELOCATION LEVEL
RECLVL:	BLOCK	1		;RECURSION LEVEL
FLTLST:	BLOCK	2		;FOR EXPANDED FLT PNT LISTING
FLTBUF:	BLOCK	^D8		;DITTO

SEQNUM:	BLOCK	1		;SEQUENCE NUMBER

AC00:	BLOCK	1		;AC EXCHANGE BLOCK
AC01:	BLOCK	1
AC02:	BLOCK	1
AC03:	BLOCK	1
AC04:	BLOCK	1
AC05:	BLOCK	1
AC06:	BLOCK	1
AC07:	BLOCK	1
AC10:	BLOCK	1
AC11:	BLOCK	1
AC12:	BLOCK	1
AC13:	BLOCK	1
AC14:	BLOCK	1

DATE:	BLOCK	1		;DATE FOR HEADER
MSTIME:	BLOCK	1		;CURRENT TIME IN MILLISECONDS
PAGNUM:	BLOCK	1		;PAGE NUMBER
PAGEXT:	BLOCK	1		;PAGE EXTENSION
ERRCNT:	BLOCK	1		;ERROR COUNT
EXTSAV:	BLOCK	1		;FILNAM EXTENSION FOR HEADER (EXEC)


CALPNT:	BLOCK	1		;POINTER TO CURRENT MACRO CALL BLOCK
MACLVL:	BLOCK	1		;MACRO NESTING LEVEL
MLSAVE:	BLOCK	1		; MACRO LEVEL SAVED BY .MEXIT
ARGLST:	BLOCK	^D65		;TEMP STORAGE FOR MACRO ARGUMENTS
MACNAM:	BLOCK	MACNES		; NESTED MACRO DEFINITION NAME TABLE
MCLREP=	MACNAM			; SAVED REPEAT LEVEL TABLE
MCLCON:	BLOCK	MACNES		; SAVED CONDITIONAL LEVEL TABLE
MCLUNS:	BLOCK	MACNES		; SAVED UNSATISFIED LEVEL TABLE
OPCODE:	BLOCK	1		;STORAGE FOR OP CODE
OPCCNT:	BLOCK	^D8
P10CNT:	BLOCK	10		;".PDP10" USAGE COUNT
LSBLOC:	BLOCK	1		; LOCAL SYMBOL BLOCK NUMBER

PF0:	BLOCK	1
PF1:	BLOCK	1
PF2:	BLOCK	1
PF3:	BLOCK	1

PFT0:	BLOCK	1
PFT1:	BLOCK	1

CODPNT:	BLOCK	1
CODBUF:	BLOCK	^D100

OFFSET:	BLOCK	1		;0 OF 1, FOR CEXT1 OR CEXT2
ADREXT:	BLOCK	2
TABCNT:	BLOCK	1
COLCNT:	BLOCK	1
CRFNAM:	BLOCK	CRFLEN		;CREF NAME STORAGE
CRFTYP:	BLOCK	CRFLEN		;CREF TYPE STORAGE

FLTTMP:	BLOCK	2		;FLOATING POINT TEMP
FLTNUM:	BLOCK	4		;FLOATING POINT NUMBERS
FLTLEN:	BLOCK	1		;FLOATING LENGTH

SECBAS:	BLOCK	^D256
SECNAM:	BLOCK	^D256

GLBPNT:	BLOCK	1
GLBBUF:	BLOCK	40

PRGTTL:	BLOCK	1
ENDVEC:	BLOCK	1
LBLPNT:	BLOCK	1

TMPFIL:	BLOCK	2		;TMPCOR UUO ARGUMENT BLOCK
TTLFLA:	BLOCK	1		;=-1 IF PROGRAM NAME TYPED


JOBFFS:	BLOCK	204*NUMBUF	;SOURCE BUFFER
TTISAV:	BLOCK	1		;TTI POINTER SAVE
XESAVE:	BLOCK	1		;FILE NAME STORAGE FOR TTY ERROR MESSAGES

XE:	BLOCK	1		;EXEC LOOKUP BLOCK
XE1:	BLOCK	1
XE2:	BLOCK	1
XE3:	BLOCK	1

BINNAM:	BLOCK	2

				;BUFFER HEADER BLOCKS

TTIPNT:	BLOCK	1

BINBUF:	BLOCK	1
BINPNT:	BLOCK	1
BINCNT:	BLOCK	1
BINPCT:	BLOCK	1		;/P BIN COUNT

LSTBUF:	BLOCK	1
LSTPNT:	BLOCK	1
LSTBCT:	BLOCK	1

SRCBUF:	BLOCK	1
SRCPNT:	BLOCK	1
SRCCNT:	BLOCK	1

LINCNT:	BLOCK	1		;EXEC LINE COUNTER
IFN CMUSW,<
CMUSTR:	BLOCK	2		;STORAGE FOR CMUDEC USERID
CMUCTR:	BLOCK	1		;   CONVERSION
CMUPTR:	BLOCK	1
>
LSTCNT:	BLOCK	1		;LIST LEVEL COUNT
SUBMSG:	BLOCK	30		;SUBTITLE BUFFER AREA
SEQ:	BLOCK	1		; LINE SEQUENCE NUMBER (BINARY)
FSEQ:	BLOCK	2		; FORMATTED LINE SEQUENCE NUMBER

;	**** CORE CLEARED BY INITIALIZATION ENDS HERE ****

EZCOR:
LSTCTL:	BLOCK	1		; LISTING CONTROL FLAGS
CCLFLA:	BLOCK	1		;CCL MODE FLAG, =-1 IF CCL MODE
TMPFLA:	BLOCK	1		;TMPCOR UUO IN PROGRESS FLAG
INDFLA:	BLOCK	1		;INDIRECT FILE IN USE FLAG
JOBFFI:	BLOCK	1		;POINT TO RESTORE JOBFF
CMDBUF:	BLOCK	1		;BUFFER HEADER FOR CMD FILE INPUT
CMDPNT:	BLOCK	1		;BYTE POINTER
CMDCNT:	BLOCK	1		;BYTE COUNT
GLBRDX:	BLOCK	1		;GLOBAL RADIX (SET BY .RADIX)
LOCRDX:	BLOCK	1		;LOCAL RADIX

DEF	NONREN,	<RELOC>

	END	START		;....MACN11


