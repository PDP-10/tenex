;<XTENEX>DSKPAK.ISI;7    25-NOV-73 22:44:32	EDIT BY MELVIN
;CHANGED DSKSWA TO HITRK+1 AND THUS DSKRMA TO <HITRK+1+DSKNST>*NSECTK
;<XTENEX>DSKPAK.ISI;6    14-NOV-73 22:35:15	EDIT BY MELVIN
;CHANGED HITRK TO BE EQUAL TO NTRACK-1
;<XTENEX>DSKPAK.ISI;5    13-JUL-73 22:52:59	EDIT BY MELVIN
;<XTENEX>DSKPAK.ISI;4    13-JUL-73 22:36:20	EDIT BY MELVIN
;PUT IN ALLOCATION FOR NEW DISK -- USING ONLY LOWER HALF OF THE
;FORTH DRIVE (DRIVE 3)
;<XTENEX>DSKPAK.ISI;3    16-MAY-73 03:31:39	EDIT BY MELVIN
;CHANGED HITRK TO NTRACK
;<XTENEX>DSKPAK.ISI;2    16-MAY-73 01:18:14	EDIT BY MELVIN
;CHANGED DISK ALLOCATION SO THAT ALL OF SYSTEM DRIVES IS USED
;FOR FILE SPACE.  IF THE DRUM GOES DOWN, THE STANDBY DRIVE MUST BE
;BROUGHT UP FOR SWAPPING.
;WRMON AND WRSWM ARE DISABLED
;<XTENEX>DSKPAK.ISI;1     8-FEB-73 21:47:42	EDIT BY MELVIN
;HITRK AND DSKRMA CHANGED AND FILE CHANGED TO DSKPAK.ISI
;<TENEX-130>DSKPAK.MAC;48    28-DEC-72 19:26:25	EDIT BY CLEMENTS
;FIXED TYPO IN DSKRCK
;<TENEX-130>DSKPAK.MAC;47    26-DEC-72 16:20:45	EDIT BY TOMLINSON
;<TENEX-130>DSKPAK.MAC;46    26-DEC-72 14:59:37	EDIT BY TOMLINSON
;<TENEX-130>DSKPAK.MAC;49    20-DEC-72 10:21:53	EDIT BY TOMLINSON
;<TENEX-130>DSKPAK.MAC;48    20-DEC-72 10:06:43	EDIT BY TOMLINSON
; ADDED TEMPORARY TABLE OF HOME ADDRESSES TO RESERVE SPACE
;<TENEX-130>DSKPAK.MAC;47    20-DEC-72 09:01:27	EDIT BY TOMLINSON
;<TENEX-130>DSKPAK.MAC;46    18-DEC-72 15:24:40	EDIT BY TOMLINSON
;<TENEX-130>DSKPAK.MAC;45    18-DEC-72 15:20:37	EDIT BY TOMLINSON
;<TENEX-130>DSKPAK.MAC;44    21-NOV-72 16:58:16	EDIT BY WALLACE
;<TENEX-130>DSKPAK.MAC;43    21-NOV-72 15:44:50	EDIT BY WALLACE
;<TENEX-130>DSKPAK.MAC;42    20-NOV-72 23:55:32	EDIT BY TOMLINSON
;<TENEX-130>DSKPAK.MAC;41    20-NOV-72 17:23:00	EDIT BY WALLQcE
;<TENEX-130>DSKPAK.MAC;40    20-NOV-72 15:05:03	EDIT BY TOMLINSON
;<TENEX-130>DSKPAK.MAC;39    18-NOV-72 18:49:01	EDIT BY WALLACE
;<TENEX-130>DSKPAK.MAC;38     9-NOV-72 19:35:17	EDIT BY TOMLINSON
; ISOLATING FOR SEPARATE ASSEMBLY -- ADDED BGHERE AND END
;<TENEY-530>DSKPAK.MAC;37     6-NOV-72 12:27:56	EDIT BY TOMLINSON
; DSKRDA FIXES
;<TENEXDLM>DSKPAK.MAC;36    22-SEP-72 15:21:03	EDIT BY MURPHY
;<TENEXDLM>DSKPAK.MAC;35    21-SEP-72 11:31:21	EDIT BY MURPHY
;<TENEXDLM>DSKPAK.MAC;34     8-AUG-72 22:02:56	EDIT BY MURPHY
;<TENEXDLM>DSKPAK.MAC;33     8-AUG-72 19:01:30	EDIT BY MURPHY
;<TENEXDLM>DSKPAK.MAC;32     7-AUG-72 23:15:17	EDIT BY MURPHY

;19 JUN 72, 1852:
;TENEX DRIVER FOR DISK PACKS.  D. MURPHY

;GENERAL CODE FOR DISK PACK DEVICES; DEVICE DEPENDENT CODE FOR
;DEC RP10/RP02 AND TELEFILE DC10 INCLUDED UNDER ASSEMBLY SWITCH

	INTERN RLMX0,DSKRMA,VERSIZ,VERSNL,NSECPG
	INTERN DSKIO,DSKCHK,UDSKIO,CVDSK,CDSKVA,DIDSCI,DSKCP
	EXTERN NOFN,BLOCK1,DSKTIM,DISKP,FPTA,JFNOFN,NXTDMP
	EXTERN SETMPG,SETPT,DBUGSW,PSKED,DIDSCA,DEVMPE
	EXTERN DISGET,SCHEDP,EDISMS

;THE FOLLOWING ARE ALL OF THE DEVICE AND INSTALLATION DEPENDENT
;PARAMETERS

IFDEF RP02F,<		;RP02 DEVICE PARAMETERS

DSK=250			;DEVICE ADDRESS
DSKCP=62		;INITIAL CHANNEL ADDRESS

NTKUN=^D406		;NUMBER OF TRACKS PER DRIVE (UNIT)
NCYLBT==8
NSECBT==5

	NTRACK=NTKUN*NPACKS ;EACH DRIVE CONSIDERED A GROUP OF TRACKS

NWSEC==200		;RPO2'S HAVE 128 WORDS/SECTOR,
NSECS==^D10		; 10 SECTORS PER ROTATION,
NSURFS==^D20		; AND 20 SURFACES PER UNIT

	HOMCY1==1			; HOME CYLINDERS
	HOMCY2==1
	HOMSF1==5			; SURFACES
	HOMSF2==^D15
	HOMSC1==0			; AND SECTORS
	HOMSC2==0
	NSECPG==1000/NWSEC		;SECTORS PER PAGE
	NSECTK==NSURFS*NSECS		;NUMBER OF SECTORS PER TRACK
	NPGTK==NSECTK*NWSEC/1000	;NUMBER OF PAGES PER TRACK
	NBWTK==<NPGTK+^D35>/^D36	;NUMBER OF WORDS OF BITS PER TRACK
	NMINFP==NPGTK/3			;MIN PAGES FOR FREE CHOICE ASSMT
	DSKNST==NDST/NPGTK		;NUMBER OF TRACKS FOR SWAPPING

;THE FOLLOWING PARAMETERS RESERVE THE VARIOUS AREAS OF THE DISK(S)

HITRK=NTRACK-^D100		;UPPER LIMIT, PUBLIC FILE SYSTEM
LOTRK==0			;LOWER LIMIT
DSKSWA==<HITRK+1>*NSECTK	;SWAPPING AREA BEGINS ON STANDBY DRIVE
DSKRMA==<HITRK+1+DSKNST>*NSECTK	;RESIDENT MON IS JUST ABOVE SWAPPING AREA
DSKSMA==DSKRMA+200*NSECPG	;SWAPPABLE MONITOR JUST ABOVE RESIDENT MON
CSHPAG:: DSKSMA+200*NSECPG	;LINEAR DISK ADDR OF CRSH CNTRL PAGE
				;CRASH IMAGES START AT PAGE CSHPAG+1
;*******************************
;defined in CRSHSV:
;NCSHSV==1			;number of crash dump areas
;LCSHSV==600*NSECPG		;size of each dump area (in sectors)
;*******************************
VERSIZ==230			;SIZE OF MON SAVES PER AREA
VERSNL==<NTRACK-^D16>*NSECTK	;SYSTEM SAVE AREA

>			;END OF RP02 PARAMETERS

IFDEF DC10F,<		;TELEFILE DC10 PARAMETERS

DSK=700
DSKCP=62

IFNDEF CD215F,<
NTKUN==^D203
NWSEC==100
NSECS==^D18
NCYLBT==8
NSECBT==5
>

IFDEF	CD215F,<
NTKUN==^D406
NWSEC==200
NSECS==^D9
NCYLBT==9
NSECBT==4
>

NSURFS==^D20

	HOMCY1==1		; HOME CYLINDERS
	HOMCY2==1
	HOMSF1==5		; AND SURFACES
	HOMSF2==15
	HOMSC1==0		; AND SECTORS
	HOMSC2==0
	ADRPOS==^D14+NSECBT
	NTRACK=NTKUN*NPACKS
	NSECPG==1000/NWSEC		;SECTORS PER PAGE
	NSECTK==NSURFS*NSECS		;NUMBER OF SECTORS PER TRACK
	NPGTK==NSECTK*NWSEC/1000	;NUMBER OF PAGES PER TRACK
	NBWTK==<NPGTK+^D35>/^D36	;NUMBER OF WORDS OF BITS PER TRACK
	NMINFP==NPGTK/3			;MIN PAGES FOR FREE CHOICE ASSMT
	DSKNST==NDST/NPGTK		;NUMBER OF TRACKS FOR SWAPPING

HITRK=NTRACK-5
LOTRK=0

DSKSWA==<NTRACK>*NSECTK		;SWAPPING AREA AFTER 'LAST' PACK

DSKRMA==<HITRK>*NSECTK		;RESIDENT MON IMAGE
DSKSMA==DSKRMA+PPRMPG*NSECPG	;SWAP MON IMAGE
>			;END OF DC10 PARAMETERS

;COMMON PARAMETERS AND STORAGE

NGS DSKFCT,NTRACK	;COUNT OF FREE PAGES EACH TRACK
NGS DSKBTB,NTRACK*NBWTK	;BIT TABLE
XX==NTRACK+NTRACK*NBWTK		;SIZE OF ACTUAL STORAGE FOR CNT AND BITS
NGS DSKDMY,<<<XX+777>/1000>*1000>-XX ;FILL TO NEXT PAGE BOUNDARY
NGS INFBUF,NJOBS*40	;defined here so it comes after bittable
			;INFBUF USED BY .GTINF,.PTINF
XX==NJOBS*40
NGS INFDMY,<<<XX+777>/1000>*1000>-XX ;fill to next page boundry

LS DSKBLK,1		;BIT TABLE LOCK
LS DBTJFN,1		;JFN OF BIT TABLE FILE

;DISC ADDRESS OF INDEX FILE

DIDSC0==<HITRK+LOTRK>/2*NSECTK	;PUT IN MIDDLE OF FILE AREA

DIDSCI:	DIDSC0+DSKABT
GS DIDSCA,1

NDVMAX==2		;MAX NUMBER OF DRIVES

DSKSIP=1B19		;SEEK IN PROGRESS, LH OF DSKSTS
DSKCMR=1B20		;COMMAND READY, LH OF DSKSTS
DSKUIO=1B21		;UDSKIO TYPE OPERATION, LH OF DSKSTS
DSKRCB=1B22		;RECALIBRATE IN PROGRESS

NDSKCM==10		;SIZE OF UDSKIO COMMAND BUFFER
NDSKPD==10		;SIZE OF INTERRUPT PDL
NPD1==20		;SIZE OF LOCAL (MAIN) PDL

;STATUS OF DRIVE IS RECORDED IN DSKSTS
; BITS 18 - 23 ARE ERROR COUNTER
; BITS 24 - 32 ARE CYLINDER AT WHICH DRIVE IS POSITIONED OR SEEKING
;LH BITS 13-17 ARE AN INDEX INTO THE UDSKIO COMMAND BUFFER
;DSKUIO BIT ON INDICATES UDSKIO TYPE OPERATION
; DSKRCB BIT ON INDICATES RECALIBRATE OPERATION IN PROGRESS
;STATE OF DRIVE IS INDICATED BY DSKSIP AND DSKCMR BITS IN LH
; 00 - NOTHING HAPPENING
; 10 - DRIVE SEEKING TRACK
; 01 - DRIVE POSITIONED, TRANSFER READY TO BE STARTED
; 11 - TRANSFER IN PROGRESS (ALSO USED WHEN REQUEST BEING UNQUEUED)

;STORAGE

LS DSKFCL,1		;FREE LIST FOR UDSKIO REQUEST PAIRS
LS DSKCCT,1		;COUNT OF UDSKIO REQUESTS
LS DSKCL,2*NDSKCM	;COMMAND BUFFER FOR UDSKIO REQUESTS
LS DSKLUN,1		;LAST UNIT XFERRING, -1 IF NO UNIT XFERRING
LS DSKCCM,2		;BUFFER FOR DF10 CHANNEL COMMAND

LS DSKQ,NDVMAX		;QUEUE FOR ALL SWAP IO REQUESTS

LS DSKUI,NDVMAX		;UTILITY QUEUE IN
LS DSKUO,NDVMAX		;UTILITY QUEUE OUT

LS DSKDAW,NDVMAX	;DISK ADDRESS FOR CURRENT OPERATION
LS DSKCAW,NDVMAX	;CORE ADDRESS AND COUNT FOR CURRENT OPERATION
LS DSKSTS,NDVMAX	;STATUS OF DRIVE,,CURRENT TRACK
LS DSKLSV,NDVMAX	;TIME WHEN CURRENT OPERATION IS OVERDUE

LS DSKPD1,NPD1+1	;LOCAL MAIN PDL

LS DSKSVR,1		;INTERRUPT SERVICE RETURN
LS DSKACP,1		;SAVED AC-P
LS DSKPDL,NDSKPD	;INTERRUPT PDL

;DO NOT REORDER ERROR WORDS, USED BY GETAB

NDSKEW==^D10		;NUMBER OF ERROR WORDS FOR GETAB

LS DSKRCE,1		;COUNT OF RECOVERABLE ERRORS
LS DSKRER,4		;COMMAND WORDS AND ERROR BITS OF LAST ERROR
LS DSKNRE,1		;COUNT OF NON-RECOVERABLE ERRORS
LS DSKLER,4		;COMMAND WORDS AND ERROR BITS LAST NON-REC ERR

DSKNTR==^D5		;NUMBER OF TRIES ON RECOVERABLE ERRORS

UCMIPT:	POINT 5,DSKSTS(1),17	; POINTER TO UDSKIO COMMAND INDEX
ERRCPT:	POINT 6,DSKSTS(1),23	;POINTER TO ERROR RETRY COUNT
CTRKPT:	POINT 9,DSKSTS(1),32	; CURRENT TRACK

;DEVICE DEPENDENT CONSTANTS AND ROUTINES
;SOME ARE CALLED WITH PUSHJ, OTHERS ARE SINGLE INSTRUCTIONS EXECUTED
;WITH XCT

IFDEF RP02F,<		;DEC RP02 DRIVES

DSOIRQ:	CONSO DSK,1B32		;CONSO DSK INTERRUPT REQUEST

DSKPWF:	CONO DSK,175700+1B32	;CONO IN CASE OF POWER FAIL
	JRST DSKSV1

DSZERR:	CONSZ DSK,177760	;CONSZ ERROR CONDITIONS

DCLERR:	CONO DSK,175700+1B32+DSKCHN ;CONO CLEAR ALL ERROR CONDITIONS

DCLDNF:	CONO DSK,1B32+DSKCHN	;CONO CLEAR DONE FLOP

DRATT:	DATAI DSK,0		;READ ATTENTIONS TO AC0, B28-35

DSKPOS:	MOVE 2,DSKDAW(1)	;ISSUE POSITION (SEEK) REQUEST
	TLO 2,(4B2)		;UNIT NUMBER IN AC1, DSK ADR IN DSKDAW(1)
	DATAO DSK,2
	RET

DSKRCL:	MOVSI 2,(7B2)		;ISSUE RECALIBRATE (RESTORE) COMMAND
	DPB 1,[POINT 3,2,5]
	DATAO DSK,2
	RET

DCLATT:	CALL DCLAT1		;INST. TO CLEAR ATTENTIONS FOR DRIVE IN 1

DCLAT1:	MOVSI 2,(5B2)
	DPB 1,[POINT 3,2,5]
	IOR 2,BITS+^D27(1)
	DATAO DSK,2
	RET

DCKSEK:	DATAI DSK,2		;CALLED TO CHECK SEEK COMPLETE
	TLNN 2,(1B11)		;SKIP IF NO SEEK INCOMPLETE
	AOS 0(P)
	RET

DSZPCI:	TLNE 0,(1B14+1B16)	;SKIP NO PCI (GIVEN CONI BITS IN 0)

DSZSCF:	TRNE 0,1B21		;SKIP NO SEARCH FAILURE

DSZATN:	TDNE 0,BITS+^D27(1)	;SKIP IF ZERO ATTENTION

DUEATT:	RET			;UNEXPECTED ATTENTION (NOP FOR RP02)

;TEST EXISTENCE OF UNIT AND INIT

DIUNIT:	MOVEI 3,0(1)		;UNIT NUMBER
	ROT 3,-6		;CONSTRUCT NOP COMMAND
	TLO 3,(6B2)
	DATAO DSK,3		;ISSUE IT, SELECTING UNIT
	JFCL
	DATAI DSK,3		;GET BITS FOR THAT UNIT
	LDB 2,[POINT 3,3,2]	;GET UNIT NUMBER AS REPORTED
	CAIE 2,0(1)		;AGREES?
	BUG(HLT,<DSK - FAILED TO SELECT UNIT>)
	TLNN 3,(1B15)		;NO SUCH UNIT? OR
	TLNN 3,(1B13)		;NOT ON LINE?
	JRST [	SETOM DSKSTS(1)	;YES, PREVENT USE OF DRIVE
		RET]
	MOVEI 3,0(1)
	ROT 3,-6		;CONSTRUCT RECALIBRATE COMMAND
	TLO 3,(7B2)
	DATAO DSK,3		;ISSUE IT
	JFCL
DSKII2:	DATAI DSK,3		;CHECK STATUS OF DRIVE
	LDB 2,[POINT 8,3,10]	;TRACK
	TRNE 3,1B24		;TEST EXTRA BIT FOR RP03
	TRO 2,1B27
	JUMPN 2,DSKII2		;WAIT FOR TRACK 0
	TLNN 3,(1B12)		;AND 'ON CYLINDER'
	JRST DSKII2
	MOVEI 3,0(1)
	ROT 3,-6
	TLO 3,(5B2)		;CONSTRUCT CLEAR ATTENTIONS COMMAND
	IOR 3,BITS+^D27(1)
	DATAO DSK,3		;ISSUE IT
	SETZM DSKSTS(1)		;CLEAR STATUS AND SET TRACK TO 0
	RET

DMKHWA:	LSH 2,^D12		;CONVERT LOGICAL H'WARE ADR TO ACTUAL
	RET			;H'WARE FORMAT

DSKCYL:	POINT 8,DSKDAW(1),13	;POINTER TO CYLINDER ADDRESS

DSKWDA:	1B2+DSKCP			;WRITE DATA COMMAND BITS
DSKRDA:	0B2+DSKCP			;READ DATA COMMAND BITS
>	;END OF RP02 SECTION

IFDEF DC10F,<			;TELEFILE DC10 CONSTANTS AND ROUTINES

DSOIRQ:	JSP 1,.+1		;CONSO DSK REQUESTING
	CONSZ DSK,640777	;ERRORS, DONE, OR ATTENTIONS?
	CONSZ DSK,1B20		;AND NOT BUSY?
	JRST 0(1)		;NO
	JRST 1(1)		;YES

DSKPWF:	CONO DSK,0		;POWER FAIL - CLEAR PI
	JRST DSKSV1

DSZERR:	TDNE 0,[XWD 73700,440000] ;TEST ERRORS, IGNORE EOC

DCLERR:	CALL DCLER1		;DO NOP, CLEARS ALL ERROR FLOPS

DCLER1:	JSP 2,DWTCTL		;WAIT FOR CONTROL NOT BUSY
	MOVEI 2,1(1)		;DEVICE ADDRESS IS 1+LOGICAL UNIT
	LSH 2,^D9		;SHIFT TO POSITION FOR DATAO
;	IORI 2,0B22		;NOP COMMAND
	DATAO DSK,2
	RET

DCLDNF:	CALL [	JSP 2,DWTCTL	;CLEAR DONE FLAG
		DATAO DSK,[0]	;ANY DATAO DOES IT
		RET]

DRATT:	CONI DSK,0		;READ ATTENTIONS INTO 0

DSKPOS:	JSP 2,DWTCTL		;WAIT FOR CONTROLLER
	MOVE 2,DSKDAW(1)	;DSK AND CYLINDER
	IORI 2,3B22		;SEEK COMMAND
	DATAO DSK,2
	RET

DSKRCL:	JSP 2,DWTCTL		;WAIT FOR CONTROL
	MOVEI 2,1(1)		;DEVICE ADDRESS
	LSH 2,^D9		;SHIFT FOR DATAO
	IORI 2,2B22		;RECALIBRATE (RESET) COMMAND
	DATAO DSK,2
	RET

DCLATT:	CALL DCLER1		;CLEAR ATTENTIONS AND SELECT DRIVE

DCKSEK:	CONI DSK,0		;GET SELECTED DRIVE STATUS
	TLNN 0,(1B13)		;CHECK SEEK INCOMPLETE
	AOS 0(P)
	RET

DSZPCI:	TLNE 0,(1B0+1B1)	;CHECK PCI

DSZSCF:	TLNE 0,(1B7+1B8+1B9)	;CHECK SEARCH FAILURE

DSZATN:	CALL [	MOVEI 2,1	;SKIP IF ZERO ATTENTION
		LSH 2,0(1)	;COMPUTE BIT FOR DRIVE
		TDNN 0,2
		AOS 0(P)
		RET]

DUEATT:	JFCL			;UNEXPECTED ATTN (E.G. POWER ON)

DMKHWA:	MOVEI 2,0(2)		;CYL, SURF, AND SEC
	LSH 2,^D35-ADRPOS	;SHIFT FOR DATAO
	DPB 1,[POINT 4,2,26]	;DRIVE NUMBER
	ADDI 2,1B26		;PLUS 1 FOR DRIVE ADDRESS
	RET

;WAIT FOR CONTROL NOT BUSY

DWTCTL:	CONSO DSK,1B20		;CTL BUSY
	JRST 0(2)
	AOS NCTBSY		;COUNT CURRANCES
	JRST DWTCTL

LS NCTBSY,1

DSKCYL:	POINT NCYLBT,DSKDAW(1),9	;POINTER TO CYL IN H'WARE ADDRESS

DSKWDA:	6B22+DSKCP		;WRITE DATA COMMAND
DSKRDA:	4B22+DSKCP		;READ DATA COMMAND

;TEST UNIT FOR READY AND INIT

DIUNIT:	MOVEI 3,1(1)		;UNIT ADDRESS
	LSH 3,^D9
	CONO DSK,DSKCHN(3)	;SELECT IT
	CONI DSK,3		;GET DEVICE STATUS
	TLNE 3,(1B12+1B15)	;OFF LINE OR WRITE INHIBIT?
	JRST [	SETOM DSKSTS(1)	;YES, SET STATE TO OFFLINE
		RET]
	CALL DSKRCL		;ISSUE RECAL
	MOVEI 2,1		;COMPUTE BIT FOR DRIVE
	LSH 2,0(1)
	CONSO DSK,0(2)		;WAIT FOR ATTN
	JRST .-1
	CONI DSK,3
	TLNE 3,(1B13)		;SEEK INCOMPLETE?
	BUG(HLT,<DSKINI - SEEK INCOMPLETE ON RECAL>)
	MOVEI 3,1(1)
	LSH 3,^D9
	IOR 3,DSKRDA		;CONSTRUCT READ
	DATAO DSK,3		;DO 1-WORD READ TO CLEAR ATTN
	CONSZ DSK,1B20		;WAIT FOR DONE
	JRST .-1
	CONSZ DSK,0(2)		;ATTN NOW GONE?
	BUG(HLT,<DSKINI - XFER FAILED TO CLEAR ATTN>)
	SETZM DSKSTS(1)		;SET STATUS TO READY
	RET
>			;END DC10 SECTION

;DISK I/O DRIVER - CALLED FROM SWAPPER

DSKIO:	SKIPG DISKP
	JRST DRMIO		;NO DISK, USE DRUM
	MOVEM P,DSKPD1		;SETUP LOCAL STACK
	MOVE P,[XWD -NPD1,DSKPD1]
	PUSH P,1
	MOVE 4,CST1(1)		;GET DISK ADDRESS
	TLNN 4,10		;REGULAR DISK ADDRESS?
	JRST [	PUSH P,1	;NO, MUST BE SWAPPING ADDRESS
		MOVE 1,4
		CALL DSKIS	;CONVERT TO REGULAR DISK ADDRESS
		MOVE 4,1
		POP P,1
		JRST DSKI7]
DSKI7:	PUSH P,1
	MOVE 1,4		;DISK ADDRESS
	CALL CVDSK		;CONVERT TO HARDWARE FORMAT
	POP P,4
	LDB 3,[POINT NCYLBT,1,17+NCYLBT]	;GET TRACK NUMBER
	TRNE 1,1B31		;TEST RP03 EXTRA BIT
	TRO 3,1B27	
	TLO 4,0(3)		;PUT IN LH OF LIST WORD
	HLRZ 1,1		;GET DRIVE NUMBER FOR INDEX
	PIOFF			;MUST NOT INTERRUPT QUEUEING
	MOVEI 3,CST3(4)		;ADD TO SWAP QUEUE
	EXCH 3,DSKQ(1)
	HRRI 4,0(3)
	MOVEM 4,@DSKQ(1)
	PION
	SETO 3,
	CAMN 3,DSKSTS(1)	;DRIVE INITIALIZED?
	BUG(CHK,<DSKIO REQUESTED ON UNAVAILABLE DRIVE>)
	SKIPGE DSKLUN		;TRANSFER NOW IN PROGRESS?
	CALL DSKRC		;NO, GO START THIS OPERATION
DSKIR:	POP P,1
	MOVE P,DSKPD1		;RESTORE CALLERS STACK
	RET

;IF SWAPPING TO DISK, DISK ADDRESS DISGUISED AS DRUM ADDRESS

DSKIS:	SKIPE DRUMP		;REALLY SWAPPING ON DISK?
;;;	BUG(HLT,<DSKIO - BAD SWAP ADDRESS>)
	JFCL 0
	HRRZS 2,1		;LINEARIZE 'DRUM' ADDRESS
	ANDI 2,77		;SECTOR
	LSH 1,-6		;BAND
	IMULI 1,DRMSEC
	ADD 1,2
	IMULI 1,NSECPG		;TIMES SECTORS PER PAGE
	ADD 1,[DSKSWA]		;BEGINNING OF SWAP AREA
	RET

;PERIODIC CHECK OF DISK

DSKCHK:	MOVEI 1,^D1000		;DO IT ONCE PER SEC.
	MOVEM 1,DSKTIM
	MOVSI 1,-NDVMAX
DSKCH3:	SKIPE 2,DSKLSV(1)	;TIME SETUP ON THIS DRIVE?
	CAMLE 2,TODCLK		;AND PAST DUE?
	JRST DSKCH1		;NO
	SETO 2,
	CAME 2,DSKSTS(1)	;DRIVE UNINITIALIZED?
	JRST DSKCH4		;NO
;	CALL DIUNIT		;YES, TRY TO INIT IT
	MOVE 2,TODCLK
	ADDI 2,^D10000
	SKIPL DSKSTS(1)		;WAS INIT SUCCESSFUL?
	SETZ 2,			;YES, NO FURTHER CHECK
	MOVEM 2,DSKLSV(1)	;OTHERWISE CHECK AGAIN IN 10SEC.
	JRST DSKCH1

DSKCH4:	BUG(HLT,<DISK OPERATION OVERDUE>)
REPEAT 0,<		;THE FOLLOWING WAS INTENDED TO RESTART A DRIVE
			;FROM WHICH AN INTERRUPT HAD BEEN LOST, BUT
			;PECULIARITIES IN THE DC10 MAKE IT INADEQUATE
	MOVSI 2,DSKUIO		;GIVE ERROR COMPLETION FOR REQUEST
	TDNE 2,DSKSTS(1)	;IN PROGRESS
	JRST [	LDB 3,UCMIPT	; UTILITY OP
		MOVEI 2,-1	;RETURN -1 FOR NONSPECIFIC FAILURE
		MOVEM 2,DSKCL+1(3)
		JRST DSKCH2]
	CHNOFF DSKCHN
	CALL DSKEP1		;PROCESS 'UNREC' ERROR
	CHNON DSKCHN
DSKCH2:	CALL DIUNIT
>
DSKCH1:	AOBJN 1,DSKCH3
	RET

;UTILITY DISK I/O
; AC1/ HARDWARE DISK ADDRESS
; AC2/ BIT 13 - WRITE HEADER, BIT 14 - WRITE, BIT 15 - COMPARE CLASS
;      BITS 16-24 - CLASS, BITS 25-35 WORD COUNT
; AC3/ REAL CORE ADDRESS
;RETURNS +1 WITH ERROR BITS IN AC1 24-35 (0 IF NO ERRORS)

UDSKIO:
UDSK3:	SOSGE DSKCCT		;COMMAND BUFFER FULL?
	JRST UDSK1		;YES, GO WAIT FOR ROOM
	NOSKED
	MOVE 4,@DSKFCL		;GET A COMMAND PAIR
	EXCH 4,DSKFCL
	HRLZM 1,0(4)		;STORE DISK ADDRESS LH OF FIRST WORD
	HRRZM 3,1(4)		;CORE ADDRESS RH OF SECOND WORD
	HRLM 2,1(4)		;WORD COUNT IN BITS 7-17
	MOVEI 3,0(4)
	SUBI 3,DSKCL		;INDEX FOR THIS PAIR
	TLNE 2,(1B14)		;READ OR WRITE?
	TROA 3,600000B46	;WRITE
	TRO 3,400000B46		;READ, B0 ALWAYS SET
	DPB 3,[POINT 7,1(4),6]	;TO BITS 0-6
	HLRZ 1,1		;DRIVE NUMBER
	ANDI 1,NDVMAX-1
	SETO 3,
	CAMN 3,DSKSTS(1)	;UNIT INITIALIZED?
	JRST [	MOVEI 1,-1	;NO, RETURN FAILURE
		JRST UDSK4]
	PIOFF
	HRRM 4,@DSKUI(1)	;APPEND TO UTILITY QUEUE
	HRRZM 4,DSKUI(1)
	PION
	PUSH P,4
	SKIPGE DSKLUN		;STARTUP POSSIBLE?
	CALL DSKRC		;YES
	POP P,4
	OKSKED
	MOVEI 1,DISGET		;SCHEDULER .GE. TEST
	HRLI 1,1(4)		;WILL TEST SECOND WORD OF PAIR
	JSYS SCHEDP
	NOSKED
	MOVE 1,1(4)		;ERROR BITS RETURNED HEREIN
UDSK4:	EXCH 4,DSKFCL		;RETURN PAIR TO FREE LIST
	MOVEM 4,@DSKFCL
	AOS DSKCCT
	OKSKED
	RET

UDSK1:	PUSH P,1
	AOS DSKCCT		;CORRECT COUNT
	MOVEI 1,UDSK2
	JSYS EDISMS		;DISMISS TILL ROOM IN COMMAND LIST
	POP P,1
	JRST UDSK3

UDSK2:	SKIPG DSKCCT		;ROOM NOW?
	JRST 0(4)		;KEEP WAITING
	JRST 1(4)		;RUN

;ENTRY TO DSKRCK AT NON-INTERRUPT LEVEL

DSKRC:	MOVSI 3,DSKSIP+DSKCMR
	CHNOFF DSKCHN
	SKIPGE DSKLUN		;CONTROL BUSY, OR
	TDNE 3,DSKSTS(1)	;THIS DRIVE NOW DOING SOMETHING?
	JRST [	CHNON DSKCHN	;YES, LEAVE IT
		RET]
	CALL DSKRCK		;NO, GO GET IT GOING
	CHNON DSKCHN
	RET

DSKRC3:	HRRZ 2,0(2)		;UNQUEUE
	JUMPN 2,.+3
	MOVEI 3,DSKUO(1)	;FIXUP ON END
	MOVEM 3,DSKUI(1)
	EXCH 2,DSKUO(1)
	MOVSI 3,DWRBIT+DSKUIO
	ANDCAM 3,DSKSTS(1)	;BITS
	LDB 3,[POINT 5,1(2),6]	;DSKCL INDEX
	DPB 3,UCMIPT	 ;WHERE INTERRUPT ROUTINE CAN GET
	HLLZ 3,1(2)		;WORD COUNT
	TLZ 3,774000
	MOVNM 3,DSKCAW(1)	;TO LH OF CHANNEL WORD
	MOVE 4,1(2)		;CORE ADDRESS AND BITS
	HRRM 4,DSKCAW(1)	;STORE CORE ADDRESS
	MOVSI 3,DSKUIO		;SET UTILITY BIT IN ANY CASE
	TLNE 4,200000		;AND IF WRITE,
	MOVSI 3,DSKUIO+DWRBIT	;SET WRITE BIT TOO
	IORM 3,DSKSTS(1)	;YES
	HLRZ 2,0(2)		;DISK ADDRESS
	HRLI 2,0(1)		;INCLUDE UNIT
	JRST DSKRC4

;ROUTINE TO REMOVE REQUESTS FOR READ AND WRITE QUEUES AND
;INITIATE SEEK OPERATIONS
;CALLED AT MAIN AND INTERRUPT LEVEL WITH DRIVE NUMBER IN 1

DSKRCK:	IORM 3,DSKSTS(1)	;SET BITS TO INDICATE UNQUEUEING IN PROG
	SKIPE 2,DSKUO(1)	;UTILITY QUEUE WAITING?
	JRST DSKRC3		;YES, IS FIRST PRIORITY
	SKIPN DSKQ(1)		;SWAP REQUESTS WAITING?
	JRST DSKRCC		;NO
	MOVEI 2,DSKQ(1)		;PTR TO QUEUE
	LDB 3,CTRKPT		 ;CURRENT TRACK
	CALL TRKSCH		;FIND NEAREST .GE. TRACK
	JRST [	SETZ 3,		;NONE .GE., SO RESET TO 0
		MOVEI 2,DSKQ(1)	;AND TRY AGAIN
		CALL TRKSCH
		JRST DSKRCC	;NONE, ALL MUST HAVE BEEN FLUSHED
		JRST .+1]
DSKRC2:	SUBI 2,CST3		;CONVERT BACK TO CORE PAGE NUMBER
	HLL 2,CST3(2)		;GET WRITE AND CLASS INFO
	MOVSI 3,DWRBIT+DSKUIO
	ANDCAM 3,DSKSTS(1)	;CLEAR BITS
	MOVSI 3,DWRBIT
	TLNE 2,DWRBIT		;WRITE BIT ON?
	IORM 3,DSKSTS(1)	;YES, PUT IT ON IN STATUS WORD
	MOVEI 3,0(2)
	LSH 3,^D9		;MAKE PAGE NUMBER INTO CORE ADDRESS
	HRLI 3,-1000		;WITH ONE PAGE WORD COUNT
	MOVEM 3,DSKCAW(1)	;LEAVE IT FOR TRANSFER STARTUP
	PUSH P,1
	MOVE 1,CST1(2)		;DISK ADDRESS
	TLNN 1,10		;REGULAR?
	CALL DSKIS		;NO, SWAPPING. CONVERT
	CALL CVDSK		;CONVERT TO HARDWARE FORMAT
	MOVE 2,1
	POP P,1
DSKRC4:	CALL DMKHWA		;MAKE INTO HARDWARE FORMAT
	MOVEM 2,DSKDAW(1)	;LEAVE FOR OTHER ROUTINES
	SETZ 2,
	DPB 2,ERRCPT		;CLEAR ERROR COUNT BEFORE SEEK
	LDB 3,DSKCYL		;GET DESIRED CYLINDER
	MOVE 2,DSKDAW(1)	;GET EXTRA BIT FOR RP03
	TRNE 2,1B19
	TRO 3,1B27
	LDB 2,CTRKPT		 ;CYL DISK IS NOW AT
	DPB 3,CTRKPT		;SET NEW CURRENT TRACK
	CAMN 2,3		;NOW AT DESIRED TRACK?
	JRST [	CONSO PI,1B<DSKCHN+^D20> ;YES, ON PI LEVEL?
		JRST DSKSVX	;NO, GO START TRANSFER
		MOVSI 2,DSKSIP	;YES, SET STATE TO READY
		ANDCAM 2,DSKSTS(1) ;TRANSFER WILL BE STARTED BEFORE DBRK
		RET]
	MOVSI 2,DSKCMR		;CLEAR READY BIT
	ANDCAM 2,DSKSTS(1)
	MOVE 2,TODCLK
	ADDI 2,^D5000		;SET OVERDUE TIME FOR SEEK AS 5 SEC
	MOVEM 2,DSKLSV(1)	;FROM NOW
	JRST DSKPOS		;ISSUE SEEK AND RETURN

;SCAN FOR BEST OP TO DO NEXT
; 2/ QUEUE TO SEARCH
; 3/ CURRENT TRACK
; FIND ANY PAGE ON CURRENT TRACK, OR CLOSEST PAGE .G. CURRENT TRACK

TRKSCH:	PUSH P,1
	PUSH P,[400000]		;USED TO REMEMBER BEST DIFFERENCE FOUND
	PUSH P,[0]		;REMEMBERS PTR TO BEST PAGE FOUND
	PUSH P,3		;CURRENT TRACK
TRKS1:	HRRZ 3,0(2)		;2 ALWAYS HAS PTR TO PTR TO ITEM
	JUMPE 3,TRKSD		;END OF LIST
	MOVEI 1,0(3)
	SUBI 1,CST3		;GET PAGE NUMBER
	MOVE 4,CST0(1)
	TLNE 4,(700B8)		;PAGE NOW IN USE?
	JRST [	HRRZ 4,0(3)	;YES, CANCEL IO. UNQUEUE PAGE
		HRRM 4,0(2)
		MOVSI 4,(CORMB)
		IORM 4,CST0(1)	;SET MODIFIED BIT
		PUSH P,2
		JSP 4,SWPDON
		POP P,2
		JRST TRKS1]
	HLRZ 3,0(3)		;GET TRACK
	ANDI 3,7777
	SUB 3,0(P)		;DIFFERENCE OF THIS AND CURRENT TRACK
	JUMPE 3,TRKSS		;SAME TRACK, CAN'T BE ANY BETTER
	JUMPL 3,TRKSN		;LOWER TRACK, NOT INTERESTED
	CAML 3,-2(P)		;BEST DIFFERENCE?
	JRST TRKSN		;NO
	MOVEM 3,-2(P)		;YES, SAVE DIFFERENCE
	MOVEM 2,-1(P)		;SAVE PTR
TRKSN:	HRRZ 2,0(2)		;CDR
	JRST TRKS1

TRKSD:	MOVE 4,-2(P)
	CAIL 4,400000		;FOUND ANY PAGE?
	JRST TRKSX		;NO
	MOVE 2,-1(P)		;YES, GET PTR
TRKSS:	HRRZ 3,0(2)		;UNQUEUE PAGE
	HRRZ 4,0(3)
	HRRM 4,0(2)
	MOVEI 2,0(3)
	AOS -4(P)		;RETURN SKIP
TRKSX:	SUB P,BHC+3		;FLUSH TEMPS
	POP P,1
	RET

DSKRCC:	MOVSI 3,DSKSIP+DSKCMR
	ANDCAM 3,DSKSTS(1)	;SET DRIVE TO IDLE STATE
	RET

;DISK INTERRUPT SERVICE

	INTERN DSKSV

DSKSV:	XWD DSKSVR,.+1
	XCT DSOIRQ		;DISK REQUESTING?
	JRST @DSKSVR		;NO
	MOVEM P,DSKACP		;SAVE AC
	MOVE P,[IOWD NDSKPD,DSKPDL] ;SET UP LOCAL STACK POINTER
	CONI DSK,0		;GET ALL BITS
	SKIPE PWRDWN		;PWR FAIL?
	JRST DSKPWF		;YES, CLEAR DSK
	SKIPGE 1,DSKLUN		;WAS A DRIVE TRANSFERRING?
	JRST DSKSV2		;NO
	XCT DSZERR		;ERROR?
	JRST DSKERR		;YES
DSKSV7:	MOVSI 2,DSKSIP+DSKCMR	;XFER FINISHED
	ANDCAB 2,DSKSTS(1)	;SO CLEAR ALL BITS FOR THAT DRIVE
	SETZM DSKLSV(1)		;RESET OVERDUE ALARM
	TLNE 2,DSKUIO		;UTILITY OP?
	JRST DSKSVU		;YES
	HRRZ 1,DSKCAW(1)	;GET CORE ADDRESS JUST FINISHED
	LSH 1,-^D9		;PAGE NUMBER
	JSP 4,SWPDON		;NOTE XFER COMPLETED
DSKSV2:	XCT DRATT		;READ ATTENTION BITS INTO AC0, B28-35
	MOVSI 1,-NDVMAX
DSKSV6:	MOVSI 3,DSKSIP+DSKCMR
	XCT DSZATN		;SEEK COMPLETE ON THIS DRIVE?
	JRST DSKSV4		;YES
	TDNN 3,DSKSTS(1)	;THIS DRIVE FREE?
	CALL DSKRCK		;YES, SEE IF ANY WAITING REQUESTS
DSKSV5:	AOBJN 1,DSKSV6		;CHECK ALL DRIVES
	AOS 1,DSKLUN		;START WITH NEXT UNIT, OR 0 IF NONE
	HRLI 1,-NDVMAX
DSKSV3:	MOVEI 2,0(1)
	CAIL 2,NDVMAX
	HRRI 1,0		;WRAPAROUND DRIVE NUMBER
	MOVE 3,DSKSTS(1)
	TLNE 3,DSKCMR		;COMMAND READY AND NO SEEK IN PROGRESS?
	TLNE 3,DSKSIP
	JRST [	AOBJN 1,DSKSV3	;NO, CHECK NEXT DRIVE
		SETOM DSKLUN	;ALL DRIVES CHECKED, NONE XFERRING
		XCT DCLDNF	;CLEAR DONE FLAG
		 IFDEF DC10F,<
		 XCT DSOIRQ	;NEW ATTENTIONS APPEARED?
		 JRST DSKSV1	;NO
		 JRST DSKSV2>	;YES, MUST SERVICE NOW CAUSE PI CLRD
		JRST DSKSV1]	;GO DEBREAK
	SETZ 2,
	DPB 2,ERRCPT		;CLEAR ERROR COUNT
	CALL DSKSVX		;START TRANSFER
DSKSV1:	MOVE P,DSKACP		;RESTORE AC-P
	UNBRK DSK		;DEBREAK

;ROUTINE TO START XFER ON READY DRIVE

DSKSVX:	MOVSI 3,DSKSIP+DSKCMR
	IORB 3,DSKSTS(1)	;SET STATE TO XFER IN PROGRESS
	MOVE 2,TODCLK
	ADDI 2,^D1000		;SET OVERDUE ALARM FOR 1 SEC.
	MOVEM 2,DSKLSV(1)
	MOVE 2,DSKCAW(1)	;CORE ADDRESS AND COUNT
	HRRI 2,-1(2)		;LIKE IOWD, ADDRESS IN 1 LESS
	MOVEM 2,DSKCCM		;FIXED LOCATION FOR CHANNEL COMMAND
	MOVE 2,DSKDAW(1)	;DISK ADDRESS
	TLNE 3,DWRBIT		;READ OR WRITE?
	TDOA 2,DSKWDA		;WRITE, CONSTRUCT COMMAND
	TDO 2,DSKRDA		;CONSTRUCT READ COMMAND
	PIOFF
	DATAO DSK,2		;START XFER
	HRRZM 1,DSKLUN		;REMEMBER NUMBER OF DRIVE XFERRING
	PION
	RET

;FOUND ATTN BIT FOR DRIVE

DSKSV4:	XCT DCLATT		;CLEAR ATTENTIONS
	MOVSI 3,DSKSIP
	XOR 3,DSKSTS(1)
	TLCE 3,DSKSIP+DSKCMR	;WAS SEEK IN PROGRESS?
	JRST DSKSC1		;NO
	TLNE 3,DSKRCB		;WAS RECALIBRATE COMMAND?
	JRST [	MOVSI 3,DSKRCB	;YES, CLEAR BIT
		ANDCAM 3,DSKSTS(1)
		CALL DSKPOS	;ISSUE NEW SEEK COMMAND
		JRST DSKSV5]
	CALL DCKSEK		;SKIP NO SEEK INCOMPLETE
	JRST DSKSKE
DSKSK1:	MOVSI 3,DSKSIP+DSKCMR
	XORM 3,DSKSTS(1)	;CHANGE STATE TO COMMAND READY
	JRST DSKSV5

DSKSC1:	TLNE 3,DSKSIP+DSKCMR	;WAS IN COMMAND READY STATE?
	CALL DUEATT		;NO, UNEXPECTED
	JRST DSKSV5		;IGNORE IT

DSKSKE:	LDB 3,ERRCPT		;GET RETRY COUNT
	ADDI 3,1
	CAILE 3,DSKNTR		;UNRECOVERABLE?
	JRST DSKSK1		;YES, TRY XFER ANYHOW
	DPB 3,ERRCPT
	MOVSI 3,DSKRCB		;SEEK INCOMPLETE, TRY RECAL
	IORM 3,DSKSTS(1)
	CALL DSKRCL
	JRST DSKSV5

DSKUER:	MOVSI 3,DSKSIP+DSKCMR
	ANDCAM 3,DSKSTS(1)
	TLZA 0,400000		;RETURN ERROR BITS (B0 SHOULD BE OFF)
DSKSVU:	SETZ 0,			;0 MEANS NO ERRORS
	LDB 3,UCMIPT		; GET COMMAND INDEX
	MOVEM 0,DSKCL+1(3)	;WORD GOING POSITIVE INDICATES DONE
	AOS PSKED		;SIG SCHED
	JRST DSKSV2

;DISK ERROR

	INTERN DSKERR

DSKERR:	XCT DCLERR		;CLEAR ALL ERROR CONDITIONS
	MOVE 3,DSKDAW(1)	;SAVE ERROR WORDS
	MOVEM 3,DSKRER
	MOVE 3,DSKCAW(1)
	MOVEM 3,DSKRER+1
	MOVE 3,DSKSTS(1)
	MOVEM 3,DSKRER+2
	MOVEM 0,DSKRER+3	;AND ERROR BITS
	AOS DSKRCE		;COUNT REC ERRORS
	LDB 3,ERRCPT		;RETRY COUNT
	ADDI 3,1
	DPB 3,ERRCPT
	CAILE 3,DSKNTR		;UNRECOVERABLE?
	JRST DSKERP		;YES
DSKER2:	XCT DSZSCF		;SKIP NO SEARCH FAILURE
	JRST DSKER3		;SEARCH FAILED, TRY RECALIBRATE
	CALL DSKSVX		;START XFER OVER AGAIN
	JRST DSKSV1		;DEBREAK

DSKER3:	MOVSI 3,DSKCMR+DSKRCB	;SET STATE TO RECAL IN PROGRESS
	XORM 3,DSKSTS(1)
	CALL DSKRCL		;INITIATE RECAL
	JRST DSKSV2		;CONTINUE PROCESSING INTERRUPTS

;UNRECOVERABLE ERROR

DSKERP:	XCT DSZPCI		;SKIP NO PCI ERROR
	JRST [	MOVE 3,[SIXBIT /DSKPAK/]
		MOVEM 3,DEVMPE	;YES, REQUEST CORE SCAN
		ISB APRCHN
		JRST DSKER2]	;TRY AGAIN
	SETZM DSKLSV(1)		;RESET OVERDUE ALARM
	MOVNI 3,DSKNTR
	ADDM 3,DSKRCE		;REMOVE FROM RECOVERABLE COUNT
	AOS DSKNRE		;COUNT IRRECOVERABLE
	MOVE 3,[XWD DSKRER,DSKLER]
	BLT 3,DSKLER+3		;SAVE COMMAND WORDS
	MOVSI 3,DSKUIO
	TDNE 3,DSKSTS(1)	;UTILITY OP?
	JRST DSKUER		;YES
	CALL DSKEP1		;CLEAN UP
	JRST DSKSV2

DSKEP1:	HRRZ 2,DSKCAW(1)	;'NORMAL' IRREC TYPE ERROR
	LSH 2,-^D9		;GET PAGE NUMBER
	MOVSI 3,SWPERR
	IORM 3,CST3(2)		;NOTIFY SWAPPER OF ERROR
	MOVE 3,CST2(2)		;FIND OUT WHAT PAGE IS
	TLNN 3,-1		;FROM SPT?
	JRST [	CAIL 3,NOFN	;YES, OFN?
		HLRZ 3,SPTH(3)	;NO, GET OFN
		JRST DSKXX3]
	HLRZ 3,3
DSKXX3:	CAIL 3,1		;SENSITIVE FILE? I.E. DI OR DIRECTORY?
	CAILE 3,NFDIB+3
	JRST .+2
	BUG(CHK,<DISK ERROR IN SENSITIVE PAGE>)
	MOVSI 3,DSKSIP+DSKCMR
	ANDCAM 3,DSKSTS(1)
	PUSH P,1
	MOVE 1,2		;CORE PAGE NUMBER
	JSP 4,SWPDON		;NOTIFY SWAPPER OF COMPLETION
	POP P,1
	RET

;DISK DRIVER INITIALIZATION

	INTERN DSKINI,DSKRST

DSKINI:	IFNDEF DRMCHN,<CALL DRMINI> ;INIT SWAP BIT TABLE
DSKRST:	SETOM DSKLUN
	SKIPN DISKP
	RET
	SETOM DSKBLK
	MOVEI 1,DSKCL+2*NDSKCM-2
	SETZM 0(1)		;END OF LIST
	MOVEM 1,-2(1)		;INIT UTILITY FREE LIST
	SUBI 1,2
	CAILE 1,DSKCL
	JRST .-3
	MOVEM 1,DSKFCL
	MOVEI 1,NDSKCM
	MOVEM 1,DSKCCT		;INIT UTILITY COMMAND FREE COUNT
	MOVEI 1,DSKCCM
	MOVEM 1,DSKCP		;INITIAL COMMAND WORD FOR CHANNEL
	MOVSI 1,-NDVMAX		;FOR EACH UNIT, DO:
DSKII1:	SETZM DSKQ(1)
	MOVEI 2,DSKUO(1)	;INIT UTILITY QUEUE
	MOVEM 2,DSKUI(1)
	CALL DIUNIT		;INIT UNIT
DSKII3:	AOBJN 1,DSKII1
	CONO DSK,DSKCHN		;GIVE IT IT'S PI ASSMT
	RET

;RELOAD RES MON, CALLED FROM SYSGO

PPRMPX==170		;IN PLACE OF PPRMPG FOR KI
RLRMA==3000		;RUN LOCATION OF RELOAD ROUTINE
RLRCA==36		;FIRST CORE LOCATION RESTORED

RLRMON:	MOVE 1,[XWD RLMX0,RLRMA]
	BLT 1,RLRMA+777		;MOVE RELOAD ROUTINE TO RUN LOCATION
	JRST RLMGO		;IT RELOADS AND STARTS MON

IFDEF RP02F,<		;BOOT ROUTINE FOR RP02

;RELOAD ROUTINE, RUN IN LOWER CORE. CAN BE EXTRACTED FOR PAPER TAPE, ETC.

RLMX0:	PHASE RLRMA

RLMC5:	REPEAT PPRMPX,<0>	;TABLE OF DISK ADDRESSES, SETUP AT POSTLD

MNBOOT:	SETZM 20		;CLEAR CORE NOT CLEARED BY TENDMP
	MOVSI 1,20
	HRRI 1,21
	BLT 1,777
	MOVEI 7,100		;SETUP RETURN TO DDT WHEN LOADED
RLMGO:	MOVSI 10,-PPRMPX+1
	MOVEI 11,RLRCA		;FIRST CORE LOC TO LOAD INTO
RLMG2:	CAIGE 11,RLRMA+1000
	CAIGE 11,RLRMA
	CAIA
	ADDI 11,1000		;SKIP OVER THIS CODE WHEN READING
	MOVE 1,RLMC5(10)	;DISK ADDRESS
	LSH 1,^D12
	TLO 1,(4B2)
	DATAO DSK,1		;POSITION HEADS
	ROTC 2,^D72		;DELAY SEEMS NECESSARY HERE
RLMG1:	DATAI DSK,2
	TLNN 2,(1B11)		;ERROR?
	TLNN 2,(1B13)		;OR NOT ON LINE?
	JRST 4,RLMGO		;YES
	TLNN 2,(1B12)		;ON CYL?
	JRST RLMG1		;NO, WAIT
	CONO DSK,1B32		;CLEAR DONE
	MOVEI 2,-1(11)		;CONSTRUCT CHANNEL COMMAND
	HRLI 2,-1000		;TRANSFER ONE PAGE
	MOVEM 2,RLMNB
	SETZM RLMNB+1		;ONE WORD CHAN PGM
	MOVEI 2,RLMNB
	MOVEM 2,DSKCP		;INITIAL CHANNEL LOC
	TLZ 1,(7B2)		;READ COMMAND = 0
	IORI 1,DSKCP		;CONSTRUCT READ COMMAND
	DATAO DSK,1		;ISSUE READ
	CONSO DSK,1B31		;WAIT TILL BUSY OFF AND DONE ON
	CONSO DSK,1B32
	JRST .-2
	ANDCMI 11,777		;BUMP TO NEXT PAGE
	ADDI 11,1000
	AOBJN 10,RLMG2
	AOS GETSMF
	JRST 0(7)		;RETURN

RLMNB:	REPEAT 2,<0>

	DEPHASE
RLRMX1:
>			;END RP02F

IFDEF DC10F,<		;BOOT ROUTINE FOR DC10

;RELOAD ROUTINE, RUN IN LOWER CORE. CAN BE EXTRACTED FOR PAPER TAPE, ETC.

DCBSY==1B20		;DC10 BUSY FLAG

RLMX0:	PHASE RLRMA

RLMC5:	REPEAT PPRMPX,<0>	;TABLE OF DISK ADDRESSES, SETUP AT POSTLD

MNBOOT:	SETZM 20	;CLEAR CORE NOT CLEARED BY TENDMP
	MOVSI 1,20
	HRRI 1,21
	BLT 1,777
	MOVEI 7,100	;SET UP RETURN TO DDT

RLMGO:	MOVEI 11,RLMNB	;SET UP DF10 CMD POINTER
	MOVEM 11,DSKCP
	MOVSI 10,-PPRMPX+1
	MOVEI 11,RLRCA		;FIRST CORE LOC TO LOAD INTO
RLMG2:	CAIGE 11,RLRMA+1000
	CAIGE 11,RLRMA
	CAIA
	ADDI 11,1000		;SKIP OVER THIS CODE WHEN READING
	MOVE 1,RLMC5(10)	;DISK ADDRESS
	HLRZ 2,1	;FORM REAL HARWARE DISK ADR
	ADDI 2,1	;UNIT IN 2 +1 (CONTROLLER IS 0)
	HRRZS 1
	LSH 1,^D35-ADRPOS
	LSH 2,^D9
	IOR 1,DSKRDA	; MAKE READ COMMAND
	IORI 1,(2)	;COMPLETE HARDWARE ADR
	JSR RWDSK	;CORE ADR IN 11, DISK DATAO IN 1
	ANDCMI 11,777		;BUMP TO NEXT PAGE
	ADDI 11,1000
	AOBJN 10,RLMG2
	AOS GETSMF
	JRST 0(7)	;RETURN

;STAND ALONE DISK DRIVER FOR RELOADING MONITOR OFF DISK, AND FOR 
;WRITING CRASH COPY OF MONITOR TO CRASH AREA OF DISK.  AC2,3 SCRATCH
;	1=DATAO WORD FOR DISK
;	11=CORE ADDRESS
;	JSR RWDSK

RWDSK:	0
	MOVEI 2,0(11)
	ANDI 2,777
	SUBI 2,1000	;-WDCNT FOR PARTIAL OR COMPLETE PAGE
	HRLI 2,-1(11)	;XWD ADR-1, -WDCNT	(BACKWARDS IOWD)
	MOVSM 2,RLMNB	;IOWD TO CHANNEL CMD LOCATION
RWDSK3:	MOVEI 3,DSKNTR	;NO. OF RETRIES IF ERROR
RWDSK1:	MOVE 2,1	;DISK CMD WORD
	ANDI 2,17000	;JUST GET UNIT
	CONO DSK,DSKCHN(2)	;SELECT THE UNIT
	CONI DSK,2	;AND READ ITS STATUS
	TLNE 2,(1B12+1B14+1B15)	;OFF LINE, UNSAFE, OR WRITE PROTECTED?
	HALT RWDSK1	;YES, HALT. CLEAR HALT TO TRY AGAIN
	DATAO DSK,1	;START XFER
	CONSZ DSK,DCBSY	;WAIT FOR CONTROLLER BUSY STATE TO RESET
	JRST .-1
	CONSO DSK,640000	;ERRORS?
	JRST @RWDSK	;NO, JUST RETURN
	SOJG 3,RWDSK1	;YES, TRY AGAIN
	HALT RWDSK3	;HARD ERROR, CLEAR HALT TO RETRY

RLMNB:	REPEAT 2,<0>

	DEPHASE
RLRMX1:
>			;END DC10F

RLRMSZ==400	;MINIMUM SIZE BECAUSE TENDMP CAN'T LOAD 1 BLOCK FILES
	IFG <RLRMX1-RLMX0-RLRMSZ>,<RLRMSZ==RLRMX1-RLMX0>
	IFG <RLRMSZ-1000>,<PRINTX <RELOAD MONITOR ROUTINE EXCEEDS 1 PAGE - CODE WON'T WORK>>

;CONVERT LINEAR ADDRESS TO HARDWARE DISK ADDRESS

CVDSK:	TLZ 1,DSKMSK		;FLUSH EXTRA BITS
	IDIVI 1,NSECTK		;GET TRACK, SECTORS
	PUSH P,2
	IDIVI 1,NTKUN		;GIVES DRIVE NO IN 1, TRACK IN 2
	LSH 2,^D18-NCYLBT	;TRACK TO BITS 18-XX
	TLZE 2,1		;TEST EXTRA BIT FOR RP03
	TRO 2,1B31
	HRL 2,DRIVTB(1)		;PHYS. DRIV NO FOR TRK GROUP TO B15-17
	POP P,1
	PUSH P,2
	IDIVI 1,NSECS		;GET SURFACE, SECTOR
	LSH 1,NSECBT		;SURFACE TO B26-30
	IORI 1,0(2)		;WITH SECTOR IN B31-35
	POP P,2			;RECOVER DRIVE AND TRACK
	IOR 1,2			;MERGE ALL FIELDS
	RET

;CONVERT HARDWARE FORMAT TO LINEAR ADDRESS

CDSKVA:	HLRZ 2,1		;15-17 IS DRIVE
	ANDI 2,7
	HLRZ 3,DRIVTB(2)	;GET CORRESPONDING TRACK GROUP NO
	IMULI 3,NTKUN		;FIRST OF THIS GROUP OF TRACKS
	LDB 2,[POINT NCYLBT,1,17+NCYLBT]	;18-25 IS TRACK ON SPECIFIED DRIVE
	TRZE 1,1B31		;TEST EXTRA RP03 BIT
	TRO 2,1B27
	ADDI 3,0(2)		;NOW HAVE ACTUAL TRACK NUMBER
	IMULI 3,NSECTK		;COMPUTE SECTOR NUMBER
	LDB 2,[POINT 5,1,35-NSECBT]	;26-30 IS SURFACE
	IMULI 2,NSECS		;FIRST SECTOR THIS SURFACE
	ANDI 1,<1_NSECBT>-1	;31-35 IS SECTOR
	ADDI 1,0(2)		;TOTAL SECTORS
	ADD 1,3
	RET

; TABLE OF HOME BLOCKS (TEMPORARY UNTIL MOUNTABLE PACKS ARE DONE)

QQ==0
HOME:	REPEAT NPACKS,<
	<QQ>B17+<HOMCY1>B<^D17+NCYLBT>+<HOMSF1>B<^D17+NCYLBT+5>+HOMSC1
	<QQ>B17+<HOMCY2>B<^D17+NCYLBT>+<HOMSF2>B<^D17+NCYLBT+5>+HOMSC2
QQ==QQ+1
>
NHOME==.-HOME

;TABLE FOR CONVERSION BETWEEN PHYSICAL DRIVE NUMBERS AND INTERNAL
;TRACK GROUPS NUMBERS.  INDEXED BY INTERNAL, RH GIVES PHYSICAL.
;INDEXED BY PHYSICAL, LH GIVES INTERNAL

DRIVTB:	XWD 0,0
	XWD 1,1
	XWD 2,2
	XWD 3,3
	XWD 4,4
	XWD 5,5
	XWD 6,6
	XWD 7,7

	END


