    TITLE  BRTP -- BASIC RUN TIME PACKAGE--MAIN ROUTINES
    SUBTTL ASSEMBLY CONTROL
    SEARCH STENEX,BRSYMS,BGBL
;
;
    ENTER INIT.,FLPTR.,TYPAS.,STCPY.,STLN.,INTST.
    ENTER BLOC.,BSLOC.,SALOC.,DLOC.,XDLOC.
    ENTER SDLOC.,STKEX.,RBGSP.,CLFLS.,CLOSE.,OPNFL.,OPNER.
    ENTER OTCHR.,OTSTL.,RNSET.,RSSET.,XINIT.,SRBGS.,SETTY.
;
    INTER BYPWD.,NWDTL.,EOFFG.,CNTOF.,NSCFL.
    INTER INRST.,PATCH.,NUM..,STTIM.
    INTER CRTTY.,TMPTL.,TMPBF.,TMPCT.,RGSV.,INAMP.
;
    INTER E.FLER,E.FTYP,E.FLNO,E.FNOP,E.EOF,E.STL,E.SYS
    INTER E.OTCR,E.FLR1,E.OFLO,E.UFLO
;
;
    EXTERNAL STOP.,FSET.
;
;
;
;
    PAGE
    SUBTTL MACRO DEFINITIONS
;
;
;
DEFINE CLEAN (LC,LN)
<
	SETZM  LC
	MOVE   R1,[XWD LC,LC+1]
	BLT	R1,LC+LN-1
>
;
;
;
DEFINE SREG (RGSV)
<
	MOVEM  R17,RGSV+R17
	MOVEI  R17,RGSV
	BLT	R17,RGSV+R17-1
	MOVE R17,RGSV+R17
>
;
;
;
DEFINE LREG (RGSV)
<
	HRLZI  R17,RGSV
	BLT	R17,R17
>
;
    PAGE
    SUBTTL INTERRUPT ROUTINES--INTSET
;
;   INTSET--THIS ROUTINE TURNS ON THE INTERRUPT SYSTEM.
;
;
 INTST.:Z
    CIS			;CLEAR INTERRUPT SYSTEM
    MOVEI  R1,400000   ;CURRENT FORK
    EIR                ;ENABLE
    MOVE   R2,[XWD LEVTAB,CHNTAB] ;TABLE PTRS
    SIR                ;SET UP
    MOVE   R2,[742747500000] ;CHANNEL SELECT
    AIC                ;ACTIVATE
    MOVE R1,[XWD 2,0]	;^B ON CHN 0
    ATI
    MOVE R1,[XWD 27,2]	;^W ON CHN 2
    ATI
    MOVE R1,[XWD 17,1]	;^O ON CHN 1
    ATI
    MOVEI R1,400000
    MOVE R2,[100004010000] ;^B,^W,^O
    STIW		;ALLOW THESE INTERRUPTS
    JRA T,0(T)		;AND RETURN
;
    PAGE
    SUBTTL INTERRUPT ROUTINES--TABLES
;
;   LEVTAB--TABLE OF PC SAVES
;
 LEVTAB:
    XWD    0,INTPC1   ;LEVEL 1
    XWD    0,INTPC2   ;LEVEL 2
    XWD    0,INTPC3   ;LEVEL 3
;
;
;   CHNTAB--TRANSFER VECTOR FOR PROCESSING
;
 CHNTAB:
    XWD    2,F.CNTB           ;CHARACTERS
    XWD    2,F.CNTO
    XWD    2,F.CNTW
    XWD    0
    XWD    0
    XWD    0
;
    XWD    1,F.OFLO    ;APR OVERFLOW
    XWD    1,F.OFLO    ;FLOATING OVERFLOW
;
    XWD    0
;
    XWD    1,F.PDLO    ;PDL OVERFLOW
    XWD    1,F.EOFR    ;END OF FILE
    XWD    1,F.DTER    ;FILE DATA ERROR
    XWD    1,F.FLER    ;MISC FILE ERROR
;
    XWD    0
    XWD    0           ;TIME OF DAY
;
    XWD    1,F.INST    ;ILLEGAL INSTRUCTION
    XWD    1,F.ABT     ;ILLEGAL MEMORY READ
    XWD    1,F.ABT     ;ILLEGAL MEMORY WRITE
    XWD    1,F.ABT     ;ILLEGAL MEMORY EXECUTE
    XWD    0           ;FORK TERMINATION
    XWD    1,F.ABT     ;MACHINE SIZE EXCEEDED
    XWD    0           ;TRAP TO USER
    XWD    0           ;NON-EXISTANT PAGE
;
    XWD    0
;
    XWD    0           ;CHARACTERS
    XWD    0
    XWD    0
    XWD    0
    XWD    0
    XWD    0
;
    PAGE
    SUBTTL INTERRUPT ROUTINES--PDL OVERFLOW
;
;   F.PDLO--HANDLE PDL OVERFLOW.  IF IT IS THE GOSUB PDL, THEN GIVE IT
;      MORE SPACE AND CONTINUE, ELSE FATAL ERROR.
;
;
 F.PDLO:
    SREG   FLTRG       ;SAVE REGS
    MOVE R1,INTPC1	;GET PC OF FAULT
    MOVE R1,-1(R1)	;GET INST OF FAULT
    LSH    R1,-22-4-1  ;GET REG
    ANDI   R1,17
    CAIE   R1,P        ;CHECK IF RIGHT ONE
    JRST F.ABT ;IF NOT, ABORT
    MOVEI R7,E.OTCR ;PTR TO ERROR
    JRST FERROR ;AND PROCESS
;
    PAGE
    SUBTTL INTERRUPT ROUTINES--EOFR,DTER,FLER,ABT
;
;   THESE SHORT ROUTINES CAUSE THE APPROPRIATE MESSAGE TO BE PRINTED
;      ON TERMINAL INTERRUPTS.  AFTERWARDS EXECUTION IS DELETED.
;
;
 F.EOFR:
    AOSN EOFFG. ;IGNORE IF FLAG SAYS OK TO IGNORE--SET FLAG
    DEBRK ;RETURN IF IGNORING IT
    SREG FLTRG	;SAVE REGS
    MOVEI R7,E.EOF       ;ILLEGAL END OF FILE
    JRST FERROR ;AND GIVE MESSAGE
;
 F.DTER:
    SREG FLTRG	;SAVE REGS
    MOVEI R7,E.FLER      ;FILE DATA ERROR
    JRST FERROR ;AND GIVE MESSAGE
;
 F.FLER:
    SREG FLTRG	;SAVE REGS
    MOVEI R7,E.FLER      ;FILE ERROR OF SOME SORT
    JRST FERROR ;AND GIVE MESSAGE
;
 F.ABT:
    SREG FLTRG	;SAVE REGS
    MOVEI R7,E.SYS       ;ABORT CONDITION
    JRST FERROR ;AND GIVE MESSAGE
;
    PAGE
    SUBTTL INTERRUPT ROUTINES--OVERFLOW
;
;   F.OFLO--THIS ROUTINE HANDLE OVERFLOW/UNDERFLOW BY PRINTING THE
;      APPROPRIATE MESSAGE AND RET8URNING EITHER INFINITY OR 0
;      AS APPROPRIATE.
;
;
 F.OFLO:
    SREG   FLTRG       ;SAVE REGS
    MOVE R1,INTPC1 ;GET PC AND FLAGS
    TLNE R1,000040 ;CHECK FOR DIVISION BY ZERO
      JRST OFLO2 ;HANDLE
    TLNE R1,000100 ;CHECK FOR UNDERFLOW
      JRST OFLO1 ;HANDLE
    TLNE R1,040000 ;CHECK FOR FIXED POINT
    JRST OFLO8 ;IGNORE IF SO
;
    MOVEI R7,E.OFLO ;MESSAGE PTR FOR OVERFLOW
    JSR ERROR ;PRINT MESSAGE
    MOVE R0,[377777777777] ;RESULT=+INF
    JRST   OFLO9
;
 OFLO1:
    MOVEI R7,E.UFLO ;MESSAGE PTR
    JSR ERROR ;PRINT MESSAGE
    MOVEI R0,0 ;RETURN ZERO
    JRST OFLO9 ;AND SKIP
;
 OFLO2:
    MOVEI R7,E.DVBZ ;GET DIVISION BY ZERO MESSAGE
    JSR ERROR ;PRINT IT
    MOVE R0,[377777777777] ;PLUS INFINITY FOR RESULT
;
;
 OFLO9:
    MOVE R1,INTPC1 ;GET FAULT ADDRESS
    HLRZ R1,-1(R1) ;GET OP OF OFFENDER
    LSH    R1,-5       ;GET REG
    ANDI   R1,17       ;ONLY
    MOVEM  R0,FLTRG(R1) ;SAVE RESULT
;
 OFLO8:
    JFCL 17,.+1 ;CLEAR FLAGS
    LREG   FLTRG       ;RESTORE REGS
    DEBRK              ;AND RETURN
;
    PAGE
    SUBTTL INTERRUPT ROUTINES--ILLEGAL INSTRUCTION
;
;   F.INST--THIS ROUTINE HANDLES AN ILLEGAL INSTRUCTION.  IT CHECKS FOR
;      AN ERROR MESSAGE REQUEST '001', AND IF NOT ABORTS, AND IF SO,
;      CALLS THE ERROR MESSAGE ROUTINE.
;
;
 F.INST:
    SREG   FLTRG       ;SAVE REGS
    MOVE   R1,INTPC1  ;GET INSTRUCTION
    MOVE R1,-1(R1) ;GET ACTUAL INST
    LSH    R1,-33      ;ADJUST TO SEE ONLY OP
    CAIN R1,104	;CHECK FOR JSYS ERROR
    JRST F.JSYS ;HANDLE IF SO
    CAIG R1,4 ;CHECK IF USED UUO
    JRST .+1(R1) ;IF SO, BRANCH TO HANDLE
    JRST F.ABT ;0--ILLEGAL (ALSO >4)
      JRST F.INS1 ;1--ERROR MESSAGE REQUEST
      JRST F.INS2 ;2--ON ERROR
      JRST F.INS3 ;3--SUBSCRIPT ERROR
    JRST F.INS4 ;4--FCT ERROR
;
;
 F.INS1:
    MOVE R7,INTPC1 ;GET PTR TO FAULT
    HRRZ R7,-1(R7) ;GET MESSAGE PTR
    JSR ERROR ;PRINT ERROR MESSAGE
;
 FINRT:
    LREG FLTRG ;RESTORE REGS
    DEBRK ;AND RETURN
;
;
 F.INS2:
  MOVEI R7,E.ONER ;HANDLE ON ERROR
    JRST FERROR ;PRINT MESSAGE
;
;
 F.INS3:
  JSP R1,ERNAM ;GET NAME OF VAR FROM MESSAGE
  MOVEM R2,ERBUF ;SAVE IN COMMON BUFFER
  MOVE R1,INTPC1	;FAULT LOC+1
  MOVE R1,-1(R1)	;FAULT INST
  LSH R1,-22-4-1		;GET REG
  ANDI R1,17		;MASK REG
  MOVE R1,FLTRG(R1)	;GET OLD VALUE
  MOVEM R1,ERBUF+1	;SAVE VALUE
  MOVEI R7,E.SBSC ;HANDLE SUBSCRIPT ERROR
    JRST FERROR ;PRINT MESSAGE
;
;
 F.INS4:
  JSP R1,ERNAM ;GET FCT NAME
  LSH R2,-16 ;MAKE ROOM FOR 'FN'
  TLO R2,432340 ;AND ADD 'FN'
  MOVEM R2,ERBUF ;SAVE RESULT
  MOVEI R7,E.GBFC ;ERROR MESSAGE
    JRST FERROR ;PRINT GLOBAL FCT MESSAGE
;
;
 F.JSYS:
  MOVE R1,FLTRG+R1 ;GET R1
  CAIN R1,CFDBX2 ;CHECK FOR CHFDB FAULT
    JRST FINRT ;IGNORE IF SO
;
  JRST F.ABT ;OTHERS ARE FATAL
;
;
PAGE
SUBTTL INTERRUPT ROUTINES--CONTROL CHARACTER HANDLING
;
;
;   ^B--ENTER DEBUGGER IF POSSIBLE
;
F.CNTB:
  SETOM SKPCT.		;SET FLAG TO ENTER DEBUGGER
  DEBRK ;AND RETURN
;
;
;   ^W--TELL USER WHERE WE ARE
;
F.CNTW:
  ERR E.WHR ;PRINT DUMMY ERROR MESSAGE
  DEBRK ;AND RETURN
;
 E.WHR: EXP EB.TRC!EB.CRA!EB.RET ;NO MESSAGE, BUT TRACE CALLS
;
;
;   ^O--TURN OFF TTY OUTPUT
;
F.CNTO:
  AOSE CNTOF.		;SET FLAG TO SHUT OFF OUTPUT
  SETOM CNTOF.		;ACT AS FLIP FLOP
  SKIPN CNTOF.		;CHECK IF SETTING FLAG
    DEBRK		;IF NOT, THEN JUST DEBREAK
  MOVEM R1,CNTORG	;IF SO, SAVE R1
  MOVEI R1,101		;PRIMARY OUTPUT JFN
  CFOBF			;DO IMMEDIATE OUTPUT STOP
  MOVE R1,CNTORG	;RESTORE R1
  DEBRK			;AND RETURN
;
;
PAGE
    SUBTTL ERROR MESSAGE ROUTINES--ERROR
;
;   ERROR--THIS ROUTINE IS CALLED WHEN A REQUEST TO PRINT AN ERROR
;      MESSAGE HAS BEEN RECIEVED.  THE REQUEST IS IN @INTPC1 WITH
;      THE BITS WORD AND THE MESSAGE TEXT, IF ANY, FOLLOWS IN THE NEXT
;      WORD.
;
;
 ERROR:Z
 FERROR:
;
    MOVE   R0,0(R7)    ;GET BITS OF ERROR MESSAGE
  SETZM CNTOF.		;ALLOW OUTPUT
  MOVEI R1,101		;TTY OUTPUT JFN
  DOBE			;WAIT FOR OUTPUT TO CEASE
  MOVEI R1,100		;TTY INPUT JFN
  TRNN R0,EB.RET	;CHECK FOR WARNING--SKIP IF SO
  CFIBF			;DELETE TYPE AHEAD
;
    TRNN   R0,EB.CRB   ;EOL BEFORE MESSAGE
    JRST   ERR1        ;NO--SKIP
    MOVEI  R1,ASCEOL   ;YES--GET CHAR
    PBOUT              ;PRINT IT
;
 ERR1:
    TRNN   R0,EB.MES   ;MMESSAGE TEXT
    JRST   ERR1A       ;NONE
    HRROI  R1,1(R7)    ;GET START TALLY TO IT
    PSOUT              ;PRINT
;
 ERR1A:
  TRNN R0,EB.BUF ;CHECK FOR PRINTING BUFFER
    JRST ERR1B ;NO--SKIP
  HRROI R1,[ASCIZ / for '/] ;PREFIX
  PSOUT ;PRINT
  HRROI R1,ERBUF ;BUFFER
  PSOUT ;PRINT IT
  MOVEI R1,"'" ;TAIL
  PBOUT ;PRINT IT
;
 ERR1B:
  TRNN R0,EB.BFN	;CHECK FOR NUMBER IN ERBUF+1
    JRST ERR2		;NO--SKIP
  HRROI R1,[ASCIZ / with /] ;LEAD IN
  PSOUT
  MOVEI R1,101		;TO TTY
  MOVE R2,ERBUF+1	;GET NUMBER
  MOVEI R3,12		;IN DECIMAL (GOD FORBID)
  NOUT			;PRINT NUMBER
    BLOWUP
;
 ERR2:
    TRNN   R0,EB.FIL   ;FILE NAME TO BE PRINTED???
    JRST   ERR3        ;NO--SKIP
    HRROI  R1,[ASCIZ / for file /] ;LEAD IN MESSAGE
    PSOUT              ;PRINT
    CAIN FL,CRTTY. ;CHECK FOR TTY CURRENT
    JRST ERR2A ;HANDLE IF SO
    MOVEI  R1,101      ;TO TTY
    HRRZ   R2,F.JFN(FL) ;GET JFN
    JUMPE R2,ERR2B	;HANDLE IF NO JFN FOR FILE
    MOVEI  R3,0        ;FREE FORMAT
    JFNS               ;PRINT FILE NAM
    JRST ERR3 ;AND CONTINUE
;
 ERR2B:
  SKIPN R1,F.WLN(FL)	;GET TALLY IF PRESENT
    HRROI R1,[ASCIZ /???/]	;ELSE DUMMY TALLY
  SKIPA			;AND SKIP
;
 ERR2A:
    HRROI R1,[ASCIZ /TTY:/] ;DEVICE NAME ONLY FOR TTY
    PSOUT ;PRINT IN PLACE OF JFNS
;
 ERR3:
    TRNN   R0,EB.LIN+EB.TRC   ;LIN+EB.TRCE NUMBER???
    JRST   ERR4        ;NO
    HRROI  R1,[ASCIZ / in/] ;YES--PREFIX MESSAGE
    TRNN R0,EB.MES		;DOES MESSAGE PRECED
    HRROI R1,[ASCIZ /In/]	;no--alternative leader
    HLRE R2,FLTRG+L ;GET LINE NUMBER
    MOVE R4,PGDAT.(V) ;GET CURRENT RGM DATA PTR
    JSA T,ERLIN ;PRINT LINE NUMBER AND NAME
;
 ERR4:
    TRNN   R0,EB.CRA   ;EOL AFTER MESSAGE
    JRST   ERR5        ;NO
    MOVEI  R1,ASCEOL   ;YES--GET CHR
    PBOUT              ;PRINT
;
 ERR5:
    TRNN   R0,EB.EFL!EB.ER1!EB.ER2!EB.ERR
    JRST   ERR6        ;NO SYSTEM MESSAGE TO BE PRINTED
    TRNE   R0,EB.EFL   ;CHECK FOR FILE MESSAGE
    MOVE   R2,F.FLER(FL) ;IF SO, GET FROM FIB
    TRNE   R0,EB.ER1   ;CHECK FOR R1
    MOVE   R2,FLTRG+1  ;GET IF SO
    TRNE   R0,EB.ER2   ;CHECK FOR R2
    MOVE   R2,FLTRG+R2 ;GET IF SO
    TRNE   R0,EB.ERR   ;CHECK FOR MOST RECENT ERROR
    MOVNI  R2,1        ;INDICATE
    MOVEI  R1,101      ;TO TTY
    HRLI   R2,400000   ;CURRENT FORK
    MOVEI  R3,0        ;FREE FORMAT
    ERSTR              ;PRINT MESSAGE
    NOP
    NOP
    MOVEI R1,ASCEOL ;END OF LINE
    PBOUT ;PRINT IT
;
 ERR6:
    SKIPL TESFG		;IGNORE IF TEST
    TRNN   R0,EB.TRC   ;TRACE OF CALLS WANTED???
    JRST   ERR7        ;NO
    SKIPN R6,DBGPDL	;IF DEBUGGER PDL THEN USE SAVED ONE
    MOVE   R6,FLTRG+P  ;YES--GET PDL
    SKIPA
;
 ERR6C:
    SOS    R6          ;BUMP TO PREVIOUS ENTRY
    MOVE R2,0(R6) ;GET ITEM OFF PDL
    TLZ R2,400000 ;TURN OFF FLAG BIT IF PRESENT
    CAME R2,RBGSP. ;CHECK MARKER
    JRST ERR6C ;IGNORE IF NOT
;
    SOS R6 ;PREVIOUS ITEM
    MOVE R2,0(R6) ;IS LINE NUMBER
    CAMN R2,[XWD 333333,333333] ;END MARKER?
    JRST ERR7 ;YES--DONE
    MOVE R4,PGDAT.(R2) ;GET PGDATA PTR
    HLRES R2 ;NO--ISOLATE LINE NUMBER
    HRROI R1,[ASCIZ /Called from /] ;PREFIX MESSAGE
    HLRZ R3,1(R6) ;CHECK MARKER AGAIN
    CAIN R3,400000 ;CHECK FOR SUB
    MOVE R6,-1(R6) ;IF SO, IGNORE THE JUNK ON STACK
;
    JSA T,ERLIN ;PRINT LINE NUMBER
    MOVEI R1,ASCEOL ;EOL
    PBOUT ;PRINT
    JRST ERR6C ;AND TRY NEXT
;
 ERR7:
  TRNE R0,EB.RET ;CHECK IF RETURN REQUESTED
    JRST @ERROR ;IF SO, RETURN
;
 ERR8:
  MOVE R1,INTPC1	;GET ADDRESS OF FAULT
  MOVEM R1,FLTPC	;SAVE FOR DEBUGGING
  HLRZ R1,DBGENT 	;GET DEBUGGER ENTRY
  SKIPN R1		;IF DEBUGGER EXISTS
  MOVEI R1,ERR9 ;GUESS WE WANT TO STOP
  TRNE R0,EB.RES ;CHECK FOR INPUT RESTART
    SOS R1,INRST. ;IF SO, GET ADDRESS FOR THAT
  TRNE R0,EB.ABT ;CHECK FOR ABORT
    MOVEI R1,ABORT ;IF SO, GET ADDRESS FOR THAT
  HRRZM R1,INTPC1 ;SAVE FOR FAULT RETURN
  DEBRK ;RETURN FROM FAULT IF IN ONE
  JRST 0(R1) ;JUST IN CASE, DO TRANSFER OURSELVES
;
 ERR9:
    JSA    T,STOP.   ;STOP EXECUTION
    JRST .-1		;DO NOT ALLOW RESTART
;
    PAGE
SUBTTL ERROR MESSAGE ROUTINES--ERLIN
;
;   ERLIN--THIS ROUTINE IS ENTERED WITH A STRING POINTER IN R1
;      AND A LINE NUMBER IN R2 AS WELL AS THE PROGRAM DATA
;      POINTER IN R4.  IT PRINTS FIRST THE STRING, THEN THE
;      LINE NUMBER AND FINALLY 'IN SUB' FOLLOWED BY THE SUB
;      NAME IF IT IS IN A SUB.
;
;
ERLIN: Z
;
  SKIPGE R2 ;MAKE SURE LINE NUMBER IS VALID
    JRA T,0(T) ;DON'T PRINT IF NOT
  PSOUT ;PRINT THE STRING
  MOVEI R1,ASCSPA ;SAPCE AFTERWARDS
  PBOUT ;SAVE
  MOVEI R1,101 ;JFN FOR TTY
  MOVEI R3,12 ;FREE FORMAT
  NOUT ;PRINT THE NUMBER
    TRN ;IGNORE ERROR RETURN
;
  SKIPL TESFG		;NO SUB NAMES IN TEST MODE
  SKIPN PGNAME(R4) ;CHECK FOR MAIN PROGRAM
    JRA T,0(T) ;RETURN IF SO
  HRROI R1,[ASCIZ / in sub  /] ;LEADER FOR SUB NAME
  PSOUT ;PINT
  HRROI R1,PGNAME(R4) ;STRING PTR TO NAME
  PSOUT ;PRINT IT
  JRA T,0(T) ;NOW RETURN
;
;
    PAGE
SUBTTL ERROR MESSAGE ROUTINES--ERNAM
;
;   ERNAM--THIS ROUTINE TAKES THE ERROR PRODUCING INSTRUCTION
;      AND LOOKS AT THE LOWER HALF TO CREATE A ONE OR TWO CHR
;      NAME (A...Z OR A$...Z$), WHICH IS RETURNED IN R2.
;
;
ERNAM:
;
  MOVE R2,INTPC1 ;GET LOC OF FAULT
  HRRZ R2,-1(R2) ;GET LOWER HALF OF OFFENDER
  CAIL R2,32 ;CHECK FOR STR
    JRST ERNAM1 ;HANDLE STRING
  MOVEI R2,"A"(R2) ;CONVERT TO LETTER
  LSH R2,44-7 ;POSITION
  JRST 0(R1) ;AND RETURN
;
 ERNAM1:
  MOVEI R2,"A"-32(R2) ;CONVERT TO LETTER
  LSH R2,44-7 ;POSITION
  TLO R2,001100 ;ADD '$' AS SECOND CHR
  JRST 0(R1) ;AND RETURN
;
;
PAGE
SUBTTL ERROR ROUTINES--ABORT
;
;   ABORT--THIS ROUTINE IS CALLED WITH A JSR WHEN SOMETHING
;      SERIOUS HAPPENS.  ITS JOB IS TO INFORM THE USER AND
;      POSSIBLY TO SAVE ENOUGH INFO AROUND FOR FUTURE 
;      DEBUGGING OF THE RUN> (IE A DUMP).
;
;
 ABORT: NOP
;
  SREG ABTRG ;SAVE ABORT REGS
  HALTF ;AND IF WE HEVER GET HERE__HELP
  JRST .-1		;NO RESTART AFTER ABORT
;
;
    PAGE
    SUBTTL INITIALIZATION ROUTINES--INIT
;
;   INIT--THIS IS THE ROUTINE WHICH IS CALLED IMMEDIATELY ON ENTRY TO
;      A BASIC MAIN PROGRAM.  IT SETS UP STORAGE, THE FCB FOR THE TTY,
;      THE DATA POINTERS, ETC.
;
;
 INIT.:Z
    MOVEM R1,RGSV. ;SAVE PTR TO PRG DATA
    RESET              ;RESET EVERYTHING WE CAN
    MOVEI R1,400000 ;CURRENT FORK
    RUNTM ;GET START RUN TIME
    MOVEM R1,STTIM. ;SAVE IT
    MOVE R1,RTVSYM	;GET SAVED SYMBOL TABLE
    MOVEM R1,JOBSYM	;SAVE FOR DEBUGGING RTP
;
    SETZM DBGPDL	;NOT IN DEBUGGER
    SETZM NSCFL.	;START WITH FIRST SCRATCH FILE
    MOVE   R1,JOBFF    ;ELSE USE OTHER GIVEN TOP
    ADDI   R1,777     ;ROUND UP
    ANDI   R1,-1000    ;TO K MULTIPLE
    MOVEM R1,PDLBS ;SAVE AS BASE OF PDL
    MOVEI  R1,377777   ;ABSOULTE TOP***
    MOVEM R1,JOBREL	;SAVE TOP
    MOVEM  R1,ABTOP    ;SAVE
    ADDI R1,1 ;GET ACTUAL TOP
    MOVEM R1,CRTOP ;SAVE
;
  MOVE R1,PDLBS ;GET TOP
  LSH R1,-11 ;PAGE NUMBER
  HRLI R1,400000 ;CURRENT FORK
  MOVE R0,JOBREL ;ABS TOP
  LSH R0,-11 ;GET AS PAGE NUMBER
;
 INIT4:
  RPACS ;STATUS OF NEXT PAGE
  TLNN R2,010000 ;DOES IT EXIST
    JRST INIT3 ;NO--SKIP
  MOVE R2,R1 ;YES--WE DON'T WANT IT
  MOVNI R1,1 ;SO DELETE IT
  PMAP ;BY MAPPING IT OUT OF EXISTANCE
  MOVE R1,R2 ;RESTORE PAGE PTR
;
 INIT3:
  AOS R1 ;NEXT PAGE
  HRRZ R2,R1 ;CHECK NUMBER
  CAMG R2,R0 ;FOR DONE
    JRST INIT4 ;LOOP IF MORE TO LOOK AT
;
    CLEAN  ALCTB,ALTBL ;NOTHING ALLOCATED
;
  MOVE R1,[XWD CRTTYD,CRTTY.]
  BLT R1,CRTTY.+FLBLN-1	;RESET TTY FILE DESCRIPTOR
;
    MOVE R1,PDLBS ;GET PDL BASE
    SUB R1,ABTOP ;DISTANCE TO ABS TOP OF CORE
    ADDI R1,2 ;MINUS MINUS 2 FOR SAFETY
    HRLS R1 ;USE AS COUNT
    HRR R1,PDLBS ;FOR PDL
    MOVEM R1,P ;SAVE AS PDL PTR
    PUSH   P,[XWD 333333,333333] ;FIRST WORD
    PUSH   P,RBGSP. ;RETURN BEFORE GOSUB ENTRY
    JSA T,INTST.	;AND TURN ON INTERRUPT SYSTEM
;
  PUSHJ P,SETTY. ;SET UP TTY
  MOVE R1,RGSV. ;GET PROGRAM DATA PTR
  HRRZ V,PGNVRP(R1) ;SET UP INITIAL V-REGISTER
  SETZM CALLV.(V)	;NO ONE CALLED US
  JSA T,XINIT. ;ROUTINE INIT.
;
  MOVEI R1,ASCEOL ;END OF LIEN (INDICATE RT)
  PBOUT ;PRINT
  SETZM CNTOF.		;ALLOW TTY OUTPUT
  PUSHJ P,CHENT		;CHECK FOR CHAIN ENTRY
;
    JRA    T,0(T)      ;AND RETURN INITIALIZED
;
    PAGE
SUBTTL INITIALIZATION ROUTINES--XINIT
;
;   XINIT--THIS ROUTINE DOES THE BASIC INITIALIZATIONS NEEDED 
;      BY BOTH THE MAIN PROGRAM AND ANY SUBS.  IT WORKS PRIMARILY
;      WITH THE PROGRAM DATA AREA, SETTING UP THE FILE PTR, THE
;      DATA POINTERS, AND THE VARIABLE AREAS.
;
;
XINIT.: Z
;
  MOVE R2,R1 ;GET THE PRGM DATA PTR
  MOVEM R2,PGDAT.(V) ;SAVE PROGRAM DATA PTR
  HRL R1,PGNDAT(R2) ;NUMERIC DATA PTR
  HRR R1,PGSDAT(R2) ;STRING DATA PTR
  MOVEM R1,IDATP.(V) ;SAVE AS CURRENT DATA PTRS
;
  MOVE R1,PGFILS(R2) ;GET FILES PTR
    ADD R1,V ;IF NOT, RELOCATE FILE PTR
  MOVEM R1,FILTB.(V) ;SAVE FILE PTR
;
  HLRZ R1,PGNVRL(R2) ;GET LENGTH OF NUM VRS
  HLRZ R0,PGSVRL(R2) ;AND OF STR VRS
  ADDI R0,-HDRLN.(R1) ;LENGTH TO CLEAR TOTAL
  HRRZ R1,PGNVRP(R2) ;GET LOC OF PRGM VRS
  ADDI R1,HDRLN. ;START LOC IS AFTER HEADER
  SKIPE PGNAME(R2) ;CHECK IF MAIN
    ADD R1,V ;ELSE GET VAR PTR
  SETZM 0(R1) ;CLEAR FIRST ONE
  CAIN R0,1 ;CHECK IF ONLY ONE
    JRST XINIT1		;HANDLE DONE
;
  HRLI R2,0(R1) ;PTR TO FIRST
  HRRI R2,1(R1) ;POINTER TO SECOND
  ADD R1,R0 ;GET PTR TO END
  BLT R2,0(R1) ;CLEAR THE WHOLE AREA
;
 XINIT1:
  MOVEI R0,CRTTY.	;PTR TO TTY
  MOVE R1,FILTB.(V)	;PTR TO FILE TABLE
  MOVEM R0,0(R1)	;SAVE TTY AS FILE #0
;
  JRA T,0(T)		;AND RETURN
;
;
    PAGE
SUBTTL INITIALIZATION ROUTINES--SETTTY
;
;   SETTTY--THIS ROUTINE SETS UP THE VARIOUS TENEX CONTROL
;      FEATURES FOR THE TERMINAL (CCOC, MRGN, ECHO, ...)
;      CORRECT FOR THE BASIC RUN TIME ROUTINES.
;
;
SETTY.:
;
  MOVEI FL,CRTTY. ;POINTER TO BLOCK FOR TTY
  HRRZ R1,F.JFN(FL)	;GET OUTPUT JFN
  DVCHR			;CHECK FOR TTY
  TLNE R1,-1
    POPJ P,		;RETURN FAST IF NOT
;
  HRRZ R1,F.JFN(FL) ;USE OUTPUT JFN
;
  MOVEI R2,170120 ;DEFAULT MODES
  SFMOD ;SET
;
  RFMOD ;GET MODE WORD
  TLZ R2,000177 ;PAGE WIDTH TO 0 (INFINITY)
  STPAR ;SET PAGE WIDTH
;
  RFCOC ;OLD CCOC
  AND R2,[BYTE (2)3,0,0,0,0,0,0,0,0,3,0,0,3,0,0,0,0,0]
  AND R3,[BYTE (2)0,0,0,0,0,0,0,0,0,3,0,0,0,3,3,3,3,3]
  IOR R2,[BYTE (2)0,2,2,2,2,2,2,2,2,0,2,2,0,2,2,2,2,2]
  IOR R3,[BYTE (2)2,2,2,2,2,2,2,2,2,0,2,2,2,0,0,0,0,0]
  SFCOC ;SET NEW CCOC WORDS
;
  POPJ P,		;AND RETURN
;
;
    PAGE
SUBTTL RUN TIME SUBROUTINES--CHENT
;
;   CHENT--THIS ROUTINE IS CALLED FROM INITIALIZATION TO CHECK
;      IF ENTRY WAS MADE VIA CHAIN AND IF FILES WERE PASSED
;      ON THAT CHAIN.  IF SO, THEN IT SETS UP THOSE FILES FOR THE
;      MAIN PROGRAM.
;
;
CHENT:
;
  MOVSI R1,400000	;CURRENT FORK
  HRRI R1,CHNPGN	;CHAIN INFO PAGE
  RPACS			;DOES THE PAGE EXIST?
  TLNN R2,010000	;CHECK IT
    POPJ P,		;NO--JUST RETURN
;
  SKIPN CHNNFL		;CHECK IF ANY FILES PASSED
    JRST CHENT1		;NO--GET RID OF PAGE AND DONE
;
  MOVSI R1,(1.0)	;YES--STARTING NUMBER
  MOVEM R1,RGSV.+2	;SAVE IT
  MOVEM R3,RGSV.+3	;SAVE R3
  MOVEI R3,CHNFLS	;PTR TO FILE BLOCKS
;
 CHENT2:
  MOVE R2,RGSV.+2	;GET NUMBER INTO R2
  JSA T,FSET.		;GET BLOCK FOR FILE
    JUMP R2		;WHOSE NUMBER IS IN R2
  HRROI R2,6(R3)	;GET NAME PTR
  MOVSI R1,100001	;AND SHORT FORM JFN
  GTJFN			;OPEN THE FILE
    ERR E.CHER		;NO REASON NOT TO
  HRRM R1,F.JFN(FL)	;SAVE JFN
  HRLM R1,F.JFN(FL)
  MOVE R2,1(R3)		;GET BITS WORD SAVED
  TRZ R2,FB.CHN	;IGNORE CHAINING BIT
  MOVEM R2,F.BTS(FL)	;SAVE BITS FOR NEW FILE
  TRNN R2,FB.ACC	;CHECK IF IT WAS OPEN
    JRST CHENT3		;NO--SKIP
  TLZ R2,FB.OUR	;YES--TURN OFF EXTRANEOUS BITS
  OPENF			;AND OPEN IT AGAIN
    ERR E.CHER		;SHOULD BE ABLE TO
  TRNE R2,FB.AP		;CHECK IF APPENDING
    JRST CHENT3		;IF SO, THEN PTR ALREADY SET
  MOVE R2,2(R3)		;GET THE PTR
  SFPTR			;AND SET IT
    ERR E.CHER		;SHOULD BE ABLE TO
;
 CHENT3:
  HLRE R1,3(R3)		;GET TERMINATOR CHR
  MOVEM R1,F.TRM(FL)
  HRRZ R1,3(R3)		;GET LINE POSITION
  MOVEM R1,F.CPOS(FL)
  MOVE R1,4(R3)		;GET END OF FILE FLAG
  MOVEM R1,F.EOF(FL)
  MOVE R1,5(R3)		;GET LINE AND PAGE NUMBERS
  MOVEM R1,F.LNM(FL)
;
  HRRZ R3,0(R3)	;GET PTR TO NEXT FILE
  MOVSI R1,(1.0)	;DELTA FOR FILE NUMBERS
  FADM R1,RGSV.+2	;CREATE NEXT NUMBER
  JUMPN R3,CHENT2	;LOOP IF MORE FILES
  MOVE R3,RGSV.+3	;RESTORE R3 IF DONE
;
 CHENT1:
  MOVNI R1,1		;FLAG FOR DELETEING PAGE
  MOVEI R2,CHNPGN	;DONE WITH CHAIN INFO
  HRLI R2,400000	;CURRENT FORK
  PMAP			;SO DELETE IT
;
  POPJ P,		;AND THEN RETURN
;
;
    PAGE
SUBTTL RUN TIME SUBROTINES--CLFLS.
;
;   CLFLS.--THIS ROUTINE IS USED TO CLOSE ALL THE FILES
;      OF THE CURRENT SUBPROGRAM OR MAIN PROGRAM.
;
;
CLFLS.: Z
;
  MOVE R2,FILTB.(V) ;GET PTR TO TABLE OF FCB PTRS
  HLRZ R3,FILTB.(V) ;GET LENGTH OF FILE TABLE
  SKIPN R3 ;IF NOTHING THERE, IGNORE
  JRA T,0(T) ;NO--RETURN
;
 CLFLS1:
  AOS R2 ;NEXT FILE
  SKIPE FL,0(R2) ;GET FILE PTR IF FILE EXISTS
  TLNE FL,FLGBL ;CHECK FOR GLOBAL
    SKIPA ;IF NO FILE, OR GLOBAL, SKIP
  JSA T,RLEAS. ;IF GOOD FILE, RELEASE IT
  SOJG R3,CLFLS1 ;AND LOOP TILL WE GT THEM ALL
;
  JRA T,0(T) ;THEN RETURN
;
;
    PAGE
SUBTTL RUN TIME SUBROUTINES--CLOSE.
;
;   CLOSE.--THIS ROUTINE CLOSES THE FILE WHOSE FCB IS
;      IN FL ON ENTRY.  THIS INVOLVES ISSUING THE
;      CLOSF JSYS AS WELL AS DELETING TEMP FILES.
;
;
RLEAS.: Z
  MOVEI R1,1 ;FLAG TO ACTUALLY RELEASE THE FILE
  JRST CLOSE0 ;SKIP
;
;
CLOSE.: Z
  MOVEI R1,0 ;FLAG TO JUST CLOSE THE FILE
;
 CLOSE0:
  MOVEM R1,RLSFG# ;SAVE THE FLAG
  MOVE R1,F.BTS(FL) ;GET BITS WORD
  TRNN R1,FB.CHN	;CHECK IF FILE NEEDED FOR CHAIN
  TLNE R1,FB.TTY ;CHECK IF TTY
    JRA T,0(T) ;DON'T CLOSE IF SO
;
  HRRZ R1,F.JFN(FL) ;GET JFN
  JUMPE R1,CLOSE1 ;NONE--RETURN
  SKIPN RLSFG# ;CHECK IF RELEASE/CLOSE
    TLO R1,400000 ;IF CLOSE, SAVE THE JFN
;
  CLOSF ;CLOSE THE FILE
    TRN		;IGNORE FAILURE
;
  MOVEI R1,FB.ACC ;ALL ACCESS BITS
  ANDCAB R1,F.BTS(FL) ;GO AWAY AFTER CLOSE
  SETZM F.EOF(FL) ;NO LONGER AT END OF FILE
  JSA T,NFLBF. ;GET RID OF ANY BUFFERS
;
 CLOSE1:
  SKIPN RLSFG# ;CHECK IF RELEASE/CLOSE
    JRA T,0(T) ;RETURN IF CLOSE
  SETZM 0(R2) ;IF RELEASE, CLEAR FILE TABLE
  MOVE R0,FL ;GET PTR TO BLOCK
  JSA T,DLOC. ;AND DEALLOCATE THE BLOCK
  JRA T,0(T) ;THEN RETURN
;
;
    PAGE
    SUBTTL RUN TIME SUBROUTINES--FLPTR.
;
;   FLPTR.--TIS ROUTINE TAKES THE FLOATING POINT NUMBER IN R0 AND EITHER
;      RETURNS TO 0(T) IF NO SUCH FILE EXISTS OR TO 1(T) WITH THE FCB
;      POINTER IN R0 IF THE FILE EXISTS.
;
;
 FLPTR.:Z
    XFIX R0 ;FIX THE NUMBER
    SKIPL  R0          ;MUST BE >0
    CAILE  R0,7777     ;AND LESS THAN 4096
    ERR    E.FLNO      ;ERROR IF NOT
    HRRZ R1,FILTB.(V) ;POINTER IN R1
;
 FLPTR1:
    SKIPN  R2,0(R1) ;CHECK FOR DONE SEARCH
    JRA    T,0(T)      ;FAIL RETURN IF SO
    HLRZS  R2          ;ELSE GET NUMBER
    ANDI R2,7777 ;KEEP ONLY THE FILE NUMBER
    CAME   R0,R2       ;CHECK VERSUS WHAT WE HAVE
    AOJA   R1,FLPTR1      ;TRY AGAIN ON FAIL
    HRRZ   R0,0(R1) ;GET PTR ON SUCCESS
    JRA    T,1(T)      ;AND RETURN IT
;
    PAGE
SUBTTL RUN TIME SUBROUTINES--NFLBF.
;
;   NFLBF--THIS ROUTINE GETS RID OF THE BUFFER FOR THE CURRENT
;      FILE IF ONE EXISTS.
;
;
NFLBF.: Z
;
  SKIPN F.BUF(FL) ;DOES A BUFFER EXIST
    JRA T,0(T) ;NO--JUST RETURN
  MOVE R0,F.BUF(FL) ;YES--GET PTR TO IT
  JSA T,DLOC. ;DEALLOCATE IT
  SETZM F.BUF(FL) ;CLEAR PTR
  SETZM F.CHCT(FL) ;AND COUNT
  SETZM F.ITAL(FL) ;AND TALLY
  SETZM F.LBK(FL) ;AND FLAG
;
  JRA T,0(T) ;THEN RETURN
;
PAGE
SUBTTL RUN TIME SUBROUTINES--OPNER.
;
;   OPNER.--THIS ROUTINE IS ENTERED (VIA JRST) WHEN A FILE OPERATION
;      IS TO BE PREFORMED ON A FILE LACKING A JFN.  IT DETERMINES
;      WHAT ERROR TO PRINT AND PRINTS IT.
;
;
OPNER.:
;
  SKIPN F.ERR(FL)	;CHECK IF WE HAD A FAILING OPEN
    ERR E.FNOP		;NO--FILE NEVER OPENED
    ERR E.NOPN		;YES--THEN COULDN'T OPEN IT
;
;
PAGE
SUBTTL RUN TIME SUBROUTINES--OPNFL.
;
;   OPNFL.--THIS ROUTINE IS USED TO OPEN A JSYS FOR THE
;      PROPER ACCESSES.  IT IS CALLED WITH ONE ARGUEMNT, THE
;      ACCESSES DESIRED.  IF EITHER THESE ARE NOT AVAILABLE
;      OR IFTHE FILE HAS NOT BEEN OOPENED. A OPENF JSYS IS
;      EXECUTED.
;
;
OPNFL.: Z
;
  PUSH P,R2	;SAVE R2
  MOVE R2,0(T) ;GET THEACCESS REQUESTED
  AND R2,F.BTS(FL) ;CHECK IF WE HAVE THEM
  CAMN R2,0(T) ;CHECK IF WE HAVE WHAT WE WANT
    JRST OPNFL1 ;YES--RETURN
;
  MOVE R2,F.BTS(FL) ;GET CURRENT BITS
  TRNE R2,FB.ACC ;CHECK IF FILE OPEN
  JSA T,CLOSE. ;IF SO, CLOSE. IT
;
  MOVE R2,F.BTS(FL) ;GET THE OLD BITS OF CLOSED FILE
  IOR R2,0(T) ;PLUS ACCESSES DESIRED
  TLZ R2,FB.OUR ;GET RID OF PRIVATE BITS
  HRRZ R1,F.JFN(FL) ;GET JFN
  OPENF ;AND OPEN THE FILE FOR WHAT WE WANTED
  ERR E.NPER ;ERROR IF WE CAN7T GET PERMISSIONS
;
  SETZM F.EOF(FL) ;NOT END OF FILE
  HRRM R2,F.BTS(FL) ;SAVE NEW BITS
  TLNN R2,FB.EPY ;CHECK IF FILE EMPTY
  TRNE R2,FB.AP ;OR IF WE ARE APPENDING
  SETOM F.EOF(FL) ;IF SO, THEN WE ARE AT EOF
;
 OPNFL1:
  POP P,R2	;RESTORE R2
  JRA T,1(T) ;AND RETURN
;
;
    PAGE
SUBTTL RUN TIME SUBROUTINES--FILES--OTCHR
;
;   OTCHR--THIS ROUTINE PUTS THE CHR IN R2 INTO THE FILE
;      SPECIFIED BY FL (ASCII) WITH JFN .R1;  THE POSITION
;      OF THE CHR IN THE LINE IS DULY NOTED AND SAVED
;      IN THE FILE BLOCK.  ALSO, A CHECK IS MADE SO
;      THAT THE MARGIN OF THE FILE IS ENFORCED.
;
;
OTCHR.: Z
;
  AOS F.CPOS(FL) ;MOST CHRS GO TO NEXT CHR POS
  CAIN R2,ASC.RO ;CHECK FOR RUB OUT
    JRST OTCH10 ;IGNORE IF SO
  CAIL R2,ASCSPA ;CHECK FOR CONTROL
    JRST OTCHR2 ;NO--RINT
;
  CAIN R2,ASC.HT ;CONTROL--CHECK FOR TAB
    JRST OTCH12 ;HANDLE TAB
  CAIN R2,ASCEOL ;EOL
    JRST OTCH11 ;HANDLE EOL
  CAIN R2,ASC.CR ;CARRIAGE RETURN
    JRST OTCH11 ;HANDLE RETURN
  CAIN R2,ASC.BS ;BACKSPACE
    SOSE F.CPOS(FL) ;YES--BACKSPACE LINE PTR
;
 OTCH10:
  SOSA F.CPOS(FL) ;NORMAL CONTROL CHR--0 SPACE
;
 OTCH11:
  SETZM F.CPOS(FL) ;START OF LINE
;
;
 OTCHR2:
  MOVE R0,F.MAR(FL);GET MARGIN
  JUMPE R0,OTCHR3 ;NONE GIVEN--PRINT CHR
  CAML R0,F.CPOS(FL) ;CAN WE FIT CHR
    JRST OTCHR3 ;YES--GO PRINT IT
;
  MOVE R0,R2 ;SAVE CHR
  MOVEI R2,ASCEOL ;GET EOL
  JSA T,OCHR3A		;PRINT THE CHR
  SETZM F.CPOS(FL) ;NEW LINE
  MOVE R2,R0 ;RESTORE CHR
  JRST OTCHR.+1 ;AND REFORMAT THAT CHR
;
;
 OCHR3A: Z		;INTERNAL ENTRY TO PRINT CHR
;
 OTCHR3:
  SKIPE CNTOF.		;CHECK TO IGNORE TTY OUTPUT
  CAIE FL,CRTTY.	;AND OUTPUT IS TO TTY
    SKIPA
    JRA T,0(T)		;IGNORE CHR IF SO
;
  BOUT ;PRINT GIVEN CHR
  JRA T,0(T) ;AND RETURN
;
;
 OTCH12:
  MOVE R0,F.CPOS(FL) ;HANDLE TAB--NEXT MULTIPLE OF 8
  ADDI R0,7 ;GET MULTIPLE
  TRZ R0,7 ;BY #+7+1 AND WITH -8
  MOVEM R0,F.CPOS(FL) ;SAVE AS POSITION
  JRST OTCHR2 ;AND CHECK MARGIN
;
;
    PAGE
SUBTTL RUN TIME SUBROUTINES--FILES--OTSTL.
;
;   OTSTL--THIS ROUTINE IS CALLED WITH A STRING PTR IN R2
;      AND THE JFN OF THE FILE IN R1 AND PRINTS THE ASCIZ
;      STRING USING OTCHR.
;
;
OTSTL.: Z
;
  MOVEM R2,STTAL# ;SAVE THE TALLY TO STRING
;
 OTSTL2:
  ILDB R2,STTAL ;GET NEXT CHR
  JUMPE R2,OTSTL1 ;IF DONE, EXIT
  JSA T,OTCHR. ;ELSE PRINT CHR
  JRST OTSTL2 ;AND LOOP
;
 OTSTL1:
  JRA T,0(T) ;RETURN WHEN DONE
;
;
    PAGE
SUBTTL RUN TIME SUBROUTINES--FILES--RNSET.
;
;   RNSET.--THIS ROUTINE MAKES SURE THAT THE CURRENT FILE
;      IS A RANDOM NUMERIC FILE.
;
;
RNSET.: Z
;
  MOVE R1,F.BTS(FL) ;GET FILE BITS
  TLOE R1,FB.RNM ;CHECK IF RANDOM NUMERIC
    JRST RNST1 ;IF SO, THEN JUMP
;
  TLZN R1,FB.UDF+FB.EPY ;CHECK IF UNDEFINED
    ERR E.FTYP ;IF NOT, THEN ERROR
;
  MOVEM R1,F.BTS(FL) ;SAVE BITS FOR IT AS RNUM
  MOVEI R1,44 ;BYTE SIZE
  SVBYSZ R1 ;SAVE BYTE SIZE
  MOVEI R1,1 ;MARGIN IS ONE
  MOVEM R1,F.MAR(FL) ;SAVE IT
  MOVEM R1,F.WLN(FL)	;SAVE AS RECORD LENGTH
  SKIPN R1,F.JFN(FL) ;GET JFN
    JRST OPNER.		;MUST BE THERE
  HRLI R1,FDBUSW ;PTR TO USER WORD
  PUSH P,R2	;SAVE R2,R3
  PUSH P,R3
  SETOM R2,R3 ;MINUS ONE IS RNUM MARKER
  CHFDB ;SET MARKER IN FILE BLOCK
  POP P,R3	;RESTORE R2,R3
  POP P,R2
;
 RNST1:
  JSA T,OPNFL. ;MAKE SURE THE FILE IS OPEN
    EXP FB.RD+FB.WT ;FOR READ-WRITE
;
  JRA T,0(T) ;THEN DONE
;
;
    PAGE
SUBTTL RUN TIME SUBROUTINES--FILES--RSSET.
;
;   RSSET--THIS ROUTINE MAKES SURE THAT THE CURRENT FILE
;      IS A RANDOM STRING FILE.
;
;
RSSET.: Z
;
  MOVE R1,F.BTS(FL) ;GET BITS FOR FILE
  TLOE R1,FB.RST ;CHECK IF RANDOM STRING
    JRST RSSET1 ;HANDLE IF SO
  TLZN R1,FB.UDF ;CHECK IF UNDEFINED
    ERR E.FTYP ;ERROR IF NOT
  TLZN R1,FB.EPY ;CHECK IF EMPTY
    ERR E.FTYP ;MUST BE
;
  MOVEM R1,F.BTS(FL) ;SAVE BITS INDICATING RSTR
  MOVEI R1,44 ;FULL WORDS READ
  SVBYSZ R1 ;SO SET BYTE SIZE
  PUSH P,R2	;SAVE R2,R3
  PUSH P,R3
  SKIPGE R3,F.MAR(FL) ;CHECK IF MARGIN GIVEN
  MOVEI R3,17 ;DEFAULT IF NONE IS 15
  MOVEM R3,F.MAR(FL) ;SAVE NEW MARGIN
  MOVEI R0,4+5(R3) ;GETMARGIN ROUNDED UP + 1 WD
  IDIVI R0,5 ;GET BLOCK SIZE IN WORDS
  MOVEM R0,F.WLN(FL) ;SAVE IN FILE BLOCK
  HRLI R3,-1 ;FILE INDICATOR IS -1,,<MRGN>
  SKIPN R1,F.JFN(FL) ;GET JFN
    JRST OPNER.		;FILE MUST HAVE ONE
  HRLI R1,FDBUSW ;PTR TO WORD TO SET
  SETO R2, ;CHANGE WHOLE WORD
  CHFDB ;SET USER SETTABLE WORD
  POP P,R3	;RESTORE R2,R3
  POP P,R2
;
 RSSET1:
  JSA T,OPNFL. ;MAKE SURE FILE IS OPEN
    EXP FB.RD+FB.WT ;FOR READ-WRITE
;
  JRA T,0(T) ;THEN RETURN
;
;
    PAGE
    SUBTTL RUN TIME SUBROUTINES--TYPAS
;
;   TYPAS--THIS ROUTINE INSURES THAT THE CURRENT FILE IS AN ASCII FILE
;      AND TRIES TO MAKE IT ONE IF NOT.
;
;
 TYPAS.:Z
  MOVE R1,F.BTS(FL) ;GET TYPE OF FILE
  TLON R1,FB.ASC ;FROM BITS--CHECK IF ASCII
    JRST TYPAS1 ;NO--SKIP
  TLNN R1,FB.TTY ;YES--CHECK IF TTY
    JRA T,1(T) ;RETURN FOR FILE
    JRA T,0(T) ;RETURN FOR TTY
;
 TYPAS1:
  TLZN R1,FB.UDF ;CHECK IF UNDEFINED
    ERR E.FTYP ;ERROR IF RANDOM FILE
  TLZ R1,FB.EPY		;NO LONGER EMPTY TYPE FILE
  MOVEM R1,F.BTS(FL) ;SAVE BITS INDICATING ASCII
  MOVEI R1,113 ;DEFAULT MARGIN OF 75
  SKIPGE F.MAR(FL) ;CHECK IF MARGIN GIVEN
    MOVEM R1,F.MAR(FL) ;IF NOT, SAVE DEFAULT
  SKIPN R1,F.JFN(FL) ;GET JFN OF FILE
    JRST OPNER.		;MUST HAVE ONE
  PUSH P,R2	;SAVE R2,R3
  PUSH P,R3
  HRLI R1,FDBUSW ;PTR TO USER WD IN FILE BLOCK
  SETO R2, ;CHECK WHOLE WORD
  HRROI R3,0 ;TO -1,,0 FOR ASCII FILE
  CHFDB ;SET WORD
  POP P,R3	;RESTORE R2,R3
  POP P,R2
;
  JRA T,1(T) ;NOW RETURN FILE
;
;
    PAGE
SUBTTL RUN TIME SUBROUTINES--STKEX.
;
;   STKEX--THIS ROUTINE IS CALLED WHEN WE ARE RETURNING
;      FROM A SUB OR FUNCTION.  ITS JOB IS TO POP THE
;      RUN TIME STACK UNTIL A CALL TO RTBGS. (RETURN
;      BEFORE GOSUB) IS FOUND.  THIS GETS RID OF THE
;      UNRETURNED GOSUBS.
;
;
STKEX.: Z
;
  MOVEM R2,RGSV. ;SAVE R2
  POP P,R2 ;GET NEXT ITEM OFF STACK
  TLZ R2,400000 ;TURN OFF FLAG BIT
  CAME R2,RBGSP. ;CHECK FOR RTBGS. CALL
  JRST .-2 ;IF NOT, CONTINUE LOOPING
  MOVE R2,RGSV. ;RESTORE R2 WHEN FOUND
  POP P,V ;RESTORE VINE NUMBER AS WEVV
  JRA T,0(T) ;AND RETURN
;
;
;   RTBGS.--THIS ENTRY ADDRESS IS PUSHED ON THE STACK AT
;      THE START OF A SUBROUTINE OR FUNCTION.  THEN IF AN
;      EXTRA RETURN IF EXECTUED, IT RETURNS TO THIS
;      ROUTINE, WHICH PRINTS THE APPROPRIATE ERROR MESSAGE.
;
;
RTBGS.:
  AOBJP P,.+1 ;RESTORE PDL SO MARKER STILL ON STACK
  ERR E.RBGS ;RETURN BEFORE GOSUB
;
;
RBGSP.:
  EXP RTBGS. ;POINTER TO PUSH ONTO STACK
;
;
SRBGS.:
  XWD 400000,RTBGS. ;POINTER TO PUSH W/ SUB FLAG
;
;
    PAGE
    SUBTTL RUN TIME SUBROUTINES--STCPY
;
;   STCPY--THIS ROUTINE COPIES THE STRING POINTED TO BY R2 ONTO THE
;      TALLY POINTED TO BY R1.  BOTH R1,R2,R3 AND R0 ARE USED.  THE
;      UPDATED R1 IS RETURNED IN R1.
;
;
 STCPY.:Z
    HLRZ   R3,-1(R2)   ;GET CHARACTER COUNT
;
 STCP1:
    CAMGE  R3,BYPWD.   ;CHECK COUNT VS. BYTES/WD
    JRST   STCP2       ;LESS THAN FULL WORD TO GO
    MOVE   R0,0(R2)    ;MORE THAN FULL WORD--GET IT
    MOVEM  R0,0(R1)    ;SAVE WHOLE WORD
    AOS    R2          ;BUMP PTRS
    AOS    R1
    SUB    R3,BYPWD.   ;UPDATE COUNT
    JUMPG  R3,STCP1    ;JUMP BACK IF MORE
    JRA    T,0(T)      ;RETURN IF NOT
;
 STCP2:
    ILDB   R0,R2       ;LESS THAN WORD--GET CHAR
    IDPB   R0,R1       ;SAVE CHAR
    SOJG   R3,.-2      ;JUMP BACK IF MORE
    JRA    T,0(T)      ;AND DONE
;
    PAGE
    SUBTTL RUN TIME SUBROUTINES--STLN
;
;   STLN--THIS ROUTINE IS USED AFTER A STRING IS CREATED THAT IS PRGENDED
;      WITH A NULL.  IT DETERMINES THE LENGTH IN CHARS OF THAT STRING
;      AND SAVES IT IN THE STRING BLOCK.
;
;
 STLN.:Z
    MOVEM  R1,STTAL#   ;SAVE TALLY
    MOVNI  R0,1        ;COUNTER
    ILDB   R2,R1       ;GET NEXT CHAR
    AOS    R0          ;BUMP COUNT
    JUMPN  R2,.-2      ;SKIP IF MORE
    MOVE   R1,STTAL    ;RESTORE TALLY
    HRLM   R0,-1(R1)   ;SAVE NEW COUNT
    JRA    T,0(T)      ;AND RETURN
;
    PAGE
    SUBTTL RUN TIME ALLOCATION ROUTINES--BLOC
;
;   BLOC--THIS ROUTINE USES THE BUDDY SYSTEM TO ALLOCATE A BLOCK OF
;      STORAGE.  THE LENGTH OF THE BLOCK DESIRED IN IN R0 ON ENTRY.
;      A BLOCK OF (R0)+1 IS ALLOCATED.  ITS POINTER IS RETURNED IN
;      R1 AND R2 ON EXIT.  IT USES R0,R1 AND R2.
;
;
 BLOC.:Z
    HRRZS  R0          ;ISOLATE SIZE
    MOVEI  R1,0        ;GET SIZE LOG 2
    CAML   R0,ALSTB(R1) ;WITH TABLE OF SIZES
    AOJA   R1,.-1      ;CONTINUE LOOKUP
;
    CAILE  R1,ALTBL    ;CHECK IF TOO BIG
    ERR    E.STL       ;ERROR IF SO
    MOVE   R2,ALCTB(R1) ;GET FREE POINTER FOR OUR SIZE
    JUMPN  R2,BLOC1    ;WE HAVE A BLOCK--USE IT
    MOVEM  R1,BLCT1#   ;ELSE SAVE SIZE
;
 BLOC4:
    AOS    R1          ;TRY NEXT SIZE
    CAIL  R1,ALTBL    ;TOO BIG??
    JRST   BLOC2       ;HANDLE HUGE BLOCK
;
 BLOC3:
    MOVE   R2,ALCTB(R1) ;GET POINTER TO BLOCK OF LARGER SIZE
    JUMPE  R2,BLOC4      ;NONE--TRY NEXT LARGER SIZE
    MOVEM  R2,ALCTB-1(R1) ;SAVE IT
    ADD    R2,ALSTB-1(R1) ;DIVIDE THE BLOCK IN HALF
    SETZM  0(R2)       ;FREE SECOND
    EXCH   R2,@ALCTB-1(R1) ;LINK SECOND BLOCK
    MOVEM  R2,ALCTB(R1) ;UNLINK AS LARGER BLOCK
    SOS    R1          ;DECREMENT SIZE
    CAME   R1,BLCT1    ;CHECK IF BACK TO WHAT WE WANT
    JRST   BLOC3       ;TRY SPLITTING SOME MORE IF NOT
    MOVE   R2,ALCTB(R1) ;GET PROPER POINTER IF SO
;
 BLOC1:
    MOVE   R0,0(R2)    ;UNLINK THIS BLOCK FROM FREE LIST
    MOVEM  R0,ALCTB(R1) ;AND RESTORE FREE LIST
    MOVE   R0,R2       ;GET PTR
    HRLS   R0          ;CREATE ZEROING TALLY
    ADD    R0,[XWD 1,2] ;TO CLEAN BLOCK
    SETZM  1(R2)       ;CLEAN FIRST WORD
    XCT    ALZTB(R1)   ;AND THEN REST
    HRRM   R1,0(R2)    ;GET PTR
    AOS    R1,R2       ;BUMP TO FIRST DATA WORD
    JRA    T,0(T)      ;AND RETURN PTRS IN R1,R2
;
 BLOC2:
    SOS    R1          ;GO BACK TO LAST SIZE
    MOVE   R2,CRTOP    ;GET CURRENT TOP
    SUBI R2,2000 ;GET START OF NEW PAGE
    MOVEM R2,ALCTB(R1) ;SAVE AS PAGE FREE
    MOVEM R2,CRTOP ;SAVE AS NEW TOP
    PUSH P,R1 ;SAVE R1
    SKIPE DBGPDL	;CHECK IF IN DEBUGGER
    EXCH P,DBGPDL	;IF SO, USE PROPER PDL
    ADD P,[XWD 2000,0] ;LESS ROOM FOR STACK
    HRRZ R1,P ;CHECK STACK PTR
    SKIPE DBGPDL	;CHECK IF IN DEBUGGER
    EXCH P,DBGPDL	;IF SO, RESTORE ITS PDL
    CAML R1,CRTOP ;TO SEE IF MORE ROOM EXISTS
      ERR E.OTCR ;IF NOT, ERROR
    HRLI R1,0(R2) ;FROM AREA TO CLEAR
    HRRI R1,1(R2) ;TO AREA TO CLEAR
    SETZM 0(R2) ;CLEAR FIRST WORD
    BLT R1,1777(R2) ;CLEAR NEW PAGE
    POP P,R1 ;RESTORE R1
    JRST   BLOC3       ;AND PROCESS
;
    PAGE
;
;   TABLES FOR ALLOCATION ROUTINES
;
;
;   ALSTB--SIZE TABLE
;
    EXP    1
 ALSTB:EXP 2
    EXP    4
    EXP    10
    EXP    20
    EXP    40
    EXP    100
    EXP    200
    EXP    400
    EXP    1000
    EXP    2000
    EXP    377777777777
;
;
;   ALCTB--FREE PAGE TABLE
;
 ALCTB:BLOCK 12
;
;
;   ALZTB--ZEROING INSTRUCTION TABLE
;
 ALZTB:BLT R0,2-1(R2)
    BLT    R0,4-1(R2)
    BLT    R0,10-1(R2)
    BLT    R0,20-1(R2)
    BLT    R0,40-1(R2)
    BLT    R0,100-1(R2)
    BLT    R0,200-1(R2)
    BLT    R0,400-1(R2)
    BLT    R0,1000-1(R2)
    BLT    R0,2000-1(R2)
;
;
    ALTBL== 12         ;LENGTH OF TABLES
;
    PAGE
    SUBTTL RUN TIME ALLOCATION ROUTINES--BSLOC
;
;   BSLOC--THIS ROUTINE ALLOCATES A BIT STRING WITH (R0) BYTES OF SIZE
;      (R1).  IT SETS UP THE STRING BLOCK WITH COUNT AND RETURNS THE
;      PROPER TALLY TO THE STRING IN R1 ON EXIT.  USES R0,R1,R2,R3.
;
;
 BSLOC.:Z
    MOVEM  R1,BSLCTM#  ;SAVE BYTE SIZE
    HRLM   R0,BSLCTM   ;AND COUNT
    MOVEI  R2,44       ;WORD SIZE
    IDIV   R2,R1       ;GET #BYTES/WD IN R2 ,X-->R3
    MOVEM  R2,BYPWD.   ;SAVE
    AOS    R0          ;SAVE SPACE FOR 0 BYTE
    IDIV   R0,R2       ;GET # WDS  TO R0, X TO R1
    SKIPE  R1          ;CHECK IF EXCESS
    ADDI   R0,1        ;BUMP WORD COUNT
    MOVEM  R0,NWDTL.   ;SAVE NUMBER OF WORDS
    ADDI   R0,1        ;ROOM FOR HEADER FOR STRING
    JSA    T,BLOC.     ;ALLOCATE BLOCK
    HLLZ   R0,BSLCTM   ;GET COUNT
    MOVEM  R0,0(R1)    ;SAVE IN BLOCK
    HRRZ   R2,BSLCTM   ;GET BYTE SIZE
    LSH    R2,6        ;TO PROPER POSITION
    HRLI   R1,440000(R2) ;CREATE TALLY HEAD IN R1
    AOS    R1          ;BUMP PTR TO DATA AREA IN TALLY
    JRA    T,0(T)      ;AND RETURN TALLY
;
    PAGE
    SUBTTL RUN TIME ALLOCATION ROUTINES--SALOC
;
;   SALOC--THIS ROUTINE ALLOCATES A NORMAL (7 BIT) STRING OF (R0) CHRS
;      AND RETURNS A TALLY TO IIT IN R1.
;
;
 SALOC.:Z
    MOVEM  R0,SALTM#   ;SAVE COUNT
    ADDI R0,1+4+5 ;ROUND UP, ADD HEADER SPACE
    HRRZS R0 ;ISOLATE LENGTH
    IDIVI  R0,5        ;GET NUMBER OF WORDS
    JSA    T,BLOC.     ;ALLOCATE BLOCK
    HRLZ   R0,SALTM    ;GET COUNT
    MOVEM  R0,0(R1)    ;SAVE IN BLOCK
    AOS    R1          ;BUMP TALLY TO DATA AREA
    HRLI   R1,440700   ;TALLY TO R1
    JRA    T,0(T)      ;AND RETURN
;
    PAGE
    SUBTTL RUN TIME ALLOCATION ROUTINES--DLOC
;
;   DLOC--THIS ROUTINE DEALLOCATES A BLOCK WHOSE POINTER IS IN R0.  IT
;      USES R0 AND R1.  NO GARBAGE COLLECTING IS DONE.
;
;
 DLOC.:Z
    SUBI   R0,1        ;GET POINTER TO OUR HEADER
    MOVE   R1,@R0      ;GET LENGTH FACTOR
    EXCH   R0,ALCTB(R1) ;PUT THIS BLOCK ON FREE LIST
    MOVEM  R0,@ALCTB(R1) ;CONTINUE LINK
    JRA    T,0(T)      ;AND RETURN
;
    PAGE
    SUBTTL RUN TIME ALLOCATION ROUTINES--SDLOC
;
;   SDLOC--THIS ROUTINE DEALLOCATES THE STRING IN 0(T).  IT IS CALLABLE
;      FROM THE RUN TIME PACKAGE AND WILL ONLY USE R0.  IT DECREMENTS
;      THE COUNT (USAGE) FOR THE STRING AND IF NOONE IS USING IT ANYMORE,
;      THEN IT ACTUALLY DEALLOCATES IT.
;
;
 SDLOC.:Z
    MOVEM R0,SDLT2# ;SAVE R0
    MOVEM  R1,SDLTM#   ;SAVE R1
    MOVE   R1,@0(T)    ;GET TALLY
    JUMPE  R1,SDLC2    ;NULL--NOTHING TO DO
    MOVEM  R1,SDLT1#   ;SAVE IT
    SOS    R1,-1(R1)   ;DECREMENT USAGE COUNT
    TRNN   R1,400000   ;CHECK IF NEGATIVE
    JRST   SDLC1       ;NO--STILL BEING USED
    MOVE   R0,SDLT1    ;NO ONE USING ME--GET MY POINTER
    HRRZS  R0          ;ONLY
    SUBI   R0,1        ;STRING HEADER
    JSA    T,DLOC.     ;BYE BYE
;
 SDLC1:
    SETZM  @0(T)       ;RETURN NULL STRING TO CALLER
;
 SDLC2:
    MOVE   R1,SDLTM    ;RESTORE R1
    MOVE R0,SDLT2 ;RESTORE R0
    JRA    T,1(T)      ;AND RETURN
;
    PAGE
    SUBTTL RUN TIME ALLOCATION ROUTINES--XDLOC
;
;   XDLOC--THIS ROUTINE DEALLOCATES A STRING.  IT IS CALLED FROM WITHIN
;      THE RTP WITH THE TALLY IN R1.  IT DOESN'T PRESERVE R1 NOR DOES
;      IT RETURN A NULL STRING TO THE CALLER.  GENERALLY IT IS USED AFTER
;      AN  'EXCH R1,@N(T)'.
;
;
 XDLOC.:Z
    JUMPE  R1,XDLC2    ;HANDLE NULL STRING--IGNORE
    HRRZ   R0,R1       ;SAVE PTR
    SOS    R1,-1(R1)   ;DECREMENT USAGE COUNT
    TRNN   R1,400000   ;CHECK IF FREEABLE
;
 XDLC2:
    JRA    T,0(T)      ;NOT--RETURN
;
    SUBI   R0,1        ;ELSE POINT TO START
    JRST   DLOC.+1     ;AND EXIT BY DEALLOCATING STRING
;
    PAGE
SUBTTL RUN TIME ROUTINES--MAIN ERROR MESSAGES
;
;
;
E.CHER: ER NRM,Error with chained files
E.EOF: ER FLM,Reading past end of file
;
E.FLER: ER <FLM,ERR>,File error
;
E.FLR1: ER <FLM,ER1>,File error
;
E.FLNO: ER NRM,Illegal file number
;
E.FNOP: ER NRM,No file for file number
;
E.FTYP: ER FLM,File type and usage conflict
;
E.OFLO: ER WRN,Overflow
;
E.UFLO: ER WRN,Underflow
;
E.DVBZ: ER WRN,Division by zero
;
E.OTCR: ER NRM,Out of room
;
E.STL:ER NRM,String too long
;
E.SYS: ER SYS,Run time system error
;
E.ONER:ER NRM,ON evaluated out of range
;
E.SBSC:ER <NRM,BUF,BFN>,Subscript out of bounds
;
E.RBGS:ER NRM,RETURN before GOSUB
;
E.NPER:ER <FLM,ER1>,Not enough permissions
;
;
E.GBFC:ER <NRM,BUF>,Function types inconsistent
;
;
E.NOPN:ER <FLM,EFL>,Couldn't open file
;
;
    PAGE
    SUBTTL STORAGE FOR MAIN RTP ROUTINES
;
;
;
 FLTRG:BLOCK 20        ;REGS DURING ERROR MESSAGE
 ABTRG:BLOCK 20 ;AOBRT REGS
 RGSV.:BLOCK 20 ;MISC SAVE REGS FOR ALL RTNS
 CNTORG: BLOCK 1	;REG SAVE FOR CNTROL O
 FLTPC: BLOCK 1		;INTPC1 OF LAST FATAL ERROR
;
;
 ABTOP:BLOCK 1         ;ABSOLUTE TOP OF CORE
PDLBS: BLOCK 1 ;BASE OF PDL (TOP OF STRING AREA)
 CRTOP:BLOCK 1         ;CURRENT TOP OF CORE
;
 ERBUF: BLOCK 4 ;BUFFER FOR ERROR INFO
;
;
;
 BYPWD.:BLOCK 1        ;BYTES PER WORD IN CURRENT STRING
 NWDTL.:BLOCK 1        ;NEXT WORD TALLY
 INRST.:BLOCK 1        ;INPUT RESTART ADDRESS
 INAMP.:BLOCK 1       ;AMPERSAND ALLOWED ON INPUT FLAG
 NUM..:BLOCK 1      	;NUM FUNCTION VALUE
 STTIM.:BLOCK 1 	;START RUN TIME
 CNTOF.:BLOCK 1		;CONTROL O OUTPUT
 NSCFL.:BLOCK 1	;NUMBER FOR VERSION OF SCRATCH FILE
;
;
TMPTL.: POINT 7,TMPBF. ;TEMP BUFFER TALLY
TMPCT.: BLOCK 1 ;STRING HEADER FOR TMP BUFFER
TMPBF.: BLOCK 20 ;TEMP BUFFER
;
;
EOFFG.: Z ;END OF FILE OK FLAG (-1 IS OK, ELSE FATAL)
;
;
PATCH.: BLOCK 100 ;PATCH SPACE FOR ALL RTNS
;
;
    PAGE
SUBTTL TTY FILE BLOCK DEFINITION
;
;   THE FOLLOWING IS THE INITIAL FCB FOR THE USERS TTY.
;
;
CRTTYD:
  XWD FB.ASC+FB.TTY,FB.RWA ;BITS
  XWD 100,101 ;JFNS
  EXP 0 ;LAST TERM CHR
  EXP 0 ;EXTRA CHR READ
  EXP 113 ;MARGIN
  EXP 0 ;CHAR POSITION
  EXP 0 ;END OF FILE FLAG
  EXP 0 ;CHARACTER COUNT IN BUFFER
  EXP 0 ;TALLY TO BUFFER
  EXP 0 ;BUFFER PTR
  EXP 0 ;LAST BLOCK FLAG
  EXP 0 ;LINE,PAGE #S
  EXP 0,0,0 ;SPARE
;
;
CRTTY.: BLOCK FLBLN	;BLOCK FOR RUNNING DESCRIPTION
;
;
    PAGE
    SUBTTL END OF ASSEMBLY
;
;
;
    PRGEND INIT
    TITLE  CCT. -- BASIC RUN TIME ROUTINES--CONCATENATE
    SUBTTL ASSEMBLY CONTROL
    SEARCH STENEX,BGBL,BRSYMS
;
;
;
    ENTER CCT.
;
;
    EXTERNAL SALOC.,BYPWD.,STCPY.,BSLOC.
;
;
;
    PAGE
    SUBTTL BASIC RUN TIME ROUTINES--CCT
;
;   CCT--THIS ROUTINE DOES STRING CONCATENATION.  IT IS CALLED WITH
;      TWO STRINGS AS ARGUMENTS AND RETURNS THE CONCATENATION OF THE
;      TWO IN R1.  SPECIAL CHECKS ARE MADE FOR ONE OR BOTH OF THE
;      INPUT STRINGS BEING NULL.
;
;
 CCT.:Z
    MOVEM  R3,CCTM2#   ;SAVE R3
    MOVEM  R2,CCTM1#   ;SAVE R2
    MOVE   R1,@0(T)    ;PICK UP FIRST STRING
    MOVEM  R1,CCTM4#      ;SAVE PTR
    JUMPE  R1,CCT1     ;HANDLE FIRST NULL
    MOVE   R2,@1(T)    ;PICK UP SECOND STRING
    MOVEM  R2,CCTM5#      ;SAVE IT TOO
    JUMPE  R2,CCT2     ;HANDLE IF THAT IS NULL TOO
    MOVE   R0,-1(R1)   ;LENGTH OF FIRST
    ADD    R0,-1(R2)   ;PLLUS LENGTH OF SECOND
    HLRZS  R0          ;TO R0 AS LENGTH OF NEW STRING
;
;   CHECK FOR ODD LENGTH STRINGS
;
    HLRZS  R1          ;CHECK TALLY OF FIRST
    HLRZS  R2          ;AND SECOND
    CAME   R1,R2       ;MUST BE THE SAME (SAME LENGTH CHRS)
    ERR    E.CCT       ;ERROR IF NOT
    CAIE   R1,440700   ;CHECK IF DEFAULT=7
    JRST   CCT4        ;HANDLE IF NOT
    MOVEI  R1,5        ;GET DEFAULT NUMBER OF BYTE PER WORD
    MOVEM  R1,BYPWD.   ;SAVE IT
;
    JSA    T,SALOC.    ;ALLOCATE STRING
;
 CCT5:
    MOVE   R2,CCTM4    ;RESTORE PTR TO FIRST STRING
    MOVEM  R1,CCTM3#   ;SAVE PTR TO RESULT
    JSA    T,STCPY.    ;COPY FIRST STRING
    MOVE   R2,CCTM5    ;GET SECOND STRING TALLY
    HLRZ   R3,-1(R2)   ;GET LENGTH IN CHRS
    ILDB   R0,R2       ;GET CHR
    IDPB   R0,R1       ;SAVE
    SOJG   R3,.-2      ;REPEAT UNTIL DONE
    MOVE   R1,CCTM3    ;RESTORE TALLY TO STRING
    MOVE   R3,CCTM2    ;RESTORE R3
    JRST   CCT3        ;AND SKIP
;
 CCT1:
    MOVE   R1,@1(T)    ;CHECK SECOND STRING IF FIRST NULL
    SKIPE  R1          ;SKIP IF IT TOO IS NULL
;
 CCT2:
    AOS    -1(R1)      ;UPDATE USAGE COUNT IF GOING TO USE
;
 CCT3:
    MOVE   R2,CCTM1    ;RESTORE R2
    JRA    T,2(T)      ;AND RETURN
;
;   HANDLE ODD CHARACTER LENGTHS
;
 CCT4:
    LSH    R1,-6       ;GET LENGTH IN LOWER
    ANDI   R1,77       ;MASK TO GET IT ONLY
    JSA    T,BSLOC.    ;ALLOCATE ODD STRING
    JRST   CCT5        ;AND THEN CONTINUE NORMALLY
;
;
;
;   ERROR MESSAGE
;
E.CCT: ER NRM,Can't concatenate strings of different byte sizes
;
    PAGE
    SUBTTL END OF ASSEMBLY
;
;
;
    PRGEND
TITLE CHAIN. -- BASIC RUN TIME ROUTINES--CHAIN
SUBTTL ASSEMBLY CONTROL
SEARCH STENEX,BGBL,BRSYMS
;
;
  ENTER CHAIN.,CHANN.
;
;
  EXTERNAL RGSV.,E.FNOP,STPFL.,OPNER.,E.FLR1
;
;
    PAGE
SUBTTL BASIC RUN TIME ROUTINES--CHAIN., CHANN.
;
;   CHAIN.--THIS ROUTINE IS ENTERED WITH THE NUMBER OF FILES TO
;      PASS IN R1, THE STRING TO CHAIN TO IN 0(T), THE SYSTEM
;      STRING IN 1(T) AND THE FILE NUMBERS IN 2(T)...N(T).  IT
;      EITHER RUNS THE GIVEN FILE (SYSTEM RUN), OR IGNORES IT
;      AND RUNS THE GIVEN SYSTEM, OR SETS IT UP AS THE INPUT
;      STRING FOR THE COMPILER FOR A CHAIN TO TBASIC.
;
;   CHANN.--THIS ROUTINE IS SIMILAR TO CHAIN. EXCEPT INSTEAD
;      OF THE STRING TO CHAIN TO IN 0(T), A FILE NUMBER IS GIVEN
;      IN 0(T).  THE FILE SPECIFIED BY THAT NUMBER BECOMES THE
;      ONE TO CHAIN TO.
;
;
CHAIN.: Z
;
  MOVEM R1,NFLS#	;SAVE NUMBER OF FILES
  MOVE R1,@0(T)		;GET STRING TO CHAIN TO
  MOVEM R1,CHNFL#	;SAVE IT
  JRST CHN1		;AND ENTER MAIN ROUTINE
;
;
;
CHANN.: Z
;
  MOVEM R1,NFLS#	;SAVE NUMBER OF FUILES
  FIX R0,@0(T)		;GET FIXED FILE NUMBER
  PUSHJ P,CHNFLN	;FIND THE GIVEN FILE
    ERR E.FNOP		;FILE BETTER EXIST
  MOVEI R0,FB.CHN	;GET BIT SO WE DON'T CLOSE FILE
  IORM R0,F.BTS(R1)	;SET ON IN FCB
  HRRZ R0,F.JFN(FL)	;GET JFN OF FILE
  SKIPN R0		;CHECK FOR ITS BEING THERE
    JRST OPNER.		;ELSE ERROR OF SOME SORT
  MOVEM R0,CHNFL#	;SAVE JFN
;
;
    PAGE
;
;   CHN1--PROCESS SYSTEM TO CHAIN TO
;
 CHN1:
;
  SETZM EVCLOC#		;NORMALLY USE 0 ENTRY VIA ENTRY VECTOR
  MOVE R1,@1(T)		;GET SYSTEM STRING
  MOVEM R1,SYSTM#	;SAVE IT
  MOVEM R2,RGSV.	;SAVE R2,R3
  MOVEM R3,RGSV.+1
;
  MOVNI R1,1		;GET RID OF OLD SOURCE PAGE
  MOVEI R2,SRCPGN	;NOW RATHER THAN LATER
  PMAP			;AS WE MIGHT WANT TO CREATE A NEW ONE
;
  SKIPN R1,SYSTM	;GET SYSTEM, CHECK FOR NONE
    JRST CHBAS		;NONE IMPLIES CHAIN TO TBASIC
  MOVE R0,0(R1)	;GET FIRST WORD OF STRING
  CAMN R0,[ASCII /RUN/]	;CHECK FOR SYSTEM 'RUN'
    JRST CHRUN		;HANDLE THAT CASE
  CAME R0,[ASCII /TBASI/]	;CHECK FOR TBASIC
    JRST CHXXX		;HANDLE UNKNOWN
  MOVE R0,1(R1)		;GET SECOND WORD OF TBASI STRING
  CAMN R0,[ASCII /C/]	;CHECK FOR 'C'
    JRST CHBAS		;HANDLE TBASIC
  JRST CHXXX		;HANDLE UNKNOWN
;
;
 CHRUN:
  SETZM OPDIR		;SYSTEM RUN--CLEAR DFLT DIRECTORY
  PUSHJ P,OPFIL		;OPEN THE STIRNG GIVEN
  JRST CHN2		;AND THEN HANDLE FILES
;
;
 CHBAS:
  MOVEI R1,3		;ENTER AT 3RD LOC IN ENTRY VECTOR
  MOVEM R1,EVCLOC#	;SAVE THAT
  MOVE R1,CHNFL		;GET FILE PTR FOR SOURCE
  TLNN R1,-1		;CHECK IF STRING/FILE NUMBER
    JRST CHBAS1		;HANDLE FILE NUMBER--FAKE STRING
  MOVEI R2,SRCBUF	;GET PTR TO SOURCE BUFFER
;
 CHBAS2:
  MOVE R0,0(R1)		;GET WORD FROM USER STRING
  MOVEM R0,0(R2)	;SAVE IN BUFFER FOR COMPILER
  AOS R2		;BUMP BUFFER PTR
  TRNE R0,376		;CHECK IF DONE
    AOJA R1,CHBAS2	;LOOP IF NOT
  MOVSI R0,174000	;BYTE (7)37
  MOVEM R0,0(R2)	;SAVE AS STRING TERMINATOR
  JRST CHBAS3		;AND PROCESS FILES
;
 CHBAS1:
  SKIPN R1		;MAKE SURE WE HAVE A JFN
    JRST CHBAS4		;HANDLE NO PROGRAM GIVEN
  SETZM SRCBUF		;CLEAR FIRST WORD OF BUFFER (INSURE THERE)
  HRROI R1,SRCBUF	;PTR TO BUFFER
  MOVE R2,CHNFL		;GET JFN
  MOVEI R3,0		;FREE FORMAT
  JFNS			;PUT STRING INTO BUFFER
  MOVEI R0,37		;END OF STRING MARKER
  IDPB R0,R1		;SAVE IT IN STRING
;
 CHBAS3:
  HRLZI R1,100001	;BITS FOR OLD FILE
  HRROI R2,[ASCIZ /<SUBSYS>TBASIC.SAV/]	;COMPILER JFN
  GTJFN			;GET IT
    BLOWUP		;PLEASE
  HRRZM R1,CHNFL	;SAVE FOR CHAINING
  JRST CHN2		;AND THEN PROCESS FILES
;
 CHBAS4:
  SETZM EVCLOC		;DO A RUN OF THE COMPILER
  JRST CHBAS3		;GET COMPILER
;
;
 CHXXX:
  MOVE R1,SYSTM		;GET SYSTEM STRING
  MOVEM R1,CHNFL	;SAVE AS SOURCE
  HRROI R1,[ASCIZ /SUBSYS/]	;DEFAULT DIRECTORY
  MOVEM R1,OPDIR	;SAVE
  PUSHJ P,OPFIL		;OPEN THE FILE
  JRST CHN2		;AND THEN HANDLE FILES
;
;
    PAGE
;
;   CHN2--PROCESS CHAIN WITH PASSED FILES
;
 CHN2:
  MOVNI R1,1		;FIRST GET RID OF CHAIN INFO PAGE
  MOVEI R2,CHNPGN
  PMAP
;
  SKIPN R1,NFLS		;CHECK IF ANY FILES BEING PASSED
    JRST CHN3		;HANDLE IF NOT
  MOVEM R1,CHNNFL	;SAVE NUMBER  IF SO
  ADDI T,2		;BUMP ENTRY PTR TO CURRENT FILE
  MOVEI R1,CHNFLS	;PTR TO FILES
  MOVEM R1,CURFL#	;SAVE THAT
  SETZM LSTFL#		;NO PREVIOUS FILE
;
 CHN2B:
  MOVE R2,RGSV.		;RESTORE R2 AND R3
  MOVE R3,RGSV.+1
  FIX R0,@0(T)		;GET NEXT FILE NUMBER
  PUSHJ P,CHNFLN	;GET FILE PTR FOR IT
    ERR E.FNOP		;MUST EXIST
  MOVE FL,R1		;MOVE PTR TO FL
  MOVE R3,CURFL		;PTR TO CHAIN BLOCK ENTRY
  SKIPE R2,LSTFL	;CHECK FOR PREVIOUS FILE
    MOVEM R3,0(R2)	;LINK IF SO
  MOVE R0,F.BTS(FL)	;GET FILE BITS
  MOVEM R0,1(R3)	;SAVE IN CHAIN FILE BLOCK
  TLNE R0,FB.TTY	;CHECK FOR TTY
    ERR E.TTY		;WHICH IS ILLEGAL
  SKIPN F.JFN(FL)	;MAKE SURE WE HAVE A JFN
    JRST OPNER.		;ERROR IF NOT
;
  TRNN R0,FB.ACC	;CHECK IF FILE OPEN
    JRST CHN2A		;IGNORE THIS IF NOT
  HRRZ R1,F.JFN(FL)	;GET JFN
  RFPTR		;GET CURRENT PTR
    ERR E.FLR1		;SHOULD BE ABLE TO 
  MOVEM R2,2(R3)	;SAVE IN BLOCK
  SKIPN F.BUF(FL)	;CHECK IF BUFFERED INPUT
    JRST CHN2A		;HANDLE IF NOT--DONE
  MOVE R1,F.CHCT(FL)	;IF SO, GET CHRS LEFT THERE
  ADDM R1,2(R3)		;GET PROPER FILE POSITION
  SKIPN R1		;CHECK IF THERE WERE ANY
    SETZM F.EOF(FL)	;IF SO, CLEAR EOF FLAG
;
 CHN2A:
  MOVE R1,F.CPOS(FL)	;GET LINE POSITION
  HRL R1,F.TRM(FL)	;AND LAST TERMINATOR
  MOVEM R1,3(R3)	;SAVE IN CFB
  MOVE R1,F.EOF(FL)	;GET EOF FLAG
  MOVEM R1,4(R3)	;SAVE
  MOVE R1,F.LNM(FL)	;GET LINE/PAGE NUMBERS
  MOVEM R1,5(R3)	;SAVE
  HRROI R1,6(R3)	;GET PTR TO NAME AREA
  HRRZ R2,F.JFN(FL)	;GET JFN
  MOVEI R3,0		;AND FREE FORMAT
  JFNS			;SAVE STRING OF NAME IN CFB
  HRRZI R1,2(R1)	;EXTRA SPACE, CLEAR PTR
  EXCH R1,CURFL		;SAVE PTR FOR NEW BLOCK
  MOVEM R1,LSTFL	;AND MAKE THIS ONE THE OLD ONE
  SOSLE NFLS		;CHECK IF DONE
    AOJA T,CHN2B	;LOOP IF MORE
;
;
    PAGE
;
;   CHN3--SET UP TO ACTUALLY CHAIN
;
 CHN3:
  JSA T,STPFL.		;CLOSE UNNEEDED FILES
  MOVNI R1,1		;FLAG FOR DELETING PAGES
  HRLI R2,400000	;CURRENT FORK
  HRRI R2,GBLPGN	;GLOBAL INFO
  PMAP
  HRRI R2,RTVPGN	;RUN TIME TRANSFERS
  PMAP
  HRRI R2,SUBPGN	;SUB DESCRIPTIONS
  PMAP
  HRRI R2,SUBPGN+1
  PMAP
  HRRI R2,LIBPGN	;LIBRARY DESCRIPTIONS
  PMAP
;
  MOVE R1,[XWD CHN4,CHN4B] ;MOVE CODE TO REGISTER AREA
  BLT R1,CHN4A
  MOVE R1,EVCLOC	;GET ENTRY VECTOR LOC
  HRRM R1,CHN4A		;SAVE IT
;
  MOVNI R1,1		;MINUS ONE IN R1
  MOVEI R4,757		;FIRST PAGE TO DELETE IN R4
  HRRZ R3,CHNFL		;JFN TO CHAIN TO IN R3
  HRLI R3,400000	;W/ CURRENT FORK IN UPPER
  HRLZI R2,400000	;CURRENT FORK IN R2
  JRST CHN4B		;DO THE CHAIN
;
;
;   CHN4--CODE IN REGISTERS TO DO CHAIN
;
 CHN4:
	PHASE 7
;
 CHN4B:
  HRR R2,R4		;GET NEXT PAGE NUMBER
  PMAP			;GET RID OF A PAGE
  SOJGE R4,.-2		;LOOP TO GET RID OF NEXT
  MOVE R1,R3		;GET JFN TO CHAIN TO
  GET			;GET IT INTO CORE
  RESET			;CLEAN UP FOR EXIT
  MOVEI R1,400000	;CURRENT FORK
  GEVEC			;GET ENTRY VECTOR
;
 CHN4A:
  JRST 0(R2)		;END AND EVEC JUMP
;
	DEPHASE
;
;
;   ERROR MESSAGES
;
 E.TTY: ER NRM,Can't pass TTY: with CHAIN
;
 E.CHFL: ER NRM,Couldn't open CHAIN system
;
;
    PAGE
SUBTTL BASIC RUN TIME ROUTINES--CHNFLN
;
;   CHNFLN--THIS IS A SUBROUT9INE USED BY CHAIN TO FIND THE FILE
;      BLOCK FOR THE FILE WHOSE NUMBER IS FIXED IN R0 ON ENTRY.
;
;
CHNFLN:
;
  MOVEM R0,RGSV.+10	;SAVE R0
  HLLZ R1,FILTB.(V)	;GET FILE TABLE PTR
  ADD R1,[XWD 1,0]	;CORRECT FOR AOB PTR
  MOVNS R1		;GET MINUS LENGTH
  HRR R1,FILTB.(V)	;ALONG WITH PTR
;
 CHFN1:
  LDB R0,[POINT 12,0(R1),17]	;GET FILE NUMBER OF THIS ENTRY
  CAMN R0,RGSV.+10	;CHECK FOR NUMBER MATCH
    AOSA 0(P)		;IF SO, SKIP AND BUMP RETURN
  AOBJN R1,CHFN1	;IF NOT, LOOP AND INCREMENT PTR, CHECK IF DONE
;
  HRRZ R1,0(R1)		;GET PTR IF REASONABLE (GARBAGE IF NOT)
  MOVE R0,RGSV.+10	;RESTORE R0
  POPJ P,		;AND RETURN 0(P) FOR FAIL, 1(P) FOR OK
;
;
    PAGE
SUBTTL BASIC RUN TIME ROUTINES--OPFIL
;
;   OPFIL--THIS ROUTINE OPENS THE FILE WHOSE TALLY IS IN CHNFL
;      WITH THE DEFAULTS SPECIFIED IN THE TABLE OPTBL.  IT PRINTS
;      A MESSAGE ON ERRORS AND SETS CHNFL AS THE RESULTANT JFN.
;
;
OPFIL:
;
20000	  SKIPN R2,CHNFL	;CHECK STRING/JFN OF CHAIN FILE
20010	    ERR E.CHFL		;MUST BE ONE OR OTHER
20020	  TLNN R2,-1		;CHECK FOR JFN
20030	    JRST OPFL1		;HANDLE IF SO
20040	;
20050	  HRRZI R1,OPTBL		;ELSE GET PTR TO OPEN TABLE
20060	  GTJFN			;OPEN THE FILE
20070	    ERR E.CHFL		;FAIL IF WE CAN'T GET IT
20080	  HRRZM R1,CHNFL	;SAVE THE JFN
20090	  POPJ P,		;AND RETURN
20100	;
20110	 OPFL1:
20120	  MOVE R1,R2	;JFN TO R1
20130	  TLO R1,400000		;CLOSE WITHOUT RELEASE
20140	  CLOSF
20150	    TRN			;MAY ALREADY BE
20160	  POPJ P,		;AND THEN RETURN
20170	;
20180	;
20190	 OPTBL:
20200	  XWD 100000,0		;OLD FILE
20210	  XWD 377777,377777
20220	  EXP 0
20230	 OPDIR: EXP 0		;DFLT DIRECTORY
20240	  EXP 0
20250	  XWD -1,OPSAV	;DFLT EXTENSION
20260	  EXP 0,0,0
20270	;
20280	 OPSAV:
20290	  ASCIZ /SAV/
20300	;
20310	;
20320	    PAGE
20330	SUBTTL END OF ASSEMBLY
20340	;
20350	;
20360	;
20370	    PRGEND
20380	    TITLE  CMS -- BASIC RUN TIME ROUTINE--CHANGE MAT TO STR
20390	    SUBTTL ASSEMBLY CONTROL
20400	    SEARCH STENEX,BGBL,BRSYMS
20410	;
20420	;
20430	    ENTER CBMS.,CHMS.
20440	;
20450	;
20460	    EXTERNAL XDLOC.,SALOC.,BSLOC.,RGSV.
20470	;
20480	;
20490	    PAGE
20500	    SUBTTL BASIC RUN TIME ROUTINES--CBMS
20510	;
20520	;   CBMS--CHANGE BIT MAT TO STR--THIS ROUTINE TAKES A VECTOR A STRING
20530	;      AND A BYTE SIZE AND CREATS A STRING CONTAINING
20540	;      V(0) BYTES OF N-BITS WITH THE I-TH BYTE CONTAINING
20550	;      V(I).
20560	;
20570	;
20580	 CBMS.:Z
20590	    XFIX   R1,@0(T)    ;GET THE BYTE SIZE
20600	    AOS    T           ;FAKE CALL TO LOOK LIKE CHANGE
20610	    MOVE   R2,@0(T)    ;GET MATRIX PTR
20620	    XFIX   R0,0(R2)   ;GET ZEROTH ELEMENT
20630	    JUMPE  R0,CHMS1    ;HANDLE NULL
20640	    HLRZ R2,@0(T) ;GET MAX SIZE
20650	    SKIPL  R0          ;CHECK FOR TOO SMALL
20660	    CAML  R0,R2   ;CHECK FOR FIT IN MATRIX
20670	    ERR    E.CHNG      ;NO FIT--ERROR
20680	    JSA    T,BSLOC.    ;FIT--ALLOCATE STRING
20690	    JRST   CHMSA       ;AND ENTER CHANGE ROUTINE
20700	;
20710	    PAGE
20720	    SUBTTL BASIC RUN TIME ROUTINES--CHMS
20730	;
20740	;   CHMS--CHANGE MAT TO STR.  THIS ROUTINE TAKES A MATRIX AND RETURNS A
20750	;      STRING.  THE ZEROTH ELEMENT OF VECTOR CONTAINS THE STRING LENGTH AND
20760	;      THE ITH ELEMENT CONTAINS THE ITH CHARACTER VALUE.
20770	;
20780	;
20790	 CHMS.:Z
20800	    MOVE   R1,@0(T)    ;PICK UP MAT PTR
20810	    XFIX   R0,0(R1)   ;PICK UP ZEROTH ELEMENT
20820	    JUMPE  R0,CHMS1    ;HANDLE NULL RETURN
20830	    HLRZ R1,@0(T) ;GET MAX SIZE FOR ARRAY
20840	    SKIPL R0 ;DIM MUST BE >0
20850	    CAML R0,R1 ;CHECK IF IT WILL FIT
20860	    ERR    E.CHNG      ;ERROR IF NOT
20870	    JSA    T,SALOC.    ;ELSE IF FIT, ALLOCATE STRING
20880	;
20890	 CHMSA:
20900	    EXCH   R1,@1(T)    ;STORE STRING TALLY AS RESULT
20910	    JSA    T,XDLOC.    ;GET RID OF OLD TALLY
20920	    MOVE   R1,@1(T)    ;RESTORE SAVED TALLY
20930	    MOVEM R1,RGSV.     ;SAVE R1
20940	    HLRZ   R1,-1(R1)   ;GET LENGTH
20950	    HRRZ R2,@0(T) ;GET POINTER TO MAT DATA
20960	    ADD    R2,[XWD 444400,1] ;CREAT WORD TALLY
20970	;
20980	 CHMS2:
20990	    ILDB   R0,R2       ;PICK UP NEXT WORD
21000	    XFIX R0 ;XFIX IT
21010	    IDPB   R0,RGSV.       ;SAVE IN STRING
21020	    SOJG   R1,CHMS2      ;LOOP UNTIL DONE
21030	    JRA    T,2(T)      ;AND THEN RETURN
21040	;
21050	 CHMS1:
21060	    MOVEI  R1,0        ;RETURN NULL STRING
21070	    EXCH   R1,@1(T)    ;SAVE AND GET OLD VALUE
21080	    JSA    T,XDLOC.    ;DEALLOCATE OLD ALUE
21090	    JRA    T,2(T)      ;AND RETURN
21100	;
21110	;
21120	;   ERROR MESSAGE
21130	;
21140	E.CHNG: ER NRM,CHANGE error
21150	;
21160	    PAGE
21170	    SUBTTL END OF ASSEMBLY
21180	;
21190	;
21200	;
21210	    PRGEND
21220	    TITLE   CSM -- BASIC RUN TIME ROUTINES--CHANGE STRING TO VECTOR
21230	    SUBTTL ASSEMBLY CONTROL
21240	    SEARCH STENEX,BGBL,BRSYMS
21250	;
21260	;
21270	;
21280	    ENTER CBSM.,CHSM.
21290	;
21300	;
21310	    EXTERNAL RGSV.
21320	;
21330	;
21340	;
21350	;
21360	    PAGE
21370	    SUBTTL BASIC RUN TIME ROUTINES--CHANGE BIT STRING TO VECTOR
21380	;
21390	;   CBSM--THIS ROUTINE TAKES A STRING AND PUTS IT CHARACTER BY CHARACTER
21400	;      INTO THE SPECIFIED VECTOR.  THE BIT SIZE IS TAKEN AS THE FIRST
21410	;      ARGUMENT.  THE ZEROTH ELEMENT OF THE VECTOR WILL CONTAIN THE
21420	;      LENGTH OF THE STRING IN BITS OF THE SPECIFIED SIZE.
21430	;
21440	;
21450	 CBSM.:Z
21460	    AOS    T           ;BUMP RETURN SO WE LOOK LIKE CHANGE
21470	    MOVE   R1,@0(T)    ;PICK UP STRING POINTER
21480	    MOVEM  R1,CBSTM#   ;SAVE IT
21490	    JUMPE  R1,CHSM.+1     ;HANDLE NUULL STRING
21500	    LSH    R1,-6-22    ;ELSE GET BYTE SIZE
21510	    ANDI   R1,77       ;SAVE IT ALONE IN R1
21520	    XFIX   R2,@-1(T)   ;PICK UP BYTE SIZE
21530	    CAMN   R1,R2       ;CHECK IF SAME
21540	    JRST   CHSM.+1     ;PROCESS  NORMALLY IF SO
21550	;
21560	;   BYTE SIZES DIFFER--MUST RECOMPUTE
21570	;
21580	    MOVEM R3,RGSV.+3 ;SAVE R3
21590	    MOVEM R4,RGSV.+4 ;R4
21600	    MOVEM R5,RGSV.+5 ;R5
21610	    MOVEM R6,RGSV.+6 ;AND R6
21620	    MOVEI  R3,44       ;GET WORD SIZE IN R3
21630	    IDIV   R3,R1       ;GET #BYTES/WD IN R3
21640	    MOVE   R4,CBSTM    ;GET STRING TALLY IN R4
21650	    HLRZ   R4,-1(R4)   ;GET BYTE COUNT
21660	    IDIV   R4,R3       ;#WDS TO R4, #EXTRA BYTES TO R5
21670	    IMUL   R5,R1       ;#EXTRA BITS TO R5
21680	;
21690	    MOVEI  R6,44       ;WORD SIZE TO R6
21700	    IDIV   R6,R2       ;#BYTES/WD TO R6
21710	    IMULM  R6,R4       ;#BYTES IN FULL WDS TO R4
21720	    IDIV   R5,R2       ;#BYTES IN EXCESS TO R5
21730	    SKIPE  R6          ;CHECK IF MORE
21740	    AOS    R5          ;DON'T LOSE DATA
21750	    ADD    R4,R5       ;GET TOTAL NUMBER OF BYTES
21760	    MOVE   R0,R4       ;MOVE TO R0
21770	    LSH    R2,6        ;NEW BYTE SIZE TO TALLY POS
21780	    HRLI   R1,440000(R2) ;NEW TALLY TO STRING
21790	    HRR    R1,CBSTM    ;WITH OLD POINTER
21800	    MOVE R3,RGSV.+3 ;RESTORE R3
21810	    MOVE R4,RGSV.+4 ;R4
21820	    MOVE R5,RGSV.+5 ;R5
21830	    MOVE R6,RGSV.+6 ;AND R6
21840	    JRST   CHSMA       ;PROCESS WITH CONT IN R0, PTR IN R1
21850	;
21860	    PAGE
21870	    SUBTTL BASIC RUN TIME ROUTINES--CHANGE STRING TO VECTOR
21880	;
21890	;   CHSM--THIS ROUTINE TAKES A STRING AND PUTS IT ON A CHARACTER BASIS
21900	;      INTO THE SPECIFIED VECTOR.  THE ZEROTH ELEMENT OF THE VECTOR WILL
21910	;      CONTAIN THE LENGTH OF THE STRING.  THE STRING IS TAKEN AS
21920	;      WHATEVER BYTE SIZE IS WAS CREATED AS.
21930	;
21940	;
21950	 CHSM.:Z
21960	    MOVE   R1,@0(T)    ;PICK UP STRING POINTER
21970	    JUMPE  CHSM1       ;HANDLE NULL STRING
21980	    HLRZ   R0,-1(R1)   ;GET CHARACTER COUNT IN R0
21990	;
22000	 CHSMA:
22010	    MOVEM R1,RGSV.     ;SAVE TALLY
22020	    MOVE   R2,1(T)    ;GET MATRIX POINTER
22030	    HLRZ   R1,0(R2)   ;DIMS
22040	    MOVEM  R1,1(R2)   ;SAVE FULL VECTOR
22050	    CAML  R0,R1       ;CHECK FOR FIT
22060	    ERR    E.CHNG      ;ERROR IF NOT
22070	    MOVE   R1,R0       ;MOVE COUNT
22080	    MOVE   R2,0(R2)    ;GET POINTER TO VECTOR DATA
22090	    HRLI   R2,444400   ;MAKE IT INTO WORD TALLY
22100	    FSC    R1,233      ;FLOAT COUNT
22110	    IDPB   R1,R2       ;SAVE IT
22120	    ILDB   R1,RGSV.       ;PICK UP NEXT CHARACTER
22130	    SOJGE   R0,.-3      ;CONTINUE TILL DONE
22140	    JRA    T,2(T)      ;AND THEN RETURN
22150	;
22160	 CHSM1:
22170	    MOVEI  R2,@1(T)   ;GET MATRIX PTR
22180	    HLRZ   R1,0(R2)   ;GET DIMS
22190	    MOVEM  R1,1(R2)   ;EXTPRGEND MAT DIIMS TO FULL
22200	    MOVE R2,0(R2)	;GET PTR TO ZERO ELEMENT
22210	    SETZM 0(R2)		;AND SET TO ZERO FOR NULL
22220	    JRA    T,2(T)      ;AND RETURN
22230	;
22240	;
22250	;   ERROR MESSAGE
22260	;
22270	E.CHNG: ER NRM,CHANGE error
22280	;
22290	    PAGE
22300	    SUBTTL END OF ASSEMBLY
22310	;
22320	;
22330	;
22340	    PRGEND
22350	    TITLE  FILE. -- BASIC RUN TIME FILE ROUTINES--FILE STATEMENT
22360	    SUBTTL ASSEMBLY CONTROL
22370	    SEARCH STENEX,BGBL,BRSYMS
22380	;
22390	;
22400	;
22410	    ENTER FILE.
22420	;
22430	;
22440	    EXTERNAL E.FLR1,E.FTYP,RGSV.,CLOSE.,NSCFL.,CRTTY.
22450	    EXTERNAL TMPTL.,TMPBF.
22460	;
22470	;
22480	;
22490	;
22500	    PAGE
22510	    SUBTTL BASIC RUN TIME FILE ROUTINES--FILE
22520	;
22530	;   FILE--THIS ROUTINE IS CALLED WITH A CURRENT FILE PRESUMED AND ONE
22540	;      STRING ARGUMENT.  THIS STRING CONTAINS THE FILE NAME OF THE
22550	;      FILE TO BE OPENED FOR THE FILE NUMBER.  ANY OLD FILES ARE CLOSED
22560	;      FIRST.  A NAME OF '0' OPENS A SCRATCH FILE.  THE FILE IS ASSUMED
22570	;      TO BE AN OLD VERSION IF POSSIBLE.
22580	;
22590	;
22600	 FILE.:Z
22610	    CAIN FL,CRTTY.	;CHECK IF USER CHANGING TTY
22620	    ERR E.TTY		;GIVE ERROR IF SO
22630	    MOVE   R2,@0(T)    ;GET STRING TALLY
22640	    JSA T,CLOSE. ;CLOSE THE OLD FILE IF THERE IS ONE
22650	    MOVSI R1,FB.OUR	;GET BITS
22660	    ANDCAM R1,F.BTS(FL)	;AND CLEAR THEM
22670	    SETZM F.ERR(FL)	;NO ERROR IN OPEN
22680	    SETZM F.WLN(FL)	;NO BLOCK LENGTH/STRING FOR NAME
22690	  HRRZ R1,F.JFN(FL)	;CHECK IF FILE HAS JFN
22700	  SKIPE R1
22710	  RLJFN			;AND RELEASE IT IF SO
22720	    TRN
22730	  SETZM F.JFN(FL)	;CLEAR OLD JFN
22740	  MOVEM R3,RGSV.	;AND SAVE R3
22750	;
22760	 FILE1:
22770	    HLRZ   R0,0(R2)    ;CHECK FIRST BITS OF STRING
22780	    CAIN   R0,(ASCII "*")   ;CHECK FOR '*'
22790	    JRST   FILE2       ;HANDLE IF SO
22800	    HRLZI  R1,1        ;OPTIONS FOR GETJFN--FROM STRING
22810	    MOVEM R2,RGSV.	;SAVE INITIAL STRING PTR
22820	    GTJFN              ;GET THE FILE JFN
22830	    JRST   FILE3       ;HANDLE ERROR ON GET JFN
22840	;
22850	 FILE4:
22860	    MOVEM  R1,F.JFN(FL) ;SAVE NEW JFN
22870	    HRLM R1,F.JFN(FL) ;SAVE AS INP AND OUT JFNS
22880	    SETOM F.MAR(FL) ;UNDEFINED MARGIN
22890	    MOVEI R2,7 ;DEFAULT BYTE SIZE=7
22900	    SVBYSZ R2 ;SAVE
22910	    DVCHR		;CHECK FILE
22920	    TLNN R1,600000	;FOR TTY
22930	      JRST FILTTY	;HANDLE TTY
22940	    HRRZ R1,F.JFN(FL)	;HANDLE FILE--RESTORE JFN
22950	    SIZEF              ;GET SIZE OF FILE
22960	    ERR    E.FLR1      ;ERROR IF CAN'T
22970	    JUMPE  R2,FILE8    ;EMPTY FILE--HANDLE
22980	    MOVE   R2,[XWD 1,24] ;ELSE GET PTR TO USER WORD IN FD BLOCK
22990	    MOVEI  R3,R0       ;PTR TO LOC FOR IT
23000	    GTFDB              ;GET THE OLD CONTENTS OF THAT WORD IN  R4
23010	    MOVE R3,RGSV. ;RESTORE R3
23020	;
23030	;   HANDLE TYPE CHECKING
23040	;
23050	  HLRZ R2,R0  ;GETUPPER HALF OF USER WORD
23060	  HRRZS R0 ;ISOLATE LOWER HALF
23070	  CAIE R2,-1 ;CHECK UPPER HALF FOR BEING OURS
23080	    JRST FILE5 ;UNTYPED
23090	  JUMPE R0,FILE6 ;ASCII IF -1,,0
23100	  CAIN R0,-1 ;RNUM IF -1,,-1
23110	    JRST FILE7 ;HANDLE RNUM
23120	  CAILE R0,2000*5 ;RSTR IF -1,<MRGN>
23130	    JRST FILE5 ;ILLEGAL MRGN--CANT BE RSTR
23140	;
23150	  MOVEI R2,44 ;RANDOM STRING FILE
23160	  SVBYSZ R2 ;SAVE BYTE SIZE OF 36
23170	  MOVEM R4,F.MAR(FL) ;SAVE MARGIN AS GIVEN
23180	  MOVEI R0,4+5(R4) ;BLOCK SIZE +1WD IN CHRS
23190	  IDIVI R0,5 ;GET BLOCK SIZE IN WDS
23200	  MOVEM R0,F.WLN(FL) ;AND SAVE
23210	  MOVSI R2,FB.RST ;BIT FOR RSTR
23220	  JRST FILE9 ;AND HANDLE
23230	;
23240	 FILE7:
23250	  MOVEI R2,44 ;RANDOM NUMERIC FILE
23260	  SVBYSZ R2 ;SAVE BYTE SIZE OF 36
23270	  MOVEI R2,1 ;DEFAULT MARGIN OF 1
23280	  MOVEM R2,F.MAR(FL) ;SAVE
23290	  MOVEM R2,F.WLN(FL)	;SAVE AS BLOCK LENGTH
23300	  MOVSI R2,FB.RNM ;BIT FOR RNDM NUM
23310	  JRST FILE9 ;AND HANDLE
23320	;
23330	 FILE6:
23340	  MOVEI R2,113 ;ASCII FILE
23350	  MOVEM R2,F.MAR(FL) ;SAVE MARGIN OF 75
23360	  SETZM F.LNM(FL) ;NO LINE NUMBER/PAGE NUMBER
23370	  MOVSI R2,FB.ASC ;TYPE OF ASCII
23380	  JRST FILE9 ;AND HANDLE
23390	;
23400	 FILE8:
23410	  MOVSI R2,FB.UDF+FB.EPY ;EMPTY FILE--UNTYPE
23420	  JRST FILE9 ;AND HANDLE
23430	;
23440	 FILE5:
23450	  MOVSI R2,FB.UDF ;NON-EMPTY, UNDEFINED TYPE OF FILE
23460	;
23470	 FILE9:
23480	  IORM R2,F.BTS(FL) ;SET FILE TYPE IN BITS
23490	  JRA T,1(T) ;AND RETURN
23500	;
23510	;   HANDLE '*' FILES
23520	;
23530	 FILE2:
23540	    MOVSI R2,FB.TMP ;GET BIT FOR TMP FILE
23550	    MOVEM R2,F.BTS(FL) ;AND SAVE
23560	;
23570	 FILE2A:
23580	  AOS R2,NSCFL.		;GET UNIQUE NUMBER FOR THIS RUN
23590	  MOVE R1,TMPTL.	;PTR TO NAME AREA
23600	  MOVE R3,[XWD 160003,12] ;NOUT FIELDS
23610	  NOUT			;GET UNIQUE NUMBER
23620	    TRN			;IGNORE FIELD OVERFLOW
23630	  MOVE R2,[POINT 7,[ASCIZ /BAS.BTM/]] ;REST OF NAME
23640	  ILDB R3,R2	;GET A CHR
23650	  IDPB R3,R1		;AND SAVE IN NAME
23660	  JUMPN R3,.-2		;LOOP UNTIL DONE
23670	  HRLZI R1,610001	;WANT A NEW SCRATCH FILE
23680	  MOVE R2,TMPTL.	;PTR TO NAME
23690	  GTJFN			;TRY TO GET IT
23700	    SKIPA		;SKIP ON FAIL
23710	  JRST FILE2B		;PROCESS ON SUCCESS
23720	  CAIN R1,GJFX27	;CHECK FOR NOT NEW
23730	    JRST FILE2A		;IN THAT CASE, RETRY OPEN
23740	  JRST FILER		;AND HANDLE FAIL
23750	;
23760	 FILE2B:
23770	  SIZEF			;CHECK SIZE OF GOTTEN FILE
23780	    BLOWUP		;BETTER BE ABLE TO
23790	  IOR R2,R3		;SEE IF ANYONE FOOLED WITH IT ERE
23800	  JUMPE R2,FILE4	;NO--THEN USE IT
23810	  RLJFN			;YES--GET RID OF IT
23820	    BLOWUP
23830	  JRST FILE2A		;AND TRY AGAIN
23840	;
23850	 FILE3:
23860	    MOVEM  R1,F.ERR(FL) ;SAVE ERROR NUMBER ON BAD OPEN
23870	    MOVE R2,RGSV.	;RESTORE STRING PTR
23880	    HRLZI R1,400001	;OPEN AS NEW FILE IF FIRST FAILS
23890	    GTJFN		;ATTEMPT GTJFN
23900	      SKIPA		;SKIP IF THIS ALSO FAILS
23910	    JRST FILE4		;IF OK, THEN USE THIS JFN
23920	;
23930	 FILER:
23940	  MOVEM R1,F.ERR(FL)	;SAVE JSYS ERROR NUMBER
23950	  SKIPN R1,RGSV.	;GET NAME TALLY
23960	    AOS -1(R1)		;KEEP STRING IF POSSIBLE
23970	  MOVEM R1,F.WLN(FL)	;SAVE STRING FOR ERROR MESSAGES
23980	    JRST FILE8		;AND SET TYPE AND RETURN
23990	;
24000	 FILTTY:
24010	  MOVEI R2,113		;HANDLE TTYS
24020	  MOVEM R2,F.MAR(FL)	;SET INITIAL MARGIN
24030	  MOVSI R2,FB.TTY+FB.ASC ;TYPE
24040	  JRST FILE9		;AND HANDLE
24050	;
24060	;
24070	;   ERROR MESSAGES
24080	;
24090	E.TTY: ER NRM,Illegal file number
24100	;
24110	;
24120	    PAGE
24130	    SUBTTL END OF ASSEMBLY
24140	;
24150	;
24160	;
24170	    PRGEND
24180	    TITLE  FSET. -- BASIC RUN TIME ROUTINES--FILE SET UP
24190	    SUBTTL ASSEMBLY CONTROL
24200	    SEARCH STENEX,BGBL,BRSYMS
24210	;
24220	;
24230	;
24240	    ENTER FSET.
24250	;
24260	;
24270	    EXTERNAL FLPTR.,BLOC.
24280	;
24290	;
24300	;
24310	;
24320	    PAGE
24330	    SUBTTL BASIC RUN TIME FILE ROUTINES--FSET
24340	;
24350	;   FSET--THIS ROUTINE IS CALLED WITH ONE ARGUMENT, A FILE NUMBER
24360	;      AND ITS PURPOSE IS TO SET THAT FILE AS THE CURRENT FILE.  IF THE
24370	;      FILE HASN'T BEEN USED BEFORE, A FILE CONTROL BLOCK IS SET UP
24380	;      FOR IT.  THE FCB POINTER IS LEFT IN 'FL' ON EXIT.
24390	;
24400	;
24410	 FSET.:Z
24420	    MOVEM  R2,FSETM#   ;SAVE R2
24430	    MOVE   R0,@0(T)    ;PICK UP FILE NUMBER OF ARG
24440	    JSA    T,FLPTR.    ;GET POINTER TO FILE
24450	    JRST   FSET1       ;HANDLE IF FIRST TIME
24460	;
24470	    MOVEM R0,FL ;SAVE NEW ONE
24480	    MOVE   R2,FSETM    ;RESTORE R2
24490	    JRA    T,1(T)      ;AND RETURN
24500	;
24510	 FSET1:
24520	    MOVEI  R0,FLBLN        ;LENGTH OF FCB
24530	    JSA    T,BLOC.     ;ALLOCATE BLOCK
24540	    HRRZ   R2,FILTB.(V)   ;GET FILE TABLE PTR
24550	    SKIPE  0(R2)       ;CHECK FOR NULL ENTRY
24560	    AOJA   R2,.-1      ;SOMEWHERE IN BLOCK
24570	    MOVE   R0,R2       ;GET FINAL PTR
24580	    SUB    R0,FILTB.(V)   ;CHECK IF TOO MANY FILES
24590	    HRLZS R0 ;NUMBER TO UPPER HALF
24600	    CAML  R0,FILTB.(V)       ;WHICH IS 30
24610	    ERR    E.NFLS      ;ERROR IF SO
24620	    MOVEM  R1,0(R2)    ;ELSE SAVE PTR TO BLOCK
24630	    MOVEM  R1,FL   ;SAVE NEW ONE
24640	    EXCH   R2,FSETM    ;RESTORE R2
24650	    XFIX   R0,@0(T)    ;PICK UP ARG AGAIN
24660	    HRLM   R0,@FSETM   ;SAVE FILE NUMBER IN PTR
24670	    JRA    T,1(T)      ;AND RETURN
24680	;
24690	;
24700	;   ERROR MESSAGE
24710	;
24720	E.NFLS: ER NRM,Too many files
24730	;
24740	    PAGE
24750	    SUBTTL END OF ASSEMBLY
24760	;
24770	;
24780	;
24790	    PRGEND
24800	TITLE IFEND. -- BASIC RUN TIME FILE ROUTINES--END/MORE CHECK
24810	SUBTTL ASSEMBLY CONTROL
24820	SEARCH STENEX,BGBL,BRSYMS
24830	;
24840	;
24850	;
24860	  ENTER IFEND.,IFMOR.
24870	;
24880	  EXTERNAL FLPTR.,E.FNOP,E.FTYP,E.FLNO
24890	;
24900	;
24910	;
24920	    PAGE
24930	SUBTTL BASIC RUN TIME FILE ROUTINES--IFEND.
24940	;
24950	;   IFEND.--THIS ROUTINE CHECKS FOR THE END OF AN ASCII FILE.
24960	;      IT CHECKS THE TYPE OF FILE (TTY,ASCII,EMPTY,...) AND
24970	;      ALSO THE EOF FLAG FOR THE FILE (SET BY LAST INPUT
24980	;      READING AHEAD).
24990	;
25000	;
25010	IFEND.: Z
25020	;
25030	  MOVE R0,@0(T) ;GET ARG (FILE NUMBER
25040	  JSA T,TSEND ;CALL ROUTINE TO HANDLE
25050	    JRA T,1(T) ;END--RETURN END
25060	    JRA T,2(T) ;MORE--RETURN NOT END
25070	;
25080	;
25090	    PAGE
25100	SUBTTL BASIC RUN TIME FILE ROUTINES--IFMOR.
25110	;
25120	;   IFMOR.--THIS ROUTINE CHECKS FOR THE END OF AN ASCII FILE.
25130	;      IT IS THE EXACT OPPOSITE OF IF END (USING A COMMON ROUTINE)
25140	;      BUT SKIPS IF AT THE END RATHER THAN IF NOT.
25150	;
25160	;
25170	IFMOR.: Z
25180	;
25190	  MOVE R0,@0(T) ;PICK UP FILE NUMBER
25200	  JSA T,TSEND ;CHECK IF END
25210	    JRA T,2(T) ;END--RETURN NO MORE
25220	    JRA T,1(T) ;MORE--RETURN MORE
25230	;
25240	;
25250	    PAGE
25260	SUBTTL BASIC RUN TIME FILE ROUTINES--TSEND
25270	;
25280	;   TSEND--THIS IS THE ROUTINE USED BY IFEND AND IFMORE TO
25290	;      CHECK FOR THE END OF AN ASCII FILE.
25300	;
25310	;
25320	TSEND: Z
25330	;
25340	  JSA T,FLPTR. ;GET POINTER TO FILE BUFFER
25350	    ERR E.FLNO ;MUST BE THERE
25360	  MOVE FL,R0 ;GET PTR IN FL
25370	;
25380	  MOVE R0,F.BTS(FL) ;GET BITS OF FILE
25390	  TLNE R0,FB.TTY ;CHECK FOR TTY
25400	    JRA T,1(T) ;ALWAYS MORE TTY
25410	  TLNE R0,FB.ASC ;CHECK FOR ASCII
25420	    JRST TSEND1 ;HANDLE IF SO
25430	  TLNE R0,FB.RST!FB.RNM ;CHECK FOR RANDOM
25440	    ERR E.FTYP ;ERROR IF SO
25450	;
25460	  SKIPN F.JFN(FL) ;CHECK IF FILE EXISTS IF UNTYPED
25470	    ERR E.FNOP ;NO--ERROR
25480	  TLNE R0,FB.EPY ;CHECK IF FILE EMPTY
25490	    JRA T,0(T) ;YES--END OF FILE
25500	  JRA T,1(T) ;NO--HAVEN'T USED NON EMPTY FILE--NOT END
25510	;
25520	 TSEND1:
25530	  SKIPE F.EOF(FL) ;CHECK IF END
25540	    JRA T,0(T) ;YES--RETURN END
25550	  JRA T,1(T) ;NO--RETURN MORE
25560	;
25570	;
25580	    PAGE
25590	SUBTTL END OF ASSEMBLY
25600	;
25610	;
25620	;
25630	  PRGEND
25640	    TITLE INPUT. -- BASIC RUN TIME FILE ROUTINES--INPUT
25650	    SUBTTL ASSEMBLY CONTROL
25660	    SEARCH STENEX,BGBL,BRSYMS
25670	;
25680	;
25690	;
25700	    ENTER INDON.,INDNC.,INNUM.,INSET.,INSTR.,LNSTR.
25710	;
25720	;
25730	    INTER INSMX.,INSLN.
25740	;
25750	;
25760	    EXTERNAL EOFFG.,RGSV.,TMPTL.,TYPAS.,E.EOF,OPNFL.,CRTTY.
25770	    EXTERNAL INRST.,XDLOC.,BLOC.,INAMP.,STOP.,CNTOF.
25780	;
25790	;
25800	;
25810	;
25820	    PAGE
25830	SUBTTL INPUT MACROS
25840	;
25850	;
25860	;
25870	;   LKAMP--CHECK CHR FOR '&' AT EOL
25880	;
25890	DEFINE LKAMP (RG,ADDR)
25900	<
25910		CAIN RG,"&" ;CHECK FOR AMPERSAND
25920		JSA T,CKAMP ;IF SO, CHECK IF VALID
25930		SKIPA ;IF NOT VALID, OR NOT AMPERSAND, SKIP
25940		JRST ADDR ;IF AMPERSAND AND VALID, USE
25950	>
25960	;
25970	;
25980	PAGE
25990	    SUBTTL BASIC RUN TIME FILE ROUTINES--INDON
26000	;
26010	;   INDON--THIS IS THE NORMAL DONE INPUT ROUTINE WHICH CAUSES THE RESET
26020	;      OF THE CURRENT LINE TO BE IGNORED ON INPUT FROM ASCII FILE OR TTY.
26030	;
26040	;
26050	 INDON.:Z
26060	  MOVE R0,F.BTS(FL) ;GET FILE BITS
26070	  TLNN R0,FB.TTY ;CHECK FOR TTY
26080	    JRST INDNF ;HANDLE FILE
26090	;
26100	  MOVE R1,F.TRM(FL) ;GET TERM OF LAST LINE
26110	  CAIE R1,ASCEOL ;CHECK FOR EOL
26120	    ERR E.TMCH ;ERROR IF NOT
26130	  SETZM F.CHCT(FL) ;IGNORE REST OF LINE (=REST OF BUFFER)
26140	  MOVEI R2,37 ;EOL
26150	  HRRZ R1,F.JFN(FL) ;JFN FOR TTY
26160	  SKIPE ECHOFG	;CHECK IF ECHOING
26170	    BOUT ;RESPOND TO INPUT
26180	  SETZM F.CPOS(FL) ;BEGINING OF LINE FOR OUTPUT
26190	  JRA T,0(T) ;AND DONE
26200	;
26210	 INDNF:
26220	  MOVE R1,F.TRM(FL) ;CHECK TERMINATOR FOR FILE
26230	  CAIN R1,ASCEOL ;FOR EOL
26240	    JRST INDNF1
26250	;
26260	 INDNF2:
26270	  JSA T,INCHR. ;GET ANOTHER CHR
26280	  CAIE R2,ASCEOL ;CHECK FOR EOL NOW
26290	    JRST INDNF2 ;LOOP UNTIL EOL
26300	;
26310	 INDNF1:
26320	  SETOM EOFFG. ;ALLOW END OF FILE
26330	  JSA T,INCHR. ;READ AN EXTRA CHR
26340	  MOVS R2,F.ITAL(FL) ;GET TALLY
26350	  ADDI R2,070000 ;BACK UP ONE CHR
26360	  MOVSM R2,F.ITAL(FL) ;AND RESAVE TALLY
26370	  SOS F.CHCT(FL) ;BACK UP COUNT TOO
26380	  JRA T,0(T) ;THEN DONE
26390	;
26400	;   ERROR MESSAGE
26410	;
26420	E.TMCH: ER WRN,Too much input--excess ignored
26430	;
26440	    PAGE
26450	    SUBTTL BASIC RUN TIME FILE ROUTINES--INDNC
26460	;
26470	;   INDNC--THIS ROUTINE IS SIMILAR TO INDON EXCEPT THAT IT CAUSES THE
26480	;      NEXT INPUT STATEMENT FOR THIS FILE TO CONTINUE READING FROM THE
26490	;      SAME LINE OF DATA.
26500	;
26510	;
26520	 INDNC.:Z
26530	    MOVE   R1,F.TRM(FL) ;CHECK TERMINATOR
26540	    CAIN   R1,ASCCMA   ;CHECK FOR COMMA
26550	    JRA    T,0(T)      ;IF SO, JUST RETURN
26560	    JRST   INDON.+1    ;ELSE HANDLE AS NORMAL INPUT DONE
26570	;
26580	    PAGE
26590	    SUBTTL BASIC RUN TIME FILE ROUTINES--INNUM
26600	;
26610	;   INNUM--THIS ROUTINE READS A NUMBER FROM THE CURRENT FILE.  THIS IS
26620	;      DONE BY READING CHARACTERS INTO THE TMPBF BUFFER UNTILE A TERMIN-
26630	;      ATOR IS FOUND AND THEN USING FLIN TO CONVERT.  SPACES INSIDE THE
26640	;      NUMBER ARE IIGNORED AS ARE LEADING COMMAS.   ALL REGISTERS ARE
26650	;      PRESERVED OVER THE CALL.
26660	;
26670	;
26680	 INNUM.:Z
26690	    HRRZI  R0,RGSV.    ;GET REGISTER SAVE AREA POINTER
26700	    BLT    R0,RGSV.+6  ;SAVE R0...R6
26710	    HLRZ   R1,F.JFN(FL) ;GET JFN OF FILE
26720	    MOVEI  R4,0        ;CLEAR CHARACTER COUNT
26730	    MOVE   R3,TMPTL.   ;GET TEMP TALLY
26740	;
26750	 INNM0:
26760	  JSA T,FSCHR 	;SCAN FIRST CHR--CHECK FOR LINE NUMBER
26770	;
26780	 INNM1:
26790	    JSA T,INCHR.       ;GET NEXT INPUT CHARACTER
26800	    CAIN   R2,ASCSPA   ;CHECK FOR SPACE
26810	    JRST   INNM1       ;IGNORE IF SO
26820	    CAIN   R2,ASCCMA   ;CHECK FOR COMMA
26830	    JRST   INNM2       ;HANDLE IF SO
26840	    CAIN   R2,ASCEOL   ;CHECK FOR END OF LINE
26850	    JRST   INNM4       ;HANDLE IF SO
26860	    LKAMP R2,INNM2 ;CHECK FOR AMPERSAND
26870	    AOS    R4          ;ELSE BUMP CHAR COUNT
26880	    IDPB   R2,R3       ;SAVE THE CHARACTER
26890	    JRST   INNM1       ;AND CONTINUE WITH NEXT CHARACTER
26900	;
26910	 INNM4:
26920	  JUMPN R4,INNM2	;IF NOT INITIAL CR, HANDLE NORMALLY
26930	  SKIPG INAMP.		;CHECK IF MAT V INPTU
26940	    JRST INNM2		;NO--NORMAL PROCESSING
26950	  MOVEM R2,F.TRM(FL)	;SAVE TERM
26960	  JRA T,1(T)		;AND RETURN
26970	;
26980	 INNM2:
26990	    JUMPE  R4,INNM0    ;IGNORE INITIAL TERMINATORS
27000	    MOVEM  R2,F.TRM(FL) ;SAVE FINAL TERM
27010	    MOVEI  R0,0        ;FINAL BYTE OF 0
27020	    IDPB   R0,R3       ;SAVE IT
27030	    MOVE   R1,TMPTL.   ;GET TALLY TO NUMBER AS SAVED
27040	    FLIN               ;CONVERT TO FLOATING POINT
27050	    JRST INNM3   ;HANDLE BAD FORMAT
27060	    CAME   R1,R3       ;CHECK IF USED WHOLE TALLY
27070	    ERR    E.INFT      ;ERROR IF NOT (TERM TO EXEC INSSTRING)
27080	    MOVE   R1,R2       ;GET NUMBER IN R1
27090	    HRLI   R0,RGSV.+2  ;GET REG SAVE AREA PTR
27100	    HRRI   R0,2        ;FOR REGS 2...6
27110	    BLT    R0,6        ;RESTORE THEM
27120	    MOVEM  R1,@0(T)    ;SAVE THE RESULTANT VALUE
27130	    JRA    T,1(T)      ;AND RETURN
27140	;
27150	 INNM3:
27160	  MOVE R0,@F.BUF(FL) ;GET FIRST WORD TYPED IN
27170	  LSH R0,7-44 ;GET FIRST CHARACTER ONLY
27180	  CAIN R0,"S" ;CHECK FOR "S"--USER WANTS TO STOP PROGRAM
27190	    JSA T,STOP. ;YES--STOP FOR HIM
27200	  MOVE R0,F.BTS(FL) ;CHECK TYPE
27210	  TLNN R0,FB.TTY ;FOR TTY
27220	    ERR E.INFT	;FILE ERROR
27230	  SETZM F.CHCT(FL)	;ALLOW MORE TTY INPUT
27240	  ERR E.INFR	;TTY ERROR (RESTART LINE)
27250	;
27260	;
27270	;   ERROR MESSAGES
27280	;
27290	E.INFR: ER <RES,MES,CRB>,Incorrect format--retry
27300	E.INFT: ER <FLM>,Incorrect format
27310	;
27320	;
27330	    PAGE
27340	    SUBTTL BASIC RUN TIME FILE ROUTINES--INSET
27350	;
27360	;   INSET--THIS ROUTINE SETS UP FOR INPUT BY INSURING THE FILE TYPE TO
27370	;      BE ASCII OR TTY; BY CHECKING FOR EOF; AND BY PROMPTING IF
27380	;      NECESSARY FOR THE TTY.
27390	;
27400	;
27410	 INSET.:Z
27420	    MOVEM R2,RGSV.	;SAVE R2
27430	    MOVEM T,INRST. ;SAVE INPUT RESTART ADDRESS
27440	    SETZM INAMP. ;USUALLY DON'T ALLOW '&' ON INPUT
27450	    MOVE   R0,INSLN.   ;GET INPUT STRING MINIMUM
27460	    CAMLE R0,INSMX. ;CHECK IF OK TO USE LAST FIGURE
27470	      MOVE R0,INSMX. ;NO--USE GIVEN MAX
27480	    MOVEM  R0,INSLN.   ;SAVE IT
27490	    CAIN FL,CRTTY.	;CHECK FOR TTY
27500	      SETZM CNTOF.	;IF SO, PREMIT OUTPUT AGAIN
27510	    JSA    T,TYPAS.    ;MAKE SURE FILE IS TYPE ASCII
27520	    JRA T,0(T) ;JUST RETURN FOR TTY
27530	    JSA T,OPNFL. ;OPEN THE FILE
27540	      EXP FB.RD ;FOR READING
27550	    SKIPE  F.EOF(FL)   ;CHECK FOR END OF FILE
27560	    ERR    E.EOF       ;ERROR IF SO
27570	    MOVE R2,RGSV.	;RESTORE R2
27580	    JRA    T,0(T)      ;DONE IF NOT
27590	;
27600	    PAGE
27610	    SUBTTL BASIC RUN TIME FILE ROUTINES--INSTR
27620	;
27630	;   INSTR--THIS ROUTINE DOES STRING INPUT FROM AN ASCII DEVICE.  IT EITHER
27640	;      READS A STRING OF CHARACTERS TERMINATED WITH A COMMA OR CR OR
27650	;      IT READS A STRING OF CHARACTERS STARTING WITH A QUOTE.
27660	;
27670	;
27680	 INSTR.:Z
27690	    HRRZI  R0,RGSV.    ;PTR TO REG SAVE AREA
27700	    BLT    R0,RGSV.+6  ;SAVE REGS 0..6
27710	    MOVE   R2,INSMX.   ;GET MAX INPUT LEN
27720	    CAMGE  R2,INSLN.   ;CHECK FOR CURRENT OR MAX USAGE
27730	    MOVEM  R2,INSLN.   ;SAVE THE ONE WERE USING
27740	    SETZM  SPCNT#      ;CLEAR COUNTER
27750	    JSA    T,INSTA     ;SET UP FOR STRING INPUT
27760	;
27770	;   HANDLE  NEXT CHARACTER
27780	;
27790	 INST0:
27800	  JSA T,FSCHR 	;SCAN FIRST CHR--CHECK FOR LINE NUMBERS
27810	;
27820	 INST1:
27830	    JSA T,INCHR. ;GET CHARACTER
27840	    JUMPN  R4,INST2    ;CHECK IF FIRST CHARACTER--JUMP IF NOT
27850	    CAIN   R2,ASCSPA   ;CHECK FOR SPACE
27860	    JRST   INST1       ;IGNORE INITIAL SPACES
27870	    CAIN   R2,ASCEOL   ;CHECCK FOR EOL
27880	    JRST   INST7       ;HANDLE INITIAL EOL
27890	    CAIN   R2,ASCCMA   ;CHECK FOR COMMA
27900	    JRST   INST1       ;IGNORE INITIAL COMMAS
27910	    CAIN   R2,ASCQTE   ;CHECK FOR INITIAL QUOTE
27920	    JRST   INST5       ;PROCESS IF SO
27930	    LKAMP R2,INST0 ;CHECK FOR AMPERSAND
27940	;
27950	;   SAVE CHAR
27960	;
27970	 INST3:
27980	    SKIPE  SPCNT       ;CHECK FLAG
27990	    JRST   INST9       ;PROCESS SPECIAL IF SPACES SKIPPED
28000	    JSA    T,INSVC     ;ELSE SAVE CHAR
28010	    JRST   INST1       ;AND GO ON TO NEXT CHARACTER
28020	;
28030	 INST7:
28040	  SKIPG INAMP.		;CHECK IF MAT V INPUT
28050	    JRST INST0		;PROCESS EOL NORMALLY (IGN)
28060	  MOVEM R2,F.TRM(FL)	;ELSE SAVE EOL TERM
28070	  JSA T,INSTB		;RELEASE STRING BLOCK
28080	  JRA T,1(T)		;AND RETURN NOT
28090	;
28100	 INST2:
28110	    CAIN   R2,ASCEOL   ;CHECK FOR EOL
28120	    JRST   INST4       ;DONE IF SO
28130	    CAIN   R2,ASCSPA   ;CHECK FOR SPACE
28140	    JRST   INST8       ;HANDLE IF SO
28150	    LKAMP R2,INST4 ;CHECK FOR AMPERSAND
28160	    CAIE   R2,ASCCMA   ;CHECK FOR COMMA
28170	    JRST   INST3       ;DONE IF SO
28180	;
28190	 INST4:
28200	    MOVEM  R2,F.TRM(FL) ;SAVE TERMINATOR
28210	    JSA    T,INSTB     ;FINISH UP STRING
28220	    HRLI   R0,RGSV.+2  ;RESTORE REGS 2...6
28230	    HRRI   R0,2
28240	    BLT    R0,6        ;FROM SAVED AREA
28250	    EXCH   R1,@0(T)    ;SAVE RESULTANT STRING
28260	    JSA    T,XDLOC.    ;DEALLOCATE OLD STRING
28270	    JRA    T,1(T)      ;AND RETURN
28280	;
28290	;   HANDLE QUOTED STRINGS
28300	;
28310	 INST5:
28320	    JSA T,INCHR.    ;GET CHR
28330	    CAIN   R2,ASCQTE   ;CHECK FOR QUOTE
28340	    JRST   INST6       ;HANDLE IF SO
28350	    CAIN   R2,ASCEOL   ;CHECK FOR EOL
28360	    ERR    E.NQTE      ;ERROR IF SO
28370	    JSA    T,INSVC     ;ELSE SAVE THE CHAR
28380	    JRST   INST5       ;AND GO ON TO NEXT CHAR
28390	;
28400	 INST6:
28410	    JSA T,INCHR.    ;GET CHR
28420	    CAIN   R2,ASCSPA   ;CHECK FOR SPACE
28430	    JRST   INST6       ;IGNORE IF SO
28440	    CAIN   R2,ASCEOL   ;CHECK FOR EOL
28450	    JRST   INST4       ;END IF SO
28460	    CAIN   R2,ASCCMA   ;CHECK FOR COMMA
28470	    JRST   INST4       ;END IF SO
28480	    LKAMP R2,INST4 ;CHECK FOR AMPERSAND
28490	    MOVE R0,F.BTS(FL) ;CHECK TYPE OF FILE
28500	    TLNE R0,FB.TTY ;FOR TTY
28510	    ERR E.INFR ;TTY ERROR
28520	    ERR    E.INFT      ;ELSE EXCESS CHARACTERS
28530	;
28540	 INST8:
28550	    AOS    SPCNT       ;SET ON FLAG FOR SPACE COUNTING
28560	    JRST INST1 ;AND CONTINUE
28570	;
28580	 INST9:
28590	    MOVEM  R2,INSTM#   ;SAVE CHAR
28600	    MOVEI  R2,ASCSPA   ;GET A SPACE
28610	    JSA    T,INSVC     ;SAVE IT
28620	    SOSE   SPCNT       ;DECREMENT COUNT
28630	    JRST   .-3         ;CONTINUE UNTIL DONE
28640	    MOVE   R2,INSTM    ;RESTORE CHAR
28650	    JRST   INST3       ;AND CONTINUE
28660	;
28670	;
28680	;   ERROR MESSAGES
28690	;
28700	E.NQTE: ER <FLM,RES>,Missing closed quote for string
28710	;
28720	;
28730	    PAGE
28740	    SUBTTL BASIC RUN TIME FILE ROUTINES--LNSTR
28750	;
28760	;   LNSTR--THIS ROUTINE HANDLES THE LINPUT STATEMENT FOR STRINGS.  IT BASIC-
28770	;      ALLY GOBBLES UP A WHOLE (OR THE REST OF) LINE OF THE FILE/TTY.
28780	;
28790	;
28800	 LNSTR.:Z
28810	    HRRZI  R0,RGSV.    ;SAVE REGS
28820	    BLT    R0,RGSV.+6  ;R0...R6
28830	    MOVE   R2,INSMX.   ;GET INPUT STRING BLOCK LEN
28840	    CAMGE  R2,INSLN.   ;MATCH
28850	    MOVEM  R2,INSLN.   ;DECIDE ON LENGTH TO USE
28860	    JSA    T,INSTA     ;SET UP FOR STRING INPUT
28870	    HLRZ   R1,F.JFN(FL) ;GET JFN OF FILE
28880	;
28890	;   GET FIRST CHARACTER
28900	;
28910	  JSA T,FSCHR 		;SCAN FIRST CHR, CHECK FOR LINE #
28920	;
28930	 LNST1:
28940	    JSA T,INCHR.  ;GET CHR FROM FILE/TTY
28950	    CAIN   R2,ASCNUL   ;CHECK FOR NULL
28960	    JRST   LNST1       ;IGNORE IF SO
28970	    CAIN   R2,ASCEOL   ;CHECK FOR EOL
28980	    JRST   LNST2       ;HANDLE IF SO
28990	    JSA    T,INSVC     ;ELSE SAVE CHAR
29000	    JRST   LNST1       ;AND GO ON TO NEXT CHAR
29010	;
29020	 LNST2:
29030	    MOVEM  R2,F.TRM(FL) ;SAVE TERMINATOR
29040	    JSA    T,INSTB     ;FINISH OFF STRING
29050	    HRLI   R0,RGSV.+2  ;RESTORE REGS R2...R6
29060	    HRRI   R0,2
29070	    BLT    R0,6        ;FROM SAVED AREA
29080	    EXCH   R1,@0(T)    ;SAVE NEW VALUE
29090	    JSA    T,XDLOC.    ;GET RID OF OLD ONE
29100	    JRA    T,1(T)      ;AND RETURN
29110	;
29120	    PAGE
29130	    SUBTTL BASIC RUN TIME FILE SUBROUTINES--INSTA
29140	;
29150	;   INSTA--THIS ROUTINE SETS UP FOR STRING INPUT.  IT GETS A STRING BLOCK
29160	;      OF THE APPROPRIATE LENGTH AND SETS UP THE TALLY AND THE
29170	;      CHARACTER COUNT FOR LATER USE.
29180	;
29190	;
29200	 INSTA:Z
29210	    MOVE   R0,INSLN.   ;GET LENGTH
29220	    JSA    T,BLOC.     ;ALLOCATE BLOCK FOR STRING
29230	    MOVE   R6,INSLN.   ;GET LENGTH
29240	    SUBI   R6,1        ;MINUS ONE FOR HEADER
29250	    IMULI  R6,5        ;GET CHARA LEN
29260	    ADDI   R1,1        ;GET TALLY PTR
29270	    HRLI   R1,440700   ;FOR 7 BIT CHRS
29280	    MOVE   R5,R1       ;SAVE IN R5
29290	    MOVEM  R1,CRTAL#   ;SAVE THE TALLY
29300	    MOVEI  R4,0        ;CHAR COUNT TO 0
29310	    JRA    T,0(T)      ;AND RETURN
29320	;
29330	    PAGE
29340	    SUBTTL BASIC RUN TIME FILE SUBROUTINES--INSVC
29350	;
29360	;   INSVC--THIS ROUTINE SAVES THE CHAR IN R2 IN THE CURRENT INPUT
29370	;      STRING.  IF THE STRING OVERFLOWS, THEN ANOTHER STRING IS ALLOCATED
29380	;      AND THE OLD STRING IS COPIED OVER.
29390	;
29400	;
29410	 INSVC:Z
29420	    CAMN   R4,R6       ;CHECK IF  ROOM IN STRING
29430	    JRST   INSVC1      ;HANDLE IF NOT
29440	;
29450	 INSVC2:
29460	    AOS    R4          ;UPDATE CHAR COUNT
29470	    IDPB   R2,R5       ;SAVE CHAR
29480	    JRA    T,0(T)      ;AND RETURN
29490	;
29500	;   NEED A LARGER BLOCK
29510	;
29520	 INSVC1:
29530	    MOVE   R3,R2       ;SAVE OLD CHAR
29540	    MOVE   R0,INSLN.   ;GET OLD LENGTH
29550	    LSH    R0,1        ;TIMES 2
29560	    ADDI   R0,1        ;PLUS 1
29570	    MOVEM  R0,INSLN.   ;SAVE AS NEW LENGTH
29580	    JSA    T,BLOC.     ;ALLOCATE NEW BLOCK
29590	    ADDI   R1,1        ;CREATE TALLY TO IT
29600	    HRLI   R1,440700   ;FOR 7 BIT STRINGS
29610	    MOVE   R5,R1       ;SAVE IN R5
29620	    HRR    R0,R1       ;GET ADDRESS IN R0
29630	    HRL    R0,CRTAL    ;GET ADDRESS OF OLD STRING
29640	    MOVE   R2,INSLN.   ;GET OLD LENGTH
29650	    LSH    R2,-1       ;FROM NEW THIS TIME
29660	    SUBI R2,1 ;MINUS ONE FOR HEADER
29670	    ADDB   R2,R5       ;BUMP ACTIVE TALLY TO END PTR
29680	    BLT    R0,-1(R2)    ;COPY OLD STRING TO NEW
29690	    LSH    R6,1        ;DOUBLE NUMBER OF CHRS
29700	    ADDI   R6,5        ;PLUS A WORD FULL
29710	    EXCH   R1,CRTAL    ;SAVE NEW TALLY, RESTORE OLD
29720	    JSA    T,XDLOC.    ;DEALLOCATE IT
29730	    HLRZ   R1,F.JFN(FL) ;RESTORE JFN OF CURRENT FILE
29740	    MOVE   R2,R3       ;RESTORE CURRENT CHARACTER
29750	    JRST   INSVC2      ;AND THEN SAVE CHARACTER
29760	;
29770	    PAGE
29780	    SUBTTL BASIC RUN TIME FILE SUBROUTINES--INSTB
29790	;
29800	;   INSTB--THIS ROUTINE FINISHES STRING INPUT.  IT FIXES UP THE STRING BY
29810	;      FIXING THE LENGTH OF THE STRING TO REPRESENT THE ACTUAL LEN.
29820	;
29830	;
29840	 INSTB:Z
29850	    JUMPE R4,INSTB1 ;HANDLE NULL INPUT STRINGS SPECIAL
29860	    MOVEI  R2,0        ;SAVE 0 AT END OF STRING
29870	    JSA    T,INSVC     ;FOR SOME FUNCTIONS REQUIRE IT
29880	    MOVE   R1,CRTAL    ;PICK UP CURRENT STRING PTR
29890	    SOS    R4          ;CHAR COUNT MINUS ONE
29900	    HRLM   R4,-1(R1)   ;SAVE IN STRING BLOCK
29910	    JRA    T,0(T)      ;AND DONE
29920	;
29930	 INSTB1:
29940	  MOVE R1,CRTAL ;GET TALLY TO BLOCK WE ALLOCATED FOR INPUT
29950	  JSA T,XDLOC. ;GET RID OF IT
29960	  SETZB R1,CRTAL ;WANT TO RETURN NULL STRING
29970	  JRA T,0(T) ;DO SO
29980	;
29990	;
30000	    PAGE
30010	SUBTTL BASIC RUN TIME FILE SUBROUTINES--INCHR.
30020	;
30030	;   INCHR.--THIS GETS THE NEXT CHR FROM THE FILE'S BUFFER,
30040	;      GETTING AND SETTING UP A BUFFER, AND MOVING TO THE
30050	;      NEXT BUFFER IF NECESSARY
30060	;
30070	;
30080	INCHR.: Z
30090	;
30100	 INCHR0:
30110	  AOSL F.CHCT(FL) ;CHECK IF MORE LEFT IN BUFFER
30120	    JRST INBUF ;NO--HANDLE
30130	  ILDB R2,F.ITAL(FL) ;PICK UP CHR
30140	;
30150	  JUMPE R2,INCHR0 ;NULL--IGNORE
30160	  CAIN R2,ASC.RO ;RUBOUT
30170	    JRST INCHR0 ;IGNORE IT TOO
30180	  CAIN R2,ASC.CR ;CHECK FOR CARRIAGE RETURN
30190	    JRST INCHR0 ;IGNORE THOSE ALONE
30200	  CAIN R2,ASC.LF ;CHECK FOR LINE FEED
30210	    MOVEI R2,ASCEOL ;FAKE TO BE EOL
30220	  JRA T,0(T) ;ELSE RETURN CHR
30230	;
30240	;
30250	;   INBUF--GET NEXT BUFFER
30260	;
30270	 INBUF:
30280	  MOVEM R1,INBFT1# ;SAVE R1,R3,R4
30290	  MOVEM R3,INBFT3#
30300	;
30310	 INBUFA:
30320	  SKIPN F.BUF(FL) ;CHECK IF BUFFER EXISTS
30330	    JRST GTBUF ;NO--CREATE ONE
30340	  MOVE R2,F.BTS(FL) ;GET FILE TYPE
30350	  TLNN R2,FB.TTY ;CHECK FOR TTY
30360	    JRST INBF1 ;HANDLE FILE
30370	  JSA T,INTTY ;READ LINE FROM TTY
30380	  JRST INBF2 ;AND SKIP
30390	;
30400	 INBF1:
30410	  SKIPE F.LBK(FL) ;FILE--CHECK IF LAST BUFFER
30420	    JRST INBF6 ;EOF
30430	  SETOM EOFFG. ;ALLOW EOF
30440	  MOVNI R3,5*FLBFLN ;LENGTH OF BUFFER IN CHRS
30450	;
30460	 INBF4:
30470	  HLRZ R1,F.JFN(FL) ;GET JFN
30480	  MOVE R2,F.BUF(FL) ;GET BUFFER PTR
30490	  HRLI R2,440700 ;MAKE INTO TALLY
30500	  MOVEM R2,F.ITAL(FL) ;SAVE TALLY
30510	  SIN ;AND READ THE STRING
30520	  MOVMS R3 ;EXCESS COUNT POSITIVE
30530	  SUBI R3,5*FLBFLN+1 ;GET NEG COUNT
30540	  MOVEM R3,F.CHCT(FL) ;SAVE COUNT
30550	;
30560	 INBF5:
30570	  SKIPN EOFFG. ;CHECK FOR EOF REACHED
30580	    SETOM F.LBK(FL) ;SET LAST BLOCK IF SO
30590	  SETZM EOFFG. ;CLEAR EOF FLAG
30600	;
30610	 INBF2:
30620	  MOVE R1,INBFT1 ;RESTORE R1,R3,R4
30630	  MOVE R3,INBFT3
30640	  JRST INCHR0 ;AND TRY GETTING A CHR FROM THIS BUFFER
30650	;
30660	 INBF6:
30670	  SETZM F.LBK(FL) ;CLEAR LAST BLOCK FLAG
30680	  SETOM F.EOF(FL) ;MARK AS EOF
30690	  AOSE EOFFG. ;CHECK IF EOF
30700	    ERR E.EOF ;ERROR IF ACTUAL EOF
30710	  MOVE R1,INBFT1 ;RESTORE R1
30720	  JRA T,0(T) ;AND DONE
30730	;
30740	;
30750	;   GTBUF--GET A BUFFER IF ONE DOESN'T EXIST
30760	;
30770	 GTBUF:
30780	  PUSH P,R0 ;SAVE R0
30790	  MOVEI R0,FLBFLN ;GET BUFFER LENGTH IN WDS
30800	  JSA T,BLOC. ;AND ALLOCATE BUFFER
30810	  HRLI R1,440700 ;FORM TALLY LIKE PTR
30820	  MOVEM R1,F.BUF(FL) ;AND SAVE
30830	;
30840	  POP P,R0 ;RESTORE R0
30850	  JRST INBUFA ;NOW READ IN BUFFER
30860	;
30870	;
30880	;   ERROR MESSAGES
30890	;
30900	 E.NENI: ER <WRN>,Not enough input--add more
30910	;
30920	;
30930	  PAGE
30940	SUBTTL BASIC RUN TIME FILE SUBROUTINES--INTTY.
30950	;
30960	;   INTTY.--THIS ROUTINE READS A FILE FROM THE TTY INTO
30970	;      THE BUFFER FOR THE FILE.  IT DOES LINE EDITING
30980	;      ALA TENEX, SOS, ETC.
30990	;
31000	;
31010	INTTY: Z
31020	;
31030	  SKIPG F.CHCT(FL) ;CHECK IF ERROR MESSAGE FIRST
31040	    ERR E.NENI ;YES--USER MUST BE TOLD WE NEED MORE
31050	;
31060	 INTY7:
31070	  HRRZ R1,F.JFN(FL) ;GET JFN
31080	  HRROI R2,[ASCIZ /? /] ;PROMPT STRING
31090	  MOVEI R3,0 ;UNTIL NUL
31100	  SOUT ;PRINT THE STRING
31110	;
31120	  SETOM ECHOFG#		;ASSUME ECHOING
31130	  HLRZ R1,F.JFN(FL)	;CHECK INPUT JFN
31140	  DVCHR			;FOR TTY
31150	  TLNE R1,600000	;CHECK DEVICE TYPE
31160	    SETZM ECHOFG#	;NOT TTY--DON'T ECHO
31170	  MOVE R2,F.BUF(FL) ;GET BUFFER
31180	  HRLI R2,440700 ;GET TALLY TO BUFFER
31190	  MOVEM R2,F.ITAL(FL) ;SAVE
31200	  MOVEM R2,INTYTL# ;SAVE TALLY FOR INPUTTING
31210	  MOVEI R3,0 ;CLEAR CHR COUNT
31220	;
31230	 INTY6:
31240	  HLRZ R1,F.JFN(FL) ;GET INPUT JFN
31250	  BIN ;READ NEXT CHR
31260	  CAIN R2,177 ;CHECK FOR RUN OUT (DELETE)
31270	    JRST INTY2 ;DELETE CHR
31280	  CAIL R2,40 ;CHECK FOR CONTROL
31290	    JRST INTY1 ;NON-CONTROL--USE
31300	  CAIN R2,ASCEOL ;CHECK FOR EOL
31310	    JRST INTY5 ;HANDLE
31320	  CAIN R2,1 ;CHECK FOR ^A
31330	    JRST INTY2 ;DELETE CHR
31340	  CAIN R2,30 ;CHECK FOR ^X
31350	    JRST INTY3 ;DELETE LINE
31360	  CAIN R2,25	;CHECK FOR ^U
31370	    JRST INTY3	;DELETE LINE
31380	  CAIN R2,21 ;CHECK FOR ^Q
31390	    JRST INTY3 ;DELETE LINE
31400	  CAIN R2,22 ;CHECK FOR ^R
31410	    JRST INTY4 ;RETYPE LINE
31420	  CAIN R2,ASC.LF ;CHECK FOR LINE FEED
31430	    JRST INTY5 ;HANDLE SPECIAL IF SO
31440	  CAIN R2,ASC.CR	;CHECK FOR CR
31450	    JRST INTY6		;IGNORE IF SO
31460	  JRST INTY1 ;ELSE USE AS INPUT
31470	;
31480	;   USE THIS CHR
31490	;
31500	 INTY1:
31510	  IDPB R2,INTYTL ;SAVE CHR
31520	  CAIN R2,33 ;CHECK FOR ESCAPE
31530	    MOVEI R2,"$" ;ECHO DOLLAR SIGN FOR IT
31540	  HRRZ R1,F.JFN(FL) ;GET OUTPUT JFN
31550	  SKIPE ECHOFG		;CHECK IF ECHOING
31560	    BOUT ;ECHO CHR
31570	  AOS R3 ;UPDATE COUNT
31580	  CAIGE R3,5*FLBFLN ;CHECK IF TOO MUCH
31590	    JRST INTY6 ;NO--CONTINUE
31600	  ERR E.LTL ;YES--ERROR
31610	  JRST INTY7 ;AND TRY AGAIN
31620	;
31630	;   DELETE LAST CHR
31640	;
31650	 INTY2:
31660	  SOJL R3,INTY3 ;CHECK FOR NEW LINE NEEDED
31670	  HRRZ R1,F.JFN(FL) ;GET OUTPU JFN
31680	  MOVEI R2,"\" ;CHR TO INDICATE DELETE
31690	  BOUT ;PRINT
31700	  LDB R2,INTYTL ;GET LAST CHR
31710	  BOUT ;PRINT
31720	  MOVS R2,INTYTL ;GET TALLY
31730	  ADDI R2,070000 ;BACK UP ONE
31740	  TRNE R2,400000 ;CHECL FOR WORD BOUNDARY
31750	  SUB R2,[XWD 1,430000] ;GET IN PREVIOUS WORD
31760	  MOVSM R2,INTYTL ;RESAVE TALLY
31770	  JRST INTY6 ;AND HANDLE NEXT CHR
31780	;
31790	;   DELETE LINE
31800	;
31810	 INTY3:
31820	  HRRZ R1,F.JFN(FL) ;GET JFN FOR OUTPUT
31830	  MOVEI R2,"_" ;CHR
31840	  BOUT ;PRINT
31850	  BOUT ;IT
31860	  BOUT ;THREE TIMES
31870	  MOVEI R2,ASCEOL ;NEW LINE
31880	  BOUT ;PRINT
31890	  JRST INTY7 ;AND READ NEW LINE
31900	;
31910	;   RETYPE LINE
31920	;
31930	 INTY4:
31940	  MOVE R0,R3 ;GET COUNT THUS FAR
31950	  HRRZ R1,F.JFN(FL) ;GET OUTPUT JFN
31960	  MOVEI R2,ASCEOL ;NEW LINE
31970	  BOUT ;FORCEIOUT
31980	  HRRO R2,F.BUF(FL) ;GET TALLY
31990	  SOUT ;PRINT THE STRING WE HAVE
32000	  MOVE R3,R0 ;RESTORE COUNT
32010	  JRST INTY6 ;AND NEXT
32020	;
32030	;   END OF INPUT
32040	;
32050	 INTY5:
32060	  IDPB R2,INTYTL ;SAVE LAST CHR
32070	  ADDI R3,2 ;UPDATE COUNT
32080	  MOVNM R3,F.CHCT(FL) ;SAVE COUNT FOR FILE
32090	;
32100	  SETZM F.LBK(FL) ;MORE BLOCKS FORM TTY
32110	  JRA T,0(T) ;AND DONE
32120	;
32130	;
32140	;   ERROR MESSAGES
32150	;
32160	 E.LTL: ER WRN,Line too long--retry
32170	;
32180	;
32190	PAGE
32200	SUBTTL BASIC RUN TIME FILE SUBROUTINES--CKAMP
32210	;
32220	;   CKAMP--THIS ROUTINE IS ENTERED WHEN AN AMPERSAND IS FOUND
32230	;      IT CHECKS IF THE AMPERSAND IS SPECIAL OR NOT.  IF
32240	;      IT IS IT RETURNS TO 1(T) ELSE TO 0(T).
32250	;
32260	;
32270	CKAMP: Z
32280	;
32290	  SKIPN INAMP. ;ARE WE ACCEPTING AMPERSANDS
32300	    JRA T,0(T) ;NO--RETURN NOT SPECIAL
32310	  JSA T,INCHR. ;GET NEXT CHR
32320	  CAIN R2,ASCEOL ;CHECK FOR EOL
32330	    JRST CKAMP1 ;YES--AMPERSAND IS SPECIAL
32340	  MOVSI R2,070000 ;NO--BACK UP TALLY
32350	  ADDM R2,F.ITAL(FL) ;SO WE REREAD THIS CHR
32360	  MOVEI R2,ASCAMP ;RESTORE CURRENT CHR
32370	  JRA T,0(T) ;RETURN NOT SPECIAL
32380	;
32390	 CKAMP1:
32400	  MOVE R2,F.BTS(FL) ;CHECK FILE
32410	  TLNN R2,FB.TTY	;CHECK FOR TTY
32420	    JRST CKAMP2		;NO--SKIP
32430	  SETZM F.CHCT(FL)	;YES--PREVENT ERROR MESSAGE
32440	  MOVEM R1,INBFT1#	;SAVE R1
32450	  MOVEI R1,37		;GET EOL
32460	  PBOUT			;AND RPINT IT
32470	  MOVE R1,INBFT1	;RESTORE R1
32480	;
32490	 CKAMP2:
32500	  MOVEI R2,ASCCMA ;MAKE AMPERSAND INTO COMMA
32510	  JRA T,1(T) ;AND RETURN SPECIAL
32520	;
32530	;
32540	PAGE
32550	SUBTTL BASIC RUN TIME FILE SUBROUTINES--FSCHR
32560	;
32570	;   FSCHR--THIS ROUTINE IS CALLED FOR THE FIRST CHARACTER IN
32580	;      AN INPUT.  IT CHECKS FOR SOS TYPE LINE NUMBERS AND
32590	;      PAGE MARKS IF THE FILE FB.ILN BIT IS ON, SAVES THE CURRENT
32600	;      LINE NUMBER AND UPDATES THE CURRENT PAGE NUMBER AS
32610	;      APPROPRIATE.  IT RETURNS TO 1(T) IF THE NEXT CHAR
32620	;      HAS ALREADY BEEN SCANNED AND TO 0(T) IF NOT.
32630	;
32640	;
32650	FSCHR: Z
32660	;
32670	  MOVE R2,F.BTS(FL) ;CHECK FILE BITS
32680	  TLNN R2,FB.ILN ;ARE WE LOOKING FOR SOS-LINE NUMBERS
32690	    JRA T,0(T) ;NO--JUST RETURN WITHOUT GETTING CHR
32700	;
32710	  JSA T,INCHR. ;GET NEXT CHR
32720	  MOVEM R1,FSCHT1# ;SAVE R1 THRU WORK
32730	  MOVE R1,@F.ITAL(FL) ;CHECK CURRENT WORD
32740	  TLNN R1,1 ;FOR SPECIAL
32750	    JRST FSCHX1 ;IF NOT, IGNORE
32760	  CAMN R1,[BYTE (7)40,40,40,40,40(1)1] ;PAGE MARK
32770	    JRST FSPAG ;HANDLE IF SO
32780	;
32790	 FSNUM:
32800	  MOVEM R3,FSCHT3# ;SAVE R3
32810	  MOVE R3,R1 ;GET LINE NUMBER WORD IN R3
32820	  MOVEI R1,0 ;CLEAR R1
32830	  TRZ R3,1 ;TURN OFF SPECIAL BIT
32840	;
32850	 FSNUM1:
32860	  MOVEI R2,0 ;CLEAR R2
32870	  LSHC R2,7 ;GET NEXT CHR IN R2
32880	  IMULI R1,12 ;OLD NUMBER TIMES 10
32890	  ADDI R1,-"0"(R2) ;PLUS NEW DIGIT
32900	  JUMPN R3,FSNUM1 ;LOOP IF MORE
32910	;
32920	  MOVE R3,FSCHT3 ;RESTORE R3
32930	  HRLM R1,F.LNM(FL) ;SAVE FILE LINE NUMBER
32940	  MOVEI R1,5 ;NUMBER OF CHRS TO IGNORE
32950	  JSA T,INCHR. ;GET A CHR
32960	  SOJG R1,.-1 ;LOOP UNTIL WE GO THEM
32970	  CAIN R2,11 ;CHECK FOR TAB
32980	    JRST FSCHX0 ;HANDLE IF SO--IGNORE IT
32990	    JRST FSCHX1 ;HANDLE IF NOT--USE CHR
33000	;
33010	;
33020	 FSPAG:
33030	  AOS F.PGN(FL) ;UPDATE PAGE NUMBER IN FILE
33040	  MOVEI R1,5 ;CHRS TO IGNORE
33050	  JSA T,INCHR. ;GET NEXT
33060	  SOJG R1,.-1 ;UNTIL DONE
33070	  CAIN R2,14 ;CHECK FOR FORM FEED (PAGE)
33080	    JRST FSCHX0 ;YES--IGNORE IT
33090	    JRST FSCHX1 ;NO--USE CHR
33100	;
33110	;
33120	 FSCHX1:
33130	  AOS T ;BUMP RETURN TO USE CHR WE SCANNED
33140	;
33150	 FSCHX0:
33160	  MOVE R1,FSCHT1 ;RESTORE R1
33170	  JRA T,0(T) ;AND RETURN
33180	;
33190	;
33200	PAGE
33210	SUBTTL BASIC RUN TIME FILE ROUTINES--INPUT STRING--PARAMS
33220	;
33230	;   INSMX.--MAX LENGTH IN WORDS OF INPUT STRING INITIALLY
33240	;
33250	INSMX.: EXP 37 ;37 WDS=36*5=180 CHRS
33260	;
33270	;
33280	;   INSLN.--CURRENT LENGTH FOR INPUT
33290	;
33300	INSLN.: EXP 7 ;7 WDS==6*5=30 CHRS
33310	;
33320	;
33330	    PAGE
33340	    SUBTTL END OF ASSEMBLY
33350	;
33360	;
33370	;
33380	    PRGEND
33390	    TITLE  MRGN. -- BASIC RUN TIME FILE ROUTINES--MARGIN
33400	    SUBTTL ASSEMBLY CONTROL
33410	    SEARCH STENEX,BGBL,BRSYMS
33420	;
33430	;
33440	;
33450	    ENTER MRGN.
33460	;
33470	;
33480	;
33490	    EXTERNAL TYPAS.,OPNER.
33500	;
33510	;
33520	;
33530	;
33540	    PAGE
33550	    SUBTTL BASIC RUN TIME FILE ROUTINES--MRGN
33560	;
33570	;   MRGN--THIS ROUTINE HANDLES THE MARGIN STATEMENT.  THE MARGIN OF
33580	;      A FILE IS USED FOR OUTPUT LINE LENGTH (ASCII) AND FOR RECORD
33590	;      LENGTH DETERMINATION (RANDOM).  DEFAULT VALUES OF 75 (ASCII) AND
33600	;      12 (RANDOM) ARE ASSUMED UNLESS THIS STATEMENT IS USED.
33610	;
33620	;
33630	 MRGN.:Z
33640	    XFIX R1,@0(T) ;GET SETTING
33650	    SKIPL R1 ;CAN'T BE NEGATIVE
33660	  CAILE R1,2000*5 ;OR TOO BIG
33670	    ERR E.MRGN ;ERROR IF IT IS
33680	;
33690	    SKIPN F.JFN(FL)	;CHECK IF FILE HAS JFN
33700	    JRST OPNER.		;ERROR IF NOT
33710	    MOVE R0,F.BTS(FL) ;GET TYPE OF FILE
33720	    TLNE R0,FB.ASC ;CHECK FOR ASCII/TTY
33730	    JRST MRGN1 ;YES--HANDLE
33740	    TLNE R0,FB.RST ;CHECK FOR RSTR
33750	    JRST MRGN2 ;YES--HANDLE
33760	    TLNE R0,FB.EPY ;CHECK FOR EMPTY
33770	    JRST MRGN3 ;HANDLE
33780	    TLNE R0,FB.RNM ;CHECK FOR RANDOM NUMERIC
33790	    JRST MRGN4 ;HANDLE
33800	    TLNE R0,FB.UDF ;CHECK FOR UNDEFINED
33810	    JRST MRGN5 ;HANDLE
33820	    BLOWUP ;IMPOSSIBLE TO GET HERE
33830	;
33840	;   ASCII
33850	;
33860	 MRGN1:
33870	    MOVEM R1,F.MAR(FL) ;SAVE MARGIN
33880	    JRA T,1(T) ;AND RETURN
33890	;
33900	;   RSTR
33910	;
33920	 MRGN2:
33930	    CAME R1,F.MAR(FL) ;CHECK VS SAVED MRGN
33940	    ERR E.MRGN ;MUST MATCH
33950	    JRA T,1(T) ;AND RETURN
33960	;
33970	;   EMPTY
33980	;
33990	 MRGN3:
34000	  MOVEM R1,F.MAR(FL) ;SAVE NEW MARGIN
34010	  JRA T,1(T) ;AND RETUNR
34020	;
34030	;   RNUM
34040	;
34050	 MRGN4:
34060	  CAME R1,F.MAR(FL) ;MUST MATCH FILE MARGIN
34070	    ERR E.MRGN ;ERROR IF NOT
34080	  JRA T,1(T) ;RETURN IF OK
34090	;
34100	;   UNDEF
34110	;
34120	 MRGN5:
34130	  CAIN R1,1 ;CHECK IF 1
34140	    JRST MRGN3 ;IF SO, TYPE STILL UNDEFINED
34150	  MOVEM R1,F.MAR(FL) ;SAVE SETTING (MUST BE ASCII)
34160	  JSA T,TYPAS. ;MAKE FILE ASCII
34170	    NOP ;IGNORE TTY RETURN
34180	  JRA T,1(T) ;AND RETURN
34190	;
34200	;
34210	;   ERROR MESSAGE
34220	;
34230	E.MRGN: ER FLM,Illegal MARGIN setting
34240	;
34250	    PAGE
34260	    SUBTTL END OF ASSEMBLY
34270	;
34280	;
34290	;
34300	    PRGEND
34310	    TITLE  PEOL. -- BASIC RUN TIME FILE ROUTINES--PRINT END OF LINE
34320	    SUBTTL ASSEMBLY CONTROL
34330	    SEARCH STENEX,BGBL,BRSYMS
34340	;
34350	;
34360	;
34370	;
34380	    ENTER PEOL.
34390	;
34400	;
34410	;
34420	    EXTERNAL OTCHR.
34430	;
34440	;
34450	;
34460	    PAGE
34470	    SUBTTL BASIC RUN TIME FILE ROUTINES--PEOL
34480	;
34490	;   PEOL--THIS CAUSES A CR-LF PAIR TO BE PUT INTO THE CURRENT FILE
34500	;      WHICH IS EITHER A TTY OR ASCII TYPED.
34510	;
34520	;
34530	 PEOL.:Z
34540	    HRRZ   R1,F.JFN(FL) ;GET JFN
34550	    MOVEI R2,ASC.CR	;CR
34560	    JSA T,OTCHR.	
34570	    MOVEI R2,ASC.LF	;LF
34580	    JSA T,OTCHR.
34590	    JRA    T,0(T)      ;AND RETURN
34600	;
34610	    PAGE
34620	    SUBTTL END OF SSEMBLY
34630	;
34640	;
34650	;
34660	    PRGEND
34670	    TITLE  PNUM. -- BASIC RUN TIME FILE ROUTINES--PRINTING
34680	    SUBTTL ASSEMBLY CONTROL
34690	    SEARCH STENEX,BGBL,BRSYMS
34700	;
34710	;
34720	;
34730	;
34740	    ENTER PNUM.,PSTR.
34750	;
34760	;
34770	    EXTERNAL TMPTL.,TMPCT.,TYPAS.,OTSTL.,RGSV.
34780	;
34790	;
34800	;
34810	;
34820	    PAGE
34830	    SUBTTL BASIC RUN TIME FILE ROUTINES--PNUM
34840	;
34850	;   PNUM--THIS ROUTINE IS CALLED WITH ONE NUMERIC ARGUMENT AND CAUSES THAT
34860	;      ARGUMENT TO BE PRINTED IN ASCII ON THE CURRENT FILE/TTY.
34870	;
34880	;
34890	 PNUM.:Z
34900	    MOVEM R3,RGSV. ;SAVE REG R3
34910	    MOVE   R2,@0(T)    ;PICK UP NUMBER
34920	    MOVE   R1,TMPTL.   ;GET TALLY FOR TEMP BUFFERR
34930	    MOVEI R0,"-"	;GUESS NEGATIVE NUMBER
34940	    IDPB R0,R1		;SAVE SIGN
34950	    MOVEI R0,ASCSPA	;SPACE FILL
34960	    SKIPL R2		;CHECK IF NEGATIVE
34970	    DPB R0,R1		;ELSE MAKE SIGN A SPACE
34980	    MOVMS R2		;GET ABS OF NUMBER
34990	    MOVEI R3,"0"	;LEAD ZERO IF NEEDED
35000	    CAMGE R2,ALMST1	;CHECK IF TENEX WILL DROP '0'
35010	    CAMGE R2,[1.0E-4]
35020	    SKIPA		;SKIP IF NOT
35030	    IDPB R3,R1		;IF SO, INSERT IT FOR TENEX
35040	    MOVSI  R3,0        ;FREE FORMAT
35050	    FLOUT              ;CONVERT NUMBER TO STRING
35060	    BLOWUP ;CAN'T FAIL
35070	    IDPB R0,R1 ;SAVE SPACE AFTER NUMBER TOO
35080	    MOVEI R0,0 ;END CHR IS NULL
35090	    IDPB R0,R1 ;SAVE IT AS WELL
35100	    MOVE R3,RGSV. ;RESTORE R3
35110	    MOVE   R1,TMPTL.   ;RESTORE TALLY TO NUMBER
35120	    MOVEI  R2,0        ;INIT COUNT OF CHRS
35130	    ILDB   R0,R1       ;GET NEXT CHAR
35140	    AOS    R2          ;BUMP COUNT
35150	    JUMPN  R0,.-2      ;SKIP IF MORE
35160	    HRLZM  R2,TMPCT.   ;SAVE COUNT IN STRING DUMMY
35170	    JSA    T,PSTR.     ;PRINT THE NUMERIC STRING
35180	    EXP    TMPTL.      ;PTR TO IT
35190	    JRA    T,1(T)      ;AND RETURN
35200	;
35210	;
35220	 ALMST1: 200777777772	;CUTOFF FOR PLACING '0' IN FRONT
35230	;
35240	    PAGE
35250	    SUBTTL BASIC RUN TIME FILE ROUTINES--PSTR
35260	;
35270	;   PSTR--THIS ROUTINE TAKES ONE ARGUMENT, A STRING, AND CAUSES IT TO
35280	;      BE PRINTED ON THE CURRENT ASCII DEVICE, FILE OR TTY.  7 BIT CHRS
35290	;      ARE ASSUMED.
35300	;
35310	;
35320	 PSTR.:Z
35330	    MOVE   R2,@0(T)    ;PICK UP PTR TO STRING
35340	    HLRZ   R1,-1(R2)   ;GET CHR LEN
35350	    MOVE  R0,F.MAR(FL) ;MARGIN IN EFFECT
35360	    JUMPE R0,PSTR1       ;NO--SKIP
35370	    SUB    R0,F.CPOS(FL) ;YES--SE IF WE FIL
35380	    SKIPE F.CPOS(FL) ;ALWAYS FIT IF BEGINING OF LINE
35390	    CAML   R0,R1       ;BY CHECKING BOUNDS
35400	    JRST   PSTR1       ;HANDLE FIT
35410	;
35420	    MOVE R0,R2 ;SAVE R2 IN R0
35430	    HRRZ R1,F.JFN(FL) ;GET OUTPUT JFN
35440	    MOVEI  R2,ASCEOL   ;IF NO FIT, GO TO NEXT LINE
35450	    BOUT               ;BY PRINTING CRLF
35460	    SETZM  F.CPOS(FL)  ;MARK AS LINE BEGINING
35470	    MOVE R2,R0 ;RESTORE CHR
35480	;
35490	 PSTR1:
35500	    HRRZ R1,F.JFN(FL) ;GET OUTPUT JFN
35510	    JSA T,OTSTL. ;PRINT STRING
35520	    JRA    T,1(T)      ;AND RETURN
35530	;
35540	    PAGE
35550	    SUBTTL END OF ASSEMBLY
35560	;
35570	;
35580	;
35590	    PRGEND
35600	    TITLE  PRSET. -- BASIC RUN TIME FILE ROUTINES--PRINT SETUP
35610	    SUBTTL ASSEMBLY CONTROL
35620	    SEARCH STENEX,BGBL,BRSYMS
35630	;
35640	;
35650	;
35660	;
35670	    ENTER PRSET.
35680	;
35690	;
35700	    EXTERNAL TYPAS.,OPNFL.
35710	;
35720	;
35730	;
35740	;
35750	    PAGE
35760	    SUBTTL BASIC RUN TIME FILE ROUTINES--PRSET
35770	;
35780	;   PRSET--THIS ROUTINE IS USED TO SET UP FOR A PRINT STATEMENT.  IT
35790	;      INITIALIZES THE FILE FOR PRINTING AND MAKES SURE EVERYTHING WILL
35800	;      WORK.
35810	;
35820	;
35830	 PRSET.:Z
35840	    JSA    T,TYPAS.    ;CHECK FILE TYPE FOR ASCII
35850	    JRA    T,0(T)      ;IF TTY, JUST RETUN
35860	    JSA T,OPNFL. ;IF FILE--MAKE SURE OPEN FOR APPEND
35870	      EXP FB.AP ;BIT FOR APPEND
35880	    JRA    T,0(T)      ;IF SO, THEN DONE
35890	;
35900	    PAGE
35910	    SUBTTL END OF ASSEMBLY
35920	;
35930	;
35940	;
35950	    PRGEND
35960	TITLE PSFL. -- BASIC RUN TIME ROUTINES--PASSING FILES
35970	SUBTTL ASSEMBLY CONTROL
35980	SEARCH STENEX,BGBL,BRSYMS
35990	;
36000	;
36010	;
36020	ENTER PSFL.,PCFL.
36030	;
36040	;
36050	EXTERNAL RGSV.,FSET.
36060	;
36070	;
36080	;
36090	PAGE
36100	SUBTTL BASIC RUN TIME SUB ROUTINES--PASS FILE--PSFL.
36110	;
36120	;   THIS ROUTINE IS CALLED WITH ONE ARGUMENT, NUMERIC, AND
36130	;      RETURNS IN R0 THE LOCATION OF THE FILE BLOCK OF THE
36140	;      CORRESPONDING FILE.
36150	;
36160	;
36170	PSFL.: Z
36180	;
36190	  MOVEM FL,RGSV.+10 ;SAVE OLD FILE REG
36200	  MOVE R2,@0(T) ;GET ARG
36210	  JSA T,FSET. ;CALL FILE SET
36220	    JUMP R2 ;WHICH WILL CREATE BLOCK AND ALL
36230	  MOVE R0,FL ;SAVE FILE PTR IN R0
36240	  MOVE FL,RGSV.+10 ;RESTORE OLD VALUE OF FILE REG
36250	  JRA T,1(T) ;AND RETURN
36260	;
36270	;
36280	PAGE
36290	SUBTTL BASIC RUN TIME SUB ROUTINES--RECIEVE FILE--PCFL.
36300	;
36310	;   THIS ROUTINE IS CALLED WITH THE FILE WORD IN
36320	;      R0 (#,,PTR) AND SHOULD PUT THIS WORD INTO THE
36330	;      FILE TABLE.
36340	;
36350	;
36360	PCFL.: Z
36370	;
36380	  TLO R0,FLGBL ;MARK AS GLOBAL FILE
36390	  HRRZ R1,FILTB.(V) ;GET PTR TO TABLE
36400	  SKIPN 0(R1) ;FIND FREE ENTRY
36410	  AOJA R1,.-1 ;LOOP UNTIL FOUND
36420	  MOVEM R0,0(R1) ;SAVE ENTRY IN TABLE
36430	  SUB R1,FILTB.(V) ;MAKE SURE WE'RE OK
36440	  HRLZS R0 ;THAT IS, THERE AREN'T TOO MANY FILES
36450	  CAMGE R0,FILTB.(V) ;CHECK COUNT
36460	    JRA T,0(T) ;FINE--EXIT
36470	;
36480	  ADD R1,FILTB.(V) ;RESTORE PTR
36490	  SETZM 0(R1) ;CLEAR BAD ENTRY
36500	  ERR E.NFLS ;GIVE ERROR MESSAGE
36510	;
36520	;
36530	;
36540	;   ERROR MESSAGES
36550	;
36560	 E.NFLS: ER NRM,Too many files
36570	;
36580	;
36590	PAGE
36600	SUBTTL END OF ASSEMBLY
36610	;
36620	;
36630	;
36640	PRGEND
36650	    TITLE  RDATN. -- BASIC RUN TIME ROUTINES--READ NUMERIC INTERNAL
36660	    SUBTTL ASSEMBLY CONTROL
36670	    SEARCH STENEX,BGBL,BRSYMS
36680	;
36690	;
36700	;
36710	    ENTER RDATN.
36720	;
36730	;
36740	;
36750	;
36760	;
36770	;
36780	    PAGE
36790	    SUBTTL BASIC RUN TIME ROUTINES--RDATN
36800	;
36810	;   RDATN--READ DATA (INTERNAL READ) NUMERIC--THIS ROUTINE TAKES THE NEXT
36820	;      ITEM ON THE NUMERIC DATA LIST AND RETURNS IT AND UPDATES THE
36830	;      DATA LIST.
36840	;
36850	;
36860	 RDATN.:Z
36870	    HLRZ R1,IDATP.(V) ;GET NUMERIC DATA PTR
36880	    SKIPN R1 ;CHECK IF MORE
36890	    ERR    E.ODAT      ;ERROR IF OUT OF DATA
36900	    HLLZ   R0,0(R1)    ;PICK UP DATA
36910	    CAMN   R0,[XWD 1,0] ;CHECK IF DATA IN NEXT WORD
36920	    MOVE   R0,1(R1)    ;PICK IT UP IF SO
36930	    HRRZ   R1,0(R1)    ;GET NEXT LINK
36940	    HRLM R1,IDATP.(V) ;SAVE DATA PTR
36950	    MOVEM  R0,@0(T)    ;SAVE VALUE WE GOT
36960	    JRA    T,1(T)      ;AND RETURN
36970	;
36980	;
36990	;   ERROR MESSAGE
37000	;
37010	E.ODAT: ER NRM,Out of data
37020	;
37030	    PAGE
37040	    SUBTTL END OF ASSEMBLY
37050	;
37060	;
37070	;
37080	    PRGEND
37090	    TITLE  RDATS. -- BASIC RUN TIME ROUTINES--READ INTERNAL STRING DATA
37100	    SUBTTL ASSEMBLY CONTROL
37110	    SEARCH STENEX,BGBL,BRSYMS
37120	;
37130	;
37140	;
37150	    ENTER RDATS.
37160	;
37170	;
37180	    EXTERNAL XDLOC.
37190	;
37200	;
37210	;
37220	;
37230	    PAGE
37240	    SUBTTL BASIC RUN TIME ROUTINES--RDATS
37250	;
37260	;   RDATS--READ INTERNAL STRING DATA--THIS ROUTINE TAKES THE NEXT
37270	;      STRING OF THE INTERNAL STRING DATA LIST AND RETURNS IT TO THE
37280	;      ONE ARGUEMENT AND UPDATES THE DATA LIST.
37290	;
37300	;
37310	 RDATS.:Z
37320	    HRRZ R1,IDATP.(V) ;GET STRING DATA PTR
37330	    SKIPN R1 ;CHECK IF MORE STRING DATA
37340	    ERR    E.ODAT      ;ERROR IF NOT
37350	    HRRZ   R0,0(R1)    ;GET NEXT DATA LINK OFFSET
37360	    MOVE R1,-1(R1) ;PICK UP TALLY
37370	    AOS -1(R1) ;UPDATE USAGE COUNT OF STRING
37380	    HRRM R0,IDATP.(V) ;SAVE NEW LINK
37390	    EXCH   R1,@0(T)    ;SAVE NEW VALUE, PICK UP OLD
37400	    JSA    T,XDLOC.    ;DEALLOCATE OLD
37410	    JRA    T,1(T)      ;AND RETURN
37420	;
37430	;
37440	;   ERROR MESSAGE
37450	;
37460	E.ODAT: ER NRM,Out of data
37470	;
37480	    PAGE
37490	    SUBTTL END OF ASSEMBLY
37500	;
37510	;
37520	;
37530	    PRGEND
37540	    TITLE  RDNUM. -- BASIC RUN TIME FILE ROUTINES--RANDOM READ NUMERIC
37550	    SUBTTL ASSEMBLY CONTROL
37560	    SEARCH STENEX,BGBL,BRSYMS
37570	;
37580	;
37590	;
37600	;
37610	    ENTER RDNUM.
37620	;
37630	;
37640	;
37650	    EXTERNAL RGSV.
37660	;
37670	;
37680	;
37690	    PAGE
37700	    SUBTTL BASIC RUN TIME FILE ROUTINES--RDNUM
37710	;
37720	;   RDNUM--THIS ROUTINE TAKE STHE CURRENT RANDOM FILE AND READS A NUMBER
37730	;      FROM IT.  THE FILE MUST HAVE BEEN WRITTEN WITH A NUMBER IN THE
37740	;      CURRENT RECORD FOR THIS TO WORK.
37750	;
37760	;
37770	 RDNUM.:Z
37780	    MOVEM  R2,RGSV.   ;SAVE R2
37790	    HLRZ   R1,F.JFN(FL) ;GET JFN OF FILE
37800	    BIN                ;GET NEXT WORD IN FILE
37810	    MOVE   R1,R2       ;GET IT IN R1
37820	    MOVE   R2,RGSV.    ;RESTORE R2, SAVE FILE BLK PTR
37830	    MOVEM  R1,@0(T)    ;SAVE ITEM AS RETURNED VALUE
37840	    JRA    T,1(T)      ;RETURN WHEN DONE
37850	;
37860	    PAGE
37870	    SUBTTL END OF ASSEMBLY
37880	;
37890	;
37900	;
37910	    PRGEND
37920	    TITLE  RDSTR. -- BASIC RUN TIME FILE ROUTINES--RANDOM STR READ
37930	    SUBTTL ASSEMBLY CONTROL
37940	    SEARCH STENEX,BGBL,BRSYMS
37950	;
37960	;
37970	;
37980	;
37990	    ENTER RDSTR.
38000	;
38010	;
38020	    EXTERNAL RGSV.,BSLOC.,XDLOC.,NWDTL.
38030	;
38040	;
38050	;
38060	    PAGE
38070	    SUBTTL BASIC RUN TIME FILE ROUTINES--RDSTR
38080	;
38090	;   RDSTR--THIS ROUTINE READS THE STRING THAT OCCUPIES THE CURRENT RECORD
38100	;      IN THE CURRENT RANDOM FILE.  A STRING HAD BETTER BE THERE AS
38110	;      EXPECTED.
38120	;
38130	;
38140	 RDSTR.:Z
38150	  MOVEM R2,RGSV. ;SAVE R2
38160	  MOVEM R3,RGSV.+1 ;AND R3
38170	;
38180	    HLRZ   R1,F.JFN(FL) ;GET JFN OF FILE
38190	    BIN                ;READ THE STRING HEADER WORD
38200	    JUMPE  R2,RDST1    ;HANDLE NULL STRING IN FILE
38210	;
38220	    HLRZ   R1,R2       ;GET TALLY FIELDS
38230	    HRRZ   R0,R2       ;GET CHR LENGTH
38240	    JSA    T,BSLOC.    ;ALLOCATE RANDOM CHR STRING
38250	;
38260	    MOVEM R1,RDSTM# ;SAVE TALLY
38270	    MOVE   R3,R1       ;IN R3 AND R4
38280	    HRLI   R3,444400   ;USE R3 AS WORD TALLY
38290	    MOVE   R0,NWDTL.   ;SAVE COUNT
38300	    HLRZ   R1,F.JFN(FL) ;GET JFN OF FILE
38310	    BIN                ;GET NEXT DATA WORD
38320	    IDPB   R2,R3       ;SAVE IN STRING BLOCK
38330	    SOJG   R0,.-2      ;CONTINUE UNTIL DONE
38340	;
38350	 RDST3:
38360	    MOVE R3,F.WLN(FL) ;GET WORD LENGTH OF A BLOCK
38370	    SUB    R3,NWDTL.   ;MINUS LENGTH READ
38380	    SKIPG R3		;CHECK IF BLOCK SIZE OK
38390	      ERR E.RFER	;ERROR IF NOT
38400	;
38410	    SOJLE  R3,RDST2    ;IF DONE, JUMP
38420	    BIN                ;ELSE READ MORE
38430	    SOJG   R3,.-1      ;UNTIL DONE COMPLETELY
38440	;
38450	 RDST2:
38460	    MOVE   R1,RDSTM       ;RESTORE TALLY TO R1
38470	    MOVE R2,RGSV. ;RESTORE R2
38480	    MOVE R3,RGSV.+1 ;AND R3
38490	    EXCH   R1,@0(T)    ;SAVE RESULTANT STRING FOR RETURN
38500	    JSA    T,XDLOC.    ;DEALLOCATE OLD ONE
38510	    JRA    T,1(T)      ;AND THEN DONE
38520	;
38530	 RDST1:
38540	    SETZM NWDTL. ;NOTHING READ
38550	    SETZM RDSTM# ;NO TALLY
38560	    JRST   RDST3       ;AND FINISH PROCESSING
38570	;
38580	;
38590	;
38600	;   ERROR MESSAGE
38610	;
38620	E.RFER: ER FLM,Block too long for file
38630	;
38640	    PAGE
38650	    SUBTTL END OF ASSEMBLY
38660	;
38670	;
38680	;
38690	    PRGEND
38700	    TITLE  RESET. -- BASIC RUN TIME FILE ROUTINES--RESET ASCII FILE
38710	    SUBTTL ASSEMBLY CONTROL
38720	    SEARCH STENEX,BGBL,BRSYMS
38730	;
38740	;
38750	;
38760	;
38770	    ENTER RESET.
38780	;
38790	;
38800	    EXTERNAL E.FLR1,OPNER.,TYPAS.,OPNFL.
38810	;
38820	;
38830	;
38840	;
38850	    PAGE
38860	    SUBTTL BASIC RUN TIME FILE ROUTINES--RESET
38870	;
38880	;   RESET--THIS ROUTINE HANDLES THE RESET STATEMENT WHEN IT
38890	;      CONTAINS A FILE NUUMBER BUT NO RESET ARGUMENT.  THIS FORM OF
38900	;      THE STATMENT IS USED SOLELY ON ASCII FILES AND SETS THE FILE
38910	;      POINTER TO THE BEGINING OF THE FILE.
38920	;
38930	;
38940	 RESET.:Z
38950	  MOVE R0,F.BTS(FL) ;GET FILES BITS
38960	  TLNE R0,FB.RNM+FB.RST ;CHECK FOR RANDOM
38970	    ERR E.RST ;ERROR IF SO
38980	  TLNE R0,FB.EPY ;CHECK IF UNTYPED AND EMPTY
38990	    JRA T,0(T) ;ALREADY RESET
39000	  TLNN R0,FB.UDF ;CHECK FOR UNTYPED AND NON-EMPTY
39010	    JRST RESET2		;AND SKIP IF NOT
39020	  JSA T,TYPAS. ;TYPE AS ASCII
39030	  JRA T,0(T)		;IGNORE RESET OF TTY
39040	;
39050	 RESET2:
39060	  JSA T,OPNFL.		;MAKE SURE FILE IS OPEN
39070	    EXP FB.RD		;FOR READ
39080	;
39090	  SKIPN R1,F.JFN(FL) ;GET JFN OF FILE
39100	    JRST OPNER.		;ERROR IF NONE
39110	  HRRZS R1 ;ISOLATE OUTPUT JFN
39120	    MOVEI  R2,0        ;SET POINTER TO FIRST BYTE
39130	    SFPTR              ;DO SET PTR
39140	    ERR    E.FLR1      ;HANDLE FAILS
39150	    SETZM  F.EOF(FL)   ;NOT AT END OF FILE
39160	    SETZM F.CHCT(FL) ;CLEAR BUFFER
39170	    SETZM F.LNM(FL) ;NO LINE NUMBER KNOWN
39180	    JRA    T,0(T)      ;AND RETURN
39190	;
39200	;
39210	;   ERROR MESSAGE
39220	;
39230	E.RST: ER FLM,Must specify location for random file
39240	;
39250	    PAGE
39260	    SUBTTL END OF ASSEMBLY
39270	;
39280	;
39290	;
39300	    PRGEND
39310	    TITLE  RESTR. -- BASIC RUN TIME ROUTINES--RESTORE
39320	    SUBTTL ASSEMBLY CONTROL
39330	    SEARCH STENEX,BGBL,BRSYMS
39340	;
39350	;
39360	;
39370	;
39380	    ENTER RESTR.
39390	;
39400	;
39410	;
39420	;
39430	;
39440	;
39450	    PAGE
39460	    SUBTTL BASIC RUN TIME ROUTINES--RESTR
39470	;
39480	;   RESTR--THIS ROUTINE RESETS THE STRING AND NUMERIC DATA POINTERS TO
39490	;      THEIR INITIAL VALUES.  IT IS INVOKED BY A LINE 'RESET' WITH
39500	;      NO ARGUMENTS OR FILE SPECCIFICATION.
39510	;
39520	;
39530	 RESTR.:Z
39540	  MOVE R1,PGDAT.(V) ;GET PROGRAM DATA PTR
39550	  HRL R0,PGNDAT(R1) ;GET NUMERIC DATA HEAD
39560	  HRR R0,PGSDAT(R1) ;AND STRING DATA HEAD
39570	  MOVEM R0,IDATP.(V) ;SAVE NEW INITIAL DATA PTR
39580	    JRA    T,0(T)      ;AND RETURN
39590	;
39600	    PAGE
39610	    SUBTTL END OF ASSEMBLY
39620	;
39630	;
39640	;
39650	    PRGEND
39660	    TITLE  RRST. -- BASIC RUN TIME ROUTINES--RANDOM FILE RESET
39670	    SUBTTL ASSEMBLY CONTROL
39680	    SEARCH STENEX,BGBL,BRSYMS
39690	;
39700	;
39710	;
39720	;
39730	    ENTER RRST.
39740	;
39750	;
39760	    EXTERNAL E.FLR1,OPNER.,RGSV.,RNSET.
39770	;
39780	;
39790	;
39800	    PAGE
39810	    SUBTTL BASIC RUN TIME FILE ROUTINES--RRST
39820	;
39830	;   RRST--THIS ROUTINE HANDLES THE RESET STATEMENT WHEN BOTH A FILE
39840	;      NUMBER AND AN ARGUMENT IS GIVEN.  THE FILE NUMBER HAS ALREADY
39850	;      BEEN INTERPRETED (FL) AND THE ARGUMENT IS THE ONE ARG GIVEN
39860	;      TO THIS ROUTINE.  THE FILE POINTER IS SET TO THE RECORD NUM
39870	;      GIVEN BY THAT ARGUMENT.
39880	;
39890	;
39900	 RRST.:Z
39910	  XFIX R2,@0(T) ;GET POINTER SETTING
39920	  CAMGE R2,[-1] ;CHECK IF ILLEGAL MINUS
39930	    ERR E.RSTV ;ERROR IF SO
39940	  SKIPLE R2		;CHECK IF 0,1
39950	    SUBI R2,1		;IF NOT, CORRECT USERS NUMBER
39960	  HRRZ R1,F.JFN(FL) ;GET JFN OF FILE
39970	  SKIPN R1 ;MUST HAVE ONE
39980	    JRST OPNER.		;ERROR IF NOT
39990	;
40000	  MOVE R0,F.BTS(FL) ;CHECK TYPE OF FILE
40010	  TLNE R0,FB.EPY ;FOR EMPTY
40020	    JRST RRST1 ;HANDLE
40030	  TLNE R0,FB.ASC+FB.TTY ;FOR ASCII
40040	    ERR E.RRST ;ERROR IF SO
40050	  TLNE R0,FB.RNM ;FOR RANDOM NUMERIC
40060	    JRST RRST2 ;HANDLE
40070	  TLNE R0,FB.RST ;FOR RANDOM STRING
40080	    JRST RRST3 ;HANDLE
40090	  TLNE R0,FB.UDF ;FOR UNDEFINED
40100	    JRST RRST4 ;HANDLE
40110	  BLOWUP ;IMPOSSIBLE TO REACH
40120	;
40130	;   EMPTY
40140	;
40150	 RRST1:
40160	  CAIN R2,0 ;MUST SET TO 0
40170	    ERR E.RSTV ;ERROR IF NOT
40180	  JRA T,1(T) ;AND RETURN
40190	;
40200	;   RANDOM NUMERIC
40210	;
40220	 RRST2:
40230	  MOVE R0,R2 ;GET PTR IN R0
40240	  MOVNI R2,1		;END OF FILE
40250	  SFPTR
40260	    ERR E.FLR1	;SHOULD BE ABLE TO GET THERE
40270	  RFPTR			;FIND OUT WHERE THERE IS
40280	    ERR E.FLR1		;SHOUDL BE ABLE TO
40290	  CAMLE R0,R2 ;CHECK IF SETTING VALUD
40300	    ERR E.RSTV ;ERROR IF NOT
40310	  MOVE R2,R0 ;RESTORE SETTING
40320	  SFPTR ;SET PTR
40330	    ERR E.FLR1 ;ERROR IF CAN'T
40340	  JRA T,1(T) ;AND RETURN
40350	;
40360	;   RANDOM STRING
40370	;
40380	 RRST3:
40390	  IMUL R2,F.WLN(FL) ;BLOCK # TIMES BLOCK LEN
40400	  JRST RRST2 ;AND USE THAT FOR RANDOM NUM TYPE RESET
40410	;
40420	;   UNTYPED NON-EMPTY
40430	;
40440	 RRST4:
40450	  MOVEM R2,RGSV. ;SAVE R2
40460	  JSA T,RNSET. ;SET FILE AS RANDOM NUMERIC
40470	  MOVE R2,RGSV. ;RESTORE R2
40480	  HRRZ R1,F.JFN(FL) ;GET JFN OF FILE AGAIN
40490	  JRST RRST2 ;ANDPROCESS
40500	;
40510	;
40520	;
40530	;   ERROR MESSAGE
40540	;
40550	E.RRST: ER FLM,Can't access sequential file randomly
40560	;
40570	E.RSTV: ER FLM,Pointer setting invalid
40580	;
40590	;
40600	    PAGE
40610	    SUBTTL END OF ASSEMBLY
40620	;
40630	;
40640	;
40650	    PRGEND
40660	TITLE SBENT.--BASIC RUN TIME ROUTINES--SUB ENTER AND EXIT
40670	SUBTTL ASSEMBLY CONTROL
40680	SEARCH STENEX,BGBL,BRSYMS
40690	;
40700	;
40710	;
40720	ENTER SBENT.,SBEXT.
40730	;
40740	;
40750	EXTERNAL RGSV.,E.OTCR,SRBGS.,XINIT.,SDLOC.,CLFLS.,STKEX.
40760	;
40770	;
40780	    PAGE
40790	SUBTTL BASIC RUN TIME R0UTINES -- SBENTR
40800	;
40810	;   SBENT.--THIS ROUTINE ENTERS A SUB.  IT SETS UP THE STORAGE
40820	;      AS WELL AS SUCH THINGS AS FILES AND DATA POINTERS FOR THE
40830	;      NEW SUB, AS WELL AS SAVING THESE ITEMS FROM THE CALLING
40840	;      ROUTINE.
40850	;
40860	;
40870	SBENT.: Z
40880	;
40890	  MOVEM P,RGSV. ;SAVE INITIAL PDL/
40900	  MOVEM R2,RGSV.+1 ;SAVE R2
40910	  MOVEM V,RGSV.+2 ;SAVE INITIAL V
40920	  HRRZI V,1(P) ;GET INITIAL VAR PTR TO STACK
40930	;
40940	  HLRZ R2,PGNVRL(R1) ;GET LENGTH OF NUM VRS
40950	  HLRZ R0,PGSVRL(R1) ;GET LENGTH OF STR VRS
40960	  ADD R2,R0 ;GET TOTAL LENGTH
40970	  ADDI R2,1		;PLUS ONE
40980	  HRLS R2 ;IN BOTH HALVES
40990	  ADD P,R2 ;SAVE ROOM FOR VARS ON PDL
41000	  SKIPL P ;MAKE SURE WE'RE OKAY AS TO FIT
41010	    ERR E.OTCR ;ERROR IF NOT
41020	;
41030	  PUSH P,RGSV. ;SAVE OLD PDL
41040	  MOVE R2,RGSV.+2 ;RESTORE INITIAL V
41050	  PUSH P,R2 ;SAVE ON STACK
41060	  MOVEM R2,CALLV.(V) ;SAVE IN NEW AREA
41070	  PUSH P,SRBGS. ;FINALLY SAVE MARKER
41080	;
41090	  JSA T,XINIT. ;DO REST OF INITIALIZATIONS
41100	;
41110	  MOVE R2,RGSV. ;RESTORE R2
41120	  MOVE R1,PGDAT.(V) ;GET PROGRAM DATA PTR
41130	  SKIPN R1,PGNARG(R1) ;GET NUMBER OF ARGS
41140	    JRA T,0(T) ;NONE--DONE ALREADY
41150	;
41160	  HRRI R1,HDRLN.(V) ;GET PTR TO LOC OF FIRST ARG
41170	  EXCH V,RGSV.+2 ;GET OLD V REG BACK
41180	  EXCH T,SBENT.	;SAVE T REG
41190	;
41200	 SBENT1:
41210	  MOVEI R0,@0(T) ;PICK UP NEXT ARG
41220	  MOVEM R0,0(R1) ;SAVE
41230	  AOS T ;NEXT ARG
41240	  AOBJN R1,SBENT1 ;LOOP UNTIL ALL ARGS COUNTED
41250	  EXCH V,RGSV.+2 ;RESTORE NEW V
41260	  EXCH T,SBENT.	;RESTORE RETURN PTR
41270	;
41280	  JRA T,0(T) ;AND RETURN
41290	;
41300	;
41310	    PAGE
41320	SUBTTL BASIC RUN TIME ROUTINES -- SBEXT.
41330	;
41340	;   SBEXT--THIS ROUTINE HANDLES RETURNING FROM A SUB
41350	;      PROGRAM.  IT UNDOES ALL THE STACKING THAT SBENT DOES
41360	;      AND GETS RID OF THE VARIABLE AREA FORMED THERE.  MORE-
41370	;      OVER, IT DEALLOCATES ALL STRINGS USED IN THE SUB.
41380	;
41390	;
41400	SBEXT.: Z
41410	;
41420	  MOVE R2,PGDAT.(V) ;GET PROGRAM DATA PTR
41430	  HLRZ R1,PGSVRL(R2) ;GET NUMBER OF STR VRS
41440	  JUMPE R1,SBEX1 ;IF NONE, SKIP
41450	  HLRZ R2,PGNVRL(R2) ;NUMBER OF NUM VRS
41460	  ADD R2,V ;GET PTR TO FIRST STRING
41470	;
41480	 SBEX2:
41490	  AOS R2 ;GET NEXT STR PTR
41500	  JSA T,SDLOC. ;DEALLOCATE IT
41510	    JUMP 0(R2) ;PTR TO IT
41520	  SOJG R1,SBEX2 ;LOOP UNTIL DONE
41530	;
41540	 SBEX1:
41550	  JSA T,CLFLS. ;CLOSE FILES OF SUB
41560	  JSA T,STKEX. ;GET RID OF LINE NUMBER AND EXCESS GOSUBS
41570	;
41580	  POP P,R1 ;BUMP OUT PDL AT START
41590	  MOVE P,R1 ;GET RID OF VARIABLE AREA
41600	;
41610	  JRA T,0(T) ;AND THEN DONE--RETURN
41620	;
41630	;
41640	    PAGE
41650	SUBTTL END OF ASSEMBLY
41660	;
41670	;
41680	;
41690	PRGEND
41700	    TITLE  SCMPR. -- BASIC RUN TIME ROUTINES--STRING COMPARISON
41710	    SUBTTL ASSEMBLY CONTROL
41720	    SEARCH STENEX,BGBL,BRSYMS
41730	;
41740	;
41750	;
41760	;
41770	    ENTER SCMPR.
41780	;
41790	;
41800	    EXTERNAL RGSV.
41810	;
41820	;
41830	;
41840	;
41850	    PAGE
41860	    SUBTTL BASIC RUN TIME ROUTINES--SCMPR
41870	;
41880	;   SCMPR--THIS ROUTINE DOES STRING COMPARISON.  IT IS CALLED WITH
41890	;      TWO ARGUMENTS, BOTH STRINGS AND RETURNS -1,0, OR +1 IN
41900	;      R0 DEPENDING ON WETHER THE FIRST IS LESS THAN, EQUAL TO, OR GREATER
41910	;      THAN THE SECOND.  REGISTERS ARE NOT PRESERVED OVER THIS CALL.
41920	;
41930	;
41940	 SCMPR.:Z
41950	    MOVEM R2,RGSV. ;SAVE REGS 2...5
41960	    MOVEM R3,RGSV.+1
41970	    MOVEM R4,RGSV.+2
41980	    MOVEM R5,RGSV.+3
41990	    MOVE   R1,@0(T)    ;GET FIRST STRING
42000	    JUMPE  R1,SCMP1    ;HANDLE IF NULL
42010	    HLRZ   R0,-1(R1)   ;GET LENGTH IN CHRS
42020	    MOVE   R2,@1(T)    ;GET SECOND STRING
42030	    JUMPE  R2,SCMP2    ;HANDLE NULL
42040	    HLRZ   R3,-1(R2)   ;GET LENGTH OF SECOND
42050	;
42060	 SCMP5:
42070	    ILDB   R4,R1       ;GET NEXT BYTE FROM FIRST
42080	    ILDB   R5,R2       ;GET NEXT BYTE FROM SECOOND
42090	    CAME   R4,R5       ;CHECK IF EQQAL
42100	    JRST   SCMP3       ;HANDLE IF NOT
42110	    SOJE   R0,SCMP4    ;DEC COUN# OF FIRST
42120	    SOJG   R3,SCMP5    ;DEC CNT OF SECOND IF FIRST NOT DONE--LOOP
42130	;
42140	 SCMP2:
42150	    MOVEI  R5,ASCSPA   ;ELSE SPACE FULL EMPTY STRING
42160	;
42170	 SCMP6:
42180	    ILDB   R4,R1       ;S2 DONE, S1 NOT
42190	    CAIE   R4,ASCSPA   ;CHECK IF STILL EQUAL
42200	    JRST   SCMP3       ;NO--FAIL RETURN
42210	    SOJG   R0,SCMP6    ;REPEAT TILL OUT OF CHARACTERS
42220	;
42230	 SCMP7:
42240	    MOVEI  R1,0        ;STRINGS ARE EQUAL
42250	    JRST SCMP8 ;AND EXIT
42260	;
42270	 SCMP4:
42280	    SOJE   R3,SCMP7    ;DONE FIRST STRING--CHECK IF DONE SECOND AS WELL
42290	    MOVEI  R4,ASCSPA   ;IF NOT, USE SPACES IN STEAD OF  FIRST
42300	    ILDB   R5,R2       ;GET NEXT CHAR FROM S2
42310	    CAIE   R5,ASCSPA   ;EQUAL
42320	    JRST   SCMP3       ;NO--FAIL RETURN
42330	    SOJG   R3,.-3      ;CONTINUE UNTIL STRING DONE
42340	    JRST   SCMP7       ;AND THEN RETURN EQUAL
42350	;
42360	 SCMP1:
42370	    MOVE   R2,@1(T)    ;FIRST NULL--LOOK AT SECOND
42380	    JUMPE  R2,SCMP7    ;IF ALSO NULL ,THEN EQUAL STRINGS
42390	    HLRZ   R3,-1(R2)   ;ELSE GET LENGTH OF SECOND
42400	    JRST   SCMP4       ;AND CHECK FOR ALL SPACES
42410	;
42420	 SCMP3:
42430	    MOVEI  R1,1        ;GUESS GREATER
42440	    CAMG   R4,R5       ;CHECK GUESS
42450	    MOVNS  R1          ;WRONG--CHANGE SIGN
42460	;
42470	 SCMP8:
42480	  MOVE R2,RGSV. ;RESTORE R2...R5
42490	  MOVE R3,RGSV.+1
42500	  MOVE R4,RGSV.+2
42510	  MOVE R5,RGSV.+3
42520	  JRA T,2(T) ;AND RETURN
42530	;
42540	;
42550	    PAGE
42560	    SUBTTL END OF ASSEMBLY
42570	;
42580	;
42590	;
42600	    PRGEND
42610	    TITLE  SCRCH. -- BASIC RUN TIME FILE ROUTINES--SCRATCH
42620	    SUBTTL ASSEMBLY CONTROL
42630	    SEARCH STENEX,BGBL,BRSYMS
42640	;
42650	;
42660	;
42670	    ENTER SCRCH.
42680	;
42690	;
42700	    EXTERNAL TMPTL.,TMPBF.,OPNFL.,OPNER.,RGSV.
42710	;
42720	;
42730	;
42740	;
42750	    PAGE
42760	    SUBTTL BASIC RUN TIM EFILE ROUTINES--SCRCH
42770	;
42780	;   SCRCH--THIS ROUTINE HANDLES THE SCRATCH STATEMENT.  IT CREATES
42790	;      A FILE WITH A NEW VERSION NUMBER FOR OUTPUUT WITH THE SAME NAME
42800	;      AS THAT GIVEN.
42810	;
42820	;
42830	 SCRCH.:Z
42840	;
42850	  MOVE R0,F.BTS(FL) ;GET FILE BITS
42860	  SKIPN F.JFN(FL) ;AND JFN
42870	    JRST OPNER.		;MUST HAVE JFN
42880	  TLNE R0,FB.EPY+FB.TTY ;CHECK IF FILE EMPTY
42890	    JRA T,0(T) ;YES--ALREADY SCRATCHED
42900	  TLZ R0,FB.ASC+FB.RNM+FB.RST ;UNTYPE
42910	  TLO R0,FB.UDF+FB.EPY ;MAKE UNTYPED AND EMPTY
42920	  MOVEM R0,F.BTS(FL) ;RESAVE THE BITS
42930	  JSA T,OPNFL. ;GET THE FILE OPEN
42940	    EXP FB.PG ;FOR WHATEVER WE CAN GET
42950	  HRRZ R1,F.JFN(FL)	;GET JFN
42960	  HRLI R1,FDBSIZ	;AND THE SIZE WORD IF FDB
42970	  MOVNI R2,1		;CHANGE ALL OR IT
42980	  MOVEM R3,RGSV.	;SAVE R3
42990	  MOVEI R3,0		;SET LENGTH TO 0
43000	  CHFDB			;DO IT
43010	  MOVE R3,RGSV.		;RESTORE R3
43020	;
43030	 SCRCH1:
43040	  HRRZ R1,F.JFN(FL) ;GET JFN OF FILE
43050	  FFUFP ;GET FIRST USED PAGE
43060	    JRA T,0(T)	;RETURN IF NO MORE USED PAGES
43070	  MOVE R2,R1		;GET PTR TO NEXT PAGE
43080	  SETOM R1,		;PREPARE TO DELETE PAGE
43090	  PMAP ;NOW GET RID OF PAGE
43100	  JRST SCRCH1 ;AND LOOP FOR NEXT PAGE
43110	;
43120	;
43130	    PAGE
43140	    SUBTTL END OF ASSEMBLY
43150	;
43160	;
43170	;
43180	    PRGEND
43190	    TITLE  STOP. -- BASIC RUN TIME ROUTINES--STOP
43200	    SUBTTL ASSEMBLY CONTROL
43210	    SEARCH STENEX,BGBL,BRSYMS
43220	;
43230	;
43240	;
43250	;
43260	;
43270	    ENTER STOP.,STPFL.
43280	;
43290	;
43300	    EXTERNAL E.FLR1,CLFLS.,RGSV.,STTIM.,RBGSP.,CNTOF.
43310	;
43320	;
43330	;
43340	;
43350	    PAGE
43360	    SUBTTL BASIC RUN TIME ROUTINES--STOP
43370	;
43380	;   STOP--THIS ROUTINE DOES A NORMAL TERMINATION FOR A BASIC RUN.
43390	;      IT CLOSES ALL FILES AND THEN PRINTS A CLOSING MESSAGE AND THEN
43400	;      HALTS.
43410	;
43420	;
43430	 STOP.:Z
43440	;
43450	  SETZM CNTOF.		;ALLOW TTY OUTPUT
43460	  JSA T,STPFL.		;CLOSE ALL FILES
43470	;
43480	  HRRZ R1,DBGENT	;CHECK IF DEBUGGER ACTIVE
43490	  SKIPE R1		;SKIP IF NOT
43500	    JSA T,0(R1)		;IF SO, TELL IT WE'RE STOPPING
43510	;
43520	    ERR    E.STOP      ;JUST PRINT CLOSING MESSAGE
43530	;
43540	  HRROI R1,[ASCIZ /TIME: /]	;FINAL MESSAGE
43550	  PSOUT
43560	  HRRZI R1,400000	;CURRENT FORK
43570	  RUNTM
43580	  SUB R1,STTIM.	;GET DELTA TIME
43590	  FSC R1,233		;GET FLOATED TIME
43600	  FSC R2,233		;AND UNITS
43610	  FDVM R1,R2		;GET TIME IN SECONDS
43620	  MOVEI R1,101		;TO TTY
43630	  MOVEI R3,0
43640	  FLOUT
43650	    BLOWUP
43660	  HRROI R1,[ASCIZ / SEC./]
43670	  PSOUT
43680	  MOVEI R1,37		;END OF MESSAGE
43690	  PBOUT
43700	  PBOUT
43710	;
43720	  HALTF			;NOW HALT
43730	  JRA T,0(T)		;ALLOW USER TO CONTINUE
43740	;
43750	;
43760	;   ERROR MESSAGE
43770	;
43780	E.STOP: ER WRN,Program halted
43790	;
43800	    PAGE
43810	SUBTTL BASIC RUN TIME  ROUTINES--STPFL.
43820	;
43830	;   STPFL.--THIS ROUTINE IS USED BY STOP AND BY CHAIN
43840	;      TO CLOSE ALL OPEN FILES IN PREPARATION FOR TERMINATING
43850	;      AT LEAST THIS PORTION OF THE RUN.  IT GOES THRU
43860	;      THE STACK AND FINDS ALL RELEVANT FILES.
43870	;
43880	;
43890	STPFL.: Z
43900	;
43910	  MOVEM V,RGSV.	;SAVE INITIAL V
43920	  MOVEM P,RGSV.+1	;AND P
43930	  SKIPE DBGPDL		;CHECK IF IN DEBUGGER
43940	    MOVE P,DBGPDL	;IF SO, USE SAVED PDL
43950	  JSA T,CLFLS.	;CLOSE FILES OF CURRENT SUB/PROGRAM
43960	;
43970	 STOP4:
43980	  MOVE R2,0(P)		;GET ITEM OFF STACK
43990	  TLZ R2,400000	;TURN OFF FLAG BIT
44000	  CAME R2,RBGSP.	;CHECK IF MARKER
44010	    SOJA P,STOP4	;LOOP IF NOT
44020	  SOS P			;GO BEYOND MARKER
44030	  MOVE V,0(P)		;RESTORE OLD V REG
44040	  CAMN V,[XWD 333333,333333] ;CHECK IF DONE
44050	    JRST STOP3		;HANDLE DONE
44060	  JSA T,CLFLS.		;CLOSE ALL FILES FOR CURRENT BLOCK
44070	  HLRZ R1,1(P)		;GET FLAG
44080	  CAIN R1,400000	;CHECK IF SUB/FCT
44090	  MOVE P,-1(P)		;FOR SUB, BACK PDL OVER VARS
44100	  SOJA P,STOP4		;LOOK FOR ANOTHER MARKER
44110	;
44120	 STOP3:
44130	  MOVE V,RGSV.		;RESTORE V
44140	  MOVE P,RGSV.+1	;AND P
44150	  JRA T,0(T)		;AND THEN RETURN
44160	;
44170	;
44180	    PAGE
44190	    SUBTTL END OF ASSEMBLY
44200	;
44210	;
44220	;
44230	    PRGEND
44240	    TITLE TAB. -- BASIC RUN TIME FILE ROUTINES -- TABBING
44250	    SUBTTL ASSEMBLY CONTROL
44260	    SEARCH STENEX,BGBL,BRSYMS
44270	;
44280	;
44290	;
44300	;
44310	    ENTER TAB.,TBCMA.
44320	;
44330	;
44340	    EXTERNAL RGSV.,OTCHR.,PEOL.
44350	;
44360	;
44370	;
44380	;
44390	    PAGE
44400	    SUBTTL BASIC RUN TIME FILE ROUTINES--TAB
44410	;
44420	;   TAB--THIS ROUTINE TAKES ONE ARGUMENT, AN INTEGER, AND CAUSES THE COMPUTER
44430	;      TO TAB TO THAT POSITION IN THE CURRENT FILE.  IF THE POSITION IS
44440	;      LARGER THAN THE MARGIN, THEN IT IS TAKEN MOD THE MARGIN, ELSE IF
44450	;      WE ARE AT OR PAST THE SPECIFIED POSITION, ONLY ONE SPACE IS PRINTED.
44460	;
44470	;
44480	 FCT TAB.,N,1,N
44490	;
44500	  XFIX R0,@0(T) ;PICK UP COLUMN TO TAB TO
44510	;
44520	 TABA:
44530	  MOVE R1,R0 ;GET COL IN R1
44540	  SKIPE F.MAR(FL) ;CHECK IF MARGIN GIVEN
44550	  IDIV R0,F.MAR(FL) ;IF SO, USE MOD MARGIN
44560	  MOVE R0,R1 ;GET REAL COLUMN NUM IN R0
44570	;
44580	 TABA2:
44590	  SUB R0,F.CPOS(FL) ;GET LENGTH TO TAB
44600	  SKIPG R0 ;CHECK IF WE MUST TAB ANY
44610	    JRA T,1(T) ;NO--RETURN
44620	;
44630	  HRRZ R1,F.JFN(FL) ;GET JFN
44640	  CAIG R0,10 ;CHECK IF WE CAN USE A TAB
44650	    JRST TABA1 ;NO--SPACE FILL
44660	  ADD R0,F.CPOS(FL) ;GET FINAL COLUMN
44670	  MOVEM R0,RGSV. ;SAVE IT
44680	  MOVEI R2,ASC.HT ;AND GET A TAB CHR
44690	  JSA T,OTCHR. ;PRINT IT
44700	  MOVE R0,RGSV. ;RESTORE COLUMN TO TAB TO
44710	  JRST TABA2 ;AND CHECK DISTANCE TO GO AGAIN
44720	;
44730	 TABA1:
44740	  MOVEM R0,RGSV. ;SAVE AMOUNT TO TAB
44750	;
44760	 TABA3:
44770	  MOVEI R2,ASCSPA ;GET SPACE
44780	  JSA T,OTCHR. ;PRINT IT
44790	  SOSLE RGSV. ;DECREMENT COUNT TO GO
44800	    JRST TABA3 ;LOOP IF MORE TO GO
44810	;
44820	  JRA T,1(T) ;AND RETURN WHEN DONE
44830	;
44840	;
44850	    PAGE
44860	    SUBTTL BASIC RUN TIME FILE ROUTINES--TBCMA
44870	;
44880	;   TBCMA--THIS ROUTINE TABS FOR A COMMA IN THE PRINT STREAM BY
44890	;      GOING OUT TO THE NEXT MULTIPLE OF 15.
44900	;
44910	;
44920	 TBCMA.:Z
44930	    MOVE   R0,F.CPOS(FL) ;GET CURRENT CHAR POS
44940	    IDIVI  R0,17       ;DIVIDE BY 15
44950	    ADDI   R0,1        ;QUOTIENT PLUS ONE
44960	    IMULI  R0,17       ;TIME 15--> NEXT MULTIPLE
44970	    SOS    T           ;BUMP RETURN FOR NO ARGS
44980	    SKIPE F.MAR(FL)	;CHECK IF MARGIN GIVEN
44990	    CAMGE R0,F.MAR(FL)	;AND IF SO, CHECK IF BEYOND IT
45000	      JRST TABA		;IF NOT, THEN JUST TAB
45010	    JSA T,PEOL.		;IF SO, PRINT END OF LINE
45020	    JRA T,1(T)		;AND THEN DONE
45030	;
45040	;
45050	    PAGE
45060	    SUBTTL END OF ASSEMBLY
45070	;
45080	;
45090	;
45100	    PRGEND
45110	    TITLE  TSET. -- BASIC RUN TIME FILE ROUTINES--TTY SET UP
45120	    SUBTTL ASSEMBLY CONTROL
45130	    SEARCH STENEX,BGBL,BRSYMS
45140	;
45150	;
45160	;
45170	;
45180	    ENTER TSET.
45190	;
45200	;
45210	    EXTERNAL CRTTY.
45220	;
45230	;
45240	;
45250	;
45260	    PAGE
45270	    SUBTTL BASIC RUN TIME FILE ROUTINES--TSET
45280	;
45290	;   TSET--THIS ROUTINE SETS UP FOR I/O ON TELETYPE (FILE NUMBER 0).  IT
45300	;      IS CALLED IN PLACE OF FSET WHEN NO FILE NUMBER IS GIVEN FOR AN
45310	;      ASCII DEVICE.
45320	;
45330	;
45340	 TSET.:Z
45350	    MOVEI   FL,CRTTY.   ;GET TTY POINTER
45360	    JRA    T,0(T)      ;AND RETURN
45370	;
45380	    PAGE
45390	    SUBTTL END OF ASSEMBLY
45400	;
45410	;
45420	;
45430	    PRGEND
45440	TITLE USING. -- BASIC RUN TIME FILE ROUTINES--PRINT USING
45450	SUBTTL ASSEMBLY CONTROL
45460	SEARCH STENEX,BGBL,BRSYMS
45470	;
45480	;
45490	;
45500	ENTER USING.,PUNUM.,PUSTR.,PUEND.,USEOL.
45510	;
45520	;
45530	;
45540	EXTERNAL OTCHR.,SDLOC.,TMPTL.,RGSV.
45550	;
45560	;
45570	;
45580	    PAGE
45590	SUBTTL BASIC RUN TIME FILE ROUTINES--USING.
45600	;
45610	;   USING.--THIS ROUTINE IS CALLED WITH A USING STRING AS THE
45620	;      ARGUMENT.  IT SETS UP TO DO FUTURE PRINT USINGS FROM THIS
45630	;      STRING.
45640	;
45650	;
45660	USING.: Z
45670	;
45680	  SKIPN R1,@0(T) ;CHECK FOR NULL STRING, GET IN R1
45690	    ERR E.IUST ;CANT BE NULL
45700	  MOVEM R1,USGSTR# ;SAVE STRING PTR
45710	  AOS -1(R1) ;BUMP ALLOCATION COUNT OF STRING
45720	  MOVEM R1,CURTL# ;SAVE AS CURRENT TALLY
45730	  SETOM USFLG# ;SET FLAG FOR FIRST TIME
45740	  JRA T,1(T) ;AND RETURN
45750	;
45760	;
45770	;   ERROR MESSAGES
45780	;
45790	E.IUST: ER FLM,Illegal USING string
45800	;
45810	;
45820	    PAGE
45830	SUBTTL BASIC RUN TIME FILE ROUTINES--PUNUM.
45840	;
45850	;   PUNUM--THIS ROUTINE TAKES ONE ARGUMENT, A NUMBER AND PRINTS
45860	;      IT IN THE NEXT FIELD S~PECIFIED IN THE GIVEN USING STRING.
45870	;
45880	;
45890	PUNUM.: Z
45900	;
45910	  JSA T,UCKEOL ;CHECK FOR START OF NEW LINE
45920	  MOVEM R3,RGSV. ;SAVE R3
45930	  MOVE R0,CURTL ;GET CURRENT TALLY TO USING STRING
45940	  MOVEM R0,XCRTL# ;SAVE FOR LATER USE
45950	  SETZM NMLDG# ;ZERO NUMBER DIGITS LEFT OF DP
45960	  SETZM NMRDG# ;ZERO NUMBER OF DIGITS RIGHT OF DP
45970	  SETZM NMEDG# ;ZERO NUMBER OF DIGIT IN EXP
45980	  SETZM DPFG# ;NO DECIMAL PT
45990	  SETZM SGNFG# ;NO SIGN GIVEN
46000	  SETZM DOLFG# ;DOLLAR SIGN NOT GIVEN
46010	  SETZM OVFOFG# ;OVERFLOW NOT INDICATED
46020	;
46030	 PUNM0:
46040	  ILDB R0,CURTL ;GET NEXT CHR FROM USING STR
46050	  CAIN R0,"+" ;CHECK FOR START OF FIELD
46060	    JRST PUNM1 ;HANDLE +-FIELD
46070	  CAIN R0,"-" ;MINUS MAY ALSO START FIELD
46080	    JRST PUNM2 ;HANDLE --FIELD
46090	  CAIN R0,"$" ;CHECK FOR DOLLAR FIELD
46100	    JRST PUNM3 ;HANDLE $-FIELD
46110	  CAIE R0,"<" ;CHECK FOR STRING FIELD NEXT
46120	  CAIN R0,">"
46130	    ERR E.IUST ;ERROR IF SO
46140	  JUMPN R0,PUNM0 ;IF MORE STRING TO GO, HANDLE
46150	  ERR E.IUST ;ELSE NO FIELD IN STRING
46160	;
46170	 PUNM1:
46180	  AOS SGNFG ;INDICATE +==SIGN REQUIRED
46190	  JRST PUNM9 ;AND SKIP
46200	;
46210	 PUNM2:
46220	  SETOM SGNFG ;INDICATE -==SIGN ONLY IF NEGATIVE
46230	  JRST PUNM9 ;SKIP
46240	;
46250	 PUNM3:
46260	  SETOM DOLFG ;INDICATE $
46270	;
46280	 PUNM9:
46290	  AOS NMLDG ;ONE CHR LEFT OF DP SCANNED
46300	;
46310	;
46320	    PAGE
46330	;
46340	;   HANDLE MIDDLE OF NUMERIC USING FIELD
46350	;
46360	 PUNM10:
46370	  ILDB R0,CURTL ;GET NEXT CHR
46380	  CAIN R0,"+" ;CHECK IF NEW FIELD
46390	    JRST PUNM11 ;OR $+
46400	  CAIN R0,"-" ;CHECK FOR NEW FILED
46410	    JRST PUNM12 ;OR $-
46420	  CAIN R0,"$" ;CHECK IF NEW FIELD
46430	    JRST PUNM20 ;HANDLE
46440	  CAIN R0,"#" ;CHECK FOR DIGIT POSITION
46450	    JRST PUNM14 ;HANDLE
46460	  CAIN R0,"." ;CHECK FOR DECIMAL PT
46470	    JRST PUNM15 ;HANDLE
46480	  CAIN R0,"^" ;CHECK FOR EXPONENT
46490	    JRST PUNM17 ;HANDLE
46500	  CAIE R0,"<" ;CHECK FOR NEW STRING FIELD
46510	  CAIN R0,">" ;STARTING NOW
46520	    JRST PUNM20 ;HANDLE IF SO
46530	  JUMPN R0,PUNM10 ;IGNORE MISC CHRS
46540	  JRST PUNM20 ;HANDLE END OF STRING--END OF FIELD
46550	;
46560	 PUNM11:  
46570	  SKIPE SGNFG ;+ FOUND--CHECK FOR $+
46580	    JRST PUNM20 ;NO--END OF FIELD
46590	  AOS SGNFG ;YES--INGIDCATE SIGN REQUIRED
46600	  JRST PUNM13 ;AND GET NEXT CHR
46610	;
46620	 PUNM12:
46630	  SKIPE SGNFG ;- FOUND--CHECK FOR $-
46640	    JRST PUNM20 ;NO--END OF FIELD
46650	  SETOM SGNFG ;SET FOR TYPE OF SIGN
46660	;
46670	 PUNM13:
46680	  SKIPE NMEDG ;CHECK FOR EXPONENT ALREADY
46690	    JRST PUNM20 ;END OF FIELD IF SO
46700	  MOVE R0,NMLDG ;CHECK FOR DIGITS SCANNED
46710	  ADD R0,DPFG ;OR FOR DP
46720	  CAIN R0,1 ;ONE IS OK
46730	    JRST PUNM14 ;OK--ANOTHER DIGIT POSITION
46740	  SETZM SGNFG ;ELSE CLEAR SIGN FLAG
46750	  JRST PUNM20 ;AND HANDLE NEW FILED
46760	;
46770	 PUNM14:
46780	  SKIPN DPFG ;CHECK IF AFTER DP
46790	    AOS NMLDG ;IF NOT, LEFT OF IT
46800	  SKIPE DPFG ;CHECK OPPOSITIE
46810	    AOS NMRDG ;AFTER DP
46820	  SKIPE NMEDG ;CHECK IF IN EXPONENT
46830	    ERR E.IUST ;ILLEGAL IF SO FOR DIGIT
46840	  JRST PUNM10 ;AND GO ON TO NEXT CHR
46850	;
46860	 PUNM15:
46870	  SKIPE NMEDG ;DP ILLEGAL IN EXP FIELD
46880	    ERR E.IUST ;ERROR IF THAT'S FOUND
46890	  SKIPN DPFG ;CHECK IF PREVIOUS DP
46900	    JRST PUNM16 ;NO--HANDLE FIRST
46910	  MOVE R0,NMRDG ;YES--GET DIGITS AFTER IT
46920	  ADDM R0,NMLDG ;PROCEDE TO IGNORE IT'S EXISTANCE
46930	  SETZM NMRDG ;TOTALLY
46940	;
46950	 PUNM16:
46960	  MOVE R0,CURTL ;GET CURRENT TALLY
46970	  MOVEM DPFG ;SAVE THAT AS FLAG
46980	  JRST PUNM10 ;AND GO ON TO NEXT CHR
46990	;
47000	 PUNM17:
47010	  AOS NMEDG ;ANOTHER EXPONENT DIGIT
47020	  JRST PUNM10 ;GO ON TO NEXT CHR
47030	;
47040	;
47050	    PAGE
47060	;
47070	;   NOW SET UP TENEX FORMAT CONTROL WORD
47080	;
47090	 PUNM20:
47100	  MOVE R2,@0(T) ;GET NUMBER TO PRINT
47110	  MOVE R0,NMLDG ;GET NUMBER OF LEFT OF DP DIGITS
47120	  SKIPG SGNFG ;CHECK IF SIGN MANDATORY
47130	  SKIPGE R2 ;OR IF NUMBER DEMANDS ONE
47140	  SOS R0 ;IF SO, ONE LESS SPACE FOR NUMBER
47150	  SKIPN DOLFG ;CHECK IF DOLLAR SIGN NEEDED
47160	    SOS R0 ;IF SO, ONE LESS SPACE
47170	  MOVEM R0,NMDG# ;SAVE AS NUMBER OF DIGITS
47180	;
47190	  MOVE R1,TMPTL. ;GET TALLY TO PLACE FOR PUTTING RESULT
47200	  MOVEI R3,0 ;CLEAR INITIAL FCW
47210	  SKIPLE SGNFG ;CHECK IF SIGN NOT MANDATORY
47220	  MOVSI R3,400000 ;INDICATE SIGN MANDATORY
47230	;
47240	  SKIPE NMDG ;CHECK IF SPACE FOR DIGIT
47250	    TLO R3,020000 ;YES--PRINT AT LEAST ONE LEFT OF DP
47260	;
47270	  SKIPE DOLFG ;CHECK IF DOLLAR SIGN REQUESTED
47280	    TLO R3,010000 ;YES--INDICATE
47290	  SKIPE DPFG ;CHECK IF DECIMAL PT REQUESTED
47300	    TLO R3,004000 ;YES--PRINT IT
47310	  SKIPN NMEDG ;CHECK FOR EXPONENT FIELD
47320	    JRST PUNM21 ;NO--SKIP
47330	  TLO R3,001200 ;YES--SPECIFY TYPE
47340	  MOVE R0,NMLDG ;CHECK NUM DIG LEFT OF DP
47350	  CAILE R0,1 ;FOR >2
47360	  TLO R3,200000 ;IF ROOM, LEAD OFF WITH SPACE
47370	;
47380	 PUNM21:
47390	  MOVE R0,NMDG ;DIGITS SPACE LEFT OF DP
47400	  ADD R0,NMRDG ;TOTAL SPACE
47410	  DPB R0,[POINT 5,R3,17] ;SAVE FOR ROUNDING
47420	;
47430	  MOVE R0,NMLDG ;SPACE IN FIELD ONE
47440	  DPB R0,[POINT 6,R3,23] ;SAVE
47450	  MOVE R0,NMRDG ;SPACE IN FIELD TWO
47460	  DPB R0,[POINT 6,R3,29] ;SAVE
47470	  MOVE R0,NMEDG ;SPACE IN FIELD THREE
47480	  DPB R0,[POINT 6,R3,35] ;SAVE
47490	  FLOUT ;NUMBER TO TEMP BUFFER
47500	    JRST PUNM50 ;HANDLE ERRORS ON CONVERSION
47510	;
47520	;
47530	    PAGE
47540	;
47550	;   NOW PRINT THE RESULTANT NUMBER IN THE FIELD
47560	;
47570	 PUNM30:
47580	  HRRZ R1,F.JFN(FL) ;GET JFN OF FILE
47590	  MOVE R3,TMPTL. ;GET TEMP TALLY TO RESULTANT STR
47600	  EXCH R3,XCRTL ;SAVE IT, GET TALLY TO USING STRING
47610	;
47620	 PUNM35:
47630	  ILDB R2,R3 ;GET NEXT USING STR CHR
47640	  CAMN R3,CURTL ;CHECK IF FIRST CHR OF NEXT FIELD
47650	    JRST PUNM40 ;YES--DONE
47660	  CAIN R2,"-" ;CHECK FOR USABLE CHR
47670	    JRST PUNM31 ;USABLE
47680	  CAIN R2,"+"
47690	    JRST PUNM31 ;+ IS USABLE
47700	  CAIN R2,"$"
47710	    JRST PUNM31 ;$ IS USABLE
47720	  CAIN R2,"#"
47730	    JRST PUNM31 ;# IS USABLE
47740	  CAIN R2,"^"
47750	    JRST PUNM31 ;^ IS USABLE
47760	  CAIN R2,"." ;CHECK FOR "."
47770	    JRST PUNM32 ;THAT IS SOMETIMES USABLE
47780	;
47790	 PUNM33:
47800	  JSA T,OTCHR. ;MISC--PRINT IT
47810	  JRST PUNM35 ;AND GO ON TO NEXT
47820	;
47830	 PUNM31:
47840	  SKIPN R2,OVFOFG ;DIGIT POSITION--CHECK IF OVERFLOW
47850	    ILDB R2,XCRTL ;NOT OVERFLOW--GET DIGIT
47860	  JRST PUNM33 ;AND PRINT IT
47870	;
47880	 PUNM32:
47890	  CAMN R3,DPFG ;DECIMAL PT--CHECK IF IT IS THE REAL ONE
47900	    JRST PUNM31 ;REAL ONE--HANDLE LIKE DIGIT
47910	  MOVEI R2," " ;ELSE USE A SPACE
47920	  JRST PUNM33 ;AS A COMMENT CHR
47930	;
47940	 PUNM34:
47950	  MOVEI R1,"*" ;OVERFLOW INDICATED
47960	  MOVEM R1,OVFOFG ;SAVE CHR AS FLAG
47970	  JRST PUNM30 ;AND START FIELD
47980	;
47990	;
48000	    PAGE
48010	;
48020	;   HANDLE END OF STRING
48030	;
48040	 PUNM40:
48050	  LDB R0,CURTL ;CHECK LAST CHR OF FIELD
48060	  JUMPN R0,PUNM41 ;NOT END OF STRING--SKIP
48070	  MOVE R0,USGSTR ;END OF STRING--RESTORE TALLY
48080	  MOVEM R0,CURTL ;AND PREPARE TO START OVER
48090	;
48100	 PUNM41:
48110	  MOVE R3,RGSV. ;RESTORE R3
48120	  JRA T,1(T) ;THEN RETURN
48130	;
48140	;
48150	;   HANDLE ERROR IN CONVERSION
48160	;
48170	 PUNM50:
48180	  CAIN R3,FLOTX2 ;CHECK FOR FIELD 3 OVERFLOW
48190	    ERR E.IUSE ;ILLGAL EXPONENT IF SO
48200	  CAIN R3,FLOTX1 ;CHECK FOR FIELD OVERFLOW
48210	    JRST PUNM34 ;PRINT "*" FOR ALL DIGIT POSITIONS
48220	  ERR E.IUST ;ELSE SOMETHINGS WRONG WITH STRING
48230	;
48240	;
48250	;   ERROR MESSAGES
48260	;
48270	E.IUSE: ER FLM,Illegal exponent field in USING string
48280	;
48290	;
48300	    PAGE
48310	SUBTTL BASIC RUN TIME FILE ROUTINES--PUSTR.
48320	;
48330	;   PUSTR.--THIS ROUTINE IS USED TO PRINT ITS STRING ARGUMENT
48340	;      IN THE NEXT POSITION IN THE USING FIELD WHICH MUST BE FOR
48350	;      A STRING.
48360	;
48370	;
48380	PUSTR.: Z
48390	;
48400	  JSA T,UCKEOL ;CHECK FOR START OF NEW LINE
48410	  MOVEM R3,RGSV. ;SAVE R3
48420	  MOVEM R4,RGSV.+1 ;AND R4
48430	  MOVE R3,RGSV. ;RESTORE R3 AND R4
48440	  MOVE R4,RGSV.+1
48450	  MOVE R0,CURTL ;GET CURRENT TALLY TO USING STRING
48460	  MOVEM R0,XCRTL# ;SAVE FOR LATER USE
48470	  SETZM NMLDG# ;CLEAR CHR COUNT
48480	  SETZM SGNFG ;CLEAR JUSTIFICATION FLAG
48490	;
48500	 PUST0:
48510	  ILDB R0,CURTL ;GET NEXT CHR FROM USING STRING
48520	  CAIN R0,"<" ;LOOK FOR FIELD START
48530	    JRST PUST2 ;YES--LEFT JUST
48540	  CAIN R0,">" ;AGAIN
48550	    JRST PUST1 ;YES--RUIGHT JUST
48560	  CAIE R0,"+" ;CHECK FOR NUMERIC FIELD
48570	  CAIN R0,"-" ;WHICH IS ILLEGAL
48580	    ERR E.IUST ;ERROR IF NUMERIC FIELD
48590	  CAIN R0,"$" ;CHECK FOR DOLLAR SIGN FIELD
48600	    ERR E.IUST ;ALSO NUMERIC, ALSO ILLEGAL
48610	  JRST PUST0 ;IGNORE MISC CHR
48620	;
48630	 PUST1:
48640	  SETOM SGNFG ;-1 MEANS LEFT
48650	;
48660	 PUST2:
48670	  AOS NMLDG ;FIRST STR POS
48680	;
48690	;
48700	    PAGE
48710	;
48720	;   NOW SCAN REST OF FIELD
48730	;
48740	 PUST10:
48750	  ILDB R0,CURTL ;GET NEXT USING CHR
48760	  JUMPE R0,PUST20 ;NULL--END OF STR, END OF FIELD
48770	  CAIN R0,"#" ;CHECK FOR FIELD
48780	    JRST PUST11 ;HANDLE IN FIELD
48790	;
48800	  CAIE R0,"<" ;LOOK FOR ANOTHER FIELD
48810	  CAIN R0,">"
48820	    JRST PUST20 ;END OF FIELD
48830	;
48840	  CAIE R0,"+" ;LOOK FOR NUMERIC FIELD
48850	  CAIN R0,"-"
48860	    JRST PUST20 ;END OF FIELD
48870	;
48880	  CAIN R0,"$" ;LOOK FOR $-FIELD
48890	    JRST PUST20 ;NEW FIELD IF SO
48900	;
48910	  JRST PUST10 ;ELSE IGNORE CHR
48920	;
48930	 PUST11:
48940	  AOS NMLDG ;INCREASE FIELD SIZE
48950	  JRST PUST10 ;AND THEN GET NEXT CHR
48960	;
48970	;
48980	    PAGE
48990	;
49000	;   FIGURE POSITION OF STRING IN FIELD
49010	;
49020	 PUST20:
49030	  SETZM OVFOFG# ;ASSUME NO EXCESS
49040	  SKIPN R3,@0(T) ;PICK UP STRING TO USE
49050	  JRST PUST21 ;IF NULL, HANDLE
49060	;
49070	  HLRZ R4,-1(R3) ;GET LENGTH OF STRING TO PRINT
49080	  SUB R4,NMLDG ;CHECK AGAINST FIELD SIZE
49090	  JUMPE R4,PUST30 ;IF FIELD IS OK
49100	  JUMPG R4,PUST22 ;HANDLE TOO MUCH STRING
49110	;
49120	  MOVEM R4,OVFOFG ;SAVE EXCESS IF STRING IS LARGER
49130	  SKIPN SGNFG ;CHECK JUSTIFICATION
49140	  MOVNM R4,OVFOFG ;NEGATIVE IF LEFT
49150	  JRST PUST30 ;NOW PRINT
49160	;
49170	 PUST21:
49180	  MOVN R4,NMLDG ;GET SIZE OF FIELD TO BLANK FILL
49190	  MOVEM R4,OVFOFG ;SAVE FOR FIELD
49200	  JRST PUST30 ;AND PROCESS
49210	;
49220	 PUST22:
49230	  SKIPN SGNFG ;CHECK JUSTIFICATION
49240	    JRST PUST30 ;JUST PRINT FIRST PART OF STRING
49250	  ILDB R0,R3 ;PRINT LAST PART--SKIP FIRST
49260	  SOJG R4,.-1 ;FOR AS MANY CHRS AS NEEDED
49270	;
49280	;
49290	    PAGE
49300	;
49310	;   NOW PRINT STRING
49320	;
49330	 PUST30:
49340	  HRRZ R1,F.JFN(FL) ;GET FILE JFN
49350	  EXCH R3,XCRTL ;SAVE STRING TALLY, GET USING TALLY AT FIELD HEAD
49360	;
49370	 PUST31:
49380	  ILDB R2,R3 ;GET NEXT USING CHR
49390	  CAMN R3,CURTL ;CHECK IF DONE
49400	    JRST PUST40 ;HANDLE DONE
49410	  CAIE R2,"<" ;R2ECK IF FIELD R2R
49420	  CAIN R2,">" ;FOR HEAD
49430	    JRST PUST32 ;OK--PRINT FROM STR
49440	  CAIN R2,"#" ;INSIDE FIELD R2R
49450	    JRST PUST32 ;OK
49460	;
49470	 PUST33:
49480	  JSA T,OTCHR. ;PRINT CHR INTO FILE
49490	  JRST PUST31 ;AND GET NEXT USING CHR
49500	;
49510	 PUST32:
49520	  SKIPGE OVFOFG ;CHECK FLAG FOR BLANK FILL
49530	    JRST PUST34 ;BLANK FILL
49540	  ILDB R2,XCRTL ;GET NEXT STR CHR
49550	  JUMPN R2,PUST33 ;USE IF GOOD
49560	  MOVNS OVFOFG ;ELSE MAKE COUNT TO BLANK FILL REST OF STR
49570	;
49580	 PUST34:
49590	  MOVEI R2," " ;FILL WITH BLANK
49600	  AOS OVFOFG ;BUMP COUNT
49610	  JRST PUST33 ;AND GO PRINT BLANK
49620	;
49630	;
49640	    PAGE
49650	;
49660	;   END OF STRING
49670	;
49680	 PUST40:
49690	  LDB R0,CURTL ;CHECK LAST CHR OF FIELD
49700	  JUMPN R0,PUST41 ;NOT END OF USING STR
49710	  MOVE R0,USGSTR ;GET NEW TALLY FOR STRING
49720	  MOVEM R0,CURTL ;SAVE IT
49730	;
49740	 PUST41:
49750	  JRA T,1(T) ;AND RETURN
49760	;
49770	;
49780	    PAGE
49790	SUBTTL RUN TIME FILE ROUTINES--USEOL.
49800	;
49810	;   USEOL--THIS ROUTINE IS USED TO RESTART THE USING STRING
49820	;      ON A NEW LINE.  MAT PRINT USING IS ITS MAIN USER
49830	;
49840	;
49850	 USEOL.: Z
49860	;
49870	  HRRZ R1,F.JFN(FL) ;GET JFN
49880	  MOVEI R2,ASCEOL ;NEW LINE CHR
49890	  JSA T,OTCHR. ;PRINT IT
49900	  MOVE R2,USGSTR ;GET STRING TALLY
49910	  MOVEM R2,CURTL ;AND SAVE AS CURRENT
49920	  SETOM USFLG# ;MARK FOR FIRST ITEM IN STRING
49930	;
49940	  JRA T,0(T) ;NOW RETURN
49950	;
49960	;
49970	    PAGE
49980	SUBTTL RUN TIME FILE ROUTINES -- UCKEOL
49990	;
50000	;   UCKEOL--THIS IS AN INTERNAL PRINT-USING ROUTINE USED
50010	;      TO DETERMINE IF A NEW LINE MUST BE FORCED BEFORE
50020	;      PRINTING THE CURRENT USING ITEM BECAUSE THE OLD
50030	;      USING STRING RAN OUT IN THE MIDDLE OF A LINE.
50040	;
50050	;
50060	UCKEOL: Z
50070	;
50080	  MOVE R1,CURTL ;YES--GET USING STRING PTR
50090	  CAME R1,USGSTR ;CHECK IF WE ARE HEAD OF STRING
50100	    JRST UCKEL1 ;HANDLE IF MIDDLE OF LINE
50110	  AOSN USFLG# ;CHECK IF FIRST TIME
50120	    JRA T,0(T) ;NO--RETURN
50130	  MOVEM R2,RGSV.+2 ;SAVE R2
50140	  JSA T,USEOL. ;PRINT EOL
50150	  MOVE R2,RGSV.+2 ;RESTORE R2
50160	  SETZM USFLG# ;CLEAR FLAG TO AVOID REPEATS
50170	  JRA T,0(T) ;AND RETURN
50180	;
50190	 UCKEL1:
50200	  ADD R1,[070000000000] ;BACK UP TALLY
50210	  MOVEM R1,CURTL ;SAVE AS NEW CURRENT
50220	  JRA T,0(T) ;AND THEN RETURN
50230	;
50240	;
50250	PAGE
50260	SUBTTL BASIC RUN TIME FILE ROUTINES--PUEND.
50270	;
50280	;   PUEND.--THIS ROUTINE IS CALLED AT THE END OF A PRINT USING
50290	;      STATEMENT AND ITS JOB IS TO GET RID OF THE EXTRA PTR TO
50300	;      THE USING STRING.
50310	;
50320	;
50330	PUEND.: Z
50340	;
50350	  JSA T,SDLOC. ;DEALLOCATE STRING
50360	    JUMP USGSTR ;POINTER TO STRING
50370	  SETZM USFLG# ;CLEAR FLAG
50380	;
50390	  JRA T,0(T) ;THEN DONE--RETURN
50400	;
50410	;
50420	    PAGE
50430	SUBTTL END OF ASSEMBLY
50440	;
50450	;
50460	;
50470	 PRGEND
50480	    TITLE  WRNUM. -- BASIC RUN TIME FILE ROUTINES--WRITE NUMBER RANDOM
50490	    SUBTTL ASSEMBLY CONTROL
50500	    SEARCH STENEX,BGBL,BRSYMS
50510	;
50520	;
50530	;
50540	    ENTER WRNUM.
50550	;
50560	;
50570	;
50580	;
50590	;
50600	;
50610	    PAGE
50620	    SUBTTL BASIC RUN TIME FILE ROUTINES--WRNUM
50630	;
50640	;   WRNUM--THIS ROUTINE TAKES ONE ARGUMENT, A NUMBER, WHICH IS WRITTEN INTO
50650	;      THE CURRENT FILE WHICH MUST BE OF TYPE RANDOM.
50660	;
50670	;
50680	 WRNUM.:Z
50690	    MOVE   R2,@0(T)    ;PICK UP NUMBER
50700	    HRRZ   R1,F.JFN(FL) ;GET JFN OF FILE
50710	    BOUT               ;OUTPUT NUMBER TO FILE
50720	    JRA    T,1(T)      ;AND THENRRETURN
50730	;
50740	    PAGE
50750	    SUBTTL END OF ASSEMBLY
50760	;
50770	;
50780	;
50790	    PRGEND
50800	    TITLE  WRSTR. -- BASIC RUN TIME FILE ROUTINES--RANDOM WRITE A STRING
50810	    SUBTTL ASSEMBLY CONTROL
50820	    SEARCH STENEX,BGBL,BRSYMS
50830	;
50840	;
50850	;
50860	    ENTER WRSTR.
50870	;
50880	;
50890	    EXTERNAL RGSV.
50900	;
50910	;
50920	;
50930	    PAGE
50940	    SUBTTL BASIC RUN TIME FILE ROUTINES--WRSTR
50950	;
50960	;   WRSTR--THIS ROUTINE TAKES ONE STRING ARGUMENT AND WRITES THAT STRING
50970	;      INTO THE CURRENT FILE WHICH MUST BE A RANDOM TYPE FILE AND HAVE
50980	;      RECORDS LONG ENOUGH TO CONTAIN THE STRING.  THE STRING IS WRITTER
50990	;      SO AS TO PRESERVE LENGTH AND CHARACTER SIZE.
51000	;
51010	;
51020	 WRSTR.:Z
51030	  MOVEM R3,RGSV. ;SAVE R3
51040	  MOVE R2,@0(T) ;GET STRING TO WRITE
51050	  MOVEM R2,WRSTM# ;SAVE ITS PTR
51060	  MOVEI R0,0 ;CLEAR R0
51070	  SETZM WRSTM1# ;CLEAR HEADER WORD
51080	  JUMPE R2,WRST2 ;JUMP FOR NULL STRING
51090	;
51100	  LDB R1,[POINT 6,R2,11] ;GET BYTE SIZE
51110	  HLRZ R0,-1(R2) ;GET LENGTH OF STRING
51120	  HRLM R1,WRSTM1# ;SAVE BYTE SIZE
51130	  HRRM R0,WRSTM1 ;SAVE NUMBER OF BYTES
51140	;
51150	  MOVEI R2,44 ;BITS PER WORD
51160	  IDIV R2,R1 ;GET NUMBER OF BYTES PER WORD
51170	  IDIV R0,R2 ;GET NUMBER OF WORDS IN STRING
51180	  SKIPE R1 ;CHECK FOR PARTIAL WORD
51190	  ADDI R0,1 ;BUMP WORD COUNT FOR PARTIAL WORD
51200	;
51210	 WRST2:
51220	  MOVE R1,F.WLN(FL) ;GET WORD BLOCK LEN OF FILE
51230	  SUB R1,R0 ;DELTA IN WORDS
51240	  SKIPG R1 ;CHECK FOR FIT
51250	    ERR E.WRST ;ERROR IF STRING IS TOO LONG
51260	;
51270	  MOVE R2,WRSTM1 ;PICK UP THE STRING HEADER
51280	  MOVEM R1,WRSTM1 ;SAVE EXCESS WORD COUNT
51290	;
51300	  HRRZ R1,F.JFN(FL) ;GET FILE JFN
51310	  BOUT ;PRINT BYTE (HEADER)
51320	;
51330	  SKIPN R3,WRSTM ;GET STRING PTR
51340	    JRST WRST4 ;NULL STRING--DONE
51350	;
51360	  HRLI R3,444400 ;GET WORD TALLY TO STRING
51370	  ILDB R2,R3 ;GET NEXT WORD OF STRING
51380	  BOUT ;PRINT IT
51390	  SOJG R0,.-2 ;AND LOOP TILL DONE
51400	;
51410	 WRST4:
51420	  MOVE R0,WRSTM1 ;GET EXCESS LENGTH
51430	  SOJLE R0,WRST1 ;CHECK IF DONE
51440	  MOVEI R2,0 ;IF NOT, GET WORD OF ZERO
51450	  BOUT ;PRINT FILLER INTO STRING
51460	  SOJG R0,.-1 ;AND LOOP UNTIL DONE
51470	;
51480	 WRST1:
51490	  MOVE R3,RGSV. ;RESTORE R3
51500	  JRA T,1(T) ;RETURN WHEN ONE
51510	;
51520	;
51530	;   ERROR MESSAGES
51540	;
51550	 E.WRST: ER FLM,String too long
51560	;
51570	;
51580	    PAGE
51590	    SUBTTL END OF ASSEMBLY
51600	;
51610	;
51620	;
51630	    PRGEND
51640	TITLE ABS. -- BASIC RUN TIME FUNCTIONS--ABS
51650	SUBTTL ASSEMBLY CONTROL
51660	SEARCH STENEX,BGBL,BRSYMS
51670	;
51680	;
51690	;
51700	;
51710	    ENTER ABS.
51720	;
51730	;
51740	;
51750	  PAGE
51760	SUBTTL BASIC RUN TIME FUNCTIONS--ABS
51770	;
51780	;   ABS--ABSOLUTE VALUE
51790	;
51800	;
51810	 FCT ABS.,N,1,N
51820	;
51830	  MOVM R0,@0(T) ;GET ABS OF NUMBER TO R0
51840	  JRA T,1(T) ;AND RETURN
51850	;
51860	;
51870	  PAGE
51880	SUBTTL END OF ASSEMBLY
51890	;
51900	;
51910	;
51920	  PRGEND
51930	TITLE ATN. -- BASIC RUN TIME FUNCTIONS--ATN
51940	SUBTTL ASSEMBLY CONTROL
51950	SEARCH STENEX,BGBL,BRSYMS
51960	;
51970	;
51980	  ENTER ATN.
51990	;
52000	;
52010	  EXTERNAL RGSV.
52020	;
52030	;
52040	PAGE
52050	SUBTTL BASIC RUN TIME FUNCTIONS--ATN
52060	;
52070	;   ATN--ARCTANGENT FUNCTION.  COPIED FROM DEC FORTRAN FOROTS.
52080	;
52090	;
52100	 FCT ATN.,N,1,N
52110	;
52120	  MOVE R0,@0(T) ;GET ARG
52130	  MOVM R1,R0 ;ABS ARG
52140	  CAMG R1,A1   ;X < 2^-33 ==> RETURN WITH ATAN(X)=X
52150	    JRST AT5
52160	  MOVEM R3,RGSV. ;SAVE R3
52170	  HLLO R3,R0     ;SAVE SIGN; SET RH(R3) = -1
52180	  CAML R1,A2 	;X > 2^33 ==> RETURN WITH
52190	    JRST AT4	;   ATAN(X) = PI/2
52200	  MOVEM R2,RGSV.+1 	;SAVE R2
52210	  MOVSI R2,201400 ;R2_1.0
52220	  CAMG R1,R2 	;IS ABSF(X) > 1.0 ?
52230	  TRZA R3,-1	;IF R1 < -1.0 ==> RH(R3) _ 0
52240	  FDVM R2,R1	;REPLACE B WITH 1.0/B
52250	  TLC R3,0(R3) 	;XOR SIGN WITH .GT. 1.0 INDICATOR
52260	  MOVEM R1,RGSV.+2	;SAVE THE ARG
52270	  FMP R1,R1 	;GET R1^2
52280	  MOVE R2,KB3	;GET CONST
52290	  FAD R2,R1	;PLUS B^2
52300	  MOVE R0,KA3	;NEXT CONST
52310	  FDVM R0,R2	;FORM -A3/(B^2+B3)
52320	  FAD R2,R1	;ADD B^2 TO PARTIAL SUM
52330	  FAD R2,KB2 ;ADD B2
52340	  MOVE R0,KA2 ;PICK UP -A2
52350	  FDVM R0,R2	;DIVIDE PARTIAL SUM BY -A2
52360	  FAD R2,R1	;ADD B^2 TO PARTIAL SUM
52370	  FAD R2,KB1	;ADD B1 TO PARTIAL SUM
52380	  MOVE R0,KA1	;PICK UP A1
52390	  FDV R0,R2	;DIVIDE PARTIAL SUM BY A1
52400	  FAD R0,KB0	;PLUS B0
52410	  FMP R0,RGSV.+2 	;TIMES ORIG ARG
52420	  TRNE R3,-1	;CHECK .G. 1.0 INDICATOR
52430	  FSB R0,PIOT	;ATAN(A)=-(ATAN(1/A)-PI/2)
52440	  SKIPA R2,RGSV.+1	;RESTORE R2
52450	;
52460	 AT4:
52470	  MOVE R0,PIOT	;GET PI/2 AS ANSWER
52480	  SKIPGE R3	;LH(D)=-SGN(B) IF B > 1.0
52490	  MOVNS R0	;NEGATE ANSWER
52500	  MOVE R3,RGSV. 	;RESTRE R3
52510	;
52520	 AT5:
52530	  JRA T,1(T) 	;AND RETURN
52540	;
52550	;
52560	;   CONSTANTS
52570	;
52580	A1:  145000000000	;2^-33
52590	A2:  233000000000	;2^33
52600	KB0: 176545543401	;0.1746554388
52610	KB1: 203660615617	;6.762139240
52620	KB2: 202650373270	;3.316335425
52630	KB3: 201562663021	;1.448631538
52640	KA1: 202732621643	;3.709256262
52650	KA2: 574071125540	;-7.106760045
52660	KA3: 600360700773	;-0.2647686202
52670	;
52680	PIOT: 201622077325	;PI/2
52690	;
52700	;
52710	PAGE
52720	SUBTTL END OF ASSEMBLY
52730	;
52740	;
52750	;
52760	PRGEND
52770	    TITLE  CHR. -- BASIC RUN TIME FUNCTIONS--CHR
52780	    SUBTTL ASSEMBLY CONTROL
52790	    SEARCH STENEX,BGBL,BRSYMS
52800	;
52810	;
52820	;
52830	;
52840	    ENTER CHR.
52850	;
52860	    EXTERNAL SALOC.
52870	;
52880	;
52890	;
52900	;
52910	    PAGE
52920	    SUBTTL BASIC FUNCTION CHR$
52930	;
52940	;   CHR.--THIS ROUTINE TAKES A FLOATING POINT NUMBER AS ITS ONE ARGUMENT
52950	;      AND RETURNS A STRING CONSISTING OF ONE CHARACTER (7 BIT) WHICH
52960	;       IS THAT NUMBER MOD 2'7.
52970	;
52980	;
52990	 FCT CHR.,S,1,N 
53000	    MOVEM  R2,CHRTM#   ;SAVE R2 OVER CALL
53010	    MOVEI  R0,1        ;LENGTH OF STRING TO BE CREATED
53020	    JSA    T,SALOC.    ;ALLOCATE FOR STRING
53030	    MOVE   R2,CHRTM    ;RESTORE R2
53040	    XFIX   R0,@0(T)    ;PICK UP ARGUMENT
53050	    LSH    R0,44-7     ;POSITION IN UPPER SEVEN BITS
53060	    MOVEM  R0,0(R1)    ;SAVE AS DATA OF STRING
53070	    JRA    T,1(T)      ;AND RETURN WITH STRING TALLY IN R1
53080	;
53090	    PAGE
53100	    SUBTTL END OF ASSEMBLY
53110	;
53120	;
53130	;
53140	    PRGEND
53150	    TITLE  CLK. -- BASIC RUN TIME FUNCTIONS--CLK$ AND DAT$
53160	    SUBTTL ASSEMBLY CONTROL
53170	    SEARCH STENEX,BGBL,BRSYMS
53180	;
53190	;
53200	;
53210	    ENTER CLK.,DAT.
53220	;
53230	;
53240	    EXTERNAL SALOC.
53250	;
53260	;
53270	;
53280	;
53290	    PAGE
53300	    SUBTTL BASIC RUN TIME FUNCTIONS--CLK$
53310	;
53320	;   CLK.--THIS FUNCTION RETURNS THE TIME OF DAY AS A STRING.  COLUMNS ARE
53330	;      ALIGNED (FOR NOW).
53340	;
53350	;
53360	 FCT CLK.,S,0
53370	    HRLZI  R1,400000   ;USE TIME OF DAY
53380	;
53390	 DATM:
53400	    MOVEM  R2,DTMT1#   ;PRESERVE R2
53410	    MOVEM  R3,DTMT2#   ;AND R3
53420	    MOVE   R3,R1       ;MOVE FLAGS TO R3
53430	    MOVEI  R0,10       ;LENGTH OF STRING
53440	    JSA    T,SALOC.    ;ALLOCATE STRING FOR RESULT
53450	    MOVEM  R1,DTMT3#   ;SAVE TALLY FOR STRING
53460	    MOVNI  R2,1        ;CURRENT DATE/TIME
53470	    ODTIM              ;GET IT AS STRING
53480	    MOVE   R1,DTMT3    ;RESTORE TALLY
53490	  MOVE R2,R1		;DUPLICATE TALLY
53500	  MOVEI R0,"0"		;GET ZERO IN ASCII
53510	  ILDB R3,R2		;CHECK FIRST CHR
53520	  CAIN R3," "		;FOR SPACE FILLER
53530	  DPB R0,R2		;REPCACE WITH ZERO IF SO
53540	    MOVE   R2,DTMT1    ;RESTORE R2
53550	    MOVE   R3,DTMT2    ;RESTORE R3
53560	    JRA    T,0(T)      ;AND RETURN
53570	;
53580	    PAGE
53590	    SUBTTL BASIC RUN TIME FUNCTIONS--DAT$
53600	;
53610	;   DAT.--THIS FUNCTION RETURNS THE DATE AS A STRING. COLUMNS
53620	;      ARE ALIGNED AND NO DAY IS INCLUDED (FOR NOW).
53630	;
53640	;
53650	 FCT DAT.,S,0
53660	    HRLZI  R1,045400   ;FORMAT FOR CALL
53670	    JRST   DATM        ;PROCESS
53680	;
53690	    PAGE
53700	    SUBTTL END OF ASSEMBLY
53710	;
53720	;
53730	;
53740	    PRGEND
53750	TITLE EXPON. -- BASIC RUN TIME FUNCTIONS--EXPONENTIATION
53760	SUBTTL ASSEMBLY CONTROL
53770	SEARCH STENEX,BGBL,BRSYMS
53780	;
53790	;
53800	ENTER EXPON.,EXP.,LOG.
53810	;
53820	;
53830	EXTERNAL RGSV.,E.OFLO,E.UFLO
53840	;
53850	;
53860	PAGE
53870	SUBTTL EXPONENTIATION ROUTINES--EXPON
53880	;
53890	;   EXPON.--THIS ROUTINE IS CALLED FROM THE RUN TIME OBJECT
53900	;      CODE TO HANDLE X^Y.  IF POSSIBLE IT TREATS Y AS AN
53910	;      INTEGER.  OTHERWISE IT USES LOG AND EXP.
53920	;
53930	;
53940	EXPON.: Z
53950	;
53960	  MOVM R0,@1(T) ;GET EXPONENT ABS
53970	  JUMPE R0,EXPONE ;HANDLE IF X^0=1
53980	  SKIPN R1,@0(T) ;GET BASE, CHECK FOR 0^N
53990	    JRST EXPZER ;HANDLE 0^N=0
54000	;
54010	  CAMLE R0,[266400000000] ;CHECK IF <2^27
54020	    JRST EXPLGS ;NO--USE LOGS
54030	  FAD R0,[233400000000] ;YES--FIX IT
54040	  FSB R0,[233400000000] ;OR AT LEAST TRUNCATE
54050	  CAME R0,@1(T) ;CHECK IF FRACTION
54060	    JRST EXPLGS ;NO--HANDLE LOG
54070	  XFIX R0 ;YES--FIX INTO R0
54080	;
54090	  MOVEM R2,RGSV.+10 ;SAVE IT
54100	  MOVSI R2,(1.0) ;GET 1.0
54110	  SKIPA ;FOR STARTERS--AND SKIP INTO LOOP
54120	;
54130	 EXPN4:
54140	  FMP R1,R1 ;SQUARE BASE FOR NEXT ATTEMPT
54150	  TRNE R0,1 ;CHECK IF THIS POWER IS SIGNIFICANT
54160	  FMP R2,R1 ;IF SO,USE IT
54170	  LSH R0,-1 ;GET NEXT TO USE
54180	  JUMPN R0,EXPN4 ;AND LOOP
54190	;
54200	  MOVE R0,R2 ;GET RESULT IN R2
54210	  EXCH R2,RGSV.+10 ;SAVE RESULT, RESTORE R2
54220	  SKIPL @1(T) ;CHECK IF EXP NEG
54230	    JRA T,2(T) ;NO--DONE NOW
54240	  MOVSI R0,(1.0) ;YES--GET 1.0
54250	  FDVR R0,RGSV.+10 ;GET 1/RESULT
54260	  JRA T,2(T) ;AND RETURN THAT
54270	;
54280	;
54290	 EXPLGS:
54300	  SKIPGE R1,@0(T) ;GET BASE
54310	    ERR E.PWAB ;BASE MUST BE >0
54320	  MOVE R0,@1(T) ;GET EXP
54330	  MOVMM R1,RGSV.+10 ;SAVE BASE
54340	  MOVEM R0,RGSV.+11 ;AND EXP
54350	;
54360	  JSA T,LOG. ;GET LOG OF
54370	    JUMP RGSV.+10 ;BASE
54380	  FMPRM R0,RGSV.+11 ;TIMES EXPONENT
54390	  JSA T,EXP. ;GET EXP OF
54400	    JUMP RGSV.+11 ;RESULT
54410	;
54420	  JRA T,2(T) ;AND RETURN
54430	;
54440	;
54450	 EXPONE:
54460	  MOVSI R0,(1.0) ;GET 1.0 FOR X^0
54470	  JRA T,2(T) ;AND RETURN
54480	;
54490	;
54500	 EXPZER:
54510	  MOVEI R0,0 ;0^N=0
54520	  JRA T,2(T) ;RETURN IT
54530	;
54540	;
54550	;   ERROR MESSAGES
54560	;
54570	 E.PWAB: ER WRN,Absolute value raised to a power
54580	;
54590	;
54600	PAGE
54610	SUBTTL EXPONENTIATION ROUTINES--EXP FUNCTION
54620	;
54630	;   EXP.--THIS COMPUTES THE EXPONENTIAL FUNCTION (E^X).  THE
54640	;      ROUTINE IS TAKEN FROM FOROTS.
54650	;
54660	;
54670	 FCT EXP.,N,1,N
54680	;
54690	  MOVE R1,@0(T) ;GET ARG
54700	  CAMGE R1,E77 ;IS EXP < -89.41...?
54710	    JRST EXP1 ;YES--GO TO EXIT
54720	  CAMG R1,E7 ;IS EXP > +88.029...
54730	    JRST EXP2 ;YES--GO TO STD ALG
54740	  ERR E.OFLO ;ELSE OVERFLOW ERROR
54750	  HRLOI R0,377777 ;POSITIVE INFINITY RESULT
54760	  JRA T,1(T) ;AND RETURN IT
54770	;
54780	 EXP1:
54790	  ERR E.UFLO ;UNDERFLOW ERROR IF TOO SMALL
54800	  MOVEI R0,0 ;0 RESULT
54810	  JRA T,1(T) ;AND RETURN IT
54820	;
54830	EXP2:
54840	  MOVEM R2,RGSV. ;SAVE R2 AND R3
54850	  MOVEM R3,RGSV.+1
54860	  SETZM RGSV.+2 ;CLEAR FLAG
54870	  MULI R1,400 ;SEPARATE FRACTION AND EXP
54880	  TSC R1,R1 ;GET +EXP
54890	  MUL R2,E5 ;FIXED PT MULTIPLY BY LOG2(E)
54900	  ASHC R2,-242(R1) ;SEPARATE FRACTION AND INTEGER
54910	  AOSG R2 ;ALG CALLS FOR MULT BY 2
54920	  AOS R2 ;ADJUST IF FRACT WAS NEG
54930	  HRRM R2,EXP4 ;SAVE FOR FUTURE SCALING
54940	  JUMPG R3,EXP3 ;GO AHEAD IF ARG > 0
54950	  TRNN R3,377 ;ARE ALL THESE BITS 0 ?
54960	    JRST EXP3 ;YES--GO AHEAD
54970	  ADDI R3,200 ;NO--FIX UP
54980	;
54990	 EXP3:
55000	  ASH R3,-10 ;MAKE ROOM FOR EXP
55010	  TLC R3,200000 ;PUT 200 IN EXP BITS
55020	  FADB R3,RGSV.+2 ;NORM. RESULTS TO R3 AND RGSV.+2
55030	  FMP R3,R3 ;FORM X^2
55040	  MOVE R0,E2 ;FIRST CONST
55050	  FMP R0,R3 ;E2*X^2 IN R0
55060	  FAD R3,E4 ;ADD E4 TO RESULTS IN R3
55070	  MOVE R1,E3 ;PICK UP E3
55080	  FDV R1,R3 ;CALC E3/(F^2+E4)
55090	  FSB R0,R1 ;E2*F^2-E3(F^2+E4)^-1
55100	  MOVE R2,RGSV.+2 ;GET F AGAIN
55110	  FSB R0,R2 ;SUB FROM PARTIAL SUM
55120	  FAD R0,E1 ;PLUS E1
55130	  FDVM R2,R0 ;DIVIDE BY F
55140	  FAD R0,E6 ;ADD 0.5
55150	;
55160	 EXP4:
55170	  FSC R0,0 ;SCALE THE RESULTS
55180	  MOVE R2,RGSV. ;RESTORE R2,R3
55190	  MOVE R3,RGSV.+1
55200	  JRA T,1(T) ;AND RETURN
55210	;
55220	;
55230	;   CONSTANTS FOR EXP.
55240	;
55250	E1:  204476430062  ;9.95459578
55260	E2:  174433723400  ;0.03465735903
55270	E3:  212464770715  ;617.97226953
55280	E4:  207535527022  ;87.417497202
55290	E5:  270524354513  ;LOG(E) BASE 2
55300	E6:  0.5
55310	E7:  207540074636  ;88.029
55320	E77: 570232254037  ;-89.415986
55330	;
55340	;
55350	PAGE
55360	SUBTTL EXPONENTIATION ROUTINES--LOG FUNCTION
55370	;
55380	;   LOG.--THIS COMPUTES THE LOG FUNCTION (NATURAL).  THE
55390	;      ROUTINE WAS TAKEN FROM FOROTS.
55400	;
55410	;
55420	 FCT LOG.,N,1,N
55430	;
55440	  MOVE R0,@0(T) ;GET ARG
55450	  JUMPG R0,LOGOK ;>0?
55460	  JUMPE R0,LZERO ;=0?
55470	  ERR E.LOG ;ERROR IF NEGATIVE
55480	  MOVM R0,@0(T) ;USE ABS OF ARG IF NEGATIVE
55490	;
55500	 LOGOK:
55510	  CAMN R0,ONE ;CHECK FOR 1.0 ARG
55520	    JRST LONE ;HANDLE IF SO
55530	  ASHC R0,-33 ;SEPARATE FRACT AND EXP
55540	  ADDI R0,211000 ;FLOAT EXP ANDMULT BY 2
55550	  MOVSM R0,RGSV. ;NUMBER NOW IN CORRECT FL. FORMAT
55560	  MOVSI R0,567377 ;SET UP -401.0 IN R0
55570	  FADM R0,RGSV. ;SUB R01 FROM EXP*2
55580	  ASH R1,-10 ;SHIFT FRACT FOR FLOATING
55590	  TLC R1,200000 ;FLAT THE FRACTION PART
55600	  FAD R1,L1 ;R1=R1-SQRT(2.0)/2.0
55610	  MOVE R0,R1 ;RESULTS TO R0
55620	  FAD R0,L2 ;A=A+SQRT(2.0)
55630	  FDV R1,R0 ;R1=R1/R0
55640	  MOVEM R1,RGSV.+1 ;STOVE NEW VARIABLE
55650	  FMP R1,R1 ;Z^2
55660	  MOVE R0,L3 ;FIRST CONST
55670	  FMP R0,R1 ;*Z^2
55680	  FAD R0,L4 ;ADD NEXT CONST
55690	  FMP R0,R1 ;*Z^2
55700	  FAD R0,L5 ;ADD NEXT CONST
55710	  FMP R0,RGSV.+1 ;*Z
55720	  FAD R0,RGSV. ;ADD IN EXP TO GET LOG2(X)
55730	  FMP R0,L7 ;FORM LOGE(X)
55740	  JRA T,1(T) ;AND RETURN IT
55750	;
55760	 LZERO:
55770	  ERR E.LOGZ ;ERROR IF LOG(0)
55780	  MOVE R0,MIFI ;MINUS INFINITY RESULT
55790	  JRA T,1(T) ;RETURN IT
55800	;
55810	 LONE:
55820	  MOVEI R0,0 ;LOG(1)=0
55830	  JRA T,1(T) ;RETURN IT
55840	;
55850	;
55860	;   ERROR MESSAGES
55870	;
55880	E.LOG: ER WRN,LOG of negative number
55890	E.LOGZ: ER WRN,LOG of zero
55900	;
55910	;
55920	;   CONSTANTS FOR LOG ROUTINE
55930	;
55940	ONE: 201400000000
55950	L1:  577225754146 ;-0.707106781187
55960	L2:  201552023632 ;1.414213562374
55970	L3:  200462532521 ;0.5989786496
55980	L4:  200754213604 ;0.9614706323
55990	L5:  202561251002 ;2.8853912903
56000	L7:  200542710300 ;0.69314718056
56010	MIFI: 400000000001 ;MINUS INFINITY
56020	;
56030	;
56040	PAGE
56050	SUBTTL END OF ASSEMBLY
56060	;
56070	;
56080	;
56090	PRGEND
56100	TITLE INT. -- BASIC RUN TIME FUNCTIONS--INT
56110	SUBTTL ASSEMBLY CONTROL
56120	SEARCH STENEX,BGBL,BRSYMS
56130	;
56140	;
56150	ENTER INT.
56160	;
56170	;
56180	;
56190	;
56200	PAGE
56210	SUBTTL BASIC RUN TIME FUNCTIONS--INT
56220	;
56230	;   INT--THIS IS THE INTEGER TRUNCATION FUNCTION.
56240	;
56250	;
56260	 FCT INT.,N,1,N
56270	;
56280	  MOVE R1,@0(T) ;ARG TO R1
56290	  MOVM R0,R1 ;ABS(ARG) TO R0
56300	  SKIPGE R1 ;CHECK IF <0
56310	    FAD R0,ALMST1 ;HANDLE NEG NUMBERS CORRECTLY
56320	  CAML R0,[233400000000] ;IS ABS(ARG) < 2**26
56330	    JRST INT1 ;NO--NO FRACT PART ALREADY-->EXIT
56340	  FAD R0,[233400000000] ;YES--REMOVE
56350	  FSB R0,[233400000000] ;THE FRACT BITS
56360	;
56370	 INT1:
56380	  SKIPGE R1 ;SET THE
56390	    MOVNS R0 ;CORRECT SIGN AND
56400	  JRA T,1(T) ;RETURN
56410	;
56420	;
56430	 ALMST1: 200777777777	;ALMOST 1 FOR NEG NUMBERS
56440	;
56450	;
56460	PAGE
56470	SUBTTL END OF ASSEMBLY
56480	;
56490	;
56500	;
56510	PRGEND
56520	    TITLE  LEN. -- BASIC RUN TIME FUNCTIONS--LEN
56530	    SUBTTL ASSEMBLY CONTROL
56540	    SEARCH STENEX,BGBL,BRSYMS
56550	;
56560	;
56570	;
56580	    ENTER LEN.
56590	;
56600	;
56610	;
56620	;
56630	;
56640	;
56650	    PAGE
56660	    SUBTTL RUN TIME FUNCTIONS--LEN
56670	;
56680	;   LEN.--THIS HANDLES THE LEN FUNCTION WHICH TAKES A STRING FOR ITS
56690	;      ONE ARGUMENT AND RETURNS THE LENGTH IN CHARACTERS OF THAT
56700	;      STRING.
56710	;
56720	;
56730	 FCT LEN.,N,1,S
56740	    MOVE   R1,@0(T)    ;GET TALLY TO STRING
56750	    HLRZ   R0,-1(R1)   ;GET LENGTH IN CHARACTERS FIXED
56760	    FSC    R0,233      ;FLOAT IT
56770	    JRA    T,1(T)      ;AND RETURN
56780	;
56790	    PAGE
56800	    SUBTTL END OF ASSEMBLY
56810	;
56820	;
56830	;
56840	    PRGEND
56850	TITLE LIN. -- BASIC RUN TIME FUNCTIONS--LIN.
56860	SUBTTL ASSEMBLY CONTROL
56870	SEARCH STENEX,BGBL,BRSYMS
56880	;
56890	;
56900	;
56910	ENTER LIN.,PAG.
56920	;
56930	;
56940	;
56950	EXTERNAL OTCHR.,RGSV.,E.FLR1
56960	;
56970	;
56980	;
56990	    PAGE
57000	SUBTTL BASIC RUN TIME FUNCTIONS -- LIN.
57010	;
57020	;   LIN(#)--THIS FUNCTION TAKES A LINE NUMBER AND PRINTS IT
57030	;      TO AN ASCII TYPE FILE AS AN SOS-FORMAT LINE NUMBER.
57040	;
57050	;
57060	 FCT LIN.,N,1,N
57070	;
57080	  XFIX R2,@0(T) ;GET THE NUMBER
57090	  MOVE R1,[POINT 7,R0] ;GET POINTER FOR RESULT
57100	  MOVE R3,[XWD 140005,12] ;CONVERSION TYPE
57110	  NOUT ;GET ASCII WORD FOR LINE NUMBER
57120	    ERR E.ILLN ;MUST FIT
57130	  TRO R0,1 ;SET ON SPECIAL BIT
57140	;
57150	  SKIPN F.CPOS(FL) ;CHECK IF AT BEGINING OF LINE
57160	    JRST LIN1 ;YES--SKIP
57170	  MOVEI R2,ASCEOL ;NO--WE MUST BE
57180	  HRRZ R1,F.JFN(FL) ;GET JFN
57190	  BOUT ;OUTPUT CHR
57200	  SETZM F.CPOS(FL) ;NEW LINE
57210	;
57220	 LIN1:
57230	  JSA T,OTWRD ;PRINT THE WORD TO THE FILE
57240	  MOVEI R2,5 ;SPACE 5 SPACES
57250	  ADDM R2,F.CPOS(FL) ;IN LINE FOR 5 CHRS
57260	  MOVEI R2,ASC.HT ;GET TAB CHR
57270	  JSA T,OTCHR. ;AND PRINT INTO FILE
57280	;
57290	  JRA T,1(T) ;THEN DONE
57300	;
57310	;
57320	;   ERROR MESSAGE
57330	;
57340	 E.ILLN:ER NRM,Illegal line number given to LIN function
57350	;
57360	;
57370	    PAGE
57380	SUBTTL BASIC RUN TIME FUNCTIONS -- PAG.
57390	;
57400	;   PAG--THIS FUNCTION PUTS A PAGE MARK INTO THE FILE BEING PRINTED
57410	;      TO.  THIS PAGE MARK IS IN SOS-FORMAT
57420	;
57430	;
57440	 FCT PAG.,N,0
57450	;
57460	  MOVE R0,[BYTE (7)40,40,40,40,40(1)1] ;FIRST WORD
57470	  JSA T,OTWRD ;PRINT IT
57480	  MOVE R0,[BYTE (7)15,15,14,0,0] ;SECOND WORD
57490	  JSA T,OTWRD ;PRINT IT
57500	  SETZM F.CPOS(FL) ;NEW LINE
57510	;
57520	  JRA T,0(T) ;AND RETURN
57530	;
57540	;
57550	    PAGE
57560	SUBTTL BASIC RUN TIME FUNCTION SUBROUTINES--OTWRD
57570	;
57580	;   OTWRD--THIS ROUTINE IS USED BY THE LIN AND PAG FUNCTIONS TO
57590	;      WRITE A FULL WORD INTO THE FILE AT A WORD BOUNDARY.
57600	;
57610	;
57620	OTWRD: Z
57630	;
57640	  HRRZ R1,F.JFN(FL) ;GET JFN OF FILE
57650	  MOVE R2,F.BTS(FL) ;CHECK FILE BITS
57660	  TLNE R2,FB.TTY ;FOR TTY
57670	    JRST OTWRD2 ;YES--HANDLE SPECIAL
57680	  RFPTR ;GET CURRENT FILE PTR
57690	    ERR E.FLR1 ;ERROR IF FAIL
57700	  IDIVI R2,5 ;CHECK IF WORD BOUNDARY
57710	  JUMPE R3,OTWRD1 ;HANDLE IF ALREADY AT WRD BNDRY
57720	  MOVEI R2,0 ;FILL WITH NULLS
57730	  BOUT ;PRINT IT
57740	  SOJG R3,.-1 ;LOOP UNTIL AT WRD BOUNDARY
57750	;
57760	 OTWRD1:
57770	  MOVEI R2,44 ;GET FULL WORD SIZE
57780	  SFBSZ ;SET BYTE SIZE
57790	  MOVE R2,R0 ;GET WORD TO WRITE
57800	  BOUT ;PUT INTO FILE
57810	  MOVEI R2,7 ;RETURN TO ASCII MODE
57820	  SFBSZ ;SET BYTE SIZE BACK AGAIN
57830	  JRA T,0(T) ;AND RETURN
57840	;
57850	 OTWRD2:
57860	  MOVEM R0,RGSV. ;SAVE R0 FOR TTY
57870	  MOVE R0,[POINT 7,RGSV.] ;TALLY TO SAVED R0
57880	  MOVEM R0,RGSV.+1 ;SAVE THAT TOO
57890	  MOVEI R0,5 ;COUNT OF RELEVANT CHRS
57900	  MOVEM R0,RGSV.+2 ;SAVE THAT TOO
57910	  ILDB R2,RGSV.+1 ;GET NEXT CHR
57920	  JSA T,OTCHR. ;PRINT IT
57930	  SOSLE RGSV.+2 ;CHECK IF DONE
57940	    JRST .-3 ;LOOP IF NOT
57950	  JRA T,0(T) ;RETURN WHEN DONE
57960	;
57970	;
57980	    PAGE
57990	SUBTTL END OF ASSEMBLY
58000	;
58010	;
58020	;
58030	PRGEND
58040	    TITLE  LOC. -- BASIC RUN TIME FUNCTIONS--LOC AND LOF
58050	    SUBTTL ASSEMBLY CONTROL
58060	    SEARCH STENEX,BGBL,BRSYMS
58070	;
58080	;
58090	;
58100	    ENTER LOC.,LOF.
58110	;
58120	;
58130	    EXTERNAL FLPTR.,E.FLR1,E.FLNO,RGSV.
58140	;
58150	;
58160	;
58170	;
58180	    PAGE
58190	    SUBTTL BASIC RUN TIME FUNCTIONS--LOC
58200	;
58210	;   LOC--THIS FUNCTION TAKES A FILE NUMBER FOR ITS ONE ARGUMENT
58220	;      AND RETURNS THE CURRENT LOCATION OF THE FILE.  THIS IS THE
58230	;      RECORD NUMBER IN A RANDOM FILE AND THE CHARACTER NUMBER
58240	;      IN AN ASCII FILE.
58250	;
58260	;
58270	 FCT LOC.,N,1,F
58280	    MOVEM  R2,LOCTM#   ;PRESERVE R2
58290	    MOVE   R0,@0(T)    ;PICK UP FILE NUMBER
58300	    JSA    T,FLPTR.    ;FIND FILE
58310	    ERR    E.FLNO      ;ERROR IF NOT ALREADY OPEN
58320	    MOVE   R1,R0       ;GET PTR IN R1
58330	    MOVEM R1,RGSV.+1	;SAVE PTR
58340	    HRRZ   R1,F.JFN(R1) ;GET JFN OF FILE
58350	    RFPTR              ;GET CURRENT BYTE POINTER IN FILE
58360	    ERR    E.FLR1      ;ERROR IF CAN'T GET IT
58370	    MOVE R1,RGSV.+1	;GET PTR TO FILE BLOCK
58380	    ADD R2,F.WLN(R1)	;CORRECT POSITION FOR USER NUMBER
58390	;
58400	 LOCA:
58410	  MOVE R1,RGSV.+1	;RESTORE PTR TO FILE BLOCK
58420	  MOVE R0,F.BTS(R1) ;GET FILE TYPE BITS
58430	  TLNE R0,FB.RNM+FB.ASC+FB.UDF ;CHECK FOR RSTR
58440	  JRST LOC1 ;NO--HANDLE SIZE/LOC AS IS
58450	  MOVE R0,R2 ;GET ITEM IN R0
58460	  IDIV R0,F.WLN(R1) ;GET BLOC K NUMBER IN FILE
58470	  SKIPA ;AND SKIP
58480	;
58490	 LOC1:
58500	  MOVE R0,R2 ;GET DIRECT ITEM IN R0
58510	  FSC R0,233 ;FLOAT IT
58520	  MOVE R2,LOCTM# ;RESTORE R2
58530	  JRA T,1(T) ;AND RETURN
58540	;
58550	;
58560	    PAGE
58570	    SUBTTL BASIC RUN TIME FUNCTIONS--LOF
58580	;
58590	;   LOF--THIS FUNCTION IS SIMILAR TO LOC EXCEPT THAT IT RETURNS
58600	;      THE RECORD NUMBER OR CHARACTER POSITION OF THE END OF
58610	;      THE FILE.
58620	;
58630	;
58640	 FCT LOF.,N,1,F
58650	    MOVEM  R2,LOCTM    ;SAVE R2
58660	    MOVE   R0,@0(T)    ;PICK UP FILE NUMBER
58670	    JSA    T,FLPTR.    ;GET FILE POINTER
58680	    ERR    E.FLNO      ;ERROR IF NO FILE FOR THAT NUMBER
58690	    MOVE   R1,R0       ;GET ANOTHER POINTER TO FILE
58700	    MOVEM R1,RGSV.+1	;SAVE PTR TO FILE BLOCK
58710	    HRRZ   R1,F.JFN(R1) ;GET JFN OF FILE
58720	    RFPTR ;GET CURRENT FILE PTR
58730	    BLOWUP ;CANT FAIL
58740	    MOVEM R2,RGSV. ;SAVE IT
58750	    SETO R2, ;REQUEST END OF FILE
58760	    SFPTR ;POINTER
58770	    BLOWUP ;CAN'T FAIL EITHER
58780	    RFPTR ;READ FILE PTR AT END
58790	    BLOWUP ;CAN'T FAIL
58800	    EXCH R2,RGSV. ;SAVE LEN, GET ORIG PTR
58810	    SFPTR ;GET BACK TO WHERE WE WERE
58820	    BLOWUP ;CAN'T FAIL
58830	    MOVE R2,RGSV. ;NOW GET LENGTH IN BYTES
58840	    JRST   LOCA        ;PROCESS AS IN LOC
58850	;
58860	    PAGE
58870	    SUBTTL END OF ASSEMBLY
58880	;
58890	;
58900	;
58910	    PRGEND
58920	    TITLE  MAR. -- BASIC RUN TIME FUNCTIONS--MAR
58930	    SUBTTL ASSEMBLY CONTROL
58940	    SEARCH STENEX,BGBL,BRSYMS
58950	;
58960	;
58970	;
58980	    ENTER MAR.
58990	;
59000	;
59010	    EXTERNAL FLPTR.,E.FLNO
59020	;
59030	;
59040	;
59050	;
59060	    PAGE
59070	    SUBTTL BASIC RUN TIME FUNCTIONS--MAR
59080	;
59090	;   MAR--THIS ROUTINE RETURNS THE CURRENT MARGIN OF THE SPECIFIED
59100	;      FILE (FILE NUMBER IS FIRST ARGUMENT).  THE FILE MUST EXIST.
59110	;
59120	;
59130	 FCT MAR.,N,1,F
59140	    MOVEM  R2,MARTM#   ;SAVE R2
59150	    MOVE   R0,@0(T)    ;PICK UP FILE NUMBER
59160	    JSA    T,FLPTR.    ;GET FILE POINTER
59170	    ERR    E.FLNO      ;ERROR IF NONE
59180	    MOVE   R1,R0       ;GET FILE POINTER IN R1
59190	    MOVE   R0,F.MAR(R1) ;PICK UP FIXED MARGIN
59200	    FSC    R0,233      ;FLOAT IT
59210	    MOVE   R2,MARTM    ;RESTORE R2
59220	    JRA    T,1(T)      ;AND RETURN
59230	;
59240	    PAGE
59250	    SUBTTL END OF ASSEMBLY
59260	;
59270	;
59280	;
59290	    PRGEND
59300	TITLE MOD. --BASIC RUN TIME FUNCTIONS--MOD
59310	SUBTTL ASSEMBLY CONTROL
59320	SEARCH STENEX,BGBL,BRSYMS
59330	;
59340	;
59350	ENTER MOD.
59360	;
59370	;
59380	EXTERNAL RGSV.,E.OFLO
59390	;
59400	;
59410	PAGE
59420	SUBTTL BASIC RUN TIME FUNCTIONS--MOD
59430	;
59440	;   MOD.--THIS FUNCTION IS EQUIVALENT TO THE FORTRAN AMOD(A,B).
59450	;      AND WAS TAKEN FROM FOROTS.
59460	;
59470	;
59480	 FCT MOD.,N,2,N,N
59490	;
59500	  MOVEM R2,RGSV. ;SAVE R2
59510	  MOVE R0,@0(T) ;GET 1ST ARG
59520	  MOVE R1,@1(T) ;2ND ARG
59530	  MOVM R2,R1 ;ABS(2ND) TO R2
59540	  FDVM R0,R1 ;GET A/B
59550	;
59560	  MOVMS R1 ;CALC ABSF(A/B)
59570	  CAML R1,[233400000000] ;IF A/B GE 2^26
59580	    JRST MOD2 ;GO TO ERROR RETURN
59590	  FAD R1,[233400000000] ;OTHERWISE TRUNCATE
59600	  FSB R1,[233400000000] ;TO INTEGER
59610	  FMP R2,R1 ;R2=R1*![A/B]!
59620	  SKIPGE R0 ;RESTORE
59630	    MOVNS R2 ;THE SIGN
59640	  FSB R0,R2 ;A-[A/B]*B
59650	;
59660	 MOD1:
59670	  MOVE R2,RGSV. ;RESTORE R2
59680	  JRA T,2(T) ;AND RETURN
59690	;
59700	 MOD2:
59710	  ERR E.OFLO ;NUMBER TOO BIG
59720	  SETZ R0, ;RETURN 0
59730	  JRST MOD1 ;AND RETURN
59740	;
59750	;
59760	PAGE
59770	SUBTTL END OF ASSEMBLY
59780	;
59790	;
59800	;
59810	PRGEND
59820	    TITLE  POS. -- BASIC RUN TIME FUNCTIONS--POS
59830	    SUBTTL ASSEMBLY CONTROL
59840	    SEARCH STENEX,BGBL,BRSYMS
59850	;
59860	;
59870	;
59880	;
59890	    ENTER POS.
59900	;
59910	;
59920	;
59930	;
59940	;
59950	;
59960	    PAGE
59970	    SUBTTL BASIC RUN TIME FUNCTIONS--POS
59980	;
59990	;   POS--THIS FUNCTION TAKES THREE ARGUMENTS.  IT TRIES TO FIND AN
60000	;      OCCURENCE OF THE SECOND ARGUMENT (A STRING) IN THE FIRST
60010	;      (ALSO A STRING) AFTER THE THIRD'S (A NUMBER) POSITION.  IF
60020	;      NONE IS FOUND ZERO IS RETURNED.  IF ONE IS FOUND THE CHARACTER
60030	;      POSITION OF THE FIRST MATCHING CHARACTER IS RETURNED.
60040	;
60050	;
60060	 FCT POS.,N,3,S,S,N
60070	    MOVEM  R2,POST1#   ;SAVE R2
60080	    MOVEM  R3,POST2#   ;SAVE R3
60090	    MOVEM  R4,POST3#   ;SAVE R4
60100	    MOVEM  R5,POST4#   ;SAVE R5
60110	;
60120	    MOVE   R1,@0(T)    ;PICK UP FIRST TALLY
60130	    JUMPE  R1,POS1     ;CHECK AND HANDLE NULL STRING
60140	    MOVEM  R1,POSTA#   ;SAVE TALLY
60150	    HLRZ   R0,-1(R1)   ;GET LENGTH OF STRING IN R0
60160	    MOVE   R1,@1(T)    ;PICK UP SECOND STRING
60170	    JUMPE  R1,POS1     ;CHECK AND HANDLE NULL STRING
60180	    MOVEM  R1,POSTB#   ;SAVE ITS TALLY
60190	    HLRZ   R1,-1(R1)   ;GET LENGTH OF SECOND STRING
60200	    SUBM   R0,R1       ;GET LAST CHARACTER TO CHECK
60210	    ADDI   R1,1        ;WHICH IS PLUS ONE
60220	    MOVEM  R1,POSTC#   ;SAVE IT
60230	    XFIX   R1,@2(T)    ;PICK UP INITIAL CHARACTER POS
60240	    CAMLE  R1,R0       ;CHECK FOR TOO BIG
60250	    JRST   POS1        ;RETURN 0 IF SO
60260	    SETZM  R2          ;ELSE CLEAR R2 FOR COUNT
60270	    MOVE   R3,POSTA    ;RESTORE FIRST TALLY
60280	    SOJLE  R1,POS2     ;IF NOTHING TO DO, DONE
60290	    IBP    R3          ;ELSE GO TO NEXT CHARACTER
60300	    AOS    R2          ;BUMP COUNT
60310	    SOJG   R1,.-2      ;AND LOOK UNTIL DONE INITIAL LOOP
60320	;
60330	 POS2:
60340	    MOVE   R1,POSTB    ;GET TALLY TO MATCH STRING
60350	    CAMLE  R2,POSTC    ;CHECK IF DONE CHECKING
60360	    JRST   POS1        ;FAIL IF SO
60370	    HLRZS  R5,-1(R1)   ;LENGTH OF MATCH STRING
60380	    ILDB   R4,R1       ;GET NEXT INPUT CHARACTER
60390	    ILDB   R0,R3       ;AND NEXT MATCH CHARACTER
60400	    AOS    R2          ;BUMP COUNT
60410	    CAME   R0,R4       ;CHECK IF CHARACTER MATCH
60420	    JRST   POS2        ;HANDLE IF NOT--NEXT TRY
60430	    MOVEM  R3,POSTA    ;SAVE OLD TALLY IF SO
60440	    SOJLE  R5,POS4     ;DECREMENT MATCH LENGTH COUNT
60450	    ILDB   R4,R1       ;CHECK ANOTHER CHARACTER
60460	    ILDB   R0,R3       ;FROM BOTH
60470	    CAMN   R0,R4       ;CHECK
60480	    JRST   .-4         ;LOOP UNTIL FAIL/DONE
60490	    MOVE   R3,POSTA    ;IF FAIL, RESTORE TALLY
60500	    JRST   POS2        ;AND CONTINUE
60510	;
60520	 POS4:
60530	    MOVE   R0,R2       ;GET COUNT TO R0
60540	    FSC    R0,233      ;FLOAT IT
60550	;
60560	 POS5:
60570	    MOVE   R2,POST1    ;RESTORE R2
60580	    MOVE   R3,POST2    ;RESTORE R3
60590	    MOVE   R4,POST3    ;RESTORE R4
60600	    MOVE   R5,POST4    ;RETORE R5
60610	    JRA    T,3(T)      ;AND RETURN
60620	;
60630	 POS1:
60640	    MOVEI  R0,0        ;RETURN FAIL
60650	    JRST   POS5        ;RESTORE REGS AND RETURN
60660	;
60670	    PAGE
60680	    SUBTTL END OF ASSEMBLY
60690	;
60700	;
60710	;
60720	    PRGEND
60730	TITLE RND. -- BASIC RUN TIME FUNCTIONS--RANDOM NUMBERS
60740	SUBTTL ASSEMBLY CONTROL
60750	SEARCH STENEX,BGBL,BRSYMS
60760	;
60770	;
60780	ENTER RND.,RNDMZ.
60790	;
60800	;
60810	;
60820	;
60830	PAGE
60840	SUBTTL RANDOMIZE STATEMENT ROUTINE--NEW FIRST NUMBER
60850	;
60860	;   RNDMZ.--THIS ROUTINE GENERATES A UNIQUE STARTING OR
60870	;      SEED VALUE FOR THE RANDOM NUMBER GENERATOR.
60880	;
60890	;
60900	RNDMZ.: Z
60910	;
60920	  TIME ;GET TIME SINCE SYSTEM WAS RESTARTED LAST
60930	  MOVEM R1,RNDXN ;SAVE IT IN SEED
60940	  GTAD ;GET  CURRENT TIME AND DATE
60950	  ADD R1,RNDXN ;PLUS ORIG TIME==>NUMBER
60960	  TLZ R1,400000 ;INSURE POSITIVE
60970	  MOVEM R1,RNDXN ;SAVE AS SEED
60980	  JRST RND1 ;AND WORK ONCE WITH THIS NUMBER
60990	;
61000	;
61010	PAGE
61020	SUBTTL RANDOM NUMBER ROUTINES--RND FUNCTION
61030	;
61040	;   RND.--THIS ROUTINE RETURNS THE NEXT RANDOM NUMBER.
61050	;    WHICH IS A FUNCTION OF THE PREVIOUS ONE.  THE ALGORITHM
61060	;      IS FROM DEC FOROTS.
61070	;
61080	;
61090	 FCT RND.,N,0
61100	;
61110	 RND1:
61120	  MOVE R0,RNDK ;GET CONSTANT
61130	  MUL R0,RNDXN ;TIMES OLD SEED
61140	  ASHC R0,4 ;ADJUST
61150	  LSH R1,-4 ;TO PREVENT RANDOM THINGS
61160	  ADD R0,R1 ;GET FUNNY NEW NUMBER
61170	  TLZE R0,760000 ;INSURE IN RANGE
61180	  ADDI R0,1 ;INSURE NON-ZERO
61190	  MOVEM R0,RNDXN ;SAVE NUMBER
61200	  HLRZ R1,R0 ;GET UPPER HALF
61210	  FSC R1,216 ;GET FLOATII'G NUMBER IN RANGE
61220	  HRLI R0,R0 ;OTHER PART OF NUMBER
61230	  FSC R0,174 ;GET IT IN RANGE TOO
61240	  FAD R0,R1 ;SUM OF TWO RANDOM NUMBERS IS RANDOM
61250	  JRA T,0(T) ;AND RETURN
61260	;
61270	;
61280	PAGE
61290	SUBTTL RANDOM NUMBER ROUTINES--STORAGE
61300	;
61310	;
61320	;
61330	;
61340	RNDK:  DEC 630360016 ;CONSTANT TO ADD=14**29 (MOD 2**31-1)
61350	;
61360	RNDXN: DEC 524287    ;STARTING VALUE DEFAULT
61370	;
61380	;
61390	PAGE
61400	SUBTTL END OF ASSEMBLY
61410	;
61420	;
61430	;
61440	PRGEND
61450	    TITLE  SEG. -- BASIC RUN TIME FUNCTIONS--SEG$
61460	    SUBTTL ASSEMBLY CONTROL
61470	    SEARCH STENEX,BGBL,BRSYMS
61480	;
61490	;
61500	;
61510	;
61520	    ENTER SEG.
61530	;
61540	;
61550	    EXTERNAL SALOC.
61560	;
61570	;
61580	;
61590	;
61600	    PAGE
61610	    SUBTTL BASIC RUN TIME FUNCTIONS--SEG
61620	;
61630	;   SEG--THIS IS A FUNCTION OF THREE ARGUMENTS.  THE FIRST IS THE SOURCE
61640	;      STRING.   THE SECOND IS THE STARTING CHARACTER POSITION AND THE
61650	;      THIRD IS THE PRGENDING CHARACTER POSITION.  IT RETURNS A STRING WHICH IS
61660	;      THE PART OF THE FIRST STRING SPECIFIED BETWEEN (AND INCLUDING)
61670	;      THE GIVEN CHARACTER POSITIONS.
61680	;
61690	;
61700	 FCT SEG.,S,3,S,N,N
61710	    MOVEM  R2,SEGT1#   ;SAVE R2
61720	    MOVEM  R3,SEGT2#   ;SAVE R2
61730	    MOVE   R1,@0(T)    ;PICK UP FIRST ARGUMENT
61740	    JUMPE  R1,SEG1     ;HANDLE NULL STRING
61750	    HLRZ   R0,-1(R1)   ;GET LENGTH OF STRING
61760	    MOVEM  R1,SEGTM#   ;SAVE TALLY
61770	    XFIX   R1,@1(T)    ;GET SECOND ARGUMENT
61780	    SOS    R1          ;MINUS ONE
61790	    SKIPG              ;CHECK IF >0
61800	    MOVEI  R1,0        ;ELSE USE 0
61810	    MOVEM  R1,SEGTA#   ;SAVE START
61820	    XFIX   R1,@2(T)    ;GET SECOND ARGUMENT
61830	    CAMG   R1,R0       ;CHECK IF IN BOUNDS
61840	    MOVE   R0,R1       ;ELSE SET TO MAX OF STRING
61850	    SUB    R0,SEGTA    ;GET LENGTH OF NEW STRING
61860	    MOVE   R3,R0       ;SAVE THAT IN R0
61870	    JUMPLE R0,SEG1     ;HANDLE NULL OR EMPTY
61880	    JSA    T,SALOC.    ;ELSE ALLOCATE A STRING FOR US
61890	    MOVE   R2,SEGTM    ;GET TALLY OF SOURCE
61900	    MOVEM  R1,SEGTM    ;SAVE TALLY OF NEW
61910	    MOVE   R0,SEGTA    ;GET INITIAL COUNT
61920	    JUMPE  R0,.+3      ;SKIP IF DONE INITIAL STEP
61930	    IBP    R2          ;ELSE BUMP TALLY
61940	    SOJG   R0,.-1      ;UNTIL DONE
61950	    ILDB   R0,R2       ;GET CHARACTER
61960	    IDPB   R0,R1       ;SAVE IN NEW STRING
61970	    SOJG   R3,.-2      ;CONTINUE UNTIL DONE
61980	    SKIPA  R1,SEGTM    ;RESTORE ORIG TALLY/SKIP
61990	;
62000	 SEG1:
62010	    MOVEI  R1,0        ;ERROR--RETURN NULL STRING
62020	    MOVE   R2,SEGT1    ;RESTORE R2
62030	    MOVE   R3,SEGT2    ;AND R3
62040	    JRA    T,3(T)      ;AND RETURN
62050	;
62060	    PAGE
62070	    SUBTTL END OF ASSEMBLY
62080	;
62090	;
62100	;
62110	    PRGEND
62120	    TITLE  SGN. -- BASIC RUN TIME FUNCTIONS--SGN
62130	    SUBTTL ASSEMBLY CONTROL
62140	    SEARCH STENEX,BGBL,BRSYMS
62150	;
62160	;
62170	;
62180	;
62190	    ENTER SGN.
62200	;
62210	;
62220	;
62230	;
62240	;
62250	;
62260	    PAGE
62270	    SUBTTL BASIC RUN TIME FUNCTIONS--SGN
62280	;
62290	;   SGN--THIS FUNCTION RETURNS THE SIGNUM OF ITS SOLE ARGUMENT.  THIS
62300	;      IS 0 IF THE ARG IS 0; OR +/-1 IF THE ARG IS POSITIVE OR NEGATIVE
62310	;      RESPECTIVELY.
62320	;
62330	;
62340	 FCT SGN.,N,1,N
62350	    MOVE   R0,@0(T)    ;GET ARGUMENT
62360	    JUMPE  R0,SGN1     ;DONE IF SO
62370	    JUMPG  R0,SGN2     ;HANDLE >0
62380	    MOVSI R0,(-1.0) ;-1 IF NEGATIVE
62390	;
62400	 SGN1:
62410	    JRA    T,1(T)      ;RETURN
62420	;
62430	 SGN2:
62440	    MOVSI R0,(1.0) ;+1 IF POSITIVE
62450	    JRA    T,1(T)      ;AND RETURN
62460	;
62470	    PAGE
62480	    SUBTTL END OF ASSEMBLY
62490	;
62500	;
62510	;
62520	    PRGEND
62530	TITLE TRIG. -- BASIC RUN TIME FUNCITONS--TRIG RTNS
62540	SUBTTL ASSEMBLY CONTROL
62550	SEARCH BRSYMS,STENEX,BGBL
62560	;
62570	;
62580	ENTER COS.,SIN.,TAN.,COT.
62590	;
62600	;
62610	EXTERNAL RGSV.
62620	;
62630	;
62640	PAGE
62650	SUBTTL TRIG FUNCTIONS -- SIN.
62660	;
62670	;   SIN.--COMPUTES THE SIN FUNCTION.  TAKEN FROM FOROTS.
62680	;
62690	;
62700	 FCT SIN.,N,1,N
62710	;
62720	  MOVE R1,@0(T) ;GET ARG
62730	;
62740	 SIN1:			;ENTRY FROM COS.
62750	  MOVEM R1,RGSV. ;SAVE ARG
62760	  MOVMS R1	;ABS(ARG)
62770	  CAMG R1,SP2	;SIN(X)=X IF X <2^-9
62780	    JRST SIN3A
62790	  MOVEM R2,RGSV.+1 ;SAVE R2
62800	  FDV R1,PIOT ;DIVIDE X BY PI/2
62810	  CAMG R1,ONE ;IS X/(PI/2) < 1.0 ?
62820	  JRST SIN2 ;YES--ARG IN 1ST QUAD ALREADY
62830	  MULI R1,400 ;NO--SEPARATE FRACT AND EXP
62840	  LSH R2,-202(R1) ;GET X MOD 2PI
62850	  TLZ R2,(1B0) ;SUPRESS OVERFLOW ERROR**********???
62860	  MOVEI R1,200 ;PREPARE FLOATING FRACTION
62870	  ROT R2,3 ;SAVE 3 BITS TO DETERMINE QUADRANT
62880	  LSHC R1,33 ;ARG NOW IN RANGE (-1,1)
62890	  FAD R1,SP3 ;NORMALIZE
62900	  JUMPE R2,SIN2 ;REDUCED TO 1ST QUAD IF BITS 000
62910	  TLCE R2,1000 ;-1.0 FROM ARG IF BITS ARE
62920	    FSB R1,ONE ;001 OR 011
62930	  TLCE R2,3000 ;CHECK FOR FIRST QUAD, 001
62940	  TLNN R2,3000 ;CHECK FOR THIRD QUAD, 010
62950	  MOVNS R1 ;001,010
62960	;
62970	 SIN2:
62980	  SKIPGE RGSV. ;CHECK SIGN OF ORIG ARG
62990	  MOVNS R1 ;SIN(-X)=-SIN(X)
63000	  MOVEM R1,RGSV. ;STORE REDUCED ARG
63010	  FMPR R1,R1 ;GET X^2
63020	  MOVE R0,SC9 ;1ST CONST
63030	  FMP R0,R1 ;*X^2
63040	  FAD R0,SC7 ;2ND CONST
63050	  FMP R0,R1 ;*X^2
63060	  FAD R0,SC5 ;3RD CONST
63070	  FMP R0,R1 ;*X^2
63080	  FAD R0,SC3 ;4TH CONSTANT
63090	  FMP R0,R1 ;*X^2
63100	  FAD R0,PIOT ;5TH CONST
63110	;
63120	 SIN2B:
63130	  FMPR R0,RGSV. ;*X
63140	  SKIPA R2,RGSV.+1 ;RESTORE R2, SKIP
63150	;
63160	 SIN3A:
63170	  MOVE R0,RGSV. ;SIN(X)=X
63180	;
63190	  JRA T,1(T) ;AND RETURN
63200	;
63210	;
63220	;   CONSTANTS USED FOR SIN
63230	;
63240	SC3: 577265210372
63250	SC5: 175506321276
63260	SC7: 606315546346
63270	SC9: 164475536722
63280	SP2: 170000000000
63290	SP3: 0
63300	ONE: 1.0
63310	PIOT: 201622077325
63320	;
63330	;
63340	PAGE
63350	SUBTTL TRIG FUNCTIONS -- COS.
63360	;
63370	;   COS.--COMPUTES THE COSINE FUNCTION.  TAKEN FROM FOROTS, USES
63380	;      THE SIN. ROUTINE.
63390	;
63400	;
63410	 FCT COS.,N,1,N
63420	;
63430	  MOVE R1,@0(T) ;GET ARG
63440	  FADR R1,PIOT ;+PI/2  (COS(X)=SIN(X+PI/2)
63450	  JRST SIN1 ;AND PROCESS
63460	;
63470	;
63480	PAGE
63490	SUBTTL TRIG FUNCTIONS -- COT.
63500	;
63510	;   COT.--COMPUTE THE COTANGENT FUNCTION--COMPUTES COS/SIN
63520	;
63530	;
63540	 FCT COT.,N,1,N
63550	;
63560	  MOVE R0,@0(T) ;GET ARG
63570	  MOVEM R0,RGSV.+10 ;SAVE IT
63580	  JSA T,SIN. ;COMPUTE SIN
63590	    JUMP RGSV.+10 ;OF ARG
63600	  MOVEM R0,RGSV.+11 ;SAVE RESULT
63610	  JSA T,COS. ;NOW COMPUTE COSING
63620	    JUMP RGSV.+10 ;OF ARG
63630	  FDVR R0,RGSV.+11 ;GET QUOTIENT
63640	  JRA T,1(T) ;AND RETURN IT
63650	;
63660	;
63670	PAGE
63680	SUBTTL TRIG FUNCTIONS -- TAN.
63690	;
63700	;   TAN.--COMPUTE THE TANGENT FUNCTIONS--COMPUTES SIN/COS.
63710	;
63720	;
63730	 FCT TAN.,N,1,N
63740	;
63750	  MOVE R0,@0(T) ;GET ARG
63760	  MOVEM R0,RGSV.+10 ;SAVE IT
63770	  JSA T,COS. ;COMPUTE COSING
63780	    JUMP RGSV.+10 ;OF ARG
63790	  MOVEM R0,RGSV.+11 ;SAVE RESULT
63800	  JSA T,SIN. ;COMPUTE SINE
63810	    JUMP RGSV.+10 ;OF ARG
63820	  FDVR R0,RGSV.+11 ;COMPUTE QUOTIENT
63830	  JRA T,1(T) ;AND RETURN
63840	;
63850	;
63860	PAGE
63870	SUBTTL END OF ASSEMBLY
63880	;
63890	;
63900	;
63910	PRGEND
63920	TITLE SQR. -- BASIC RUN TIME FUNCTIONS -- SQUARE ROOT
63930	SUBTTL ASSEMBLY CONTROL
63940	SEARCH STENEX,BGBL,BRSYMS
63950	;
63960	;
63970	ENTER SQR.
63980	;
63990	;
64000	EXTERNAL RGSV.
64010	;
64020	;
64030	PAGE
64040	SUBTTL SQUARE ROOT COMPUTATION
64050	;
64060	;   SQR.--THIS FUNCTION COMPUTES THE SQUARE ROOT USING
64070	;      NEWTONS METHOD.  IT WAS TAKEN FROM FOROTS.
64080	;
64090	;
64100	 FCT SQR.,N,1,N
64110	;
64120	  SKIPG R1,@0(T) ;CHECK IF ARG > 0
64130	    JRST SQRT4 ;HANDLE IF NOT
64140	;
64150	 SQRTP:
64160	  MOVEI R0,0 ;GET EXP TO R0
64170	  LSHC R0,11 ;FROM ARG IN R1
64180	  SUBI R0,201 ;GET TRUE EXP+1
64190	  ROT R0,-1 ;DIVIDE BY 2
64200	  HRRM R0,SQRT2 ;AND STORE FOR SCALE INST
64210	  LSH R1,-11 ;RESTORE FRACTION IN R1
64220	  JUMPL R0,SQRT3 ;JUMP IF > 0.5
64230	  FSC R1,177 ;< 0.5--FIX UP EXP .25<F<.5
64240	  MOVEM R1,RGSV. ;SAVE FRACTION
64250	  FMPRI R1,200640 ;COMPUTE LINEAR APPROX #1
64260	  FADRI R1,177465
64270	;
64280	 SQRT1:
64290	  MOVE R0,RGSV. ;1ST ITERATION OF NEWTON
64300	  FDV R0,R1 ;F/APPROX
64310	  FAD R1,R0 ;APPROX+F/APPROX
64320	  FSC R1,-1 ;0.5(APPROX+F/APPROX)
64330	  MOVE R0,RGSV. ;2ND ITERATION
64340	  FDV R0,R1 ;F/APPROX
64350	  FADR R0,R1 ;APPROX+F/APPROX
64360	;
64370	 SQRT2:
64380	  FSC 0 ;HALVE AND SCALE EXPONENT
64390	  JRA T,1(T) ;AND DONE--RETURN
64400	;
64410	 SQRT3:
64420	  FSC R1,200 ;FIX UP EXP .5<=F<1
64430	  MOVEM R1,RGSV. ;SAVE FRACT
64440	  FMPRI R1,200450 ;COMPUTE LIN APPROX 2
64450	  FADRI R1,177660
64460	  JRST SQRT1 ;AND EXNTER NEWTON CODE
64470	;
64480	 SQRT4:
64490	  JUMPE R1,SQRT5 ;SQR(0)=0
64500	  ERR E.SQRT ;ERROR IF NEGATIVE
64510	  MOVM R1,@0(T) ;GET ABS IF NEG
64520	  JRST SQRTP ;AND USE IT
64530	;
64540	 SQRT5:
64550	  MOVEI R0,0 ;GET A ZERO TO RETURN
64560	  JRA T,0(T) ;AND RETURN IT
64570	;
64580	;
64590	;   ERROR MESSAGES
64600	;
64610	E.SQRT: ER WRN,Square root of negative number
64620	;
64630	;
64640	PAGE
64650	SUBTTL END OF ASSEMBLY
64660	;
64670	;
64680	;
64690	PRGEND
64700	    TITLE  STR. -- BASIC RUN TIME FUNCTIONS--STR$
64710	    SUBTTL ASSEMBLY CONTROL
64720	    SEARCH STENEX,BGBL,BRSYMS
64730	;
64740	;
64750	;
64760	    ENTER STR.
64770	;
64780	    EXTERNAL SALOC.,STLN.,E.SYS
64790	;
64800	;
64810	;
64820	;
64830	;
64840	    PAGE
64850	    SUBTTL RUN TIME FUNCTIONS--STR
64860	;
64870	;   STR--THIS FUNCTION TAKES A NUMBER AS ITS ONE ARGUMENT AND RETURNS
64880	;      THE STRING CONTAINING THE PRINT FORMAT OF THAT NUMBER.
64890	;
64900	;
64910	 FCT STR.,S,1,N
64920	    MOVEM  R2,STRT1#   ;SAVE R2
64930	    MOVEM  R3,STRT2#   ;SAVE R3
64940	    MOVE   R3,@0(T)    ;PICK UP THE ARGUMENT
64950	    MOVEI  R0,15       ;LENGTH IN CHARACTERS (MAX)
64960	    JSA    T,SALOC.    ;ALLOCATE STRING
64970	    MOVEM  R1,STRT3#   ;SAVE PTR TO STRING
64980	    MOVE   R2,R3       ;GET NUMBER IN R2
64990	    MOVEI  R3,0        ;DEFAULT FORMAT IN R3
65000	    FLOUT              ;CONVERT NUMBER TO STRING
65010	    ERR    E.SYS       ;ERROR IF FAIL
65020	    MOVE   R1,STRT3    ;RESTORE TALLY TO STRING
65030	    JSA    T,STLN.     ;GET ACTUAL LENGTH OF STRING
65040	    MOVE   R2,STRT1    ;RSTORE R2
65050	    MOVE   R3,STRT2    ;RESTORE R3
65060	    JRA    T,1(T)      ;AND RETURN
65070	;
65080	    PAGE
65090	    SUBTTL END OF ASSEMBLY
65100	;
65110	;
65120	;
65130	    PRGEND
65140	    TITLE  TIM. -- BASIC RUN TIME FUNCTIONS--TIM
65150	    SUBTTL ASSEMBLY CONTROL
65160	    SEARCH STENEX,BGBL,BRSYMS
65170	;
65180	;
65190	;
65200	    ENTER TIM.
65210	;
65220	;
65230	    EXTERNAL STTIM.
65240	;
65250	;
65260	;
65270	;
65280	    PAGE
65290	    SUBTTL BASIC RUN TIME FUNCTIONS--TIM
65300	;
65310	;   TIM--THIS FUNCTION RETURNS THE RUN TIME IN SECONDS AS A FLOATING
65320	;      POINT NUMBER.  THE FRUN TIME USED IS THAT OF THE CURRENT FORK.
65330	;
65340	;
65350	 FCT TIM.,N,0
65360	    MOVEM  R2,TIMT1#   ;SAVE R2
65370	    MOVEM  R3,TIMT2#   ;AND R3
65380	    HRRZI  R1,400000   ;CURRENT FORK
65390	    RUNTM              ;GET RUN TIME
65400	    SUB R1,STTIM. ;GET DELTA RUN TIME SINCE START
65410	    FSC    R1,233      ;FLOAT IT
65420	    FSC R2,233	;FLOAT DIVISOR
65430	    FDVR R1,R2	;GET RESULT
65440	    MOVE   R0,R1       ;RETURN IN R0
65450	    MOVE   R2,TIMT1    ;RESTORE R2
65460	    MOVE   R3,TIMT2    ;RESTORE R3
65470	    JRA    T,0(T)      ;AND RETURN
65480	;
65490	    PAGE
65500	    SUBTTL END OF ASSEMBLY
65510	;
65520	;
65530	;
65540	    PRGEND
65550	TITLE TYP. -- BASIC RUN TIME FUNCTIONS--TYP, PER
65560	SUBTTL ASSEMBLY CONTROL
65570	SEARCH STENEX,BGBL,BRSYMS
65580	;
65590	;
65600	;
65610	 ENTER TYP.,PER.
65620	;
65630	;
65640	EXTERNAL RGSV.,FLPTR.,E.FLR1,TMPTL.,CRTTY.
65650	;
65660	;
65670	;
65680	;
65690	 PAGE
65700	SUBTTL BASIC RUN TIME FUNCTIONS--TYP.
65710	;
65720	;   TYP--THIS ROUTINE HANDLES THE TYP FUNCTION  IT RETURNS (-1,0,1) IN
65730	;      RESPONSE TO AN INQUIRY ABOUT THE TYPE OF A FILE. -1 MEANS THAT
65740	;      THE INQUIRY WAS NOT UNDERSTOOD, 0 THAT IT IS NOT, AND 1 THAT
65750	;      IT IS THE TYPE GIVEN.
65760	;
65770	;
65780	 FCT TYP.,N,2,F,S
65790	;
65800	  MOVE R0,[IOWD TYPTBL,TYPTB+1]	;TABLE PTR OF INQUIRYS
65810	  JRST TYPER		;ENTER COMMON ROUTINE
65820	;
65830	;
65840	;   TABLE FOR TYP
65850	;
65860	 TYPTB:
65870	  ASCII 'TERMI'
65880	    ASCII 'NAL'
65890	    XWD FB.RST+FB.RNM+FB.TTY,0
65900	  ASCII 'NUMER'
65910	    ASCII 'IC'
65920	    XWD FB.ASC+FB.RST+FB.TTY,0
65930	  ASCII 'STRIN'
65940	    ASCII 'G'
65950	    XWD FB.ASC+FB.RNM+FB.TTY+FB.UDF,0
65960	  ASCII 'TTY'
65970	    EXP 0
65980	    XWD FB.ASC+FB.RNM+FB.RST+FB.EPY+FB.UDF,0
65990	  ASCII 'ANY'
66000	    EXP 0
66010	    XWD 0
66020	;
66030	 TYPTBL== .-TYPTB
66040	;
66050	;
66060	PAGE
66070	SUBTTL BASIC RUN TIME FUNCTIONS--PER.
66080	;
66090	;   PER--THIS FUNCTIONS IS SIMILAR TO TYP EXCEPT IT INVOLVES QUESTIONS
66100	;      AS TO WHAT CAN BE DONE WITHT THE FILE.  THEY USE A COMMON
66110	;      ROUTINE.
66120	;
66130	;
66140	 FCT PER.,N,2,F,S
66150	;
66160	  MOVE R0,[IOWD PERTBL,PERTB+1]	;GET TABLE PTR
66170	  JRST TYPER		;AND PROCESS
66180	;
66190	;
66200	;   TABLE FOR PER
66210	;
66220	 PERTB:
66230	;
66240	  ASCII 'INPUT'
66250	    EXP 0
66260	    XWD FB.RST+FB.RNM+400000+FB.EPY,0
66270	  ASCII 'LINPU'
66280	    ASCII 'T'
66290	    XWD FB.RST+FB.RNM+400000+FB.EPY,0
66300	  ASCII 'PRINT'
66310	    EXP 0
66320	    XWD FB.RST+FB.RNM+040000,0
66330	  ASCII 'READ'
66340	    EXP 0
66350	    XWD FB.ASC+FB.TTY+400000+FB.EPY,0
66360	  ASCII 'RESET'
66370	    EXP 0
66380	    XWD 400000,0
66390	  ASCII 'SCRAT'
66400	    ASCII 'CH'
66410	    XWD 600000,0
66420	  ASCII 'WRITE'
66430	    EXP 0
66440	    XWD FB.ASC+FB.TTY+200000,0
66450	;
66460	 PERTBL== .-PERTB
66470	;
66480	;
66490	PAGE
66500	SUBTTL BASIC RUN TIME FUNCTIONS--TYPER
66510	;
66520	;   TYPER--THIS IS THE COMMON ROUTINE TO HANDLE THE PER AND TYP FCTS.
66530	;      IT IS ENTERED WITH A TABLE PTR (IOWD) IN R0.  THE FIRST TWO WORDS OF
66540	;      THE THREE WORD TABLE ENTRYS CONTAIN THE ASCIZ NAME.  THE LAST WORD
66550	;      CONTAINS BITS NOT ALLOWED FOR THIS ITEM, WITH THE LOWER BITS BEING
66560	;     FOR TYPE (400--1) AND THE UPPER ONES FOR PERMISSIONS (SEE ACCESSES
66570	;      IN TENEX).
66580	;
66590	;
66600	TYPER:
66610	;
66620	  MOVEM R2,RGSV.	;SAVE R2
66630	  MOVEM R3,RGSV.+1	;AND R3 AND R4
66640	  MOVEM R4,RGSV.+2
66650	  MOVEM R0,RGSV.+10	;SAVE TABLE PTR
66660	;
66670	  MOVE R0,@0(T)		;GET FILE NUMBER
66680	  SKIPN R1,@1(T)	;GET STRING NAME
66690	    JRST TYP10		;NULL STRING IS ILLEGAL
66700	  MOVE R2,0(R1)		;GET FIRST WORD OF STRING
66710	  MOVEI R3,0		;GUESS NO SECOND WORD
66720	  HLRZ R4,-1(R1)
66730	  CAILE R4,5
66740	    MOVE R3,1(R1)	;GET SECOND WORD IF PRESENT
66750	  MOVE R1,RGSV.+10	;RESTORE TABLE PTR
66760	;
66770	 TYP3:
66780	  CAMN R2,0(R1)
66790	  CAME R3,1(R1)		;CHECK FOR MATCH WITH TABLE
66800	    SKIPA		;NO MATCH--SKIP
66810	    JRST TYP2		;HANDLE MATCH
66820	  ADD R1,[XWD 2,2]	;SKIP MOST OF THIS ENTRY
66830	  AOBJN R1,TYP3		;LOOP IF MORE
66840	  JRST TYP10	;NOT FOUND
66850	;
66860	 TYP2:
66870	  MOVE R3,2(R1)		;GET BITS WORD
66880	  MOVEM R3,RGSV.+10	;SAVE IT
66890	  JSA T,FLPTR.		;GET FILE POINTER
66900	    JRST TYP20		;NO FILE--CAN'T DO VERY MUCH
66910	  MOVE R2,R0		;GET PTR IN R2
66920	  SKIPN F.JFN(R2)	;CHECK IF FILE EXISTS
66930	    JRST TYP20		;NO--AUTOMATIC FAIL
66940	;
66950	  MOVE R1,F.BTS(R2)	;GET BITS
66960	  AND R1,[XWD FB.OUR,0]	;KEEP TYPE BITS
66970	  TLNE R1,FB.EPY	;CHECK IF UNDEFINED AND EMPTY
66980	    TLZ R1,FB.UDF	;LET EPY SHOW THIS ALONE
66990	  TLNE R1,FB.TTY	;CHECK FOR TTY TYPE
67000	    TLZ R1,FB.ASC	;DIRRERENTIATE FROM ASCII
67010	  TDNE R1,RGSV.+10	;CHECK IF FILE LEGAL THUS FAR
67020	    JRST TYP20		;NO--ILLEGAL TYPE
67030	  MOVSI R1,740000	;YES--GET REMAINING BTS
67040	  TDNN R1,RGSV.+10	;CHECK IF ANY OTHER TESTS TO MAKE
67050	    JRST TYP30		;NO--SUCCESSFUL
67060	;
67070	  JSA T,GTPROT		;GET CURRENT ACCESS TO FILE IN R0
67080	  TLC R0,640000		;COMPLEMENT RELEVANT BITS TO GET WHAT CAN'T DO
67090	  TDNN R0,RGSV.+10	;CHECK IF WE CAN DO WHAT WE WANT TO
67100	    JRST TYP30		;YES--HANDLE
67110	    JRST TYP20		;NO--HANDLE
67120	;
67130	;
67140	 TYP10:
67150	  MOVSI R0,(-1.0)	;ILLEGAL STRING
67160	;
67170	 TYP11:
67180	  MOVE R2,RGSV.		;RESTORE R2,R3,R4
67190	  MOVE R3,RGSV.+1
67200	  MOVE R4,RGSV.+2
67210	  JRA T,2(T)		;AND RETURN
67220	;
67230	;
67240	 TYP20:
67250	  MOVEI R0,0		;NOT LEGAL--RETURN 0
67260	  JRST TYP11
67270	;
67280	;
67290	 TYP30:
67300	  MOVSI R0,(1.0)	;LEGAL RETURN 1.0
67310	  JRST TYP11
67320	;
67330	;
67340	PAGE
67350	SUBTTL BASIC RUN TIME FUNCTIONS--GTPROT
67360	;
67370	;   GTPROT--THIS ROUTINE IS USED BY TYPER TO GET THE CURRENT
67380	;      ACCESSES (PROTECTIONS) OF A FILE.  THE FILE BLOCK PTR
67390	;      IS IN R2 ON ENTRY.  THIS ROUTINE DOESN'T HANDLE GROUP
67400	;      PERMISSIONS CURRENTLY.  IT IS HOPED THAT A NEW JSYS WILL
67410	;      SIMPLY ITS WORK GREATLY.
67420	;
67430	;
67440	GTPROT: Z
67450	;
67460	  MOVE R1,F.BTS(R2)	;GET TYPE OF FILE
67470	  TLNE R1,FB.TTY	;CHECK FOR TTY
67480	    JRST GTPRT1		;HANDLE SPECIAL IF SO
67490	  HRRZ R2,F.JFN(R2)	;GET JFN
67500	  MOVEM R2,RGSV.+14	;SAVE
67510	  MOVE R1,TMPTL.	;WERE DIRECTORY NAME SHOULD GO
67520	  MOVSI R3,010000	;CODE FOR DIRECTORY ONLY
67530	  JFNS			;GET FILE'S DIRECTORY
67540	  MOVEI R1,1		;POSITIVE NUMBER ==>EXACT MATCH
67550	  MOVE R2,TMPTL.	;WHERE DIRECTORY IS
67560	  STDIR			;GET DIRECTORY NUMBER
67570	    BLOWUP		;ALWAYS WILL WORK AS FROM FILE
67580	    BLOWUP
67590	  HRRZS R1		;ISOLATE NUMBER
67600	  EXCH R1,RGSV.+14	;SAVE NUMBER, RESTORE JFN
67610	  MOVE R2,[XWD 1,FDBPRT]	;GET FILE PROTECTION WORD
67620	  MOVEI R3,0		;TO R0
67630	  GTFDB			;FROM FDB
67640	  GJINF			;NO2W GET JOB INFO
67650	  CAME R2,RGSV.+14	;CHECK FOR SAME ACCOUNT AS CONNECTED
67660	    LSH R0,6+6		;IF SO, USE PROPER PROTECTION BITS
67670	  HRLZS R0		;GET IN UPPER HALF
67680	  AND R0,[XWD 770000,0]	;KEEP ONLY ONE SET OF BITS
67690	  JRA T,0(T)		;AND RETURN
67700	;
67710	 GTPRT1:
67720	  MOVSI R0,770000	;FAKE BITS FOR TTY
67730	  JRA T,0(T)		;RETURN THEM
67740	;
67750	;
67760	PAGE
67770	SUBTTL END OF ASSEMBLY
67780	;
67790	;
67800	;
67810	PRGEND
67820	    TITLE  USR. -- BASIC RUN TIME FUNCTIONS--USR$
67830	    SUBTTL ASSEMBLY CONTROL
67840	    SEARCH STENEX,BGBL,BRSYMS
67850	;
67860	;
67870	;
67880	    ENTER USR.
67890	;
67900	;
67910	    EXTERNAL SALOC.,STLN.
67920	;
67930	;
67940	;
67950	;
67960	    PAGE
67970	    SUBTTL BASIC RUN TIME FUNCTIONS--USR$
67980	;
67990	;   USR--THIS FUNCTION RETURNS THE CURRENT ACCOUNT AS A STRING.  THE
68000	;      ACCOUNT USED IS THAT ATTACHED TO THE JOB.
68010	;
68020	;
68030	 FCT USR.,S,0
68040	    MOVEM  R2,USRT1#   ;SAVE R2
68050	    MOVEM  R3,USRT2#   ;SAVE R3
68060	    MOVEM  R4,USRT3#   ;SAVE R4
68070	    MOVEI  R0,50       ;MAX LENGTH OF ACCOUT
68080	    JSA    T,SALOC.    ;ALLOCATE STRING
68090	    MOVEM  R1,USRT4#   ;SAVE THE TALLY
68100	    GJINF              ;GET JOB INFORMATION
68110	    MOVE   R1,USRT4    ;RESTORE STRING POINTER
68120	    DIRST              ;DIRECTORY#(R2) TO STRING(R1)
68130	    NOP ;IGNORE BAD RETURN (CAN'T HAPPEN)
68140	    MOVE   R1,USRT4    ;RESTORE STRING POINTER
68150	    JSA    T,STLN.     ;GET ACTUAL LENGTH OF STRING
68160	    MOVE   R2,USRT1    ;RESTORE R2
68170	    MOVE   R3,USRT2    ;RESTORE R3
68180	    MOVE   R4,USRT3    ;RESTORE R4
68190	    JRA    T,0(T)      ;AND RETURN
68200	;
68210	    PAGE
68220	    SUBTTL END OF ASSEMBLY
68230	;
68240	;
68250	;
68260	    PRGEND
68270	    TITLE  VAL. -- BASIC RUN TIME FUNCTIONS--VAL
68280	    SUBTTL ASSEMBLY CONTROL
68290	    SEARCH STENEX,BGBL,BRSYMS
68300	;
68310	;
68320	;
68330	    ENTER VAL.
68340	;
68350	;
68360	;
68370	;
68380	    PAGE
68390	    SUBTTL BASIC RUN TIME FUNCTIONS--VAL
68400	;
68410	;   VAL--THIS IS A FUNCTION OF A STRING ARGUMENT WHICH RETURNS THE NUMBER
68420	;      WHICH THAT STRING REPRESENTS (AS IN INPUT).  IT IS THE INVERSE
68430	;      OF STR$.
68440	;
68450	;
68460	 FCT VAL.,N,1,S
68470	    MOVE   R0,R2       ;SAVE R2 IN R0
68480	    SKIPN   R1,@0(T)    ;PICK UP STRING POINTER
68490	    ERR E.VAL		;CAN'T HAVE NULL STRING
68500	    FLIN               ;CONVERT TO NUMBER
68510	    ERR    E.VAL       ;ERROR IF CAN'T
68520	    EXCH   R2,R0       ;RETURN NUMBER IN R0;RESTORE R2
68530	    JRA    T,1(T)      ;AND RETURN
68540	;
68550	;
68560	;   ERROR MESSAGE
68570	;
68580	 E.VAL: ER NRM,Illegal VAL argument
68590	;
68600	;
68610	    PAGE
68620	    SUBTTL END OF ASSEMBLY
68630	;
68640	;
68650	;
68660	    PRGEND
68670	TITLE MADD. -- BASIC RUN TIME MAT ROUTINES MAT ADD, SUB
68680	SUBTTL ASSEMBLY CONTROL
68690	SEARCH STENEX,BGBL,BRSYMS
68700	;
68710	;
68720	ENTER MADD.,MSUB.
68730	;
68740	;
68750	EXTERNAL E.DIM,CKDMS.,SET3.,NEXT3.,NEXT2.,NEXT1.
68760	EXTERNAL EXIT3.,EXIT2.,EXIT1.,RSET1.
68770	;
68780	;
68790	PAGE
68800	SUBTTL RUN TIME MAT ROUTINES--MADD,MSUB
68810	;
68820	;   MADD,MSUB--THESE ROUTINES DO MATRIX ADDITION AND
68830	;      SUBTRACTION RESPECTIVELY.  THEY USE A COMMON ROUTINE
68840	;      MADSB WHICH UTILIZES THE STANDARD MATRIX ROUTINES
68850	;      (SET,NEXT,EXIT).
68860	;
68870	;
68880	MADD.: Z
68890	;
68900	  MOVE R0,[FADR R2,0(R10)] ;GET OP TO USE
68910	  JRST MADSB ;AND PROCESS
68920	;
68930	;
68940	MSUB.: Z
68950	;
68960	  MOVE R0,[FSBR R2,0(R10)] ;GET OP TO USE FOR SUB
68970	;
68980	;
68990	 MADSB:
69000	  MOVEM R0,MATOP# ;SAVE OP TO USE
69010	  JSP R1,SET3. ;SET UP ALL THREE MATS
69020	  MOVE R0,1(R5) ;GET FIRST DIM OF 1ST
69030	  CAME R0,1(R7) ;COMPARE TO SECOND
69040	    ERR E.DIM ;MUST BE THE SAME
69050	  MOVE R1,2(R5) ;GET SECOND DIM OF FIRST
69060	  CAME R1,2(R7) ;COMPARE TO SECOND
69070	    ERR E.DIM ;MUST BE THE SAME
69080	  MOVE R2,R3 ;R2(R0,R1) TO BE CREATED
69090	  JSA T,CKDMS. ;CHECK NEW DIMS
69100	  JSP R1,RSET1. ;RESET PARAMETERS FOR NEW ARRAY
69110	;
69120	 MADSB1:
69130	  JSP R1,NEXT3. ;NEXT ITEM OF THIRD
69140	    JRST EXIT3. ;DONE
69150	  MOVE R2,0(R6) ;GET NEXT ITEM OF FIRST
69160	  XCT MATOP ;ADD OR SUB THE SECOND
69170	  MOVEM R2,0(R4) ;SAVE IN THIRD
69180	  JRST MADSB1 ;AND LOOP
69190	;
69200	;
69210	PAGE
69220	SUBTTL END OF ASSEMBLY
69230	;
69240	;
69250	;
69260	PRGEND
69270	TITLE MASS. -- BASIC RUN TIME MAT ROUTINES--MASS, MSCL
69280	SUBTTL ASSEMBLY CONTROL
69290	SEARCH STENEX,BGBL,BRSYMS
69300	;
69310	;
69320	ENTER MASS.,MSCL.,SMASS.
69330	;
69340	;
69350	EXTERNAL SET2.,CKDMS.,NEXT2.,NEXT1.,EXIT2.,RSET2.,RSET1.,MTRGS.
69360	;
69370	;
69380	PAGE
69390	SUBTTL MAT ROUTINES--MAT ASSIGNMENT, MAT SCALAR
69400	;
69410	;   MASS--THIS ROUTINE DOES MAT A=B.
69420	;
69430	;   MSCL--THIS ROUTINE MULTIPLIES A MATRIX BY A SCALAR.
69440	;
69450	;   SMASS--THIS ROUTINE DOES MAT A$=B$
69460	;
69470	;   THE ABOVE ROUTINE BOTH USE A COMMON WORK ROUTINE (MASSC)
69480	;      WHICH USES THE STANDARD MAT FCTS.
69490	;
69500	;
69510	MASS.: Z
69520	;
69530	  JSP R1,SET2.	;GET 2 MATS
69540	  MOVE R0,[TRN] ;DO NOTHING TO THE ELEMENTS BUT MOVE
69550	  JRST MASSC ;AND ENTER COMMON ROUTINE
69560	;
69570	;
69580	MSCL.: Z
69590	;
69600	  MOVE R0,@1(T) ;GET SCALAR
69610	  MOVEM R0,MTSCLR# ;SAVE IT
69620	  MOVEM R3,MTRGS.+3	;SAVE MAT REGS
69630	  MOVEM R4,MTRGS.+4	;R3,R4,R5,R6
69640	  MOVEM R5,MTRGS.+5
69650	  MOVEM R6,MTRGS.+6
69660	  MOVE R3,0(T)		;GET FIRST MAT
69670	  MOVE R5,2(T)		;AND SECOND
69680	  JSP R1,RSET2.		;SET UP SECOND
69690	  AOS T			;BUMP RETURN
69700	  MOVE R0,[FMPR R2,MTSCLR] ;GET OP TO DO MULTIPLY
69710	  JRST MASSC		;AND SKIP
69720	;
69730	;
69740	SMASS.: Z
69750	;
69760	  JSP R1,SET2.		;GET 2 MATS
69770	  MOVE R0,[JSP R0,SMASSA] ;CODE TO DO ASSIGNMENT SET UP
69780	  JRST MASSC		;PROCESS
69790	;
69800	 SMASSA:
69810	  SKIPE R2		;CHECK FOR NULL STRING
69820	    AOS -1(R2)		;UPDATE IF NOT
69830	  JRST @R0		;AND RETURN TO DO ASSIGNMENT
69840	;
69850	;
69860	 MASSC:
69870	  MOVEM R0,MATOP# ;SAVE THE OP
69880	  MOVE R0,1(R5) ;GET DIMS OF GIVEN
69890	  MOVE R1,2(R5) ;BOTH OF THEM
69900	  MOVE R2,R3 ;GET PTR TO SECOND
69910	  JSA T,CKDMS. ;SET DIMS THE SAME
69920	  JSP R1,RSET1. ;RESET PTRS,DIMS FOR NEW MAT
69930	;
69940	 MASS1:
69950	  JSP R1,NEXT2. ;NEXT ITEM PTR
69960	    JRST EXIT2. ;HANDLE DONE
69970	  MOVE R2,0(R6) ;GET NEXT ITEM BEING MOVED
69980	  XCT MATOP ;MODIFY IT
69990	  MOVEM R2,0(R4) ;AND SAVE IN NEW LOC
70000	  JRST MASS1 ;AND LOOP
70010	;
70020	;
70030	PAGE
70040	SUBTTL END OF ASSEMBLY
70050	;
70060	;
70070	;
70080	PRGEND
70090	TITLE MCON. -- BASIC RUN TIME MAT ROUTINES--FUNCTIONS I
70100	SUBTTL ASSEMBLY CONTROL
70110	SEARCH STENEX,BGBL,BRSYMS
70120	;
70130	;
70140	ENTER CON.,ZER.,NUL.
70150	;
70160	;
70170	EXTERNAL MSET.,SDLOC.
70180	;
70190	;
70200	PAGE
70210	SUBTTL MAT FUNCTION ROUTINES--CON,ZER,NUL$
70220	;
70230	;   THESE MAT FUNCTIONS ARE ALL GROUPED TOGETHER AS THEY
70240	;      ALL USE THE MSET. ROUTINE.  OTHER MAT FUNCTIONS
70250	;      WILL BE FOUND SEPARATELY.  CON SETS A MAT TO ALL
70260	;      ONES;9 ZER TO ALL ZEROS; NUL$ TO ALL NULL
70270	;      STRINGS.
70280	;
70290	;
70300	CON.: Z
70310	;
70320	  MOVE R0,[MOVSI R2,201400] ;GET OP
70330	  JRST MSET. ;AND PROCESS
70340	;
70350	;
70360	ZER.: Z
70370	;
70380	  MOVE R0,[MOVEI R2,0] ;GET OP
70390	  JRST MSET. ;AND PROCESS
70400	;
70410	;
70420	NUL.: Z
70430	;
70440	  MOVE R0,[JSA T,SDLOC.] ;OP IS CALL
70450	  JRST MSET. ;AND PROCESS
70460	;
70470	;
70480	PAGE
70490	SUBTTL END OF ASSEMBLY
70500	;
70510	;
70520	;
70530	PRGEND
70540	TITLE MWRN. -- BASIC RUN TIME MAT ROUTINES--WRITE NUMERIC
70550	SUBTTL SHORT ASSEMBLY
70560	SEARCH STENEX,BGBL,BRSYMS
70570	;
70580	;
70590	ENTER MWRN.
70600	;
70610	;
70620	EXTERNAL MSET.,WRNUM.
70630	;
70640	;
70650	;
70660	;
70670	 MWRN.: Z
70680	  MOVE R0,[JSA T,WRNUM.] ;GET OP
70690	  JRST MSET. ;AND PROCESS
70700	;
70710	;
70720	;
70730	PRGEND
70740	TITLE MWRS. -- BASIC RUN TIME MAT ROUTINES--WRITE STRING
70750	SUBTTL SHORT ASSEMBLY
70760	SEARCH STENEX,BGBL,BRSYMS
70770	;
70780	;
70790	ENTER MWRS.
70800	;
70810	;
70820	EXTERNAL MSET.,WRSTR.
70830	;
70840	;
70850	;
70860	;
70870	 MWRS.: Z
70880	  MOVE R0,[JSA T,WRSTR.] ;GET OP
70890	  JRST MSET. ;AND PROCESS
70900	;
70910	;
70920	;
70930	PRGEND
70940	TITLE MRDN. -- BASIC RUN TIME MAT ROUTINES--WREAD NUMERIC
70950	SUBTTL SHORT ASSEMBLY
70960	SEARCH STENEX,BGBL,BRSYMS
70970	;
70980	;
70990	ENTER MRDN.
71000	;
71010	;
71020	EXTERNAL MSET.,RDNUM.
71030	;
71040	;
71050	;
71060	;
71070	 MRDN.: Z
71080	  MOVE R0,[JSA T,RDNUM.] ;GET OP
71090	  JRST MSET. ;AND PROCESS
71100	;
71110	;
71120	;
71130	PRGEND
71140	TITLE MRDS. -- BASIC RUN TIME MAT ROUTINES--READ STRING
71150	SUBTTL SHORT ASSEMBLY
71160	SEARCH STENEX,BGBL,BRSYMS
71170	;
71180	;
71190	ENTER MRDS.
71200	;
71210	;
71220	EXTERNAL MSET.,RDSTR.
71230	;
71240	;
71250	;
71260	;
71270	 MRDS.: Z
71280	  MOVE R0,[JSA T,RDSTR.] ;GET OP
71290	  JRST MSET. ;AND PROCESS
71300	;
71310	;
71320	;
71330	PRGEND
71340	TITLE MRIN. -- BASIC RUN TIME MAT ROUTINES--READ INT NUM
71350	SUBTTL SHORT ASSEMBLY
71360	SEARCH STENEX,BGBL,BRSYMS
71370	;
71380	;
71390	ENTER MRIN.
71400	;
71410	;
71420	EXTERNAL RDATN.,MSET.
71430	;
71440	;
71450	;
71460	;
71470	 MRIN.: Z
71480	  MOVE R0,[JSA T,RDATN.] ;GET OP
71490	  JRST MSET. ;AND PROCESS
71500	;
71510	;
71520	;
71530	PRGEND
71540	TITLE MRIS. -- BASIC RUN TIME MAT ROUTINES--READ INT STR
71550	SUBTTL SHORT ASSEMBLY
71560	SEARCH STENEX,BGBL,BRSYMS
71570	;
71580	;
71590	ENTER MRIS.
71600	;
71610	;
71620	EXTERNAL RDATS.,MSET.
71630	;
71640	;
71650	;
71660	;
71670	 MRIS.: Z
71680	  MOVE R0,[JSA T,RDATS.] ;GET OP
71690	  JRST MSET. ;AND PROCESS
71700	;
71710	;
71720	;
71730	PRGEND
71740	TITLE MLNS. -- BASIC RUN TIME MAT ROUTINES--LINPUT STRING
71750	SUBTTL SHORT ASSEMBLY
71760	SEARCH STENEX,BGBL,BRSYMS
71770	;
71780	;
71790	ENTER MLNS.
71800	;
71810	;
71820	EXTERNAL LNSTR.,MSET.
71830	;
71840	;
71850	;
71860	;
71870	 MLNS.: Z
71880	  MOVE R0,[JSA T,LNSTR.] ;GET INDIV CALL
71890	  JRST MSET. ;AND PROCESS
71900	;
71910	;
71920	;
71930	PRGEND
71940	TITLE MINN. -- BASIC RUN TIME MAT ROUTINES--INPUT NUMERIC
71950	SUBTTL SHORT ASSEMBLY
71960	SEARCH STENEX,BGBL,BRSYMS
71970	;
71980	;
71990	ENTER MINN.
72000	;
72010	;
72020	EXTERNAL INNUM.,INAMP.,MSET.,NUM..
72030	;
72040	;
72050	;
72060	;
72070	 MINN.: Z
72080	  MOVEI R2,@0(T) ;GET MAT PTR
72090	  MOVE R0,1(R2) ;GET FIRST DIM
72100	  SUBI R0,1 ;MINUS ONE
72110	  MOVM R1,2(R2) ;GET SECOND DIM (+1 FOR VECTOR)
72120	  SOSE R1 ;MINUS ONE, IGNORE VECTOR
72130	  IMULI R0,R1 ;GET MAXTRIX MAX
72140	  FSC R0,233 ;FLOAT RESULT
72150	  MOVEM R0,NUM.. ;SAVE FOR NUM FUNCTION
72160	;
72170	  SETOM INAMP. ;ALLOW "&" ON INPUT
72180	  MOVE R0,[JSA T,INNUM.] ;GET OP TO DO INPUT
72190	  JRST MSET. ;AND PROCESS
72200	;
72210	;
72220	;
72230	PRGEND
72240	TITLE MINS. -- BASIC RUN TIME MAT ROUTINES--INPUT STRING
72250	SUBTTL SHORT ASSEMBLY
72260	SEARCH STENEX,BGBL,BRSYMS
72270	;
72280	;
72290	ENTER MINS.
72300	;
72310	;
72320	EXTERNAL INSTR.,INAMP.,MSET.,NUM..
72330	;
72340	;
72350	;
72360	;
72370	 MINS.: Z
72380	  MOVEI R2,@0(T) ;GET MAT PTR
72390	  MOVE R0,1(R2) ;GET FIRST DIM
72400	  SUBI R0,1 ;MINUS ONE
72410	  MOVM R1,2(R2) ;GET SECOND DIM (+1 FOR VECTOR)
72420	  SOSE R1 ;MINUS ONE, IGNORE VECTOR
72430	  IMULI R0,R1 ;GET MAXTRIX MAX
72440	  FSC R0,233 ;FLOAT RESULT
72450	  MOVEM R0,NUM.. ;SAVE FOR NUM FUNCTION
72460	;
72470	  SETOM INAMP. ;ALLOW & ON INPUT
72480	  MOVE R0,[JSA T,INSTR.] ;GET CALL TO DO INPUT
72490	  JRST MSET. ;AND PROCESS
72500	;
72510	;
72520	;
72530	PRGEND
72540	TITLE MSET. --BASIC RUN TIME MAT ROUTINES--MSET.
72550	SUBTTL ASSEMBLY CONTROL
72560	SEARCH STENEX,BGBL,BRSYMS
72570	;
72580	;
72590	ENTER MSET.
72600	;
72610	;
72620	EXTERNAL SET1.,NEXT1.,EXIT1.
72630	;
72640	;
72650	PAGE
72660	SUBTTL MAT SUBROUTINES--MSET.
72670	;
72680	;   MSET--THIS IS A ROUTINE USED BY MOST MAT I/O ROUTINES
72690	;      AND BY SEVERAL MAT FUNCTIONS.  IT IS ENTERED WITH
72700	;      AN OP IN R0 ON ENTRY, AND T STILL POINTING TO A ONE-
72710	;      MATRIX CALLING SEQUENCE.  IT EXECUTES THE GIVEN OP
72720	;      FOR EACH ELEMENT OF THE GIVEN MATRIX, WITH THE
72730	;      INSTRUCTION FOLLOWING THE OP BEING A 'MOVEM <ADD>'
72740	;      THUS ALLOWING IT TO SERVE AS A STORE OR AS A POINTER
72750	;      FOR A SUB CALL.
72760	;
72770	;
72780	MSET.:
72790	;
72800	  MOVEM R0,MATOP# ;SAVE THE OP
72810	  JSP R1,SET1. ;SET UP THE ONE MAT
72820	;
72830	 MSET1:
72840	  JSP R1,NEXT1. ;GET THE NEXT ELEMENT
72850	    JRST EXIT1. ;HANDLE DONE
72860	  XCT MATOP ;EXECUTE THE OP
72870	  MOVEM R2,0(R4) ;STORE/POINT TO ELEMENT
72880	  JRST MSET1 ;LOOP IF MORE
72890	;
72900	;
72910	PAGE
72920	SUBTTL END OF ASSEMBLY
72930	;
72940	;
72950	;
72960	PRGEND
72970	TITLE IDN. -- BASIC RUN TIME MAT ROUTINES--IDN.
72980	SUBTTL ASSEMBLY CONTROL
72990	SEARCH BRSYMS,BGBL,STENEX
73000	;
73010	;
73020	;
73030	ENTER IDN.
73040	;
73050	;
73060	EXTERNAL SET1.,NEXT1.,EXIT1.,E.DIM
73070	;
73080	;
73090	PAGE
73100	SUBTTL BASIC RUN TIME MAT FUNCTIONS--IDN.
73110	;
73120	;   IDN.--THIS ROUTINE RETURNS AN IDENTITY MATRIX IN THE
73130	;      MATRIX PASSED.  IT DOES THIS BY FIRST ZEROING IT ALL
73140	;      AND THEN SETTING UP THE DIAGONAL.
73150	;
73160	;
73170	IDN.: Z
73180	;
73190	  JSP R1,SET1.		;SET UP FOR ONE MAT
73200	  MOVE R1,1(R3)		;CHECK FIRST DIM
73210	  CAME R1,2(R3)		;FOR BEING SAME AS SECOND
73220	    ERR E.DIM		;IF NOT, THEN ERROR
73230	;
73240	 IDN1:
73250	  JSP R1,NEXT1.		;GET NEXT ELEMENT PTR
73260	    JRST IDN10		;HANDLE WHEN DONE
73270	  SETZM 0(R4)		;CLEAR THIS ONE
73280	  JRST IDN1		;AND LOOP
73290	;
73300	 IDN10:
73310	  MOVE R1,1(R3)		;GET COUNTER
73320	  HRRZ R4,0(R3)		;POINTER TO DIAG (0,0)
73330	  MOVEI R2,1(R1)	;DIAGONAL DELTA
73340	  MOVSI R0,(1.0)	;NUMBER TO SAVE THERE
73350	  ADD R4,R2		;NEXT DIAG ELEMENT
73360	  MOVEM R0,0(R4)	;SAVE 1 THERE
73370	  SOJG R1,.-2		;LOOP TIL DONE
73380	;
73390	  JRST EXIT1.		;AND THEN EXIT
73400	;
73410	;
73420	PAGE
73430	SUBTTL END OF ASSEMBLY
73440	;
73450	;
73460	;
73470	PRGEND
73480	TITLE MPRN. -- BASIC RUN TIME MAT ROUTINES--PRINT NUMERIC
73490	SUBTTL SHORT ASSEMBLY
73500	SEARCH STENEX,BGBL,BRSYMS
73510	;
73520	;
73530	ENTER MPRN.
73540	;
73550	;
73560	EXTERNAL PEOL.,PNUM.,MPRT.
73570	;
73580	;
73590	;
73600	;
73610	 MPRN.: Z
73620	  JSA T,PEOL. ;FIRST GO TO NEW LINE
73630	  MOVE R0,[JSA T,PNUM.] ;GET OP TO DO PRINT
73640	  JRST MPRT. ;AND PROCESS
73650	;
73660	;
73670	;
73680	PRGEND
73690	TITLE MPRS. -- BASIC RUNT TIME MAT ROUTINES--PRINT STRING
73700	SUBTTL SHORT ASSEMBLY
73710	SEARCH STENEX,BGBL,BRSYMS
73720	;
73730	;
73740	ENTER MPRS.
73750	;
73760	;
73770	EXTERNAL PEOL.,PSTR.,MPRT.
73780	;
73790	;
73800	;
73810	;
73820	 MPRS.: Z
73830	  JSA T,PEOL. ;FIRST GO TO NEW LINE
73840	  MOVE R0,[JSA T,PSTR.] ;GET OP TO DO PRINTING
73850	  JRST MPRT. ;AND PROCESS
73860	;
73870	;
73880	;
73890	PRGEND
73900	TITLE MPUN. -- BASIC RUN TIME MAT ROUTINES--PRINT USING NUM
73910	SUBTTL SHORT ASSEMBLY
73920	SEARCH STENEX,BGBL,BRSYMS
73930	;
73940	;
73950	ENTER MPUN.
73960	;
73970	;
73980	EXTERNAL PUNUM.,MPU.
73990	;
74000	;
74010	;
74020	;
74030	 MPUN.: Z
74040	  MOVE R0,[JSA T,PUNUM.] ;GET OP TO PRINT NUMBERS
74050	  JRST MPU. ;AND PROCESS
74060	;
74070	;
74080	;
74090	PRGEND
74100	TITLE MPUS. -- BASIC RUN TIME MAT ROUTINES--PRINT USING STR
74110	SUBTTL SHORT ASSEMBLY
74120	SEARCH STENEX,BGBL,BRSYMS
74130	;
74140	;
74150	ENTER MPUS.
74160	;
74170	;
74180	EXTERNAL PUSTR.,MPU.
74190	;
74200	;
74210	;
74220	;
74230	 MPUS.: Z
74240	  MOVE R0,[JSA T,PUSTR.] ;GET OP FOR STIRNG PRINT
74250	  JRST MPU. ;AND PROCESS
74260	;
74270	;
74280	;
74290	PRGEND
74300	TITLE MPRT. -- BASIC RUN TIME MAT ROUTINES--MAT PRINT
74310	SUBTTL ASSEMBLY CONTROL
74320	SEARCH STENEX,BGBL,BRSYMS
74330	;
74340	;
74350	ENTER MPRT.,MPU.
74360	;
74370	;
74380	EXTERNAL PEOL.,SET1.,NEXT1.,EXIT1.,INCA1.
74390	;
74400	;
74410	PAGE
74420	SUBTTL MAT ROUTINES--MAT PRINT COMMON ROUTINE--MPRT,MPU
74430	;
74440	;   MPRT--THIS IS A COMMON ROUTINE FOR MAT PRINT AND
74450	;      MATPRINT USING (USING ENTRY IS AT MPU.) IT
74460	;      CYCLES THRU THE MATRIX AND EXECUTES THE OP
74470	;      GIVEN IN R0 FOR EACH ELEMENT OF THE MAT.
74480	;      ALSO, IT ASSUMES THAT THE CALL GIVEN BY T CONTAINS
74490	;      AT 1(T) THE ELEMENT SEPARATOR CALL AND AT 2(T) THE
74500	;      ROW SEPARATOR CALL.
74510	;
74520	;
74530	MPRT.:
74540	  SKIPA R1,[JSA T,PEOL.] ;END CALL TO USE
74550	;
74560	;
74570	MPU.:
74580	  MOVSI R1,(TRN) ;END CALL (NONE) TO USE
74590	;
74600	;
74610	  MOVEM R0,MATOP# ;SAVE OP GIVEN IN R0
74620	  MOVEM R1,MATOP1# ;SECOND OP FOR END
74630	  JSP R1,SET1. ;SET UP THE MATRIX
74640	;
74650	 MPRT1:
74660	  JSP R1,NEXT1. ;GET NEXT ELEMENT
74670	    JRST MPRT3 ;DONE
74680	  XCT MATOP ;EXECUTE OP FOR NEXT ELEMENT
74690	    JUMP 0(R4) ;PTR TO ELEMENT
74700	  MOVE R0,INCA1. ;ELSE CHECK COUNTER
74710	  CAIN R0,1 ;FOR BEING NEW ROW
74720	    JRST MPRT2 ;HANDLE NEW ROW
74730	  XCT 1(T) ;ELSE EXECUTE ITEM SEPARATOR
74740	  JRST MPRT1 ;AND LOOP
74750	;
74760	 MPRT2:
74770	  XCT 2(T) ;EXECUTE ROW SEPARATOR
74780	  JRST MPRT1 ;AND LOOP
74790	;
74800	 MPRT3:
74810	  XCT MATOP1 ;HANDLE END SEPARATOR
74820	  ADDI T,2 ;BUMP RETURN PAST SEP CALLS
74830	  JRST EXIT1. ;AND RETURN
74840	;
74850	;
74860	PAGE
74870	SUBTTL END OF ASSEMBLY
74880	;
74890	;
74900	;
74910	PRGEND
74920	TITLE MVI. -- BASIC RUN TIME MAT ROUTINES--VARIABLE LEN IN
74930	SUBTTL ASSEMBLY CONTROL
74940	SEARCH STENEX,BGBL,BRSYMS
74950	;
74960	;
74970	ENTER MVIN.,MVIS.,NUM.
74980	;
74990	;
75000	EXTERNAL INNUM.,INSTR.,INAMP.,NUM..,SET1.,EXIT1.,INDNC.
75010	;
75020	;
75030	PAGE
75040	SUBTTL BASIC RUN TIME MAT INPUT WITH NO GIVEN DIMS
75050	;
75060	;   THESE ARE THE ENTRYS RELEVANT TO MATINPUT WITHOUT
75070	;      GIVING DIMENSIONS.  THEY INPUT AS MANY NUMBERS
75080	;      AS WILL FIT OR AS ARE GIVEN, AND SET NUM..
75090	;      ACCORDINGLY.  MOREOVER, NUM.. IS ACCESSABLE
75100	;      THRU THE FUNCTION NUM (NUM.).
75110	;
75120	;   THESE ARE ENTRY POINTS TO THE COMMON ROUTINE
75130	;      MVI.
75140	;
75150	;
75160	MVIN.: Z
75170	  MOVE R0,[JSA T,INNUM.] ;NUMERIC MAT INPUT--GET RTN TO USE
75180	  JRST MVI. ;AND ENTER COMMON ROUTINE
75190	;
75200	;
75210	MVIS.: Z
75220	  MOVE R0,[JSA T,INSTR.] ;STRING MAT INPUT--GET RTN
75230	  JRST MVI. ;AND ENTER COMMON ROTUINE
75240	;
75250	;
75260	FCT NUM.,N,0
75270	  MOVE R0,NUM.. ;GET NUMBER OF ITEMS LAST INPUT
75280	  JRA T,0(T) ;AND RETURN THAT
75290	;
75300	;
75310	PAGE
75320	SUBTTL BASIC RUN TIME MATINPUT--MVI.
75330	;
75340	;   MVI.--THIS ROUTINE USES THE OP IN R0 ON ENTRY TO READ
75350	;      ONE ITEM.  IT READS UNTIL EITHER AN END OF LINE
75360	;      (WITHOUT AN '&') OR UNTIL THE MATRIX IS FULL.
75370	;
75380	;
75390	MVI.:
75400	  MOVEI R1,1		;POSITIVE VALUE
75410	  MOVEM R1,INAMP.	;FOR FLAG ALLOWING & AND NULL LINES
75420	  MOVEM R0,MATOP# ;SAVE THE OPERATION TO GET MAT
75430	;
75440	  JSP R1,SET1. ;SET UP OUR ONE MATRIX
75450	  HLRZ R0,0(R3) ;GET MAX DIM OF IT
75460	  MOVEM R0,MAXDM# ;SAVE THAT
75470	;
75480	 MVI1:
75490	  SOSG MAXDM ;CHECK IF ROOM FOR MORE IN MATRIX
75500	    JRST MVI2 ;NO--DONE
75510	  AOS R4 ;YES--GO ON TO NEXT
75520	;
75530	  XCT MATOP ;GET ELEMENT
75540	    JUMP 0(R4) ;INTO MATRIX
75550	  JSA T,INDNC. ;HANDLE END OF INPUT
75560	;
75570	  MOVE R0,F.TRM(FL) ;CHECK TERMINATOR
75580	  CAIE R0,ASCEOL ;CHECK FOR EOL
75590	    JRST MVI1 ;NO--GET NEXT ITEM
75600	  SOS MAXDM ;DECREMENT COUNT ANYWAY
75610	;
75620	 MVI2:
75630	  HLRZ R0,0(R3) ;GET MAX SIZE FOR MATRIX
75640	  SUB R0,MAXDM ;GET NEW SIZE
75650	  MOVEM R0,1(R3) ;SAVE AS DIMS
75660	  SUBI R0,1 ;GET MAX DIM
75670	  FSC R0,233 ;FLOAT IT
75680	  MOVEM R0,NUM.. ;SAVE IT
75690	  SETZM INAMP. ;CLEAR FLAG
75700	  JRST EXIT1. ;AND DONE
75710	;
75720	;
75730	PAGE
75740	SUBTTL END OF ASSEMBLY
75750	;
75760	;
75770	;
75780	PRGEND
75790	TITLE TRN. -- BASIC RUN TIME MAT ROUTINES--TRANSPOSE
75800	SUBTTL ASSEMBLY CONTROL
75810	SEARCH STENEX,BGBL,BRSYMS
75820	;
75830	;
75840	ENTER TRN.,TRNS.
75850	;
75860	;
75870	EXTERNAL SDLOC.,SET2.,CKDMS.,RSET2.,RSET1.,NEXT1.,EXIT2.,INCA1.
75880	EXTERNAL CKNEW.,NWMAT.,NWMTF.
75890	;
75900	;
75910	;
75920	PAGE
75930	SUBTTL TRN. -- ENTRYS TO THE TRANSPOSE MATRIX ROUTINE
75940	;
75950	;   TRN.--THIS ROUTINE TRANSPOSES A NUMERIC MATRIX
75960	;
75970	;   TRNS.--THIS ROUTINE TRANSPOSES A STRING MATRIX.
75980	;
75990	;
76000	TRN.: Z
76010	;
76020	  MOVE R1,[MOVEM R1,0(R4)]	;CODE TO SAVE ELEMENT
76030	  JRST MSNTRN
76040	;
76050	;
76060	TRNS.: Z
76070	;
76080	  MOVE R1,[JSP R0,TRNS1]	;CODE TO SAVE STRING ELEMENT
76090	  JRST MSNTRN
76100	;
76110	;
76120	 TRNS1:
76130	  SKIPE NWMTF.		;CHECK IF TO DUMMY MAT
76140	    JRST TRNS2		;HANDLE SPECIAL IF SO--DO NOTHING
76150	  JSA T,SDLOC.		;TO SAVE STRING ELEMENT, FIRST RELEASE OLD
76160	    JUMP 0(R4)
76170	  SKIPN R1		;CHECK FOR NULL
76180	    AOS -1(R1)		;BUMP UPDATE COUNT IF NOT
76190	;
76200	 TRNS2:
76210	  MOVEM R1,0(R4)	;THEN SAVE RESULT
76220	  JRST @R0		;THEN RETURN
76230	;
76240	;
76250	PAGE
76260	SUBTTL MAT TRANSPOSE MAIN ROUTINE--MSNTRN
76270	;
76280	;   MSNTRN--THIS ROUTINE DOES A MAT TRANSPOSE.  THE OPERATOR FOR SAVING
76290	;      A NEW ELEMENT FROM R1 IS IN R1 ONE ENTRY.  IF NECESSARY, THIS 
76300	;      ROUTINE WILL CREATE A TEMP MATRIX IN STRING STORAGE.
76310	;
76320	;
76330	MSNTRN:
76340	;
76350	  SETZM NWMTF.		;NO NEW MAT NEEDED
76360	  MOVEM R1,MATOP#	;SAVE OP
76370	  JSP R1,SET2.	;SET UP TWO MATS
76380	;
76390	  MOVE R2,R3		;PTR TO SECOND MAT
76400	  CAMN R3,R5		;CHECK IF SAME AS FIRST
76410	    JSA T,NWMAT.	;CREAT A NEW MATRIX
76420	  MOVE R3,R2		;RESTORE POINTER TO MATRIX
76430	;
76440	  MOVE R0,2(R5)		;GET FLIPPED DIMS
76450	  MOVE R1,1(R5)		;FOR NEW MAT
76460	  JSA T,CKDMS.		;SET DIMS FOR IT
76470	  JSP R1,RSET1.		;RESET ITS PTR
76480	;
76490	  MOVEM R6,LPPTR1#	;SAVE INITIAL MAT PTR
76500	  MOVE R1,2(R5)		;GET #COL
76510	  MOVEM R1,LPINC1#	;SAVE IT AS WELL
76520	;
76530	 MTRN1:
76540	  AOS R6,LPPTR1		;POINT TO A(1,N)
76550	;
76560	 MTRN2:
76570	  JSP R1,NEXT1.		;GET PTR TO CORRESPONDING ELEMENT IN ORIG MAT
76580	    JRST MTRN3		;HANDLE DONE
76590	  MOVE R1,0(R6)		;GET ITEM
76600	  XCT MATOP		;SAVE IT
76610	  MOVE R0,INCA1.	;CHECK IF AT ROW BOUNDARY
76620	  CAIN R0,1
76630	    JRST MTRN1		;JANDLE IF SO
76640	  ADD R6,LPINC1		;ELSE GET NEXT ELEMENT IN NEW MAT
76650	  JRST MTRN2		;AND LOOP
76660	;
76670	 MTRN3:
76680	  JSA T,CKNEW.		;RESTORE IF WE CREATED NEW MAT
76690	  JRST EXIT2.		;AND RETURN
76700	;
76710	;
76720	PAGE
76730	SUBTTL END OF ASSEMBLY
76740	;
76750	;
76760	;
76770	PRGEND
76780	TITLE MMUL. -- BASIC RUN TIME MATRIX ROUTINES--MAT MULTIPLY
76790	SUBTTL ASSEMBLY CONTROL
76800	SEARCH STENEX,BGBL,BRSYMS
76810	;
76820	;
76830	ENTER MMUL.
76840	;
76850	;
76860	EXTERNAL NWMAT.,CKNEW.,E.DIM,CKDMS.,E.MSBZ,EXIT3.,SET3.
76870	EXTERNAL MTRGS.,RSET1.,NEXT3.,NWMTF.
76880	;
76890	;
76900	;
76910	PAGE
76920	SUBTTL BASIC RUN TIME MAT ROUTINES--MMUL
76930	;
76940	;   MMUL--THIS ROUTINE MULTIPLYS TWO MATRICES TO GET A THIRD. IT
76950	;      USES A BRUTE FORCE METHOD.  IF COMPLICATIONS WILL ARISE
76960	;      BECAUSE OF MAT A=A*B THEN, A DUMMY MATRIX IS CREATED FOR
76970	;      RESULTS AND COPIED INTO THE FINAL MATRIX AT THE END.
76980	;
76990	;
77000	MMUL.: Z
77010	;
77020	  JSP R1,SET3.		;SET UP THREE MATS
77030	  SETZM NWMTF.		;NO NEW MAT NEEDED (YET)
77040	;
77050	  MOVE R2,R3		;ALSO TO R2
77060	  CAME R3,R5		;CHECK IF DUMMY MAT NEEDED
77070	  CAMN R3,R7
77080	    JSA T,NWMAT.	;IF SO, CREATE ONE
77090	  MOVE R3,R2		;RESTORE POINTER TO MAT
77100	;
77110	  SKIPGE R1,2(R5)	;CHECK IF FIRST IS VECTOR
77120	    MOVE R1,1(R5)	;IF SO, GET VECTOR SIZE
77130	  CAME R1,1(R7)		;CHECK FOR INSIDE DIMS MATCHING
77140	    ERR E.DIM		;IT BETTER
77150	  SOSG R1		;MINUS ONE FOR REAL DIMS
77160	    ERR E.MSBZ		;CAN'T BE ZERO
77170	  MOVEM R1,LPSIZ#	;SAVE LOOP SIZE (INSIDE DIM)
77180	;
77190	  SKIPGE 2(R5)		;CHECK FOR DOT PRODUCT
77200	  SKIPL 2(R7)		;OF TWO VECTORS
77210	    SKIPA
77220	    JRST MMUL1		;HANDLE SPECIAL IF SO
77230	;
77240	  MOVE R0,1(R5)		;ELSE GET DIMS FOR NEW MAT
77250	  MOVE R1,2(R7)
77260	  SKIPGE 2(R5)		;CHECK IF FIRST IS VECTOR
77270	    MOVNI R1,1		;IF SO, FORCE RESULT TO BE
77280	  MOVE R2,R3		;GET PTR TO NEW MAT
77290	  JSA T,CKDMS.		;REDIM IT
77300	  JSP R1,RSET1.		;RESTORE PTR TO IT
77310	  JSP R1,NEXT3.		;GET PTR TO X(1,1)
77320	    ERR E.MSBZ		;BETTER BE ONE TO GET
77330	;
77340	  MOVE R1,1(R3)		;GET DIMS OF NEW
77350	  MOVEM R1,LPINC1#	;SAVE FOR LOOP INC
77360	  MOVEM R1,LPINC2#
77370	  SKIPL R1,2(R3)	;CHECK IF VECTORE
77380	    MOVEM R1,LPINC2#	;IF NOT, SAVE SECOND INC
77390	  SKIPGE R1		;CHECK FOR VECTOR AGAIN
77400	    SETOM LPINC1#	;HANDLE IF SO
77410	  JRST MML10		;AND ENTER LOOP
77420	;
77430	 MMUL1:
77440	  SETOM LPINC1#		;HANDLE DOT PRODUCT
77450	  SETOM LPINC2#		;SET INCS SO WE EXIT FAST
77460	  MOVE R4,0(R3)	;GET PTR TO FIRST ELEMENT
77470	  HRRZ R4,1(R4)	;ITSELF
77480	;
77490	;   SET UP FOR MAIN MULTIPLY LOOP
77500	;
77510	 MML10:
77520	  MOVEM R10,LPPTR1#	;SAVE INITIAL PTR TO SECOND MAT
77530	  MOVEM R10,LPSPT1#
77540	  MOVEM R6,LPSPT2#	;AND PTR TO FIRST MAT
77550	  SKIPG R1,2(R7)	;CHECK FOR VECTOR--SET SECOND DIM SIZE
77560	    MOVEI R1,1		;SET FOR VECTOR--IS INCREMENT
77570	  MOVEM R1,LPINC3#	;TO GO DONW COLUMNS
77580	  SOS LPINC1		;GET REAL DIMS
77590	  SOS R1,LPINC2	;SECOND DIM
77600	  MOVEM R1,LPIN2A#	;SAVE IT
77610	;
77620	;
77630	;   MAIN LOOP
77640	;
77650	 MML20:
77660	  MOVE R2,LPSIZ
77670	  MOVEI R0,0		;SET UP FOR ADDING
77680	;
77690	 MML21:
77700	  MOVE R1,0(R6)		;GET ITEM OF FIRST
77710	  FMP R1,0(R10)		;TIEM ITEM OF SECOND
77720	  FAD R0,R1		;ACCUMULATE
77730	  ADDI R6,1		;NEXT IN ROW
77740	  ADD R10,LPINC3		;NEXT IN COL
77750	  SOJG R2,MML21		;LOOP IF MORE
77760	  MOVEM R0,0(R4)	;SAVE RESULT WHEN DONE
77770	;
77780	  SOSG LPIN2A		;CHECK IF DONE ROWS
77790	    JRST MML22		;HANDLE IF SO
77800	  MOVE R6,LPSPT2	;ELSE GET NEW COUNTER
77810	  AOS R10,LPPTR1		;NEXT COLUMN
77820	  AOJA R4,MML20	;AND REENTER LOOP
77830	;
77840	 MML22:
77850	  SOSG LPINC1		;CHECK IF DONE COLS
77860	    JRST MML30	;DONE BOTH--EXIT
77870	  ADDI R4,1		;NEXT ELEMENT
77880	  ADDI R6,1		;NEXT ITEM IN ROW
77890	  MOVEM R6,LPSPT2	;SAVE FOR START OF NEXT ROW
77900	  MOVE R10,LPSPT1	;TOP OF COL
77910	  MOVEM R10,LPPTR1	;SAVE THAT
77920	  MOVE R1,LPINC2	;GET SAVED COUNT
77930	  MOVEM R1,LPIN2A	;RESAVE
77940	  AOJA R4,MML20	;AND REEENTER LOOP
77950	;
77960	 MML30:
77970	  JSA T,CKNEW.		;ALL DONE--CHECK TO RECOPY DUMMY MAT
77980	  JRST EXIT3.		;RESTORE REGS AND RETURN
77990	;
78000	;
78010	PAGE
78020	SUBTTL END OF ASSEMBLY
78030	;
78040	;
78050	;
78060	PRGEND
78070	TITLE MINV. -- BASIC RUN TIME MATRIX ROUTINES--MAT INVERSE
78080	SUBTTL ASSEMBLY CONTROL
78090	SEARCH STENEX,BGBL,BRSYMS
78100	;
78110	;
78120	ENTER MINV.,DET.
78130	;
78140	;
78150	EXTERNAL SET2.,E.DIM,E.MSBZ,BLOC.,DLOC.,EXIT2.
78160	EXTERNAL CKDMS.,RSET1.
78170	;
78180	;
78190	;
78200	PAGE
78210	SUBTTL BASIC RUN TIME MAT ROUTINES--DET
78220	;
78230	;   DET--THIS FUNCTION RETURNS THE DETERMINATE OF THE LAST MATRIX
78240	;      INVERTED.
78250	;
78260	;
78270	FCT DET.,N,0
78280	;
78290	  MOVE R0,DET		;LOAD THE DETERMINATE
78300	  JRA T,0(T)		;AND RETURN
78310	;
78320	;
78330	PAGE
78340	SUBTTL BASIC RUN TIME MAT ROUTINES--MINV.
78350	;
78360	;   MINV.--THIS ROUTINE INVERTS A MATRIX.  IT IS DESIGNED TO INVERT IN
78370	;      PLACE, SO IF THE TWO MATRIXES PASSED AREN'T IDENTICAL, THE
78380	;      OLD ONE IS FIRST ASSIGNED TO THE OTHER.  ROW AND COLUMN ZERO ARE
78390	;      PRESERVED BY COPPING THEM TO STRING STORAGE AT THE START
78400	;      AND RESTORING THEM AT THE END.  THE BASIC ROUTINE IS TAKEN FROM
78410	;      DARTMOUTH BASIC VI, WHICH IN TURN WAS TAKEN FROM BASIC V.
78420	;
78430	;
78440	MINV.: Z
78450	;
78460	  JSP R1,SET2.		;GET TWO MATS
78470	  MOVE R1,1(R3)		;GET DIMS OF FIRST
78480	  CAME R1,2(R3)		;MUST BE SQUARE
78490	    ERR E.DIM		;OR ELSE ERROR
78500	  SKIPN R1		;CAN'T BE ZERO EITHER
78510	    ERR E.MSBZ		;OR ELSE ERROR
78520	;
78530	;   SAVE ROW/COL 0
78540	;
78550	  MOVE R0,1(R5)
78560	  LSH R0,1		;LENGTH TIMES TWO
78570	  ADDI R0,2		;PLUS TWO
78580	  JSA T,BLOC.		;GET STRING BLOCK
78590	  MOVEM R1,IVTM1#	;SAVE PTR
78600	  HRLI R1,444400	;MAKE WORD TALLY OF PTR
78610	  HRRZ R2,0(R3)		;GET PTR TO MAT
78620	  HRLI R2,444400	;MAKE WORD TALLY OF IT AS WELL
78630	  MOVE R0,1(R5)		;NUMBER OF ROWS
78640	;
78650	 IMV1:
78660	  ILDB R6,R2		;GET NEXT ITEM
78670	  SETZM 0(R2)		;INITIALIZE
78680	  IDPB R6,R1		;SAVE ITEM FOR LATER RESTORATION
78690	  SOJG R0,IMV1		;LOOP UNTIL DONE ROW
78700	;
78710	  MOVE R0,1(R5)		;COUNTER FOR COL
78720	  HRRZ R2,0(R3)		;PTR TO COL
78730	;
78740	 IMV2:
78750	  MOVE R6,0(R2)		;GET NEXT ITEM
78760	  SETZM 0(R2)		;CLEAR
78770	  IDPB R6,R1		;SAVE IN BLOCK
78780	  ADD R2,1(R3)		;NEXT ITEM IN COL
78790	  SOJG R0,IMV2		;LOOP UNTIL DONE
78800	;
78810	  CAMN R3,R5		;CHECK FOR SAME MAT
78820	    JRST INVI		;IF SO, JUMP
78830	  MOVE R0,1(R5)		;ELSE MUST DO QUICKY ASSIGNMENT
78840	  MOVE R1,2(R5)		;GET NEW DIMS
78850	  MOVE R2,R3
78860	  JSA T,CKDMS.		;AND SET
78870	  HRL R1,0(R5)		;FROM OLD MAT
78880	  HRR R1,0(R3)		;TO NEW ONE
78890	  HLRZ R2,0(R3)		;PTR TO NEW
78900	  ADD R2,0(R3)		;PLUS LENGTH MAKES END PTR
78910	  BLT R1,-1(R2)		;FILL QUICKLY
78920	;
78930	 INVI:
78940	  MOVSI R0,(1.0)	;INITIALIZE-
78950	  MOVEM R0,INDET#	;DETERMINATE FIRST
78960	  JSP R1,RSET1.		;NOW GET PTR TO NEW MAT
78970	  MOVEM R4,AADR#	;AND SAVE
78980	  AOS AADR		;PLUS ONE
78990	;
79000	;
79010	;   NOW BEGIN INVERSION
79020	;
79030	INVB:
79040	  MOVE R1,1(R3)		;COUNTER
79050	  SUBI R1,1		;MINUS ONE FOR ACTUAL SIZE
79060	  MOVEM R1,MTSIZ#	;SAVE SIZE
79070	  MOVNM R1,ICNT#
79080	;
79090	;   FIND PIVOT
79100	;
79110	 INVF:
79120	  SETZM IRCNT#		;INITIALLY ACTUAL ROW COUNTER
79130	  SETZM IPVT#		;INITIAL PIVOT TO 0
79140	  SETZM IPVABS		;ALSO ZERO ITS ABS VALUE
79150	  MOVE R4,AADR	;PTR TO NEAR FIRST ELEMENT
79160	  MOVE R1,MTSIZ		;DIMS
79170	  MOVEM R1,COLCT#	;SAVE FOR COUNTERS
79180	  MOVEM R1,ROWCT#
79190	  HRRZ R2,0(R3)		;R2--> A(I,0)
79200	  MOVEI R1,1(R2)	;R1-->A(0,J)
79210	  MOVEM R1,BADR#
79220	  ADD R2,1(R3)		;GET A(1,0) ADDRESS
79230	;
79240	 IVFL1:
79250	  SKIPE 0(R2)		;HAS THIS ROW BEEN USED YET?
79260	    JRST IVFX1		;YES--SKIP IT
79270	  SETZM ICCNT#		;RESET ACTUAL COLUMN COUNTER
79280	  AOS IRCNT		;BUMP ACTUAL ROW COUNTER
79290	;
79300	 IVFL2:
79310	  SKIPE 0(R1)		;CHECK FOR COLUMN USED
79320	    JRST IVFX2		;USED--SKIP IT
79330	  AOS ICCNT		;BUMP ACTUAL COLUMN COUNTER
79340	  MOVE R5,0(R4)	;PICK UP AN ELEMENT AND TEST IT
79350	  MOVM R6,R5
79360	  CAMG R6,IPVABS		;DONT REPLACE IF NEW ELEMENT IS <= OLD ONE
79370	    JRST IVFX2
79380	  MOVEM R5,IPVT	;SAVE NEW PIVOT
79390	  MOVMM R5,IPVABS#	;SAVE ABS VALUE FOR COMPARE
79400	  MOVEM R4,IPVADD#	;AND ITS ADDRESS
79410	  MOVE R0,ROWCT		;AND ANYTHING ELSE WE CAN THINK OF
79420	  MOVEM R0,IPVRCT#
79430	  MOVEM R1,IPVRPT#
79440	  MOVE R0,COLCT
79450	  MOVEM R0,IPVCCT#
79460	  MOVEM R2,IPVCPT#
79470	  MOVE R0,IRCNT
79480	  MOVEM R0,IPVIRC#
79490	  MOVE R0,ICCNT
79500	  MOVEM R0,IPVICC#
79510	;
79520	 IVFX2:
79530	  ADDI R4,1		;INCREMENT PTRS
79540	  ADDI R1,1
79550	  SOSE COLCT		;CHECK FOR ROW SCAN COMPLETE
79560	    JRST IVFL2
79570	  SKIPA
79580	;
79590	 IVFX1:
79600	  ADD R4,MTSIZ	;SKIP OVER ROW ALREADY REPRESENTED
79610	  ADDI R4,1		;SKIP ZERO COLUMN ENTRY
79620	  ADD R2,1(R3)		;INC A(I,0) PTR
79630	  MOVE R1,BADR		;RESET A(0,J) PTR
79640	  MOVE R0,MTSIZ		;RESET COLUMN COUNT
79650	  MOVEM R0,COLCT
79660	  SOSE ROWCT		;CHECK FOR SCAN COMPLETE
79670	    JRST IVFL1
79680	  SKIPE IPVT		;CHECK FOR SINGULAR MATRIX
79690	    JRST .+3
79700	  SETZM DET		;SET DET=0.0
79710	  JRST INVR3	;AND EXIT
79720	  MOVE R4,IPVADD	;GET INFO BACK ON PIVOT
79730	  MOVE R1,IPVRPT
79740	  MOVE R2,IPVCPT
79750	  HRRM R1,0(R2)		;RECORD USE OF ROW
79760	  HRLM R2,0(R1)		;AND COLUMN
79770	  MOVE R0,INDET		;COMPUTE DETERMINATE
79780	  FMP R0,0(R4)		;AS THE PRODUCT OF THE PIVOT ELEMENTS
79790	  MOVE R5,IPVIRC	;WITH CHANGE OF SIGN IF ROW PARITY
79800	  XOR R5,IPVICC		;DOES NOT EQUAL COLUMN PARITY
79810	  TRNE R5,1
79820	  MOVNS R0
79830	  MOVEM R0,INDET
79840	;
79850	;   BEGIN EX-STEP
79860	;
79870	;      FIRST INVERT PIVOT ELEMENT
79880	;
79890	  MOVSI R0,(1.0)
79900	  FDVRM R0,0(R4)
79910	;
79920	;      NOW GO DOWN COLUMN
79930	;
79940	  MOVE R0,MTSIZ		;GET COUNT
79950	  MOVN R5,0(R4)		;GET MULTIPLIER
79960	;
79970	 IVEL1:
79980	  ADD R1,1(R3)		;INC PTR
79990	  CAME R0,IPVRCT		;SKIP PIVOT ELEMENT
80000	  FMPM R5,0(R1)		;COMPUTE NEW ELEMENT
80010	  SOJG R0,IVEL1		;CHECK FOR COLUMN DONE
80020	;
80030	;      NOW DO ELEMENTS NOT IN PIVOT ROW OR COLUMN
80040	;
80050	  MOVE R0,MTSIZ		;RESTORE COLUMN COUNTER
80060	  MOVEM R0,COLCT
80070	  MOVE R4,AADR		;R4-->ELEMENT BEING CHANGED
80080	  MOVE R1,IPVRPT	;R1-->PIVOT COLUMN ELEMENT
80090	;
80100	 IVEL2:
80110	  ADD R1,1(R3)		;BUMP PTR
80120	  MOVE R0,IPVRCT
80130	  CAMN R0,COLCT		;SKIP PIVOT ROW
80140	    JRST IVEX2
80150	  MOVE R2,IPVCPT	;R2-->PIVOT ROW ELEMENT
80160	  MOVE R5,MTSIZ		;R5 HAS COL COUNT
80170	;
80180	 IVEL3:
80190	  ADDI R2,1		;INC PTR
80200	  CAMN R5,IPVCCT		;SKIP ELEMENT IN PIVOT COLUNN
80210	    JRST IVEX3
80220	  MOVE R6,0(R1)		;COMPUTE NEW ELEMENT
80230	  FMP R6,0(R2)
80240	  FADM R6,0(R4)		;AND STORE IT
80250	;
80260	 IVEX3:
80270	  ADDI R4,1		;INC PTR
80280	  SOJG R5,IVEL3		;CHECK FOR ROW DONE
80290	  SKIPA
80300	;
80310	 IVEX2:
80320	  ADD R4,MTSIZ		;SKIP PAST PIVOT ROW
80330	  ADDI R4,1		;SKIP PAST 0 COLUMN ENTRY
80340	  SOSE COLCT		;CHECK FOR THIS PIVOT DONE
80350	    JRST IVEL2
80360	;
80370	;      FINALLY GO ACCROSS PIVOT ROW
80380	;
80390	  MOVE R4,IPVADD	;R4-->PIVOT ELEMNT
80400	  MOVE R1,IPVCPT	;R1-->ELEMENT BEING CHANGED
80410	  MOVE R0,MTSIZ		;R0 HAS COUNT
80420	  MOVE R6,0(R4)
80430	;
80440	 IVEL4:
80450	  ADDI R1,1		;INC POINTER
80460	  CAME R0,IPVCCT		;SKIP PIVOT ELEMENT
80470	    FMPM R6,0(R1)	;COMPUTE NEW ELEMENT
80480	;
80490	 IVEX4:
80500	  SOJG R0,IVEL4		;CHECK FOR ROW DONE
80510	  AOSE ICNT		;HAVE WE DONE ENOUGH PIVOTS?
80520	    JRST INVF		;NO--REPEAT THE WHOLE (EXPLETIVE DELETED) MESS
80530	;
80540	;
80550	;   NOW UNSCRAMBLE THIS MESS
80560	;
80570	;      FIRST WE UNSHUFFLE THE COLUMNS
80580	;
80590	  MOVE R0,MTSIZ
80600	  MOVEM R0,COLCT	;RESTORE COLUMN COUNT
80610	  MOVE R1,BADR		;GET A(0,1) ADDR
80620	  SUBI R1,1		;GET A(0,0) ADDR
80630	;
80640	 IVCL1:
80650	  SOSN COLCT		;CHECK FOR COLS DONE
80660	    JRST IVCX1
80670	  ADDI R1,1		;INC LOWER ADDR
80680	  MOVE R4,COLCT		;R4 HAS MINOR COUNT
80690	  ADDI R4,1		
80700	  MOVEI R2,0(R1)		;R2 HAS UPPER ADDR
80710	;
80720	 IVCL2:
80730	  SOJE R4,IVCL1		;CHECK FOR COMPARING THE COL WITH ALL OTHERS
80740	  ADDI R2,1		;INC UPPER ADDR PTR
80750	  MOVE R0,0(R1)		;COMPARE HDRS
80760	  CAMGE R0,0(R2)
80770	    JRST IVCL2		;IN RIGHT ORDER--NO SWAP NEEDED
80780	  MOVEM R1,AADR		;R1,R2 HAVE SWAP ADDRS
80790	  MOVEM R2,CADR#
80800	  MOVE R0,1(R3)		;R0 HAS SUPRA COUNT
80810	;
80820	 IVCL3:
80830	  MOVE R5,0(R1)
80840	  EXCH R5,0(R2)
80850	  MOVEM R5,0(R1)
80860	  ADD R1,1(R3)		;INC PTRS
80870	  ADD R2,1(R3)
80880	  SOJG R0,IVCL3		;CHECK FOR SWAP COMPLETE
80890	  MOVE R1,AADR		;RESTORE PTRS
80900	  MOVE R2,CADR
80910	  JRST IVCL2		;AND LOOP
80920	;
80930	 IVCX1:
80940	  MOVE R0,MTSIZ		;RESTORE COL CNTR
80950	  MOVEM R0,COLCT
80960	  MOVE R1,BADR		;GET A(0,1) ADDR
80970	  SUBI R1,1
80980	;
80990	 IVRL1:
81000	  SOSN COLCT		;CHECK FOR ROW UNSHUFFLED
81010	    JRST INVR4		;DONE--EXIT
81020	;
81030	 INVR5:
81040	  ADD R1,1(R3)		;INC LOWER ADDR
81050	  MOVE R4,COLCT		;GET MINOR COUNT IN R4
81060	  ADDI R4,1
81070	  MOVEI R2,0(R1)	;R2 HAS UPPER ADDR
81080	;
81090	 IVRL2:
81100	  SOJE R4,IVRL1		;CHECK IF DONE COMPARING THIS ROW TO ALL OTHERS
81110	  ADD R2,1(R3)		;INC UPPER ADDR PTR
81120	  MOVE R0,0(R1)		;COMPARE HDRS
81130	  CAMGE R0,0(R2)
81140	    JRST IVRL2		;IN RIGHT ORDER--NO SWAP
81150	  MOVEM R1,AADR		;SAVE PTRS
81160	  MOVEM R2,CADR#	;WHICH NOW HAVE SWAP ADDRESSES
81170	  MOVE R0,1(R3)
81180	;
81190	 IVRL3:
81200	  MOVE R5,0(R1)		;DO SWAP
81210	  EXCH R5,0(R2)
81220	  MOVEM R5,0(R1)
81230	  ADDI R1,1		;INC PTRS
81240	  ADDI R2,1
81250	  SOJG R0,IVRL3		;CHECK FOR SWAP COMPLETE
81260	  MOVE R1,AADR		;RESTORE PTRS
81270	  MOVE R2,CADR
81280	  JRST IVRL2		;AND CHECK SOME MORE
81290	;
81300	 INVR4:
81310	  MOVE R0,INDET		;DONE--GET DETERMINATE
81320	  MOVEM R0,DET#		;AND SAVE IT
81330	;
81340	;
81350	;   NOW RESTORE ROW AND COLUMN ZERO
81360	;
81370	 INVR3:
81380	  MOVE R1,IVTM1		;POINT TO BLOCK
81390	  HRLI R1,444400	;CREATE TALLY
81400	  HRRZ R2,0(R3)		;PT TO MAT
81410	  MOVE R0,1(R3)		;GET CNTR
81420	;
81430	 IMV10:
81440	  ILDB R5,R1		;COLUMN 0 RESTORATION
81450	  MOVEM R5,0(R2)
81460	  ADDI R2,1
81470	  SOJG R0,IMV10
81480	  MOVE R0,1(R3)		;RESTORE CNTR
81490	  HRRZ R2,0(R3)		;AND MAT PTR
81500	;
81510	 IMV11:
81520	  ILDB R5,R1		;RESTORE ROW 0
81530	  MOVEM R5,0(R2)
81540	  ADD R2,1(R3)		;BUMP PTR
81550	  SOJG R0,IMV11		;SKIP BACK IF MORE
81560	;
81570	  MOVE R0,IVTM1		;GET BLK PTR
81580	  JSA T,DLOC.		;GET RID OF IT
81590	  SETZM IVTM1		;GET RID OF PTR TO IT
81600	;
81610	  JRST EXIT2.		;AND DONE
81620	;
81630	;
81640	PAGE
81650	SUBTTL END OF ASSEMBLY
81660	;
81670	;
81680	;
81690	PRGEND
81700	TITLE RDM1. -- BASIC RUN TIME MAT ROUTINES--REDIM 1D
81710	SUBTTL ASSEMBLY CONTROL
81720	SEARCH STENEX,BGBL,BRSYMS
81730	;
81740	;
81750	ENTER RDM1.
81760	;
81770	;
81780	EXTERNAL E.DIM,CKDMS.
81790	;
81800	;
81810	PAGE
81820	SUBTTL REDIMENSIONING MATRICES--RDM1 (1D)
81830	;
81840	;   RDM1.--THIS ROUTINE IS CALLED FROM THE OBJECT CODE
81850	;      WITH THE NEW DIM AS THE ARG.  IT SHOULD CHECK
81860	;      THE PARAMETERS AND REDIMENSION THE GIVEN MATRIX.
81870	;
81880	;
81890	RDM1.: Z
81900	;
81910	  XFIX R0,@0(T) ;GET NEW DIM
81920	  SKIPGE R0 ;CHECK IF VALID
81930	    ERR E.DIM ;ERROR IF NOT
81940	  AOS R0 ;PLUS ONE
81950	  MOVNI R1,1 ;INDICATE 1D
81960	  MOVEI R2,@1(T) ;GET MAT PTR FROM CALL
81970	  JSA T,CKDMS. ;CHECK DIMS
81980	  JRA T,2(T) ;AND DONE
81990	;
82000	;
82010	PAGE
82020	SUBTTL END OF ASSEMBLY
82030	;
82040	;
82050	;
82060	PRGEND
82070	TITLE RDM2. -- BASIC RUN TIME MAT ROUTINES--REDIM 2D
82080	SUBTTL ASSEMBLY CONTROL
82090	SEARCH STENEX,BGBL,BRSYMS
82100	;
82110	;
82120	ENTER RDM2.
82130	;
82140	;
82150	EXTERNAL E.DIM,CKDMS.
82160	;
82170	;
82180	PAGE
82190	SUBTTL REDIMENSIONING MATRICES--RDM2 (2D)
82200	;
82210	;   RDM2--THIS ROUTINE IS CALLED FROM THE OBJECT CODE TO
82220	;      REDIMENSION A 2D MATRIX.  THE ARGS ARE THE NEW DIMS
82230	;      FOLLOWED BY THE MAT PTR.
82240	;
82250	;
82260	RDM2.: Z
82270	;
82280	  XFIX R0,@0(T) ;GET FIRST DIM
82290	  SKIPGE R0 ;CHECK IT
82300	    ERR E.DIM ;FOR LEGAL
82310	  AOS R0 ;AND ADD ONE
82320	;
82330	  XFIX R1,@1(T) ;GET SECOND DIM
82340	  SKIPGE R1 ;CHECK IT
82350	    ERR E.DIM ;FOR LEGAL
82360	  AOS R1 ;AND ADD ONE
82370	;
82380	  MOVEI R2,@2(T) ;GET MAT PTR
82390	  JSA T,CKDMS. ;CHECK DIMS
82400	  JRA T,3(T) ;THEN DONE
82410	;
82420	;
82430	PAGE
82440	SUBTTL END OF ASSEMBLY
82450	;
82460	;
82470	;
82480	PRGEND
82490	TITLE NWMAT. -- BASIC RUN TIME MAT ROUTINES--DUMMY MATS
82500	SUBTTL ASSEMBLY CONTROL
82510	SEARCH STENEX,BGBL,BRSYMS
82520	;
82530	;
82540	ENTER NWMAT.,CKNEW.
82550	;
82560	;
82570	EXTERNAL BLOC.,DLOC.,MASS.,SMASS.
82580	;
82590	;
82600	INTER NWMTF.
82610	;
82620	;
82630	PAGE
82640	SUBTTL BASIC RUN TIME MATRIX ROUTINES--NWMAT.
82650	;
82660	;   NWMAT--THIS ROUTINE CREATS A DUMMY (TEMP) MATRIX IN STRING
82670	;      STORAGE AND COPIES THE CONTENTS OF THE OLD MAT PTD TO BY
82680	;      R2 INTO IT.  IT THEN CHANGES THE PTR OF THE OLD MAT TO BE
82690	;      THE TEMP MAT.  ITS EFFECTS ARE UNDONE BY CKNEW.
82700	;
82710	;
82720	NWMAT.: Z
82730	;
82740	  HRRZM R2,NWMTF.#	;SAVE MAT PTR
82750	;
82760	  HLRZ R0,0(R2)		;SIZE TO R0
82770	  ADDI R0,3		;PLUS 3 FOR MAT HEADER
82780	  JSA T,BLOC.		;PTR TO TEMP BLOCK TO R1
82790	  MOVEM R1,NWMTPT	;SAVE IT
82800	;
82810	  HRRZ R2,R1		;DUPLICATE POINTER
82820	  HRL R1,NWMTF.		;GET BLT PTR FOR BLOCK
82830	  BLT R1,2(R2)		;MOVE MAT BLOCK TO NEW BLOCK
82840	;
82850	  MOVEI R1,3(R2)	;POINTER TO DATA AREA OF NEW BLOCK
82860	  HRRM R1,0(R2)		;SAVE IN MAT BLOCK
82870	;
82880	  MOVE R2,NWMTPT	;END WITH PTR TO NEW MAT IN R2
82890	  JRA T,0(T)		;THEN DONE
82900	;
82910	;
82920	PAGE
82930	SUBTTL BASIC RUN TIME MATRIX ROUTINES--CKNEW.
82940	;
82950	;   CKNEW--THIS ROUTINE CHECKS TO SEE IF A TEMP (DUMMY) MATRIX WAS
82960	;      CREATED BY NWMAT AND IF SO, IT GETS RID OF IT AFTER SETTING
82970	;      THE CONTENTS OF THE ORIGINAL MAT TO BE THOSE OF THE NEW ONE.
82980	;
82990	;
83000	CKNEW.: Z
83010	;
83020	  SKIPN NWMTF.	;CHECK IF WE COPIED MATRIX
83030	    JRA T,0(T)		;IF NOT, RETURN NOW
83040	  JSA T,MASS.		;DO SIMPLE ASSIGNMENT (EVEN FOR STRINGS)
83050	;
83060	NWMTF.:	BLOCK 1		;NEW MAT BLOCK PTR
83070	NWMTPT:	BLOCK 1		;NEW MAT PTR
83080	;
83090	;
83100	  MOVE R0,NWMTPT	;GET BLOCK PTR
83110	  JSA T,DLOC.		;GET RID OF BLOCK
83120	  SETZM NWMTF.		;AND PTRS TO IT
83130	  SETZM NWMTPT		;AND FLAGS
83140	;
83150	  JRA T,0(T)		;THEN DONE
83160	;
83170	;
83180	PAGE
83190	SUBTTL END OF ASSEMBLY
83200	;
83210	;
83220	;
83230	PRGEND
83240	TITLE MAT. -- BASIC RUN TIME MAT ROUTINES--COMMON RTNS
83250	SUBTTL ASSEMBLY CONTROL
83260	SEARCH STENEX,BGBL,BRSYMS
83270	;
83280	;
83290	ENTER SET3.,SET2.,SET1.,NEXT3.,NEXT2.,NEXT1.,EXIT3.,EXIT2.,EXIT1.
83300	ENTER CKDMS.,RSET1.,RSET2.
83310	;
83320	;
83330	INTER INCA1.,INCA2.,INCA3.,INCB1.,INCB2.,INCB3.,E.DIM
83340	INTER MTRGS.,E.MSBZ
83350	;
83360	;
83370	;
83380	;
83390	PAGE
83400	SUBTTL MAT PACKAGE COMMON ROUTINES--SET UP RTNS
83410	;
83420	;   SETN.--THIS ROUTINES SET UP THE REGISTERS AND COUNTERS
83430	;      FOR N MATRICES.  THEY GET THE MAT PTRS FROM THE CALL
83440	;      SEQUENCE (OFF T).
83450	;
83460	;   THEY ARE ALL ENTERED WITH A JSP R1,<RTN>.
83470	;
83480	;
83490	DEFINE SETN (N,RA,RB) ;DEFINE CODE BLOCK FOR EACH
83500	<
83510	    SET'N'.:
83520		MOVEM RB,MTRGS.+RB ;SAVE REGS
83530		MOVEM RA,MTRGS.+RA
83540		MOVEI RA,@N-1(T) ;GET MAT PTR
83550		HRRZ RB,0(RA) ;PTR TO MAT(0,0)
83560		SKIPL 2(RA) ;CHECK FOR 1D (VECTOR)
83570		ADD RB,2(RA) ;IGNORE ROW 0 IF MATRIX
83580		MOVE R0,2(RA) ;GET FIRST DIM
83590		JUMPGE R0,SET'N'M ;JUMP FOR MATS
83600		MOVEM R0,INCB'N'.# ;SAVE -1 FOR VECTORS
83610		MOVE R0,1(RA) ;GET DIM FOR VECTOR
83620		MOVEM R0,INCA'N'.# ;SAVE
83630		JRST SET'N'A ;AND SKIP
83640	 SET'N'M:	MOVEM R0,INCA'N'.# ;SAVE
83650		CAIN R0,1 ;CAN'T BE ZERO
83660		ERR E.MSBZ ;ERROR IF IS
83670		MOVE R0,1(RA) ;GET SECOND DIM
83680		MOVEM R0,INCB'N'.# ;SAVE
83690		SOS INCB'N'. ;MINUS ONE
83700	 SET'N'A:	CAIN R0,1 ;CAN'T BE ZERO
83710		ERR E.MSBZ ;ELSE ERROR
83720	>
83730	;
83740	;
83750	;
83760	SETN (3,R7,R10) ;FOR 3 MATS
83770	;
83780	;
83790	SETN (2,R5,R6) ;FOR 2 MATS
83800	;
83810	;
83820	SETN (1,R3,R4) ;FOR 1 MAT
83830	;
83840	;
83850	  JRST 0(R1) ;AND RETURN
83860	;
83870	;
83880	PAGE
83890	SUBTTL MAT PACKAGE COMMON ROUTINES--RESETUP ROUTINES
83900	;
83910	;   RSETN--THESE ROUTINES ARE USED TO RESET THE POINTER
83920	;      REGISTERS AND COUNTS FOR ONE SPECIFIC MATRIX AFTER
83930	;      IT HAS BEEN CHANGED BY REDIMENSIONING.
83940	;
83950	;
83960	DEFINE RSETN (N,RA,RB) ;CODE BLOCKS MACRO
83970	<
83980	    RSET'N'.:
83990		HRRZ RB,0(RA) ;GET INIT PTR TO MAT(0,0)
84000		SKIPL 2(RA) ;CHECK FOR VECTOR
84010	 	ADD RB,2(RA) ;MATRIX--SKIP ROW 0
84020		MOVE R0,2(RA) ;GET FIRST DIM
84030		JUMPGE R0,RST'N'M ;HANDLE MATS
84040		MOVE R0,1(RA) ;GET VECTOR DIMS
84050		MOVEM R0,INCA'N'.# ;SAVE
84060		JRST RST'N'A ;AND SKIP
84070	 RST'N'M:	MOVEM R0,INCA'N'.# ;SAVE
84080		CAIN R0,1 ;CHECK IF GTR 0
84090		  ERR E.MSBZ ;ERROR IF NOT
84100		MOVE R0,1(RA) ;CHECK SECOND DIM
84110		MOVEM R0,INCB'N'.# ;SAVE
84120		SOS INCB'N'. ;MINUS ONE
84130	 RST'N'A:	CAIN R0,1 ;CHECK IF GTR 0
84140		  ERR E.MSBZ ;ERROR IF NOT
84150		JRST 0(R1) ;OK--RETURN
84160	>
84170	;
84180	;
84190	RSETN (1,R3,R4) ;RESETUP THIRD MATRIX
84200	;
84210	;
84220	RSETN (2,R5,R6) ;RESETUP SECOND MATRIX
84230	;
84240	;
84250	PAGE
84260	SUBTTL MAT PACKAGE COMMON ROUTINES--NEXT ELEMENT
84270	;
84280	;   NEXTN.--THESE ROUTINES ADD TO THE ELEMENT POINTER
84290	;      OF MATRIX N TO POINT TO THE NEXT SIGNIFICANT (NON-ZERO
84300	;      ROW/COL) ELEMENT. THEY ARE CALLED WITH A JSP R1,<RTN>,
84310	;      AND RETURN TO 0(R1) ON END OF MAT, AND TO 1(R1) IF
84320	;      MORE MAT REMAINS.
84330	;
84340	;
84350	;   FIRST DEFINE A MACRO TO DEFINE THE ROUTINES
84360	;
84370	DEFINE NEXTN (N,RA,RB,EX)
84380	<
84390	    NEXT'N'.:
84400		AOS RB ;NEXT ELEMENT
84410		SOSE INCA'N'. ;DONE ROW
84420		  JRST EX ;NO--RETURN
84430		MOVE R0,2(RA) ;YES--RESTORE COUNTER A
84440		MOVEM R0,INCA'N'.
84450		SOSLE INCB'N'. ;CHECK IF DONE MAT
84460		  JRST NEXT'N'. ;AND IGNORE ZERO ITEM
84470		JRST 0(R1) ;YES--RETURN END
84480	>
84490	;
84500	;
84510	;
84520	NEXTN (3,R7,R10,NEXT2.) ;THIRD MATRIX
84530	;
84540	;
84550	NEXTN (2,R5,R6,NEXT1.) ;SECOND MATRIX
84560	;
84570	;
84580	NEXTN (1,R3,R4,1(R1)) ;FIRST MATRIX
84590	;
84600	;
84610	;
84620	PAGE
84630	SUBTTL MAT PACKAGE COMMON ROUTINES--EXIT
84640	;
84650	;   EXITN.--THESE ROUTINES EXIT ASSUMING THAT THE CORRESPONDING
84660	;      SETN WAS CALLED EARLIER.  THIS ROUTINE RESTORES ALL
84670	;      REGISTERS AND RETURNS PAST THE END OF THE MATRICES.
84680	;
84690	;
84700	EXIT3.: 
84710	  MOVE R10,MTRGS.+10 ;RESTORE R10,R7 FOR 3 MATS
84720	  MOVE R7,MTRGS.+7
84730	  AOS T ;BUMP RETURN ONCE
84740	;
84750	;
84760	EXIT2.:
84770	  MOVE R6,MTRGS.+6 ;RESTORE R6,R5 FOR 2 MATS
84780	  MOVE R5,MTRGS.+5
84790	  AOS T ;BUMP RETURN ONCE
84800	;
84810	;
84820	EXIT1.:
84830	  MOVE R4,MTRGS.+4 ;RESTORE R3,R4 FOR 1 MAT
84840	  MOVE R3,MTRGS.+3
84850	  JRA T,1(T) ;AND RETURN OVER CALL
84860	;
84870	;
84880	PAGE
84890	SUBTTL MAT PACKAGE COMMON ROUTINES--CHECK DIMS
84900	;
84910	;   CKDMS--THIS ROUTINE IS CALLED WITH A MAT POINTER IN R2
84920	;      AND NEW DIMS FOR THAT MAT IN R0 AND R1.  ITS JOB IS TO
84930	;      SAVE THOSE NEW DIMS WITH THE MAT AND TO CHECK THE
84940	;      LEGALITY OF THOSE DIMS.
84950	;
84960	;
84970	CKDMS.: Z
84980	;
84990	  JUMPGE R1,CK2D ;HANDLE 2D CHECKS
85000	;
85010	 CK1D:
85020	  MOVEM R0,1(R2) ;SAVE NEW 1ST DIM
85030	  HLRZ R1,0(R2) ;GET MAX ALLOWED FOR MAT
85040	  CAMLE R0,R1 ;CHECK IF OK WITH NEW ONE
85050	    ERR E.DIM ;ERROR IF NOT
85060	  JRA T,0(T) ;RETURN IF OK
85070	;
85080	 CK2D:
85090	  MOVEM R0,1(R2) ;SAVE NEW 1ST DIM
85100	  MOVEM R1,2(R2) ;AND SECOND DIM
85110	  IMUL R0,R1 ;GET TOTAL SPACE NEEDED
85120	  HLRZ R1,0(R2) ;GET SPACE AVAILABLE
85130	  CAMLE R0,R1 ;WILL NEW DIMS FIT
85140	    ERR E.DIM ;ERROR IF NOT
85150	  JRA T,0(T) ;RETURN IF OK
85160	;
85170	;
85180	PAGE
85190	SUBTTL MAT PACKAGE COMMON ROUTINES--STORAGE, ERRORS
85200	;
85210	;
85220	;
85230	MTRGS.: BLOCK 20 ;BLOCK FOR REG STORAGE
85240	;
85250	;
85260	E.DIM: ER NRM,Dimension error
85270	;
85280	;
85290	E.MSBZ: ER NRM,Subscript zero for matrix routine
85300	;
85310	;
85320	;
85330	PAGE
85340	SUBTTL END OF ASSEMBLY
85350	;
85360	;
85370	;
85380	PRGEND
85390	TITLE BRLOAD -- RUN TIME LOADER
85400	SUBTTL ASSEMBLY CONTROL
85410	SEARCH BRSYMS,BGBL,STENEX
85420	;
85430	;
85440	;
85450	LOC 2000
85460	;
85470	;
85480	PAGE
85490	SUBTTL BRLOAD--SET UP RTP
85500	;
85510	;   BRLOAD--THIS ROUTINE TAKES THE LOADED VERSION OF THE RTP, WITH
85520	;      THE CODE STARTING IN 400000 BUT LOADED FOR 600000 AMD THE
85530	;      TRANSFER VECTOR IN 1000-1777 AND ABSOLUTE, AND MOVES
85540	;      THE CODE TO 600000 AND THE TRANSFER VECTOR TO THE PROPER
85550	;      COMMUNICATIONS AREA PAGE.
85560	;
85570	;   IT THEM DOES AN SSAVE OF BOTH SETS INTO THE FILE 'BRTP.SAV' IN
85580	;      THE CURRENT DIRECTORY.
85590	;
85600	;
85610	;
85620	;   THE RTP SHOULD BE LOADED TO ORG THE HIGH SEMENT IN 600000
85630	;      AND SO ALL RELOCATABLE CODE GOES THERE.  ALSO, THE SYMBOL
85640	;      TABLE SHOULD BE IN HIGH SEGMENT.
85650	;
85660	;   THIS CAN BE ACCOMPLISHED WITH :
85670	;
85680	;
85690	;	@LOADER
85700	;	*/S/1B/1H/600000H BRTP,BDBG$
85710	;	@START
85720	;
85730	;
85740	;  OR
85750	;
85760	;	@LINK10
85770	;	*/SYMSEG:HIGH,/SEGMENT:HIGH,/SET:.HIGH.:600000,BRTP,BGBL/G
85780	;	@START
85790	;
85800	;
85810	;
85820	;   THIS CODES SITS IN ABSOLUTE ADDRESS 2000.
85830	;
85840	;
85850	BRLOAD:
85860	;
85870	  IFN LIBRARY,<HALTF>		;DON'T EXECUTE IF LIBRARY MODE
85880	;
85890	  CIS		;DISABLE INTERRUPTS
85900	  MOVEI R1,400000
85910	  DIR
85920	;
85930	  MOVEI R1,400000	;CLEAR ENTRY VECTOR
85940	  MOVEI R2,0
85950	  SEVEC
85960	;
85970	  HRRZ R1,JOBSYM	;FIND TOP AND MOVE CODE
85980	  HLRE R2,JOBSYM
85990	  SUB R1,R2		;R1 IS END OF SYMBOL TABLE
86000	  ADDI R1,10 ;NEW END PLUS SPACE
86010	  MOVE R2,[XWD 400000,600000]
86020	  BLT R2,0(R1)		;MOVE CODE
86030	;
86040	  IORI R1,777		;GET NEXT PAGE BOUNDARY
86050	  SUBI R1,600000-1	;GET DELTA (SIZE IN WORDS)
86060	  LSH R1,-11		;GET SIZE IN PAGES
86070	  MOVNS R1		;NEGATE
86080	  MOVS R10,R1		;TO R10 FOR SSAVE WORD
86090	  HRRI R10,520600	;COMPLETE SSAVE WORD IN R10
86100	;
86110	  MOVE R2,[XWD 1000,RTVPAG]	;MOVE TRANSFER VECTOR
86120	  BLT R2,RTVPAG+777	;WHOLE PAGE
86130	  MOVE R2,JOBSYM	;GET SYMBOL TABLE LOC
86140	  MOVEM R2,RTVSYM	;SAVE IN TRANSFER VECTOR
86150	  HRROI R11,520000+RTVPGN	;GET SSAVE WORD FOR IT IN R11
86160	;
86170	  MOVSI R1,400001	;NOW OPEN FILE FOR SSAVE
86180	  HRROI R2,[ASCIZ /BRTP.SAV/]
86190	  GTJFN
86200	    BLOWUP
86210	;
86220	  HRLI R1,400000	;FROM CURRENT FORK
86230	  MOVEI R12,0		;END OF SSAVE TABLE
86240	  MOVEI R2,R10		;PTR TO SSAVE TABLE
86250	  MOVEI R3,0		;FLAGS
86260	  SSAVE			;DO THE SSAVE
86270	;
86280	  HALTF			;AND DONE
86290	;
86300	;
86310	PAGE
86320	SUBTTL END OF RUN TIME PACKAGE
86330	;
86340	;
86350	;
86360	END BRLOAD
