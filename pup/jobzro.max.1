;<134>JOBZRO.MAC;1207    12-JUN-78 09:45:24    EDIT BY TAFT
; Fix bug in last edit
;<134>JOBZRO.MAC;1206    20-FEB-78 20:49:02    EDIT BY TAFT
; Print Ethernet-related bugnotes only if EBUGFL turned on
;<134>JOBZRO.MAC;1205    25-JAN-77 20:29:23    EDIT BY TAFT
; Put calls to set DLS line speeds in Maxc1 conditional
;<134>JOBZRO.MAC;1204    17-JUL-76 18:21:15    EDIT BY TAFT
; Add code in CHKMPE to print memory register data
;<134>JOBZRO.MAC;1203    29-JUN-76 16:13:49    EDIT BY TAFT
; Add mechanism to limit rate of NVIO bugchk printing
;<134>JOBZRO.MAC;1202    23-JAN-76 19:33:13    EDIT BY TAFT
; Reinsert missing call to CHKRST in CHKR loop
;<134>JOBZRO.MAC;1201    10-JAN-76 22:41:07    EDIT BY TAFT
; Install patches from 1.33 SWPMON.MAC:
; Add code to run SETIME after soft restart
; Add SETIME to list of startup programs
; Insert call to PUPBEG
; Add Pup stuff -- call to NTDINI and PBGLOG, NTDINI OPRFN
; Call LOGCNF if KCFLOG # 0.
; Don't broadcast system resumed message if DBUGSW=2
; Build going down message first and send it all at once to avoid
;  awkward pauses
; Print argument word passed in NVIO bug check
; Fix CHKMPE to also output data from original error, as well as sweep
; Bypass running CHKDSK if flag CHKBYP is set
; Clear RSTFLG after initialization mostly complete so don't get
; spurious resumption messages if bugchks occur during startup.
; Log disk configuration after restart
; Add code for logging disk errors, BUGCHKs, BUGHLTs, and scheduled
;  downtime in the fact file 
; Add code to print parity error data on logging console.
; Wake job 0 when NVCHK becomes nonzero.
; On soft restart, reset DLS line speeds and broadcast a message.
; Fix IMPBUG glitch (undocumented entry at CHKBG1)
; Rewrite BUGHLT/BUGCHK/BUGLOG/NVBUG code.
; Put in DOBE's for BUGHLT and BUGCHK
; Make HSYS halt system same as HALT TENEX command
; Run BSYS verify before CHECKDSK on system startup.  (ERF & EAT)
; Call XNTCHK for flush MCA host checks.  (ERF)
; DOBE stuck in here and there to keep logging messages from typing all
;  over each other.  (EAT)
; Use up less paper printing disk errors.  (ERF)
;<134-TENEX>JOBZRO.MAC;12    17-SEP-75 13:33:29    EDIT BY PLUMMER
; ALLOW FOR HSYST5 TO HAVE USER NUMBER IN LH
;<134-TENEX>JOBZRO.MAC;11    29-AUG-75 12:02:52    EDIT BY OPERATOR
;<134-TENEX>JOBZRO.MAC;10    28-AUG-75 13:34:23    EDIT BY ALLEN
;<134-TENEX>JOBZRO.MAC;7    27-AUG-75 11:57:12    EDIT BY ALLEN
;<134-TENEX>JOBZRO.MAC;6    27-AUG-75 11:55:05    EDIT BY ALLEN
; CORRECT MAINTENANCE OF PIE-SLICE GROUP CPU TIME
;<134-TENEX>JOBZRO.MAC;4    11-AUG-75 18:03:38    EDIT BY CLEMENTS
; Make system reset HSYS if one was pending before reload.
;<134-TENEX>JOBZRO.MAC;3     7-AUG-75 13:50:49    EDIT BY CLEMENTS
; Move CHKDRM error printer out into individual drum drivers
;  so it can print device dependent stuff.
; Change err msg from CHECKDSK to CKECKDISK at RUNDD1
;<134-TENEX>JOBZRO.MAC;2     3-JUN-75 15:53:55    EDIT BY ALLEN
; CHKR RUNS ON HIQ FOR PIE-SLICE SYSTEM
;<134-TENEX>JOBZRO.MAC;1    23-APR-75 13:04:12    EDIT BY CLEMENTS
;SPLITTING SWPMON.MAC INTO PIECES. THIS IS JOBZRO.MAC

	SEARCH PROLOG
	TITLE JOBZRO
	SWAPCD

INTERNAL	RUNDD,HSYS4,CHKR,CVTAD,CHKRI,CHKH1,CHKBG1

EXTERNAL	CAPENB,CAPMSK,DISKP
EXTERNAL	ACCIFG,BHC,BLOCKW,BUGCHK,BUGHLT,BUGNTE,BUGTAB
EXTERNAL	CGFLG,CHKBT,CHKTIM,CHKTM1,CRSTAD,CTIMS
EXTERNAL	DDMP,DDMPFK,DDTIME,DONSJ,DRMCFE,DRMFRE,DRMIN0
EXTERNAL	DSKNRE,DSKRCE,EDISMS,ENTFLG
EXTERNAL	FACTSW,FORKX,HSYST1,HSYST2,HSYST3,HSYST4,HSYST5
EXTERNAL	IOIP,JB0FLG,JB0TT,JOBPT,JOBRT,MENTR,NXTDMP
EXTERNAL	OTYLIN,PRIMRY,R,SPC1,SPCSTJ,SPTC
EXTERNAL	SVNUM,SYSIFG,SYSRST,TNAMS1,TTFORK,XEFACT

DEFINE TMSG <	PUSHJ P,TMSGQ##>

; START OF JOB ZERO ONCE THE MONITOR INITIALIZATION HAS BEEN DONE,
; I.E. SWAPPABLE CODE IS IN AND DEVICES INITIALIZED.
; FIRE UP CHECKDSK, SYSJOB, THEN RUN CHKR BACKGROUND TASKS

; Programs to run during startup
; B0 set => always run;  clear => omit if debugging Tenex
J0FKS:	1B0+[ASCIZ /<SYSTEM>SETIME.SAV/]
	[ASCIZ /<SUBSYS>BSYS.SAV/]
	[ASCIZ /<SYSTEM>CHECKDSK.SAV/]
NJ0FKS==.-J0FKS

RUNDD::	MOVSI 1,777
	ANDCAM 1,CAPENB		;FLUSH ANY SUPERIOR FORK CAPS
	SKIPN 1,CRSTAD		;DO WE HAVE A SAVED TIME FROM CRASH?
	JRST RUNDD3		;NO
	STAD			;YES, SET IT
	JFCL
RUNDD3:	MOVEI 1,101
	DOBE
IFDEF PUPCHN,<CALL PUPBEG##>	; Start Pup background fork
IFN NDLS,<IFE MAXC-1,<CALL STTSPD##>>  ; Initialize DLS line speeds
	SETO 1,
	HRROI 2,[ASCIZ /
TENEX RESTARTING, WAIT...
/]
	MOVE 3,DBUGSW##		;IF USERS WILL GET A CHANCE AT IT,
	CAIGE 3,2		; ..
	TTMSG			;TELL THEM
	SKIPG DISKP
	JRST RUNDD2		;SKIP DISK STUFF IF NO DISK
	MOVEI 1,RUNDD1		;BREAK TO RUNDD1 IF ANYTHING GOES WRONG
	HRRM 1,MONBK
	CALL CHKBT		;CHECK CONSISTENCY OF DISK BIT TABLE
	IFDEF IMPCHN,<CALL IMPBEG##> ;START IMP ASYNCH FORK
	MOVSI 6,-NJ0FKS		; Count of startup programs to run
J0FKLP:	SKIPGE J0FKS(6)		; Always run this program?
	 JRST J0FKL0		; Yes, do so
	MOVE 1,DBUGSW		; No, debugging?
	CAIE 1,2
	 SKIPE CHKBYP##		; Verify bypass switch set?
	 JRST J0FKL1		; Yes, bypass this program
J0FKL0:	MOVSI 1,(1B2+1B17)
	HRRO 2,J0FKS(6)		; Get name of next program to be run
	GTJFN
	JRST RUNDD1
	PUSH P,1
	MOVSI 1,(1B1)		;XMIT CAPABILITIES
	CFORK			;CREATE A FORK FOR CHECKDSK
	BUG(HLT,<JOB 0 CFORK FAILED>)
	EXCH 1,0(P)
	HRL 1,0(P)
	GET
	MOVE 1,[CHKDSR]		;SAY CHECK DSK RUNNING
	IORM 1,FACTSW
	POP P,1
	SETZ 2,
	SFRKV			;START AT MAIN ENTRY
	WFORK
	KFORK
	MOVE 1,[CHKDSR]		;SAY CHKDSK COMPLETED
	ANDCAM 1,FACTSW
	JRST J0FKL1

RUNDD1:	HRROI 1,[ASCIZ /NO /]
	PSOUT
	HRRO 1,J0FKS(6)		; Name of program we couldn't run
	PSOUT
	MOVEI 1,EOL
	PBOUT
J0FKL1:	AOBJN 6,J0FKLP		; Repeat for all startup programs

RUNDD2:	SETZM CHKBYP##		; Clear Checkdsk bypass flag
	MOVEI 1,RUNDD6		;BREAK TO RUNDD6 IF ANY SCREWUP
	HRRM 1,MONBK
	MOVEI 1,101
	DOBE			;WAIT FOR ANY JOB0 OUTPUT
	MOVE 1,[CHKDSE]		;DISK OK?
	TDNE 1,FACTSW
	JRST 	[HRROI 2,TNAMS1
		SETO 1,
		TTMSG
		JRST .+1]
	MOVE 1,JB0TT		;JOB 0 TTY
	CAIE 1,377777		;REAL TTY?
	JRST RUNDD4		;YES
	MOVSI 1,(1B0+1B17)	;NONE, SO OPEN FILE FOR MESSAGES
	HRROI 2,[ASCIZ /<SYSTEM>ERROR.REPORT/]
	GTJFN
	BUG(CHK,<CAN'T GTJFN ERROR REPORT FILE>)
	MOVE 2,[44B5+1B20]
	OPENF
	BUG(CHK,<CAN'T OPENF ERROR REPORT FILE>)
RUNDD4:	HRRM 1,PRIMRY		;USE IT FOR OUTPUT 
	MOVE 1,FORKX
	MOVEM 1,DDMPFK		; RECORD FORKX OF DDMP FORK
	MOVEI 1,[SIXBIT '$RUNNING DDMP$$/']
	TMSG			;ON TTY 0
	MOVE 1,DBUGSW		; Include debug setting in restart entry
	LSH 1,6
	HRLI 1,(740B8)		; Log system restart in fact file
	MOVEM 1,LOGBUF
	HRROI 1,LOGBUF
	EFACT			;RESTART ENTRY IN FACT FILE
	 JSP 2,XEFACT		;CHECK EFACT FAILURE (ALWAYS SKIPS)
	  SETOM ACCIFG		; IF SUCCESS, ASSUME ACCOUNTING GOOD
	CALL LOGCNF##		; Log current disk configuration in fact file
	SETZM RSTFLG##		; Clear soft restart flag just in case
	AOS SYSIFG		;MAKE SYSTEM AVAILABLE
	CALL DONSJ		;START NEXT SPECIAL JOB
	MOVSI 1,(1B1)		;XMIT CAPABILITIES
	CFORK			;CREATE A FORK FOR SYSJOB
	BUG(HLT,<JOB 0 CFORK FAILED>)
	PUSH P,1
	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /<SYSTEM>SYSJOB.SAV/]
	GTJFN
	JRST [	POP P,1
		KFORK
		MOVEI 1,[SIXBIT '$NO SYSJOB$/']
		TMSG
		JRST RUNDD5]
	HRL 1,0(P)
	GET
	POP P,1
	SETZ 2,
	SFRKV			;START AT MAIN ENTRY, LET RUN FOREVER

RUNDD5:
RUNDD6:	MOVEI 2,CTYLIN
	CALL SPCSTJ		; START UP FIRST AUTO JOB
IFE PIESLC,<
	MOVEI 1,103
	MOVEM 1,JOBBIT		;SET PRIORITY FOR CHKR
> ; END NON-PIE-SLICE CONDITIONAL
IFN PIESLC,<CALL SETHIQ##>
	MOVEI 1,CHKRI
	HRRM 1,MONBK		;SET DISPATCH FOR INTERRUPTS
	MOVE 1,FORKX		;SAVE FORK INDEX FOR DEBUGGING
	MOVEM 1,CHKFRK		; ..
	JRST CHKR		;GO DO BACKGROUND

LS CHKFRK,1			;FORKX OF THE DDMP FORK

;FORK STARTED BY CHKR AT ARMAGEDDON TIME.
;COMMENCE SHUTDOWN. PREVENT NEW JOBS, LOGOUT EXISTING JOBS, HALT.

HSYS4:	MOVSI 1,UMODF		;FAKE UP SLOW JSYS ENTRY
	MOVEM 1,FPC		; ..
	JSYS MENTR		; ..
	IFDEF IMPCHN,<
	MOVE 2,HSYST4
	MOVE 1,HSYST5
	ANDI 1,17		;EXTRACT GOING DOWN REASON
	CALL IMPHLT##>
	MOVE 6,[XWD -NJOBS+1,1]	;START WITH JOB 1
	MOVEI 5,^D60000		; INITIAL TIME-OUT INTERVAL
	SKIPGE JOBRT(6)		;LOOK FOR EXISTING JOB
HSYS41:	AOBJN 6,.-1
	JUMPGE 6,HSYS7		;JUMP IF DONE
	HLRZ 1,JOBPT(6)		;WHAT TTY IS THE JOB ON?
	CAME 1,OTYLIN		;ONE OF THE PRIVILEGED ONES?
	CAIN 1,CTYLIN		; ..
	JRST HSYS41		;YES. LET IT STAY ON
	MOVEI 1,(6)		;NO, LOG OUT THIS JOB NUMBER
	LGOUT			; ..
	  JFCL
	ADDI 5,^D10000		; AUGMENT TIME-OUT BY 10 SEC PER JOB
	JRST HSYS41

HSYS7:	ADD 5,TODCLK		; TIME TO STOP WAITING FOR LOGOUTS
HSYS8:	CAMG 5,TODCLK		;WAITED MAX TIME?
	JRST HSYS9		;YES, PROCEED WITH SHUTDOWN
	MOVE 6,[XWD -NJOBS+1,1]	;START WITH JOB 1
	SKIPGE JOBRT(6)		;SEE IF ANY JOBS STILL EXIST
HSYS81:	AOBJN 6,.-1
	JUMPGE 6,HSYS9		;NONE FOUND, PROCEED
	HLRZ 1,JOBPT(6)		;TTY NUMBER OF THIS JOB
	CAME 1,OTYLIN		;PRIVILEGED?
	CAIN 1,CTYLIN		; ..
	JRST HSYS81		;YES, IGNORE
	MOVEI 1,^D1000		;NO, WAIT 1 SEC., THEN CHECK AGAIN
	DISMS
	JRST HSYS8

HSYS9:	GTAD			; Logged scheduled shutdown in fact file
	MOVE 4,1		; Date/time in third word
	SETZ 3,			; Second word not used at this time
	MOVSI 2,(306B8)		; Fact entry type in first word
	MOVE 1,[-3,,2]		; Log it
	EFACT
	  JSP 2,XEFACT
HSYS90:	SETZM NXTDMP		;INITIATE DDMP
	SETZM DDTIME
	AOS JB0FLG
	MOVEI 5,^D30		;MAX TIME FOR JOB 0
HSYS91:	MOVEI 1,^D1000		;WAIT 1 SEC
	DISMS
	SKIPN CGFLG		;EVERYTHING FINISHED?
	SKIPL NXTDMP
	SOJG 5,HSYS91		;NO, WAIT MORE
	JUMPLE 5,HSYS90		;IF TIMED OUT, TRY AGAIN
	SKIPE IOIP		;WRITES IN PROGRESS?
	JRST .-1		;YES, WAIT FOR COMPLETION
	MOVEI 1,CTYLIN		;ANNOUNCE SHUTDOWN.
	HRROI 2,[ASCIZ /SHUTDOWN COMPLETE.
/]
	TTMSG
	MOVEI 1,^D15000		;FINALLY FOR TTY OUTPUT TO QUIT,
	DISMS			; WAIT JUST A BIT MORE
	MOVE 1,OTYLIN		;NOW HALT OR HALTF DEPENDING ON
	MOVEI 2,CTYLIN
	SKIPGE TTFORK(1)	;WHETHER A JOB IS STILL ON CTY/OTY
	SKIPL TTFORK(2)		; ..
	HALTF			;SOMEONE STILL ON. KEEP RUNNING.
	CALL DDTHLT##		; Enter debug mode and request sched halt
	HALTF

;ROUTINE TOSEND GOING DOWN MESSAGE TO ALL LINES

THSYS:	PUSH P,1		;1 CONTAINS NUMBER OF MINUTES
	ADD P,BHC+17		; Allocate space on stack
	JUMPGE P,MSTKOV##
	HRROI 1,-16(P)		; Init string pointer to block
	HRROI 2,[SYSNAM(<ASCIZ /
*** >,< GOING DOWN IN />)]
	SETZ 3,
	SOUT
	MOVE 2,-17(P)		;GET NUMBER OF MINUTES AGAIN
	CAIN 2,1		;THE 'ONE' CASE?
	JRST [	HRROI 2,[ASCIZ /ONE MINUTE!! ***
/]
		JRST HSYS51]	;YES, SPECIAL MESSAGE
	MOVEI 3,^D10
	NOUT
	JFCL
	HRROI 2,[ASCIZ / MINUTES. ***
/]
HSYS51:	SETZ 3,			; Append to string
	SOUT
	SETO 1,			; Now broadcast whole string to all ttys
	HRROI 2,-16(P)
	TTMSG
	SUB P,BHC+17		; Release space on stack
	POP P,1			;RETURN NUMBER OF MINUTES
	RET

;PERIODIC (10 SEC) CHECK OF THINGS

CHKR:	SETZM JB0FLG		;CLEAR REQUEST FLAG
	MOVE 1,TODCLK
	ADDI 1,^D120000		; IN 2 MINUTES GET HI-Q
	MOVEM 1,CHKTM1
	ADDI 1,^D120000		; 2 AFTER THAT CALL US HUNG
	MOVEM 1,CHKTIM		;LEAVE FOR SCHED TO CHECK
	SKIPE RSTFLG##		; Soft restart or long pause happen?
	 CALL CHKRST		; Yes, reinitialize and broadcast message
	MOVEI 1,101		; Wait for logging console to be free
	DOBE			;   to avoid trashing messages
	SKIPE 2,BUGHLT		;BUGHLTS LATELY?
	CALL CHKHLT		;REPORT
	SKIPE 2,BUGCHK		;BUGCHK?
	CALL CHKBUG		;YES
	SKIPE 2,BUGNTE##	; Other messages to log?
	CALL CHKNTE		; Yes
	SKIPE 2,NVLOG##		; Nvio buglog?
	CALL CHKNVL		; Yes
	SKIPL 7,MPECNT		; Memory parity errors?
	CALL CHKMPE		; Yes, print them out
	CALL CHKDMS		;CHECK DRUM SPACE
	CALL CHKSPT		;CHECK SPT SPACE
	MOVE 1,DRMCFE		;DRUM ERROR COUNT
	CAME 1,CHKDMC		;DIFFERENT FROM LAST TIME?
	CALL CHKDRM##		;YES
	MOVE 1,DSKRCE		;DISK RECOVERABLE ERRORS
	CAME 1,CHKDRE		;DIFFERENT FROM LAST CHECK?
	CALL CHKDE1##		;YES, GO PRINT INFO
	MOVE 1,DSKNRE		;DISK NON-REC ERRORS
	CAME 1,CHKDNE		;DIFFERENT?
	CALL CHKDSK##		;PRINT INFO
	SKIPE KCFLOG##		; Need to log new disk configuration?
	CALL LOGCNF##		; Yes
IFDEF IMPCHN,<
	CALL CHKNET##		;YES, LOG IT
>
IFDEF MCACHN,<
	CALL XNTCHK##		; Do MCA host management
>
IFDEF PUPCHN,<
	CALL PBGLOG##		; Log Pup bugs if any
>
	SKIPE 1,NEWBS##		; New bad spots?
	CALL APNBS##		; Append to list
	CALL TTHCK##		;SEE IF DATASETS NEED TO BE HUNG UP
	CALL DDMP		;DISK BACKUP
	SKIPN HSYSIN		;HAS <SYSTEM>HSYS.TIMES BEEN CHECKED?
	CALL CHSYSI		;NO, GO DO IT NOW.
	SKIPE HSYST1		;SYSTEM SHUTTING DOWN?
	CALL CHKHSY		;YES. CHECK HSYS TIMERS.

IFN PIESLC,<
	CALL CHKPIE		;CHECK IF PIE-SLICE CPU TIMES NEED UPDATE
> ; END PIE-SLICE SCHED CONDITIONAL

	MOVE 2,TODCLK		;SETUP DISMISS CONDITION FOR
	ANDI 2,377777		;NOW PLUS 30 SEC
	MOVSI 1,^D30000(2)
	HRRI 1,JB0TST		;OR JB0FLG
	JSYS EDISMS
	JRST CHKR

	RESCD

JB0TST:	MOVE 3,4		;SAVE RETURN
	JSP 4,BLOCKW		;TEST CLOCK
	SKIPE JB0FLG		;OR FLAG
	JRST 1(3)		;RUN
	SKIPN 1,NVLOG##		; NVIO bugchecks lately?
	 JRST 0(3)		; No, wait
	MOVE 2,TODCLK		; Yes, get now
	CAMN 1,LSTNVL		; Same bugcheck as last time?
	CAML 2,NVLTIM		; Yes, waiting time elapsed?
	 JRST 1(3)		; Different bugcheck or time elapsed
	SETZM NVLOG##		; Same bugcheck, ignore it
	JRST 0(3)

	SWAPCD

CHKH1:	MOVEI 1,101
	MOVEI 3,^D8
	NOUT
	JFCL
	MOVEI 2," "
	BOUT
CHKR1::	GTAD			;CURRENT TIME AND DATE
	JUMPL 1,CHKR2		;IF NOT SET
	MOVE 2,1
	MOVEI 1,101
	SETZ 3,
	ODTIM			;INCLUDE TAD WITH MESSAGE
CHKR2:	HRROI 1,[ASCIZ /
/]
	PSOUT
	RET

CHKHLT:	SETZM BUGHLT		; Here to do BUGHLT message
	HRROI 1,[ASCIZ/*****BUGHLT AT /]
	MOVSI 3,(305B8)		; Fact entry type for BUGHLT
	AOJA 2,CHKBG3		; SOSed in BUGHLT, AOSed here, SOSed at CHKBG0

CHKBUG:	SETZM BUGCHK		; Here to do BUGCHK message
	HRROI 1,[ASCIZ/*****BUGCHK AT /]
	MOVSI 3,(304B8)		; Fact entry type for BUGCHK
CHKBG3:	PUSH P,1		; Save message
	MOVEM 3,BUGREC##	; Store entry type in first word
	MOVEI 1,-1(2)		; Bug address
	HRL 1,SVNUM		; Monitor version in lh
	MOVEM 1,BUGREC+1	; Store in second word of entry
	GTAD			; Date/time in third word
	MOVEM 1,BUGREC+2
	MOVE 1,[MNBREC##,,BUGREC##] ; Log bug and all saved data  in fact file
	EFACT
	  BUG(NTE,<EFACT failure>)
	POP P,1			; Restore message
	JRST CHKBG0

CHKNTE:	SETZM BUGNTE		; Here to log BUGNTE message
	HRROI 1,[ASCIZ/**BUGNOTE AT /]
	JRST CHKBG0

CHKNVL:	SETZM NVLOG		; Here to log NVIO BUGCHK
	CAIL 2,40_4		; One of the Ethernet-related bugs?
	CAILE 2,47_4
	 JRST .+3		; No
	SKIPN EBUGFL		; Yes, suppress unless EBUGFL set
	 POPJ P,
	MOVE 1,TODCLK		; Get now
	CAME 2,LSTNVL		; Same bugcheck as last time?
	 JRST .+3		; No
	CAMGE 1,NVLTIM		; Yes, has a minute elapsed since then?
	 POPJ P,		; No, don't print it
	MOVEM 2,LSTNVL		; Save bugcheck number
	ADDI 1,^D60000		; Setup now plus 60 seconds
	MOVEM 1,NVLTIM
	HRROI 1,[ASCIZ/**NVIO BUGCHK /]
	SKIPGE NVCHKA		; Argument passed by NVIO?
	JRST CHKBG0		; No
	PSOUT
	MOVEI 2,-1(2)		; Yes, eliminate offset
	PUSH P,2		; Save address
	CALL OCTCTY##		; Print it
	HRROI 1,[ASCIZ / status /]
	PSOUT
	MOVE 2,NVCHKA		; Get NVIO bugchk argument
	SETOM NVCHKA		; Clear out
	LSH 2,-4		; Right-justify 16-bit arg
	JRST CHKBG4		; Print status, date time etc.

LS LSTNVL		; Last NVIO bugcheck number
LS NVLTIM		; Earliest time at which to print same bugcheck
LS EBUGFL		; Set nonzero to enable printing of Ethernet bugs

; Here with initial string to type in 1, address+1 in 2
CHKBG0:	PSOUT
	MOVEI 2,-1(2)		; Clear LH, eliminate +1 offset

; IMPBUG code enters here from IMPDV
CHKBG1:	PUSH P,2		;SAVE ADDRESS
CHKBG4:	CALL CHKH1		;PRINT IT
	SKIPE NBUGTP		;HAVE BUG TABLE NOW?
	JRST BUGLK5		;YES
	MOVE 1,SVNUM		; VERSION NUMBER OF THIS SYSTEM
	HRLI 1,(1B2+1B17)	; OLD FILE & SHORT FORM STRING
	HRROI 2,[SYSNAM(<ASCIZ \<SYSTEM>BUGTABLE.>,<\>)]
	GTJFN
	JRST BUGLK0
	MOVE 2,[44B5+1B19]
	OPENF
	JRST BUGLK0
	BIN			;FIRST WORD IS (NEG) COUNT OF PTRS
	MOVEM 2,NBUGTP
	MOVE 7,[XWD -SBUGTF,BUGTAB]
BUGLK3:	BIN
	JUMPN 2,BUGLK2
	GTSTS
	TLNE 2,(1B8)		;EOF?
	JRST BUGLK4		;YES
	SETZ 2,
BUGLK2:	MOVEM 2,0(7)
	AOBJN 7,BUGLK3
BUGLK4:	CLOSF
	JFCL
BUGLK5:	POP P,1			;BUG ADDRESS
	HRLZ 7,NBUGTP
BUGLK1:	MOVE 6,BUGTAB(7)
	HLRZ 2,6
	CAME 1,2
	AOBJN 7,BUGLK1
	JUMPGE 7,R		;FAILED TO FIND ADDRESS, PRINT NOTHING
	HRROI 1,[ASCIZ / - /]
	PSOUT
	HRROI 1,BUGTAB(6)	;STRING STORAGE RELATIVE TO START OF TABLE
	PSOUT
	JRST CHKR2		;PRINT EOL AND RETURN

BUGLK0:	HRROI 1,[ASCIZ @ - (FAILED TO GTJFN/OPEN BUGTABLE FILE)
@]
	PSOUT
	POP P,1
	RET

LS NBUGTP,1		;NEG COUNT OF PTRS IN BUGTABLE

;CHECK IF SYSTEM SHUTDOWN MESSAGE NEEDS TO BE TYPED.
;CALLED ONLY FROM JOB 0, CHKR ROUTINE.

CHKHSY:	GTAD			; GET NOW
	CALL CVTAD		; LINEARIZE
	SKIPE HSYST3		; ANY MSGS TYPED YET?
	JRST CHKHS2		;YES.
	MOVE 2,HSYST2		; GET SHUTDOWN TIME
	CAIG 2,^D<2*60*60>(1)	; MORE THAN TWO HOURS AWAY?
	 SKIPA 2,1		; NO, USE NOW
	  SUBI 2,^D<60*60>	; YES, USE 1 HOUR BEFORE
	MOVEM 2,HSYST3		; ELSE USE NOW
CHKHS2:	CAML 1,HSYST2		; SHUT DOWN TIME YET?
	 JRST CHKHS4		; YES, GO DO IT
	CAMGE 1,HSYST3		;UP TO NOTIFICATION TIME?
	JRST CHKHS3		;NO. DO NOTHING.
	SUB 1,HSYST2		;YES. COMPUTE TIME TILL SHUTDOWN.
	MOVNS 1
	ADDI 1,^D30		; ROUND TO NEAREST MINUTE
	IDIVI 1,^D60
	CALL THSYS		;NOT TIME YET. SAY HOW LONG TO ALL TTY'S
	MOVE 3,[POINT 9,CTIMS]	;FIND WHEN NEXT NOTIFY SHOULD BE
	ILDB 2,3		;LOOK THRU LIST OF TIMES
	CAMG 1,2		;SHORTER TIME?
	JUMPG 2,.-2		;NO. LOOK ON. (JUMPG IN CASE IMPOS ERR)
	IMULI 2,^D60		;BACK TO SECONDS
	SUB 2,HSYST2		; ..
	MOVNM 2,HSYST3		;STORE FOR NEXT TYPEOUT TEST
CHKHS3:	RET			;DONE FOR THIS TIME.

CHKHS4:	SETZM ENTFLG		;THE TIME HAS COME. START SHUTDOWN.
	SETZM HSYST1		;CLEAR FLAGS IN CASE RESTARTED,
	SETZM HSYST2		; AND TO PREVENT MULTIPLE HSYS4 FORKS
	SETZM HSYST3		; ..
	MOVSI 1,(1B1)		;CREATE A FORK WITH CAPABILITIES
	CFORK			; ..
	  BUG (HLT,<JOB 0 CFORK FAILED - HSYS>)	;OH WELL, TIME TO QUIT..
	MOVEI 2,HSYS4		;WHERE TO START INFERIOR, EXEC MODE.
	MSFRK			;START IT.
	RET			;AND THATS ALL CHKR DOES ABOUT IT.

; CONVERT GTAD FORMAT TO LINEAR TIME AND DATE

CVTAD:	PUSH P,1
	HRRZS 0(P)
	HLRZS 1
	IMULI 1,^D<60*60*24>
	ADD 1,0(P)
	SUB P,BHC+1
	RET

;Routine to get back HSYS times from before system restart

LS HSYSIN,1		;Flag nonzero when this has been done already

CHSYSI:	GTAD			;HAS SYSTEM GOT A TAD YET?
	JUMPL 1,R		;NO IF NEG. DO IT LATER.
	MOVE 4,1		;HOLD THE CURRENT TIME
	SETOM HSYSIN		;FLAG DOING THIS NOW, DO ONLY ONCE.
	MOVSI A,100001		;SEE IF FILE EXISTS
	HRROI B,[ASCIZ /<SYSTEM>HSYS.TIMES;1/]
	GTJFN
	  RET			;NO FILE. ALL THROUGH.
	MOVE C,A		;SAVE THE JFN
	MOVE B,[440000,,200000]	;OPEN FOR READ
	OPENF
	  JRST [MOVE A,C
		RLJFN
		  JFCL
		RET]
	BIN			;GET SHUTDOWN TIME
	PUSH P,B
	BIN			;GET TIME BACK UP
	PUSH P,B
	BIN			;AND REASON
	MOVE C,B		;TO RIGHT AC'S
	CLOSF
	  JFCL
	POP P,B
	POP P,A
	CAMLE 1,4		;PAST THIS TAD ALREADY?
	HSYS			;NO, SET THE SHUTDOWN
	  JFCL
	RET

CHKDMS:	MOVE 1,DRMFRE
	CAMLE 1,DRMIN0		;DRUM SPACE LOW?
	RET			;NO
	HRROI 1,[ASCIZ /*****DRUM SPACE LOW, /]
	PSOUT
	MOVE 2,DRMFRE
	JRST CHKH1		;PRINT FREE COUNT

CHKSPT:	MOVE 1,SPTC
	CAMGE 1,SPC1		;SPT LOW?
	RET			;NO
	HRROI 1,[ASCIZ /*****SPT SPACE LOW, /]
	PSOUT
	MOVN 2,[NOFN-SSPT]
	SUB 2,SPTC		;SPACE LEFT
	JRST CHKH1

;ANY INTERRUPT WILL EVENTUALLY TRAP TO HERE

CHKRI:	MOVE P,UPP
	ADD P,BHC+2		;RESET STACK
	SETZM SLOWF
	SETOM INTDF
	SETZM PSIBW
	HRROI 1,[ASCIZ /
*****JOB 0 CRASH, CONTINUING
/]
	PSOUT
	JRST CHKR

GS CHKDRE,1			;COUNT OF REC. ERRORS AT LAST REPORT
GS CHKDNE,1			; "" NON-REC. ""
LS CHKDMC,1


IFN PIESLC,<
; ROUTINE TO PERIODICALLY UPDATE PIE-SLICE GROUP CPU TIMES
CHKPIE:	MOVE 1,TODCLK		;TIME TO DO CHECK?
	CAMGE 1,PIETIM
	 RET			;NOT TIME YET
	ADD 1,[^D<30*60*1000>]	;YES, DO IT AGAIN 30 MINUTES FROM NOW
	MOVEM 1,PIETIM

	MOVSI 1,-NJOBS		;PREPARE TO LOOP THRU ALL JOBS
	SKIPL JOBRT##(1)	;DON'T CALL IF JOB NOT THERE
	 CALL UPDPIE
	AOBJN 1,.-2
	RET

;ROUTINE TO UPDATE CPUSED FOR GROUP OF WHICH JOB IN AC1 IS A MEMBER
UPDPIE:: SKIPN PIEFLG##		;PIE-SLICE DATA FILE MAPPED?
	 RET			;NO, FORGET IT
	NOINT
	LOCK GRPLOK##


	SKIP JOBORT(1)		;TOUCH PRIOR TO GOING NOSKED
	NOSKED
	MOVE 3,JOBRT(1)		;GET JOB'S CURRENT RUNTIME
	JUMPL 3,[OKSKED		;JOB NOT THERE, RETURN
		JRST UPDPI1]
	SUBM 3,JOBORT(1)	;COMPUTE TIME SINCE LAST UPDATE
	EXCH 3,JOBORT(1)
	MOVE 2,PIEGRP##(1)	;AND GET HIS GROUP
	OKSKED

	JUMPGE 3,UPDPI2		;MAKE SURE NO SCREW-UP
	BUG (NTE,<UPDPIE: NEGATIVE INCREMENTAL RUNTIME>)
	JRST UPDPI1


UPDPI2:	IMULI 2,NWDGRP		;GET OFFSET INTO DATA FILE
	ADDM 3,CPUSED##(2)	;AND ACCUMULATE

UPDPI1:	UNLOCK GRPLOK
	OKINT
	RET

;STORAGE FOR ABOVE ROUTINES
NGS JOBORT,NJOBS
NGS PIETIM,1

> ;END OF PIE-SLICE SCHED CONDITIONAL


; Routine called from job 0 to clean up after a soft restart
CHKRST:	SETZM RSTFLG##		; Clear request
IFN NDLS,<IFE MAXC-1,<CALL STTSPD##>>  ; Reinitialize DLS line speeds
	SETO 1,			; Broadcast restart message
	HRROI 2,[SYSNAM(<ASCIZ /
*** >,< RESUMED FROM SERVICE INTERRUPTION ***
/>)]
	MOVE 3,DBUGSW		; Don't do it if debugging
	CAIE 3,2
	TTMSG
	MOVSI 1,(1B2+1B17)	; Old file, name from string
	HRROI 2,[ASCIZ /<SYSTEM>SETIME.SAV/]
	GTJFN
	 RET			; Not there, forget it
	MOVE 2,1		; Save JFN
	MOVSI 1,(1B1)		; Create a fork with our capabilities
	CFORK
	 JRST [	MOVE 1,2	; Can't, release JFN and forget it
		RLJFN
		 CAI
		RET]
	EXCH 1,2		; Fork handle to 2, JFN to 1
	HRL 1,2			; Handle,,JFN
	GET			; Get the program into the fork
	MOVE 1,2		; Recover handle
	SETZ 2,			; Offset zero in entry vector
	SFRKV			; Start the fork
	WFORK			; Wait for it to complete (<10 sec)
	KFORK			; Kill it
	RET

; Job 0 routine to log parity errors.  Called with c(MPECNT) in 7.

CHKMPE:	SETOM MPECNT##		; Reset count
	HRROI 1,[ASCIZ /*****Memory parity error /]
	PSOUT
	MOVE 2,MPEBTS##		; Get NVIO error bits from original error
	CALL QADOUT		; Report them
	MOVEI 1," "
	PBOUT
	CALL CHKR1		; Date, time, eol
	MOVSI 6,-6		; 6 memory registers to print
CHKMP0:	HRRO 1,REGTAB(6)	; Print register name
	PSOUT
	MOVE 2,MPREGS##(6)	; Get contents of register at time of error
	CALL OCTCTY##		; Print in octal
	AOBJN 6,CHKMP0
	MOVEI 1,EOL
	PBOUT
	JUMPLE 7,[HRROI 1,[ASCIZ /No bad words found on sweep
/]
		PSOUT
		RET]
	MOVN 7,7		; Make AOBJN pointer
	MOVSI 7,(7)
CHKMP1:	MOVEI 1,101
	MOVE 2,MPEADR##(7)	; Print error address
	MOVE 3,[1B0+1B2+8B17+8B35]
	NOUT
	  JFCL
	MOVE 2,MPECON##(7)	; Print bad contents
	HRLI 3,(1B0+1B2+^D13B17)
	NOUT
	  JFCL
	MOVE 2,MPEQAD##(7)	; Get error bits returned by NVIO
	CALL QADOUT		; Report them
	MOVEI 1,EOL
	PBOUT
	AOBJN 7,CHKMP1		; Repeat for each bad word
	RET

; Internal routine to decode memory error bits in 2
QADOUT:	MOVSI 6,-6		; 6 kinds of errors
CHKMP2:	TDNN 2,[BYTE(8) 1,1,1,1] ; This kind of error in any quadrant?
	JRST CHKMP3		; No
	HRRO 1,MEBTAB(6)	; Yes, print error type
	PSOUT
	MOVEI 1,"J"		; Print names of quadrants with error
	TLNE 2,(1B7)
	PBOUT
	MOVEI 1,"K"
	TLNE 2,(1B15)
	PBOUT
	MOVEI 1,"L"
	TRNE 2,1B23
	PBOUT
	MOVEI 1,"M"
	TRNE 2,1B31
	PBOUT
CHKMP3:	LSH 2,-1		; Shift error bits for next type
	AOBJN 6,CHKMP2		; Loop for all error types
	RET

; Memory register names
REGTAB:	[ASCIZ .MAR/ .]
	[ASCIZ .  MDR/ .]
	[ASCIZ .  MDRL/ .]
	[ASCIZ .  KMAR/ .]
	[ASCIZ .  KMDR/ .]
	[ASCIZ .  KMDRL/ .]

; Error types, ordered right-left in error bit byte
MEBTAB:	[ASCIZ / SE: /]		; Single error
	[ASCIZ / DE: /]		; Double error
	[ASCIZ / PBF: /]	; Parity bit failure
	[ASCIZ / APE: /]	; Address parity error
	[ASCIZ / DIP: /]	; Data in parity
	[ASCIZ / TIMEOUT: /]	; Hung or nonexistent



	END ; OF JOBZRO.MAC

