;<134>SYSINI.MAC;604     5-JUN-78 12:00:19    EDIT BY TAFT
; Add call to INIFNT (LPT font initialization)
;<134>SYSINI.MAC;603    14-JAN-76 01:13:00    EDIT BY TAFT
; Move DSKBTR and FLGIN calls
;<134>SYSINI.MAC;602    11-JAN-76 21:14:19    EDIT BY TAFT
; Remove EXTERN SSTSIZ, SWPST
; P2 -> PATCH2
;<134>SYSINI.MAC;601    10-JAN-76 22:42:02    EDIT BY TAFT
; Transplant patches from 1.33 SWPMON.MAC:
; Revise GETSWM, DDTRCL for new save-area format
; Change SPECJB to always start an Exec if DBUGSW=2
; Add Pup stuff -- call to NTDINI
; Don't flush EDDT if NOFLSH (defined in SCHED) is nonzero.
; Changed JRST 4 to HALT
; Change WMST to write MONSYMS on <SYSTEM>
; Fixed DDTRCL to recover from system boot save area.  (ERF)
; GETSWM and save area logic revised.  (ERF)
; Code added to lock and write-enable monitor (debug mode, DBUGSW=2) and
;  to unlock and write-protect monitor (UNDBG$G).  (ERF)
; Add FLGIN and call to DSKBTR in startup code
;<135-TENEX>SYSINI.MAC;6    16-DEC-75 10:58:23    EDIT BY CALVIN
; Put in PLUMMER's IFN for IFDEF PIESLC
;<135-TENEX>SYSINI.MAC;5     8-DEC-75 16:29:30    EDIT BY ALLEN
; REUNITE CALLS TO FILINI AND MAPBTF SO THAT BIT TABLE OFN IMMEDIATELY
;FOLLOWS DIRECTORY PT OFNS
;<134-TENEX>SYSINI.MAC;4    22-MAY-75 12:28:45    EDIT BY ALLEN
; PARAMETERIZE INITIAL SETTING OF KFACT
;<134-TENEX>SYSINI.MAC;3    14-MAY-75 21:48:59    EDIT BY SYSTEM
; MAKE MONDSC RESIDENT SINCE IT'S STORED INTO BY DSKRST
;<134-TENEX>SYSINI.MAC;2    24-APR-75 12:30:52    EDIT BY CLEMENTS
;<134-TENEX>SYSINI.MAC;1    23-APR-75 14:06:10    EDIT BY CLEMENTS
; SPLITTING UP SWPMON.MAC INTO FINITE SIZE PIECES
; THIS IS SYSINI.MAC

	SEARCH PROLOG
	TITLE SYSINI

	SWAPCD

	DEFINE TMSG
<	PUSHJ P,TMSGQ##>

INTERNAL	WMST,SWCEND,GETDDT,SBSNMS,TNAMS1,DDTFSH,NMNDSC
INTERNAL	MKPGSA,MKPGSU,JB0TT,GETMST,OPTT,SAVE32,SAVE36
INTERNAL	GETSWM,RCADDT,DDTRCL,LGNSYS,SPECJT,SPECJB
INTERNAL	NLGDES,SPCSTJ,LOGDES,NSPECJ,DONSJ

EXTERNAL	ACCIFG,AUTONX,BHC,BUGCHK,BUGHLT,CAPENB,CAPMSK
EXTERNAL	CVDSK,DBUGSW,DCHKSW
EXTERNAL	DDTPRS,DDTSYM,DDTX,DIDSCA,DISKP
EXTERNAL	EDISMS,ENTFLG,FACTSW,FILINI,GOTDDT
EXTERNAL	JFNOFN,JOBONT,JOBSRT,LGNPAR,LOGLCK,LOGONM
EXTERNAL	MAKPGA,MAKPGU,MAPBTF,MLKPG

EXTERNAL	MMSPTN,MONCOR,MRETN,MSTKOV,MULKPG
EXTERNAL	NODD1,NPMAX,PRIMRY
EXTERNAL	R,RUNDD,SCDRQ7,SETMPG,SNAMES,SNMLCK
EXTERNAL	PLCKT,SNMPT,SVNUM,SWPSTP,SYMPRS
EXTERNAL	TOTRC,TTFORK,UDSKIO
IFDEF IMPCHN,<	EXTERNAL HSTINI>
IFN PIESLC,<	EXTERNAL ACTINI,ACTONF,GRPFIL,GRPLOK>
; FOLLOWING IS A GETTAB TABLE
LOGDES:	LOGTTY			;DESIGNATOR FOR LOG MSGS - DEF IN PARAMS
JB0TT:	JB0TTY			;DESIG FOR JOB 0 AND ERR MSGS
OPTT:	OPTTY			; DESIGNATOR FOR OPERATOR
NLGDES==.-LOGDES
;END OF GETTAB

;THE FOLLOWING IS THE MONITOR DESCRIPTOR GETAB TABLE ("MONDSC")
;CURRENT ASSIGNMENTS:
;WORD0, B0 = 0 MEANS NO PIE-SLICING
;	  = 1 MEANS PIE-SLICE SYSTEM
;WORD0, B1 = 0 MEANS CONTIGUOUS DISK SWAP AREA
;	  = 1 MEANS MULTI-PACK SWAPPING 

RESCD
MONDSC:: <PIESLC>B0

NMNDSC==.-MONDSC
SWAPCD



;FOLLOWING CODE ONLY EXECUTED FOR FIRST JOB IN SYSTEM
; THIS CODE CALLED FROM EXEC0 FOR THE FIRST JOB.

EXECSI::SKIPE DIDSCA		; REFRESHING DISK?
	 SETOM ACCIFG		; NO, ASSUME SPECIAL FILES SHOULD EXIST
	CALL FILINI		;INIT FILE SYSTEM
	CALL MAPBTF		;INIT DSK BIT TABLE
	CALL DSKBTR##		; Allocate bad spots (in case files containing
				;   them have been deleted)
; NOTE -- DO NOT SEPARATE THE CALLS TO FILINI AND MAPBTF!! DISK
;SERVICE DEPENDS ON THE BIT TABLE BEING ASSIGNED THE OFN FOLLOWING THE
;DIRECTORY PT OFNS FOR PURPOSES OF DETERMINING WHETHER A DISK ERROR
;HAS OCCURRED IN A SENSITIVE PAGE. THUS, NO OFNS SHOULD BE ASSIGNED
;BETWEEN FILINI AND MAPBTF.

	CALL ACTINI		; CALL ACCOUNT VERIFYING INITER
	 JFCL			; IT'LL DO THE BUGCHK ON FAIL
IFN PIESLC,<SETZB 1,PIEFLG##>	; ASSUME NO PIE-SLICE FOR NOW
	SKIPN ACCIFG		; SHOULD SPECIAL FILES EXIST?
	 JRST EXEC1		; NO, SKIP SOME THINGS
IFDEF IMPCHN,<
	CALL HSTINI		; INITIALIZE HOST NAME TABLE
	 BUG(CHK,<FAILURE TRYING TO INIT HOST NAME TABLES>)
>
IFDEF PUPCHN,<
	CALL NTDINI##		; Map in the Pup network directory
	 BUG(CHK,<Failed to map in Pup network directory>)
>
IFDEF SRIARC,<FLGIN>		; Initialize NLS flags and password table
IFDEF LPTSPL,<
	CALL INIFNT##		; Do LPT font initialization
	 BUG(CHK,<Failed to initialize LPT fonts>)
>

IFN PIESLC,<
	CALL MAPGRP		;MAP PIE-SLICE GROUP DATA FILE
	SKIPN 1,PIEFLG		;MAPPING SUCCESSFUL?
	 JRST EXEC1		;NO

	MOVE 1,[INIGP]		;GET DEFAULT GROUP NAME
	CALL GRPLUK##		;LOOK UP IN FILE
	BUG (HLT,<DEFAULT GROUP NAME NOT IN FILE>)
>
EXEC1:
IFN PIESLC,<
	MOVEM 1,DEFGP##		;RECORD DEFAULT GROUP INDEX FOR STARTING JOBS
	MOVEM 1,PIEGRP##	;USE FOR THIS JOB (JOB 0)
	SETZM NAPROC##		;CLEAR COUNTER INCREMENTED FOR FIRST FORK
	MOVSI 2,(1.0)		;AND SET THE CORRECT COUNTER
	MOVEM 2,NAPROC(1)

	MOVE 2,[KFINIT]		;INITIAL VALUE FOR KFACT
	MOVEM 2,KFACT##

	SETOM GRPLOK		;INITIALIZE PIE SLICE DATA LOCK
>

	MOVE 1,[XWD SBSNMS,SNAMES]
	BLT 1,SNAMES+NSBSNM-1	;MOVE REGULAR SUBSYSTEM NAMES TO TABLE
	MOVNI 1,NSBSNM		;INIT TABLE POINTER WITH NEG COUNT
	MOVEM 1,SNMPT
	SETOM SNMLCK		;AND INIT LOCK
	SETOM LOGLCK
	MOVE A,[JOBONT,,JOBONT+1] ;CLEAR BACK-POINTERS
	SETOM JOBONT		; TO OWNING JOBS. NOTE JOB 0
	BLT A,JOBONT+NJOBS-1	; IS NOT OWNED BY ANYBODY.
	POPJ P,0		;RETURN FROM EXECSI TO EXEC0

;REGULAR SUBSYSTEM NAMES FOR INCLUSION IN SNAMES TABLE AT STARTUP

SBSNMS:	SIXBIT /EXEC/
	SIXBIT /(PRIV)/
NSBSNM==.-SBSNMS

;TABLE DEFINES SPECIAL PURPOSE FOR FIRST FEW JOBS

SPECJT:	XWD 0,RUNDD		;JOB 0 IS ALWAYS DISK CHECKER, ETC.

NSPECJ==.-SPECJT		;NUMBER OF SPECIAL JOBS

;EACH SPECIAL JOB CALLS THIS TO DETACH AND START THE NEXT ONE

DONSJ:	CALL LOGONM		;DO LOGIN STUFF
	MOVE 4,CTRLTT
	DTACH
	MOVE 1,JB0TT
	HRRM 1,PRIMRY		;USE JOB 0 TTY FOR ANY OUTPUT
	MOVE 1,JOBNO
	CAIGE 1,NSPECJ-1		;MORE SPECIAL JOBS TO DO?
	JRST DONS1		;YES
	RET
DONS1:	MOVE 2,4
	CALL SPCSTJ		; START ANOTHER JOB ON THIS TTY
	RET

;THE FOLLOWING BLACK MAGIC IS TEMPORARY UNTIL CRJOB DOES ALL
; THE AUTOSTARTUP WORK. IT IS NEEDED TO CAUSE A LOGIN TO REALLY
; SET UP PROTECTION AND GROUP ACCESS RIGHT

LGNSYS:	MOVEI A,1(P)		;SPACE FOR A STRING ACCOUNT
	ADD P,BHC+10		; ..
	JUMPGE P,MSTKOV		; ..
	MOVEI B,1		;USER "SYSTEM"
	GDACC			;GET DEFAULT ACCOUNT FOR SYSTEM
	  MOVE A,[500000,,INIACT]
	MOVE C,A
	MOVEI B,0		;NO PASSWORD STRING
	HRROI A,3		;FLAG LOGIN TO NOT CHECK PSWD, NOT
	MOVEM A,LGNPAR		; UPDATE LOGIN DATE
	MOVEI A,1		;USER NUMBER 1 = SYSTEM
	LOGIN
	  BUG(HLT,<LGNSYS - CAN'T LOG IN AS SYSTEM>)
	SETZM LGNPAR
	SUB P,BHC+10
	RET

; ALTERNATE STARTUP MECHANISM TO START JOBS FROM FILE "AUTOJOBS"

SPECJB:	PUSH P,3
IFE PIESLC,<
	MOVE 1,JOBNO
	MOVE 2,BHC+1
	MOVEM 2,JOBDIR(1)	; FAKE LOGIN AS SYSTEM
	MOVE 3,FORKX
	MOVEM 2,FKDIR(3)
	PUSHJ P,LOGONM		; AND PRINT LOGIN MESSAGE
>
IFN PIESLC,<
	CALL LGNSYS		;DO A LOGIN AS SYSTEM
>
	POP P,3
	MOVE 1,DBUGSW
	HRROI 2,[ASCIZ /<SYSTEM>AUTOJOBS.RUN/]
	CAIN 1,2
	HRROI 2,[ASCIZ /<SYSTEM>AUTOJOBS.DEBUG/]
	MOVSI 1,(1B2+1B17)	; OLD FILE & STRING & SHORT FORM
	GTJFN			; GET JFN OF AUTOJOBS FILE
	 JRST SPECJ5		; FILE NON-EXISTENT
	PUSH P,1		; SAVE IT
	DTACH			; DETACH THIS JOB
	MOVE 2,[7B5+1B19]
	OPENF			; OPEN TO READ
	 JRST [	POP P,1
		RLJFN
		 JFCL
		JRST SPECJ9]	; COULDN'T OPEN
	MOVE 2,3		; START POINT
	SFPTR
	 JRST SPECJ8		; HADN'T OUGHT TO HAPPEN
	HRLZ 2,1		; MAKE IT BE INPUT FOR GTJFN
	HRRI 2,377777		; NO OUTPUT
	MOVSI 1,(1B2+1B16+1B17)	; OLD FILE, FILE INPUT, SHORT FORM
	GTJFN
	 JRST SPECJ6		; FILE APPARENTLY NOT THERE
	EXCH 1,0(P)		; SAVE JFN OF TASK, GET JFN OF AUTOJOBS
	CALL SPECJN		; GET NEXT ONE STARTED
	MOVSI 1,(1B2+1B17)	;OLD FILE+SHORT FORM
	HRROI 2,[ASCIZ /<SYSTEM>EXEC.SAV/]
;FALL THRU

;FALLS THRU
	GTJFN
	JRST [	POP P,1		; NO EXEC?  GET RID OF JFN
		RLJFN
		JFCL
		JRST SPECLO]	; AND LOGOUT
	HRLI 1,400000
	GET			;GET CURRENT EXECUTIVE
	XCTMU [POP P,2]		; PUT JFN OF SAVE FILE IN AC2 OF EXEC
	HRRO 1,JB0TT		;GET JOB 0 TTY FOR PRIMARY
	UMOVEM 1,1		;GIVE IT TO EXEC TO USE.
	HRRZ 1,ENTVEC
	ADDI	1,2		;GO TO AUTO JOB ENTRY POINT
	HRRM 1,0(P)
	JRST MRETN

SPECJ6:	POP P,1
	CALL SPECJN		; SKIP TO NEXT TASK
SPECLO:	SETO 1,
	LGOUT			; LOG OURSELVES OUT
	 JFCL
	BUG(HLT,<IMPOSSIBLE FAILURE OF LGOUT(-1)>)

SPECJ8:	POP P,1
	CLOSF
	 JFCL
SPECJ9:	BUG(CHK,<SPECJB:  AUTOJOB FILE SCREWED UP>)
SPECJ5:	HRROI 1,[ASCIZ /NO AUTOJOBS FILE
/]
	PSOUT
	DTACH			; CAUSE SPECJL TO START A NEW EXEC
	CALL SPECJL		; PRETEND THIS WAS LAST TASK
	JRST SPECLO		; GO LOGOUT

SPECJN:	BIN			; SKIP TO NON-SEPARATOR
	JUMPE 2,SPECJ7		; NULL == EOF, FINISH UP
	CAIG 2,40		; SPACE OR LESS IS TO BE SKIPPED
	 JRST SPECJN
	RFPTR			; GET WHERE WE ARE AT
	 JFCL
	SOS 2			; MINUS ONE
	MOVEM 2,AUTONX		; IS NEXT PACE TO START
	CLOSF			; DONE WITH AUTOJOBS FILE
	 JFCL
	MOVEI 2,CTYLIN
	CALL SPCSTJ		; THEN START UP NEXT ON CTYLIN
	RET			; CONTINUE STARTING THIS TASK

SPECJ7:	CLOSF			; CLOSE AUTOJOBS FILE
	 JFCL
SPECJL:	MOVE 3,[CHKDSE]		;CHECK DEBUG AND ERROR CONDITIONS
	MOVE 1,DBUGSW
	CAIN 1,2		; If DBUGSW=2, don't check FACTSW or type junk
	JRST SPECJ4
	TDZN 3,FACTSW
	SETOB 3,ENTFLG
	HRROI 2,TIOMSG		;TENEX IN OPERATION MSG
	SKIPN 3			;DISK ERRORS?
	HRROI 2,TNAMS1		;YES. NOT AVAIL MSG DSK ERRORS.
	MOVE 1,JB0TT		; Real job 0 TTY?
	CAIE 1,377777
	DOBE			; Yes, avoid trashing typeout
	SETO 1,
	TTMSG
	GTAD			;IF WE NEED TIME AND DATE
	JUMPGE 1,R
SPECJ4:	MOVEI 2,CTYLIN		; START JOB ON CTY
	CALL SPCSTJ
	RET

SPCSTJ:	NOSKED			;PREVENT RACE ON TTY STARTUP
	SKIPGE 1,TTFORK(2)	;IS THERE A JOB EXTANT
	TLNN 1,1		; OR STARTING ON THIS LINE?
	JRST 	[OKSKED		; YES
		RET]		; NOT ANOTHER.
	MOVSI 1,-2		;NO.. FLAG STARTING ONE.
	HLLM 1,TTFORK(2)	; ..
	MOVEI 1,JOBSRT
	HRL 1,2
	CALL SCDRQ7		;START JOB ON CTY TO GET T&D
	OKSKED
	RET

TNAMS1:	ASCIZ /
TENEX NOT AVAILABLE: DISK NEEDS FIXING.
/
TIOMSG:	ASCIZ /
TENEX IN OPERATION
/

;GET SWAPPABLE MONITOR

 RESCD

GETSWM:	PUSH P,NPMAX		;SAVE CURRENT MAX SIZE
	MOVE 1,TOTRC
	MOVEM 1,NPMAX		;ALLOW ALL OF CORE WHILE GETTING SWM
	CALL DBGMAP		; Create and lock swappable monitor
	CALL SETDPG		; Create and lock DDPG1, DDPG2
	MOVEI 1,SWPMP0		; First virtual page of swappable monitor
	MOVE 2,SWCEND		; Last page
	MOVEI 3,DDPG1A		; Location of temp pages
	CALL MONBLT##		; Read swappable monitor from save area
	CALL CLRDPG		; Eliminate temp pages
	POP P,NPMAX		;RESTORE NORMAL MAX SIZE
	MOVE 2,DBUGSW		; Debugging?
	CAIE 2,2
	 CALL UDBMAP		; No, unlock and write-protect
	MOVE 1,DBUGSW		;SHOULD WE FLUSH DDT ?
	IOR 1,DCHKSW
	IOR 1,NOFLSH##		; Not if debugging or NOFLSH flag set
	SKIPN 1
	 CALL DDTFSH		;YES
	RET


; Create and lock DDPG1 and DDPG2 for temp use by GETSWM and DDTRCL

IFN DDPG2-DDPG1-1,<PRINTX DDPG1 and DDPG2 must be adjacent and in that order>

SETDPG:	MOVEI 1,DDPG1A		; Create and lock first page
	CALL MLKMA##
	MOVEI 1,DDPG2A		; Same for second
	CALL MLKMA##
	RET

; Unlock and destroy DDPG1 and DDPG2

CLRDPG:	MOVE 1,FORKX##		; Get our fork #
	HRLZ 1,FKPGS##(1)	; SPT index of fork's PSB
	HRRI 1,DDPG1		; Make first page identifier
	CALL MULKPG##		; Unlock page
	HRRI 1,DDPG2		; Repeat for second page
	CALL MULKPG##
	SETZ 1,			; Now destroy the pages
	MOVEI 2,DDPG1A
	CALL SETMPG##
	MOVEI 2,DDPG2A
	CALL SETMPG##
	RET

; Lock and write enable monitor (called by GETSWM and Miniexec \ command)
DBGMAP::MOVSI 12,WRITEB		; Write-enable bit
	MOVEI 11,SWPMP0		; First page of swappable monitor
DBGML1:	MOVEI 1,(11)		; Page #
	LSH 1,9			; Convert to address
	CALL MLKMA##		; Lock page (create if required)
	IORM 12,MMAP(11)	; Set write bit in map
	CAMGE 11,SWCEND		; End of swappable monitor?
	 AOJA 11,DBGML1		; No
	MOVEI 11,PATCH2##+2777	; Yes, now do resident monitor
	LSH 11,-9
	IORM 12,MMAP-2(11)
	CAMGE 11,MONCOR		; Note this excludes first page of EDDT
	 AOJA 11,.-2
	RET

; Unlock and write-protect monitor
UDBMAP::MOVSI 12,WRITEB		; Write-enable bit
	MOVEI 11,SWPMP0		; First page of swappable monitor
UDBMA1:	ANDCAM 12,MMAP(11)	; Write-protect a page of swappable monitor
	MOVEI 1,(11)		; Unlock it
	HRL 1,MMSPTN##
	CALL MULKPG##
	CAMGE 11,SWCEND		; End of swappable monitor?
	 AOJA 11,UDBMA1
	MOVEI 11,PATCH2##+2777	; Yes, now do resident monitor
	LSH 11,-9
	ANDCAM 12,MMAP-2(11)	; Write-protect a page
	CAMGE 11,MONCOR		; Note this stops before reaching EDDT
	 AOJA 11,.-2
	RET

;SWCEND IS SET BY POSTLD TO CONTAIN THE NUMBER OF THE HIGHEST
;PAGE CONTAINING SWAPPABLE CODE

SWCEND:	0
 SWAPCD

;FLUSH DDT AND SYMBOL TABLE AND MAKE PAGES AVAILABLE FOR SWAPPING
;RESIDENT DDT AND ITS SYMBOL TABLE CAN BE FLUSHED SEPARATELY
;THE CONTENTS OF CELL SYMDDT CONTROL WHAT GETS FLUSHED AS FOLLOWS
; C(SYMDDT)=0 MEANS FLUSH DDT AND SYMBOL TABLE
; C(SYMDDT)<>0 MEANS FLUSH SYMBOL TABLE ONLY
;THE FOLLOWING TWO CELLS DEFINE THE CURRENT STATUS
;  DDTPRS=0 MEANS DDT IS RESIDENT
;  SYMPRS=0 MEANS THE SYMBOL TABLE IS RESIDENT
;(NOTE THAT THE CODE WILL NOT ALLOW FOR A RESIDENT SYMBOL TABLE AND
;  A NON-RESIDENT DDT)

 RESCD
SYMDDT:	0
 SWAPCD

DDTFSH:	PUSH P,3		;SAVE REGISTERS
	PUSH P,2
	PUSH P,1
	NOINT			; PREVENT CONFUSION
	SETOM SYMPRS		; NO SYMBOLS
	SETZM SWPSTP		; CAUSE ANY MDDT'S TO TO FORGET SYMTAB
	SETZM 32		; NO RESIDENT SYMBOL TABLE
	SETZM 36
	SKIPE SYMDDT		;FLUSH SYMBOLS ONLY ?
	JRST [	HRRZ 1,SAVE36	;COMPUTE STARTING FLUSH ADDRESS
		MOVEI 3,777(1)	; AS FIRST PAGE .GE. SYMTAB BEG
		LSH 3,-^D9	; CONVERT ADDRESS TO PAGE NUMBER
		JRST DDTFS1]
	SETOM DDTPRS		; NO DDT
	MOVE 1,[HALT 100]	;CHANGE 100 DISPATCH
	MOVEM 1,100
	HRRZ 3,MONCOR		; START FLUSHING HERE
DDTFS1:	PUSH P,3		; SAVE FIRST PAGE
	MOVSI 2,(01B5)
DDTFSL:	SETZ 1,
	NOSKED			; INSURE CONSISTENT MMAP/CST0
	EXCH 1,MMAP(3)
	SKIPE 1
	MOVEM 2,CST0(3)		; MARK AS UNAVAILABLE
	OKSKED
	AOS 3
	CAMGE 3,RCADDT
	 JRST DDTFSL
	POP P,1			; FIRST PAGE FLUSHED
	MOVE 2,RCADDT
	SOS 2			; LAST PAGE FLUSHED
	CALL MKPGSA		; MAKE THEM ALL AVAILABLE
	OKINT
	POP P,1			;RESTORE REGISTERS
	POP P,2
	POP P,3
	RET			;RETURN

RCADDT:	0		;SAVE ADDRESS OF SWPCOR
SAVE36:	0		;SAVED LOCATION 36 (SYMBOL POINTER)
SAVE32:	0		;SAVED LOCATION 32 (UNDEF SYMBOL POINTER)

;RECLAIM DDT AND/OR SYMBOL TABLE (SEE ABOVE COMMENTS)

DDTRCL:	SKIPN SYMPRS		; HAVE SYMBOLS ALREADY?
	 JRST DDTRC0		; YES
	HRRZ 1,SAVE36
	MOVEI 1,777(1)
	LSH 1,-^D9
	SKIPE DDTPRS		; NEED DDT TOO?
	 MOVE 1,MONCOR		; THEN RESTORE FROM MONCOR
	MOVE 2,RCADDT		; THRU RCADDT
	SOS 2			; MINUS 1
	CALL MKPGSU		;GET THE PAGES
DDTRC0:	NOINT
	HRRZ 1,MONCOR		; START WITH MONCOR
	HRLZ 2,MMSPTN		;FIXUP THE MAP AND CST'S
	MOVSI 3,400000
	MOVSI 4,RWXB
DDTRC1:	HRR 4,1
	HRR 2,1
	NOSKED			; INSURE CONSISTENT MMAP/CST
	MOVEM 4,MMAP(1)
	MOVEM 3,CST0(1)		; PREVENT TRAPS
	MOVEM 1,CST1(1)
	MOVEM 2,CST2(1)
	OKSKED
	AOS 1
	CAMGE 1,RCADDT		; ALL DONE?
	 JRST DDTRC1		; NO, DO NEXT
	CALL SETDPG		; Create and lock DDPG1, DDPG2
	MOVE 1,MONCOR		; First page of DDT
	MOVE 2,RCADDT		; First page after DDT
	SUBI 2,1		; Last page of DDT
	MOVEI 3,DDPG1A		; Address of 2 temp pages
	CALL MONBLT##		; Read DDT and symbols from save area
	CALL CLRDPG		; Destroy DDPG1, DDPG2
	MOVE 1,[JRST DDTX]	;UPDATE 100
	MOVEM 1,100
	MOVE 1,SAVE36		;SETUP SYMBOL TABLE POINTER
	MOVEM 1,36
	MOVE 1,SAVE32
	MOVEM 1,32
	SETZM DDTPRS		;INDICATE DDT PRESENT
	SETZM SYMPRS		;INDICATE SYMBOLS PRESENT
	OKINT
	RET

MKPGSA:	CALL MAKPGA		; CALL ROUTINE IN PAGEM
	RET

MKPGSU:	PUSH P,1		;SAVE ARGS
	PUSH P,2
	CALL MAKPGU		; ROUTINE IN PAGEM
	 JRST MKPSU1
	SUB P,BHC+2		;ADJUST STACK
	RET

MKPSU1:	HRRZ 2,1		;NUMBER OF PAGES LOCKED
	HLRZS 1			;LOCKED PAGE
	PUSH P,1		;STACK THE LOCKED PAGE
	MOVEI 1,101		;TTY OUTPUT
	MOVEI 3,10		;OCTAL
	NOUT			;NUMBER OF LOCKED PAGES
	  JFCL
	HRROI 1,MKPSU2		;MESSAGE
	PSOUT
	POP P,2			;GET BACK LOCKED PAGE NUMBER
	MOVEI 1,101
	NOUT
	  JFCL
	HRROI 1,[ASCIZ /
/]
	PSOUT
	HRLZ 1,2		;SET UP DISMISS TILL PAGE UNLOCKED
	HRRI 1,PLCKT		; ..
	JSYS EDISMS		;WAIT
	POP P,2			;GET BACK ARGS
	POP P,1			; ..
	JRST MKPGSU		;TRY AGAIN
MKPSU2:	ASCIZ / PAGES LOCKED. WAITING FOR PAGE /

;MAP DDT FROM IMAGE FILE

GETDDT:	SKIPE GOTDDT		;GOT DDT NOW?
	RET			;YES
	MOVSI 1,(1B2+1B17)	;OLD FILE, SHORT FORM
	HRROI 2,[ASCIZ /<SYSTEM>MDDT2.SAV/]
	GTJFN
	JRST NODDT
	MOVE 2,[44B5+1B19]	;36-BIT READ
	OPENF
	JRST NODDT
	BIN			;FIRST WORD IS XWD -LENGTH,LOC
	HLRE 3,2		;GET LENGTH
	CAMGE 3,[-LMDDT]	;OUR SPACE BIG ENOUGH?
	JRST [	CLOSF		;NO
		JFCL
		MOVEI 1,[SIXBIT '$MDDT TOO BIG$/']
		JRST NODD2]
	HLLZ 7,2		;SETUP OUR AOBJN PTR
	MOVEI 2,0(2)		;SEE IF LOC IS CORRECT
	CAIE 2,MDDT
	JRST [	CLOSF		;WRONG-MUST BE REASSEMBLED
		JFCL
		MOVEI 1,[SIXBIT '$MDDT AT WRONG LOCATION$/']
		JRST NODD2]
	BIN
	MOVEM 2,MDDT(7)		;STORE MDDT CODE IN PRIVATE PAGE, BUT
	AOBJN 7,.-2		;CODE WILL BE USED BY ALL PROCESSES
	CLOSF
	JFCL
	NOINT
	MOVE 1,[XWD -LMDDT,MDDT]
	ASH 1,-^D9
	MOVSI 2,WRITEB
	ANDCAM 2,MMAP(1)	;WRITE-PROTECT ALL MDDT PAGES
	AOBJN 1,.-1
	AOS GOTDDT
	OKINT
	RET

NODDT:	MOVEI 1,[SIXBIT '$NO MDDT FILE$/']
NODD2:	TMSG
	JRST NODD1

;READ IN MONITOR SYMBOL TABLE FROM FILE

GETMST:	MOVE 1,SVNUM		; SYSTEM VERSION NUMBER
	HRLI 1,(1B2+1B17)	; OLD FILE & SHORT FORM STRING
	HRROI 2,[SYSNAM(<ASCIZ \<SYSTEM>MONSYMS.>,<\>)]
	GTJFN
	JRST NOSYMS		;NO FILE
	MOVE 2,[44B5+1B19]	;36 BIT READ
	OPENF
	JRST [	RLJFN
		JFCL
		JRST NOSYMS]
	NOINT
	BIN			;GET XWD -LENGTH,ADDRESS
	HLRE 3,2
	MOVNI 7,SSTSIZ		;PROBLEM WITH NEGATIVE EXTERN...
	HRLZS 7			; ..
	MOVM 3,3		;POSITIVE OF LENGTH
	CAILE 3,SSTSIZ		;TOO BIG?
	MOVE 2,7		;YES, READ ONLY TO MAX
	HRRI 2,SWPST		;ADDRESS WHERE TABLE TO BE PUT
	MOVEM 2,SWPSTP
	MOVE 7,2
	BIN
	MOVEM 2,0(7)
	AOBJN 7,.-2
	OKINT
	CLOSF
	JFCL
NOSYMS:	RET

;WRITE MONITOR SYMBOL TABLE ONTO FILE
;CALLED WITH JSP 4,WMST

WMST:	HRROI 1,[ASCIZ /
SYMBOL TABLE LARGER THAN SWAPPABLE STORAGE ALLOCATED FOR IT.
/]
	HLRE 2,SWPSTP
	MOVM 2,2
	CAILE 2,SSTSIZ		;TOO LARGE?
	PSOUT			;YES, PRINT MESSAGE
	HRROI 1,[ASCIZ /
SYMBOL TABLE WRITTEN ON FILE /]
	PSOUT
	MOVE 1,SVNUM		; VERSION NUMBER OF THIS SYSTEM
	HRLI 1,(1B0+1B17)	; FOR OUTPUT & SHORT FORM STRING
	HRROI 2,[SYSNAM(<ASCIZ \<SYSTEM>MONSYMS.>,<\>)]
	GTJFN
	0
	MOVE 2,[44B5+1B20]
	OPENF
	0
	MOVE 2,1
	MOVEI 1,101
	SETZ 3,
	JFNS			;TYPE THE FILE NAME
	MOVE 1,2
	MOVE 2,SWPSTP
	BOUT			;OUTPUT -LENGTH,,ADR
	HLRE 3,2		;SET UP A SOUT COUNT
	HRLI 2,444400		;AND POINTER
	SOUT
	MOVEI 2,0		;APPEND A ZERO AS ENT VECTOR
	BOUT			;FOR IDDT, EXEC MERGE
	CLOSF
	JFCL
	JRST 0(4)

IFN PIESLC,<
;ROUTINE TO MAP PIE-SLICE GROUP DATA FILE

MAPGRP:	MOVSI 1,(1B2+1B17)	;OLD FILE + SHORT FORM
	HRROI 2,GRPFNM
	GTJFN
	 JRST MAPGR2

	PUSH P,1		;SAVE JFN
	MOVEI 2,1B19+1B20+1B25	;READ, WRITE AND THAWED
	OPENF
	 BUG (HLT,<MAPGRP - FAILED TO OPENF PIE-SLICE-GROUP.DATA>)

	MOVSI 4,-NGRPPG
	MOVEI 5,GRPFIL		;ADDRESS TO START MAPPING FILE

MAPGR1:	HRLZ 1,0(P)		;GET JFN
	HRRI 1,0(4)		;FILE PAGE NUMBER
	CALL JFNOFN		;CONVERT JFN,,PN TO OFN,,PN
	 BUG (HLT,<MAPGRP - JFNOFN FAILED ON PIE-SLICE-GROUP.DATA>)

	MOVEI 2,0(5)
	HRLI 2,READB+WRITEB
	CALL SETMPG		;MAP THE PAGE

	ADDI 5,1000
	AOBJN 4,MAPGR1		;GO BACK AND DO NEXT

	SUB P,BHC+1
	AOS PIEFLG		;INDICATE SUCCESSFUL MAPPING
	RET

MAPGR2:	BUG (CHK,<MAPGRP - FAILED TO GTJFN FOR PIE-SLICE-GROUP.DATA>)
	RET

GRPFNM:	ASCIZ /<SYSTEM>PIE-SLICE-GROUP.DATA/
>

	END ; OF SYSINI.MAC

