
TITLE	DCOD11

COMMENT	&
	ATTEMPT TO DECODE PDP-11 BINARY FILES
	
	AS WRITTEN BY LINK11

	4 DEC 75  /RON
	&

DBUGSW __ -1			;FOR VERBOSE TYPE FEATURES...

;ACS

A _ 1
B _ 2
C _ 3
D _ 4

LNG _ 6
BYT _ 7
CNT _ 10
WRD _ 11
WC _ 12
IDX _ 13
LOC _ 14		
N _ 15
N1 _ 16
P _ 17

OPDEF	CALL	[PUSHJ	P,]
OPDEF	PJ	[PUSHJ	P,]
OPDEF	RET	[POPJ	P,]

DEFINE TYPE (MESS) <
	HRROI	1, [ASCIZ &MESS&]
	PSOUT >

DEFINE TYPOCT <
	MOVEI	1, 101
	MOVEI	3, 10
	NOUT
	 CALL	NOUTER >



;VARIABLES

BINPG	__ 10		;PAGE TO MAP BINARY FILE
BINAD	__ BINPG * 1000

DCPG	__ 20		;PAGE FOR DECODED .DMP CODE MAPPING
DCAD	__ DCPG * 1000

INTEGER	BJFN		;BINARY FILE JFN
INTEGER	BPAG		;BINARY FILE PAGE NO.

INTEGER	BLKAD		;ADDRESS OF THIS BLOCK HEADER
INTEGER	BLKNUM		;COUNTER FOR LDA FILES
INTEGER	OBJFLG		;FILE TYPE FLAG
INTEGER	DMPFLG		;WHETHER CODE GOING TO .IMG OR .DMP FORMAT

INTEGER	WRTJFN		;JFN - FLAG IF WRITING
INTEGER	DOSAVE		;FLAG IF THIS BLOCK GETS SAVED
INTEGER	CODBEG		;LOC OF BEGINNING OF CODE
INTEGER	CODLNG		;LENGTH OF CODE
INTEGER	COD.BP		;BYTE POINTER INTO .DMP PAGE(S)
INTEGER	STRTAD		;SAVE STARTING ADR FOR LATER TYPEOUT

INTEGER	FRMLOC		;FOR FILE LOC SAVING
INTEGER	TOLOC

INTEGER	VERBOS		;FLAG FOR LOTS OF OUTPUT
INTEGER	MAKLST		;FLAG IF DOLIST OPTION
INTEGER	LASTRD		;STORAGE CELL

STKSIZ __ 40
ARRAY	STACK	[STKSIZ]

MAXWRD	__ 30			;MOST IN ONE BUFFER
ARRAY	CODE	[MAXWRD]	;CODE BUFFER

INSIZE __ 20
ARRAY	PINBUF	[INSIZE]
INTEGER	TERMCH			;TERMINATING CHAR FROM GETLIN

GETLIN:	SETZM	PINBUF
	MOVE	B, [XWD PINBUF, PINBUF+1]
	BLT	B, PINBUF+INSIZE-1
	MOVEI	1, 101
	RFCOC			;GET CONTROL CHAR CONTROL 
	PUSH	P, 2		;SAVE OLD
	PUSH	P, 3		;SAVE OLD
	TRZ	2, 141400	;DON'T ECHO CR/LF
	TRZ	3, 1400		;OR EOL
	SFCOC
	HRROI	1, PINBUF
	MOVEI	2, INSIZE*5-1
	SETZ	3,
	JSYS	611		;PSTIN
	LDB	3, 1		;GET TERMINATOR
	MOVEM	3, TERMCH	;AND SAVE
	MOVEI	3, 33
	DPB	3, 1		;CLOBBER TERMINATOR WITH ALTMODE
	MOVEI	1, 101
	RFCOC			;GET CONTROL CHAR CONTROL 
	POP	P, 3		;GET OLD
	POP	P, 2		;GET OLD
	SFCOC
	RET


;GET BINARY FILE, MAP FIRST PAGE INTO BINPG
;DEFAULT TO .OBJ EXTENTION

OBJBLK:	XWD 100000, 0		;OLD FILE
	XWD 100, 101		;TERM JFNS
	0		;DEV
	0		;DIR
	0		;NAM
	POINT 7, [ASCIZ /OBJ/]	;EXT
	0		;PROTECTION
	0		;ACCOUNT
	0		;JFN

LDABLK:	XWD 100000, 0		;OLD FILE
	XWD 100, 101		;TERM JFNS
	0		;DEV
	0		;DIR
	0		;NAM
	POINT 7, [ASCIZ /LDA/]	;EXT
	0		;PROTECTION
	0		;ACCOUNT
	0		;JFN


GETBIN:	TYPE	<
IMAGE BINARY FILE: >
	CALL	GETLIN
	MOVEI	1, LDABLK
	SKIPE	OBJFLG
	 MOVEI	1, OBJBLK		;DEFAULT TO .OBJ
	HRROI	2, PINBUF
	GTJFN
	 JRST	GETBIN
	MOVEM	1, BJFN
	MOVE	2, [XWD 440000, 200000]
	OPENF
	 JRST	[TYPE	<
 CAN'T OPEN...>
		 HRRZ	1, BJFN
		 RLJFN
		  HALTF	
		 JRST	GETBIN ]
	SETZ	WC,		;CLEAR WORD COUNT NOW...
	RET			;FINI

;TO GET A WORD FROM FILE
;RETURNS IF OK, ELSE END OF FILE

GETWRD:	MOVE	1, BJFN
	BIN
	MOVE	WRD, 2		;SAVE WORD
	GTSTS
	TLNE	2, 1000		;END OF FILE
	 JRST	FINI		;YEP, ALL DONE
	AOJ	WC,		;COUNT WORD
	CAIGE	WRD, 400	;CHECK WORD VALUE
	 RET
	TYPE	<
FILE NOT IN IMAGE FORMAT, SORRY...
>
	HALTF
	JRST	GO


;GET CODE OUTPUT FILE
;DEFAULT TO .IMG EXTENTION

CODBLK:	XWD 400000, 0		;OUTPUT FILE
	XWD 100, 101		;NO JFNS
	0		;DEV
	0		;DIR
	0		;NAM
	POINT 7, [ASCIZ /IMG/]	;EXT
	0		;PROTECTION
	0		;ACCOUNT
	0		;JFN

DMPBLK:	XWD 400000, 0		;OUTPUT FILE
	XWD 100, 101		;NO JFNS
	0		;DEV
	0		;DIR
	0		;NAM
	POINT 7, [ASCIZ /DMP/]	;EXT
	0		;PROTECTION
	0		;ACCOUNT
	0		;JFN

GETCOD:	TYPE	<
IMAGE CODE OUTPUT FILE: >
	SETZM	WRTJFN		;CLEAR JFN
	CALL	GETLIN		;GET LINE OF INPUT
	SKIPN	PINBUF		;ANY TEXT?
	 RET			;NO, QUIT NOW, NO SKIP
	AOS	(P)		;OK, SKIP
	MOVEI	1, CODBLK
	SKIPE	DMPFLG
	 MOVEI	1, DMPBLK
	HRROI	2, PINBUF
	GTJFN
	 JRST	GETCOD
	MOVEM	1, WRTJFN	;SAVE AS FLAG

	MOVE	2, [XWD 440000, 100000]
	SKIPE	DMPFLG		;SEE IF .DMP AND SET READ ACCESS TOO
	 TRO	2, 200000	;SO WE CAN SEE PMAP PAGES WITH DDT
	OPENF
	 JRST	[TYPE	<
 OPENF ERROR. >
		 HRRZ	1, WRTJFN
		 RLJFN
	 	  HALTF
		 JRST	GETCOD ]
	SKIPN	DMPFLG			;.DMP, PACK 2/WORD?
	 RET
	HRLZ	1, WRTJFN		;SET TO MAP PAGES FROM FILE
	MOVE	2, [XWD 400000, DCPG]	;INTO .DMP CODE AREA
	MOVSI	3, 140000		;READ/WRITE
	MOVEI	CNT, 10			;8 PAGES SHOULD BE PLENTY!!
DMPLUP:	PMAP
	AOJ	1,
	AOJ	2,
	SOJG	CNT, DMPLUP
	MOVE	B, [POINT 16, DCAD+1]	;INIT BYTE POINTER TOO
	MOVEM	B, COD.BP
	RET


;PROGRAM STARTS HERE

GO:	RESET
	MOVE	P, [IOWD STKSIZ, STACK]

	TYPE	<
PDP-11 DECODER / PRINTER.  V 2.1
>
ASKOP:	TYPE	<
 LIST OR GENERATE (L OR G)? >
	SETZM	MAKLST		;CLEAR FLAG
	CALL	GETLIN
	LDB	C, [POINT 7, PINBUF, 6]
	TRZ	C, 40		;HACK THE CASE
	CAIN	C, "L"
	 JRST	DOLIST
	CAIE	C, "G"
	 JRST	ASKOP
	TYPE	<

 GENERATE IMAGE FILE.
>
WHATYP:	TYPE	<
FROM .OBJ OR .LDA (O OR L)? >
	CALL	GETLIN
	LDB	C, [POINT 7, PINBUF, 6]
	TRZ	C, 40		;CASE HACK
	SETZM	OBJFLG
	CAIN	C, "O"
	 JRST	ISOBJ
	CAIE	C, "L"
	 JRST	WHATYP
	CAIA

ISOBJ:	SETOM	OBJFLG
	CALL	GETBIN
	SETOM	BLKNUM
	
GETWRT:	SETZM	WRTJFN
	SETOM	VERBOS		;VERBOSE IF NO OUTPUT

WHTCOD:	TYPE	<
ONTO .IMG OR .DMP (I OR D)? >
	CALL	GETLIN
	LDB	C, [POINT 7, PINBUF, 6]
	TRZ	C, 40		;CASE HACK
	SETZM	DMPFLG
	CAIN	C, "D"
	 JRST	ISDMP
	CAIE	C, "I"
	 JRST	WHTCOD
	CAIA
ISDMP:	 SETOM	DMPFLG		;ONTO .DMP FILE

	CALL	GETCOD		;YES, GET FILE OPENED
	 JRST	HEADER		;NO SKIP IF NO FILE
	SETO	LOC,		;INIT LOC POINTER
	SETZM	CODBEG		;AND BEGINNING
	SETZM	CODLNG		;AND LENGTH
	setZm	DOSAVE		;AND MAKE SURE SAVE IS RESET

	TYPE	<
VERBOSE OUTPUT? >
	CALL	GETLIN
	LDB	C, [POINT 7, PINBUF, 6]
	TRZ	C, 40
	CAIE	C, "Y"
	 SETZM	VERBOS


;HERE TO SCAN FILE, MAKE CODE

HEADER:	CALL	GETWRD
	JUMPE	WRD, HEADER
	CAIE	WRD, 1			;HEADER...
	 JRST	[TYPE	<
 DIDN'T FIND HEADER VALUE 1>
		 JRST	WHERE ]
GETLNG:	CALL	GETWRD
	JUMPE	WRD, GETLNG
	MOVE	LNG, WRD		;SAVE LENGTH
	SETZM	LASTRD
	CAIN	LNG, 6		;LDA START BLOCK?
	 SETOM	LASTRD		;BORROW A WORD FROM PRINTOUT
	SKIPN	VERBOS
	 JRST	GETYPE
	TYPE	<
BLOCK BEGINNING @ >
	MOVE	2, WC
	TYPOCT
	TYPE	<
>	
GETYPE:	SKIPN	OBJFLG
	 JRST	GT0BYT
	CALL	GETWRD			;GET TYPE
	SOJ	LNG,			;COUNT AGAINST LENGTH
	JUMPE	WRD, GETYPE
	SKIPN	VERBOS
	 JRST	NOTTYP
	TYPE	<
   TYPE IS >
	MOVE	2, WRD
	TYPOCT
	TYPE	<
>
NOTTYP:	SETZM	DOSAVE		;CLEAR SAVE ON FILE FLAG
	SKIPN	OBJFLG		;RIGHT NOW WE CAN ONLY SAVE OBJ
	 JRST	DOWRD
	MOVE	BYT, WRD	;SAVE TYPE
GT0BYT:	CALL	GETWRD		;EXTRA?
	SOJ	LNG,
	SKIPN	OBJFLG
	 AOSG	BLKNUM
	CAIN	BYT, 3		;CORE TYPE?
	 SETOM	DOSAVE		;SAVE THIS ONE -- IT'S CODE
DOWRD:	SETZ	IDX,			;CLEAR OFFSET
WRDLUP:	CALL	GETWRD
	SOJ	LNG,
	MOVE	BYT, WRD		;SAVE RH
	CALL	GETWRD
	LSH	WRD, 10			;MOVE OVER 1 BYTE
	IOR 	WRD, BYT		;PUT BACK  OTHER BYTE
	SKIPN	VERBOS
	 JRST	JUSAVE
	TYPE	<
>
	MOVE	2, IDX
	TYPOCT
	TYPE	<:	>
	MOVE	2, WRD
	TYPOCT
		;FALL INTO END OF LOOP

JUSAVE:	SKIPE	DOSAVE			;SAVING THIS ONE
	 MOVEM	WRD, CODE(IDX)		;YEP...
	AOJ	IDX,
	SOJG	LNG, WRDLUP
	SKIPN	VERBOS
	 JRST	CHKSAV
	TYPE	<
END BLOCK
>
CHKSAV:	SKIPN	DOSAVE		;PUT ON FILE?
	 JRST	HEADER			;WAIT FOR NEXT
			;FALL INTO CODE SAVER
	JUMPGE	LOC, SAVCON	;CONTINUE SAVE, START SEEN
	MOVE	LOC, CODE	;ELSE GET FIRST LOC FROM BLOCK
	MOVE	1, WRTJFN	;AND WRITE ON FILE
	MOVE	2, LOC
	SKIPN	DMPFLG		;NOT IT IN .DMP MODE
	 BOUT			;AS FIRST WORD OF FILE
	SKIPE	DMPFLG
	 DPB	LOC, [POINT 16, DCAD, 31]	;AS SECOND WORD OF PMAP
	MOVEM	LOC, CODBEG	;SAVE FOR US TOO
	JRST	SAV1		;AND TO WORK

SAVCON:	SKIPN	OBJFLG		;CHECK IF LDA
	SKIPL	LASTRD		;LAST BLOCK?
	 JRST	SAVC1
	  JRST	FINI		;LET FINI WORRY
	 
SAVC1:	MOVE	C, CODE		;GET LOCATION
	CAIGE	C, (LOC)
	 JRST	[TYPE	<
  FUNNY FORMAT...
   LOCATION OF THIS BLOCK LESS THAN END OF PREVIOUS BLOCK!
>
		 HALTF ]
	CAIG	C, (LOC)	;CHECK WITH OUR CURRENT LOC
	 JRST	SAV1
FILL:	MOVE	1, WRTJFN	;NEED TO FILL IN SOME
	SETZ	2,
	SKIPN	DMPFLG
	 BOUT
	SKIPE	DMPFLG
	 IDPB	2, COD.BP	;INTO PMAP
	AOS	CODLNG
	ADDI	LOC, 2		;CHECK
	CAILE	C, (LOC)
	 JRST	FILL
SAV1:	SUBI	IDX, 3		;3 EXTRA WORDS IN CODE BLOCK
	MOVEM	LOC, FRMLOC
	MOVEI	C, 1		;STARTS AT CODE+1
	MOVE	1, WRTJFN
SAVLUP:	MOVE	2, CODE(C)	;GET WORD
	SKIPN	DMPFLG
	 BOUT
	SKIPE	DMPFLG
	 IDPB	2, COD.BP	;INTO PMAP
	AOS	CODLNG
	MOVEM	LOC, TOLOC
	ADDI	LOC, 2		;ADD TO LOC
	AOJ	C,
	SOJG	IDX, SAVLUP	;COUNT/CHECK/LOOP
	TYPE	<
BLOCK SAVED IN FILE, LOCS >
	MOVE	2, FRMLOC
	TYPOCT
	TYPE	< - >
	MOVE	2, TOLOC
	TYPOCT
	JRST	HEADER		;LOOK FOR NEXT BLOCK


FINI:	HRRZ	1, BJFN		;CLOSE FILES
	JUMPE	1, DONE
	CLOSF
	 CALL	[TYPE	<
 BINARY FILE CLOSF LOZE!
>
		 RET ]
	HRRZ	1, WRTJFN
	JUMPE	1, DONE
	SKIPE	MAKLST
	 JRST	CLSWRT		;NO FANCINESS FOR LIST
	SKIPN	OBJFLG
	SKIPL	LASTRD		;BLOCK LENGTH 6 THIS TIME?
	 JRST	GTSTRT
	MOVE	2, CODE		;GET WORD FROM CODE BLOCK
	JRST	MKST0		;IS STARTING ADR

GTSTRT:	TYPE	<
STARTING ADR? >
	CALL	GETLIN
	SETZ	2,
	SKIPN	PINBUF
	 JRST	MKST0
	HRROI	1, PINBUF
	MOVEI	3, 10
	NIN
	 JRST	GTSTRT
MKST0:	HRRZ	1, WRTJFN
	MOVEM	2, STRTAD
	SKIPN	DMPFLG
	 JRST	CLSIMG
	AOS	4, COD.BP		;GET BYTE POINTER TO NEXT LOC
	ANDI	4, -1			;MAKE LOC
	DPB	2, [POINT 16, (4), 31]	;CHEAP GUARANTEE IT'S IN RH BYTE
	SUBI	4, DCAD-1		;MAKE INTO EOF BYTE COUNT
	CAIL	4, 10000		;CHECK IF TOO BIG
	 JRST	[TYPE	<
 OUTPUT FILE BIGGER THAN 8 PAGES, YOU LOST!!
>
		 HALTF ]
	SETO	1,
	MOVE	2, [XWD 400000, DCPG]
	MOVEI	CNT, 10
UNDMP:	PMAP
	AOJ	2,
	SOJG	CNT, UNDMP
	TLO	1, 400000		;DON'T RELEASE JFN
	CLOSF
	 CALL	[TYPE	<
 .DMP OUTPUT FILE CLOSF LOZE!
>
		 RET ]
	MOVSI	1, 11		;SET BYTE SIZE OF FILE
	HRR	1, WRTJFN
	MOVSI	2, 7700		;BYTESIZE
	MOVSI	3, 4400		;GET OUR BYTE SIZE NOW
	CHFDB
	MOVSI	1, 12		;SET BYTE SIZE OF FILE
	HRR	1, WRTJFN
	SETO	2,		;WHOLE WORD
	MOVE	3, 4		;GET OUR BYTE SIZE NOW
	CHFDB
	ANDI	1, -1		;MAKE JFN
	RLJFN			;AND RELEASE
	 CALL	[TYPE	<
  .DMP RLJFN LOZE!
>
		 RET ]
	JRST	DONE

CLSIMG:	BOUT
CLSWRT:	CLOSF
	 CALL	[TYPE	<
 OUTPUT FILE CLOSF LOZE!
>
		 RET ]
DONE:	TYPE	<
END OF FILE... >
	SETZM	BJFN
	SKIPN	WRTJFN
	 JRST	XXX
	SETZM	WRTJFN
	SKIPE	MAKLST
	 JRST	XXX
	TYPE	<
OUTPUT CODE: >
	MOVE	2, CODLNG
	TYPOCT
	TYPE	< WORDS (>
	MOVE	2, CODLNG
	LSH	2, 1
	TYPOCT
	TYPE	< BYTES), FROM LOC >
	MOVE	2, CODBEG
	TYPOCT
	TYPE	<, SA = >
	MOVE	2, STRTAD
	TYPOCT
	TYPE	<
>
XXX:	HALTF
	JRST	GO


;NOW FOR LISTING STUFF

IMGBLK:	XWD 100000, 0		;OLD FILE
	XWD 100, 101		;TERM JFNS
	0		;DEV
	0		;DIR
	0		;NAM
	POINT 7, [ASCIZ /IMG/]	;EXT
	0		;PROTECTION
	0		;ACCOUNT
	0		;JFN

.DMPBK:	XWD 100000, 0		;OLD FILE
	XWD 100, 101		;TERM JFNS
	0		;DEV
	0		;DIR
	0		;NAM
	POINT 7, [ASCIZ /DMP/]	;EXT
	0		;PROTECTION
	0		;ACCOUNT
	0		;JFN

GETIMG:	TYPE	<
READ IMAGE CODE FILE: >
	CALL	GETLIN
	MOVEI	1, IMGBLK
	SKIPE	DMPFLG
	 MOVEI	1, .DMPBK
	HRROI	2, PINBUF
	GTJFN
	 JRST	GETIMG
	MOVEM	1, BJFN		;DIFFERENT NOW...
	MOVE	2, [XWD 440000, 200000]
	OPENF
	 JRST	[TYPE	<
 CAN'T OPENF FILE.
>
		 HRRZ	1, BJFN
		 RLJFN
		  HALTF
		 JRST	GETIMG ]
	BIN			;GET FIRST WORD NOW
	MOVEM	2, LASTRD
	RET

;READ WORD FROM IMAGE FILE
;ACTUALLY READS 1 WORD BEHIND, SO NO SKIP IF LAST WORD

IMGWRD:	MOVE	1, BJFN
	BIN
	MOVE	WRD, 2		;SAVE WORD
	GTSTS
	EXCH	WRD, LASTRD	;GET LAST, SAVE THIS
	TLNN	2, 1000		;CHECK EOF
	 AOS	(P)		;SKIP ON ALL BUT LAST WORD
	SKIPN	DMPFLG
	CAIGE	WRD, 200000	;CHECK WORDS
	 RET
	TYPE	<
 WORD TOO BIG!
>
	HALTF


;GET OCTAL DUMP LISTING FILE

OCTBLK:	XWD 400000, 0		;OUTPUT FILE
	XWD 100, 101		;TERM JFNS
	0		;DEV
	0		;DIR
	0		;NAM
	POINT 7, [ASCIZ /OCT/]	;EXT
	0		;PROTECTION
	0		;ACCOUNT
	0		;JFN


GETDMP:	TYPE	<
OCTAL DUMP LISTING FILE: >
	CALL	GETLIN
	MOVEI	1, OCTBLK
	HRROI	2, PINBUF
	GTJFN
	 JRST	GETDMP
	MOVEM	1, WRTJFN
	MOVE	2, [XWD 70000, 100000]
	OPENF			;OPEN IN TEXT MODE
	 JRST	[TYPE	<
 OPENF FAILED...
>
		 HRRZ	1, BJFN		
		 RLJFN
		  HALTF	 
		 JRST	GETDMP ]
	HRROI	2, [ASCIZ &

			PDP-11  OCTAL  DUMP
			------  -----  ----
  LOC +     0       2       4       6      10      12      14      16&]
	SETZ	3,
	SOUT

	RET


DOLIST:	TYPE	<

LIST OF IMAGE FILE. 
>
WHTLST:	TYPE	<
.IMG OR .DMP (I OR D)? >
	CALL	GETLIN
	LDB	C, [POINT 7, PINBUF, 6]
	TRZ	C, 40		;CASE HACK
	SETZM	DMPFLG
	CAIN	C, "D"
	 JRST	LISDMP
	CAIE	C, "I"
	 JRST	WHTLST
	CAIA
LISDMP:	 SETOM	DMPFLG		;ONTO .DMP FILE

	SETOM	MAKLST
	CALL	GETIMG		;GET FILES
	CALL	GETDMP

	CALL	IMGWRD		;GET FIRST WORD
	 JRST	[TYPE	<
 FILE OF NO LENGTH!
>
		 JRST	XXX]
	SKIPN	DMPFLG
	 JRST	.IMG1
	LSH	WRD, -4		;MOVE OVER
	ANDI	WRD, 177777	;CLEAN IT UP
.IMG1:	MOVE	LOC, WRD	;GET LOC
	MOVEM	LOC, CODBEG	;AND SAVE
	SETZM	CODLNG
	SETZ	CNT,
LSTLIN:	MOVE	1, WRTJFN
	HRROI	2, [ASCIZ /
/]
	SETZ	3,
	SOUT
	MOVEI	2, (LOC)		;THIS LOC
	MOVE	3, [XWD 100006, 10]	;OCTAL, 7 SPACES
	NOUT
	 JRST	NOUTER
	MOVEI	2, ":"
	BOUT
	MOVEI	IDX, 10
LSTLUP:	SKIPN	DMPFLG
	 JRST	GTWRD
	TRNE	CNT, 1		;ODD WORD?
	 JRST	GETODD
GTWRD:	CALL	IMGWRD
	 JRST	ENDLST
	SKIPN	DMPFLG
	 JRST	EASY
	MOVEM	WRD, COD.BP		;A LITTLE DOUBLE DUTY
	LSH	WRD, -=20		;GET LH BYTE
	JRST	EASY

GETODD:	LDB	WRD, [POINT 16, COD.BP, 31]	;GET RH BYTE FROM SAVED WRD
EASY:	MOVE	1, WRTJFN
	MOVEI	2, 40
	BOUT
	BOUT
	MOVE	2, WRD
	MOVE	3, [XWD 140006, 10]	;LEADING 0'S
	NOUT
	 JRST	NOUTER
	ADDI	LOC, 2
	AOJ	CNT,
	SOJG	IDX, LSTLUP
	JRST	LSTLIN

ENDLST:	MOVE	1, WRTJFN
	HRROI	2, [ASCIZ &

START @ &]
	SETZ	3,
	SOUT
	MOVE	2, WRD
	SKIPE	DMPFLG
	 LSH	2, -4
	MOVEI	3, 10
	NOUT
	 JRST	NOUTER
	HRROI	2, [ASCIZ /
/]
	SETZ	3,
	SOUT
	JRST	FINI



;VARIOUS ERROR ROUTINES

WHERE:	TYPE	<
 FILE WORD COUNT: >
	MOVE	2, WC
	TYPOCT
	TYPE	<
>
	JRST	XXX

NOUTER:	TYPE	<
ERROR ON NOUT!

>
	JRST	XXX

PATCH:	BLOCK 100

END GO

