PLFDEF.MAC;5                       28-Jul-82 17:29     Page 1

     1	;<PUP>PLFDEF.MAC.2, 10-Apr-82 20:55:34, Edit by SCHOEN
     2	; removed USEVAR as it was unnecessary
     3	
     4		universal plfdef
     5		subttl	Definitions for Tenex Leaf implementation
     6		search pupdef
     7	
     8	;	Eric Schoen
     9	;	SUMEX Computer Project
    10	;	Stanford University Medical Center
    11	;	Stanford, CA
    12	;	August, 1981
    13	
    14	;	Work on Leaf and Sequin implementations in Tenex
    15	;	was funded by NIH Biotechnology Resouces Program
    16	;	under grant RR-00785
    17	
    18	; LeafOp definitions
    19	LfErr==0		; LeafError
    20	LfOpen==1		; LeafOpen
    21	LfClos==2		; LeafClose
    22	LfDel==3		; LeafDelete
    23	LfLen==4		; LeafLength (not implemented)
    24	LfTrun==5		; LeafTrunctae (obsolete)
    25	LfRead==6		; LeafRead
    26	LfWrit==7		; LeafWrite
    27	LfRest==10		; LeafReset
    28	LfNop==11		; LeafNop (obsolete)
    29	LfParm==13		; LeafParams
    30	LfProp==14		; GetLeafProp
    31	
    32	
    33	; LeafOpen mode bits
    34	lfo.rd==1b20		; Open read
    35	lfo.wr==1b21		; Open write
    36	lfo.ex==1b22		; Open to extend (i.e. write)
    37	lfo.ml==1b23		; Allow wildcard (not implemented on IFS)
    38	lfo.cr==1b24		; Create a new file
    39	lfo.vn==0b26		; Don't allow an explicit version number
    40	lfo.vo==1b26		; Old file only (not in IFS/Leaf)
    41	lfo.vr==2b26		; Old file or next file (not in IFS/Leaf)
    42	lfo.va==3b26		; Any version number is legal
    43	lfo.dd==0b28		; Expect an explicit version number
    44	lfo.dl==1b28		; Default to lowest version
    45	lfo.dh==2b28		; Default to highest version
    46	lfo.dn==3b28		; Default to next version
    47	lfo.mw==1b31		; Allow multiple writers (not implemented)
    48	
    49	; error codes (these are defined as needed)
    50	erNmMl==^d201		; Malformed file name
    51	erIlVr==^d204		; Illegal version
    52	erAcDn==^d208		; access denied
    53	erFlBz==^d209		; file busy
PLFDEF.MAC;5                       28-Jul-82 17:29     Page 1.1

    54	erNtDl==^d215		; not deletable
    55	erUsrN==^d216		; Bad user name
    56	erUsrP==^d217		; Bad User password
    57	erFilS==^d218		; Files only directory
    58	erConN==^d219		; Bad connect name
    59	erConP==^d220		; Bad connect password
    60	erBkLf==^d1001		; Broken Leaf
    61	erBdLf==^d1010		; Unimplemented Leaf Op
    62	erBdHn==^d1011		; Bad file handle
    63	erIlRd==^d1015		; Illegal Leaf Read
    64	erIlWr==^d1016		; Illegal Leaf Write
    65	
    66	
    67	; Leaf wakeup constants
    68	idle1==1		; wait 1 minute at short delay
    69	idle2==4		; wait four minutes at long delay
    70	shrtd==^d100		; 100 ms short delay
    71	longd==^d1000		; 1 sec long delay
    72	
    73		end


PLFSUP.MAC;3                       28-Jul-82 17:29     Page 2

     1	;<PUP>PLFSUP.MAC.3, 10-Apr-82 20:53:44, Edit by SCHOEN
     2	; PSQVAR, PSQPVF -> TOPVAR, TOPPVR so PUPUUO loads correctly
     3	;<PUP>PLFSUP.MAC	some time ago	Edit by SCHOEN
     4	; Incorporated into Leaf server, C.CNAM,C.CDRN -> CONNUM(CX)
     5	;				 C.UNAM,C.UDRN -> USRNUM(CX)
     6	;<PUP>PUPSUP.MAC.4	1/26/81			Edit by SCHOEN
     7	; Changed TEMP to SFTEMP to avoid conflict with PUPFTP
     8	;<PUP>PUPSUP.MAC.3	1/10/81			Edit by RINDFLEISCH
     9	; Added routines to undelete a file and to set the author for a file
    10	;<PUP>PUPSUP.MAC.2	1/8/81			Edit by RINDFLEISCH
    11	; Made all TENEX/TOPS20 differences come here for resolution
    12	;<PUP>JSIM.MAC.7, 24-Sep-80 23:41:32, Edit by SCHOEN
    13	; Fix bug in CHKALL to handle non-directory files
    14	; Change PPC to MPP in .MENTR, .MRETN
    15	;<PUP>JSIM.MAC.6, 12-Jun-80 16:36:17, Edit by SCHOEN
    16	;<PUP>JSIM.MAC;4  12-Jun-80 12:46:30  Edit by SCHOEN
    17	; Made PS: default for user name specified to .CNPXY
    18	;<PUP>JSIM.MAC.2, 18-Apr-80 16:21:40, Edit by SCHOEN
    19	;<SCHOEN>JSIM.MAC;2     6-Apr-80 08:47:35    EDIT BY SCHOEN
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 3

     1	
     2		TITLE PUPSUP
     3		SUBTTL Simulate some TENEX JSYS's on TOPS20 for PUP code
     4	
     5		SEARCH PUPDEF,PSQDEF,PLFDEF
     6	TENEX,<	SEARCH STENEX >
     7	TOPS20,<SEARCH MONSYM >
     8	
     9	ifndef sumex,<SUMEX==1>
    10	
    11		USEVAR TOPVAR,TOPPVR
    12	
    13		EXTERN CONNUM,USRNUM
    14	
    15		INTERN .cnpsw,.cncon,.cnpxy,.gdacc,.vacct,.cfgrp,.oprfn
    16		INTERN cpydrn,.atpty,.stdir,.stusr,.udelf,.sfust,bkton,bktoff
    17	TOPS20,<		; If TOPS-20 system
    18		INTERN chkwr,chkrd,chkwrd,chkdr
    19	>
    20	
    21	TENEX,<			; If TENEX system
    22	ifn sumex,<
    23	; Macros for 134 accounting JSYS's at SUMEX
    24	opdef	gdacc [pushj p,$gdacc##]
    25	opdef	vacct [pushj p,$vacct##]
    26	>
    27	>
    28	
    29	; macro to define JSYS error returns
    30	define reterr (error,errac<1>),<
    31		jrst  [movei 1,error
    32		       movem 1,errac+pac
    33		       jsr .mretn
    34		       move p,mpp
    35		       ret] 
    36	>
    37	define retgd,<
    38		jsr .mretn
    39		jrst skpret##
    40	>
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 4

     1	
     2	; Standard entry/exit routines for simulated JSYS's
     3	; ac save/restore
     4	; saves/restores 0 - 7
     5	highac==7		;last ac to save
     6	.mentr:	0
     7		movem highAC,pac+highAC
     8		movei highAC,pac
     9		blt highAC,highAC-1+pac
    10		movem p,mpp
    11		jrst @.mentr
    12	
    13	.mretn:	0
    14		movsi highAC,pac
    15		blt highAC,highAC
    16		jrst @.mretn
    17	
    18	ls pac,20
    19	ls mpp
    20	
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 5

     1	
     2	; Implementation of TENEX OPRFN and TOPS-20 SMON functions.
     3	; Entry:   a = sixbit operation code
     4	; Call:    PUSHJ P,.OPRFN
     5	; Return:  +1, error
     6	;	   +2, success
     7	.OPRFN:
     8	TENEX,<			; If TENEX system
     9		OPRFN 			; TENEX, do OPRFN
    10		 POPJ P,		; Error, return +1
    11		JRST SKPRET##
    12	>
    13	TOPS20,<		; If TOPS-20 system
    14		SMON
    15		 ERJMP CPOPJ##		; If error, return +1
    16		JRST SKPRET##
    17	>
    18	
    19	
    20	; Routine to attach JFN's to NVT
    21	; Entry:   a = receive jfn
    22	;	   b = send jfn
    23	; Return:  +1, error
    24	;	   +2, ok
    25	.ATPTY:
    26	TENEX,<			; If TENEX system
    27		ATPTY			; Attach JFNs to NVT
    28		 POPJ P,
    29		JRST SKPRET##
    30	>
    31	TOPS20,<		; If TOPS-20 system
    32		ATNVT			; Attach JFN's to NVT
    33		 ERJMP CPOPJ##		; Failed
    34		JRST SKPRET##
    35	>
    36	
    37	
    38	; Routine to undelete a file
    39	; Entry:   a = file jfn
    40	; Return:  +1, file undeleted
    41	.UDELF:	PUSH P,B		; Save ac's
    42		PUSH P,C
    43		HRLI A,1		; a _ fdbctl,,jfn
    44		MOVSI B,(1B3)		; Change deleted bit
    45		SETZ C,			; To off
    46		CHFDB
    47		POP P,C			; Restore ac's
    48		POP P,B
    49		HRRZS A			; a _ 0,,jfn
    50		POPJ P,
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 6

     1	
     2	; Routine to convert string to directory #.  Makes sure string has <> if
     3	; running on TOPS-20 and does not have <> on TENEX.
     4	; Entry:   b = ptr to directory name string
     5	; Return:  +1, error
     6	;	   +2, b = flags, c = directory #
     7	.STDIR:	
     8	TENEX,<			; If TENEX system
     9		PUSHJ P,BKTOFF		; TENEX, make sure no <>
    10	.STDI1:	SETZ A,			; Exact match required
    11		STDIR			; Look up directory
    12		 JRST CPOPJ##		; Not found, return +1
    13		 JRST CPOPJ##		; Ambiguous, return +1
    14		HLLZ B,A		; Ok, b _ flag bits
    15		HRRZ C,A		; c _ dir #
    16		JRST SKPRET##		; Skip return
    17	>
    18	TOPS20,<		; If TOPS-20 system
    19		PUSHJ P,BKTON		; Be sure brackets are on
    20		MOVSI A,(RC%EMO)	; Exact match required
    21		RCDIR			; Look up directory
    22		 ERJMP CPOPJ##		; Error, return +1
    23	.STDI1:	TLNE A,(RC%NOM)		; No match?
    24		 JRST CPOPJ##		; Return +1
    25		MOVE B,A		; Ok, b _ flags (c = resulting dir #)
    26		JRST SKPRET##		; Skip return
    27	>
    28	
    29	
    30	; Routine to convert string to user #.
    31	; Entry:   b = ptr to user name string
    32	; Return:  +1, error
    33	;	   +2, b = flags, c = user #
    34	.STUSR:
    35	TENEX,<			; If TENEX system
    36		JRST .STDI1		; Do STDIR
    37	>
    38	TOPS20,<		; If TOPS-20 system
    39		MOVSI A,(RC%EMO)	; Exact match required
    40		RCUSR			; Look up directory
    41		 ERJMP CPOPJ##		; Return +1 if error
    42		JRST .STDI1		; Check out the return
    43	>
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 7

     1	
     2	; Routine to ensure <> surround the name string
     3	; Entry:   b = ptr to name str
     4	; Return:  +1, b = ptr to modified string (in SPTEMP if needed)
     5	BKTON:	PUSH P,C		; Save working ac
     6		TLC B,-1		; Be sure ptr is valid
     7		TLCN B,-1
     8		 HRLI B,(<POINT 7,0>)
     9		PUSH P,B		; Save the starting ptr
    10		PUSH P,[0]		; And place for edited str ptr
    11		ILDB C,B		; c _ 1st char
    12		CAIN C,"<"		; Starting bracket?
    13		 JRST BKTDON		; Yes, just return it as is
    14		MOVE A,[POINT 7,ONTEMP]	; No, get a temp area
    15		MOVEM A,0(P)		; Also save as new starting ptr
    16		PUSH P,C		; Save first char
    17		MOVEI C,"<"		; Tack on left bracket
    18		IDPB C,A
    19		POP P,C			; Recover 1st char
    20	BKTON0:	IDPB C,A		; Save it
    21		ILDB C,B		; c _ next char
    22		CAIE C,"<"		; Start of dir field?
    23		CAIN C,":"		; Or colon, as in PS:?
    24		 JRST [ SETZM 0(P)	; Yes, assume he knew what he was doing
    25			JRST BKTDON ]	; Keep the original string
    26		JUMPN C,BKTON0		; Continue to null
    27		MOVEI C,">"		; Install closing bracket
    28		IDPB C,A
    29		MOVEI C,0		; And make it ASCIZ
    30		IDPB C,A
    31		JRST BKTDON
    32	
    33	
    34	; Routine to ensure <> do not surround the name string
    35	; Entry:   b = ptr to name str
    36	; Return:  +1, b = ptr to modified string (in SPTEMP if needed)
    37	BKTOFF:	PUSH P,C		; Save working ac
    38		TLC B,-1		; Be sure ptr is valid
    39		TLCN B,-1
    40		 HRLI B,(<POINT 7,0>)
    41		PUSH P,B		; Save starting ptr
    42		PUSH P,[0]		; And place for ptr to edited string
    43		MOVE A,[POINT 7,OFTEMP]	; Get a temp area
    44		SKIPA
    45	BKTOF0:	 IDPB C,A		; Store a char
    46		ILDB C,B		; c _ next char
    47		CAIN C,"<"		; Start of directory part?
    48		 JRST [ MOVEM A,0(P)	; Yes, save the new ptr
    49			JRST .-2 ]	; Get the next char
    50		CAIE C,">"		; Quit on ending bracket?
    51		JUMPN C,BKTOF0		; Or null
    52		MOVEI C,0		; Terminate string before bracket
    53		IDPB C,A
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 7.1

    54	
    55	; Here to leave things as they are
    56	BKTDON:	SKIPN B,0(P)		; b _ ptr to edited str if set
    57		 MOVE B,-1(P)		; Otherwise, use the original
    58		SUB P,[2,,2]		; Reset the stack
    59		POP P,C			; Recover working ac
    60		POPJ P,
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 8

     1	
     2	; Routine to update the last writer of a file
     3	; Entry:   a = jfn for the file
     4	;	   b = str ptr to new writer
     5	; Return:  +1, writer updated if possible
     6	.SFUST:	TLC B,-1		; Form proper string ptr
     7		TLCN B,-1
     8		 HRLI B,(<POINT 7,0>)
     9		PUSH P,B		; Save the ptr
    10		ILDB C,B		; c _ first string char
    11		POP P,B
    12		JUMPE C,CPOPJ##		; Quit if null string
    13		CAIN C,"@"		; Just host part of name?
    14		 POPJ P,		; Yes, quit too
    15	TENEX,<			; If TENEX system
    16		PUSH P,A		; Save the jfn
    17		MOVE A,[POINT 7,SFTEMP]	; Place for edited string
    18	.SFUS0:	ILDB C,B		; c _ string char
    19		CAIN C,"@"		; Start of host name?
    20		 MOVEI C,0		; Yes, terminate things
    21		IDPB C,A		; Copy char to temp string
    22		JUMPN C,.SFUS0		; Finish the string
    23		HRROI B,SFTEMP		; Now try to convert to user #
    24		PUSHJ P,.STUSR
    25		 JRST [ POP P,A		; No go
    26			POPJ P, ]
    27		POP P,A			; a _ fdbuse,,jfn
    28		HRLI A,6
    29		MOVSI B,-1		; Change lh = author
    30		HRLZS C			; New author
    31		CHFDB			; Change it
    32		HRRZS A			; Leave clean jfn
    33		POPJ P,
    34	>
    35	TOPS20,<		; If TOPS-20 system
    36		HRLI A,.SFLWR		; Set to change last writer
    37		SFUST
    38		ERJMP .+1		; Just ignore errors
    39		HRRZS A			; Leave clean jfn
    40		POPJ P,
    41	>
    42	
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 9

     1	
     2	; CNDIR simulations
     3	
     4	TOPS20,<		; If TOPS-20 system
     5	; ERROR MNEMONICS:
     6	CNDIX1=600200		;invalid password
     7	CNDIX3=600202		;invalid directory #
     8	CNDIX4=600203		;logged in  (strange error)
     9	CNDIX5=600204		;not logged in
    10	>
    11	
    12	; Connect to a directory.  Changes the fork's entry in the
    13	; connected-directory table but not the login table.  Allows connect if
    14	; group privileges sufficient, but does NOT take into account enabled
    15	; status of fork.
    16	; accepts 1/36-bit directory number
    17	;	  2/pointer to password
    18	; returns +1 if failure; ac1 = failure code (tenex CNDIR JSYS code)
    19	; returns +2 if successful.
    20	.cncon:
    21	TENEX,<			; If TENEX system
    22		hrrzs 1			; Be sure TENEX dir # with no flags
    23	.cnco0:	cndir
    24		 popj p,		; No go
    25		jrst skpret##		; Got it
    26	>
    27	TOPS20,<		; If TOPS-20 system
    28		jsr .mentr		;save ACs
    29		tlnn 1,77777
    30		 tlo 1,(1b3)		;if no structure, assume PS:
    31		movsi 3,(1b0)		; Flag to check group privs for password
    32		call .cnchk
    33		 call screwup##
    34		retgd			;leave good
    35	>
    36	
    37	
    38	; routine to implement TENEX CNDIR "proxy login."  Changes entries in
    39	; both connected and login directory tables
    40	; accepts in 1/36-bit directory number
    41	;	     2/pointer to password
    42	; returns +1 on failure, Tenex error code in AC1
    43	; returns +2 on success
    44	.cnpxy:
    45	TENEX,<			; If TENEX system
    46		hrli 1,(1b1)		; 1 _ flag,,dir #
    47		jrst .cnco0		; Do the JSYS
    48	>
    49	TOPS20,<		; If TOPS-20 system
    50		jsr .mentr		; save acs, stack
    51		tlnn 1,77777
    52		 tlo 1,(1b3)		;if no structure, assume PS:
    53		setz 3,			; Don't worry about group privs
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 9.1

    54		call .cnchk		; check password, directory name
    55		 call screwup##		; shouldn't happen
    56		retgd			; leave good
    57	>
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 10

     1	
     2	; routine to check a password. Simulates TENEX CNDIR with B0 in AC1
     3	; accepts 1/36-bit directory number
     4	;	  2/pointer to password
     5	; returns +1 if failure, Tenex error code in ac1
     6	; returns +2 on success
     7	.cnpsw:
     8	TENEX,<			; If TENEX system
     9		hrli 1,(1b0)		; No, 1 _ flag,,dir #
    10		jrst .cnco0		; Do the JSYS
    11	>
    12	TOPS20,<		; If TOPS-20 system
    13		jsr .mentr		; save stats
    14		tlnn 1,77777
    15		 tlo 1,(1b3)		; If no structure, assume PS:
    16		setz 3,
    17		call .cnchk		; check password, dir #
    18		 call screwup##		; shouldn't happen
    19		retgd			; return good
    20	
    21	
    22	; routine to check if connect is possible for this user
    23	; called with 1/36-bit directory #
    24	;	      2/pointer to password
    25	;	      3/special bits:
    26	;		B0 - Check group privileges and don't require
    27	;		     password unless group priv insufficient
    28	.cnchk::call chkdir		;make sure directory exists
    29		 reterr (CNDIX3)	;return with bad directory #
    30		tlne 3,(1b0)		;check group?
    31		 call chkgrp		; yes
    32		  caia			; failed, check password
    33		 jrst skpret##		; succeeded, leave good
    34		call chkpsw		;check password supplied
    35		 reterr (CNDIX1)	;return with bad password
    36		jrst skpret##		; Good
    37	
    38	
    39	; routine to check for legal directory number
    40	; accepts directory # in ac1
    41	; returns +1 on failure, +2 on success
    42	chkdir:	push p,2		; save password pointer
    43		move 2,1
    44		movei 1,.nulio
    45		dirst			; check dir # by DIRSTing to NUL:
    46		 jrst .chk1		; failed
    47		move 1,2		; success, restore acs
    48		pop p,2
    49		jrst skpret##
    50	
    51	.chk1:	pop p,2			; failure, ret +1
    52		ret
    53	>
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 11

     1	
     2	TOPS20,<		; If TOPS-20 system
     3	; routine to check for sufficient privileges for connect
     4	; does NOT consider enabledness as privilege
     5	; accepts 1/36-bit directory number of directory to connect to
     6	;   USRNUM(CX)/current login directory
     7	;   CONNUM(CX)/current connected directory
     8	;
     9	; returns +1 on insufficient privileges for non-password connect
    10	;	  +2 on password unnecessary
    11	chkgrp:	setom chkjfn		; not supplying a JFN in .CKAUD
    12		push p,1
    13		push p,2
    14		movei 2,.charg		; address of CHKAC arg block
    15		movei 1,.ckacn		; check for legal connect
    16		movem 1,.ckaac(2)
    17		move 1,-1(p)		; retrieve .ckaud arg
    18		call chkall
    19		 jrst chkdn1		; return +1
    20		jrst chkdne		; succeed, return +2
    21	
    22		
    23	; routine to check for legal password
    24	; accepts 1/36-bit directory number
    25	;	  2/pointer to password
    26	; returns +1 on illegal password, +2 on password OK
    27	chkpsw:	push p,1
    28		push p,2
    29		call getpsw		; get password from directory
    30		hrroi 1,usepsw		; pointer to directory's psw in 1
    31		stcmp			; compare strings
    32		cain 1,0		; must be exact match
    33		 aos -2(p)
    34		pop p,2
    35		pop p,1
    36		ret
    37		
    38	
    39	; routine to get a directory's password
    40	; returns password in usepsw
    41	; accepts 1/36-bit directory number
    42	; returns +1 always
    43	getpsw:	push p,2		; save password pointer
    44		movsi 2,(cd%psw)
    45		call getdir		; get directory info
    46		pop p,2
    47		ret
    48	>
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 12

     1	
     2	TOPS20,<		; If TOPS-20 system
     3	; routine to get directory data block
     4	; accepts 1/36-bit directory number
     5	;	  2/LH: GTDIR bits (from CRDIR JSYS)
     6	; returns +1 always (or jumps to SCREWUP##)
     7	;	     directory in USRDIR
     8	;	     password, if requested, in usepsw
     9	;	     directory groups, if requested, in USRDGP
    10	;	     user groups, if requested, in USRUGP
    11	;	     default account, if requested, in useact
    12	getdir:	push p,3
    13		push p,4
    14		move 3,[usrdir,,usrdir+1]
    15		setzm usrdir		; Clear the directory buffer
    16		blt 3,usrdir+gtdlen-1
    17		move 3,[usrugp,,usrugp+1]
    18		setzm usrugp		; And the user group table
    19		blt 3,usrugp+gtdlen-1
    20		move 3,[usrdgp,,usrdgp+1]
    21		setzm usrdgp		; And the directory group table
    22		blt 3,usrdgp+gtdlen-1
    23		hrrzi 4,usrdir
    24		hrri 3,gtdlen
    25		hrrzm 3,.cdlen(4)	; set data block length
    26		setz 3,	
    27		tlne 2,(cd%psw)		; want password?
    28		 move 3,[point 7,usepsw]
    29		movem 3,.cdpsw(4)
    30		setz 3,
    31		tlne 2,(cd%ugp)		; want user groups?
    32		 movei 3,usrugp
    33		movem 3,.cdugp(4)
    34		setz 3,
    35		tlne 2,(cd%dgp)		; want directory groups?
    36		 movei 3,usrdgp
    37		movem 3,.cddgp(4)
    38		setz 3,
    39		tlne 2,(cd%dac)		; want default account?
    40		 move 3,[point 7,useact]
    41		movem 3,.cddac(4)
    42		movei 3,10		; up to 10 dir/user groups
    43		tlne 2,(cd%ugp)
    44		 movem 3,usrugp
    45		tlne 2,(cd%dgp)
    46		 movem 3,usrdgp
    47		setz 3,
    48		tlne 2,(cd%psw)
    49		 move 3,usrdir+.cdpsw
    50		exch 4,2
    51		gtdir
    52		 ercal screwup##
    53		tlne 4,(cd%dpt)		; was want directory protection on?
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 12.1

    54		 jrst  [move 3,.cddpt(2)	; put it in safe place
    55			movem 3,usrdpt
    56			jrst .+1]
    57		pop p,4
    58		pop p,3
    59		ret
    60	>
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 13

     1	
     2	; routines to put directory names into strings
     3	; accepts:  1 = dest ptr for string
     4	;	    2 = 36 bit directory number
     5	; both return +1 always
     6	cpydrn:
     7	TOPS20,<		; If TOPS-20 system
     8		 tlz 2,77777		; Yes, make dir # a user number
     9	>
    10		dirst
    11		 call screwup##
    12		ret
    13	
    14	
    15	; routine to simulate TENEX GDACC JSYS
    16	; accepts 1/Address of 8 word string block in which to store
    17	; 	    default account string
    18	;	  2/36-bit directory number (-1 for self)
    19	;returns +1 on failure, error code in AC1
    20	;	 +2 successful
    21	;GDACC ERROR MNEMONICS
    22	GDACX2=601031			; No default account for this user
    23	
    24	.GDACC:
    25	TENEX,<			; If TENEX system
    26		gdacc			; Do the TENEX version
    27		 popj p,
    28		jrst skpret##
    29	>
    30	TOPS20,<		; If TOPS-20 system
    31		jsr .mentr
    32		camn 2,[-1]		; given -1 for directory?
    33		 move 2,usrnum(cx)	; use login directory #
    34		tlnn 2,77777
    35		 tlo 2,(1b3)		; If no structure, assume PS:
    36		push p,1		; save account string destination address
    37		setzm useact		; clear out last account string
    38		move 1,[useact,,useact+1]
    39		blt 1,useact+usrstl/5+1
    40		move 1,2
    41		movsi 2,(cd%dac)
    42		call getdir		; get the account string
    43		skipn useact
    44		 reterr (GDACX2)	; nothing was put there, must be no default
    45		pop p,1			; transfer file to destination block
    46		hrli 1,useact
    47		blt 1,usrstl/5(1)
    48		retgd			; and leave
    49	>
    50	
    51	
    52	; Routine for VACCT JSYS.  For TOPS-20, have to skip return on success.
    53	; Entry:   1 = user #
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 13.1

    54	;	   2 = acct designator
    55	; Return:  +1, error in a
    56	;	   +2, success
    57	.vacct:
    58	TENEX,<			; If TENEX system
    59		vacct			; TENEX JSYS
    60		 popj p,
    61		jrst skpret##
    62	>
    63	TOPS20,<		; If TOPS-20 system
    64		vacct			; Do the JSYS
    65		erjmp cpopj##		; Return +1 on error
    66		jrst skpret##		; And +2 on success
    67	>
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 14

     1	
     2	; routine to simulate TENEX CFGRP JSYS
     3	; currently, no use for this exists in Tops20 implementation,
     4	; so no code is written.
     5	.cfgrp:
     6	TENEX,<			; If TENEX system
     7		cfgrp			; TENEX, do the JSYS
     8		 popj p,		; No go
     9	>
    10		jrst skpret##		; TOPS-20 just returns +2
    11	
    12	
    13	TOPS20,<		; If TOPS-20 system
    14	; routines to check for file access permission
    15	; Since Tops20 PUPSRV doesn't have fork groups, we have to check
    16	; to see if files can be read/written by user
    17	
    18	; routine to check for read access of file
    19	; accepts in 1/ JFN of file
    20	;	USRNUM(CX)/ login user #
    21	;	CONNUM(CX)/ connected directory # of user
    22	; returns +1/ read access not allowed
    23	;	  +2/ read access allowed
    24	
    25	chkrd:	setzm chkjfn
    26		push p,1
    27		push p,2
    28		movei 2,.charg
    29		setzm .ckaac(2)
    30		call chkall
    31		 jrst chkf
    32		jrst chkdne
    33	
    34	; routine to check for directory listing access
    35	; accepts 1/JFN of file
    36	chkdr:	setzm chkjfn
    37		push p,1
    38		push p,2
    39		movei 2,.charg
    40		movei 1,.ckadl
    41		movem a,.ckaac(2)
    42		move 1,-1(p)
    43		call chkall
    44		 jrst chkf
    45		jrst chkdne
    46	>
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 15

     1	
     2	TOPS20,<		; If TOPS-20 system
     3	; routines to check for write access to file
     4	; call chkwrd for directory, chkwr for file
     5	; CHKWR is intended to be called for delete/rename, and CHKWRD for 
     6	;  creating new files in directory
     7	
     8	chkwrd:	setom chkjfn		; means checking directory (dir in 1)
     9		caia
    10	chkwr:	setzm chkjfn		; means checking file (JFN in 1)
    11		push p,1
    12		push p,2
    13		movei 2,.charg
    14		movei 1,.ckawr
    15		skipge chkjfn		; checking directory write privs?
    16		 movei 1,.ckacf
    17		movem 1,.ckaac(2)
    18		move 1,-1(p)
    19		call chkall
    20		 jrst chkf		; failed
    21	chkdne:	aos -2(p)
    22	chkdn1:	pop p,2
    23		pop p,1
    24		ret
    25	
    26	chkf:	movei 1,GJFX35		; say invalid directory access
    27		movem 1,-1(p)
    28		jrst chkdn1
    29		
    30	
    31	; common routine to call CHKAC
    32	; accepts 1/ word to go into .CKAUD in arg block
    33	; .ckaac having already been set up by caller
    34	
    35	chkall:	movem 1,.ckaud(2)	; save dest directory in arg block
    36		move 1,USRNUM(CX)				; And the login user #
    37		movem 1,.ckald(2)
    38		move 1,connum(cx)		; And the connected dir #
    39		movem 1,.ckacd(2)
    40		movsi 1,777000		; standard privilege word
    41		movem 1,.ckaec(2)
    42		setzm .ckapr(2)		; shouldn't need file protection
    43		movei 1,6		; length of arg block
    44		skipl chkjfn
    45		tlo 1,(ck%jfn)		; .CKAUD contains a JFN
    46		chkac
    47		 erjmp chkal1		; failed
    48		jumpe 1,cpopj##		; or not Allowed
    49		jrst skpret##		; return +2
    50	
    51	; here if CHKAC failed
    52	chkal1:	caie 1,ckax4		; file not on disk?
    53		 error <CHKAC failure: %1J> ; not the error, type out a message
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 15.1

    54		seto 1,			; make sure CHKALL succeeds
    55		popj p,			; return
    56	>
PLFSUP.MAC;3                       28-Jul-82 17:29     Page 16

     1	
     2	ls usrlgn,usrstl/5+1		; login directory string
     3	ls usrcdn,usrstl/5+1		; connected directory string
     4	ls sftemp,usrstl/5+2		; Temp string for user name with @ on end
     5	ls oftemp,usrstl/5+2		; Temp for dir string w/o brackets
     6	ls ontemp,usrstl/5+2		; Temp for dir string with brackets
     7	
     8	TOPS20,<		; If TOPS-20 system
     9	ls usepsw,usrstl/5+1		; user password
    10	ls useact,usrstl/5+1		; default account string
    11	ls usrdpt			; directory protection of destination dir
    12	gtdlen==20			; length of GTDIR data block
    13	ls usrdir,gtdlen		; GTDIR data block
    14	ls usrugp,gtdlen		; user group list
    15	ls usrdgp,gtdlen		; directory group list
    16	ls .charg,6			; CHKAC arg block
    17	ls chkjfn			; flag to check JFN or directory in CHKAC
    18	>
    19	
    20		end
    21	


PSQDEF.MAC;9                       28-Jul-82 17:29     Page 2

     1	;<PUP>PSQDEF.MAC.9, 27-Apr-82 21:57:53, Edit by SCHOEN
     2	; Define SQRTRN (Sequin retransmitting)
     3	;<PUP>PSQDEF.MAC.6, 10-Apr-82 20:59:49, Edit by SCHOEN
     4	; PSQVAR, PSQPVR -> TOPVAR, TOPPVR for compatibility with PUPUUO.MAC
     5	;<PUP>PSQDEF.MAC.5,  3-Apr-82 00:12:19, Edit by SCHOEN
     6	; Fix definition of ERCAL for non-Sumex Tenexes so LEAFSV can be
     7	; compiled on Tenex for Tops-20
     8	;<PUP>PSQDEF.MAC.3,  2-Apr-82 10:38:51, Edit by SCHOEN
     9	; Don't search SYSDEF, STENEX, MONSYM
    10	;<SCHOEN>PSQDEF.MAC.5,  4-Dec-81 22:50:35, Edit by SCHOEN
    11	; Define format of Queue Information Block
PSQDEF.MAC;9                       28-Jul-82 17:29     Page 3

     1	
     2		universal Psqdef
     3		subttl	Definitions for Tenex Sequin implementation
     4		search pupdef
     5	
     6	;	Eric Schoen
     7	;	SUMEX Computer Project
     8	;	Stanford University Medical Center
     9	;	Stanford, CA
    10	;	August, 1981
    11	
    12	;	Work on Leaf and Sequin implementations in Tenex
    13	;	and Tops-20 was funded by NIH Biotechnology Resouces 
    14	;	Program	under grant RR-00785
    15	
    16	;	Sequin protocol definitions
    17	;	Control field def'ns
    18	
    19	; AC declarations
    20	
    21	f=0		; flags
    22	
    23	a=1		; temporary accumulators
    24	b=2
    25	c=3
    26	d=4
    27	
    28	sq=5		; sequin data block pointer
    29	cx=6		; connection table index
    30	pb=7		; packet buffer pointer
    31	
    32	p1=10		; permanent accumulators (saved by callers)
    33	p2=11
    34	p3=12
    35	p4=13
    36	p5=14
    37	
    38	fx=16
    39	p=17		; stack pointer
    40	
    41	callf==1b1	; BNTSRV PUSHJ'd to
    42	defntf==1b2	; Recall BNTSRV on exit
    43	inbntf==1b3	; Called SIGBNT from BNTSRV
    44	lgttyf==1b4	; LOG errors to LOGTTY also
    45	
    46	tempf1==1b18	; temp flags
    47	tempf2==1b19
    48	
    49	SeqDat==0	; Packet contains data
    50	SeqAck==1	; Packet is a Sequin acknowledge
    51	SeqNop==2	; Packet is a nop to prevent timeout
    52	SeqRes==3	; Packet requests retransmissions of unacknowledged packets
    53	SeqChk==4	; Obsolete, replaced by SeqNop
PSQDEF.MAC;9                       28-Jul-82 17:29     Page 3.1

    54	SeqOpn==5	; Packet opens a Sequin connection
    55	SeqBrk==6	; Packet indicates user abort
    56	SeqCls==7	; Packet indicates start of orderly exit [obsolete]
    57	SeqCld==10	; Packet acknowledges a SeqCls packet
    58	SeqDes==11	; Causes a connection to close (be destroyed)
    59	SeqDal==12	; Packet causes recvr to wait for SeqQui, or timeout
    60	SeqQui==13	; Packet causes receiver to go away 
    61	SeqBro==14	; Sent before a party dies unexpectedly
    62	
    63	
    64	; Well known sockets and packet types
    65	LeafSk=43			; Leaf listens on well-known socket 43
    66	SeqTyp=260			; Leaf/Sequin Pup type
    67	
    68	;Sequin state codes
    69	CLOS==0				; No open Sequin connection
    70	OPEN==1				; There is an open sequin connection
    71	DLLY==2				; In process of closing a connection
    72	BROK==3				; Broken state
    73	DSTR==4				; Destroyed state
    74	TIMD==5				; Timed-out state
    75	
    76	; Sequin data block format (indexed by sq)
    77	recvsq==0			; receive sequence number
    78	sendsq==1			; send sequence number
    79	seqsta==2			; sequin connection state
    80	seqall==3			; sequin allocations: mine,,his
    81	sqtxcu==4			; dequeue,,enqueue pointers for trans packets
    82	sqrxcu==5			; dequeue,,enqueue points for recvd packets
    83	seqlnh==6			; local net,,host
    84	seqlsk==7			; local socket
    85	seqfnh==10			; foreign net,,host
    86	seqfsk==11			; foreign socket
    87	sqjfnx==12			; port jfn,,connection table index
    88	sqtime==13			; Time at which input timeout occurs
    89	seqout==14			; packets outstanding: mine,,his
    90	leaffk==15			; fork for leaf server
    91	sqblen==leaffk+1
    92	
    93	; format of a queue header block
    94	quptrs==0			; prev,,next buffer
    95	qusize==1			; number of buffers allocated
    96	qucnt==2			; number of buffers used
    97	qulock==3			; lock word for queue
    98	qulckr==4			; FX for locker of queue
    99	lqutab==qulckr+1		; length of queue block
   100	
   101	; bits on the pbstat word of a packet buffer
   102	pNoAck=1b0			; packet has not been acknowledged
   103	
   104	; error codes for sequin interactions
   105	errBro==1000			; sequin broken
   106	errAlc==1001			; no allocation at receiver
PSQDEF.MAC;9                       28-Jul-82 17:29     Page 3.2

   107	errDes==1002			; sequin has been destroyed
   108	errTim==1003			; timeout on Sequin input
   109	
   110	; random defined quantities
   111	MNPLEN==^D22	; Minimum Pup Length (bytes), incl header and checksum
   112	MXPLEN==^D554	; Maximum Pup Length
   113	MNPBLN==<MNPLEN+3>/4  ; Minimum size of PB, in words
   114	MXPBLN==<MXPLEN+3>/4  ; Maximum size of PB, in words
   115	
   116	mxAhed=^d8	; maximum get-ahead in sequences
   117	nconn==^d8	; number of connections
   118	npupbf==mxAhed	; number of buffers in connections
   119	
   120	connt==^d12*^d3600	; connection timeout default is 12 hours
   121	filet==^d10*^d60	; file timeout default is ten minutes
   122	sqtmin==^d20000		; wait twenty seconds for receiver to respond
   123	
   124	ilsloc==300000		; begin local variable storage
   125	elsloc==310000		; end local variable storage
   126	ishloc==320000		; begin thawed storage
   127	eshloc==330000		; end thawed storage
   128	
   129	lstvar==:270000		; lstat storage
   130	lstpvr==:274000
   131	
   132	topvar==:ilsloc		; local storage
   133	toppvr==:elsloc		; local page storage
   134	
   135	pshvar==:ishloc		; fork thawed storage
   136	pshpvr==:eshloc		; fork thawed page storage
   137	
   138	pupbuf==400000		; allocate pup buffers from here
   139	stksiz==100		; pdl size
   140	psisiz==30		; interrupt pdl size
   141	sigchn==1b0		; channel on which to interrupt leaf server 
   142				; for new packet arrival
   143	
   144	define 	noint,<pushj p,.noint>
   145	define	okint,<pushj p,.okint>
   146	
   147	ifn ft10x,<
   148	ifndef ercal,<
   149	; this is for non-Sumex Tenexes
   150	opdef	ercal	[pushj 17,]
   151	>
   152	>
   153	; flags in left half of f
   154	sqrtrn==1b4			; Sequin retransmitting
   155	
   156		end
   157	


PSVLEF.MAC;33                      28-Jul-82 17:29     Page 2

     1	;<PUP>PSVLEF.MAC.33, 15-Jun-82 12:40:40, Edit by SCHOEN
     2	; Make sure $closf clears out JFNTAB and WILDFT if it closes and releases
     3	; the JFN, else just clear out RH of these table entries
     4	;<PUP>PSVLEF.MAC.25,  7-Jun-82 14:47:02, Edit by SCHOEN
     5	; $CLOSF senses unopened files, and does RLJFN instead.
     6	; CHKHDL returns +2 for legal, unopened JFN, +3 for legal, opened JFN
     7	; Add PROPL3 routines to GTJFN file (but not open it) for prop list functions
     8	; CHKVER with b0 of p3 on doesn't open file
     9	; Add Size (byte count) to list of known properties
    10	;<PUP>PSVLEF.MAC.24,  4-Jun-82 18:51:20, Edit by SCHOEN
    11	; Begin adding Property List functions
    12	;<PUP>PSVLEF.MAC.23,  3-May-82 16:14:54, Edit by SCHOEN
    13	; GETPTR was computing bytepointers incorrectly
    14	;<PUP>PSVLEF.MAC.16, 27-Apr-82 22:59:38, Edit by SCHOEN
    15	; Make the server wakeup mechanism more efficent (and complicated)
    16	;<PUP>PSVLEF.MAC.15, 23-Apr-82 11:56:18, Edit by SCHOEN
    17	; Make sure proper byte count gets set when EOF bit on in LeafWrite
    18	;<PUP>PSVLEF.MAC.14, 22-Apr-82 11:05:13, Edit by SCHOEN
    19	; Add log dump to background loop
    20	;<PUP>PSVLEF.MAC.13, 11-Apr-82 22:25:05, Edit by SCHOEN
    21	; Add LFINIT table to signal server fork ready to run
    22	;<PUP>PSVLEF.MAC.12, 11-Apr-82 21:59:53, Edit by SCHOEN
    23	; Check for Sequin received queue being empty before dismissing LEAFSV
    24	; interrupt; repeat service code if queue non-empty.
    25	;<PUP>PSVLEF.MAC.11, 10-Apr-82 20:52:20, Edit by SCHOEN
    26	; PSQVAR, PSQPVR -> TOPVAR, TOPPVR so PUPUUO.MAC loads correctly
    27	;<PUP>PSVLEF.MAC.10,  9-Apr-82 14:02:19, Edit by SCHOEN
    28	; LOGBFS was supposed to be in units of words, not pages!
    29	;<PUP>PSVLEF.MAC.8,  1-Apr-82 12:38:38, Edit by SCHOEN
    30	; Don't search SYSDEF; PUPDEF was compiled with SYSDEF
    31	;<PUP>PSVLEF.MAC.7, 31-Mar-82 17:14:09, Edit by SCHOEN
    32	; Use BYTCNT(JFN) in READLF to determine whether read is past EOF 
    33	;<PUP>PSVLEF.MAC.5, 31-Mar-82 16:05:18, Edit by SCHOEN
    34	; Replace SHRVAR mechanism with proper use of USEVAR
    35	;<PUP>PSVLEF.MAC.4, 31-Mar-82 15:15:17, Edit by SCHOEN
    36	; Keep track of file byte count during write operations, since paged
    37	; I/O in Tenex/Tops-20 does not update EOF pointer.
    38	;<PUP>PSVLEF.MAC.3, 18-Mar-82 13:37:26, Edit by SCHOEN
    39	; HRRZ 1,FILVER -> HRR 1,FILVER at GETJFN+5. Don't wipe out GTJFN flags
    40	;<SCHOEN>PSVLEF.MAC.79, 28-Feb-82 15:29:53, Edit by SCHOEN
    41	; replace ! in list of version leadin.  "OPENFILE(FOO.BAR;T)"
    42	; on dolphin causes it to look for FOO.BAR!T.
    43	;<SCHOEN>PSVLEF.MAC.78, 28-Feb-82 15:11:22, Edit by SCHOEN
    44	; Make PRSFIL understand attributes in file names
    45	; Remove ! from list of version leadins
    46	;<SCHOEN>PSVLEF.MAC.77, 25-Feb-82 11:09:33, Edit by SCHOEN
    47	; [Tops20] Make CHKACC return proper error codes in A
    48	;<SCHOEN>PSVLEF.MAC.76, 20-Feb-82 17:38:26, Edit by SCHOEN
    49	; Make MAPDAT extern, wait for system to have date/time before
    50	; starting.
    51	;<SCHOEN>PSVLEF.MAC.75, 17-Feb-82 15:26:22, Edit by SCHOEN
    52	; Fix RIFSST to handle odd length strings correctly (dumb!)
    53	;<SCHOEN>PSVLEF.MAC.73,  3-Feb-82 14:53:42, Edit by SCHOEN
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 2.1

    54	; Mapdat at very start of program
    55	;<SCHOEN>PSVLEF.MAC.72, 27-Jan-82 12:20:15, Edit by SCHOEN
    56	; Use JFNTAB to scan through locked files
    57	;<SCHOEN>PSVLEF.MAC.71, 27-Jan-82 00:33:35, Edit by SCHOEN
    58	; Protect AOBJN pointer during jfn scanning in UNLOCK 
    59	;<SCHOEN>PSVLEF.MAC.69,  3-Jan-82 13:32:58, Edit by SCHOEN
    60	; Close the correct connection on reset of a Resethosts op
    61	; Clear interrupt system on server fork crash
    62	;<SCHOEN>PSVLEF.MAC.64, 14-Dec-81 19:14:08, Edit by SCHOEN
    63	; Log server fork crashes, check for BNTLCK unlocked if last locked by
    64	; dismissing fork, unlock BNTLCK if server fork crashes with it locked
    65	;<SCHOEN>PSVLEF.MAC.63, 14-Dec-81 15:18:19, Edit by SCHOEN
    66	; Load the byte size of a file out of the proper ac
    67	; Clean up stack in RestLf when login fails
    68	;<SCHOEN>PSVLEF.MAC.61, 13-Dec-81 23:18:14, Edit by SCHOEN
    69	; More work on the leader page bookkeeping
    70	;<SCHOEN>PSVLEF.MAC.57, 11-Dec-81 14:44:54, Edit by SCHOEN
    71	; Illegal instruction trap causes the server fork to restart itself
    72	;<SCHOEN>PSVLEF.MAC.45, 10-Dec-81 10:20:33, Edit by SCHOEN
    73	; Make a fake leader page out of Twenex FDB, redirect RSIN/RSOUT
    74	; to work on the leader page if a negative byte address is given
    75	;<SCHOEN>PSVLEF.MAC.41,  4-Dec-81 23:02:54, Edit by SCHOEN
    76	; Strip out CR->CRLF conversion...messes up Lisp's byte count
    77	; for random access I/O.  Also return to default 8-bit binary files.
    78	;<SCHOEN>PSVLEF.MAC.40, 23-Nov-81 11:53:39, Edit by SCHOEN
    79	; Convert CR to CRLF in text mode files
    80	; Default file type (i.e. byte size) to text (7-bit)
    81	;<SCHOEN>PSVLEF.MAC.38, 19-Nov-81 23:31:32, Edit by SCHOEN
    82	; Don't recheck passwords if login/connect name doesn't change
    83	;<SCHOEN>PSVLEF.MAC.36, 18-Nov-81 15:12:55, Edit by SCHOEN
    84	; trap IFS leader page munging of file type to set byte size
    85	; make bytsiz a per JFN quantity, make JFN tables shared.
    86	; Clean up some error messages and JSYS error <-> IFS error pairs
    87	; Don't replace extension terminator by "!" anymore
    88	;<SCHOEN>PSVLEF.MAC.31,  9-Nov-81 11:26:04, Edit by SCHOEN
    89	; Made PUPFNH extern
    90	;<SCHOEN>PSVLEF.MAC.30,  6-Nov-81 16:18:27, Edit by SCHOEN
    91	; Don't log rec'd LeafReads unless debugging
    92	;<SCHOEN>PSVLEF.MAC.28,  6-Nov-81 11:03:34, Edit by SCHOEN
    93	; remember that $closf skip returns 
    94	;<SCHOEN>PSVLEF.MAC.26,  2-Nov-81 14:27:39, Edit by SCHOEN
    95	; Finish implementing ResetHosts mechanism in LeafReset
    96	;<SCHOEN>PSVLEF.MAC.22, 21-Oct-81 20:13:57, Edit by SCHOEN
    97	; Make sure GNJFN mode of OpenLf closes previous file before
    98	; opening the next one.
    99	;<SCHOEN>PSVLEF.MAC.20,  9-Oct-81 12:44:01, Edit by SCHOEN
   100	; Add wildcard feature to OpenLf:
   101	;	First call to OpenLf can have a file with
   102	;	wildcards in it.  The file of the group
   103	;	is returned.
   104	;
   105	;	Succeeding calls to OpenLf can have LSB
   106	;	of Open mode word set, meaning "do a GNJFN."
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 2.2

   107	;	In this case, user/connect name/password and
   108	;	filename strings are not checked.
   109	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 3

     1		title	psvlef
     2		subttl	Tenex/Tops-20 Leaf Server
     3		search	pupdef,psqdef,plfdef 
     4		usevar	topvar,toppvr,pshvar,pshpvr
     5	
     6	tenex,<	search stenex >
     7	tops20,<search monsym>
     8	
     9	
    10	;	Eric Schoen
    11	;	SUMEX Computer Project
    12	;	Stanford University Medical Center
    13	;	Stanford, CA.
    14	;	November, 1981
    15	
    16	;	Work on Leaf and Sequin implementations in Tenex
    17	;	and Tops-20 was funded by NIH Biotechnology Resouces 
    18	;	Program under grant RR-00785
    19	
    20	
    21	stksiz==100
    22	lflpdl==100		; leaf pdl
    23	njfn==150		; size of jfn table
    24	loglat==^D<5*60>	; max logging latency, seconds
    25	logbfs==2000		; size of logging buffer (words)
    26	
    27	ps%dev=1b35	; seen a device
    28	ps%dir=1b34	; seen a directory
    29	ps%nam=1b33	; seen a name
    30	ps%ext=1b32	; seen an extension
    31	ps%ver=1b31	; seen a version
    32	ps%drs=1b30	; seen the start of a directory
    33	ps%atr=1b29	; seen at least one attribute
    34	
    35		extern	connum,usrnum,contab,.okint,.noint,pbhead,connfk
    36		extern	ppupsn,ppupsh,ppupss,ppupdn,ppupdh,ppupd0,ppupd1
    37		extern	pupfnh,bntlck,bntlkr
    38	
    39	lsp pmadr,1		; page for PMAP I/O
    40	pmpag==pmadr/1000
    41	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 4

     1		subttl	startup
     2	
     3	srvstt::
     4	start:	reset
     5		gtad
     6		camn a,[-1,,-1]
     7		 jrst [movei a,^D5000
     8		       disms
     9		       jrst .-2]
    10		jsp fx,mapdat##		; map high core to a thawed file
    11		seto fx,		; top fork
    12		move p,[iowd stksiz,stack]
    13		setz f,
    14		tlo f,(debugf)		; assume debugging
    15	tenex,<
    16		gjinf		; detached?
    17		skipge d
    18		 jrst  [move a,[sixbit/LOGDES/]
    19			sysgt
    20			movei a,(b)
    21			hrli a,1
    22			getab
    23			hrls a
    24			move b,a
    25			movei a,400000
    26			spjfn
    27			tlz f,(debugf)		; not debugging
    28			jrst .+1]
    29	>
    30	tops20,<
    31		seto a,
    32		hrroi b,d
    33		movei c,.jicpj
    34		getji		; get controlling job number
    35		 ercal screwup
    36		aose d		; are we controlled?
    37		 tlz f,(debugf) ; yes, don't debug
    38	>	
    39		 
    40		pushj p,inilog	; init logger
    41		log <LEAFSV: Leaf server restarting...>
    42		seto a,		; make a server
    43		pushj p,seqini##; init sequin
    44		log <LEAFSV: Leaf server running>
    45	
    46	; Background loop here
    47	leafsl:	setob cx,fx	; so we can tell when this routine calls BNTSRV
    48		movei a,^d5000	; go to sleep for a time
    49		disms
    50		pushj p,bntsrv##; run the Sequin background process
    51		time
    52		caml a,logtim	; time to dump log?
    53		 pushj p,dmplog	; yes, dump it	 
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 4.1

    54		jrst leafsl
    55	
    56	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 5

     1		subttl	IFS String Utilities
     2	
     3	; routine to convert an ASCIZ string to an IFS String
     4	; Call: pushj p,wifsst
     5	;	a/ 16 bit bytepointer to Leaf packet being written
     6	;	b/ Tenex string pointer to an ASCIZ string
     7	; Returns: +1 always, a,b updated
     8	wifsst::push p,c		; save c and d
     9		push p,d			
    10		tlc b,-1
    11		tlcn b,-1
    12		 hrli b,(point 7)
    13		ibp a			; point to string length
    14		push p,a		; save pointer to length
    15		tlc a,(30b11)		; convert to 8 bit
    16		setz d,			; zero count
    17	wifss1:	ildb c,b		; get a character
    18		jumpe c,wifss2		; leave if done
    19		idpb c,a		; deposit into IFS string
    20		aoja d,wifss1
    21	
    22	wifss2:	exch a,(p)		; interchange current pointer w/original
    23		dpb d,a			; save string length
    24		pop p,a			; retrieve string pointer
    25		trne d,1		; odd number of bytes?
    26		 idpb c,a		; yes, deposit a garbage byte
    27		tlc a,(30b11)		; make back into 16 bit bytes again
    28		pop p,d			; retrieve acs
    29		pop p,c
    30		popj p,			; return
    31	
    32	; routine to convert an ASCIZ string to a BCPL String
    33	; Call: pushj p,wbcpst
    34	;	a/ 16 bit bytepointer to Leaf packet being written
    35	;	b/ Tenex string pointer to an ASCIZ string
    36	; Returns: +1 always, a,b updated
    37	wbcpst::push p,c		; save c and d
    38		push p,d			
    39		tlc b,-1
    40		tlcn b,-1
    41		 hrli b,(point 7)
    42		tlc a,(30b11)		; convert to 8 bit
    43		ibp a			; point to string length
    44		push p,a		; save pointer to length
    45		setz d,			; zero count
    46	wbcps1:	ildb c,b		; get a character
    47		jumpe c,wbcps2		; leave if done
    48		idpb c,a		; deposit into IFS string
    49		aoja d,wbcps1
    50	
    51	wbcps2:	exch a,(p)		; interchange current pointer w/original
    52		dpb d,a			; save string length
    53		pop p,a			; retrieve string pointer
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 5.1

    54		trnn d,1		; even number of bytes?
    55		 idpb c,a		; yes, deposit a garbage byte
    56		tlc a,(30b11)		; make back into 16 bit bytes again
    57		pop p,d			; retrieve acs
    58		pop p,c
    59		popj p,			; return
    60	
    61	
    62	; Routine to convert an IFS String to an ASCIZ string
    63	; Call: pushj p,riffst
    64	;	a/ Tenex string pointer
    65	;	b/ 16-bit byte pointer to an IFS string (such that
    66	;	   one IBP would point to the character bytes)
    67	; Returns: +1, always
    68	;	a,b updated
    69	rifsst::push p,c		; save c and d
    70		push p,d
    71		tlc a,-1		; Convert tenex pointer to hardware pointer
    72		tlcn a,-1
    73		 hrli a,(point 7,)
    74		ildb d,b		; Get count
    75		tlc b,(30b11)		; convert to 8 bit bytes
    76		jumpe d,rifss2		; if done, go to leave
    77		push p,d		; save original length
    78	rifss1:	ildb c,b		; else get byte
    79		idpb c,a		; save in string
    80		sojn d,rifss1
    81	
    82	rifss2:	idpb d,a		; null off terminating byte
    83		pop p,d			; get original length of string
    84		trne d,1		; was it odd?
    85		 ibp b			; yes, increment BP past garbage byte
    86		pop p,d			; retrieve d
    87		pop p,c			; retrieve c
    88		tlc b,(30b11)		; make pointer 16 bits again
    89		popj p,			; return
    90	
    91	; Routine to compute the number of 16-bit bytes between two 16-bit 
    92	; bytepointers
    93	; Call: pushj p,cmplen
    94	;	a/ 1st bytepointer 
    95	;	b/ 2nd bytepointer
    96	; Returns: +1 always, with the magnitude of the difference in a
    97	;	   b/ lesser bytepointer
    98	; WARNING! DOES NOT WORK WITH INDEXED OR INDIRECT BYTEPOINTERS!!!
    99	cmplen:	push p,c		; save c and d
   100		push p,d	
   101		push p,5		; save 5 also
   102		hrrz 5,a
   103		caige 5,(b)
   104		 exch a,b		; make sure a.ge.b
   105		hrrz 5,a
   106		subi 5,(b)
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 5.2

   107		lsh 5,1			; compute # of 16 bit bytes from PDP10 words
   108		move c,[point 3,b,2]	; look at position
   109		ldb d,c
   110		lsh d,-1
   111		xct [jfcl
   112		     aoj 5,
   113		     addi 5,2](d)	; adjust for position within word
   114		move c,[point 3,a,2]	; look at greater byte now
   115		ldb d,c
   116		lsh d,-1
   117		xct [jfcl
   118		     soj 5,
   119		     subi 5,2](d)	; adjust for position in word
   120		movm a,5
   121		pop p,5
   122		pop p,d
   123		pop p,c
   124		popj p,
   125	
   126	; routine to compare ASCIZ strings
   127	; call: pushj p,strcmp
   128	;	a/ pointer to string 1
   129	;	b/ pointer to string 2
   130	; returns: +1, strings are different
   131	;	   +2, strings match
   132	strcmp:	push p,c
   133		push p,d
   134		tlc a,-1
   135		tlcn a,-1
   136		 hrli a,(point 7)
   137		tlc b,-1
   138		tlcn b,-1
   139		 hrli b,(point 7)
   140	strcm1:	ildb c,a
   141		caige c,"a"
   142		 caia
   143		caile c,"z"
   144		 caia
   145		trz c,40
   146		ildb d,b
   147		caige d,"a"
   148		 caia
   149		caile d,"z"
   150	 	 caia
   151		trz d,40
   152		caie c,(d)
   153		 jrst [pop p,d
   154		       pop p,c
   155		       popj p,]
   156		jumpn c,strcm1
   157		pop p,d
   158		pop p,c
   159		aos (p)
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 5.3

   160		popj p,
   161	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 6

     1		subttl	Leaf server fork, one per connection
     2	
     3	; call: SFORK at LEAF, with at least SQ, CX set up
     4	leaf::	move p,[iowd lflpdl,lfpdl]
     5		move fx,connfk(cx)	; get fork index
     6		move a,[3,,lfint]
     7		movem a,chntab##	; make channel 0 be the channel to wake on
     8		move a,[1,,srvcrs]	; set up illegal instruction trap
     9		movem a,chntab##+^d15
    10		movei a,400000
    11		move b,[levtab##,,chntab##]
    12		sir
    13		eir
    14		move b,[sigchn+1b15]
    15		aic
    16		
    17	
    18	; Server fork wakeup mechanism:
    19	; Much efficiency is gained by reducing context swap overhead.
    20	; This code attempts to reduce the amount of work the top fork
    21	; must do to start the server fork running.  
    22	;
    23	; If the server fork has been active within the last IDLE1 minutes,
    24	; the fork dismisses for SHRTD milliseconds if its input queue is
    25	; empty.
    26	;
    27	; If the fork has been idle for between IDLE1 and IDLE2 minutes,
    28	; the fork dismisses for LONGD ms on an empty input queue.
    29	;
    30	; After IDLE2 minutes, the server fork goes to sleep (via WAIT).
    31	;
    32	; If the fork is asleep or waiting for LONGD ms, it sets a flag
    33	; telling the superior fork that it is OK for the superior to
    34	; interrupt it when it has data in the queue.
    35	
    36	; here to wait for Leaf packets
    37	leaflp:	hrrzs leaffk(sq)	; make this fork uninterruptable
    38		time			; compute time to go to delayed wakeup
    39		add a,[idle1*^d60*^d1000]
    40		move c,a
    41		movei d,shrtd		; start with short disms
    42	leafl1:	move a,sqrxcu(sq)	; scan queue
    43		skipe qucnt(a)		; anything in the queue?
    44		 jrst leafgo		; yes, go
    45		movei a,(d)
    46	lfwai1:	disms
    47		time
    48		camge a,c		; go to delayed wakeup?
    49		 jrst leafl1
    50		caie d,shrtd
    51		 jrst lfslep		; timed out on long dismiss; go to sleep
    52		movei d,longd		; go to delayed wakeup
    53		hrros leaffk(sq)	; say it's OK to interrupt
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 6.1

    54		add a,[idle2*^d60*^d1000] ; compute time to go to sleep at
    55		move c,a
    56		jrst leafl1
    57	
    58	; Here when no activity for SHRTD+LONGD ms
    59	lfslep:	
    60	lfwait:	wait
    61	
    62	; Here when interrupted by superior fork
    63	lfint:	hrrz a,lev3pc##		; get PC of interrupt
    64		soj a,
    65		cain a,lfwai1		; at the DISMS?
    66		 movei a,lfwait		; yes, make believe we were WAITing
    67		caie a,lfwait		; were we waiting?
    68		 debrk			; no, just debrk, then
    69		movei a,leafgo		; yes, start the server fork
    70		movem a,lev3pc##	
    71		debrk
    72	
    73	leafgo:	pushj p,leafsv
    74		jrst leaflp
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 7

     1	
     2	; here when the fork crashes
     3	srvcrs:	move a,lev1pc##		; get crash address
     4		soj a,			; adjust
     5		elog <Server fork %16O crashed: Illegal instruction at %1O>
     6		skipl bntlck		; BNTLCK locked?
     7		 jrst [came fx,bntlkr	; By us?
     8			jrst .+1	; No
     9		       setom bntlck	; Yes, unlock it
    10		       jrst .+1]
    11		cis			; Clear interrupts and restart process
    12		jrst leaf
    13		
    14	; here when Sequin connection receives a packet destined for me
    15	; call: Signal interrupt on channel 0
    16	; 	sq,cx/  set up
    17	; returns: +1, always
    18	leafsv::move a,sqrxcu(sq)	; see if anything waiting
    19		skipn 2(a)
    20		 jrst [movei a,(cx)
    21		       log <Connection %1O awakened with empty input queue>
    22		       popj p,]
    23		tlne f,(debugf)
    24		 movem cx,leafcx	; save connection if debugging
    25		push p,p1		; save p1
    26		push p,p2		; and p2
    27		push p,p4
    28	leafs0:	movei a,LeafPk
    29		pushj p,inpSeq##
    30		 jrst leafsx
    31		move p1,a		; save number of bytes in this packet
    32		move p2,[point 16,Leafpk]; point to received packet
    33	
    34	Leafs1:	move p5,p2		; save pointer to start of packet
    35		ildb a,p2		; get leafOpCode
    36		move p4,a		; save opcode for errors
    37		ldb c,[point 10,a,35]	; get length
    38		subi p1,(c)		; adjust byte count for this packet
    39		ldb c,[point 5,a,24]	; get opcode from packet
    40		caile c,maxOp		; less than the maximum defined opcode?
    41		 jrst LfOpEr		; no, send a BuddingLeaf
    42		pushj p,@LfOpTb(c)	; dispatch
    43		tlnn f,(debugf)
    44		 jrst Leafs2
    45		came cx,leafcx		; if debugging, make sure cx still the same
    46		 jrst [push p,a
    47		       push p,b
    48		       movei b,(cx)
    49		       hrrz a,leafcx
    50		       elog <CX clobbered! Should be %1O, but is %2O>
    51		       pushj p,screwup##]
    52	Leafs2:	jumpg p1,Leafs1	
    53	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 7.1

    54	Leafsx:	move a,sqrxcu(sq)	; anything in the queue?
    55		skipe 2(a)		; check queue count
    56		 jrst leafs0	 	; yes, go again
    57		pop p,p4
    58		pop p,p2
    59		pop p,p1
    60		skipl bntlck		; Trace unreleased BNTLCKs
    61		 jrst [came fx,bntlkr	; Locked by us?
    62			jrst .+1	; No
    63		       setom bntlck	; Yes, release it then
    64		       movei a,(cx)
    65		       log <BNTLCK left locked by connection %1O, releasing...>
    66		       jrst .+1]
    67		popj p,
    68	
    69	define lfdisp(subr),<
    70	ifdef subr,<subr>
    71	ifndef subr,<LFOpEr>
    72	>
    73	LfOpTb:	LfOpEr			; Servers don't like seeing LeafError
    74		lfdisp <OpenLf>		; LeafOpen
    75		lfdisp <ClosLf>		; LeafClose
    76		lfdisp <DeleLf>		; LeafDelete
    77		lfdisp <LfOpEr>		; LeafLength
    78		lfdisp <TrunLf>		; LeafTruncate
    79		lfdisp <ReadLf>		; LeafRead
    80		lfdisp <WritLf>		; LeafWrite
    81		lfdisp <RestLf>		; LeafReset
    82		lfdisp <NopLf>		; LeafNop
    83		lfdisp <LfOpEr>		; no opcode
    84		lfdisp <ParmLf>		; LeafParams
    85		lfdisp <PropLf>		; Get Leaf Prop list
    86	maxOp=.-LfOpTb-1
    87	
    88	; routine top clean up a leaf connection being closed
    89	; call: pushj p,cleanf
    90	;	cx/ set up for this connection
    91	; returns: +1, always
    92	cleanf::movsi c,-njfn
    93	clnf1:	skipe jfntab(c)		; is there a jfn here?
    94		 pushj p,clnf2		; yes, close if ours
    95		aobjn c,clnf1		; loop through jfn table
    96		setzm connum(cx)	; done with jfns, undo login
    97		setzm usrnum(cx)
    98		popj p,
    99	
   100	clnf2:	hlrz b,jfntab(c)	; get owning connection
   101		caie b,(cx)		; this connection?
   102		 popj p,
   103		movei a,(c)
   104		push p,a
   105		tlo a,(1b0)
   106		pushj p,$closf		; yes, close it
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 7.2

   107		 jrst [caie a,CLSX1	; file not open?
   108			type <CLEANF: CLOSF error: %1J>
   109		       jrst .+1]
   110		pop p,a
   111		rljfn
   112		 type <CLEANF: RLJFN error: %1J>
   113		popj p,
   114	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 8

     1		subttl	Leaf Errors
     2	
     3	; routine to return a BuddingLeaf error when an undefined LeafOp received
     4	; call: pushj p,LfOpEr
     5	;	c/ OpCode
     6	; returns: +1, always
     7	; clobbers a,b,c,d
     8	LfOpEr:	movei a,erBdLf		; budding leaf error
     9		move b,c
    10		setz c,
    11		pushj p,ErrLf		; send a leaf error
    12		popj p,
    13	
    14	; routine to send a leaf Error
    15	; call: pushj p, ErrLf
    16	;	a/ error subcode
    17	;	b/ optional string pointer to human readable text
    18	;	c/ error filehandle
    19	;	p4/ error opcode
    20	; returns: +1, always
    21	; clobbers a,b,c,d
    22	; note: if a is greater than 600000, then it is assumed to be a JSYS
    23	; error number.  In this case, it is mapped into a standard IFS error
    24	; number.
    25	ErrLf:	move d,[point 16,LfAnPk,31]
    26		cail a,600000		; what type of error?
    27		 pushj p,jstifs		; convert JSYS error to IFS code
    28		dpb a,d
    29		idpb p4,d
    30		idpb c,d
    31		movei c,(a)
    32		move a,d
    33		cain b,0
    34		 pushj p,IFSdf		; try to find a string for this error
    35		caie b,0
    36		 pushj p,wifsst		; write string into packet
    37		movei b,(cx)
    38		log <ERRLF: Sending Leaf error %3D for connection %2O>
    39		move b,[point 16,LfAnPk]
    40		setz c,
    41		pushj p,LeafOp
    42		popj p,
    43	
    44	; routine to convert Tenex/Tops-20 JSYS error number of IFS number
    45	; call: a/ JSYS error
    46	; returns: +1, always, a/ IFS error code if found, else 0
    47	jstifs:	push p,c
    48		hrroi b,temp
    49		write b,<%1J>		; do ERSTR on JSYS error code
    50		movsi b,-njsifs		; loop through table
    51	jstif1:	hrrz c,jsifst(b)	; get a jsys error
    52		cain c,(a)		; is it ours?
    53		 jrst [hlrz a,jsifst(b)	; yes, get IFS code
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 8.1

    54		       jrst jstif2]
    55		aobjn b,jstif1		; no, loop
    56		setz a,
    57	jstif2:	pop p,c			; found it or didn't find it
    58		hrroi b,temp
    59		popj p,
    60	
    61	; table of JSYS error <-> IFS error correspondance
    62	jsifst:	^d202,,GJFX4		; illegal char
    63		^d205,,GJFX5		; input field too large
    64		^d201,,GJFX6		; too many device fields
    65		^d201,,GJFX7		; too many directory fields
    66		^d201,,GJFX8		; no closing direcory broket
    67		^d201,,GJFX9		; too many name fields
    68		^d201,,GJFX10		; non-numeric version
    69		^d201,,GJFX11		; two version fields
    70		^d201,,GJFX12		; two account fields
    71		^d207,,GJFX16		; no such device
    72		^d210,,GJFX17		; no such direcory
    73		^d207,,GJFX18		; no such file name
    74		^d207,,GJFX19		; no such extension
    75		^d207,,GJFX20		; no such version
    76		^d207,,GJFX24		; old file required
    77		^d214,,GJFX27		; old file not allowed
    78		^d203,,GJFX31		; illegal *
    79		^d203,,GJFX32		; empty directory and * given
    80		^d202,,GJFX34		; unquoted ? in name
    81		^d208,,GJFX35		; read access not allowed
    82		^d209,,OPNX1		; file already open
    83		^d207,,OPNX2		; file doesn't exist
    84		^d208,,OPNX3		; read access not allowed
    85		^d208,,OPNX4		; write access not allowed
    86		^d209,,OPNX9		; file busy
    87		^d211,,OPNX10		; no room
    88	njsifs==.-jsifst
    89	
    90	; Routine to find supply a human-readable string to correspond
    91	; with an IFS error number
    92	; call: pushj p,IFSdf
    93	;	c/ IFS error number
    94	; returns: +1, always, error number in c, string pointer to string in b
    95	; 	       or 0 if not found
    96	IFSdf:	push p,a
    97		push p,b
    98		movsi a,-nIFSdf		; prepare to loop through table
    99	IFSdf0:	hlrz b,IFSdft(a)	; get IFS error
   100		cain c,(b)		; found it?
   101		 jrst IFSdf1		; yes
   102		aobjn a,IFSdf0		; no loop
   103		setzm (p)		; not found, return 0 in b
   104		pop p,b
   105		pop p,a
   106		popj p,
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 8.2

   107	
   108	; here when IFS error found
   109	IFSdf1:	hrro b,IFSdft(a)	; pick up string pointer
   110		pop p,(p)
   111		pop p,a			; clean stack
   112		popj p,
   113	
   114	; table of IFS error <-> Human readable string correspondance
   115	IFSdft:	^d116,,[asciz/Illegal combination of lookup bits./]
   116		^d201,,[asciz/Malformed filename./]
   117		^d202,,[asciz/Illegal character in filename./]
   118		^d203,,[asciz/Illegal use of "*"./]
   119		^d204,,[asciz/Illegal version number./]
   120		^d205,,[asciz/Filename too long./]
   121		^d206,,[asciz/Not allowed to access Directory Information File./]
   122		^d207,,[asciz/File not found./]
   123		^d208,,[asciz/File is protected - access denied./]
   124		^d209,,[asciz/File open in conflicting way - file busy./]
   125		^d210,,[asciz/No such directory./]
   126		^d211,,[asciz/Page allocation exceeded./]
   127		^d212,,[asciz/The disk is full!/]
   128		^d213,,[asciz/CreateDiskStream failed - disk error?/]
   129		^d214,,[asciz/Rename "to" file already exists./]
   130		^d215,,[asciz/File is not deletable./]
   131		^d216,,[asciz/Illegal user-name./]
   132		^d217,,[asciz/Incorrect user-password./]
   133		^d218,,[asciz/Can't login as files-only directory./]
   134		^d219,,[asciz/Illegal connect-name./]
   135		^d220,,[asciz/Incorrect connect-password./]
   136		^d1001,,[asciz/Timeout has occurred -- connection broken./]
   137		^d1010,,[asciz/Operation not implemented./]
   138		^d1011,,[asciz/Illegal leaf handle./]
   139		^d1012,,[asciz/File too long./]
   140		^d1013,,[asciz/Illegal leaf truncate./]
   141		^d1015,,[asciz/Illegal leaf read./]
   142		^d1016,,[asciz/Illegal leaf write./]
   143	nIFSdf==.-IFSdft
   144	
   145	; routine to advance pointer to start of next LeafOp
   146	; call: p2/opcode of current packet
   147	;	p5/pointer to start of current packet
   148	; returns: +1, always, p2 updated
   149	flseop:	push p,a
   150		push p,b
   151		ldb a,[point 10,p2,35]	; get length in bytes
   152		lsh a,-1		; convert to words
   153		idivi a,2		; see how many PDP10 words it spans
   154		move p2,p5		; get pointer to start of current packet
   155		addi p2,(a)		; adjust EA
   156		caie b,0		; b is either 0 or 1
   157		ibp p2			; odd number of words, increment pointer
   158		pop p,b
   159		pop p,a
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 8.3

   160		popj p,
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 9

     1		subttl	Send Leaf Answer
     2	; Routine to finish up LeafOpAnswer and send it
     3	; Call: pushj p,leafOp
     4	; a/ current 16 bit bytepointer to packet
     5	; b/ 16 bit pointer to start of packet, must be 442000,,x form
     6	; c/ LeafOp to use
     7	; Returns: +1, always
     8	; Clobbers a,c
     9	
    10	leafOp:	push p,b		; save packet org
    11		pushj p,cmplen
    12		lsh a,1			; convert to 8-bit bytes
    13		lsh c,^d11
    14		tro c,1b25		; make this an Answer
    15		iori a,(c)
    16		idpb a,b
    17		andcmi a,(c)
    18		lsh a,-1		; convert to 16 bit bytes	
    19		movsi a,(a)		; put length into left half
    20		hrr a,(p)
    21		setz b,			; Send a Sequin data
    22		pushj p,senSeq##	; send it off
    23		pop p,b			; recover packet org
    24		popj p,
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 10

     1		subttl	Login
     2	
     3	; routine to do login
     4	; call: pushj p,.login
     5	;	p2/ 16-bit pointer to packet, pointing at user name
     6	;	a/ B0: don't try connect
     7	; returns: +1, failure, LeafError in a
     8	;	   +2, success, usrnum(cx), connum(cx) filled in
     9	.login:	movem p,loginp		; save p incase of error
    10		push p,a		; save a
    11		hrroi a,temp
    12		move b,p2
    13		pushj p,rifsst		; convert string to asciz
    14		move p2,b		; save updated pointer
    15	ifn ft10x,<
    16		movei a,1		; try to parse name
    17		hrroi b,temp
    18		stdir
    19		 jfcl
    20		 jrst [movei a,erUsrN	; failure in user name
    21		       jrst .logf]
    22		tlne a,(1b0)		; files only?
    23		 jrst [movei a,erFils	; yes, fail
    24		       jrst .logf]
    25		movei a,(a)		; save dir number
    26		push p,a		; save directory number
    27		hrroi a,temp		; read password from packet
    28		move b,p2
    29		pushj p,rifsst
    30		move p2,b		; save updated pointer
    31		move a,(p)		; recover directory number
    32		camn a,usrnum(cx)	; same as before?
    33		 jrst [pop p,a
    34		       jrst .logs]	; skip proxy login
    35		hrroi b,temp		; try to do a proxy login
    36		hrli a,(1b1)
    37		cndir
    38		 jrst [movei a,erUsrP	; user password incorrect?
    39		       jrst .logf]
    40		pop p,a			; recover directory number
    41		movem a,usrnum(cx)	; save user number
    42	> ; end ifn ft10x
    43	
    44	ifn ft20,<
    45		movsi a,(rc%emo)	; match name exactly
    46		hrroi b,temp
    47		rcusr			; convert to user number
    48		 erjmp jerr##
    49		tlne a,(rc%nom!rc%amb)	; no match or ambiguous?
    50		 jrst [movei a,erUsrN	; fail
    51		       jrst .logf]
    52		camn c,usrnum(cx)	; same as before?
    53		 jrst [hrroi a,temp	; yes, read password to advance pointer
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 10.1

    54		       move b,p2
    55		       pushj p,rifsst
    56		       move p2,b
    57		       jrst .logs]
    58		push p,c		; else save user number
    59		move a,c		; and prepare for GTDIR
    60		tlo a,(1b3)		; convert to PS: 
    61		movei b,temp		; get directory password
    62		hrroi c,temp+20
    63		gtdir
    64		hrroi a,temp		; read password from packet
    65		move b,p2
    66		pushj p,rifsst
    67		move p2,b		; save updated pointer
    68		hrroi a,temp
    69		hrroi b,temp+20
    70		pushj p,strcmp		; compare strings
    71		 jrst [movei a,erUsrP	; password failed
    72		       jrst .logf]
    73		pop p,a
    74		movem a,usrnum(cx)	; save directory as login and connected
    75		tlo a,(1b3)		; make into a PS: directory number
    76	> ; end ifn ft20
    77		movem a,connum(cx)
    78		pop p,a
    79		jumpl a,.logx		; if no connect check, leave now
    80		
    81	; now attempt to connect, if possible and necessary
    82	; also end up here if no change in login directory
    83	.logs:	push p,p2		; save pointer
    84		ildb a,p2		; read length of connect string
    85		jumpe a,[ibp p2		; no connect name, incr past password block
    86			 pop p,(p)	; clean stack
    87			 jrst .logx]	; leave
    88		pop p,p2		; recover connect name pointer
    89		move b,p2
    90		hrroi a,temp
    91		pushj p,rifsst		; read connect name
    92		move p2,b		; save updated pointer
    93	ifn ft10x,<			; see if directory exists
    94		pushj p,fixcon		; fix if necessary
    95		move b,a		; prepare to STDIR
    96		movei a,1
    97		stdir
    98		 jfcl
    99		 jrst [movei a,erConN	; connect name failure
   100		       jrst .logf]
   101		camn a,connum(cx)	; same as before?
   102		 jrst .logcx		; yes
   103		push p,a		; save directory number
   104	>; ifn ft10x
   105	ifn ft20,<
   106		pushj p,fixcon		; fix string if necessary
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 10.2

   107		move b,a
   108		movsi a,(rc%emo)
   109		rcdir			; translate
   110		 ercal jerr##
   111		tlne a,(rc%nom!rc%amb)
   112		 jrst [movei a,erConN
   113		       jrst .logf]	; fail on error
   114		camn c,connum(cx)	; same as before?
   115		 jrst .logcx		; yes
   116		push p,c		; save number
   117	>; ifn ft20
   118		hrroi a,temp
   119		move b,p2
   120		pushj p,rifsst		; read connect password
   121		move p2,b
   122		pop p,a			; recover connect directory number
   123	
   124		pushj p,chkcon		; try to connect
   125		 jrst [movei a,erConP	; no, failed
   126		       jrst .logf]
   127		movem a,connum(cx)	; save connected directory number
   128		jrst .logx		; and leave
   129	
   130	; here on error
   131	.logf:	move p,loginp		; recover p
   132		setzb c,b		; no human string
   133		pushj p,errLf		; send error answer
   134		popj p,
   135	
   136	; here when connect name hasn't changed
   137	; advance pointer past password string
   138	.logcx:	hrroi a,temp
   139		move b,p2
   140		pushj p,rifsst		; swallow password string
   141		move p2,b
   142	; fall through...
   143	
   144	; here to exit successfully
   145	.logx:	move p,loginp		; recover p
   146		aos (p)			; succeed 
   147	ifn ft10x,<
   148		hrrz a,usrnum(cx)
   149		hrrz b,connum(cx)
   150		movei c,(cx)
   151		log <.LOGIN: Login user %1U%74I%2U%76I on connection %3O>
   152	>
   153	ifn ft20,<
   154		move a,usrnum(cx)
   155		move b,connum(cx)
   156		movei c,(cx)
   157		log <.LOGIN: Login user %1U, %2U on connection %3O>
   158	>
   159		popj p,			; leave
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 10.3

   160	
   161	ls loginp,1			; storage for P on entering .login
   162	
   163	; routine to fix a connect directory for brokets
   164	; call: pushj p,fixcon
   165	; 	string in temp
   166	; returns: +1, always, pointer to fixed string in A
   167	; clobbers b
   168	ifn ft20,<
   169	fixcon:	move a,[point 7,temp]	; look for a left broket
   170	fixc0:	ildb b,a
   171		cain b,74		; found one?
   172		 jrst [hrroi a,temp	; yes, leave
   173		       popj p,]
   174		jumpn b,fixc0		; loop until end of string
   175	; here if ran out of string
   176		hrroi a,temp+20		; copy string with brokets
   177		hrroi b,temp
   178		write <%74I%2S%76I>	; will add brokets around string
   179		hrroi a,temp+20
   180		popj p,
   181	> ;end ifn ft20
   182	ifn ft10x,<
   183	fixcon:	move a,[point 7,temp]
   184		ildb b,a
   185		caie b,74		; left broket?
   186		 jrst [hrroi a,temp	 
   187		       popj p,]		; no, leave
   188	fixc1:	ildb b,a		; loop until end or right broket
   189		cain b,76
   190		 jrst [setz b,
   191		       dpb b,a		; null of right broket
   192		       move a,[point 7,temp,6]
   193		       popj p,]
   194		jumpn b,fixc1
   195		move a,[point 7,temp,6]
   196		popj p,
   197	> ;end ifn ft10x
   198	; routine to try to connect
   199	; call: pushj p,chkcon
   200	; 	a/ target directory number in a
   201	; returns: +1, failure
   202	;	   +2, success
   203	ifn ft10x,<
   204	chkcon:	movei a,(a)		; clear STDIR flags
   205		push p,a
   206		tlo a,(1b1)		; do proxy GFACC
   207		hrrz 3,usrnum(cx)	; get user number
   208		gfacc
   209		trne a,1b32		; need a password?
   210		 jrst [pop p,a		; no, recover dir
   211		       setz b,
   212		       cndir		; do the connect
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 10.4

   213			caia		; failed
   214		       aos (p)
   215		       popj p,]
   216		pop p,a
   217		hrroi b,temp
   218		cndir			; connect if possible
   219		 caia			; failed, assume password invalid
   220		aos (p)
   221		popj p,
   222	>
   223	ifn ft20,<
   224	chkcon:	push p,a			; save dir number
   225		tlo c,(1b0)
   226		pushj p,.cnchk##		; from PUPSUP
   227		 skipa
   228		aos -1(p)
   229		pop p,a
   230		popj p,
   231	>	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 11

     1		subttl	LeafOpen
     2	
     3	; routine to open a file
     4	; call: p2/ 16-bit pointer to received request (ILDB gets first word after
     5	;	    opcode)
     6	; returns: +1, always, p2 updated
     7	OpenLf:	movei a,(cx)
     8		log <OPENLF: LeafOpen received for connection %1O>
     9		ildb b,p2		; get file handle incase this is GNJFN
    10		push p,p3
    11		ildb p3,p2		; get open mode
    12		trne p3,1		; is this a GNJFN-like operation?
    13		 jrst [movei c,(b)	; check valildity of JFN presented
    14		       pushj p,chkhdl
    15			jrst [pop p,p3  ; not good, bail out
    16			      jrst flseop]
    17			jfcl		; file not open, that's OK
    18		       movei b,(c)	; recover JFN
    19		       movei a,(b)
    20		       tlo a,(1b0)	; don't release JFN
    21		       pushj p,$closf	; close the file
    22			jfcl
    23		       move a,wildft(b); get jfn and flags
    24		       gnjfn
    25			jrst errLf	; error
    26		       movei a,(a)	; clear LH flags
    27		       pushj p,chkven	; open the file
    28		       pushj p,flseop	; flush extra words if necessary
    29		       jrst openL1]	; rejoin rest of LeafOpen code
    30	
    31		jumpn b,[movei c,(b)	; try to open a file if non-0 handle supplied
    32			 pushj p,chkhdl
    33			  jrst [pop p,p3  ; not good, bail out
    34			        jrst flseop]
    35			 skipa		; not open, good
    36			  jrst  [movei a,erFlBz  ; file busy
    37				 hrroi b,[asciz/Attempt to open file already open!/]
    38				 pushj p,errLf
    39			         pop p,p3
    40				 jrst flseop]
    41			 movei a,(c)
    42		         pushj p,chkven	; open the file
    43		         pushj p,flseop	; flush extra words if necessary
    44		         jrst openL1]	; rejoin rest of LeafOpen code
    45	
    46	; none of the above, a new file supplied.  Do login and parse filename
    47		pushj p,.login		; try to log in
    48		 jrst [pop p,p3
    49		       jrst flseop]
    50	 	hrroi a,temp		; logged in; read file name
    51		move b,p2
    52		pushj p,rifsst
    53		move p2,b
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 11.1

    54		pushj p,prsfil		; parse the file name
    55		 jrst [movei a,erNmMl	; error, malformed name
    56		       hrroi b,[asciz/Malformed name/]
    57		       setz c,
    58		       pushj p,errLf	; send error
    59		       pop p,p3		; recover p3
    60		       popj p,]
    61		pushj p,chkver		; Check mode bits, open file
    62		 jrst [setzb b,c
    63		       pushj p,errLf	; send of error
    64		       pop p,p3
    65		       popj p,]
    66	OpenL1:	movem b,jfntab(a)	; save openf bits
    67		hrlm cx,jfntab(a)	; tag whose connection it belongs to
    68		movei b,(a)
    69		move a,[point 16,LfAnPk]; build reply packet
    70		ibp a			; increment past opcode field
    71		idpb b,a		; put jfn in reply
    72		push p,a		; get byte count
    73		movei a,(b)
    74		move b,bytcnt(a)	; get EOF
    75		exch a,(p)		; recover packet pointer
    76		rot b,-^d16		; deposit high bits
    77		idpb b,a
    78		rot b,^d16
    79		idpb b,a		; deposit low bytes
    80		setz b,
    81		idpb b,a		; this word is ignored
    82		move b,[point 16,LfAnPk]
    83		movei c,LfOpen		; respond
    84		pushj p,Leafop		; do it
    85		pop p,a			; get JFN
    86		pushj p,makldr		; make a leader page
    87		pop p,p3
    88		popj p,			; return
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 12

     1		subttl	LeafOpen Utilities
     2	
     3	; routine to parse filename (in TEMP)
     4	; call: pushj p,prsfil
     5	; returns: +1, bad file name detected
     6	; 	   +2, file name parsed, FILDEV, FILDIR, FILNAM, FILEXT, FILVER
     7	;	       filled in
     8	;	       Flags (see above) in RH of F set accordingly
     9	prsfil:	setzm fildev		; clear strings
    10		setzm fildir
    11		setzm filnam
    12		setzm filext
    13		setzm filver
    14		setzm filflg		; flag word
    15		setzm filprt		; protection
    16		trz f,ps%dev!ps%dir!ps%nam!ps%ext!ps%ver!ps%drs!ps%atr
    17		move a,[point 7,temp]	; start reading
    18	prsfi0:	move b,[point 7,temp+40]; temp storage
    19		setz d,			; field length counter
    20	
    21	prsfi1:	ildb c,a		; get a character
    22		cain c,":"		; device terminator?
    23		 jrst prsdev		; yes, save device
    24		cain c,74		; start of directory?
    25		 jrst prsdrs		; yes, check some flags
    26		cain c,76		; end of directory?
    27		 jrst prsdir
    28		cain c,"."		; name or extension terminator?
    29		 jrst prsdot
    30		cain c,";"		; Tenex extension terminator
    31		 jrst prssmi
    32		cain c,"!"		; IFS version leadin?
    33		 jrst prssmi		; removed 2/28/82.  Dolphin supposed to know
    34		idpb c,b
    35		jumpe c,prsfi2		; at end of string, see what we've got
    36		aoja d,prsfi1
    37	
    38	; here when device terminator seen
    39	prsdev:	jumpe d,cpopj		; fail if a bare ":" seen
    40		trne f,ps%dev!ps%dir!ps%nam ;already seen a device, dir, or name?
    41	cpopj:	 popj p,		; fail
    42		setz c,			; else terminate string
    43		idpb c,b
    44		hrroi c,fildev
    45		move b,[point 7,temp+40]; copy into device
    46		write c,<%2S>
    47		tro f,ps%dev		; say we've seen a device
    48		jrst prsfi0		; continue
    49	
    50	; here when start of directory seen	 
    51	prsdrs:	trne f,ps%drs!ps%dir!ps%nam ; already seen dir start, dir, or name?
    52		 popj p,		; fail
    53		tro f,ps%drs		; say seen start
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 12.1

    54		jrst prsfi0		; continue
    55	
    56	; here when end of directory seen
    57	prsdir:	jumpe d,cpopj		; fail if nothing in directory
    58		trnn f,ps%drs		; seen the start of the directory?
    59	 	 popj p,		; no, die
    60		setz c,			; null off dir string
    61		idpb c,b
    62		hrroi c,fildir
    63		move b,[point 7,temp+40]
    64		write c,<%2S>
    65		trc f,ps%drs!ps%dir	; say seen directory
    66		jrst prsfi0		; continue
    67	
    68	; here when a "." seen
    69	prsdot:	trne f,ps%drs		; in the middle of a directory?
    70		 jrst [idpb c,b		; dot is ok, then
    71		       aoja d,prsfi1]	; continue through loop
    72		trnn f,ps%nam		; seen a name field, yet?
    73		 jrst [setz c,		; no, then this is name. terminate
    74		       idpb c,b		
    75		       hrroi c,filnam	; and copy
    76		       move b,[point 7,temp+40]
    77		       write c,<%2S>
    78		       tro f,ps%nam	; say seen name
    79		       jrst prsfi0]	; go for extension
    80		trnn f,ps%ext		; seen extension yet?
    81		 jrst [setz c,		; no, then this is ext. terminate
    82		       idpb c,b		
    83		       hrroi c,filext	; and copy
    84		       move b,[point 7,temp+40]
    85		       write c,<%2S>
    86		       tro f,ps%ext	; say seen extension
    87		       jrst prsfi0]	; go for version
    88		popj p,			; no dots after seeing name and extension
    89	
    90	; here when a semicolon encountered
    91	prssmi:	trnn f,ps%nam		; seen a name yet?
    92		 jrst [setz c,		; no, then this is name. terminate
    93		       idpb c,b		
    94		       hrroi c,filnam	; and copy
    95		       move b,[point 7,temp+40]
    96		       write c,<%2S>
    97		       tro f,ps%nam	; say seen name
    98		       tro f,ps%ext	; and also extension (foo;1 => foo.;1)
    99		       jrst prsfi0]	; go for version
   100		trnn f,ps%ext		; seen an extension?
   101		 jrst [setz c,		; no, then this is ext. terminate
   102		       idpb c,b		
   103		       hrroi c,filext	; and copy
   104		       move b,[point 7,temp+40]
   105		       write c,<%2S>
   106		       tro f,ps%ext	; say seen extension
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 12.2

   107		       jrst prsfi0]	; go for version
   108	
   109	; must be a version or an attribute
   110		move a,[point 7,temp+40]
   111		ildb b,a		; get first character of version
   112	
   113		caige b,"a"		; uppercase it, incase it's a character
   114		 caia
   115		caile b,"z"
   116		 caia
   117		trz b,40
   118	
   119		cain b,"*"		; wildcard version?
   120		 jrst [hrrei b,-3	; store numeric equivalent
   121		       movem b,filver
   122		       trne f,ps%atr	; seen any attributes, yet?
   123		        popj p,		; yes, version is illegal
   124		       tro f,ps%ver	; say seen version
   125		       jrst prsfi0]
   126		cain b,"-"		; numeric special (-1, -2, -3)?
   127		 jrst [movei c,^d10	; try to read a number
   128		       nin
   129			popj p,		; not a number, die
   130		       caig b,3		; something other than 1, 2, or 3?
   131			popj p,		; incorrect, die
   132		       movns b
   133		       trne f,ps%atr	; seen any attributes, yet?
   134		        popj p,		; yes, version is illegal
   135		       movem b,filver	; save version
   136		       tro f,ps%ver	; say we have a version
   137		       jrst prsfi0]
   138		caige b,"0"
   139		 jrst prsatr
   140		caile b,"9"
   141		 jrst prsatr
   142	
   143		trne f,ps%atr		; seen any attributes
   144		 popj p,		; yes, die
   145		move a,[point 7,temp+40]
   146		movei c,^d10		; else explicit version?
   147		nin
   148		 popj p,		; bad number
   149		movem b,filver		; save version
   150		tro f,ps%ver		; say we have a version
   151		jrst prsfi0
   152	
   153	prsatr:	pushj p,doattr		; parse attributes
   154		 popj p,		; unknown attribute
   155		jrst prsfi0		; parse agai
   156	
   157	; routine to parse file name attributes.
   158	; currently understands ;S, ;T, ;P
   159	; call: pushj p, doattr
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 12.3

   160	;	b/ attribute character
   161	; returns: +1, unknown attribute
   162	;	   +2, attribute known
   163	doattr:	cain b,"T"		; temp?
   164		 jrst [movsi b,(1b5)
   165		       iorm b,filflg
   166		       tro f,ps%atr
   167		       aos (p)
   168		       popj p,]
   169		cain b,"S"		; scratch?
   170		 jrst [movsi b,(1b14)
   171		       iorm b,filflg
   172		       tro f,ps%atr
   173		       aos (p)
   174		       popj p,]
   175		cain b,"P"		; protection
   176		 jrst [movei c,^d8	; try to read a number
   177		       nin
   178			popj p,		; not a number, die
   179		       movem b,filprt	; save version
   180		       tro f,ps%atr
   181		       aos (p)
   182		       popj p,]
   183		popj p,			; semicolon in version is illegal (for now)
   184	
   185	; here when string ends
   186	prsfi2:	trne f,ps%drs		; was a started dir ever ended?
   187		 popj p,		; no, die
   188		trnn f,ps%nam		; name seen?
   189		 jrst [setz c,		; no, then this is name. terminate
   190		       idpb c,b		
   191		       hrroi c,filnam	; and copy
   192		       move b,[point 7,temp+40]
   193		       write c,<%2S>
   194		       tro f,ps%nam	; say seen name
   195		       tro f,ps%ext	; and also extension (foo;1 = foo.;1)
   196		       jrst prsfi4]	; 
   197		trnn f,ps%ext		; seen an extension?
   198		 jrst [setz c,		; no, then this is ext. terminate
   199		       idpb c,b		
   200		       hrroi c,filext	; and copy
   201		       move b,[point 7,temp+40]
   202		       write c,<%2S>
   203		       tro f,ps%ext	; say seen extension
   204		       jrst prsfi4]	; go for version
   205	; if here, string must have ended with version or attribute
   206		move a,[point 7,temp+40]
   207		ildb b,a		; get first character of version
   208	
   209		caige b,"a"		; uppercase it, incase it's a character
   210		 caia
   211		caile b,"z"
   212		 caia
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 12.4

   213		trz b,40
   214	
   215		caige b,"0"
   216		 caia
   217		caile b,"9"
   218		 jrst [pushj p,doattr
   219		       popj p,
   220		      jrst prsfi4]
   221		trne f,ps%ver!ps%atr	; seen a version or attribute?
   222		 popj p,		; can't have two versions or ;attr;version
   223		cain b,"*"		; wildcard version?
   224		 jrst [hrrei b,-3	; store numeric equivalent
   225		       movem b,filver
   226		       tro f,ps%ver	; say seen version
   227		       jrst prsfi4]
   228		cain b,"-"		; numeric special (-1, -2, -3)?
   229		 jrst [movei c,^d10	; try to read a number
   230		       nin
   231			popj p,		; not a number, die
   232		       caig b,3		; something other than 1, 2, or 3?
   233			popj p,		; incorrect, die
   234		       movns b
   235		       movem b,filver	; save version
   236		       tro f,ps%ver	; say we have a version
   237		       jrst prsfi4]
   238		move a,[point 7,temp+40]
   239		movei c,^d10		; else explicit version?
   240		nin
   241		 popj p,		; bad number
   242		movem b,filver		; save version
   243		tro f,ps%ver		; say we have a version
   244		
   245	prsfi4:	trnn f,ps%dir		; seen a directory?
   246		 jrst [hrroi a,fildir	; no, fill in connected directory
   247		       move b,connum(cx); from tables
   248		       tlz b,77777	; make into user number
   249		       write <%2U>
   250		       tro f,ps%dir	; say there's a directory
   251		       jrst .+1]
   252		aos (p)
   253		popj p,
   254	
   255	; routine to check version supplied with file name against open mode bits
   256	; call: pushj p,chkver
   257	;	FILDEV, FILNAM, ... , FILVER set up
   258	;	f/ ps%dev, ... , ps%ver flags set accordingly
   259	;	p3/open mode bits (b0 on means don't actually open file)
   260	; returns: +1, illegal lookup control (error in A, possibly JSYS error)
   261	;	   +2, success, file opened, JFN in A, OPENF mode bits in B
   262	chkver:	ldb a,[point 2,p3,26]	; get explicit version control bits
   263		pushj p,@chkevd(a)	; dispatch
   264		 jrst chkvf1		; failed, die
   265		ldb a,[point 2,p3,28]	; get default handling
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 12.5

   266		trne f,ps%ver		; version supplied
   267		 jrst chkve1		; yes, skip this
   268		pushj p,@chkdvd(a)	; will set GTJFN mode bits on success
   269		 jrst chkvf1		; fail
   270	chkve1:	trne p3,lfo.cr		; should file be created?
   271		 tlo a,(1b1)		; say new file only
   272		pushj p,getjfn
   273		 jrst chkvf1		; GTFJN failed
   274	; fall through ...
   275	
   276	; Routine to OPENF a file whose JFN is in A
   277	; this can be called from OPENLF when a GNJFN operation
   278	; is being performed
   279	chkven:	movsi b,(^d8b5)		; open 8 bit
   280		trne p3,lfo.rd		; open read?
   281		 tro b,1b19		; arg for OPENF
   282		trne p3,lfo.wr!lfo.ex!lfo.cr	; open for write, extend, or create?
   283		 tro b,1b19!1b20	; arg for OPENF (write implies read because of IFS code)
   284		movei c,(a)		; hold onto JFN
   285	tops20,<
   286		pushj p,chkacc		; see if access for this user is allowed
   287		 pushj p,chkvrf
   288	>
   289		jumpl p3,[aos (p)
   290			  popj p,]	; don't open, just return
   291		openf			; try to OPENF it
   292		 pushj p,chkvrf
   293		push p,b		; save OPENF bits
   294		sizef			; get current byte count
   295		 jrst [elog <CHKVER: Unexpected JSYS error %1J>
   296		       popj p,]
   297		movem b,bytcnt(a)	; save current byte count
   298		pop p,b
   299		aos (p)			; success, return JFN in A
   300		pushj p,getsiz		; get byte size for file
   301	;	tlnn f,(debugf)		; debugging?
   302	;	 popj p,		; no, return here
   303		hrroi d,temp
   304		write d,<CHKVER: Open of file >
   305		jrst chkvrx
   306	
   307	; PUSHJ here when OPENF or CHKACC [Tops-20] above fails
   308	; If a contains OPNX9 (file busy), CHKVRF will attempt to unlock
   309	; If unlock is possible, CHKVRF returns +1 with JFN in A
   310	; If not file busy, or unlock not possible, CHKVRF returns to CHKVER's
   311	;   caller with A/ error code from CHKACC or OPNX9
   312	chkvrf:	cain a,OPNX9		; file busy?
   313		 jrst [movei a,(c)	; get jfn
   314		       pushj p,unlock	; try to unlock
   315			jrst [movei a,OPNX9 ; restore error code
   316			      jrst .+1] ; give fail return
   317		       popj p,]		; unlocked, succeed
   318		pop p,(p)		; undo return
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 12.6

   319		push p,a		; don't clobber error
   320		movei a,(c)		; release JFN on file
   321		rljfn
   322		 log <CHKVRF: Failed to release JFN: %1J>
   323		pop p,a
   324	chkvf1:	hrroi d,temp
   325		write d,<CHKVRF: Failed to open file >
   326	; fall through
   327	
   328	chkvrx:	push p,a
   329		push p,b
   330		hrroi a,fildir
   331		hrroi b,filnam
   332		hrroi c,filext
   333		write d,<%74I%1S%76I%2S.%3S;>
   334		move a,filver
   335		write d,<%1D >
   336		movei a,(cx)
   337		write d,<for connection %1O%/>
   338		hrroi a,temp
   339		log <%1S>
   340		pop p,b
   341		pop p,a
   342		popj p,
   343	
   344	; dispatch for handling explicit version number field
   345	chkevd:	chkev0
   346		chkev1
   347		chkev2
   348		chkev3
   349	
   350	; explicit version control says no versions allowed
   351	chkev0:	trne f,ps%ver		; don't allow versions; was there one?
   352		 jrst [movei a,erIlVr
   353		       popj p,]; yes, die
   354	skpret:	aos (p)
   355		popj p,
   356	
   357	; explicit version control says file must exist
   358	chkev1:	movsi a,(1b2)		; try a GTJFN on an existing file
   359		pushj p,getjfn
   360		 popj p,		; fail
   361		rljfn
   362		 jfcl
   363		jrst skpret
   364	
   365	; explicit version control says next or old
   366	chkev2:	pushj p,chkev1		; try old
   367		 jrst [caie a,GJFX20	; no old version lying around?
   368			popj p,		; not the problem
   369		       jrst chkv2a]
   370		rljfn
   371		 jfcl
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 12.7

   372		jrst skpret
   373	
   374	; here when old version doesn't exist
   375	chkv2a:	push p,filver		; try highest version
   376		setzm filver
   377		movsi a,(1b2)
   378		pushj p,getjfn
   379		 popj p,		; shouldn't die here
   380		move b,[1,,7]
   381		movei c,c
   382		gtfdb			; get version number
   383		hlrz c,c
   384		aoj c,			; increment version
   385		pop p,filver		; recover filver
   386		came c,filver		; equal?
   387		 jrst [movei a,erIlVr	; no
   388		       popj p,]
   389		rljfn
   390		 jfcl
   391		aos (p)
   392		popj p,
   393	
   394	; explicit version control says "any"
   395	chkev3:	jrst skpret
   396	
   397	; dispatch table for default version handling
   398	chkdvd:	chkdv0
   399		chkdv1
   400		chkdv2
   401		chkdv3
   402	; here when there should be a version number
   403	chkdv0:	popj p,			; fail (here only if no version supplied)
   404	
   405	; here to default to lowest version
   406	chkdv1:	movei a,-2
   407		movem a,filver
   408		movsi a,(1b2)
   409		jrst skpret
   410	
   411	; here to default to highest version or use next highest
   412	chkdv3:	movsi a,(1b0)
   413		caia
   414	chkdv2:	movsi a,(1b2)
   415		setzm filver
   416		jrst skpret
   417	
   418		
   419	ls gtjblk,16			; storage for long gtjfn
   420	ls fildev,10			; store for device string
   421	ls fildir,10			; storage for directory name
   422	ls filnam,10			; store for file name
   423	ls filext,10			; storage for filename extension
   424	ls filact,10			; storage for default account
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 12.8

   425	ls filprt,1			; file protection
   426	ls filflg,1			; GTJFN flag word
   427	ls filver,1			; store for file version
   428	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 13

     1		subttl	LeafOpen Utilities Utilities
     2	
     3	; routine to do GTJFN from stored strings
     4	; call: pushj p,getjfn
     5	;	a/ gtjfn bits in left half
     6	;	FILDEV, ... , FILVER filled in
     7	; returns: +1, failure, GTJFN error code in A
     8	;	   +2, success, JFN in A
     9	getjfn:	move b,[gtjblk,,gtjblk+1]
    10		setzm gtjblk
    11		blt b,gtjblk+15
    12	
    13		ior a,[1b11]		; Allow wildcards
    14		ior a,filflg
    15		hrr a,filver		; 3/18/82 ejs This should be a HRR, not HRRZ!
    16		movem a,gtjblk		; save gtjfn flags
    17	
    18		move a,[377777,,377777]	; null I/O
    19		movem a,gtjblk+1
    20	
    21		move a,[gtjblk+2,,gtjblk+3] ; clear remaining entries
    22		setzm gtjblk+2
    23		blt a,gtjblk+10
    24	
    25		hrroi a,fildev		; default device
    26		skipe fildev
    27		 movem a,gtjblk+2
    28	
    29		hrroi a,fildir		; default directory
    30		skipe fildir
    31		 movem a,gtjblk+3
    32	
    33		hrroi a,temp
    34		hrroi b,filnam
    35		hrroi c,filext
    36		write <%2S.%3S>
    37	
    38		move a,filprt
    39		movem a,gtjblk+6	; protection
    40	
    41		movei a,filact		; get default account
    42		move b,usrnum(cx)
    43		pushj p,.gdacc##	; see PSVSUP, SMXACC
    44		 jrst getjf1
    45		hrroi a,filact
    46		movem a,gtjblk+7
    47	
    48	getjf1:	movei a,gtjblk			; try for JFN
    49		hrroi b,temp
    50		gtjfn
    51		 popj p,			; failed
    52		setzm wildft(a)			; clear wildcard flag storage
    53		tlne a,(77b5)			; Any wildcards supplied?
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 13.1

    54		 movem a,wildft(a)		; save wildcard flags
    55		movei a,(a)			; clear flags from JFN
    56		aos (p)
    57		popj p,				; success, jfn in A
    58	
    59	ifn ft20,<
    60	; routine to check access for a file
    61	; call: pushj p,chkacc
    62	;	a/jfn of file
    63	;	b/openf bits
    64	;	cx/connection table index
    65	; returns: +1, access prohibited, error number in A
    66	;	   +2, success
    67	chkacc:	push p,a
    68		push p,b
    69		movem a,chkblk+.ckaud		; store JFN in arg block
    70		move a,usrnum(cx)
    71		movem a,chkblk+.ckald		; store user number
    72		move a,connum(cx)
    73		movem a,chkblk+.ckacd		; store connected directory
    74		movsi a,(sc%ctc!sc%gtb!sc%log)	; reasonable capabilities
    75		movem a,chkblk+.ckaec		; store 'em
    76		move a,b			; get openf bits
    77	
    78		movei b,.ckard			; try read access if necessary
    79		movem b,chkblk+.ckaac
    80		trne a,of%rd			; want read?
    81		 jrst [pushj p,.chkac
    82			skipa a,[OPNX3]
    83		         jrst .+1
    84		       movem a,-1(p)
    85		       jrst chkacf]
    86		movei b,.ckawr			; want write?
    87		movem b,chkblk+.ckaac
    88		move a,0(p)
    89		trne a,of%wr
    90		 jrst [pushj p,.chkac
    91			skipa a,[OPNX4]
    92		         jrst .+1
    93		       movem a,-1(p)
    94		       jrst chkacf]
    95		aos -2(p)
    96	chkacf:	pop p,b
    97		pop p,a
    98		popj p,
    99	
   100	.chkac:	move a,[ck%jfn!5]
   101		movei b,chkblk
   102		chkac				; look for capabilities
   103		 ercal jerr##
   104		skipe a
   105		 aos (p)
   106		popj p,
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 13.2

   107	
   108	ls chkblk,6
   109	> ; end ifn ft20
   110	
   111	; routine to set up byte size for further I/O
   112	; call: a/ JFN
   113	; returns: +1, always, bytsiz(jfn) set up
   114	getsiz:	push p,a
   115		push p,b
   116		push p,c
   117		pushj p,makldr			; get a leader page, if necessary
   118		movei a,ldrtyp			; get the file type
   119		pushj p,getptr	
   120		ildb c,a			; get size
   121		cain c,0			; if no bytesize,
   122		 movei c,2			; assume to be written as binary
   123		move a,-2(p)			; get JFN
   124		movei b,^d8			; assume 8 bit bytes
   125		caie c,2
   126		 movei b,7			; nope, type text, 7-bit bytes
   127		movem b,bytsiz(a)		; save it
   128		movei a,ldrbyt
   129		pushj p,getptr
   130		idpb c,a			; store in leader page
   131		pop p,c
   132		pop p,b
   133		pop p,a
   134		popj p,
   135	
   136	; routine to set byte size
   137	; call:	a/JFN
   138	;	b/byte size
   139	; returns: +1, failure (byte size already set)
   140	;	   +2, success, bytsiz(JFN) + file's FDB set up
   141	setsiz:	push p,a
   142		push p,b
   143		push p,c
   144		pushj p,makldr			; make the leader
   145		movei a,ldrtyp
   146		pushj p,getptr
   147		ildb c,a
   148		caie c,0
   149		 jrst setsz1			; byte size already exists
   150		skipn c,-1(p)			; get type
   151		 movei c,2			; default to vinary
   152		dpb c,a				; place in leader page
   153		movei b,^d8			; assume 8-bit bytes
   154		caie c,2			; binary?
   155		 movei b,7			; nope, type text, 7-bit bytes
   156		movei a,ldrbyt			; deposit in leader page
   157		pushj p,getptr
   158		idpb b,a
   159		move a,-2(p)
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 13.3

   160		movem b,bytsiz(a)		; store in byte size table
   161		aos -3(p)			; set skip return
   162	setsz1:	pop p,c				; recovers acs and leave
   163		pop p,b
   164		pop p,a
   165		popj p,
   166	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 14

     1		subttl	Filelock mechanisms
     2	
     3	; routine to "unlock" a file if it is held by a timed-out sequin
     4	; call: pushj p,unlock
     5	;	a/ jfn of locked file
     6	;	b/ openf bits
     7	; returns: +1, file cannot be unlocked
     8	;	   +2, file unlocked, owning sequin broken
     9	unlock:	push p,a		; save jfn
    10		push p,b		; save openf bits
    11		push p,c
    12		move b,[1,,3]		; get index block address
    13		movei c,d
    14		gtfdb
    15		and d,[000017,,777777]	; just want address
    16		movsi c,-njfn		; loop through jfn table
    17	unlck0:	push p,c		; save AOBJN pointer
    18		skipn a,jfntab(c)
    19		 jrst unlck1		; no jfn
    20		movei a,(c)		; get JFN
    21		move b,[1,,3]		; get this file's index block
    22		movei c,c		
    23		gtfdb
    24		and c,[000017,,777777]
    25		came c,d		; compare them
    26		 jrst unlck1		; not the same
    27		hlrz a,(c)		; file same, get owning connection
    28		move b,seqsta(a)	; get state of sequin for that connection
    29		cain b,TIMD		; timed out?
    30	 	 jrst unlck2		; yes, give the requestor the connection
    31	
    32	unlck3: pop p,(p)		; clean stack of AOBJN pointer
    33	unlck4:	pop p,c			; recover JFN
    34		pop p,b			; recover bits
    35		pop p,a			; recover JFN
    36		popj p,			; return bad
    37	
    38	unlck1: pop p,c			; recover AOBJN pointer
    39		aobjn c,unlck0		; loop until filename found
    40		jrst unlck4		; not found, open by non-sequin user
    41	
    42	; here when file owned by timed out connection
    43	; c/ jfntab index
    44	unlck2:	movei a,400000		; say file lock broken
    45		pop p,c			; recover AOBJN pointer
    46		iorm a,jfntab(c)
    47		movei a,(c)		; close broken sequin's ownership
    48		tlo a,(1b0)		; don't release JFN
    49		pushj p,$closf
    50		 jrst [log <UNLCK2: CLOSF error %1J>
    51		       jrst unlck3]
    52		pop p,c			; recover jfn
    53		pop p,b			; recover openf bits
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 14.1

    54		pop p,a			; recover jfn
    55		openf
    56		 jrst [log <UNLCK2: OPENF error %1J>
    57		       popj p,]
    58		aos (p)			; success
    59		popj p,
    60	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 15

     1		subttl	LeafClose
     2	
     3	; routine to close a file
     4	; call: p2/ 16-bit pointer to received request (ILDB gets first word after
     5	;	    opcode)
     6	; returns: +1, always, p2 updated
     7	ClosLf:	movei a,(cx)
     8		log <LEAFSV: LeafClose received for connection %1O>
     9		ildb c,p2		; get filehandle
    10		pushj p,chkhdl		; check validity of filehandle
    11		 popj p,		; failed, invalid handle
    12		 jfcl			; file not open, just release JFN
    13		movei a,(c)		; close file
    14		pushj p,$closf		
    15		 log <LEAFSV: Failed to close JFN %3O: %1J>
    16		move a,[point 16,LfAnPk,31] ; send the answer
    17		move b,[point 16,LfAnPk]
    18		dpb c,a
    19		movei c,LfClos
    20		jrst LeafOp
    21	
    22	; here to CLOSF file, unmapping any mapped pages first
    23	; call: pushj p,$closf
    24	;	a/JFN (b0 on means don't release JFN)
    25	; returns: +1, always.
    26	$closf:	push p,b
    27		hrrz b,jfntab(a)	; file open?
    28		 jumpe b,[jumpl a,[pop p,b ; unopened, but want JFN saved; do nothing
    29				   aos (p)
    30				   popj p,]
    31			  setzm wildft(a)
    32			  setzm jfntab(a)
    33			  rljfn
    34			   log <LEAFSV: Failed to release JFN %3O: %1J>
    35			  pop p,b
    36			  aos (p)
    37			  popj p,]
    38		hlrz b,curpag		; is a page of this file mapped?
    39		cain b,(a)
    40		 jrst [push p,a
    41		       seto a,		; yes, unmap it
    42		       move b,[400000,,pmpag]
    43		       pmap
    44		       setzm curpag
    45		       pop p,a
    46		       jrst .+1]
    47		aos -1(p)		; assume successful CLOSF
    48		move b,ldrfil
    49		cain b,(a)		; is this the file in the leader page?
    50		 pushj p,wrtldr		; update the FDB
    51		jumpg a,[setzm jfntab(a); if not releasing JFN, hold onto table entries
    52			 setzm wildft(a)
    53			 jrst .+3]
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 15.1

    54		hllzs jfntab(a)
    55		hllzs wildft(a)		; say not open, otherwise
    56		closf
    57		 sos -1(p)		; adjust stack for +1 return on CLOSF error
    58		pop p,b
    59		popj p,
    60	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 16

     1		subttl	LeafRead
     2	
     3	; routine to read a bytes
     4	; call: pushj p,Readlf
     5	;	p2/ pointer to request packet
     6	; returns +1, always, LeafError sent if necessary
     7	ReadLf: tlnn f,(debugf)
     8		 jrst ReadL2
     9		movei a,(cx)
    10		log <LEAFSV: LeafRead received for connection %1O>
    11	ReadL2:	ildb c,p2		; get filehandle
    12		pushj p,chkhdl		; check the handle
    13		 jrst flseop		; failed, flush to end of packet
    14		 jrst  [movei a,erIlRd	; fail, Illegal Leaf Read
    15			hrroi b,[asciz/File not open/]
    16			jrst errLf]
    17		move b,jfntab(c)	; get openf bits
    18		trnn b,1b19		; open for read?
    19		 jrst [hrroi b,[asciz/File is not open for reading./]
    20		       jrst ReadEr]
    21		ildb b,p2		; construct leafaddress
    22		andi b,17777		; mask to 13 bits
    23		lsh b,^d16
    24		ildb a,p2
    25		iori b,(a)		; combine with low order address
    26		move a,c		; filehandle to A
    27		caml b,bytcnt(a)	; trying to read past eof?
    28		 jrst [tlne b,400	; write to leader page?
    29			jrst .+1
    30		       move b,temp+12	; make address EOF
    31		       setzb d,c	; length 0
    32		       ibp p2		; increment bytepointer over length
    33		       jrst ReadL1]	; yes, return no data, starting at EOF
    34		ildb c,p2		; get length of read
    35		move d,c		; save length
    36	ReadL1:	caile c,1000		; need multiple read?
    37		 movei c,1000		; yes
    38		sub d,c			; adjust residual byte count
    39		push p,a
    40		push p,b
    41		push p,c
    42		push p,d		; fill in packet
    43		pushj p,rsin		; do random sin
    44		move d,[point 16,LfAnPk,31]
    45		dpb a,d			; deposit jfn
    46		exch b,-2(p)		; get leaf address
    47		rot b,-^d16
    48		idpb b,d
    49		rot b,^d16
    50		idpb b,d
    51		idpb c,d
    52		exch b,-2(p)		; get pointer to end of packet
    53		trne c,1		; odd number of bytes?
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 16.1

    54		 idpb c,b		; make a garbage byte
    55		move a,b
    56		move b,[point 16,LFAnPk]
    57		movei c,LfRead
    58		pushj p,LeafOp
    59		pop p,d
    60		pop p,c
    61		pop p,b
    62		pop p,a
    63		add b,c			; update address to read from
    64		move c,d
    65		jumpn d,ReadL1
    66		popj p,
    67		
    68	; routine to convert tenex/tops20 time to alto time
    69	; call: pushj p,timalt
    70	;	a/ time in tenex/tops20
    71	; returns: +1, always
    72	;	b/ time in Alto format
    73	timalt:	
    74	ifn ft20,<
    75		PUSHJ P,TIMTNX		; If tops-20, make into tenex format
    76	>
    77		HLRZ B,A		; Get days
    78		SUBI B,^D15385		; Adjust origin to Jan 1, 1901
    79		IMULI B,^D86400		; Convert days to seconds
    80		ADDI B,0(A)		; Add seconds increment
    81		POPJ P,
    82	
    83	IFN FT20,<
    84	; Convert Tops20 time format to Tenex format
    85	TIMTNX:	PUSH P,A		; Save day,,fraction
    86		MOVEI A,(A)		; Isolate fraction
    87		IMULI A,^D86400		; lh _ number of seconds since midnight
    88		ADDI A,400000		; Round
    89		HLRM A,0(P)		; Make TENEX format on stack
    90		POP P,A			; Recover it
    91		POPJ P,
    92	>
    93	
    94	; here when illegal read encountered
    95	readEr:	movei a,erIlRd
    96		pushj p,errLf
    97		jrst flseop
    98		
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 17

     1		subttl	LeafWrite
     2	
     3	; routine to write bytes
     4	; call: pushj p,Writlf
     5	;	p2/ pointer to request packet
     6	; returns +1, always, LeafError sent if necessary
     7	WritLf: movei a,(cx)
     8		tlne f,(debugf)
     9		 log <LEAFSV: LeafWrite received for connection %1O>
    10		ildb c,p2		; get filehandle
    11		pushj p,chkhdl		; check the handle
    12		 jrst flseop		; failed, flush to end of packet
    13		 jrst  [movei a,erIlWr	; fail, Illegal Leaf Write
    14			hrroi b,[asciz/File not open/]
    15			jrst errLf]
    16		move b,jfntab(c)	; get openf bits
    17		trnn b,1b20!1b22	; open write or append?
    18		 jrst [hrroi b,[asciz/File is open READ only/]
    19		       jrst WritEr]
    20		ildb b,p2		; construct leafaddress
    21		ldb d,[point 3,b,22]	; get mode and EOF bit
    22		andi b,17777		; mask to 13 bits
    23		lsh b,^d16
    24		ildb a,p2
    25		iori b,(a)		; combine with low order address
    26		move a,c		; filehandle to A
    27		ildb c,p2		; get length of read
    28		trne d,1		; EOF bit set in address?
    29		 tro f,tempf1		; yes, remember to set byte count
    30		lsh d,-1
    31		pushj p,@[mdanyw	; anywhere
    32			 mdnoho		; no holes
    33			 mddntx		; don't extend
    34			 mdchkx](d)	; check extend
    35		 jrst WritEr
    36		caie c,0		; skip if no bytes to write
    37		 pushj p,rsout		; do the write operation
    38		tlne b,400		; leader page write?
    39		 jrst LeafW1		; yes, don't update EOF count
    40		push p,c		; save length
    41		add c,b			; compute ending byte
    42		trnn f,tempf1		; set EOF with this write?
    43		camle c,bytcnt(a)	; no, but is this a longer byte count?
    44		 movem c,bytcnt(a)	; yes, save
    45		pop p,c			; recover length
    46	LeafW1:	trze f,tempf1		; set EOF?
    47		 jrst  [push p,b	; do the CHFDB
    48			push p,c
    49			move c,bytcnt(a)
    50			hrli a,12
    51			seto b,
    52			chfdb		; byte count
    53			hrli a,11
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 17.1

    54			movsi b,(77b11)
    55			move c,bytsiz(a)
    56			lsh c,^d24
    57			chfdb		; byte size
    58			movei a,(a)
    59			pop p,c
    60			pop p,b
    61			jrst .+1]
    62	WrtLf1:	move d,[point 16,LfAnPk,31] ; create answer
    63		dpb a,d
    64		rot b,-^d16
    65		idpb b,d
    66		rot b,^d16
    67		idpb b,d
    68		idpb c,d
    69		move a,d
    70		move b,[point 16,LfAnPk]
    71		movei c,LfWrit
    72		jrst LeafOp		; send answer and leave
    73	
    74	
    75	; here on illegal write (illegal extend, no holes error, etc)
    76	; a/ file handle
    77	; b/ pointer to human readable string
    78	WritEr:	movei c,(a)
    79		movei a,erIlWr
    80		pushj p,errLf
    81		jrst flseop
    82	
    83	; mode handling routines
    84	; anywhere
    85	mdanyw:	jrst skpret
    86	
    87	; no holes
    88	; a/ filehandle, b/ starting address, c/ length of write
    89	mdnoho:	tlne b,400			; leader page write?
    90		 jrst skpret			; succeed
    91		push p,b
    92		push p,c
    93		sizef				; get size
    94		aoj b,				; hole if start addr > EOF+1
    95		camge b,-1(p)
    96		 jrst [hrroi b,[asciz/Write operation would create hole in file/]
    97		       movem b,-1(p)
    98		       jrst mdnohx]
    99		aos -2(p)
   100	mdnohx:	pop p,c
   101		pop p,b
   102		popj p,
   103	
   104	; check extend
   105	mdchkx:	tlne b,400			; leader page?
   106		 jrst skpret			; yes, succeed
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 17.2

   107		tro f,tempf2			; say send error in case of extend
   108	; don't extend
   109	; a/ filehandle, b/ starting address, c/ length of write
   110	mddntx:	tlne b,400			; leader page write?
   111		 jrst skpret			; succeed
   112		push p,c
   113		push p,b
   114		addi b,(c)			; compute new EOF
   115		move d,b
   116		move b,bytcnt(a)		; get old EOF
   117		camge b,d			; will this extend?
   118		 jrst mddnx1			; yes, modify length of write
   119		aos -2(p)
   120	mddnxx:	pop p,b
   121		pop p,c
   122		popj p,
   123	
   124	; here to modify length of write to keep EOF extend from happening
   125	mddnx1:	trze f,tempf2
   126		 jrst [hrroi b,[asciz/Write operation would necessitate EOF extension/]
   127		       movem b,(p)
   128		       jrst mddnxx]
   129		sub b,(p)			; get starting address
   130		caige b,0			; also catch the no holes case
   131		 setz b,			; if start addr > old EOF, no write
   132		movem b,-1(p)			; save new write length
   133		aos -2(p)
   134		jrst mddnxx
   135		
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 18

     1		subttl	LeafDelete
     2	
     3	; routine to delete a file
     4	; call: pushj p,DeleLf
     5	; returns: +1, always
     6	Delelf:	movei a,(cx)
     7		log <DELELF: LeafDelete received for connection %1O>
     8		ildb c,p2			; get filehandle
     9		pushj p,chkhdl
    10		 jrst flseop			; bad handle
    11		 jrst  [movei a,erNtDl		; can't delete unless open write?
    12			hrroi b,[asciz/File not open/]
    13			jrst errLf]
    14		move a,jfntab(c)		; get openf bits
    15		trnn a,1b20!1b22		; open write or append?
    16		 jrst Delel1			; no, fail
    17		movei a,(c)			; ok, delete it
    18		tlo a,(1b0)			; close the jfn
    19		pushj p,$closf
    20		 jfcl
    21		delf
    22		 jrst [movei a,(c)
    23		       setzm jfntab(a)
    24		       rljfn
    25			jfcl
    26		       setz b,				; failure
    27		       jrst errLf]
    28		setzm jfntab(a)
    29		rljfn
    30		 jfcl
    31		move a,[point 16,LfAnPk,31]
    32		dpb c,a
    33		move b,[point 16,LfAnPk]
    34		movei c,LfDel
    35		jrst leafOp
    36	
    37	; here when delete not allowed (i.e. file not open write or append)
    38	Delel1:	movei a,erNtDl			; file not deletable
    39		setz b,
    40		jrst errLf
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 19

     1		subttl	LeafParams
     2	
     3	; routine to set Leaf Params
     4	ParmLf:	movei a,(cx)
     5		log <LEAFSV: LeafParams received for connection %1O>
     6		ildb a,p2		; get max pup length
     7		ildb a,p2		; discard pup length, get file timeout
     8		ildb b,p2		; get connection timeout
     9		imuli a,5		; convert to seconds
    10		imuli b,5
    11		cain a,0		; any file timeout supplied?
    12		 movei a,filet		; no, use default
    13		cain b,0
    14		 movei b,connt		; use default connection timeout if necessary
    15		hrl a,b
    16		pushj p,stlctm##	; set timeout
    17		move a,[point 16,LfAnPk,31]
    18		setz b,
    19	 	dpb b,a
    20		move b,[point 16,LfAnPk]
    21		movei c,LfParm
    22		jrst LeafOp
    23		
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 20

     1		subttl	LeafReset
     2	; routine to do reset
     3	; currently, only checks login name and password
     4	RestLf:	push p,p3
     5		ildb  p3,p2		; get ResetHosts field
     6		movsi a,(1b0)		; don't check connect params
     7		pushj p,.login		; try to log in
     8		 jrst  [pop p,p3
     9		 	jrst flseop]	; fail, point to next packet, if it exists
    10		pushj p,rstcon		; Do resets as directed by ResetHosts field
    11		pop p,p3		; recover p3
    12		move a,[point 16,LfAnPk,31] ; respond with ResetHost Answer
    13		setz b,
    14		dpb b,a
    15		move b,[point 16,LfAnPk]
    16		movei c,LfRest
    17		jrst LeafOp
    18	
    19	; routine to implement ResetHosts
    20	; call: cx/ connection table index for this connection
    21	;	p3/ ResetHosts field
    22	; returns: +1, always
    23	rstcon:	jumpe p3,rsthst		; reset connections from this host
    24		cain p3,177777		; or is it from this user?
    25		 jrst rstusr		; yes
    26		movei a,OPEN
    27		movem a,seqSta(sq)	; make state = OPEN
    28		movei a,(cx)
    29		log <LEAFSV: LeafReset received for connection %1O>
    30		popj p,			; else just return
    31	
    32	; routine to break all connections logged in under this user
    33	; call: pushj p,rstusr
    34	;	cx/ connection table index
    35	; returns: +1, always, all connections logged in under this user broken
    36	;	       (except this one, of course)
    37	rstusr:	movsi a,-nconn		; set up AOBJN loop
    38		push p,cx
    39		movei cx,(cx)		; clean off any left half stuff
    40	rstus0:	move b,usrnum(cx)	; get this user
    41		came b,usrnum(a)	; get a user
    42		 jrst rstus1		; not this one
    43		cain cx,(a)		; make sure we don't kill ourselves
    44		 jrst rstus1		; this is us
    45		skipn b,contab(a)	; get sequin data block address
    46		 jrst rstus1		; no connection here
    47		movei c,DSTR		; make its state = DeSTRoYed
    48		movem c,seqSta(b)
    49	rstus1:	aobjn a,rstus0		; loop until all connections scanned
    50		pop p,cx
    51		move a,usrnum(cx)
    52		movei b,(cx)
    53		log <LEAFSV: Reset all %1U connections from connection %2O>
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 20.1

    54		popj p,
    55	
    56	; routine to reset connections logged in from this host
    57	; call: pushj p,rsthst
    58	;	cx/ connection table index
    59	; returns: +1 always
    60	rsthst:	movsi a,-nconn		; set up AOBJN loop
    61		push p,cx
    62		movei cx,(cx)		; clean off any left half stuff
    63	rsths0:	move b,pupfnh(cx)	; get this user
    64		came b,pupfnh(a)	; get a user
    65		 jrst rsths1		; not this one
    66		cain cx,(a)		; make sure we don't kill ourselves
    67		 jrst rsths1		; this is us
    68		skipn b,contab(a)	; get sequin data block address
    69		 jrst rsths1		; no connection here
    70		movei c,DSTR		; make its state = DeSTRoYed
    71		movem c,seqSta(b)
    72	rsths1:	aobjn a,rsths0		; loop until all connections scanned
    73		pop p,cx
    74		hlrz a,pupfnh(cx)
    75		hrrz b,pupfnh(cx)
    76		movei c,(cx)
    77		log <LEAFSV: All connections from %1O#%%2O#  reset by connection %3O>
    78		popj p,
    79	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 21

     1		subttl	PropLists
     2	; These routines are extensions to the Leaf protocol, as defined by
     3	; Jeff Mogul in his paper on Leaf and Sequin.  They exist because the
     4	; implementation status of Leaf at that time provided no machine
     5	; independent mechanisms for determining information about a file.
     6	; Leaf had not been used much within Xerox, and certainly not at all
     7	; outside of Xerox; hence, there was no problem in using the machine
     8	; dependent leader page of an IFS file to access file properties.
     9	; Then, one day, along came the Dolphin Lisp machines, and all of a 
    10	; sudden, there were these PDP10's and PDP20's and VAX's which had to
    11	; communicate with the Dolphins.  And the Twenex Leaf implementor said,
    12	; "Why is this Dolphin trying to read byte -4000???"  Anyway, PUPFTP-
    13	; like property lists are supposed to be the solution.
    14	;
    15	;
    16		COMMENT 
    17	The following documents the Leaf Op formats:
    18	
    19		GetLeafProp
    20		+--------------+---+-----------+
    21		|  OP	       | 0 |           |
    22		+--------------+---+-----------+
    23		|           Handle             |
    24		+------------------------------+
    25		|       Recognition Mode       |
    26		+------------------------------+
    27		|       Desired Property       |
    28		+------------------------------+
    29		|           Username	       |
    30		+------------------------------+
    31		|        User Password         |
    32		+------------------------------+
    33		|          Connect Name        |
    34		+------------------------------+
    35		|      Connect Password        |
    36		+------------------------------+
    37		|           File name          |
    38		+------------------------------+
    39	
    40	If the supplied handle is 0, the file name specified in the OP is looked
    41	up using the supplied user/connect name/password.  If the handle is non-
    42	zero, it is assumed to be a handle valid for the Leaf connection, and the
    43	name and password information is ignored.  In the Tenex/Tops-20 
    44	implementation, if the file name has to looked up, the file will be GTJFN'd
    45	but not OPENF'd.  The desired property is returned in a GetPropAnswer
    46	OP.  If the desired property=PropList, the entire file property list is
    47	returned.  The recognition mode is like the LeafOpenMode (same bits).
    48	If the file has to be looked up, it is forgotten after responding to the
    49	request.
    50	
    51	Returns:
    52	
    53		+----------+---+---------------+
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 21.1

    54		|    OP    | 1 |               |
    55		+----------+---+---------------+
    56		|           Handle	       |
    57		+------------------------------+
    58		|    Property in IFS string    |
    59		+------------------------------+
    60	
    61	; routine to return file properties
    62	; call: pushj p,PropLf
    63	;	p2/ pointer to request packet
    64	; returns: +1,always
    65	PropLf:	tlnn f,(debugf)
    66		 jrst propl2
    67		movei a,(cx)
    68		log <LEAFSV: LeafGetFileProp received for connection %1O>
    69	propl2:	ildb c,p2		; get handle
    70		jumpe c,propl3		; if no handle, read filename as in OpenLeaf
    71		pushj p,chkhdl		; check the handle
    72		 jrst flseop		; bad handle, error already sent
    73		 jfcl			; not open; that's OK
    74	; handle still in c at this point!
    75		ibp p2			; increment past RecognitionMode word
    76		hrroi a,temp2		; read the desired property
    77		move b,p2
    78		pushj p,rifsst
    79		move p2,b
    80	propl4:	move a,[point 7,temp2]
    81		move b,[point 7,temp2+10]
    82		pushj p,genfp		; generate the desired property list
    83		 jrst flseop		; bad prop, return
    84		move a,[point 16,LfAnPk,31]
    85		dpb c,a			; deposit handle	
    86		hrroi b,temp2+10
    87		pushj p,wifsst		; write the prop list in
    88		move b,[point 16,LfAnPk]; point to start of packet
    89		hrrz d,jfntab(c)	; Is the file open?
    90		jumpe d,[push p,a
    91			 movei a,(c)
    92			 pushj p,$closf
    93			  jfcl
    94			 pop p,a
    95			 jrst .+1]
    96		movei c,LfProp		; return a LeafProp answer
    97		jrst LeafOp		; send it and return
    98	
    99	; here when file handle supplied is 0; do login and GTJFN as per strings
   100	; in packet
   101	propl3:	push p,p3
   102		ildb p3,p2		; get OpenMode word
   103		move b,p2		; read property string
   104		hrroi a,temp2
   105		pushj p,rifsst
   106		move p2,b		; p2 _ updated pointer
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 21.2

   107		pushj p,.login		; attempt login
   108		 jrst [pop p,p3
   109		       jrst flseop]
   110		hrroi a,temp		; read filename
   111		move b,p2		; point to IFS string
   112		pushj p,rifsst
   113		move p2,b		; save updated pointer in right place
   114		pushj p,prsfil
   115		 jrst  [movei a,erNmMl	; fail on malformed name
   116			hrroi b,[asciz/Malformed name/]
   117			setz c,
   118			pushj p,errLf	; send error
   119			pop p,p3	; recover p3
   120			popj p,]
   121		tlo p3,(1b0)		; Tell CHKVER not to open file
   122		pushj p,chkver
   123		 jrst  [setzb b,c
   124			pushj p,errLf
   125			pop p,p3
   126			popj p,] 	; return in error
   127		hrlzm cx,jfntab(a)	; assign the JFN to this cnxtn, but say closed
   128		pop p,p3		; recover old p3
   129		movei c,(a)		; get handle into c for prop list code
   130		jrst propl4		; rejoin proplist code
   131	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 22

     1		subttl	FileHandle utilities
     2	
     3	; routine to check validity of file handle
     4	; call: c/ file handle
     5	;	cx/ connection table index
     6	; returns: +1, invalid handle for this connection, ErrorLeaf sent
     7	;	   +2, valid handle
     8	; clobbers b, on success, others in case of error
     9	chkhdl:	skipn jfntab(c)
    10		 jrst chkhd1		; Bad Handle
    11		hlrz b,jfntab(c)	; make sure this connection owns the jfn
    12		caie b,(cx)		; compare with cx
    13		 jrst chkhd1		; wrong owner
    14		hrrz b,jfntab(c)	; make sure file lock unbroken
    15		trne b,400000
    16		 jrst chkhd2		; file lock broken
    17		caie b,0
    18		 aos (p)		; ret +3 if open
    19		aos (p)			; ret +2 if note
    20		popj p,
    21	
    22	chkhd1:	movei a,erBdHn		; bad file handle
    23		hrroi b,[asciz/Bad file handle/]
    24		jrst errLf
    25	
    26	chkhd2:	movei a,erBkLf		; file lock broken
    27		hrroi b,[asciz/File lock broken/]
    28		jrst errLf
    29	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 23

     1	
     2		subttl Property Lists
     3	; routine to generate a property list 
     4	; call: pushj p,genfp
     5	;	a/ pointer to string property desired
     6	;	b/ pointer to place to build output property
     7	;	c/ file handle (JFN)
     8	; returns: +1, unrecognized property
     9	;	   +2, property OK, written in string pointed to by B
    10	; property lists look like Lisp S-expressions:
    11	;    ((Author SCHOEN) (Read-Date 4-Jun-82 15:52) --- )
    12	; Property lists with single entries should be of the same form:
    13	;    ((Author SCHOEN))
    14	genfp:	push p,b
    15		push p,c
    16		move b,[-nprops,,pldisp]	; lookup property
    17		pushj p,fndkey##		; routine from PUPPRP.MAC
    18		 jrst genfpe			; property in bad format
    19		 jrst genfpe			; unrecognized property
    20		move a,0(b)			; get pointer
    21		pop p,c
    22		pop p,b
    23		pushj p,gnpsta			; start the prop list
    24		movei a,(a)
    25		pushj p,0(a)			; generate property
    26		pushj p,gnpend			; end the prop list	
    27		setz a,
    28		idpb a,b			; null off string
    29		aos (p)				; return
    30		popj p,
    31	
    32	genfpe:	movei a,^d609
    33		hrroi b,[asciz/Unknown Property/]
    34		pushj p,errLf
    35		pop p,c
    36		pop p,b
    37		popj p,
    38	
    39	; known properties
    40	pldisp:	[asciz/Author/],,fpauth
    41		[asciz/Byte-Size/],,fpbyte
    42		[asciz/Complete-Filename/],,fpcfil
    43		[asciz/Creation-Date/],,fpcdat
    44		[asciz/Property-List/],,fpprop
    45		[asciz/Read-Date/],,fprdat
    46		[asciz/Size/],,fpsize
    47		[asciz/Type/],,fptype
    48		[asciz/Write-Date/],,fpwdat
    49	nprops==.-pldisp
    50	
    51	; routine to start a prop list
    52	; call: pushj p,gnpsta
    53	; 	b/ pointer to start of list 
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 23.1

    54	; returns: +1, always
    55	gnpsta:	tlc b,-1
    56		tlcn b,-1
    57		 hrli b,(point 7)
    58		push p,a
    59		movei a,"("
    60		idpb a,b
    61		pop p,a
    62		popj p,
    63	
    64	; routine to end a prop list
    65	; call: pushj p,gnpend
    66	; 	b/ pointer to end of list 
    67	; returns: +1, always
    68	gnpend:	tlc b,-1
    69		tlcn b,-1
    70		 hrli b,(point 7)
    71		push p,a
    72		movei a,")"
    73		idpb a,b
    74		pop p,a
    75		popj p,
    76	
    77	; routine to copy property name into prop list
    78	; call: pushj p,cpyprp
    79	;	a/ pointer to prop name
    80	;	b/ pointer to output string
    81	; returns: +1, always
    82	cpyprp:	push p,c		; save handle
    83		tlc a,-1
    84		tlcn a,-1
    85		 hrli a,(point 7)
    86		tlc b,-1
    87		tlcn b,-1
    88		 hrli b,(point 7)
    89	cpypr0:	ildb c,a		; get byte
    90		jumpe c,cpypr1		; leave if null
    91		idpb c,b
    92		jrst cpypr0
    93	cpypr1:	pop p,c			; restore handle
    94		popj p,			; leave
    95	
    96	; routines to generate individual file properties
    97	; routine to generate Author
    98	fpauth:	pushj p,gnpsta			; start the item
    99		hrroi a,[asciz/Author /]	; identify the prop
   100		pushj p,cpyprp
   101	ifn ft10x,<
   102		push p,c		; save handle
   103		push p,b		; save prop list pointer
   104		movei a,(c)		; handle to A
   105		move b,[1,,6]		; get author
   106		movei c,b		; put dir number in B
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 23.2

   107		gtfdb
   108		pop p,a			; recover string ptr to A
   109		dirst			; output string to ptr in A
   110		 jrst [movei c,^d8	; not in use, write the number instead
   111		       nout		; write the number
   112			jfcl
   113		       jrst .+1]
   114		move b,a		; string ptr back to B
   115		pop p,c			; recover handle
   116	>
   117	ifn ft20,<
   118		movei a,(c)		; get handle in A
   119		hrli a,1		; get string of last writer
   120		gfust			; write into string
   121	>
   122		pushj p,gnpend		; end property
   123		popj p,			; return
   124	
   125	; routine to write byte-size property
   126	fpbyte:	pushj p,gnpsta
   127		hrroi a,[asciz/Byte-size /]	; name the property
   128		pushj p,cpyprp
   129		push p,c
   130		push p,b
   131		movei a,(c)
   132		move b,[1,,11]
   133		movei c,b
   134		gtfdb
   135		ldb b,[point 6,b,11]	; read bytesize out of word
   136		pop p,a			; recover prop list pointer
   137		movei c,^d10		; output decimal number
   138		nout
   139		 jfcl			; shouldn't fail
   140		move b,a		; proplist pointer to B
   141		pop p,c			; recover handle
   142		pushj p,gnpend		; end entry
   143		popj p,
   144	
   145	; Routine to output file length (in decimal bytes)
   146	fpsize:	pushj p,gnpsta
   147		hrroi a,[asciz/Size /]	; name the property
   148		pushj p,cpyprp
   149		push p,c
   150		push p,b
   151		movei a,(c)
   152		sizef			; ask the operating system
   153		 jfcl			; better not fail
   154		pop p,a			; recover prop list pointer
   155		movei c,^d10		; output decimal number
   156		nout
   157		 jfcl			; shouldn't fail
   158		move b,a		; proplist pointer to B
   159		pop p,c			; recover handle
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 23.3

   160		pushj p,gnpend		; end entry
   161		popj p,
   162	
   163	; routine to output Complete-Filename prop
   164	fpcfil:	pushj p,gnpsta
   165		hrroi a,[asciz/Complete-Filename /] ; copy prop name
   166		pushj p,cpyprp
   167		push p,c
   168		move a,b		; string pointer to A
   169		movei b,(c)		; jfn to B
   170	ifn ft10x,<
   171		move c,[1b5+1b8+1b11+1b14+1b35]
   172	>
   173	ifn ft20,<
   174		move c,[1b2+1b5+1b8+1b11+1b14+1b35]
   175	>
   176		jfns			; add complete filename
   177		move b,a		; string ptr to B
   178		pop p,c			; recover handle
   179		pushj p,gnpend
   180		popj p,
   181	
   182	; date routines
   183	; read date
   184	fprdat:	pushj p,gnpsta
   185		hrroi a,[asciz/Read-Date /]	; copy prop name
   186		pushj p,cpyprp
   187		push p,c
   188		push p,b
   189		movei a,(c)
   190		move b,[1,,15]			; get read date
   191		movei c,b
   192		gtfdb
   193		jrst fpdate			; join common code
   194	
   195	; write date
   196	fpwdat:	pushj p,gnpsta
   197		hrroi a,[asciz/Write-Date /]	; copy prop name
   198		pushj p,cpyprp
   199		push p,c
   200		push p,b
   201		movei a,(c)
   202		move b,[1,,14]			; get read date
   203		movei c,b
   204		gtfdb
   205		jrst fpdate			; join common code
   206	
   207	; creation date
   208	fpcdat:	pushj p,gnpsta
   209		hrroi a,[asciz/Creation-Date /]	; copy prop name
   210		pushj p,cpyprp
   211		push p,c
   212		push p,b
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 23.4

   213		movei a,(c)
   214		move b,[1,,13]			; get read date
   215		movei c,b
   216		gtfdb
   217	; fall through
   218	
   219	; common code to put date in prop list and end item
   220	; date in internal format in B, stack has string pointer in 0(p),
   221	; file handle in -1(p)
   222	fpdate:	pop p,a				; string ptr to A
   223		setz c,
   224		odtim
   225		move b,a			; string ptr to B
   226		pop p,c				; recover handle
   227		pushj p,gnpend			; end prop
   228		popj p,
   229	
   230	; routine to output file type
   231	fptype:	pushj p,gnpsta
   232		hrroi a,[asciz/Type /]
   233		pushj p,cpyprp
   234		push p,c
   235		push p,b
   236		movei a,(c)
   237		move b,[1,,11]
   238		movei c,a
   239		gtfdb
   240		ldb a,[point 6,a,11]	; read bytesize out of word
   241		cain a,^d7		; 7-bit bytes means text
   242		 jrst [hrroi a,[asciz/Text/]
   243		       jrst .+2]
   244		hrroi a,[asciz/Binary/]	; else assume binary
   245		pop p,b	
   246		pushj p,cpyprp
   247		pushj p,gnpend
   248		pop p,c
   249		popj p,
   250	
   251	; routine to output an entire property list
   252	fpprop:	move d,[-nprops,,pldisp] ; point to dispatch table
   253	fpprp1:	hrrz a,0(d)		; point to next prop
   254		caie a,fpprop		; avoid recursion
   255		 pushj p,0(a)		; call the routine for this prop
   256		aobjn d,fpprp1		; loop while table still exists
   257		popj p,			; done,leave
   258	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 24

     1		subttl	Paged Disk I/O
     2	
     3	; routine to simulate a SIN from a specific point in the file
     4	; call: pushj p,rsin
     5	;	a/jfn
     6	;	b/address in file (bytes)
     7	;	c/length of read
     8	; returns +1, always, data read into LfAnPk, for LeafReadAnswer
     9	rsin:	jumpe c,[move b,[point 8,LfAnPk+2,15]
    10			 popj p,]
    11		push p,a
    12		push p,b
    13		push p,c
    14		movsi c,(1b2)		; map read only
    15		pushj p,getpag		; map a page
    16		move b,-1(p)		; recover byte address
    17		tlne b,-400		; negative byte address?
    18		 jrst [addi b,4000
    19		       hrrz a,b
    20		       pushj p,getptr
    21		       tlc a,(30b11)	; make into an 8-bit byte pointer
    22		       move c,a
    23		       move b,[point 8,LfAnPk+2,15]
    24		       move a,(p)
    25		       jrst rsin1]
    26		pushj p,getsiz		; get bytesize	
    27		move c,bytsiz(a)	; get byte size
    28		cain c,7
    29		 jrst [idivi b,5000
    30		       move b,[point 8,LfAnPk+2,15]
    31		       idivi c,5
    32		       add c,[point 7,pmadr,-1
    33			      point 7,pmadr,6
    34			      point 7,pmadr,13
    35			      point 7,pmadr,20
    36			      point 7,pmadr,27](d)
    37		       move a,(p)
    38		       jrst rsin1]
    39		idivi b,4000		; get index into page
    40		move b,[point 8,LfAnPk+2,15]
    41		idivi c,4
    42		add c,[point 8,pmadr,-1
    43		       point 8,pmadr,7
    44		       point 8,pmadr,15
    45		       point 8,pmadr,23](d); this creates the lh of the byte pointer
    46		move a,(p)		; get count
    47	
    48	; loop here
    49	rsin1:	ildb d,c		; get next byte
    50		idpb d,b		; put in packet
    51		soje a,rsin2		; if done, leave
    52		move d,-2(p)		; get JFN
    53		move d,bytsiz(d)	; get byte size
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 24.1

    54		cain d,7
    55		 jrst [camn c,[point 7,pmadr+777,34] ; run out of buffer page?
    56			jrst rsin3	; yes
    57		       jrst rsin1]	; no, loop
    58		came c,[point 8,pmadr+777,31] ; run out of buffer page?
    59		 jrst rsin1		; no, loop
    60	
    61	rsin3:	move c,(p)		; retrieve count
    62		sub c,a			; get number of bytes read
    63		exch b,-1(p)		; get file address
    64		addi b,(c)		; update for bytes read
    65		exch a,-2(p)		; retrieve jfn
    66		movsi c,(1b2)		; map read only
    67		pushj p,getpag		; get the next page
    68		exch a,-2(p)		; recover count
    69		exch b,-1(p)		; recover dest bytepointer
    70		move c,-2(p)		; get jfn
    71		move c,bytsiz(c)	; get byte size
    72		cain c,7
    73		 jrst [move c,[point 7,pmadr,-1]
    74		       jrst rsin1]
    75		move c,[point 8,pmadr,-1] ; new source byte pointer
    76		jrst rsin1		; loop
    77	
    78	; here when done
    79	rsin2:	tlc b,(30b11)		; make packet end pointer 16 bits
    80		movem b,-1(p)		; save pointer to packet end
    81		pop p,c			; clean stack 
    82		pop p,b
    83		pop p,a
    84		popj p,
    85	
    86	
    87	; routine to put file page in core buffer
    88	; call: pushj p,getpag
    89	;	a/jfn
    90	;	b/address, in 8-bit bytes
    91	;	c/pmap bits
    92	; returns: +1 always
    93	getpag:	push p,a
    94		tlne b,400		; negative byte address?
    95		 jrst getpg2		; yes, get leader page
    96		push p,c
    97		move c,bytsiz(a)	; get bytsize
    98		cain c,7		; text file?
    99		 jrst [idivi b,5	; yes, 5 bytes/word
   100		       jrst .+2]
   101		idivi b,4		; convert to word address
   102		lsh b,-^d9		; convert word address to page
   103		pop p,c
   104		hrl a,a
   105		hrri a,(b)		; set up for PMAP
   106		camn a,curpag		; is that page in core now?
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 24.2

   107		 jrst getpg1		; yes, don't pmap
   108		movem a,curpag		; no, save it
   109		seto a,
   110		move b,[400000,,pmpag]
   111		pmap			; unmap previous page in core
   112		move a,curpag
   113		pmap
   114		pop p,a
   115		popj p,
   116	
   117	; here when page in core is that which is desired.  Adjust access
   118	; c/ pmap bits
   119	getpg1:	push p,b
   120		move a,[400000,,pmpag]
   121		move b,c
   122		spacs			; change access bits
   123		pop p,b
   124		pop p,a
   125		popj p,
   126	
   127	; here when a leader page address is desired
   128	getpg2:	pushj p,makldr		; make the leader page
   129		pop p,a
   130		popj p,
   131	
   132	ls curpag,1			; contains jfn,,page # for page in buffer
   133	
   134	; Routine to simulate a SOUT to a specific point in the file
   135	; call: pushj p,rsout
   136	;	a/jfn
   137	;	b/address in file (bytes)
   138	;	c/length of read
   139	; returns +1, always, data read from LeafPk into file
   140	rsout:	push p,a
   141		push p,b
   142		push p,c
   143		movsi c,(1b2!1b3)	; map read, write
   144		pushj p,getpag		; map a page
   145		move b,-1(p)		; recover byte address
   146		tlne b,400		; negative byte address
   147		 jrst [addi b,4000
   148		       hrrz a,b
   149		       pushj p,getptr
   150		       tlc a,(30b11)
   151		       move c,a
   152		       move b,[point 8,LeafPk+2,15]
   153		       move a,(p)
   154		       jrst rsout1]
   155		pushj p,getsiz		; get byte size
   156		move c,bytsiz(a)	; get bytesize
   157		cain c,7
   158		 jrst [idivi b,5000
   159		       move b,[point 8,LeafPk+2,15]
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 24.3

   160		       idivi c,5
   161		       add c,[point 7,pmadr,-1
   162			      point 7,pmadr,6
   163			      point 7,pmadr,13
   164			      point 7,pmadr,20
   165			      point 7,pmadr,27](d)
   166		       move a,(p)
   167		       jrst rsout1]
   168		idivi b,4000		; get index into page
   169		move b,[point 8,LeafPk+2,15]
   170		idivi c,4
   171		add c,[point 8,pmadr,-1
   172		       point 8,pmadr,7
   173		       point 8,pmadr,15
   174		       point 8,pmadr,23](d); this creates the lh of the byte pointer
   175		move a,(p)		; get count
   176	
   177	; loop here
   178	rsout1: ildb d,b		; get next byte
   179		idpb d,c		; put in packet
   180		soje a,rsout2		; if done, leave
   181		move d,-2(p)		; get JFN
   182		move d,bytsiz(d)	; get bytesize
   183		cain d,7
   184		 jrst [camn c,[point 7,pmadr+777,34] ; run out of buffer page?
   185			jrst rsout3	; yes
   186		       jrst rsout1]	; no, loop
   187		came c,[point 8,pmadr+777,31] ; run out of buffer page?
   188		 jrst rsout1		; no, loop
   189	
   190	rsout3:	move c,(p)		; retrieve count
   191		sub c,a			; get number of bytes read
   192		exch b,-1(p)		; get file address
   193		addi b,(c)		; update for bytes read
   194		exch a,-2(p)		; retrieve jfn
   195		movsi c,(1b2!1b3)	; map read, write
   196		pushj p,getpag		; get the next page
   197		exch a,-2(p)		; recover count
   198		exch b,-1(p)		; recover dest bytepointer
   199		move c,-2(p)		; get JFN
   200		move c,bytsiz(c)	; get bytesize
   201		cain c,7
   202		 jrst [move c,[point 7,pmadr,-1]
   203		       jrst rsout1]
   204		move c,[point 8,pmadr,-1] ; new source byte pointer
   205		jrst rsout1			; loop
   206	
   207	; here when done
   208	rsout2:	tlc b,(30b11)		; make packet end pointer 16 bits
   209		pop p,c			; clean stack 
   210		pop p,b
   211		pop p,a
   212		popj p,
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 24.4

   213	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 25

     1	
     2	; ---------------------------------------------------------------------
     3	;	UUO handler routines specific to PSVLEF (Stolen from PUPSRV)
     4	; ---------------------------------------------------------------------
     5	
     6	
     7	; Log given string with formatting actions
     8	%ULOG::	TLZA F,(LGTTYF)		; Log only on file
     9	
    10	; Log and type the given string with formatting actions
    11	%UELOG::TLO F,(LGTTYF)		; Log on both file and TTY
    12		PUSHJ P,FORMAT##	; Call formatter
    13		 PUSHJ P,BEGLOG		; Setup -- begin log entry
    14		 PUSHJ P,ENDLOG		; Completion -- end log entry
    15		POPJ P,			; Return from UUO
    16	
    17	; UUOs not used in the server
    18	%LETC:: %URUNM:: %UNOIS:: %UPROM:: %UFTPM:: PUSHJ P,SCREWUP##
    19	
    20	
    21	; Individual functions for escape sequences
    22	
    23	; P - Selected address from Pup pointed to by PB
    24	;	1P = Destination, 2P = Source
    25	%LETP::	PUSH P,A		; Save string ptr
    26		CAIL C,1		; Make sure arg in range
    27		CAILE C,3
    28		 PUSHJ P,SCREWUP
    29		XCT [	PUSHJ P,GTDPRT	; 1 = Destination Port
    30			PUSHJ P,GTSPRT]-1(C) ; 2 = Source Port
    31		MOVE D,C		; Copy socket
    32		MOVSI C,(A)		; Make net,,host
    33		HRRI C,(B)
    34		POP P,A			; Recover string ptr
    35		MOVE B,[1B2+C]		; Full expansion, constants allowed
    36		PUPNM			; Convert address to string
    37		 PUSHJ P,SCREWUP
    38		POPJ P,
    39	
    40	; Routines to return source and destination ports
    41	; Get Destination Port from Pup
    42	;	PB/ Packet buffer ptr
    43	; Returns +1:
    44	;	A/ Net, B/ Host, C/ Socket
    45	
    46	GTDPRT::MOVE A,PBHEAD+2(PB)	; Get net/host and high socket
    47		MOVE C,PBHEAD+3(PB)	; Get low socket
    48		LSHC A,-^D28		; Right-justify net
    49		LSH B,-^D12		; Right-justify high socket
    50		LSHC B,-^D16		; Concatenate, right-justify host
    51		LSH C,-4		; Right-justify socket
    52		POPJ P,
    53	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 25.1

    54	; Get Source Port from Pup
    55	;	PB/ Packet buffer ptr
    56	; Returns +1:
    57	;	A/ Net, B/ Host, C/ Socket
    58	
    59	GTSPRT::LDB A,PPUPSN		; Get net
    60		LDB B,PPUPSH		; Get host
    61		LDB C,PPUPSS		; Get socket
    62		POPJ P,
    63	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 26

     1	
     2	; -----------------------------------------------------------------
     3	;	Logging routines
     4	; -----------------------------------------------------------------
     5	
     6	; Begin a log entry
     7	;	CX/ Connection index of connection being considered
     8	;	SQ/ Sequin data block pointer
     9	; Returns +1, A/ string ptr to logging buffer
    10	; Clobbers B, C
    11	
    12	BEGLOG:	PUSHJ P,LOKLOG		; shut off interrupts if on
    13		MOVE A,LOGBPT		; Get current byte ptr
    14		SETO B,			; Default time to now
    15		MOVSI C,(1B10+1B12)	; Suppress seconds and colon
    16		ODTIM			; Log the date and time
    17		MOVEI B," "		; A space
    18		IDPB B,A
    19		SKIPL B,FX
    20		 SUBI B,400000		; Convert to small number if not top fork
    21		MOVE C,[1B2+2B17+10B35]	; 2 digits, octal radix
    22		NOUT			; Record connection #
    23		 JRST [ MOVEI B,"?"	; If FX bad, just print ??
    24			IDPB B,A
    25			IDPB B,A
    26			JRST BEGLO1 ]
    27	BEGLO1:	MOVEI B," "		; Another space
    28		IDPB B,A
    29		POPJ P,
    30	
    31	; End a log entry
    32	;	A/ Used string ptr (into logging buffer)
    33	; Returns +1
    34	
    35	ENDLOG:	HRROI B,[ASCIZ /
    36	/]
    37		SETZ C,			; Append crlf and null
    38		SOUT
    39		MOVE C,LOGBPT		; Get start of string
    40		MOVEM A,LOGBPT		; Update pointer to end
    41		TLNE F,(DEBUGF)		; Debugging?
    42		 JRST [	MOVEI A,101	; Yes, always print on TTY
    43			DOBE		; Avoid intermixed messages
    44			JRST ENDLO2]	; Go type
    45		TLNN F,(LGTTYF)		; No, serious error?
    46		 JRST ENDLO3		; No, print nothing
    47		TIME			; Yes, get now
    48		SUBM A,LTTTIM		; Compute time since last we did this
    49		EXCH A,LTTTIM		; Save now, get interval
    50		CAIGE A,^D30000		; Too soon?
    51		 JRST ENDLO3		; Yes, don't hog the logging TTY
    52		MOVEI A,101		; Wait for logging TTY to be free
    53		DOBE
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 26.1

    54		HRROI A,[ASCIZ /**LEAFSV /]  ; Identify source of message
    55		PSOUT
    56	ENDLO2:	MOVE A,C		; Recover message pointer
    57		PSOUT			; Print message
    58	ENDLO3:	HRRZ A,LOGBPT		; Get rh of current pointer
    59		CAIGE A,LOGBUF+LOGBFS/2	; More than half full?
    60		 JRST ULKLOG		; No, unlock buffer and return
    61		JRST DMPLO1
    62	
    63	LS LTTTIM		; Time we last printed on logging TTY
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 27

     1	
     2	; Logging routines (cont'd)
     3	
     4	; Initialize logging package
     5	; Returns +1
     6	; Clobbers A
     7	
     8	INILOG:	MOVE A,[POINT 7,LOGBUF]	; Initialize byte ptr into buffer
     9		MOVEM A,LOGBPT
    10		TIME			; Get now
    11		ADD A,[LOGLAT*^D1000]	; Compute time to force dump
    12		MOVEM A,LOGTIM		; Store it
    13		SETOM LOGLOK		; Free the logging lock
    14		POPJ P,
    15	
    16	; Routine to lock logger
    17	LOKLOG:	AOSE LOGLOK
    18		 JRST [CAMN FX,LOGLKR	; Do we own the log lock?
    19			POPJ P,		; Yes, just return
    20		       JRST .-1]	; No, loop on getting it
    21		MOVEM FX,LOGLKR		; Save locker of log
    22		POPJ P,
    23	
    24	; Routine to call on exiting logging code
    25	ULKLOG:	SETOM LOGLOK
    26		POPJ P,
    27	
    28	; Dump log buffer on file
    29	; Returns +1
    30	; Clobbers A-C
    31	
    32	DMPLOG::SKIPGE LOGBPT		; Any text buffered?
    33		 JRST DMPLO5		; No, just reset clock
    34		PUSHJ P,LOKLOG
    35	DMPLO1:	MOVSI C,(1B8+1B17)	; Ignore deleted, short form
    36	DMPLO2:	MOVE A,C		; Get bits
    37		HRROI B,[ASCIZ /<SYSTEM>LEAFSV.LOG/]
    38		TLNE F,(DEBUGF)		; Debugging?
    39		 HRROI B,[ASCIZ /LEAFSV.LOG/]  ; Yes, make private log
    40		GTJFN			; Look for an existing log file
    41		 JRST [	TLON C,(1B0)	; Failed, maybe make a new version
    42			 JRST DMPLO2	; Try again
    43			MOVE C,A	; Save reason for failure
    44			JRST DMPLO3]	; Already did, give up
    45		MOVE C,A		; Ok, save JFN
    46		MOVE B,[7B5+1B22]	; Open for append
    47		OPENF
    48		 JRST [	EXCH A,C	; Failed, recover JFN
    49			RLJFN		; Release it
    50			 CAI
    51			HRRZ A,LOGBPT	; Look at buffer pointer again
    52			CAIGE A,LOGBUF+LOGBFS-^D<200/5>  ; Desperately full?
    53			 JRST DMPLO4	; No, leave it and try again later
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 27.1

    54			JRST DMPLO3]	; Yes, flush buffer
    55		HRROI B,LOGBUF		; Ok, make string ptr to log buffer
    56		SETZ C,			; Until null
    57		SOUT			; Append bufferful to log file
    58		CLOSF			; Close it
    59		 CAI			; Huh?
    60		MOVE A,[POINT 7,LOGBUF]	; Reinitialize buffer pointer
    61		MOVEM A,LOGBPT
    62	DMPLO4:	PUSHJ P,ULKLOG
    63	DMPLO5:	TIME			; Get now
    64		ADD A,[LOGLAT*^D1000]	; Compute time to force dump
    65		MOVEM A,LOGTIM
    66		POPJ P,			; Done
    67	
    68	; Here if failed to open file. C has jsys error code
    69	DMPLO3:	MOVE A,[POINT 7,LOGBUF]	; Reset buffer pointer
    70		MOVEM A,LOGBPT
    71		PUSHJ P,ULKLOG
    72		JRST DMPLO5
    73	
    74	GS LOGTIM		; Time of last real append to log file
    75	GS LOGBPT		; Byte ptr into LOGBUF
    76	GS LOGBUF,LOGBFS	; Buffer region for logging entries
    77	GS LOGLOK		; Lock word on Log
    78	GS LOGLKR		; Owner of lock on log
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 28

     1	
     2		subttl	IFS Leader page simulations
     3	
     4	; These routines manage a image of an IFS leader page created from
     5	; information contained in a Twenex FDB.  These routines exist 
     6	; because the Xerox 1100 Scientific Information Processor (Dolphin
     7	; Lisp machine) uses various entries in the leader page to store/
     8	; retrieve information about a file.  This is a hopelessy machine 
     9	; dependent mechanism which will eventually be replaced by a file
    10	; property list system.  Until then, we suffer.
    11	
    12	; The following is a layout of the IFS file leader page:
    13	
    14	;	WORD			ENTRY			LENGTH (WORDS)
    15	;	----			-----			______________
    16	
    17	;	  0		Creation time				2
    18	;	  2		Write time				2
    19	;	  4		Read time				2
    20	;	  6		Name					24
    21	;	 32		Leader properties			322
    22	;	354		Spare					12
    23	;	366		Property begin|length			1
    24	;	367		Consec bit|changeSerial byte		1
    25	;	370		dirFp					5
    26	;	375		hintLastPageFA				3
    27	;	400		Complete IFS pathname			62
    28	;	462		Inherited properties			14
    29	;	476		Author					24
    30	;	522		Last backup time			2
    31	;	524		File type				1
    32	;	525		File bytesize				1
    33	;	526		IFS flags				1
    34	
    35	ldrcre==0_1		; Creation time
    36	ldrwri==2_1		; Write time
    37	ldrrea==4_1		; Read time
    38	ldrnam==6_1		; Name
    39	ldrprp==32_1		; Leader properties
    40	ldrspr==354_1		; Spare
    41	ldrpr1==366_1		; Property begin
    42	ldrbit==367_1		; Consec bit|changeSerial byte
    43	ldrdfp==370_1		; dirFp
    44	ldrhnt==375_1		; hintLastPageFA 
    45	ldrcnm==400_1		; Complete IFS pathname
    46	ldrinh==462_1		; Inherited properties
    47	ldraut==476_1		; Author
    48	ldrbkp==522_1		; Last backup time
    49	ldrtyp==524_1		; File type
    50	ldrbyt==525_1		; File bytesize
    51	ldrflg==526_1		; IFS flags
    52	
    53	; routine to return a bytepointer to a property in leader page
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 28.1

    54	; call: pushj p,getptr
    55	;	a/byte offset into leader page
    56	;	p1/address of leader page in core
    57	; returns: +1, always, 16-bit bytepointer in a
    58	getptr:	push p,b
    59		idivi a,4		; compute word offset
    60		subi b,4		; compute bytepointer offset quantity
    61		movns b			; b has 1, 2, 3, or 4
    62		lsh b,3			; b has 10, 20, 30, 40
    63		addi b,4		; b has 14, 24, 34, 44
    64		lsh b,6			; b has 1400, 2400, 3400, 4400
    65		addi b,20		; b has 1410, etc
    66		lsh b,^d24		; b has 142000,,0, etc
    67		ior a,b			; make the bytepointer
    68		addi a,ldrpag		; point into the leader
    69		pop p,b
    70		popj p,
    71	
    72		
    73	; routine to store a time into the leader page
    74	; call: pushj p,stotim
    75	;	a/Internal time
    76	;	b/bytepointer to leader page offset
    77	;	p1/address of leader page
    78	; returns: +1, always
    79	; clobbers a (returns Alto time format right-justified)
    80	stotim:	push p,a		; save time
    81		move a,b		; get byte offset into a
    82		pushj p,getptr		; make a bytepointer
    83		move b,a		; save bytepointer in b
    84		pop p,a			; restore time to a
    85		push p,b		; save b
    86		pushj p,timalt		; Convert to Alto time (ret'd in b)
    87		move a,b		; move to a
    88		pop p,b			; restore bytepointer
    89		rot a,-^d16		; get high byte
    90		idpb a,b		; deposit
    91		rot a,^D16		; get next lower byte
    92		idpb a,b		; deposit
    93		popj p,	
    94	
    95	; routine to translate Twenex FDB to leader page
    96	; call: pushj p,makldr
    97	;	a/JFN of file
    98	; returns: +1, always
    99	makldr:	camn a,ldrfil		; this JFN already in leader page?
   100		 popj p,		; yes, return now
   101		push p,b
   102		push p,c
   103		skipe ldrfil		; anything in the leader page?
   104		 pushj p,wrtldr		; yes, write it out
   105		move b,[25,,0]		; read the entire FDB
   106		movei c,fdbblk
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 28.2

   107		gtfdb
   108		push p,a		; save JFN
   109		movem a,ldrfil		; save JFN of file in LDRPAG
   110		move a,fdbblk+13	; get create time
   111		movei b,ldrcre
   112		pushj p,stotim
   113		move a,fdbblk+14	; get write time
   114		movei b,ldrwri
   115		pushj p,stotim
   116		move a,fdbblk+15	; get read time
   117		movei b,ldrrea
   118		pushj p,stotim
   119	ifn ft10x,<
   120		move a,fdbblk+21	; get last dump time (Tenex only)
   121		movei b,ldrbkp
   122		pushj p,stotim
   123	>
   124		hrroi a,temp		; write name of file
   125		move b,(p)		; get JFN
   126		move c,[1b8+1b11+1b14+1b35] ; print name.ext;version
   127		jfns
   128		movei a,ldrnam		; get pointer
   129		pushj p,getptr
   130		hrroi b,temp
   131		pushj p,wbcpst		; write into leader page
   132		hrroi a,temp
   133	ifn ft10x,<
   134		move c,[1b5+1b8+1b11+1b14+1b35]
   135	>
   136	ifn ft20,<
   137		move c,[1b2+1b5+1b8+1b11+1b14+1b35]
   138	>
   139		move b,(p)		; now format the "complete IFS pathname"
   140		jfns
   141		movei a,ldrcnm
   142		pushj p,getptr
   143		hrroi b,temp
   144		pushj p,wbcpst		; and store in core
   145		move a,fdbblk+11	; get bytesize
   146		ldb b,[point 6,a,11]
   147		movei a,ldrbyt
   148		pushj p,getptr
   149		idpb b,a		; store bytesize
   150		movei c,2		; assume type is binary
   151		cain b,7		; 7-bit bytes?
   152		 movei c,1		; Yes, type is text
   153		movei a,ldrtyp
   154		pushj p,getptr
   155		idpb c,a		; store file type
   156	ifn ft10x,<
   157		hlrz b,fdbblk+6		; get directory number of last writer
   158		hrroi a,temp		; make it into a string
   159		dirst
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 28.3

   160		 jrst [hrroi a,temp	; not in use, write a number, instead
   161		       movei c,^d8
   162		       nout		; write the number
   163			jfcl
   164		       jrst .+1]
   165		movei a,ldraut
   166		pushj p,getptr
   167		hrroi b,temp
   168		pushj p,wbcpst		; write the author string
   169	>
   170	ifn ft20,<
   171		move a,(p)		; get JFN
   172		hrli a,1		; get string of last writer
   173		hrroi b,temp
   174		gfust			; get it
   175		movei a,ldraut
   176		pushj p,getptr
   177		hrroi b,temp
   178		pushj p,wbcpst		; write the author string
   179	>
   180		pop p,a			; retrieve the JFN
   181		pop p,c
   182		pop p,b
   183		popj p,			; leave
   184	
   185	lsp ldrpag			; page on which to build IFS leader page
   186	ls ldrfil			; has JFN of file in leader page, 0 if empty
   187	
   188	; routine to write leader page back into Twenex FDB
   189	; to be supplied
   190	; call: pushj p,wrtldr
   191	; returns: +1, always
   192	; clobbers b,c
   193	wrtldr:	push p,a
   194		movei a,ldrtyp
   195		pushj p,getptr
   196		ildb b,a		; get file type from leader
   197		move a,fdbblk+11	; get bytesize from FDB
   198		ldb a,[point 6,a,11]
   199		cain a,0		; don't change it FDB already has size
   200		 jrst [hrrz a,ldrfil	; change it
   201		       hrli a,11
   202		       movei c,^d8	; assume binary file
   203		       caie b,2		; binary?
   204			movei c,^d7	; nope, text, write 7-bit bytes
   205		       movei b,(c)
   206		       setz c,
   207		       dpb b,[point 6,c,11]
   208		       movsi b,007700
   209		       chfdb
   210		       jrst .+1]
   211		setzm ldrfil
   212		pop p,a
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 28.4

   213		popj p,
   214	
PSVLEF.MAC;33                      28-Jul-82 17:29     Page 29

     1	
     2	ls fdbblk,25
     3	ls temp,100		; temp storage
     4	ls temp2,140		; another temp storage area
     5	ls LeafPk,200		; Leaf packet reception space
     6	ls LfAnPk,200		; answer space
     7	
     8	; Tables indexed by JFN
     9	gs jfntab,njfn		; connection owner,,open mode
    10	gs wildft,njfn		; GTJFN flags for JFN
    11	gs bytsiz,njfn		; byte size file written in
    12	gs bytcnt,njfn		; number of bytes in the file
    13	
    14	; Tables indexed by CX
    15	gs connum,nconn
    16	gs usrnum,nconn
    17	gs lfinit,nconn			; 0 means not initialized, <>0 means ready
    18	
    19	ls stack,stksiz			; sequin stack
    20	ls lfpdl,lflpdl			; leaf stack
    21	
    22	ls leafcx			; debugging info
    23	
    24		end start
    25	


PUPDEF.MAC;11                      28-Jul-82 17:30     Page 2

     1	;<PUP>PUPDEF.MAC.10, 31-Mar-82 15:48:46, Edit by SCHOEN
     2	; Add global storage dummy parameters to USEVAR definition
     3	;<PUP>PUPDEF.MAC;8	3/1/81			Edit by RINDFLEISCH
     4	; Added SAVE/RSTR macros for PUSH/POP and CALL/RET for PUSHJ/POPJ
     5	;<PUP>PUPDEF.MAC;7	20-Aug-80 13:12:12  Edit by SCHOEN
     6	; Added RUNM UUO for lower-fork runnable PUPFTP
     7	;<PUP>PUPDEF.MAC;6	11-Jul-80 13:06:53  Edit by SCHOEN
     8	; Added SHXINT, SHXFLG defns for user "!" typeout when not debugging
     9	;<PUP>PUPDEF.MAC;5	4/23/80		Edit by SCHOEN
    10	; SEARCH SYSDEF so calls to VACCT and GDACC simulations don't fail
    11	; on Tops20
    12	;<SCHOEN>PUPDEF.MAC;4    4/3/80			EDIT BY RINDFLEISCH
    13	; Added macros to simulate VACCT and GDACC JSYSs
    14	;<PUP>PUPDEF.MAC;3    25-Mar-80 12:45:08    EDIT BY SCHOEN
    15	; Changed (no)tenex/tops20 opdefs to macro so they work
    16	;<PUP>PUPDEF.MAC;2    21-Mar-80 12:45:08    EDIT BY SCHOEN
    17	; Define (no)tenex/tops20 macros for conditional assembly
    18	;<PUP>PUPDEF.MAC;30     2-SEP-79 15:58:49    EDIT BY TAFT
    19	;<PUP>PUPDEF.MAC;29    11-APR-79 17:31:43    EDIT BY TAFT
    20	; Put Sender property in its right alphabetical sequence, dummy
    21	;<PUP>PUPDEF.MAC;28    18-MAR-79 19:18:28    EDIT BY TAFT
    22	; Put back Sender property
    23	;<PUP>PUPDEF.MAC;27    24-MAY-78 18:12:41    EDIT BY TAFT
    24	; Add New-Store mark
    25	;<PUP>PUPDEF.MAC;26    15-SEP-77 11:19:01    EDIT BY TAFT
    26	; Fix [Mailbox-exception] command to take sub-codes
    27	;<PUP>PUPDEF.MAC;25     1-SEP-77 15:52:10    EDIT BY TAFT
    28	; Revise property and mark tables for updated Mail Transfer Protocol
    29	;<PUP>PUPDEF.MAC;24     3-JUN-77 11:04:13    EDIT BY TAFT
    30	; Remove "Sender" and "Distribution" properties
    31	;<PUP>PUPDEF.MAC;23     2-JUN-77 21:33:43    EDIT BY TAFT
    32	; Add "Size" and "Author" properties
    33	; Add "Rename" command mark
    34	;<PUP>PUPDEF.MAC;22    15-APR-77 10:03:57    EDIT BY TAFT
    35	; Add SERVF
    36	;<PUP>PUPDEF.MAC;21    31-MAR-77 20:16:42    EDIT BY TAFT
    37	; Add marks and properties for Mail Transfer Protocol
    38	;<PUP>PUPDEF.MAC;20    19-MAR-77 20:24:21    EDIT BY TAFT
    39	; Add "delete" mark type
    40	; Add date properties
    41	;<PUP>PUPDEF.MAC;18    18-MAR-77 17:05:38    EDIT BY TAFT
    42	; Move mark and property definitions here from PFUDEF.MAC.
    43	; Add some common flag bits.
    44	;<PUP>PUPDEF.MAC;16    10-MAR-77 14:24:40    EDIT BY TAFT
    45	; Divide into two definitions files:
    46	; PUPDEF.MAC contains definitions common to PUPSRV and PUPFTP
    47	; PSVDEF.MAC contains stuff specific to PUPSRV
    48	;<PUP>PUPDEF.MAC;14    20-OCT-76 13:27:17    EDIT BY TAFT
    49	; Add defs for net directory server
    50	;<PUP>PUPDEF.MAC;13     2-OCT-76 23:16:30    EDIT BY TAFT
    51	; Add defs for gateway info server
    52	;<PUP>PUPDEF.MAC;11    30-JUN-76 18:04:45    EDIT BY TAFT
    53	; Revise storage assignment macros
PUPDEF.MAC;11                      28-Jul-82 17:30     Page 2.1

    54	; Add defs for event report server
PUPDEF.MAC;11                      28-Jul-82 17:30     Page 3

     1	
     2	; Copyright 1979 by Xerox Corporation
     3	
     4		UNIVERSAL PUPDEF -- DEFINITIONS COMMON TO PUPSRV AND PUPFTP
     5		SUBTTL E. A. Taft / September, 1975
     6	
     7	IFNDEF FT10X,<SEARCH SYSDEF>
     8	
     9	; Standard Accumulator assignments
    10	
    11		F=0		; Flags
    12	
    13		A=1		; General scratch
    14		B=2
    15		C=3
    16		D=4
    17	
    18		P1=10		; Permanent -- saved by callees
    19		P2=11
    20		P3=12
    21		P4=13
    22	
    23		P=17		; Stack
    24	
    25	
    26	; Flag assignments common to PUPSRV and PUPFTP
    27	
    28	DEBUGF==1B0		; In debug mode
    29	ENABLF==1B1		; We are enabled as wheel/operator
    30	SERVF==1B2		; On if we are server, off if user
    31	RUNF==1B3		; PUPFTP running as lower fork option
    32	
    33	RAISEF==1B18		; Raise lower-case input
    34	SHXFLG==1B19		; Typed a "!" on a line
    35	
    36	
    37	; Macros to define conditional assembly for Tops-20/Tenex
    38	; assumes calling program has "SEARCHed SYSDEF"
    39	; ejs, 3/20/80
    40	define tops20,<ifn ft20>
    41	define notops20,<ife ft20>
    42	define tenex,<ifn ft10x>
    43	define notenex,<ife ft10x>
    44	
    45	; Macro to declare storage PC's to be used in a module
    46	
    47	DEFINE USEVAR(LSVAR,LSPVAR,GSVAR<GSVAR>,GSPVAR<GSPVAR>) <
    48		DEFINE LS(LOC,SIZE<1>) <.ASSIGN LOC,LSVAR,SIZE>
    49		DEFINE LSP(LOC,SIZE<1>) <.ASSIGN LOC,LSPVAR,^O1000*<SIZE>>
    50		DEFINE GS(LOC,SIZE<1>) <.ASSIGN LOC,GSVAR,SIZE>
    51		DEFINE GSP(LOC,SIZE<1>) <.ASSIGN LOC,GSPVAR,^O1000*<SIZE>>
    52	>
PUPDEF.MAC;11                      28-Jul-82 17:30     Page 4

     1	
     2	; Definitions needed to append items to a list and then extract
     3	;  them all for assembly in a single place
     4	
     5	DEFINE APPEND(DEF,ITEM) <
     6		DEFINE DEF(XX,MORE) <XX DEF,<ITEM,MORE>>
     7	>
     8	DEFINE EXPAND(DEF,OP) <
     9		DEFINE OPMAC(A,ITEM) <IRP ITEM <IFNB <ITEM>,<OP>>>
    10		DEF(OPMAC)
    11		PURGE OPMAC
    12	>
    13	
    14	DEFINE UUO(OP,DISP) <
    15		UUON==UUON+1
    16		OPDEF OP [<UUON>B8]
    17	IFB <DISP>,<UUOS(APPEND,%'OP)>
    18	IFNB <DISP>,<UUOS(APPEND,DISP)>
    19	>
    20	
    21	APPEND(UUOS)	;INIT DISPATCH LIST
    22	UUON==0		;INIT UUO NUMBERS
    23	
    24	
    25	; UUOs used in PUPSRV and PUPFTP
    26	
    27		UUO PRINT	; Print character specified in eff adr
    28		UUO UTYPE	; Type message on TTY
    29		UUO UDTYPE	; Type message on TTY iff debugging
    30		UUO UWRITE	; Write message on arbitrary designator
    31		UUO UFTPM	; Send FTP reply message
    32	
    33	; UUOs used only in PUPSRV
    34	
    35		UUO ULOG	; Log a message
    36		UUO UELOG	; Log to both file and TTY
    37	
    38	; UUOs used only in PUPFTP
    39	
    40		UUO UERROR	; Type error message, clear input buffer
    41		UUO UNOISE	; Print noise words if Escape hit
    42		UUO UPROMP	; Type text and also append to cmd buffer
    43		UUO URUNM	; Error message to shared page
    44	
    45	; Macros to call the above UUOs
    46	
    47	DEFINE LOG(STRING) <ULOG [ASCIZ \STRING\]>
    48	DEFINE ELOG(STRING) <UELOG [ASCIZ \STRING\]>
    49	DEFINE TYPE(STRING) <UTYPE [ASCIZ \STRING\]>
    50	DEFINE DTYPE(STRING) <UDTYPE [ASCIZ \STRING\]>
    51	DEFINE NOISE(STRING) <UNOISE [ASCIZ \(STRING) \]>
    52	DEFINE PROMPT(STRING) <UPROMP [ASCIZ \STRING\]>
    53	DEFINE ERROR(STRING,NPOP<0>) <UERROR NPOP,[ASCIZ \STRING\]>
PUPDEF.MAC;11                      28-Jul-82 17:30     Page 4.1

    54	DEFINE WRITE(AC,STRING) <
    55		IFNB <STRING>,<UWRITE AC,[ASCIZ \STRING\]>
    56		IFB <STRING>,<UWRITE A,[ASCIZ \AC\]>
    57	>
    58	DEFINE FTPM(TYPE,CODE,STRING,NPOP<0>,EOCF) <
    59		ZZ==<IFNB <EOCF>,<1>>
    60		UFTPM [<MK'TYPE>B7+<CODE>B15+<ZZ>B16+<NPOP>+1
    61			ASCIZ \STRING\]
    62	>
    63	DEFINE RUNM(TYPE,STRING) <
    64		URUNM [TYPE
    65		       ASCIZ \STRING\]
    66	>
    67	
    68	; MACRO definitions to save and restore lists of locations
    69	DEFINE SAVE(LST)<
    70	   IRP LST,<PUSH P,LST>		; Save stuff on stack
    71	>
    72	
    73	DEFINE RSTR(LST)<
    74	   IRP LST,<POP P,LST>		; Recover stuff from stack
    75	>
    76	
    77	; OPDEF's for subroutine call/return
    78	OPDEF	CALL [PUSHJ P,]
    79	OPDEF	RET  [POPJ P,]
    80	
PUPDEF.MAC;11                      28-Jul-82 17:30     Page 5

     1	
     2	; FTP-related definitions common to server and user
     3	
     4	USRSTL==^D39		; Maximum name/password/acct string lengths
     5	NAMSTL==^D<2*39+1+2*39>	; Name.Extension length (with possible ^Vs)
     6	SFNSTL==USRSTL+2+NAMSTL+7  ; Server-Filename string length
     7	
     8	PQUOTE=="'"		; Quote character in property lists
     9	CR==15			; Char defs
    10	LF==12
    11	FF==14
    12	DEL==177
    13	EOL==37			; Tenex EOL character (internal use only)
    14	
    15	; Global network numbers (assigned by Jon Postel/ARPA)
    16	NW%CHS==7		; CHAOSNET
    17	NW%ARP==12		; ARPANET
    18	NW%DLN==26		; DIALNET
    19	NW%SUN==44		; SUNET
    20	NW%LCL==:NW%SUN		; Local connected network for PUPSRV
    21	
    22	SHXINT==^d10		; Type a "!" every 10 pages if not debugging
    23	
    24	; Property list names and assignments
    25	; Calls are of the form
    26	;	X internal mnemonic , property name , storage
    27	; The internal mnemonic must be 4 characters or less.
    28	; Entries must be sorted alphabetically by property name.
    29	; "Storage" is the maximum number of words needed to store
    30	;  the property (default 1).
    31	; Offsets in a property list are assigned to P.' mnemonic.
    32	; Dispatches to process received properties are PP' mnemonic.
    33	
    34	DEFINE PNAMES <
    35		X AUTH,<AUTHOR>,USRSTL/5+1
    36		X BYTE,<BYTE-SIZE>
    37		X CNAM,<CONNECT-NAME>
    38		X CPSW,<CONNECT-PASSWORD>,USRSTL/5+1
    39		X CDAT,<CREATION-DATE>
    40		X DEVI,<DEVICE>,USRSTL/5+1
    41		X DIRE,<DIRECTORY>,USRSTL/5+1
    42		X EOLC,<END-OF-LINE-CONVENTION>
    43		X MLBX,<MAILBOX>,0
    44		X NAMB,<NAME-BODY>,NAMSTL/5+1
    45		X RDAT,<READ-DATE>
    46		X SNDR,<SENDER>,USRSTL/5+1
    47		X SFIL,<SERVER-FILENAME>,SFNSTL/5+1
    48		X SIZE,<SIZE>
    49		X TYPE,<TYPE>
    50		X UACT,<USER-ACCOUNT>,USRSTL/5+2
    51		X UNAM,<USER-NAME>
    52		X UPSW,<USER-PASSWORD>,USRSTL/5+1
    53		X VERS,<VERSION>
PUPDEF.MAC;11                      28-Jul-82 17:30     Page 5.1

    54		X WDAT,<WRITE-DATE>
    55	>
    56	
    57	
    58	; Assign offsets for individual properties in a property list
    59	
    60	DEFINE X(SYM,NAME,SIZE<1>) <
    61		P.'SYM==PLSIZE
    62		PLSIZE==PLSIZE+SIZE
    63	>
    64		PLSIZE==0
    65	
    66		PNAMES
PUPDEF.MAC;11                      28-Jul-82 17:30     Page 6

     1	
     2	; Mark type assignments
     3	; Calls are of the form
     4	;	XN internal mnemonic , mark type , name string , flags
     5	; or	XS internal mnemonic , mark type , name string , flags
     6	; The internal mnemonic must be 4 characters or less.
     7	; Mark type must be octal.  Entries must be in order of Mark type.
     8	; Mark types are assigned to MK' mnemonic.
     9	; Dispatches to process received Marks are C.' mnemonic.
    10	; The XS macro declares the Mark to have sub-codes.
    11	
    12	; Flag assignments
    13	;	B0			; Command has subcommands
    14		NFETCH==1B1		; Do not pre-fetch command text
    15		OKRETR==1B2		; Command ok during Retrieve
    16		OKSTOR==1B3		; Command ok during Store
    17	
    18	DEFINE MARKS <
    19		XN RETR, 1,<Retrieve>
    20		XN STOR, 2,<Store>
    21		XS YES,  3,<Yes>,OKRETR+OKSTOR
    22		XS NO,   4,<No>,OKRETR+OKSTOR
    23		XN FILE, 5,<Here-is-file>,NFETCH+OKSTOR
    24		XN EOC,  6,<End-of-command>,NFETCH+OKRETR+OKSTOR
    25		XN COMM, 7,<Comment>,OKRETR+OKSTOR
    26		XS VERS,10,<Version>
    27		XN NSTO,11,<New-store>
    28		XN DIR, 12,<Directory>
    29		XN PLST,13,<Here-is-property-list>
    30		XN YUSR,14,<You-are-user>
    31		XN ABOR,15,<Abort>,OKRETR+OKSTOR
    32		XN DELE,16,<Delete>
    33		XN RENA,17,<Rename>
    34		XN SMAI,20,<Store-mail>
    35		XN RMAI,21,<Retrieve-mail>
    36		XN FMAI,22,<Flush-mail>
    37		XS MBEX,23,<Mailbox-exception>
    38	>
    39	
    40	
    41	; Assign the Mark type symbols
    42	
    43	DEFINE XN(SYM,TYPE,NAME,FLAGS) <
    44		MK'SYM==TYPE
    45		NMARKS==NMARKS+1
    46	>
    47	DEFINE XS(SYM,TYPE,NAME,FLAGS) <
    48		MK'SYM==TYPE
    49		NMARKS==NMARKS+1
    50	>
    51	
    52		NMARKS==0
    53		MARKS
PUPDEF.MAC;11                      28-Jul-82 17:30     Page 6.1

    54	
    55	
    56	
    57	
    58		END


PUPPRP.MAC;4                       28-Jul-82 17:30     Page 2

     1	;<NORMAL>PUPPRP.MAC.7 10-Jan-81 21:01:11    Edit by SCHOEN
     2	; Made twenex runtime compatible
     3	;<PUP>PUPPRP.MAC.6    30-Jul-80 15:47:12    TECO'd by GILMURRAY
     4	; Remove 2 and Z and insert !, #, and + in FILQUO table
     5	;<PUP>PUPPRP.MAC.6, 17-Jun-80 14:51:28, Edit by SCHOEN
     6	; tops20: Fixed missing stack clean-up in GSTUSR,GSTDIR
     7	;<PUP>PUPPRP.MAC.5, 12-Jun-80 17:23:27, Edit by SCHOEN
     8	; Created GSTUSR routine to do RCUSR for PPUNAM, GSTDIR 
     9	; routine for PPCNAM (Tops20).
    10	;<PUP>PUPPRP.MAC;9  12-Jun-80  Edit by Schoen
    11	; Fixed directory # handling in PPUNAM, GSTDIR in tops20 version
    12	;<PUP>PUPPRP.MAC;8     15-APR-80    Edit by Schoen
    13	; Add Tenex/Tops20 conditional assembly
    14	;<PUP>PUPPRP.MAC;7     2-SEP-79 16:00:50    EDIT BY TAFT
    15	;<PUP>PUPPRP.MAC;6     2-JUN-77 21:32:49    EDIT BY TAFT
    16	; Add "Author" and "Size" property parsers
    17	;<PUP>PUPPRP.MAC;5    31-MAR-77 20:25:23    EDIT BY TAFT
    18	; Put in hooks for mail server
    19	; Make individual property interpreters conditionally external
    20	; Reinstate forcing device and directory to upper-case.
    21	; (I knew there was a reason.  Damn silly Tenex problem!)
    22	;<PUP>PUPPRP.MAC;3    19-MAR-77 20:05:26    EDIT BY TAFT
    23	; Add code to parse date properties
    24	;<PUP>PUPPRP.MAC;2    18-MAR-77 18:14:45    EDIT BY TAFT
    25	; Call external REFILL procedure in SCNPRP
    26	;<PUP>PUPPRP.MAC;1    18-MAR-77 17:06:55    EDIT BY TAFT
    27	; Modified to be usable in both server and user
    28	; Renamed PUPPRP.MAC
    29	; Uniformly generate "No" response before giving error return.
    30	; Remove device/directory name check -- it will be caught later if
    31	; actually used.
    32	;<PUP>PFUPRP.MAC;3    15-MAR-77 18:54:26    EDIT BY TAFT
    33	; Add Tenex-paged type
    34	;<PUP>PFUPRP.MAC;2    10-MAR-77 14:21:00    EDIT BY TAFT
    35	; Split out from PUPFTP.MAC
PUPPRP.MAC;4                       28-Jul-82 17:30     Page 3

     1	
     2	; Copyright 1979 by Xerox Corporation
     3	
     4		TITLE PUPPRP -- PUP FTP PROPERTY LIST PARSER
     5		SUBTTL E. A. Taft / March 1977
     6	
     7		SEARCH PUPDEF
     8		SEARCH MONSYM
     9	
    10	
    11	; Scan and interpret property list
    12	;	A/ Source string pointer (first char expected to be "(" )
    13	;	B/ Pointer to property list storage region
    14	; Returns +1:  Syntax error, "No" reply already generated
    15	;		(caller may have to supply terminating EOC)
    16	;	+2:  Successful, A/ Pointer to matching ")"
    17	; The external REFILL procedure is called often.  It should
    18	; do any necessary management of the source string pointer in A.
    19	; Clobbers C, D
    20	
    21	SCNPRP::PUSHJ P,SAVE1##		; Protect P1
    22		MOVE P1,B		; Put plist pointer in protected ac
    23		TLC A,-1		; Convert -1 lh string ptr
    24		TLCN A,-1		;  to standard byte ptr
    25		 HRLI A,(POINT 7)
    26		ILDB B,A		; Check first char
    27		CAIE B,"("		; Good start of property list?
    28		 FTPM(NO,10,<Malformed property list>,1)
    29	
    30	; Here to begin scanning new property
    31	SCNPR1:	PUSHJ P,REFILL##	; Refill buffer if necessary
    32		ILDB C,A		; Get next char
    33		CAIN C," "		; Permit extra spaces here
    34		 JRST SCNPR1
    35		CAIN C,")"		; End of property list?
    36		 JRST SKPRET##		; Yes, return +2
    37		CAIE C,"("		; Start of new property?
    38		 FTPM(NO,10,<Malformed property list>,1)
    39		MOVE B,[-NPROPS,,PLDISP]  ; Make ptr to property name table
    40		PUSHJ P,FNDKEY		; Get and lookup property name
    41		 FTPM(NO,10,<Malformed property name>,1)
    42		 JRST [	HRROI B,TEMP##	; Unrecognized property, say so
    43			DTYPE <Unrecognized property "%2S"%/>
    44			MOVEI C,5000	; Max # characters to discard
    45			PUSHJ P,GTPVAL	; Scan and discard property value
    46			 FTPM(NO,10,<Malformed property>,1)
    47			JRST SCNPR3]	; Ignore property, on to next
    48		LDB C,A			; Check terminator
    49		CAIE C," "		; Space?
    50		 FTPM(NO,10,<Malformed property>,1)
    51		MOVE D,0(B)		; Found, get dispatch
    52		HLLM D,0(P)		; Save entry pointer in case error
    53		TRZ F,RAISEF		; Default is not to raise lower case
PUPPRP.MAC;4                       28-Jul-82 17:30     Page 3.1

    54		PUSHJ P,0(D)		; Scan and store property value
    55		 POPJ P,		; Failed, return +1
    56	SCNPR3:	LDB C,A			; Get terminator
    57		CAIE C,")"		; Proper end of property?
    58		 FTPM(NO,10,<Malformed property>,1)
    59		JRST SCNPR1		; Yes, on to next property
PUPPRP.MAC;4                       28-Jul-82 17:30     Page 4

     1	
     2	; Construct property name and dispatch table
     3	
     4	DEFINE X(SYM,NAME,SIZE<1>) <
     5	IF2,<IFNDEF PP'SYM,<EXTERN PP'SYM>>
     6		[ASCIZ /NAME/] ,, PP'SYM
     7	>
     8	
     9	PLDISP:	PNAMES
    10	
    11		NPROPS==.-PLDISP	; Number of properties
    12	
    13	
    14	
    15	; Subroutines to process individual properties
    16	; All have the following calling sequence:
    17	;	A/ Source string ptr
    18	;	P1/ Property list pointer
    19	; Returns +1:  Error, reply already generated
    20	;	+2:  Successful, A/ byte ptr to property value terminator
    21	; May clobber B-D
    22	
    23	
    24	; (Author <string>)
    25	
    26	PPAUTH:	HRROI B,P.AUTH(P1)	; Where to put string
    27		MOVEI C,USRSTL		; Max # of characters
    28		PUSHJ P,GTPVAL		; Collect and store string
    29		 FTPM(NO,10,<Malformed property>,1)
    30		JRST SKPRET##		; Return +2
    31	
    32	
    33	; (Byte-Size <decimal number>)
    34	
    35	PPBYTE:	MOVEI C,^D10		; Decimal radix
    36		NIN			; Convert number
    37		 FTPM(NO,16,<Malformed Byte-Size>,1)
    38		CAIL B,1		; Check for reasonable value
    39		CAILE B,^D36
    40		 FTPM(NO,16,<Byte-Size not in range 1-36>,1)
    41		MOVEM B,P.BYTE(P1)	; Ok, store it in property list
    42		JRST SKPRET##		; Return +2
    43	
PUPPRP.MAC;4                       28-Jul-82 17:30     Page 5

     1	
     2	; (Connect-Name <directory name>) - only server should receive this
     3	
     4	PPCNAM:	PUSHJ P,GSTDIR		; Collect string and check it
     5		 FTPM(NO,10,<Malformed property>,1)
     6		 FTPM(NO,23,<Illegal Connect-Name>,1)
     7		MOVEM C,P.CNAM(P1)	; Store dir # in property list
     8		JRST SKPRET##		; Return +2
     9	
    10	
    11	; (Connect-Password <string>) - only server should receive this
    12	
    13	PPCPSW:	HRROI B,P.CPSW(P1)	; Where to put string
    14		MOVEI C,USRSTL		; Max # of characters
    15		TRO F,RAISEF		; Raise lower case letters
    16		PUSHJ P,GTPVAL		; Collect and store password string
    17		 FTPM(NO,10,<Malformed property>,1)
    18		JRST SKPRET##		; Return +2
    19	
    20	
    21	; (Creation-Date <date>)
    22	
    23	PPCDAT:	SETZ B,			; Permit arbitrary format
    24		PUSHJ P,GDATM			; Input date and time
    25		 FTPM(NO,25,<Malformed Creation-Date>,1)
    26		MOVEM B,P.CDAT(P1)	; Ok, store it in property list
    27		JRST SKPRET##
    28	
    29	
    30	; (Device <device name>)
    31	
    32	PPDEVI:	TRO F,RAISEF		; Raise lower case letters
    33		HRROI B,P.DEVI(P1)	; Where to put string
    34		MOVEI C,USRSTL		; Max length
    35		PUSHJ P,GTPVAL		; Collect and store device name
    36		 FTPM(NO,10,<Malformed property>,1)
    37		JRST SKPRET##		; Return +2
PUPPRP.MAC;4                       28-Jul-82 17:30     Page 6

     1	
     2	; Property value processing routines (cont'd)
     3	
     4	; (Directory <directory name>)
     5	
     6	PPDIRE:	TRO F,RAISEF		; Raise lower case letters
     7		HRROI B,P.DIRE(P1)	; Put property value here
     8		MOVEI C,USRSTL		; Max # characters
     9		PUSHJ P,GTPVAL		; Get property value string
    10		 FTPM(NO,10,<Malformed property>,1)
    11		JRST SKPRET##		; Return +2
    12	
    13	
    14	; (End-Of-Line-Convention CR|CRLF|Transparent)
    15	
    16	PPEOLC:	MOVE B,[-3,,EOLTAB]	; Set pointer to keyword table
    17		PUSHJ P,FNDKEY		; Get and lookup keyword
    18		 FTPM(NO,17,<Illegal End-of-Line-Convention>,1)
    19		 FTPM(NO,17,<Illegal End-of-Line-Convention>,1)
    20		HRRZ B,0(B)		; Succeeded, get entry value
    21		MOVEM B,P.EOLC(P1)	; Store in property list
    22		JRST SKPRET##		; Return +2
    23	
    24	EOLTAB:	[ASCIZ /CR/] ,, 0
    25		[ASCIZ /CRLF/] ,, 1
    26		[ASCIZ /TRANSPARENT/] ,, 2
    27	
    28	
    29	; (Name-Body <name.extension>)
    30	
    31	PPNAMB:	MOVE B,[POINT 7,P.NAMB(P1)]  ; Init byte ptr
    32		MOVEI C,NAMSTL		; Max length
    33		TRZ F,RAISEF		; Use this as period seen flag
    34	PPNAM1:	ILDB D,A		; Get char from property value
    35		JUMPE D,[FTPM(NO,10,<Malformed property>,1)]
    36		CAIN D,PQUOTE		; Character quote?
    37		 JRST [	ILDB D,A	; Yes, get next literally
    38			JUMPE D,[FTPM(NO,10,<Malformed property>,1)]
    39			JRST .+3]
    40		CAIN D,")"		; End of property value?
    41		 JRST PPNAM4		; Yes
    42		SOJL C,[FTPM(NO,13,<Name-Body too long>,1)]  ; Check length
    43		CAIN D,"."		; Period?
    44		 JRST [	TRON F,RAISEF	; Yes, seen one already?
    45			 JRST PPNAM3	; No, store literally
    46			JRST PPNAM2]	; Yes, quote it
    47		PUSH P,D+1		; Get another ac
    48		IDIVI D,^D36		; Compute index into bit table
    49		MOVE D,FILQUO(D)	; See if need to quote character
    50		LSH D,(D+1)		; Set sign if so
    51		POP P,D+1
    52		JUMPGE D,PPNAM3		; Jump if not
    53	PPNAM2:	MOVEI D,"V"-100		; Insert a control-V
PUPPRP.MAC;4                       28-Jul-82 17:30     Page 6.1

    54		IDPB D,B
    55		SOJL C,[FTPM(NO,13,<Name-Body too long>,1)]  ; Check length
    56	PPNAM3:	LDB D,A			; Recover character
    57		IDPB D,B		; Store it
    58		JRST PPNAM1		; Back for more
    59	
    60	PPNAM4:	SETZ D,			; Done, append null
    61		IDPB D,B
    62		JRST SKPRET##		; Return +2
    63	
    64	; Bit table of characters that must be quoted with ^V for GTJFN
    65	FILQUO:	777777777775		; 000-043
    66		003200035600		; 044-107
    67		000000104000		; 110-153
    68		000007600000		; 154-177
PUPPRP.MAC;4                       28-Jul-82 17:30     Page 7

     1	
     2	; Property value processing routines (cont'd)
     3	
     4	; (Read-Date <date>)
     5	
     6	PPRDAT:	SETZ B,			; Permit arbitrary format
     7		PUSHJ P,GDATM			; Input date and time
     8		 FTPM(NO,27,<Malformed Read-Date>,1)
     9		MOVEM B,P.RDAT(P1)	; Ok, store it in property list
    10		JRST SKPRET##
    11	
    12	
    13	; (Server-Filename <filename>)
    14	
    15	PPSFIL:	HRROI B,P.SFIL(P1)	; Where to put name string
    16		MOVEI C,SFNSTL		; Maximum length
    17		PUSHJ P,GTPVAL		; Get property value string
    18		 FTPM(NO,10,<Malformed property>,1)
    19		JRST SKPRET##		; Succeeded, return +2
    20	
    21	
    22	; (Size <decimal number>)
    23	
    24	PPSIZE:	MOVEI C,^D10		; Decimal radix
    25		NIN			; Convert number
    26		 FTPM(NO,10,<Malformed size>,1)
    27		MOVEM B,P.SIZE(P1)	; Store in property list
    28		JRST SKPRET##		; Return +2
    29	
    30	
    31	; (Type Text|Binary|Tenex-Paged)
    32	
    33	PPTYPE:	MOVE B,[-3,,TYPTAB]	; Set pointer to keyword table
    34		PUSHJ P,FNDKEY		; Get and lookup keyword
    35		 FTPM(NO,15,<Illegal Type>,1)
    36		 FTPM(NO,15,<Illegal Type>,1)
    37		HRRZ B,0(B)		; Succeeded, get entry value
    38		MOVEM B,P.TYPE(P1)	; Store in property list
    39		JRST SKPRET##		; Return +2
    40	
    41	TYPTAB:	[ASCIZ /BINARY/] ,, 2
    42		[ASCIZ /TENEX-PAGED/] ,, 3
    43		[ASCIZ /TEXT/] ,, 1
    44	
    45	
    46	; (User-Name <username>) - only server should receive this
    47	
    48	PPUNAM:	PUSHJ P,GSTUSR		; Collect string and check it
    49		 FTPM(NO,10,<Malformed property>,1)
    50		 FTPM(NO,20,<Illegal User-Name>,1)
    51		SKIPGE B		; Make sure not files-only
    52		 FTPM(NO,20,<Files-only directory illegal as User-Name>,1)
    53		MOVEM C,P.UNAM(P1)	; Store dir # in property list
PUPPRP.MAC;4                       28-Jul-82 17:30     Page 7.1

    54		JRST SKPRET##		; Return +2
    55	
    56	
    57	; (User-Password <string>) - only server should receive this
    58	
    59	PPUPSW:	HRROI B,P.UPSW(P1)	; Where to put string
    60		MOVEI C,USRSTL		; Max # of characters
    61		TRO F,RAISEF		; Raise lower case letters
    62		PUSHJ P,GTPVAL		; Collect and store password string
    63		 FTPM(NO,10,<Malformed property>,1)
    64		JRST SKPRET##		; Return +2
PUPPRP.MAC;4                       28-Jul-82 17:30     Page 8

     1	
     2	; Property value processing routines (cont'd)
     3	
     4	; (User-Account <string>) - only server should receive this
     5	
     6	PPUACT:	HRROI B,P.UACT+1(P1)	; Where to put string
     7		MOVEI C,USRSTL		; Max # of characters
     8		TRO F,RAISEF		; Raise lower-case letters
     9		PUSHJ P,GTPVAL		; Collect and store account string
    10		 FTPM(NO,10,<Malformed property>,1)
    11		MOVE D,A		; Preserve source string ptr
    12		HRROI A,P.UACT+1(P1)	; See if account is numeric
    13		MOVEI C,^D10
    14		NIN
    15		 JRST PPUAC1		; No, assume string
    16		TLNE B,(7B2)		; Yes, make sure in range
    17		 FTPM(NO,22,<Illegal User-Account>,1)
    18		TLOA B,(5B2)		; Flag numeric account
    19	PPUAC1:	 HRROI B,P.UACT+1(P1)	; Here if string account
    20		MOVEM B,P.UACT(P1)	; Store account designator
    21		MOVE A,D		; Restore source string ptr
    22		JRST SKPRET##		; Return +2
    23	
    24	
    25	; (Version <decimal number>)
    26	
    27	PPVERS:	MOVEI C,^D10		; Decimal radix
    28		NIN			; Convert number
    29		 FTPM(NO,14,<Malformed Version>,1)
    30		CAML B,[-2]		; Check for reasonable value
    31		CAILE B,777774
    32		 FTPM(NO,14,<Illegal Version>,1)
    33		MOVEM B,P.VERS(P1)	; Ok, store it in property list
    34		JRST SKPRET##		; Return +2
    35	
    36	
    37	; (Write-Date <date>)
    38	
    39	PPWDAT:	SETZ B,			; Permit arbitrary format
    40		PUSHJ P,GDATM			; Input date and time
    41		 FTPM(NO,26,<Malformed Write-Date>,1)
    42		MOVEM B,P.WDAT(P1)	; Ok, store it in property list
    43		JRST SKPRET##
PUPPRP.MAC;4                       28-Jul-82 17:30     Page 9

     1	
     2	; Collect property value and interpret it as a string dat and time
     3	; ... this is necessary because servers such IFS send dates as
     4	; ... "27-May-80 16:45:34 PDT."  Twenex IDTIM breaks on the space
     5	; ... after the time, so the timezone field is left hanging.
     6	;	A/ Source string pointer
     7	; Returns +1: IDTIM failure, bad date and time supplied
     8	;	  +2: Success, A/Updated pointer, B/Date, time in internal format
     9	
    10	GDATM:	PUSH P,A		; Save entry pointer
    11		SETZ B,			; Do a normal IDTIM
    12		IDTIM
    13		 JRST [POP P,(P)	; Clean stack, and return with error
    14		       POPJ P,]
    15		LDB C,A			; See what the terminator was
    16		CAIN C,")"		; If right parens, then all OK
    17		 JRST [POP P,(P)
    18		       JRST SKPRET##]
    19		MOVEI C,"-"		; If not parens, assume time zone follows
    20		DPB C,A			; Modify string to allow it
    21		POP P,A			; Recover string pointer for retry
    22		SETZ B,
    23		IDTIM				; Retry IDTIM
    24		 POPJ P,		; Fail
    25		JRST SKPRET##
    26	
    27	; Collect property value and check it as a directory name
    28	;	A/ Source string ptr
    29	; Returns +1:  Illegal format property value
    30	;	  +2:  check failed
    31	;	  +3:  A/ Updated pointer, B/ flags, C/ dir #
    32	; Clobbers B, C
    33	
    34	GSTDIR:	PUSHJ P,GSTVAL		; Fetch the string value into TEMP+1
    35		 POPJ P,		; Failed
    36		AOS 0(P)		; OK, return at least +2, b = ptr to value
    37		JRST GSTDR
    38	
    39	; This entry is just to convert the directory string
    40	; Entry:   b = str ptr to directory name
    41	; Return:  +1, fail
    42	;	   +2, success, b = flags, c = dir #
    43	GSTDR::	PUSH P,A		; Save source string ptr
    44		PUSHJ P,.STDIR##	; Convert to directory #
    45		 JRST GSTBAD		; Not found, return +2
    46	GSTOK:	POP P,A			; a _ string ptr to next param
    47		JRST SKPRET##		; Skip return
    48	
    49	; Here for bad directory/user name
    50	GSTBAD:	SUB P,[1,,1]		; Reset the stack
    51		POPJ P,			; No skip return
    52	
    53	
PUPPRP.MAC;4                       28-Jul-82 17:30     Page 9.1

    54	; Collect property value and check it as a user name
    55	;	A/ Source string ptr
    56	; Returns +1:  Illegal format property value
    57	;	  +2:  check failed
    58	;	  +3:  A/ Updated pointer, B/ flags, C/ user #
    59	; Clobbers B, C
    60	GSTUSR:	PUSHJ P,GSTVAL		; Get the string value
    61		 POPJ P,		; Failed, return +1
    62		AOS 0(P)		; OK, return at least +2
    63		JRST GSTUS
    64	
    65	; This entry is just to convert the user string
    66	; Entry:   b = str ptr to user name
    67	; Return:  +1, fail
    68	;	   +2, success, b = flags, c = user #
    69	GSTUS::	PUSH P,A		; Ok, save the ac
    70		PUSHJ P,.STUSR##	; Convert string to user number
    71		 JRST GSTBAD		; No go
    72		JRST GSTOK		; Got it
    73	
    74	
    75	; Here to fetch the string parameter value for GSTDIR/USR into TEMP
    76	; Entry:   a = source string ptr
    77	; Return:  +1, fail
    78	;	   +2, success, a = ptr to end of param string
    79	;			b = ptr to start of value string
    80	GSTVAL:	HRROI B,TEMP##		; Buffer property value here
    81		MOVEI C,USRSTL		; Max # characters
    82		PUSHJ P,GTPVAL		; Get property value string
    83		 POPJ P,		; Failed, return +1
    84		HRROI B,TEMP##		; OK, b _ ptr to value string
    85		JRST SKPRET##		; Success
    86	
PUPPRP.MAC;4                       28-Jul-82 17:30     Page 10

     1	
     2	; Get property value string (up to ")" )
     3	;	A/ Source string ptr
     4	;	B/ Destination string ptr
     5	;	C/ Max # of characters permitted
     6	; Returns +1:  Error, overflowed or no terminating ")"
     7	;	+2:  Successful, A/ byte ptr to terminating ")"
     8	; Terminates destination string with null.
     9	; Converts lower case to upper if RAISEF is set
    10	; Clobbers B-D
    11	
    12	GTPVAL::TLC B,-1		; If lh is -1, convert to byte ptr
    13		TLCN B,-1
    14		 HRLI B,(POINT 7)
    15	GTPVA1:	ILDB D,A		; Get char from source
    16		JUMPE D,CPOPJ##		; Fail if end of source string
    17		CAIN D,PQUOTE		; Character quote?
    18		 JRST [	ILDB D,A	; Yes, get next literally
    19			JUMPE D,CPOPJ##	; But don't allow null
    20			JRST GTPVA2]
    21		CAIN D,")"		; End of property value?
    22		 SETZ D,		; Yes, remember so
    23		CAIL D,"a"		; Lower case?
    24		CAILE D,"z"
    25		 JRST GTPVA2		; No
    26		TRNE F,RAISEF		; Yes, want to raise it?
    27		 SUBI D,40		; Yes, do so
    28	GTPVA2:	SOJL C,CPOPJ##		; Fail if overflowing destination
    29		IDPB D,B		; Store byte in destination
    30		JUMPN D,GTPVA1		; Repeat if not end of property
    31		JRST SKPRET##		; Done, return +2
    32	
    33	
    34	; Get and lookup name keyword string
    35	;	A/ Source string ptr
    36	;	B/ -length ,, address of lookup table (see NAMSRC)
    37	; Returns +1:  Error, improper format
    38	;	+2:  Name not found
    39	;	+3:  Successful, B/ pointer to matching entry
    40	; Clobbers B-D;  updates A appropriately on +2 and +3 returns
    41	
    42	FNDKEY::PUSH P,B		; Save table pointer
    43		HRROI B,TEMP##		; Where to buffer string
    44		PUSHJ P,GETNAM		; Input the name
    45		 JRST [	POP P,B		; Failed, return +1
    46			POPJ P,]
    47		EXCH A,0(P)		; Ok, save string, get table
    48		HRROI B,TEMP##		; Where the name is now
    49		PUSHJ P,NAMSRC		; Look it up
    50		 JRST [	POP P,A		; Not found, recover string ptr
    51			JRST SKPRET##]	; Return +2
    52		MOVE B,A		; Ok, copy entry pointer
    53		POP P,A			; Recover string ptr
PUPPRP.MAC;4                       28-Jul-82 17:30     Page 10.1

    54		JRST SK2RET##		; Return +3
PUPPRP.MAC;4                       28-Jul-82 17:30     Page 11

     1	
     2	; Get name keyword string
     3	;	A/ Source string ptr
     4	;	B/ String ptr to temp region in which to store name
     5	; Ignores leading blanks.  Converts lower to upper case.
     6	; Terminates on any character besides alphanumeric and "-".
     7	; Terminates temp string with null (for NAMSRC).
     8	; Returns +1:  Error, first char not keyword constituent
     9	;	+2:  Ok, A/ Byte ptr to terminator
    10	; Clobbers B-D
    11	
    12	GETNAM::TLC B,-1		; If lh is -1, convert to byte ptr
    13		TLCN B,-1
    14		 HRLI B,(POINT 7)
    15		SETZ D,			; Init counter
    16	GETNA1:	ILDB C,A		; Get char from source
    17		CAIL C,"A"		; Alphabetic?
    18		CAILE C,"Z"
    19		 CAIN C,"-"		; Hyphen?
    20		  JRST GETNA2		; Yes, append to string
    21		CAIL C,"0"		; Numeric?
    22		CAILE C,"9"
    23		 CAIA
    24		  JRST GETNA2		; Yes, append to string
    25		CAIL C,"a"		; Lower case?
    26		CAILE C,"z"
    27		 JRST GETNA3		; No, terminator
    28		SUBI C,40		; Yes, capitalize
    29	GETNA2:	IDPB C,B		; Store in temp buffer
    30		AOJA D,GETNA1		; Count and loop
    31	
    32	; Here when hit terminator
    33	GETNA3:	CAIN C," "		; Blank?
    34		 JUMPE D,GETNA1		; Yes, ignore if leading
    35		JUMPE D,CPOPJ##		; Fail if string empty
    36		SETZ C,			; Append null to temp string
    37		IDPB C,B
    38		JRST SKPRET##		; Return +2
PUPPRP.MAC;4                       28-Jul-82 17:30     Page 12

     1	
     2	; Lookup name in table
     3	;	A/ -length ,, address of table to search
     4	;	B/ String ptr to name string (all letters must be capitals)
     5	; Returns +1: Not found, A points to smallest entry > key
     6	;	+2: Found, A points to matching entry
     7	; In both cases, A is still in AOBJN pointer format.  In the
     8	;  +1 return, the lh is positive if A points past end of table.
     9	; Table entry format:
    10	;	[ASCIZ /NAME/] ,, value
    11	; Clobbers A-D
    12	
    13	NAMSRC::TLC B,-1		; If lh is -1, convert to byte ptr
    14		TLCN B,-1
    15		 HRLI B,(POINT 7)
    16		JSP C,BINSRC		; Call binary search
    17	
    18	
    19	; Name comparison routine for binary search
    20	;	A/ Address of table entry to compare in rh
    21	;	B/ Search key (as passed to BINSRC)
    22	; Returns +1: Key < Entry
    23	;	+2: Key > Entry
    24	;	+3: Key = Entry
    25	; Additionally, if the key is an initial substring of the entry
    26	; (+1 return only), returns D/ string ptr to tail (else 0)
    27	; Clobbers C, D
    28	
    29	NAMCMP::PUSH P,A		; Save args
    30		PUSH P,B
    31		HLRZ A,0(A)		; Make string ptr to table entry
    32		HRLI A,(POINT 7)
    33	NAMCM1:	ILDB C,A		; Get char from table entry
    34		CAIGE C,"a"		; Make the table character uppercase
    35		 JRST NAMCM5
    36		CAIG C,"z"
    37		 TRZ C,40
    38	NAMCM5:	ILDB D,B		; Get char from search key
    39		CAIGE D,(C)		; Compare
    40		 JRST [	JUMPN D,NAMCM3	; Key < entry; if not end return +1
    41			MOVSI D,(7B5)	; If end of key make string ptr
    42			ADD D,A		;  to tail of entry
    43			JRST NAMCM4]	; Also return +1
    44		CAILE D,(C)
    45		 JRST NAMCM2		; Key > entry, return +2
    46		JUMPN D,NAMCM1		; Key char = entry, look at next
    47		AOS -2(P)		; End, key = entry, return +3
    48	NAMCM2:	AOS -2(P)
    49	NAMCM3:	SETZ D,			; Note not substring match
    50	NAMCM4:	POP P,B			; Restore args
    51		POP P,A
    52		POPJ P,
PUPPRP.MAC;4                       28-Jul-82 17:30     Page 13

     1	
     2	; Perform binary search
     3	;	A/ -length ,, address of table to search
     4	;	B/ Search key
     5	;	C/ Routine to call to compare key to entry
     6	; Returns +1: Not found, A points to smallest entry > key
     7	;	+2: Found, A points to matching entry
     8	; In both cases, A is still in AOBJN pointer format.  In the
     9	;  +1 return, the lh is positive if A points past end of table.
    10	; Clobbers A-D
    11	
    12	; The comparison routine must operate as follows:
    13	;	A/ Address of table entry to compare in rh
    14	;	B/ Search key (as passed to BINSRC)
    15	; Returns +1: Key < Entry
    16	;	+2: Key > Entry
    17	;	+3: Key = Entry
    18	; C and D may be clobbered freely, others must be protected
    19	
    20	BINSRC::PUSHJ P,SAVE2##		; Need more temps
    21		MOVE P2,C		; Save routine to call
    22		HLRE C,A		; Get negative table length
    23		MOVN C,C		; Make positive
    24		JFFO C,.+2		; Find position of first 1
    25		 POPJ P,		; Empty table, fail
    26		MOVN D,D		; Compute largest power of 2
    27		MOVSI P1,(1B0)		;  <= table length
    28		LSH P1,(D)
    29		HRLI P1,(P1)		; Put in both halves
    30		SUB A,[1,,1]		; Backup ptr to one before table
    31	BINSR1:	ADD A,P1		; Add increment to table pointer
    32	BINSR2:	LSH P1,-1		; Halve increment (both halves)
    33		TRZ P1,400000
    34		JUMPGE A,BINSRL		; Jump if off end of table
    35		PUSHJ P,0(P2)		; Call routine to do compare
    36		 JRST BINSRL		; Key < entry
    37		 JRST BINSRG		; Key > entry
    38		JRST SKPRET##		; Key = entry, return +2
    39	
    40	; Here if key > entry: advance table pointer
    41	BINSRG:	JUMPN P1,BINSR1		; Loop if increment nonzero
    42		AOBJN A,CPOPJ##		; Set pointer and fail if zero
    43	
    44	; Here if key < entry, or past end: backup table pointer
    45	BINSRL:	JUMPE P1,CPOPJ##	; Fail if increment zero
    46		SUB A,P1		; Backup table pointer
    47		JRST BINSR2		; Try again
    48	
    49	
    50		END


PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 2

     1	;<PUP>PUPSEQ.MAC.35, 29-Jun-82 21:17:01, Edit by SCHOEN
     2	; Destroy timed out connections which had been dallying
     3	;<PUP>PUPSEQ.MAC.34, 10-Jun-82 12:31:54, Edit by SCHOEN
     4	; Let OS do unmapping of a fork's pages in KILLFK
     5	;<PUP>PUPSEQ.MAC.33, 15-May-82 19:37:13, Edit by SCHOEN
     6	; Zero last locker BEFORE freeing lock in UNLOCK
     7	;<PUP>PUPSEQ.MAC.28, 27-Apr-82 22:35:26, Edit by SCHOEN
     8	; Don't resignal server fork on receipt of duplicate packet
     9	; Make sure LEAFFK is handled as two half-words
    10	; One more time -- filter out non-sequins at RNTSV4
    11	; Rework queues; dispense with PP queue
    12	; SENSEQ sends data immediately, then queues it for retransmission on TX queue
    13	; Clean up RELSEQ (correct some 8-bit arithmetic)
    14	; Don't empty TX queue at BNTSV2
    15	; Replace SNDQ with SNDPUP
    16	; Don't gratuitously send contents of TX queue at BNTSRV
    17	;<PUP>PUPSEQ.MAC.22, 25-Apr-82 15:00:43, Edit by SCHOEN
    18	; Go NOINT in SNDQ
    19	; Lock BNTLCK only while in SNDQ
    20	; Check for non-sequin packets at beginning of HDLSEQ (not HDLSQ3)
    21	;<PUP>PUPSEQ.MAC.21, 23-Apr-82 12:07:02, Edit by SCHOEN
    22	; Unlock queue lock words if dismissed waiting for queue to empty
    23	;<PUP>PUPSEQ.MAC.20, 16-Apr-82 14:02:26, Edit by SCHOEN
    24	; Improve handling of SEQOUT
    25	; Remove routine to wait for lower fork init (doesn't work well on Tops-20)
    26	; Instead, call SGLEAF when dropping duplicate packets
    27	;<PUP>PUPSEQ.MAC.18, 11-Apr-82 22:32:42, Edit by SCHOEN
    28	; Add routine to wait for server fork to initialize
    29	;<PUP>PUPSEQ.MAC.17, 11-Apr-82 21:42:50, Edit by SCHOEN
    30	; Make some tables global
    31	;<PUP>PUPSEQ.MAC.16, 11-Apr-82 21:23:16, Edit by SCHOEN
    32	; Log non-sequin pups being discarded at HDLSQ3
    33	;<PUP-TEMP>PUPSEQ.MAC.15, 11-Apr-82 00:34:05, Edit by SCHOEN
    34	; Remove extraneous POP P,(P) from fail returns in SEQINI
    35	;<PUP>PUPSEQ.MAC.14, 10-Apr-82 23:29:32, Edit by SCHOEN
    36	; Stop treating SEQOUT as halfword -- count user's outstanding packets only
    37	;<PUP>PUPSEQ.MAC.13, 10-Apr-82 20:51:28, Edit by SCHOEN
    38	; PSQVAR, PSQPVR -> TOPVAR, TOPPVR so PUPUUO loads correctly
    39	;<PUP>PUPSEQ.MAC.11,  6-Apr-82 12:39:22, Edit by SCHOEN
    40	; Send SequinBroken on receipt of data Sequin for nonexistent connection
    41	; Send SequinBroken when no free Sequins remain
    42	; No longer timestamp buffers
    43	; When freeing locks, make the last locker impossible.
    44	;<PUP>PUPSEQ.MAC.8,  2-Apr-82 23:23:02, Edit by SCHOEN
    45	; HDLSEQ checks that received packets are Sequins
    46	;<PUP>PUPSEQ.MAC.3,  1-Apr-82 12:31:16, Edit by SCHOEN
    47	; Don't search SYSDEF; LEAFSV.CCL includes SYS10X or SYST20 along
    48	; with PUPDEF in compilation
    49	;<PUP>PUPSEQ.MAC.2, 31-Mar-82 15:56:50, Edit by SCHOEN
    50	; Shared variables via the GS macro defined in PUPDEF, rather than
    51	; by local SHRVAR mechanism's TS macro
    52	;<SCHOEN>PUPSEQ.MAC.71,  5-Mar-82 13:11:05, Edit by SCHOEN
    53	; Log Sequin brokens (not DTYPE), zero CONTAB(CX) after connection has
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 2.1

    54	; been cleaned up, not before!
    55	;<SCHOEN>PUPSEQ.MAC.70, 26-Feb-82 08:49:38, Edit by SCHOEN
    56	; Append log entry when killing connection due to timeout
    57	;<SCHOEN>PUPSEQ.MAC.68,  3-Feb-82 20:31:04, Edit by SCHOEN
    58	; Make MAPDAT map from file to core, rather than vs.
    59	;<SCHOEN>PUPSEQ.MAC.64,  3-Feb-82 14:02:25, Edit by SCHOEN
    60	; Clean stack correctly at SNDQ1 when there's no room to send
    61	;<SCHOEN>PUPSEQ.MAC.63,  1-Feb-82 16:13:08, Edit by SCHOEN
    62	; Make MAPDAT global (for PSVLEF routines), always map to <SYSTEM>
    63	;<SCHOEN>PUPSEQ.MAC.61, 21-Jan-82 13:33:40, Edit by SCHOEN
    64	; Keep track of number of active connections, do nothing when there
    65	; are no active connections.
    66	;<SCHOEN>PUPSEQ.MAC.60,  9-Jan-82 21:58:34, Edit by SCHOEN
    67	; Make sure server is enabled when it starts
    68	;<SCHOEN>PUPSEQ.MAC.59,  3-Jan-82 14:37:33, Edit by SCHOEN
    69	; Do correct test in KILLFK on fork handle
    70	;<SCHOEN>PUPSEQ.MAC.57,  3-Jan-82 13:55:48, Edit by SCHOEN
    71	; Index off the correct AC to get fork handle in KILLFK
    72	;<SCHOEN>PUPSEQ.MAC.55,  3-Jan-82 13:18:30, Edit by SCHOEN
    73	; Kill dead connections from top fork only (fork handles are top fork relative)
    74	;<SCHOEN>PUPSEQ.MAC.54,  2-Jan-82 13:36:48, Edit by SCHOEN
    75	; [Tops-20] Don't call MAPDAT
    76	;<SCHOEN>PUPSEQ.MAC.53, 15-Dec-81 10:48:41, Edit by SCHOEN
    77	; Move responsibility for cleaning up a destroyed Sequin to BNTSV2 from 
    78	; RNTSV2 (race condition)
    79	;<SCHOEN>PUPSEQ.MAC.50, 11-Dec-81 14:59:11, Edit by SCHOEN
    80	; Send packet if no allocation at receiver iff packet contains no data
    81	; Change Sequin state to BROKen after sending a SequinBroken
    82	; Map data pages to LEAFSV.PMAP;1;P770000 
    83	;<SCHOEN>PUPSEQ.MAC.48, 11-Dec-81 11:27:38, Edit by SCHOEN
    84	; make sure server is enabled to OPENF socket 43!A (for restarts)
    85	;<SCHOEN>PUPSEQ.MAC.47,  8-Dec-81 14:02:59, Edit by SCHOEN
    86	; More fixes to 8-bit arithmetic (had 0-377 working, but not 377-0)
    87	;<SCHOEN>PUPSEQ.MAC.45,  7-Dec-81 17:11:09, Edit by SCHOEN
    88	; Timestamp buffers when they're filled (for debugging info)
    89	;<SCHOEN>PUPSEQ.MAC.42,  5-Dec-81 15:45:04, Edit by SYSTEM
    90	; Fix 8-bit arithmetic simulations in sequence filter
    91	;<SCHOEN>PUPSEQ.MAC.33,  4-Dec-81 22:53:10, Edit by SCHOEN
    92	; Make BNTSRV lock shared, create locks for RX, TX, and PP queues
    93	;<SCHOEN>PUPSEQ.MAC.31, 19-Nov-81 23:47:20, Edit by SCHOEN
    94	; Log source of Sequin connections
    95	;<SCHOEN>PUPSEQ.MAC.29,  6-Nov-81 16:53:14, Edit by SCHOEN
    96	; LOG crashes
    97	; Don't enable server forks, disable after opening socket 43!A.
    98	;<SCHOEN>PUPSEQ.MAC.20, 23-Sep-81 10:16:20, Edit by SCHOEN
    99	; Mere mortals get user relative socket 43 if they try to start the...
   100	; ...server
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 3

     1	
     2		title	pupseq
     3		subttl	Sequin protocol implementation for Tenex
     4		search	pupdef,psqdef
     5		usevar	topvar,toppvr,pshvar,pshpvr
     6	
     7		extern lfinit
     8	
     9	tenex,<	search stenex >
    10	tops20,<search monsym>
    11	
    12	;	Eric Schoen
    13	;	SUMEX Computer Project
    14	;	Stanford University Medical Center
    15	;	Stanford, CA.
    16	;	August, 1981
    17	
    18	;	Work on Leaf and Sequin implementations in Tenex
    19	;	and Tops-20 was funded by NIH Biotechnology Resouces 
    20	;	Program under grant RR-00785
    21	
    22	; format of a packet buffer
    23	pblink==:0			; link word: previous,,next buffer
    24	pbstat==:1			; auxiliary word
    25	
    26	; byte pointers into Sequin packet, indexed by PB
    27	pbhead==:2
    28	pupLen::point 16,pbhead(pb),15	; Pup length, bytes
    29	pupTCB::point 8,pbhead(pb),23	; Pup Transport Control Byte
    30	PupTyp::point 8,pbhead(pb),31	; Pup Type
    31	
    32	; pbhead+1 (normally the Pup ID field)
    33	SeqAlc::point 8,pbhead+1(pb),7	; Sequin Allocation byte
    34	SeqRec::point 8,pbhead+1(pb),15	; Sequin Receive sequence
    35	SeqCon::point 8,pbhead+1(pb),23	; Sequin control byte
    36	SeqSen::point 8,pbhead+1(pb),31	; Sequin Send sequence
    37	
    38	; pbhead+2
    39	ppupdn::point 8,pbhead+2(pb),7	; Pup Destination net
    40	ppupdh::point 8,pbhead+2(pb),15	; Pup Destination host
    41	ppupd0::point 16,pbhead+2(pb),31; Pup Destination socket high
    42	
    43	; pbhead+3
    44	ppupd1::point 16,pbhead+3(pb),15; Pup Destination socket low
    45	ppupsn::point 8,pbhead+3(pb),23	; Pup Source net
    46	ppupsh::point 8,pbhead+3(pb),31	; Pup Source host
    47	
    48	; pbhead+4
    49	ppupss::point 32,pbhead+4(pb),31; Pup Source socket
    50	
    51	; pbhead+5
    52	pbcont==pbhead+5
    53	
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 3.1

    54	.noint::push p,a
    55		tlne f,(debugf)
    56		 jrst [move a,-1(p)
    57		       soj a,
    58		       movem a,.nocal	; save caller
    59		       movei a,400000
    60		       skipl intdef
    61			jrst .+1
    62		       skpir
    63			jrst [type <INTDEF = -1 but interrupts OFF!%/>
    64			      jrst .+1]
    65		       jrst .+1]
    66		movei a,400000
    67		aosg intdef
    68		 dir
    69		pop p,a
    70		popj p,
    71	
    72	.okint::push p,a
    73		tlne f,(debugf)
    74		 jrst [move a,-1(p)
    75		       soj a,
    76		       movem a,.okcal	; save caller address
    77		       movei a,400000
    78		       skipge intdef
    79			jrst [type <Call to .OKINT with INTDEF = -1%/>
    80			      jrst .+1]
    81		       skpir
    82			jrst .+1
    83		       type <Call to .OKINT with INTDEF .ge. 0 and interrupts ON!%/>
    84		       jrst .+1]
    85		movei a,400000
    86		sosge intdef
    87		 eir	
    88		pop p,a
    89		popj p,
    90	
    91	ls intdef,1			; interrupts on flag word
    92					; -1 means interrupts on
    93	ls .nocal,1			; last caller of .NOINT
    94	ls .okcal,1			; last caller of .OKINT
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 4

     1		subttl	Sequin Initialization
     2	
     3	; Initialize Sequin connection management
     4	; This routine should be called by the first user of the
     5	; Sequin package.  Its job to is set up connection tables
     6	; for the Sequin connections which follow.
     7	
     8	; call: pushj p,seqini
     9	;	a/ 0 to for sequin user, -1 for sequin server
    10	; returns: +1, always
    11	
    12	seqini::movem a,server
    13		setzm contab
    14		move a,[contab,,contab+1]
    15		blt a,contab+nconn-1
    16		setom bntlck		; make the background process lock free
    17		setzm bntlkr		; make the last locker be nonexistent
    18		movei a,pupbuf
    19		movem a,frepnt		; set up free space management
    20		movei a,freque		; assign the queues
    21		movei c,npupbf*3
    22		skipge server		; are we a server?
    23		 movei c,npupbf*nconn*3	; yes, assign queues for everyone
    24		pushj p,mqueue
    25		skipl server		; are we a server?
    26		 popj p,		; no, return here
    27		movei a,400000
    28		rpcap
    29		move c,b		; enable what we've got
    30		epcap
    31	ifn ft10x,<
    32		hrroi b,[asciz/PUP:43!A./]
    33	>
    34	ifn ft20,<
    35		hrroi b,[asciz/PUP:43!A./]
    36	>
    37		trnn c,1b18!1b19	; wheel or operator?
    38	ifn ft10x,<
    39		 hrroi b,[asciz/PUP:43!U./] ; no, open user relative socket
    40	>
    41	ifn ft20,<
    42		 hrroi b,[asciz/PUP:43!U./]
    43	>
    44		movsi a,1		; yes, open server socket
    45		gtjfn			; get a jfn
    46		 ercal [elog <Failed to get server socket: %1J%/>
    47			popj p,]
    48		move b,[7000,,300000]
    49		openf
    50		 ercal [elog <Failed to open server socket: %1J%/>
    51			popj p,]
    52		movem a,srvjfn		; save server jfn
    53		push p,a
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 4.1

    54		pushj p,psiini		; init the psi's
    55		pop p,a
    56	ifn ft10x,<			; tenex, run disabled
    57		movei a,400000
    58		rpcap
    59		trz c,1b18!1b19		; not wheel or operator, now
    60		epcap
    61	>				
    62		popj p,
    63	
    64	ls srvjfn			; JFN of port in server mode
    65	ls server			; server/user flag
    66	ls freque,3			; free pool information block
    67	
    68	; Initialize Sequin connection
    69	; This routine resets the Send and Receive sequences, opens the Sequin
    70	; connection, and creates the ring buffer of Sequin
    71	; packets, thereby computing the receiver allocation.
    72	
    73	; call:  a/ JFN of raw pup port opened read/write
    74	;	sq/ Pointer to sequin data block (at least sqblen words long)
    75	;	cx/ Connection table index, if being called as server
    76	; returns: +1, failure (no connections open)
    77	; 	   +2, success, cx/ Connection table index for this connection
    78	; clobbers a,b,c
    79	
    80	conini::skipge server		; a server?
    81		 jrst conin2		; yes, have cx, sq already
    82	 	movsi cx,-nconn		; find a free connection
    83	conin1:	skipn contab(cx)	; free connection if contab entry=0
    84		 jrst conin2		; found one
    85		aobjn cx,conin1
    86		popj p,			; fail if we can't find a free connection
    87		
    88	; now have a connection table index.  Assign buffers for this connection
    89	conin2:	movei cx,(cx)		; clear left half
    90		movem sq,contab(cx)	; assign this table
    91		move p1,a		; save Pup jfn
    92		skipge server
    93		 move p1,srvjfn
    94	
    95		movsi a,(sq)
    96		hrri a,1(sq)
    97		setzm (sq)
    98		blt a,sqblen-1(sq)	; clear out seqblk
    99		setom sendsq(sq)	; sendsq starts at -1
   100	
   101		movei a,freque		; from the free queue...
   102		movei c,npupbf		; make npupbfs on each queue
   103		movei b,(cx)		; get table address
   104		imuli b,lqutab		; compute index into table for connection
   105		movei b,txtab(b)	; get that address
   106		movem b,sqtxcu(sq)	; save it
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 4.2

   107		setom qulock(b)		; init the queue lock
   108		pushj p,aqueue		; make the queue
   109		 popj p,
   110	
   111		movei b,(cx)
   112		imuli b,lqutab
   113		movei b,rxtab(b)
   114		movem b,sqrxcu(sq)
   115		setom qulock(b)
   116		pushj p,aqueue
   117		 popj p,
   118	
   119		movsi a,npupbf		; init connection allocation
   120		movem a,seqall(sq)
   121		
   122	; now fill in sequin data block with local and foreign port info
   123		move a,p1		; retrieve pup jfn
   124		cvskt			; get local port params
   125		 ercal jerr
   126		movem b,seqlnh(sq)	; save local net,,host
   127		movem c,seqlsk(sq)	; save local socket
   128		skipge server		; server?
   129		 jrst [move a,pupfnh(cx); yes, get foreign stuff from cx tables
   130		       movem a,seqfnh(sq)
   131		       move a,pupfsk(cx)
   132		       movem a,seqfsk(sq)
   133		       jrst conin6]
   134		movei c,seqfnh(sq)	; get foreign port params
   135		hrli c,2
   136		gdsts
   137		 ercal jerr
   138		hrlm a,sqjfnx(sq)	; save jfn and connection index
   139	conin6:	hrrm cx,sqjfnx(sq)
   140		movei a,leafSk		; default socket if necessary
   141		skipn seqfsk(sq)	; a socket specified?
   142		 movem a,seqfsk(sq)	; no
   143		hlrz a,seqlnh(sq)	; see if local net specified
   144		jumpn a,conin5
   145		hlrz c,seqfnh(sq)	; no, check foreign net
   146		jumpe c,conin5		; jump if not specified either
   147		move a,[sixbit /puprou/]  ; get routing table entry for net
   148		sysgt
   149		hrrz a,b		; table number
   150		hrli a,-1(c)		; entry
   151		getab
   152		 ercal jerr
   153		trnn a,-1		; are we directly connected?
   154		 ldb c,[point 8,a,9]	; no, use net of gateway
   155		hrlm c,seqlnh(sq)	; establish local net
   156	
   157		move a,[connt,,filet]	; set up timeouts
   158		movem a,ltime(cx)	; local timeout 
   159	
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 4.3

   160		move a,[connt,,filet_-1]; remote timeout
   161		movem a,ftime(cx)
   162		
   163		skipl server		; if not serving...
   164		 jrst conin5		; ... open the connection...
   165		pushj p,makfrk		; ... otherwise, make fork for connection
   166		 error <Failed to create connection fork: %1J>,1
   167		setzm lfinit(cx)	; say server not yet initialized
   168		movei a,(cx)		; get real connection index
   169		log <Connection %1O opened from %2P>
   170		aos (p)			; and return if successful
   171		popj p,
   172	
   173	; now open the Sequin connection
   174	conin5:	setz a,			; send no data with this pup
   175		movei b,seqOpn
   176		pushj p,senSeq		; send a Sequin packet
   177		aos (p)			; increment return
   178		popj p,			; return
   179	
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 5

     1		subttl	Sequin Send
     2	
     3	; routine to send a Sequin packet
     4	; call: a/length*,,address of data to send in packet (0 if none)
     5	;	b/SequinOp (-1 to default to most reasonable choice)
     6	;      sq/pointer to Sequin data block
     7	; return: +1 always
     8	; * length in 16 bit words
     9	
    10	senseq::push p,pb		; save packet buffer pointer
    11		push p,a		; save address
    12		push p,b		; save SequinOp
    13		move a,sqtxcu(sq)
    14		move b,qusize(a)	; get queue size
    15		camg b,qucnt(a)		; is there room?
    16		 jrst [push p,a		; no, wait until there is
    17		       movei a,^d250
    18		       disms
    19		       pop p,a
    20		       jrst .-2]
    21		movei a,qulock(a)	; there's room, lock the queue
    22		pushj p,lock
    23		move a,sqtxcu(sq)	; recover queue pointer
    24		hlrz pb,(a)		; get pup pointer
    25		hrrz b,0(pb)		; get address of next buffer
    26		cain b,0		; get a zero?
    27		 jrst [dtype <Buffer chain points to nowhere!!%/%/>
    28		       pushj p,jerr
    29		       jrst .+1]
    30		hrlm b,(a)		; store as next available buffer
    31		aos 2(a)		; increment queue count
    32		pop p,b			; retrieve sequinOp
    33		move a,(p)		; retrieve a
    34		jumpe a,sensq1		; minimum length if no data
    35		hlrz a,a		; get word length
    36		lsh a,1			; convert to bytes
    37	sensq1:	addi a,mnplen		; add header length
    38		dpb a,puplen		; save pup length
    39		setz a,			; clear transport control byte
    40		dpb a,puptcb
    41		movei a,seqtyp		; type is "sequin"
    42		dpb a,puptyp
    43	
    44	; we run with 0 allocation for lockstep handling, since it is very easy for
    45	; our 2020 to be overrun with packets from an IFS, even when Sequin is the
    46	; only active process on the machine!
    47	
    48		setz a,
    49	repeat 0,<
    50		hlrz a,seqall(sq)	; store allocation byte
    51	>
    52		dpb a,seqalc
    53		move a,recvsq(sq)	; store receiver sequence
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 5.1

    54		dpb a,seqrec
    55		move a,sendsq(sq)
    56		ldb c,puplen		; get length
    57		caie c,MNPLEN		; any contents bytes?
    58		 jrst [aoj a,		; yes, increment send sequence
    59		       andi a,377
    60		       movem a,sendsq(sq)
    61		       jrst sensq4]
    62		caige a,0		; is this the first packet out on connection?
    63		 aoj a,			; yes, go from -1 to 0 in send sequence
    64	
    65	sensq4:	dpb a,seqsen
    66		skipl a,b		; get sequinOp into a
    67		 jrst sensq2		; caller supplied explicit op
    68		movei a,seqdat		; control is sequinData
    69		skipn 0(p)		; send a SequinNop if no data
    70		 movei a,seqnop
    71		skipn seqsta(sq)	; unless connection is not open
    72		 movei a,seqopn		; in which case, send a SequinOpen
    73	sensq2:	dpb a,seqcon		; store control byte
    74	
    75		hlrz a,seqfnh(sq)	; store foreign net
    76		dpb a,ppupdn
    77		hrrz a,seqfnh(sq)	; store foreign host
    78		dpb a,ppupdh
    79		move a,seqfsk(sq)	; store foreign socket
    80	 	dpb a,ppupd1		; low order
    81		rot a,-^d16
    82		dpb a,ppupd0		; high order
    83	
    84		hlrz a,seqlnh(sq)		; store local net
    85		dpb a,ppupsn
    86		hrrz a,seqlnh(sq)		; store local host
    87		dpb a,ppupsh
    88		move a,seqlsk(sq)		; store local socket
    89		dpb a,ppupss		
    90	
    91	; move any data into Sequin packet
    92		pop p,a			; recover length,,address
    93		jumpe a,sensq5		; skip this if no data to send
    94		hlrz b,a		; get length
    95		aoj b,
    96		idivi b,2		; convert to PDP10 words
    97		hrl a,a			; set up to BLT data
    98		hrri a,pbcont(pb)
    99		addi b,pbcont-1(pb)
   100		blt a,(b)		; transfer data into packet buffer
   101	sensq5:	tro f,tempf1		; Remember that we have the tx queue locked
   102	; skip the stack manipulation following
   103	
   104	; send packet
   105	; also here to retransmit packets from retransmit queue
   106	; sq/ points to Sequin data block for this connection
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 5.2

   107	; pb/ points to packet buffer for the Sequin data packet
   108	sensq3:	movei b,(pb)
   109		pushj p,sndpup		; Send the pup off
   110		trze f,tempf1
   111		 jrst  [move a,sqtxcu(sq) ; called from above?
   112			movei a,qulock(a) ; yes, unlock the queue
   113			pushj p,unlock		
   114			pop p,pb	; restore packet buffer pointer
   115			popj p,]	; return
   116		popj p,			; return
   117	
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 6

     1		subttl	Sequin Resend
     2	
     3	; This routine is called to resend any packets in the retransmission
     4	; queue which have not been acknowledged yet (i.e. on receipt of a
     5	; SequinRestart packet).
     6	; Only data containing packets are resent, control packets are ignored.
     7	; sq/ pointer to sequin data block for this connection
     8	; returns +1 always
     9	
    10	rsnseq:	push p,pb		; save packet buffer pointer
    11		move a,sqtxcu(sq)	; lock the queue for consistency
    12		movei a,qulock(a)
    13		pushj p,lock
    14		trz f,tempf1		; make sure we don't look like SENSEQ
    15		tlo f,(sqrtrn)		; say we're retransmitting
    16		hrrz pb,@sqtxcu(sq)	; pick up retransmission pointer
    17		hlrz a,@sqtxcu(sq)	; get transmission pointer?
    18		push p,a		; save on stack
    19	rsnsq1:	camn pb,(p)		; reached transmission pointer?
    20		 jrst rsnsq3		; yes, return
    21		ldb a,puplen
    22		caile a,MNPLEN		; only resend data packets
    23		 pushj p,sensq3		; resend this packet
    24	rsnsq2:	hrrz pb,0(pb)		; look at next packet buffer
    25		jrst rsnsq1		; loop
    26	
    27	; here when done
    28	rsnsq3:	pop p,(p)		; remove transmission pointer entry
    29		pop p,pb
    30		tlz f,(sqrtrn)		; no longer retransmitting
    31		move a,sqtxcu(sq)
    32		movei a,qulock(a)
    33		pushj p,unlock		; unlock the queue
    34		popj p,			; return to caller
    35	
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 7

     1		subttl	Sequin Release packets on retransmission queue
     2	
     3	; This routine frees packets on the retransmission queue which have
     4	; been acknowledged by the other process
     5	; a/ receive sequence number from the acknowledgement
     6	; sq/ pointer to sequin data block for this connection
     7	; Returns +1 always,
     8	; b/ number of freed buffers
     9	relseq:	noint
    10		push p,c
    11		push p,d
    12		setz d,			; d counts number of freed buffers
    13		push p,pb		; don't kill pb
    14		setz b,
    15		push p,b		; (p) counts number of freed packets
    16		move pb,sqtxcu(sq)
    17	relsq0:	hrrz pb,(pb)		; pick up retransmit queue pointer
    18		move b,sqtxcu(sq)	; compare with transmit queue pointer
    19		hlrz b,(b)
    20		cain b,(pb)		; if equal, we're done, else loop
    21	         jrst relsq1		; equal, leave
    22		ldb b,seqsen		; look at this packet's send sequence
    23	; do 8-bit arithmetic
    24		camn a,b		; does recv'd ack = send seq of this packet?
    25		 jrst relsq1		; yes, we're done
    26		ldb b,puplen		; any data in this packet?
    27		caie b,mnplen	
    28		 aos (p)		; yes, increment released packet count
    29		aoja d,relsq0
    30	
    31	relsq1:	move b,sqtxcu(sq)
    32		hrrm pb,(b)		; store updated dequeue pointer
    33		move c,2(b)		; get queue item count
    34		subi c,(d)		; adjust for freed items
    35		movem c,2(b)		; save new value
    36		pop p,b			; get freed buffer count
    37		pop p,pb		; restore pb
    38		pop p,d
    39		pop p,c
    40		okint
    41		popj p,			; return
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 8

     1		subttl Sequin Receive 
     2		
     3	; this routine is called to receive Sequin packets
     4	
     5	; Packets which are returned by this routine have already been
     6	; input by an interrupt level routine.  These packets are placed
     7	; in a ring buffer, like the retransmit buffer.  This routine returns
     8	; these packets to the caller if and only if they contain data destined 
     9	; for some higher level process (i.e. Leaf).
    10	
    11	; call: a/ location to store received packet in (assumed MXPBLN-MNPBLN long)
    12	;      sq/ pointer to sequin data block for this connection
    13	; return: +1 failure: a/ -1 if timeout, 
    14	;			 other error codes as defined above,
    15	;	  +2: success, packet stored in location pointed to by A
    16	;		      a/ number of bytes stored
    17	
    18	; clobbers c,d
    19	
    20	inpSeq::push p,a		; save address
    21		time
    22		addi a,sqtmin		; add timeout interval
    23		movem a,sqtime(sq)	; save timeout time
    24	
    25	; loop here looking for packets
    26	inpSq1: move a,sqrxcu(sq)	; get pointer to receive queue
    27		skipn 2(a)		; anything in the queue?
    28		 jrst inpSq0		; no, wait a bit
    29		pop p,b			; retrieve storage address
    30		tlo b,(1b0)		; flag DQUEUE to return only data portion
    31		pushj p,dqueue		; get from queue
    32		subi a,mnplen		; remove overhead from packet length
    33		aos (p)			; return +2
    34		popj p,
    35	
    36	; here when the received packet queue is empty
    37	; waits here for 250 ms, and then tries again (at inpSq1, above)
    38	; if we timeout, return to caller =1 with a/ errTim (timeout)
    39	inpSq0:	time			; get time
    40		camge a,sqtime(sq)	; timed out, yet?
    41		 jrst [movei a,^d250	; no, loop
    42		       disms
    43		       jrst inpSq1]
    44		pop p,a			; clean stack
    45		movei a,errTim
    46		popj p,			; return +1 with timeout
    47	
    48	
    49	; Interrupt level code to handle received packet
    50	; call: input PUP in tmprec
    51	; returns: +1 always
    52	; a contains some error code (see PSQDEF.MAC) or zero
    53	
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 8.1

    54	; Here when there is a packet in the received Sequin packet queue.
    55	; Here, we dispatch on the packet type and perform any Sequin-level
    56	; tasks which need to be performed.  This code parallels the routine
    57	; HandlePBI in IFSSequinSwap.bcpl (IFS Leaf/Sequin implementation).
    58	
    59	hdlSeq:	movei pb,tmprec-2	; point to input packet
    60		ldb a,seqCon		; get control field
    61		cain a,seqOpn		; if it's a sequinOpen
    62		 skipa
    63		cain a,seqCls		; or a sequinClose
    64		 movei a,seqDat		; make it look like a sequinData
    65		movem a,contro		; save control type
    66		
    67		tlnn f,(debugf)
    68		 jrst hdlsq4
    69		move a,recvsq(sq)
    70		move b,sendsq(sq)
    71		hrroi c,temp
    72		write c,<HDLSEQ: My send #%2O, recv #%1O; >
    73		ldb a,SeqSen
    74		ldb b,SeqRec
    75		write c,<packet send #%1O, recv #%2O>
    76		hrroi c,temp
    77		log <%3S>
    78	
    79	hdlsq4:	ldb a,SeqSen		; get incoming send sequence
    80		move b,recvsq(sq)	; and expected send sequence
    81		pushj p,comSeq		; compare sequence numbers
    82		 jrst sqFail		; +1: out-of-range, go die
    83		 jrst sqRqRe		; +2: ahead, request retransmission
    84		 jrst sqDupl		; +3: duplicate, drop packet
    85		 jrst sqChng		; +4: previous, change control to restart
    86	
    87	; if here, either OK or Sequin control changed to SequinRestart
    88	hdlSq1:	ldb a,SeqAlc		; get other process's allocation
    89		hrrm a,seqAll(sq)	; save it
    90		ldb a,SeqRec		; now compare incoming recv sequence...
    91		move b,sendsq(sq)	; ... against my send sequence
    92		pushj p,comSeq
    93		 jrst sqFail		; +1: out-of-range, go to die
    94		 jrst hdlSq3		; +2: ahead, fall through
    95		 jrst sqDupl		; +3: duplicate, drop packet 
    96		 jfcl			; +4: previous, fall through
    97		skiple seqout(sq)	; +5: equal, adjust outstanding packet count
    98		 sos seqout(sq)		;
    99		jrst hdlsq5		; go handle states
   100	; ...
   101	; if here, sequence compare equal, duplicate, or previous
   102	; in any case, release packets from the retransmission queue which
   103	; are acknowledged by this packet, and process the data in the packet,
   104	; if there is any
   105	
   106	hdlSq3:	move a,contro
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 8.2

   107		cain a,SeqRes		; is control a Restart?
   108		 jrst [skiple seqout(sq)
   109			sos seqout(sq)	; yes, adjust outstanding packet count
   110		       jrst hdlsq5]	; and fall through
   111		ldb a,seqRec		; get receive sequence
   112		pushj p,relSeq		; release those packets this one acks
   113		move a,seqout(sq)	; update outstanding packet count
   114		caile a,0		; don't if a is 0 or less
   115		 sub a,b
   116		jumpl a,[push p,a
   117			 movei a,(cx)
   118			 elog <HDLSEQ: Overdecremented SEQOUT for connection %1O>
   119			 pop p,a
   120			 setzm seqout(sq)
   121			 jrst .+1]
   122		movem a,seqout(sq)
   123		movei a,(cx)
   124	;	dtype <HDLSQ3: Freed %2O packets on connection %1O%/>
   125	
   126	; dispatch on state of connection
   127	hdlsq5:	move a,seqSta(sq)	; get connection state
   128		jrst @stattb(a)		; dispatch
   129	
   130	; now dispatch on control field
   131	hdlsq2:	move a,control
   132		jrst @ctrltb(a)		; dispatch
   133	
   134	; dispatch table to handle sequin connection state
   135	stattb:	stCLOS 			; state is closed
   136		stOPEN 			; state is open
   137		stDLLY 			; state is dallying
   138		stBROK 			; state is broken
   139		stDSTR 			; state is destroyed
   140		stTIMD 			; state is timed out
   141	
   142	; dispatch table to handle different control types in Sequin packets
   143	ctrltb:	hdlDat			; handle Sequin data
   144		hdlAck			; handle Sequin ack
   145		hdlNop			; handle Sequin nop
   146		hdlRes			; handle Sequin restart
   147		hdlChk			; handle Sequin check
   148		screwup			; can't get Sequin open in control
   149		hdlBrk			; handle Sequin break
   150		screwup			; can't get Sequin close in control
   151		hdlCld			; handle Sequin closed
   152		hdlDes			; handle Sequin destroy
   153		hdlDal			; handle Sequin dally
   154		hdlQui			; handle Sequin quit
   155		hdlBro			; handle Sequin broken
   156	
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 9

     1		subttl	Sequin Receive utilities
     2	
     3	; routine to compare sequence numbers
     4	; call: a/first sequence number
     5	;	b/second sequence number
     6	; Returns +1: (a-b) is out of range
     7	;	  +2: (a-b) is between 1 and mxAhed
     8	;	  +3: (a-b) is between -2 and -mxAhed
     9	;	  +4: (a-b) is -1
    10	;	  +5: a=b
    11	; Clobbers a,b
    12	comSeq:	sub a,b			; compute a-b
    13		andi a,377
    14		trne a,200
    15		 ior a,[-1,,777400]	; simluating 8-bit arithmetic
    16		movm b,a		; get magnitude of difference
    17		caile b,mxAhed		; too big a difference?
    18		 popj p,		; yes, return +1
    19		aos (p)			; return at least +2
    20		caile a,0		; a positive?
    21		 popj p,		; yes, return +2
    22		aos (p)			; no, return at least +3
    23		camge a,[-1,,-1]	; a .ge. -1?
    24		 popj p,		; no, return +3
    25		aos (p)			; yes, return at least +4
    26		caie a,0		; a = 0?
    27		 popj p,		; no, must be -1; return +4
    28		aos (p)			; else return +5
    29		popj p,
    30	
    31	; here when sequence numbers are out of range
    32	sqFail:	setz a,			; send a sequinBroken Op
    33		movei b,seqBro		; the world ends!
    34		pushj p,senSeq
    35	
    36		movei a,(cx)
    37		log <SQFAIL: Sequin broken on connection %1O%/>
    38		movei a,DSTR
    39		movem a,seqSta(sq)	; change state to BROKen
    40		movei a,errDes		; signal sequin broken
    41		popj p,			; return +1
    42	
    43	; here to request retransmission of all unacknowledged packets
    44	; this routine sends a sequinRestart, and returns
    45	sqRqRe:	setz a,			; send a sequinRestart
    46		movei b,seqRes
    47		pushj p,senSeq		; send it out
    48		movei a,(cx)
    49		dtype <SQRQRE: Sending sequinRestart for connection %1O%/>
    50	
    51	; also here to return from HDLSEQ without queueing anything for Leaf
    52	rethdl:	setz a,
    53		popj p,
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 9.1

    54	
    55	; here when packet received is flagged as "duplicate"
    56	; simply drop the packet
    57	sqDupl:	movei a,(cx)
    58		dtype <SQDUPL: Dropping duplicate packet for connection %1O%/>
    59		jrst rethdl
    60	
    61	; here when incoming packet is flagged as "previous"
    62	; change control field to restart, and fall through
    63	sqChng:	move a,control		; only make this a restart if control=data
    64		caie a,SeqDat
    65		 jrst rethdl
    66	 	movei a,seqRes
    67		movem a,control		; store control
    68		movei a,(cx)
    69		dtype <SQCHNG: Incoming control becomes RESTART on connection %1O%/>
    70		jrst hdlsq1		; fall back to hdlseq
    71	
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 10

     1	
     2	; dispatch code from control and state dispatches here
     3	
     4	; here to handle CLOSed state
     5	stCLOS:	ldb a,seqCon		; get original control byte
     6		caie a,seqDat		; was it a data byte?
     7		 cain a,seqOpn		; or an open request?
     8		  jrst stTIMD		; then fall through
     9		jrst stOPEN		; else make believe state is open
    10		   
    11	; fall through
    12	
    13	; here if state is timed out
    14	stTIMD:	movei a,OPEN
    15		movem a,seqSta(sq)	; make state open
    16	; fall through
    17	
    18	; here if state is OPEN
    19	stOPEN:	pushj p,strxtm		; set receive timer
    20		jrst hdlSq2		; return
    21	
    22	; here if state is broken
    23	stBROK:	setz a,
    24		movei b,seqBro
    25		pushj p,senSeq		; send a sequin broken
    26		movei a,errBro		; say Sequin is broken
    27		popj p,			; return bad
    28	
    29	; here if in dallying state
    30	stDLLY:	move a,contro		; get control
    31		cain a,seqQui		; was it a quit?
    32		 jrst stDLY1		; yes, go die
    33		setz a,
    34		movei b,seqDal		; no, send a dally in return
    35		pushj p,senseq
    36		setz a,
    37		popj p,			; and wait for more packets
    38	
    39	stDLY1:	movei a,DSTR		; say Sequin is destroyed
    40		movem a,seqSta(sq)
    41		movei a,errDes
    42		popj p,			; received a quit, return +1
    43	
    44	; here if in destroyed state
    45	stDSTR:	dtype <STDSTR: Received packet while in DESTROYED state>
    46		movei a,errDes		; say sequin is destroyed
    47		popj p,			; return 
    48	
    49	
    50	; these routine handle the various control fields in the sequin packet
    51	
    52	; here when control field is "destroy"
    53	hdlDes:	movei a,DLLY		; make state = dallying
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 10.1

    54		movem a,seqSta(sq)
    55		setz a,			; respond with a dallying packet
    56		movei b,seqDal
    57		pushj p,senSeq		; send off the packet
    58		setz a,
    59		popj p,			; wait for a reply
    60	
    61	; here to respond to a SequinDally
    62	hdlDal:	setz a,
    63		movei b,seqQui		; respond with a SequinQuit
    64		pushj p,senSeq
    65		movei a,ErrDes		; say Sequin has been destroyed
    66		popj p,
    67	
    68	; here to respond to a seqChk or seqNop
    69	hdlChk:
    70	hdlNop:	setz a,
    71		movei b,seqAck		; reply with an ack
    72		pushj p,senSeq		; send it
    73		setz a,
    74		popj p,			; wait for more packets to come in
    75	
    76	; here to respond to a SequinRestart
    77	hdlRes:	pushj p,rsnseq		; resend the transmit queue
    78		setz a,
    79		popj p,			; wait for more packets
    80	
    81	; here to respond to a sequinAck
    82	hdlAck:	setz a,
    83		popj p,			; just keep waiting
    84	
    85	; here to respond to a SequinData
    86	hdlDat:	move a,seqSta(sq)	; get state
    87		caie a,OPEN		; are we open?
    88		 jrst sqFail		; no, respond with sequinBroken, ret +1
    89		movei b,seqAck		; prepare to respond with sequinAck
    90		ldb a,seqCon		; get real control field
    91		cain a,seqCls		; is it a sequinClose?
    92		 jrst [movei a,CLOS	; make state = CLOSed
    93		       movem a,seqSta(sq)
    94		       movei b,seqCld	; prepare to respond with sequinClosed
    95		       jrst .+1]
    96		ldb a,puplen		; get length of incoming pup
    97		caig a,MNPLEN		; greater than minimum?
    98		 jrst [setz a,		; no, send an acknowledgement
    99		       pushj p,senSeq	; send the reply
   100		       setz a,
   101		       popj p,]		; and wait for more input
   102		aos a,recvsq(sq)	; increment received sequence number
   103		andi a,377
   104		movem a,recvsq(sq)	; save masked number
   105		pushj p,inSequ		; move the packet to the caller's space
   106		setz a,
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 10.2

   107		popj p,
   108		
   109	hdlBrk:
   110	hdlBro:
   111	hdlCld:
   112	hdlQui:	jrst sqFail		; don't like receiving these here
   113	
   114	
   115	; here to move data into caller's space
   116	; pb/ pointer to packet buffer
   117	; clobbers a,b,c
   118	; returns +1 always
   119	inSequ:	move a,sqrxcu(sq)
   120		movei b,pbhead(pb)	; yes, queue packet, else drop on floor 
   121		skipn 2(a)		; is the queue empty?
   122		 tro f,tempf1		; yes, remember
   123		move c,1(a)		; get buffer size
   124		camle c,2(a)		; is there room?
   125		 pushj p,nqueue		; yes, otherwise drop on floor
   126		trze f,tempf1		; was the queue empty?
   127		 pushj p,sgleaf		; yes, signal leaf to run
   128		popj p,			; return
   129	
   130	; here to signal a leaf fork that a previously empty queue now has data in it
   131	; call: pushj p,sgleaf
   132	;	cx/ connection index for this connection
   133	; returns: +1, always
   134	; clobbers a,b
   135	sgleaf:	skipl leaffk(sq)	; only interrupt if B0 of leaffk is on
   136		 popj p,
   137		move a,connfk(cx)	; get fork handle
   138		move b,[sigchn]
   139		iic
   140		popj p,
   141	
   142	; here if server fork isn't initialized; wait 5 seconds, then kill fork
   143	sglf1:	time
   144		addi a,5000
   145		push p,a		; save timeout time
   146	sglf1a:	movei a,100		; wait a little bit
   147		disms
   148		skipe lfinit(cx)	; ready yet?
   149		 jrst [pop p,(p)	; yes, clean stack and return
   150		       popj p,]
   151		time			; check the time
   152		caml a,(p)		; timed out yet?
   153		 jrst [movei a,DSTR	; yes, destroy this sequin
   154		       movem a,seqsta(sq)
   155		       pop p,(p)
   156		       movei a,(cx)
   157		       elog <Connection %1O won't init; destroying...>
   158		       popj p,]
   159		jrst sglf1a
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 10.3

   160	
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 11

     1		subttl General utilities
     2	
     3	; routines to manage queues
     4	; a queue is a doubly-linked set of buffers of mamximum pup length, plus
     5	; a couple of words of queue and buffer management overhead (see beginning
     6	; of this file).  Associated with each queue is a queue information block
     7	; containing:
     8	;	enqueue,,dequeue pointers for the queue
     9	;	size of queue
    10	;	count of items in the queue
    11	
    12	; routine to create a free buffer pool
    13	; call: pushj p,mqueue
    14	; 	a/ points to queue information word for this queue
    15	; 	c/ number of buffers to assign
    16	; returns: +1 always
    17	; clobbers b,c
    18	mqueue:	push p,p1		; save a permanent location
    19		move p1,a		; point queue info pointer in a safe place
    20		movem c,1(p1)		; get queue size
    21		pushj p,asgfre		; get a buffer
    22		hrrm a,(p1)		; save dequeue pointer
    23		hrlm a,(p1)		; save enqueue pointer
    24		push p,a		; save address of first buffer
    25		soje c,mquex		; leave if all buffers reserved
    26	
    27	mque1:	move b,a		; save address of this buffer
    28		pushj p,asgfre		; get next buffer
    29		hrrm a,(b)		; link it to previous buffer
    30		hrlm b,(a)		; link previous buffer to it
    31		sojn c,mque1		; loop if more to do
    32	
    33	mquex:	hlrz b,(p1)		; get enqueue pointer
    34		hrlm a,(b)		; make first buffer point back to last 
    35		hrrm a,quemax		; save highest queue address
    36		pop p,b			; retrieve first buffer address
    37		hrrm b,(a)		; make last buffer point forward to first
    38		move a,p1		; restore a
    39		setzm 2(a)		; make queue empty
    40		pop p,p1
    41		popj p,
    42	
    43	ls quemax			; contains address of highest queue entry
    44	
    45	; routine to assign buffers from free buffer pool to a process
    46	; call: a/ address of free buffer pool information word
    47	;	b/ address of information word for buffers being assigned
    48	;	c/ number of buffers requested
    49	; returns: +1, not enough available buffers
    50	;	   +2, success, buffers assigned
    51	
    52	aqueue:	push p,d		; save d
    53		push p,a		; save arguments
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 11.1

    54		push p,b
    55		push p,c
    56	
    57		hrrz a,(a)		; get address of first buffer in free pool
    58		movem a,(b)		; save in new info block
    59		hrlm a,(b)
    60		movem c,1(b)		; save queue size
    61		setzm 2(b)		; and make it initially empty
    62	
    63		move b,-2(p)		; get address of free pool info block
    64		move d,1(b)		; get free pool size
    65		subi d,(c)		; remove number of requested buffers
    66		jumpl d,aqueux		; fail if can't assigned requested number
    67		movem d,1(b)
    68	
    69		push p,a		; save address of first buffer in new queue
    70		caia			; enter assign loop
    71	aqueu1:	hrrz a,(a)		; get free buffer pool header
    72		sojn c,aqueu1		; loop until found last desired buffer
    73	
    74		hrrz c,(a)		; get address of new first buffer in free pool
    75		move b,(p)		; get address of first buffer
    76		hrrm b,(a)		; place in link word
    77		hlrz d,(b)		; get last buffer in free pool
    78		hrlm a,(b)		; place addr of last buffer in first entry
    79		move a,-3(p)		; get address of free pool info block
    80		hrrm c,(a)		; store new first buffer
    81		hrlm d,(c)		; store last free pool buffer in new first buf
    82	
    83		pop p,(p)
    84		aos -4(p)		; return successfully
    85	aqueux:	pop p,c			; recovers acs
    86		pop p,b
    87		pop p,a
    88		pop p,d
    89		popj p,
    90	
    91	; routine to return a queue of buffers to the free buffer pool
    92	; call: a/ address of free pool information block
    93	;	b/ address of information block for buffer queue being deassigned
    94	; returns: +1, always
    95	rqueue:	push p,c		; save c
    96		push p,d		; and d
    97		push p,a		; also save arguments
    98		push p,b
    99		move d,1(b)		; get size of buffer queue being returned
   100		skipn 1(a)		; is free pool currently empty?
   101		 jrst [movsi c,(b)	; yes, just move queue over
   102		       hrri c,(a)
   103		       blt c,2(a)
   104		       setzm 1(b)
   105		       jrst rqueux]
   106		hrrz c,(a)		; get address of first buffer in free pool
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 11.2

   107		hlrz c,(c)		; get address of last buffer in pool
   108		hrrz b,(b)		; get address of buffer in returning queue
   109		hrrm b,(c)		; link it into free pool
   110		hrlm c,(b)		; and link free pool into it
   111		caia			; enter loop
   112	rqueu1:	hrrz b,(b)		; get next buffer in queue
   113		sojn d,rqueu1		; loop until through all buffers
   114	
   115		hrrz a,(a)		; b has last buffer addr, get 1st in free pool
   116		hrlm b,(a)		; complete linking returned queue into free
   117		hrrm a,(b)
   118	
   119		move b,(p)
   120		move a,-1(p)
   121		exch d,1(b)		; zero queue size for returned queue
   122		setzm 2(b)		; make it empty, too
   123		addm d,1(a)		; add returned queue size to free pool size
   124	rqueux:	pop p,b
   125		pop p,a
   126		pop p,d			; recover d and c
   127		pop p,c
   128		popj p,			; and return
   129	
   130	
   131	; routine to place an item on queue
   132	; call: a/address of queue information word
   133	;	b/address of pup to place on queue
   134	; returns: +1 always
   135	; if queue if full, then process waits until it can place item on queue
   136	
   137	nqueue:	push p,pb		; don't clobber pb
   138		push p,a
   139		push p,b
   140		movei a,qulock(a)	; lock queue
   141		pushj p,lock
   142		move a,-1(p)
   143		movei pb,-pbhead(b)	; set up bytepointers for this packet
   144		move b,1(a)		; get size of queue
   145		camg b,2(a)		; is size > count?
   146		 jrst [push p,a
   147		       movei a,qulock(a)
   148		       pushj p,unlock	; unlock while dismissed
   149		       movei a,^d250	; wait 250 ms
   150		       disms
   151		       move a,(p)
   152		       movei a,qulock(a)
   153		       pushj p,lock	; relock when done waiting
   154		       pop p,a
   155		       jrst .-2]	; and try again
   156		ldb a,puplen		; compute length of move
   157		idivi a,4
   158		caie b,0
   159		 aoj a,
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 11.3

   160		move b,-1(p)		; a has length in words, compute last address
   161		hlrz b,(b)		; set up BLT pointer
   162		addi b,pbhead-1(a)	; b has last address to BLT to now
   163		move a,-1(p)
   164		hlrz a,(a)		; get enqueue pointer
   165		addi a,pbhead		; point into data region of queue
   166		hrli a,pbhead(pb)
   167		blt a,(b)		; transfer onto queue
   168		hrrz b,-1(p)
   169		hlrz a,(b)		; update queue pointer
   170		hrrz a,(a)
   171		cain a,0		; check for foul link
   172		 jrst [elog <Buffer chain points nowhere!%/%/>
   173		       pushj p,jerr
   174		       jrst .+1]
   175		hrlm a,(b)
   176		pop p,b
   177		pop p,a
   178		aos 2(a)		; increment item count
   179		push p,a		; unlock queue
   180		movei a,qulock(a)
   181		pushj p,unlock
   182		pop p,a
   183		pop p,pb
   184		popj p,
   185	
   186	; routine to dequeue item from queue
   187	; call: a/ address of queue information word
   188	;	b/ address to write into
   189	;	   B0 on means return data part only
   190	; returns: +1 always (waits if queue is empty)
   191	dqueue:	push p,p1
   192		push p,pb		; save some acs
   193		push p,a
   194		push p,b
   195		movei a,qulock(a)	; lock the queue
   196		pushj p,lock
   197		move a,-1(p)
   198		hrrz pb,(a)		; get dequeue pointer
   199		hrrz b,2(a)		; get item count
   200		cain b,0		; wait if it's zero
   201		 jrst [push p,a
   202		       movei a,qulock(a)
   203		       pushj p,unlock	; unlock while dismissed
   204		       movei a,^d250	; wait 250 ms
   205		       disms
   206		       move a,(p)
   207		       movei a,qulock(a)
   208		       pushj p,lock	; relock when done waiting
   209		       pop p,a
   210		       jrst .-2]	; and try again
   211		ldb a,puplen		; see how many words to transfer
   212		skipge 0(p)
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 11.4

   213		 move p1,a		; if returning data only, save packet len
   214		idivi a,4
   215		caie b,0
   216		 aoj a,
   217		move b,(p)		; a has len in wds, make BLT pointer
   218		hrli b,pbhead(pb)	; read following queue link word
   219		addi a,-1(b)		; b is source,,dest; get addr of last word
   220		skipge 0(p)		; want data part only?
   221		 jrst [add b,[mnpbln-1,,0]; yes, adjust BLT stuff
   222		       subi a,mnpbln-1
   223		       jrst .+1]
   224		blt b,(a)
   225		pop p,b
   226		pop p,a
   227		hrrz pb,(pb)		; update queue pointer
   228		cain pb,0
   229		 jrst [elog <Buffer chain points nowhere!%/%/>
   230		       pushj p,jerr
   231		       jrst .+1]
   232		hrrm pb,(a)
   233		sos 2(a)		; decrement queue item count
   234		push p,a		; save address of queue block
   235		movei a,qulock(a)	; compute address of lock
   236		pushj p,unlock		; unlock
   237		pop p,a			; restore address
   238		skipge b
   239		 move a,p1		; return packet length if necessary
   240		pop p,pb	
   241		pop p,p1
   242		popj p,			; return
   243		
   244	
   245	; routine to mark out a buffer (MXPBLN+PBHEAD words)
   246	; returns: +1 always, a/ address of buffer
   247	asgfre:	move a,frepnt
   248		push p,a
   249		addi a,mxpbln+pbhead
   250		movem a,frepnt
   251		pop p,a
   252		popj p,
   253	
   254	; routines to set timeouts for various connections
   255	
   256	; routine to set timeout to keep connection alive
   257	; call: cx/ connection index for this connection
   258	; returns: +1 always, transparent to acs
   259	sttxtm:	push p,a		; get now
   260		push p,b
   261		time
   262		hrrz b,ftime(cx)
   263		imuli b,^d1000		; convert to ms
   264		add a,b
   265		movem a,txtime(cx)	; save time to transmit in table
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 11.5

   266		pop p,b
   267		pop p,a
   268		popj p,
   269	
   270	; routine to set timeout on received packets
   271	; call: cx/ connection index for this connection
   272	; returns: +1 always, transparent to acs
   273	strxtm:	push p,a		; get now
   274		push p,b
   275		time
   276		hrrz b,ltime(cx)
   277		imuli b,^d1000		; convert to ms
   278		add a,b
   279		movem a,rxtime(cx)	; save time to receive by
   280		pop p,b
   281		pop p,a
   282		popj p,
   283	
   284	; routine to set local timeout params (called by Leaf server)
   285	; call: pushj p,stlctm
   286	;	a/ connection,,file timeout (seconds)
   287	;	cx/ connection table index
   288	; returns: +1, always
   289	stlctm::movem a,ltime(cx)
   290		popj p,
   291	
   292	; routine to set foreign timeout params (called by Leaf user)
   293	; call: pushj p,stfntm
   294	;	a/ connection,,file timeout (seconds)
   295	;	cx/ connection table index
   296	; returns: +1, always
   297	; A SequinNop will be sent every time the file timeout expires.  Thus,
   298	; it is advisable to set the file timeout to be something less than the
   299	; server's file timeout.  The default timeout is 5 minutes, one-half the
   300	; default timeout for the IFS.
   301	
   302	stfntm::movem a,ftime(cx)
   303		popj p,
   304	
   305	; routine to create a server fork
   306	; call: pushj p,makfrk
   307	;	cx/ connection index
   308	;	sq/ address of sequin data block
   309	; returns: +1, failure, JSYS error code in 1
   310	;	   +2, success; leaffk(sq) containing fork handle of fork
   311	; clobbers a,b,c,d
   312	makfrk:	movsi a,(1b1)
   313		cfork			; create empty fork with superior's capenb
   314		 popj p,
   315	tenex,<
   316		cfgrp			; in Tenex, do proxy logins for fork groups
   317		 popj p,
   318	>
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 11.6

   319		hrrzm a,leaffk(sq)	; save fork index in sequin data block
   320		movem a,connfk(cx)	; and in table indexed by connection
   321		move d,[400000,,1000]	; stop PMAP loop when AC1 contains (d)
   322		movsi c,(1b2!1b4!1b9)	; map read, cw, execute
   323		hrlz b,a		; map from this fork to inferior
   324		movsi a,400000
   325	makfk1:	camn a,d		; done yet?
   326		 jrst makfk3		; yes, leave
   327		push p,b		; no, check if this page exists
   328		rpacs
   329		tlnn b,(1b5)		; page exists?
   330		 jrst [push p,a		; make the page exist
   331		       movei a,(a)
   332		       lsh a,^d9
   333		       setzm (a)	; touch it
   334		       pop p,a
   335		       jrst .+1]
   336		pop p,b			; yes, map to inferior
   337		pmap
   338		caia
   339	makfk2:	pop p,b
   340		aoj b,			; increment page numbers
   341		aoja a,makfk1		; and loop
   342	
   343	; here when done mapping pages... make certain pages read, write, exec
   344	makfk3: hll a,b
   345		hrri a,ishloc/1000	; starting at ishloc
   346		move c,quemax
   347		lsh c,-^d9
   348		aoj c,
   349		subi c,-1(a)		; number of pages to change
   350	makfk4:	rpacs
   351		tlne b,(1b5)		; page exists?
   352		 jrst [movsi b,(1b2!1b3); yes, change to read, write
   353		       spacs
   354		       jrst .+1]
   355		aoj a,
   356		sojn c,makfk4
   357	
   358		hlrz a,a		; get fork handle
   359		setz b,			; set fork acs
   360		sfacs
   361		movei b,leaf##		; start at leaf
   362		sfork
   363		aos (p)
   364		popj p,
   365	
   366	; here to kill a server fork
   367	; call: pushj p,killfk
   368	;	sq/ address of sequin data block
   369	;	cx/ connection table index
   370	; returns: +1, always
   371	; clobbers a,b,c
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 11.7

   372	killfk:	hrrz a,connfk(cx)	; check consistency of fork handle
   373		caig a,400000		; for debugging
   374		 jrst  [movei b,(cx)
   375			elog <Connection %2O claims fork handle %1O for server>
   376			popj p,]
   377		kfork
   378		setzm leaffk(sq)
   379		setzm connfk(cx)	; clear fork pointers
   380		popj p,			; returns
   381	
   382	; lock and unlock utilities to insure contention-free program flow
   383	; routine to lock a data structure
   384	; call: pushj p,lock
   385	;	a/address of lock block (word 0 = lock, word 1 = fx of locker)
   386	; returns: +1, always, when locked
   387	lock:	aose (a)		; try to lock
   388		 jrst .-1
   389		movem fx,1(a)
   390		popj p,
   391	
   392	; routine to unlock
   393	; call: pushj p,unlock
   394	;	a/address of lock block
   395	unlock: push p,a
   396		move a,(a)		; get lock word
   397		camn a,[-1,,-1]		; is it locked?
   398		 jrst [move a,(p)
   399		       elog <Lock at %1O is not locked>
   400		       jrst .+1]
   401		pop p,a
   402		came fx,1(a)		; do we own the lock?
   403		 jrst [elog <Attempt to unlock lock at %1O by improper process %16O>
   404		       pushj p,screwup]
   405		setzm 1(a)		; yes, make the last locker impossible
   406		setom (a)		; free lock
   407		popj p,
   408	
   409	; routine to map data space into a thawed file so (enabled) others can look at
   410	; what the server is doing
   411	mapdat::movsi a,1		; get the .PMAP file
   412	ifn ft10x,<
   413		hrroi b,[asciz/<SYSTEM>LEAFSV.PMAP;1;P770000/]
   414	>
   415	ifn ft20,<
   416		hrroi b,[asciz/SYSTEM:LEAFSV.PMAP.1;P770000/]
   417	>
   418		gtjfn
   419		 jrst mapdaf
   420		move p1,a
   421		move b,[44b5+1b19+1b20+1b25]	; open read, write, thawed, 36 bits
   422		openf
   423		 jrst mapdaf
   424		move b,[400000,,ilsloc/1000]
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 11.8

   425		hrlz a,p1
   426		hrri a,ilsloc/1000
   427		movsi c,(1b2!1b3)	; map read/write
   428		move d,[400000,,600]	; stop here
   429	mapda1: move p2,b
   430		move b,a
   431		seto a,
   432		pmap			; delete the file page
   433		move a,b		; (hope this works on Tops-20)
   434		move b,p2
   435		pmap			; map a page to core
   436		aoj b,			; increment core address
   437		came b,d		; reached end?
   438		 aoja a,mapda1		; nope, incr file address, loop
   439	mapda2:	jrst (fx)
   440	
   441	
   442	; here on failure
   443	mapdaf:	log <Can't create .PMAP file: %1J>
   444		skipe a,p1		; relase JFN if we've got one
   445		 rljfn	
   446		  jfcl			; ignore it if we can't
   447		jrst (fx)
   448	
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 12

     1		subttl	interrupt driven routines and background process
     2	
     3	; These routines maintain the state of the server.  RNTSRV is run at
     4	; interrupt level to receive Pups.  On receipt of a PUP, RNTSRV finds
     5	; the connection it belongs to (or creates a new one), then calls the
     6	; sequence number filter to determine where in the packet sequence the
     7	; received Sequin belongs.  Sequins which are indeed in sequence are
     8	; queued in SQRXCU for the server fork (whatever it may be) below to
     9	; handle.  
    10	
    11	; BNTSRV is run on  a five second timer, and is responsible for garbage
    12	; collecting dead or destroyed sequins, and also maintaining the state
    13	; of each sequin connection.
    14	
    15	; call: pushj p,bntsrv
    16	;	transparent to acs
    17	
    18	bntsrv::skipg nactcn			; are there any active connections?
    19		 popj p,			; no, return
    20		exch p,bntpdl
    21		movem 16,bntacs+16		; save acs 0-16
    22		movei 16,bntacs
    23		blt 16,bntacs+15
    24		move 16,bntacs+16		; recover fx (=AC16)
    25	
    26		cail fx,0			; are we the top fork here?
    27		 jrst [pushj p,bntsv1		; no, service this connection only
    28		       tlze f,(defntf)		; need to reenter?
    29			jrst .-2		; yes, do so
    30		       jrst bntsv5]		; done, leave
    31	
    32	bntsv4:	movsi cx,-nconn			; look for active connections
    33	bntsv0:	skipe sq,contab(cx)		; is this connection alive?
    34		 pushj p,bntsv1			; yes, handle it
    35		aobjn cx,bntsv0			; loop if more connections to scan
    36	
    37		tlze f,(defntf)			; want to recycle through this?
    38		 jrst bntsv4			; yes, go again
    39	
    40	bntsv5:	movsi 16,bntacs			; done, recovers acs
    41		blt 16,16			
    42		exch p,bntpdl
    43		tlze f,(defntf)			; want BNTSRV again?
    44		 jrst bntsrv			; loop through again
    45		popj p,
    46	
    47	gs bntlck				; Background service lock
    48	gs bntlkr				; Last locker
    49		 
    50	; this routine does all the work
    51	bntsv1:
    52		move a,seqSta(sq)		; get current state
    53		caie a,BROK			; if broken...
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 12.1

    54		 cain a,DSTR			; ... or destroyed
    55		  jrst bntsv2			; clean up
    56		cain a,TIMD			; timed out?
    57		 jrst [skipn b,rxtime(cx)	; see if connection timed out
    58			jrst .+1
    59		       hrrz a,ltime(cx)		; compute time of connection timeout
    60		       imuli a,^d1000
    61		       sub b,a
    62		       hlrz a,ltime(cx)
    63		       imuli a,^d1000
    64		       add b,a
    65		       push p,b			; get now
    66		       time
    67		       pop p,b	
    68		       caml a,b
    69			jrst [movei c,(cx)
    70			      elog <BNTSV1: Connection %3O timed out>
    71			      jrst bntsv2]	; connection timed out
    72		       jrst .+1]
    73	
    74	; check for time to send
    75		skipn txtime(cx)		; is there a send timeout?
    76		 pushj p,sttxtm			; no, set one
    77		time
    78		caml a,txtime(cx)		; tx timeout yet?
    79		 pushj p,sndnop			; yes, send a nop (if not server)
    80	
    81	; check if receiver timed out
    82		skipn rxtime(cx)		; is there a received timeout?
    83		 pushj p,strxtm			; no, set one
    84		caml a,rxtime(cx)
    85		 jrst [movei a,TIMD
    86		       exch a,seqSta(sq)	; yes, say connection is timed out
    87		       cain a,DLLY		; were we dallying on this connection?
    88			jrst [movei a,DSTR
    89			      movem a,seqSta(sq); yes, destroy the connection
    90			      popj p,]
    91		       movei a,(cx)
    92		       log <Short-term timeout on connection %1O>
    93		       popj p,]
    94		popj p,				; return
    95	
    96	; here to close a BROKen, DeSTRoyed, or TIMeD out connection
    97	; sq, cx set up
    98	bntsv2:	cail fx,0			; Let only the top fork do this
    99		 popj p,			; If not, then return
   100		movei a,(cx)
   101		log <BNTSV2: Closing connection %1O>
   102		setzm pupfsk(cx)		; clear address for server, also
   103		setzm pupfnh(cx)
   104		setzm rxtime(cx)
   105		setzm txtime(cx)
   106		skipge server
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 12.2

   107		 jrst [pushj p,cleanf##		; clean JFNs
   108		       pushj p,killfk		; kill server fork
   109		       jrst bnts2a]		; don't close socket if server
   110		hlrz a,sqjfnx(sq)		; close jfn
   111		closf
   112		 elog <BNTSV2: While closing port: %1J>
   113	bnts2a:	movei a,freque			; return queues to free pool
   114		hrrz b,sqtxcu(sq)
   115		pushj p,rqueue
   116		hrrz b,sqrxcu(sq)
   117		pushj p,rqueue
   118		setzm contab(cx)		; clear connect index
   119		sosge nactcn			; decrement count of actives conns
   120		 jrst  [elog <BNTS2A: NACTCN overdecremented>
   121			setzm nactcn
   122			popj p,]
   123		popj p,
   124	
   125	; Routine to send a PUP, updating allocations as it goes, if necessary.
   126	; This routine will dismiss if the allocation does not exist at the
   127	; receiver, hence, do not lock any critical data structures or call with
   128	; interrupts off.
   129	; call: b/ Address of packet buffer to send
   130	; returns: +1 always
   131	;	    Clobbers c,d
   132	sndpup: push p,a
   133		push p,b
   134		push p,pb			; save pb
   135		movei pb,(b)			; point to packet
   136		ldb a,puplen			; compute PDP10 word count
   137		addi a,3
   138		idivi a,4
   139		hrl b,a
   140		hrri b,pbhead(pb)		; point to start of packet data
   141		hlr a,sqjfnx(sq)
   142		skipge server			; if server
   143		 hrr a,srvjfn			; use the server jfn
   144		hrli a,(1b0+1b1)		; don't block, generate checksum
   145	sndpp1:	hrrz c,seqall(sq)		; get allocation for receiver
   146		cain c,0			; is it 0?	
   147		 movei c,1			; then make it 1
   148		move d,seqout(sq)		; get outstanding packet count
   149		sub c,d				; get difference
   150		jumple c,[tlne f,(sqrtrn)	; retransmitting?
   151			   jrst .+1		; ignore allocation limits
   152			  push p,a		; no allocation, must wait
   153			  ldb a,puplen		; get length of pup
   154			  caig a,mnplen		; don't disms if no contents bytes
   155			    jrst [pop p,a
   156				  jrst .+1]
   157			  move a,sqtxcu(sq)
   158			  movei a,qulock(a)
   159			  push p,a		; unlock the queue while waiting
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 12.3

   160			  pushj p,unlock
   161			  movei a,^d100
   162			  disms
   163			  pop p,a
   164			  pushj p,lock		; relock the queue
   165			  pop p,a
   166			  jrst sndpp1]		; try again now
   167		pupo
   168		 ercal jerr
   169		ldb a,puplen			; get length of PUP just sent
   170		caig a,MNPLEN			; any contents bytes?
   171		 jrst sndpp2			; no, don't mess with seqout	
   172		tlnn f,(sqrtrn)			; retransmitting?
   173		 aos seqout(sq)			; no, incr outstanding packet count
   174	sndpp2:	pushj p,sttxtm			; reset the timeout timer for 5 minutes
   175		pop p,pb			; restore pb
   176		pop p,b
   177		pop p,a
   178		popj p,
   179	
   180	; routine to place a sequinNop on the queue
   181	sndNop:	skipge server			; only if not server
   182		 popj p,
   183		push p,a
   184		push p,b
   185		setz a,				; send no data
   186		movei b,seqNop			; send a Nop
   187		pushj p,senSeq			; queue it
   188		pop p,b				; restore acs
   189		pop p,a
   190		popj p,
   191	
   192	; routine called when a pup is received
   193	rntsrv: exch p,rntpdl
   194		movem 16,rntacs+16		; save acs 0-16
   195		movei 16,rntacs
   196		blt 16,rntacs+15
   197		skipge server
   198		 jrst [seto fx,			; we're the top fork
   199		       pushj p,rntsv1		; if server, get packet
   200		       jrst rntsv5]
   201	
   202		movsi cx,-nconn			; loop through connections
   203	rntsv0:	skipe sq,contab(cx)		; looking for those with pups waiting
   204		 pushj p,rntsv1			; do the work
   205		aobjn cx,rntsv0
   206	
   207	rntsv5:	movsi 16,rntacs			; done, recovers acs
   208		blt 16,16			
   209		exch p,rntpdl
   210		debrk				; leave interrupt routine
   211		 ercal jerr			; in case something fails
   212	
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 12.4

   213	rntsv1:	hrrz a,srvjfn			; assume we're a server
   214		skipl server			; are we a server?
   215		 hlr a,sqjfnx(sq)		; no, get jfn from seqblk
   216		hrli a,(1b0+1b1)		; don't disms for I/O, gen checksum
   217		move b,[mxpbln,,tmprec]
   218		pupi				; attempt to input a pup
   219		 jrst rntsv3			; empty or error
   220		skipge server			; are we a server?
   221		 jrst [pushj p,rntsv4		; yes, get connection for this packet
   222		        jrst rntsv1		; failed, see if there's another
   223		       jrst .+1]		; found the connection
   224		movei c,tmprec
   225		pushj p,HdlSeq			; Handle this packet
   226		cain a,errDes			; was the Sequin destroyed?
   227		 jrst rntsv2			; yes, go wait for send queue to empty
   228		jrst rntsv1			; no, loop until input port is empty
   229	
   230	
   231	; here when Sequin is classified as destroyed
   232	; Make state=DSTR, let BNTSV2 clean up this connection
   233	rntsv2:	movei a,DSTR
   234		movem a,seqsta(sq)		; make state=DeSTRoyed
   235		popj p,
   236	
   237	rntsv3:	cain a,pupx3			; empty?
   238		 popj p,
   239		type <RNTSRV: PUPI failure %1J%/>
   240		popj p,
   241	
   242	; routine to find connection index (or make new one) for received packet
   243	; call: pushj p,rntsv4
   244	;	TMPREC: containing received packet
   245	; returns: +1, failed packet (can't open connection or not Sequin, etc)
   246	; 	   +2, packet received ok, with cx, sq set up
   247	rntsv4: push p,pb
   248		movei pb,tmprec-pbhead
   249		ldb a,puptyp		; is this a sequin packet?
   250		caie a,seqtyp
   251		 jrst [log <RNTSV4: Discarding non-sequin packet>
   252		       pop p,pb
   253		       popj p,]
   254		ldb a,ppupss			; get source socket
   255		movsi cx,-nconn
   256	rnts4a:	camn a,pupfsk(cx)		; did we find it?
   257		 jrst rnts4d			; maybe, try net,,host
   258		aobjn cx,rnts4a			; loop until we find it
   259	
   260	; here if not found; look for an empty slot to make a new connection in
   261	rnts4g:	ldb a,seqcon			; get control byte
   262		caie a,seqOpn			; is it an open request?
   263		 jrst rnts4x			; no, send a broken in return
   264		movsi cx,-nconn			; yes, look for a free slot
   265	rnts4b:	skipn contab(cx)
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 12.5

   266		 jrst rnts4c
   267		aobjn cx,rnts4b
   268	
   269	; here if no room; return +1
   270	rnts4x:	pop p,pb
   271		jrst breksq			; send a sequin broken, return +1
   272	
   273	; here when a free slot found, make new connection
   274	rnts4c:	movei cx,(cx)
   275		movei sq,(cx)
   276		imuli sq,sqblen
   277		movei sq,sqbtab(sq)
   278		movem sq,contab(cx)
   279		ldb a,ppupss
   280		movem a,pupfsk(cx)
   281		ldb a,ppupsh
   282		ldb b,ppupsn
   283		hrl a,b
   284		movem a,pupfnh(cx)
   285		move a,srvjfn
   286		hrlm a,sqjfnx(sq)
   287		pushj p,conini
   288		 jrst [pop p,pb
   289		       popj p,]
   290		pop p,pb
   291		aos 0(p)
   292		dtype <LEAFSV: Sequin connection %6O opened%/>
   293		aos nactcn			; increment number of active conns
   294		popj p,
   295	
   296	; here when socket matches; look for net,,host
   297	rnts4d:	move c,a		; save pupfsk
   298		ldb a,ppupsh
   299		ldb b,ppupsn
   300		hrl a,b
   301	rnts4e:	camn a,pupfnh(cx)
   302		 jrst [camn c,pupfsk(cx)
   303			jrst rnts4f	; got it
   304		       jrst .+1]
   305		aobjn cx,rnts4e
   306		jrst rnts4g	
   307	
   308	; here when found a match
   309	rnts4f:	move sq,contab(cx)
   310		pop p,pb
   311		aos (p)
   312		popj p,
   313	
   314	ls rntstk,psisiz
   315	ls bntstk,psisiz			; interrupt stacks
   316	ls rntpdl
   317	ls bntpdl				; interrupt stack pointers
   318	
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 12.6

   319	; routine to send a SequinBroken back to sender when a Sequin cannot be
   320	; created
   321	; call: pushj p,breksq
   322	;	pb/ pointer to received packet
   323	; returns: +1, always
   324	breksq: movei pb,tmprec-pbhead
   325		ldb a,ppupsn			; get source port
   326		ldb b,ppupsh
   327		ldb c,ppupss
   328		movei pb,brkpup-pbhead		; point to space to send break pup
   329		dpb a,ppupdn			; deposit dest port
   330		dpb b,ppupdh
   331		dpb c,ppupd1			; low order bits
   332		rot c,-^d16			; rotate around high order bits
   333		dpb c,ppupd0			; and deposit into Pup
   334	
   335		movei pb,tmprec-pbhead		; deposit source host bytes
   336		ldb a,ppupdn
   337		ldb b,ppupdh
   338		movei pb,brkpup-pbhead
   339		dpb a,ppupsn
   340		dpb b,ppupsh
   341		move a,srvjfn			; determine local net, host, socket
   342		cvskt			
   343		 ercal jerr
   344		dpb c,ppupss			; save socket
   345	
   346		movei pb,tmprec-pbhead		; set up sequin fields
   347		ldb a,seqrec			; receive sequence
   348		ldb b,seqSen			; get send sequence
   349		ldb c,puplen			; any data in packet?
   350		caile c,mnplen	
   351		 aoj b,				; yes, increment for return recv seq
   352		movei pb,brkpup-pbhead
   353		dpb a,seqSen
   354		dpb b,seqRec
   355		setz a,				; no Alloc
   356		dpb a,seqAll
   357		movei a,seqBro			; say sequin broken
   358		dpb a,seqCon
   359	
   360		movei a,mnplen
   361		dpb a,puplen
   362		movei a,seqtyp
   363		dpb a,puptyp
   364		hrr a,srvjfn		; use the server jfn
   365		hrli a,(1b0+1b1)	; don't block, generate checksum
   366		movei b,brkpup
   367		hrli b,mnpbln
   368		pupo
   369		 elog <BREKSQ: PUPO error: %1J>
   370		log <BREKSQ: No room or Data Sequin rcvd for nonexistent connection>
   371		popj p,
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 12.7

   372	
   373	ls brkpup,MNPBLN+2		; a little longer for superstitious reasons
   374	
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 13

     1		subttl	PSI utilities
     2	
     3	; routine to init psi's
     4	; call: (p)/ jfn on port
     5	psiini::setom intdef
     6		move a,[iowd psisiz,bntstk] ; do this here because BNTSRV used to...
     7		movem a,bntpdl		    ; ... run at interrupt level
     8		move a,[iowd psisiz,rntstk]
     9		movem a,rntpdl
    10		move b,[levtab,,chntab]
    11		movei a,400000		; init PSI's for this fork
    12		sir
    13		eir
    14		move b,[actchn]		; activate used channels
    15		aic
    16		move a,[^d26,,^d23]	; assign ^Z interrupt to channel 23
    17		ati
    18		move a,-1(p)		; set received pup interrupt
    19		movei b,24
    20		move c,[36b5+1b11+36b17]; chan 1 is recvd interrupt
    21		mtopr
    22		popj p,
    23	
    24	; PSI channel definitions
    25	define psi(ch,lev,disp),<
    26	actchn==actchn!1b<ch>
    27		reloc chntab+^d<ch>
    28		lev,,disp
    29	>
    30	
    31	actchn==0
    32	chntab::psi(1,3,rntsrv)		; receiver service
    33		psi(9,1,pdlovf)		; Pushdown overflow
    34		psi(11,1,daterr)	; Data error
    35		psi(15,1,illins)	; Illegal instruction
    36		psi(16,1,illred)	; Illegal read
    37		psi(17,1,illwrt)	; Illegal write
    38		psi(18,1,illxct)	; Illegal execute
    39		psi(20,1,illsiz)	; Machine size exceeded
    40		psi(23,1,kilsrv)	; ^Z interrupt to kill server
    41	
    42		reloc chntab+^d36
    43	
    44	levtab::lev1pc
    45		lev2pc
    46		lev3pc
    47	
    48	; Fatal errors
    49	
    50	pdlovf::jsr crashx
    51		asciz /Pushdown overflow/
    52	
    53	daterr::jsr crashx
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 13.1

    54		asciz /IO data error/
    55	
    56	illred::jsr crashx
    57		asciz /Illegal read/
    58	
    59	illwrt::jsr crashx
    60		asciz /Illegal write/
    61	
    62	illxct::jsr crashx
    63		asciz /Illegal execute/
    64	
    65	illsiz::jsr crashx
    66		asciz /Machine size exceeded/
    67	
    68	; Common code for fatal error interrupts
    69	crashx:	0
    70		push p,lev1pc		; Put trap pc on stack
    71		push p,b
    72		hrro b,crashx		; Make call pc into string ptr
    73		jrst screw1
    74	
    75	jerr::	push p,b
    76		hrroi b,temp##
    77		write b,<%1J%/>
    78		hrroi b,temp##
    79		jrst screw1
    80	
    81	screwup::
    82		push p,b
    83		hrroi b,[asciz/A fatal error has occurred/]
    84	screw1:	push p,a		; don't clobber any acs
    85		hrrz a,-2(p)		; get caller
    86		soj a,			; decrement for true address
    87		log <%2S at %1O%/%/>
    88		time			; get now
    89		subm a,crstim		; compute how long ago we last crashed
    90		exch a,crstim
    91		caige a,^d<60*1000>	; longer than a minute?
    92		 jrst  [elog <Too-frequent crashes, aborting...>
    93			pushj p,dmplog##
    94			haltf
    95			jrst srvstt##]
    96		elog <Leaf server crashed, restarting...>
    97		pushj p,dmplog##
    98		jrst srvstt##
    99	
   100	ls crstim
   101	
   102	; here to handle illegal instruction
   103	illins::push p,a		; Not sumex, try to do ERCAL
   104		push p,b
   105		hrrz a,lev1pc
   106		hllz b,(a)		; Get instruction after error
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 13.2

   107		camn b,[ERCAL]		; Is it an ERCAL?
   108		 jrst [hrrz a,lev1pc	; Yes, simulate ERCAL to error routine
   109		       hrrz b,(a)	; Get address of error routine
   110		       movem b,psiret	; store it
   111		       aoj a,		; Adjust return address from interrupt
   112		       pop p,b
   113		       exch a,(p)	; Store new return address
   114		       jrst @psiret]	; Jump into error routine
   115		hllz b,-1(a)		; Not ERCAL, did a JSYS get us?
   116		camn b,[JSYS 0]		; Was it a JSYS?
   117		 jrst  [movei a,400000
   118			geter
   119			movei a,(b)	; isolate error number
   120			hrroi b,temp
   121			write b,<Fatal JSYS error %1J>
   122			pop p,b		; mung stack
   123			pop p,a
   124			push p,lev1pc
   125			push p,b
   126			hrroi b,temp
   127			jrst screw1]
   128		pop p,b
   129		pop p,a			; Not JSYS, handle as with other errors
   130		jsr crashx		
   131		asciz /Illegal instruction/
   132	
   133	ls psiret,1			; Location to hold address of error routine
   134	
   135	; ^Z interrupt to kill server
   136	kilsrv:	movsi cx,-nconn		; break all connections
   137		setz a,
   138		movei b,seqBro		; send sequin brokens
   139	kilsr1:	skipe sq,contab(cx)
   140		 pushj p,senseq
   141		aobjn cx,kilsr1
   142		pushj p,dmplog
   143		move a,srvjfn		; close the socket
   144		closf
   145		 elog <KILSRV: Unable to close server socket: %1J>
   146		gtad
   147		type <%/%/Tenex Leaf Server halted at %1T>
   148		haltf
   149		jrst srvstt##
PUPSEQ.MAC;35                      28-Jul-82 17:30     Page 14

     1		subttl	Storage
     2	ls bntacs,20		; storage for background process acs
     3	ls rntacs,20		; storage for recv interrupt acs
     4	
     5	; tables indexed by CX
     6	gs contab,nconn		; connection table
     7	gs rxtime,nconn		; receiver timeout
     8	gs txtime,nconn		; transmitter timeout
     9	gs pupfsk,nconn		; table of foreign sockets, indexed by cx
    10	gs pupfnh,nconn		; table of foreign net,,host, index by cx
    11	gs ltime,nconn		; local timeout (connection,,filelock)
    12	gs ftime,nconn		; foreign timeout (connection,,filelock)
    13	gs connfk,nconn		; fork for leaf server, indexed by cx
    14	
    15	gs nactcn,1		; holds number of active connections
    16	ls contro,1		; control word from received packet
    17	ls frepnt,1		; free space pointer for ASGFRE
    18	ls sndtmp,MXPBLN	; temporary send buffer
    19	ls tmprec,MXPBLN	; temporary receive buffer
    20	
    21	ls lev1pc,1
    22	ls lev2pc,1
    23	ls lev3pc,1
    24	
    25	gs txtab,lqutab*nconn
    26	gs rxtab,lqutab*nconn
    27	
    28	gs sqbtab,sqblen*nconn
    29	
    30		end
    31	


PUPUUO.MAC;7                       28-Jul-82 17:31     Page 2

     1	;<PUP>PUPUUO.MAC;6    17-May-81 18:03:12    Edit by Schoen
     2	; Fix %LETU to handle errors correctly on Tops20
     3	;<PUP>PUPUUO.MAC;4    20-Jan-81 20:45:59    Edit by SCHOEN
     4	; Fix %PRINT to handle PRINT EOL correctly on both Tops20 and Tenex
     5	;<PUP>PUPUUO.MAC;5	1/7/81			Edit by RINDFLEISCH
     6	; Added storage for RNERR and RNSTAT
     7	;<PUP>PUPUUO.MAC;4    20-Aug-80 11:35:24    Edit by SCHOEN
     8	; %RUNM UUO for errors in lower fork runnable version
     9	; %UERRO UUO modified to go to RNERR string in shared page if lower fork
    10	; %UTYPE UUO modified to be noop in lower fork version
    11	;<PUP>PUPUUO.MAC.3     9-Jul-80 23:35:18    Edit by SCHOEN
    12	; %PRINT checked only 37 as EOL, not using EOL defn in PUPDEF
    13	; This meant that tops20 version never sent <lf> after <cr>
    14	;<PUP>PUPUUO.MAC;2     6-Dec-79 14:27:46    EDIT BY SWEER
    15	; added DOLUUO to simulate Maxc UPSHJ opcode
    16	;<PUP>PUPUUO.MAC;6     2-SEP-79 16:00:59    EDIT BY TAFT
    17	;<PUP>PUPUUO.MAC;5    12-NOV-77 18:08:19    EDIT BY TAFT
    18	; Print octal numbers unsigned
    19	;<PUP>PUPUUO.MAC;4    15-APR-77 09:59:32    EDIT BY TAFT
    20	; Different format for %F conversion if SERVF is set
    21	;<PUP>PUPUUO.MAC;2    10-MAR-77 14:37:23    EDIT BY TAFT
    22	; Split out from PUPFTP.MAC
PUPUUO.MAC;7                       28-Jul-82 17:31     Page 3

     1	
     2	; Copyright 1979 by Xerox Corporation
     3	
     4		TITLE PUPUUO -- UUO HANDLER FOR PUPSRV AND PUPFTP
     5		SUBTTL E. A. Taft / March 1977
     6	
     7		SEARCH PUPDEF
     8		SEARCH MONSYM
     9	
    10	IFNDEF MAXC,<MAXC==0>
    11	
    12		USEVAR TOPVAR,TOPPVR
    13	
    14		LOC 41
    15	IFN MAXC,<
    16		UPSHJ P,UUODSP-1	; Dispatch on UUO (Maxc opcode)
    17	>
    18	IFE MAXC,<
    19		PUSHJ P,DOLUUO		; simulate Maxc opcode
    20	>
    21		RELOC
    22	
    23	IFE MAXC,<
    24	DOLUUO:	PUSH P,A		; save an ac
    25		MOVE A,40		; pick up luuo
    26		LSH A,-^D27		; position opcode to rh
    27		ADD A,[JRST @UUODSP-1]	; form jrst @uuodsp-1+opcode
    28		EXCH A,0(P)		; restore ac, put jrst on stack
    29		SUB P,[1,,1]		; adjust stack
    30		XCT 1(P)		; execute the jrst
    31	>
    32	
    33	; UUO dispatch table (driven by definitions in PUPDEF)
    34	; UUO handler routines are responsible for saving their own ac's
    35	
    36	UUODSP:	EXPAND(UUOS,<	IF2,<IFNDEF ITEM,<EXTERN ITEM>>
    37				EXP ITEM>)
    38	
    39	
    40	
    41	; PRINT "char"
    42	; Print the given character
    43	
    44	%PRINT:	EXCH A,40		; Get the character
    45		ANDI A,177		; Mask to just 7 bits
    46		CAIE A,CR		
    47		CAIN A,EOL		; EOL means CRLF
    48		 CAIA
    49		JRST %PRIN1
    50		MOVEI A,15
    51		PBOUT
    52		MOVEI A,12
    53	%PRIN1:	PBOUT			; Print it
PUPUUO.MAC;7                       28-Jul-82 17:31     Page 3.1

    54		MOVE A,40		; Restore ac
    55		POPJ P,
    56	
    57	
    58	; DTYPE <string>
    59	; Type given string iff debugging, with formatting actions
    60	
    61	%UDTYP:	TLNN F,(DEBUGF)		; Debugging?
    62		 POPJ P,		; No, ignore DTYPE
    63	
    64	; TYPE <string>
    65	; Type given string with formatting actions
    66	
    67	%UTYPE:	TLNE F,(RUNF)		; Lower fork version?
    68		 POPJ P,		; Then TYPE is a noop
    69		PUSHJ P,FORMAT		; Call formatter
    70		 PUSHJ P,%UTYP1		; Setup
    71		 CAI			; No completion action
    72		POPJ P,			; Return from UUO
    73	
    74	%UTYP1:	MOVEI A,101		; Setup destination designator
    75		TLNE F,(DEBUGF)		; Debugging?
    76		 DOBE			; Yes, avoid intermixed output
    77		POPJ P,
PUPUUO.MAC;7                       28-Jul-82 17:31     Page 4

     1	
     2	; ERROR <string>  or  ERROR <string>,n
     3	; Same as TYPE except also clears input buffer
     4	; If n is nonzero, n extra levels are popped before return
     5	
     6	%UERRO:	PUSH P,40		; Save the UUO itself
     7		PUSHJ P,FORMAT		; Call formatter
     8		 PUSHJ P,%UERR3		; Setup destination
     9		 PUSHJ P,%UERR2		; Completion -- clear input buffer
    10		SUB P,0(P)		; Pop off extra levels as required
    11		POPJ P,
    12	
    13	%UERR2:	MOVEI A,^D500		; Wait half a second
    14		DISMS
    15		MOVEI A,100		; Clear terminal input buffer
    16		CFIBF
    17		LDB A,[POINT 4,-6(P),12]  ; Get ac field of UUO
    18		ADDI A,1		; Make word for fixing stack
    19		HRLI A,(A)
    20		MOVEM A,-6(P)		; Put it back
    21		POPJ P,
    22	
    23	; Set up destination according to RUNF flag
    24	%UERR3: MOVEI A,101		; Assume to terminal
    25		TLNN F,(RUNF)		; Check type of PUPFTP
    26		 POPJ P,		; Lower fork, leave
    27		MOVSI A,(1B0)		; set some error condition
    28		MOVEM A,RNSTAT##
    29		HRROI A,RNERR##		; Error dest is string in shared paged
    30		POPJ P,
    31	
    32	
    33	; WRITE <string>   or   WRITE ac,<string>
    34	; Write given string with formatting actions on arbitrary
    35	;  destination designator given in ac (default ac is A)
    36	
    37	%UWRIT:	PUSHJ P,FORMAT		; Call formatter
    38		 PUSHJ P,%UWRI1		; Setup -- get selected designator
    39		 PUSHJ P,%UWRI2		; Completion -- update designator
    40		POPJ P,			; Return from UUO
    41	
    42	; Setup routine -- fetch designator from ac specified in UUO
    43	%UWRI1:	LDB A,[POINT 4,40,12]	; Get ac field of UUO
    44		CAIG A,D		; Ac in protected range?
    45		 ADDI A,-5(P)		; Yes, now on stack
    46		HRLM A,-5(P)		; Save address for finishing up
    47		MOVE A,0(A)		; Get designator from specified ac
    48		POPJ P,
    49	
    50	; Completion routine -- store possibly updated designator
    51	%UWRI2:	HLRZ D,-5(P)		; Recover ac field of UUO
    52		MOVEM A,0(D)		; Store updated designator
    53		SETZ B,			; Prepare to store null
PUPUUO.MAC;7                       28-Jul-82 17:31     Page 4.1

    54		TLNE A,-1		; Outputting to string?
    55		 IDPB B,A		; Yes, append null
    56		POPJ P,
PUPUUO.MAC;7                       28-Jul-82 17:31     Page 5

     1	
     2	; RUNM (error code,<string>)
     3	; Write error code in shared page, and error string, with formatting,
     4	; into error string region of page
     5	
     6	%URUNM:	PUSH P,A		; Save an AC
     7		HRRZ A,@40		; Move error code into stat region
     8		TLO A,(1B0)		; Say this is an error
     9		MOVEM A,RNSTAT##
    10		AOS 40			; Increment EA for string pointer
    11		PUSHJ P,FORMAT		; Format the string
    12		 HRROI A,RNERR##
    13		 PUSHJ P,%URUN1		; Null out string
    14		POP P,A
    15		POPJ P,
    16	
    17	%URUN1:	SETZ B,			; Null out the string
    18		IDPB B,A
    19		POPJ P,
    20	
    21	LS RNSTAT
    22	LS RNERR,40
PUPUUO.MAC;7                       28-Jul-82 17:31     Page 6

     1	
     2	; Perform output formatting for UUO routines.
     3	; Assumes ASCIZ string pointed to by 40 (effective adr of UUO).
     4	; Performs substitution for escape sequences of the form
     5	;	% <number> <letter>
     6	; where <number> sometimes specifies an ac and <letter> specifies
     7	; the operation (see table LETDSP).
     8	
     9	; Call by:
    10	;	PUSHJ P,FORMAT
    11	;	 Instruction to set up destination designator in A
    12	;	 Instruction to finish up after entire string written
    13	; Returns +3 always
    14	; No ac's clobbered
    15	
    16	FORMAT::PUSH P,A		; Save a block of ac's
    17		PUSH P,B
    18		PUSH P,C
    19		PUSH P,D
    20		XCT @-4(P)		; Execute setup instruction
    21		TLC A,-1		; -1 in lh of designator?
    22		TLCN A,-1
    23		 HRLI A,(POINT 7)	; Yes, make string ptr
    24		HRRZ B,40		; Get the effective address
    25		HRLI B,(POINT 7)	; Make byte ptr
    26		PUSH P,B		; Put on stack
    27	
    28	; Loop here for each character
    29	; A/ destination designator
    30	FORMAL:	ILDB B,0(P)		; Get a char from the string
    31		JUMPE B,FORMA2		; Jump if finished
    32		CAIN B,"%"		; Escape?
    33		 JRST FORMA3		; Yes, go handle
    34	
    35	; Not special character, just output it
    36	FORMA1:	PUSHJ P,FBOUT		; Do BOUT
    37		JRST FORMAL		; Loop
    38	
    39	; Here when done
    40	FORMA2:	SUB P,[1,,1]		; Flush byte ptr
    41		MOVE D,-4(P)		; Get caller pc
    42		XCT 1(D)		; Execute completion instruction
    43		POP P,D			; Restore ac's
    44		POP P,C
    45		POP P,B
    46		POP P,A
    47		JRST SK2RET		; Return +3
    48	
    49	
    50	; Internal BOUT routine
    51	; Same as BOUT except much faster in string pointer case
    52	; (Does not handle case of lh=-1
    53	
PUPUUO.MAC;7                       28-Jul-82 17:31     Page 6.1

    54	FBOUT::	TLNN A,-1		; Outputting to a file?
    55		 BOUT			; Yes, do so in normal manner
    56		TLNE A,-1		; To string?
    57		 IDPB B,A		; Yes (much faster than BOUT)
    58		POPJ P,
PUPUUO.MAC;7                       28-Jul-82 17:31     Page 7

     1	
     2	; FORMAT (cont'd)
     3	
     4	; Here when hit escape sequence
     5	FORMA3:	SETZ C,			; Init number
     6	FORMA4:	ILDB D,0(P)		; Get next char
     7		CAIL D,"0"		; A digit?
     8		CAILE D,"7"
     9		 JRST FORMA5		; No
    10		LSH C,3			; Yes, multiply number by 8
    11		ADDI C,-"0"(D)		; Add value of new digit
    12		JRST FORMA4
    13	
    14	FORMA5:	MOVEI B,-5(P)		; Get loc-1 of ac block on stack
    15		ADDI B,(C)		; Add ac #
    16		CAIG C,D		; One of the protected ac's?
    17		 SKIPA B,0(B)		; Yes, get contents from stack
    18		 MOVE B,0(C)		; No, get contents directly
    19		CAIL D,"A"		; Check bounds
    20		CAILE D,"Z"
    21		 JRST [	CAIN D,"%"	; %% means just quote %
    22			 JRST [	MOVEI B,"%"
    23				JRST FORMA1]
    24			CAIN D,"/"	; %/ means crlf
    25			 JRST [	MOVEI B,15
    26				PUSHJ P,FBOUT
    27				MOVEI B,12
    28				JRST FORMA1]
    29			PUSHJ P,SCREWUP##]  ; Anything else is a bug
    30		PUSHJ P,@LETDSP-"A"(D)	; Dispatch on command
    31		JRST FORMAL		; Loop
    32	
    33	
    34	; Dispatch table for escape sequence function letters
    35	; The routine dispatched to has the calling sequence:
    36	;	A/ Destination designator
    37	;	B/ Contents of ac
    38	;	C/ The ac number itself
    39	; Returns +1
    40	; Must update A appropriately;  may clobber B-D
    41	
    42	LETDSP:	SCREWUP##	; A
    43		SCREWUP##	; B
    44		%LETC##		; C - Pup contents as string (PUPSRV only)
    45		%LETD		; D - Decimal integer in ac
    46		SCREWUP##	; E
    47		%LETF		; F - Filename for JFN in ac
    48		SCREWUP##	; G
    49		SCREWUP##	; H
    50		%LETI		; I - Insert character given octal code
    51		%LETJ		; J - String for JSYS error # in ac
    52		SCREWUP##	; K
    53		SCREWUP##	; L
PUPUUO.MAC;7                       28-Jul-82 17:31     Page 7.1

    54		SCREWUP##	; M
    55		SCREWUP##	; N
    56		%LETO		; O - Octal integer in ac
    57		%LETP##		; P - Address from Pup (PUPSRV only)
    58		SCREWUP##	; Q
    59		%LETR		; R - Runime interval in ac - HH:MM:SS.S
    60		%LETS		; S - ASCIZ string pointed to by ac
    61		%LETT		; T - Date and time in ac
    62		%LETU		; U - User name for directory # in ac
    63		SCREWUP##	; V
    64		SCREWUP##	; W
    65		SCREWUP##	; X
    66		SCREWUP##	; Y
    67		SCREWUP##	; Z
PUPUUO.MAC;7                       28-Jul-82 17:31     Page 8

     1	
     2	; Individual functions for escape sequences
     3	
     4	; D - Decimal integer in ac
     5	%LETD:	MOVEI C,^D10		; Decimal radix
     6		NOUT			; Output number
     7		 PUSHJ P,SCREWUP##
     8		POPJ P,
     9	
    10	
    11	; F - Filename for JFN in ac
    12	%LETF:	HRRZS B			; Ensure no flags on in lh
    13		TLNN F,(SERVF)		; Are we in server?
    14		 TDZA C,C		; No, use standard form
    15		 MOVE C,[211120,,1]	; Yes, force printing of directory
    16		JFNS			; Generate filename string
    17		POPJ P,
    18	
    19	
    20	; I - Insert character for given octal code
    21	%LETI:	MOVE B,C		; Get the code
    22		JRST FBOUT		; Output it
    23	
    24	
    25	; J - String for JSYS error # in ac
    26	%LETJ:	HRLI B,400000		; This fork
    27		SETZ C,			; Expand fully
    28		ERSTR			; Convert error # to string
    29		 JRST [	HRRZ D,B	; Not defined, save error #
    30			HRROI B,[ASCIZ /Undefined JSYS error /]
    31			SOUT		; Complain
    32			HRRZ B,D	; Recover error #
    33			MOVEI C,10	; Octal radix
    34			NOUT		; Include error # in message
    35			 PUSHJ P,SCREWUP##
    36			POPJ P,]
    37		 PUSHJ P,SCREWUP##	; Bad designator?
    38		POPJ P,			; Done
    39	
    40	
    41	; O - Octal integer in ac
    42	%LETO:	MOVE C,[1B0+10]		; Unsigned, octal
    43		NOUT			; Output number
    44		 PUSHJ P,SCREWUP##
    45		POPJ P,
PUPUUO.MAC;7                       28-Jul-82 17:31     Page 9

     1	
     2	; Individual functions for escape sequences (cont'd)
     3	
     4	; R - Runtime interval in ac (ms), in form HH:MM:SS.S
     5	%LETR:	ADDI B,^D50		; Round up to nearest 0.1 second
     6		IDIV B,[^D<60*60*1000>]	; Get hours
     7		PUSH P,C		; Save remainder
     8		MOVEI C,^D10		; Output hours
     9		NOUT
    10		 PUSHJ P,SCREWUP##
    11		MOVEI B,":"		; Colon
    12		PUSHJ P,FBOUT
    13		POP P,B			; Recover remainder
    14		IDIVI B,^D<60*1000>	; Get minutes
    15		IDIVI C,^D1000		; Get seconds
    16		PUSH P,C		; Save seconds
    17		MOVE C,[1B2+1B3+2B17+^D10]  ; Decimal, always 2 digits
    18		NOUT			; Output minutes
    19		 PUSHJ P,SCREWUP##
    20		MOVEI B,":"		; Colon
    21		PUSHJ P,FBOUT
    22		POP P,B			; Recover seconds
    23		NOUT			; Output them
    24		 PUSHJ P,SCREWUP##
    25		MOVEI B,"."		; Decimal point
    26		PUSHJ P,FBOUT
    27		MOVE B,D		; Get thousanths
    28		IDIVI B,^D100		; Convert to tenths
    29		MOVEI C,^D10
    30		NOUT			; Output tenths
    31		 PUSHJ P,SCREWUP##
    32		POPJ P,
    33	
    34	
    35	; S - String pointed to by ac
    36	%LETS:	SETZ C,			; Terminate by null
    37		SOUT			; Append the string
    38		POPJ P,
    39	
    40	
    41	; T - Date and time in ac, in standard form DD-MMM-YY HH:MM:SS
    42	%LETT:	SETZ C,			; Specify standard form
    43		ODTIM			; Output date and time
    44		POPJ P,
    45	
    46	
    47	; U - User name for directory # in ac
    48	%LETU:
    49	tenex,<
    50		DIRST			; Directory to string
    51		 JRST %LETO		; Failed, output octal number
    52	>
    53	tops20,<
PUPUUO.MAC;7                       28-Jul-82 17:31     Page 9.1

    54		PUSH P,A		; Save dest
    55		DIRST
    56		 ERJMP [POP P,A		; Recover dest (Tops20 DIRST clobbers A...
    57			JRST %LETO]	; ...on error)
    58		POP P,0(P)		; Clean up stack
    59	> ;ifn tops20
    60		POPJ P,
PUPUUO.MAC;7                       28-Jul-82 17:31     Page 10

     1	
     2	; -----------------------------------------------------------------
     3	;	Miscellaneous subroutines
     4	; -----------------------------------------------------------------
     5	
     6	; Calling SAVEn (n=1 to 4) at the beginning of a subroutine causes
     7	; ac's P1 through Pn to be saved on the stack.  When the subroutine
     8	; returns, control passes back to SAVEn, which restores the same
     9	; ac's and returns to the caller of the subroutine.  A subroutine
    10	; that calles SAVEn must return either +1 or +2.
    11	
    12	SAVE1::	EXCH P1,0(P)		; Save P1, get caller pc
    13		HRLI P1,0(P)		; Remember where saved P1 is
    14		PUSHJ P,SAVJMP		; Save our pc and return to caller
    15		 SOS -1(P)		; Caller returned +1, compensate
    16		JRST P1SKP		; +2, restore P1 and return +2
    17	
    18	SAVE2::	EXCH P1,0(P)		; Save P1, get caller pc
    19		HRLI P1,0(P)		; Remember where saved P1 is
    20		PUSH P,P2		; Save P2
    21		PUSHJ P,SAVJMP		; Save our pc and return to caller
    22		 SOS -2(P)		; Caller returned +1, compensate
    23		JRST P2SKP		; +2, restore P1-P2 and return +2
    24	
    25	SAVE3::	EXCH P1,0(P)		; Save P1, get caller pc
    26		HRLI P1,0(P)		; Remember where saved P1 is
    27		PUSH P,P2		; Save P2
    28		PUSH P,P3		; Save P3
    29		PUSHJ P,SAVJMP		; Save our pc and return to caller
    30		 SOS -3(P)		; Caller returned +1, compensate
    31		JRST P3SKP		; +2, restore P1-P3 and return +2
    32	
    33	SAVE4::	EXCH P1,0(P)		; Save P1, get caller pc
    34		HRLI P1,0(P)		; Remember where saved P1 is
    35		PUSH P,P2		; Save P2
    36		PUSH P,P3		; Save P3
    37		PUSH P,P4		; Save P4
    38		PUSHJ P,SAVJMP		; Save our pc and return to caller
    39		 SOS -4(P)		; Caller returned +1, compensate
    40	
    41		POP P,P4		; Restore P4
    42	P3SKP:	POP P,P3		; Restore P3
    43	P2SKP:	POP P,P2		; Restore P2
    44	P1SKP:	POP P,P1		; Restore P1
    45		AOS 0(P)		; Return +2 to caller of caller
    46		POPJ P,
    47	
    48	
    49	; The following instruction restores P1 from stack and dispatches
    50	; to the caller of SAVEn.
    51	
    52	SAVJMP:	JRA P1,0(P1)
    53	
PUPUUO.MAC;7                       28-Jul-82 17:31     Page 10.1

    54	
    55	
    56	; Common subroutine returns
    57	
    58	SK3RET::AOS 0(P)		; Return +4 (i.e., skip 3)
    59	SK2RET::AOS 0(P)		; Return +3 (i.e., skip 2)
    60	SKPRET::AOS 0(P)		; Return +2 (i.e., skip 1)
    61	CPOPJ::	POPJ P,			; Return +1
    62	
    63	
    64		END


SMXACC.MAC;7                       28-Jul-82 17:31     Page 2

     1	;<PUP>SMXACC.MAC.6,  5-May-82 15:46:50, Edit by SCHOEN
     2	; Add ERCAL to GET in $RNUAC
     3	;<PUP>SMXACC.MAC;3		4/6/80		EDIT BY SCHOEN
     4	; BLT in $VACCT to clear UACBLK was missing AC1 operand.  Caused
     5	; PUPSRV to pages 1-16 of core...
     6	;<PUP>SMXACC.MAC;1		3/21/80		EDIT BY RINDFLEISCH
     7	; Code to simulate GDACC and VACCT JSYSs from SUBMIT in the batch system
     8	; TENEX 131 does not have these JSYSs
     9	
SMXACC.MAC;7                       28-Jul-82 17:31     Page 3

     1	
     2		TITLE SMXACC -- GDACC/VACCT JSYS EMULATION
     3		SUBTTL T. C. Rindfleisch / March, 1980
     4	
     5		SEARCH STENEX,PUPDEF,PSVDEF
     6	
     7	P==17
     8	
     9	; Verify user/account pair
    10	; Entry:   1 = USER # (-1 MEANS SELF (CONN DIR))
    11	;	   2 = ACCT DESIGNATOR, 5B2+NUMBER OR DSP
    12	; Call:    PUSHJ P,$VACCT
    13	; Return:  +1	FAIL TO MATCH
    14	;	   +2	USER/ACCT PAIR MATCH (or UACHK unrunnable)
    15	
    16	$VACCT::MOVEM	P,UPDL		;SAVE THE USER'S STACK POINTER
    17		PUSH	P,1		;USER NUMBER
    18		PUSH	P,2		;ACCOUNT DESIGNATOR
    19		PUSH	P,3
    20		MOVEI	1,400000	;THIS FORK
    21		RPCAP
    22		TRNE	3,1B18+1B19	;WHEEL OR OP?
    23		 JRST  [POP P,3		;YES
    24			JRST $VACC2]	;SKIP RETURN
    25		POP	P,3
    26		MOVE	2,-1(P)		;GET USER NUMBER
    27		SETZM	UACBLK
    28		MOVE	1,[UACBLK,,UACBLK+1]
    29		BLT	1,UACBLK+17	;CLEAR AC ARG BLOCK (ejs,4/6/80 ac1 was missing)
    30		CAME	2,[-1]		;SELF?
    31		 JRST $VACC1		;NO
    32		PUSH	P,3
    33		PUSH	P,4
    34		GJINF			;GET JOB INFO CONN DIR IN 2
    35		POP	P,4
    36		POP	P,3
    37	$VACC1:	HRROI	1,UACBLK	;FIRST 8 AC'S CONTAIN DIRST
    38		DIRST
    39		 JRST  [MOVEI 1,VACX1	; Error, no such user
    40			JRST $VAFXT]
    41		MOVE	1,0(P)		;GET ACCT DESG
    42		CAML	1,[500000,,0]
    43		CAMLE	1,[577777,,-1]	;IS IT NUMERIC?
    44		 JRST $VASTR		;NO STRING
    45		MOVEM	1,UACBLK+10	;NUMERIC DESIG IN AC10
    46		MOVEI	2,1		;START AT NUMERIC ENTRY POINT
    47		JRST $VACC3		; Run the fork
    48	
    49	$VASTR:	MOVE	2,[POINT 7,UACBLK+10] ;POINT TO AC10-17 FOR ACCT STRING
    50		TLC	1,-1		;DSP?
    51		TLCN	1,-1		;SKIP IF NOT DSP
    52		HRLI	1,440700	;CONVERT TO STRING POINTER
    53		PUSH	P,3
SMXACC.MAC;7                       28-Jul-82 17:31     Page 3.1

    54		PUSH	P,4
    55		MOVNI	4,^D39		;WE ONLY TAKE 39 CHARS
    56	$VALUP:	ILDB	3,1
    57		IDPB	3,2
    58		CAIE	3,0		;SKIP IF NULL BYTE
    59		 AOJL	4,$VALUP	;GET 39 CHARS MAX
    60		POP	P,4
    61		POP	P,3
    62		MOVEI	2,2		;ENTRY POINT FOR STRING
    63	$VACC3:	MOVEI	1,UACBLK	;POINT TO ARG BLOCK
    64		PUSHJ	P,$RNUAC
    65		 JRST $VACC2		;FORK FAILED TO RUN
    66		CAIE	1,0		;FIND A MATCH?
    67		 SKIPA 1,[VACX2]	; No Match
    68	$VACC2:	AOSA -2(P)		; OK, Skip return
    69	$VAFXT:	MOVEM 1,-1(P)		; Error, install code - non-skip return
    70		POP P,2
    71		POP P,1
    72		POPJ P,
    73	
SMXACC.MAC;7                       28-Jul-82 17:31     Page 4

     1	
     2	; Get default account for user
     3	; Entry:   1 = E FOR STRING ACCT (DSP)
     4	;	   2 = USER DIR # (-1 FOR SELF (CONN DIR))
     5	; Call:    PUSHJ P,$GDACC
     6	; Return:  +1	FAILURE
     7	;	   +2	SUCCESS ACCOUNT STRING POINTER IN AC1
     8	;
     9	$GDACC::MOVEM	P,UPDL		;SAVE USER'S STACK POINTER
    10		PUSH	P,1		;DSP FOR ACCT
    11		PUSH	P,2		;USER NUMBER
    12		SETZM	UACBLK
    13		MOVE	1,[UACBLK,,UACBLK+1]
    14		BLT	1,UACBLK+17	;CLEAR AC ARG BLOCK
    15		CAME	2,[-1]		;SELF?
    16		 JRST $GDAC1		;NO
    17		PUSH	P,3
    18		PUSH	P,4
    19		GJINF			;GET CONN DIR NUM IN 2
    20		POP	P,4
    21		POP	P,3
    22	$GDAC1:	HRROI	1,UACBLK	;POINT TO AC0-7	FOR DIRST
    23		DIRST
    24		 JRST  [MOVEI 1,GDACX1	; No go
    25			JRST $GDFXT]	;DO FAIL RETURN
    26		MOVEI	1,UACBLK	;POINT TO AC BLOCK
    27		SETZ	2,		;0 ENTRY POINT FOR DEFAULT
    28		PUSHJ	P,$RNUAC
    29		 JRST  [MOVEI 1,ACCTX1	;NON-SKIP IF FORK FAILED
    30			JRST $GDFXT]
    31		CAIE	1,0		;DID WE FIND DEFAULT?
    32		 JRST  [MOVEI 1,GDACX2	; No go
    33			JRST $GDFXT]
    34		PUSH	P,3
    35		PUSH	P,4
    36		MOVNI	3,^D39		;39 CHARS MAX
    37		HRRZ	2,UACBLK+2	;GET POINTER REL TO AC BLOCK
    38		ADD	2,[POINT 7,UACBLK] ;MAKE IT A USEFUL POINTER
    39		MOVE	4,-3(P)		;GET USERS POINTER
    40		HRLI	4,440700	;MAKE E A POINTER
    41	$GDACL:	ILDB	1,2
    42		IDPB	1,4
    43		CAIE	1,0		;SKIP IF  A NULL
    44		AOJL	3,$GDACL
    45		JUMPE 3,[DPB 3,4	; MAKE SURE IT'S ASCIZ
    46			 JRST .+1]
    47		POP	P,4
    48		POP	P,3
    49		AOSA	-2(P)		;DO SKIP RETURN
    50	$GDFXT:	MOVEM 1,-1(P)		; INSTALL THE ERROR CODE
    51		POP	P,2
    52		POP	P,1
    53		POPJ	P,
SMXACC.MAC;7                       28-Jul-82 17:31     Page 4.1

    54	
SMXACC.MAC;7                       28-Jul-82 17:31     Page 5

     1	
     2	; Runs UACHK program for account lookup/check
     3	; Entry:   1 = POINTER TO AC ARG BLOCK
     4	;	   2 = ENTRY VECTOR OFFSET
     5	;	   	0=GET DEFAULT, 1=NUMERIC CHECK, 2=STRING CHECK
     6	; Call:    PUSHJ P,$RNUAC
     7	; Return:  +1, failure
     8	;	   +2, success
     9	
    10	$RNUAC:	PUSH	P,1		;ARG POINTER
    11		PUSH	P,2		;ENTRY VECTOR
    12		MOVSI	1,(1B2+1B17)	;OLD FILE, SHORT FORM
    13		HRROI	2,[ASCIZ /<SYSTEM>UACHK.SAV/]
    14		GTJFN
    15		JRST [	POP	P,2
    16			POP	P,1
    17			POPJ	P, ]	;DO FAIL RETURN IF CANT FIND FILE
    18		PUSH	P,1		;JFN
    19	$RNUA1:	MOVSI	1,(1B1)		;SET CAP DONT START
    20		CFORK
    21		 JRST  [MOVEI	1,^D1000
    22			DISMS		;TRY AGAIN IN 1 SEC
    23			JRST $RNUA1]
    24		PUSH	P,1		;FORK HANDLE
    25		MOVSI	1,0(1)		;MOVE HANDLE TO LH
    26	$RNUA2:	HRR	1,-1(P)		;AND PUT JFN IN RH
    27		GET
    28		 ERCAL	$RNUAF
    29		MOVE	1,(P)
    30		MOVE	2,-3(P)		;GET POINTER TO ARG BLOCK
    31		SFACS			;LOAD ACS
    32		MOVE	2,-2(P)		;GET VECTOR OFFSET
    33		SFRKV			;START IT
    34		WFORK			;WAIT FOR IT
    35		FFORK			;FREEZE IT
    36		MOVE	2,-3(P)		;POINT TO ARG BLOCK
    37		RFACS			;COPY BACK THE ACS
    38		RFSTS			;GET FORK STATUS
    39		TLZ	1,(1B0)		;KILL THE FREEZE BIT
    40		CAME	1,[2,,0]
    41		 TLOA	2,-1		;INVOL TERMINATE
    42		TLZ	2,-1		;CLEAN HALT
    43		POP	P,1		;GET FORK HANDLE
    44		KFORK			;GET RID OF IT
    45		POP	P,1		;GET THE JFN
    46		RLJFN			;RELEASE IT
    47		 JFCL			;SHOULDNT HAPPEN!!??
    48		MOVE	1,-1(P)		;POINT TO BLOCK
    49		MOVE	1,1(1)		;WE WANT THE AC1
    50		CAIL	2,0		;INVOL TERMINATE?
    51		CAILE	1,0		;OR PROGRAM ERROR?
    52		 SOS	-2(P)		;DO NON-SKIP
    53		POP	P,2
SMXACC.MAC;7                       28-Jul-82 17:31     Page 5.1

    54		SUB	P,[1,,1]	;POP STACK AGAIN
    55		AOS	(P)
    56		POPJ	P,
    57	
    58	; HERE ON ILLEGAL INSTRUCTION
    59	$RNUAF: PUSH P,1
    60		PUSH P,2
    61		MOVEI 1,400000
    62		GETER
    63		MOVEI 2,(2)
    64		ELOG <$RNUAC: PSI due to %2J%/>
    65		CAIN 2,GETX2		; Special pages table full?
    66		 JRST [MOVE 1,-2(P)
    67		       MOVE 1,-1(1)	; Get the failing instruction
    68		       CAME 1,[GET]	; A get?
    69		       JRST .+1		; No, leave
    70		       MOVEI 1,^D1000	; Yes, wait and try again
    71		       DISMS		
    72		       POP P,2
    73		       POP P,1
    74		       SOS 0(P)		; Return to the failing instruction
    75		       POPJ P,]
    76		MOVE P,UPDL
    77		POPJ P,			;Ret +1 for perceived failure
SMXACC.MAC;7                       28-Jul-82 17:31     Page 6

     1	
     2	; AC block for running UACHK
     3	UACBLK:	BLOCK 20		; AC block for running lower fork
     4	UPDL:	BLOCK 1			; User's stack pointer on entry
     5		END

                                   28-Jul-82 17:31     Page 7

$CLOSF	PSVLEF.MAC;33        7.106   11.21   14.49   15.14   15.26#  18.19   21.92   
$GDAC1	SMXACC.MAC;7  4.16    4.22#   
$GDACC	PLFSUP.MAC;3  3.24    
	SMXACC.MAC;7  4.9#    
$GDACL	SMXACC.MAC;7  4.41#   4.44    
$GDFXT	SMXACC.MAC;7  4.25    4.30    4.33    4.50#   
$RNUA1	SMXACC.MAC;7  5.19#   5.23    
$RNUA2	SMXACC.MAC;7  5.26#   
$RNUAC	SMXACC.MAC;7  3.64    4.28    5.10#   5.64#   
$RNUAF	SMXACC.MAC;7  5.28    5.59#   
$VACC1	SMXACC.MAC;7  3.31    3.37#   
$VACC2	SMXACC.MAC;7  3.24    3.65    3.68#   
$VACC3	SMXACC.MAC;7  3.47    3.63#   
$VACCT	PLFSUP.MAC;3  3.25    
	SMXACC.MAC;7  3.16#   
$VAFXT	SMXACC.MAC;7  3.40    3.69#   
$VALUP	SMXACC.MAC;7  3.56#   3.59    
$VASTR	SMXACC.MAC;7  3.44    3.49#   
%     	PUPDEF.MAC;11        4.17    
	PUPPRP.MAC;4  3.43    
	PUPSEQ.MAC;35        3.63    3.83    5.27    5.27    11.172  11.172  11.229  11.229  13.87   13.147  13.147  
%%2O  	PSVLEF.MAC;33        20.77#  
%16O  	PSVLEF.MAC;33        7.5     
	PUPSEQ.MAC;35        11.403  
%1D   	PSVLEF.MAC;33        12.335  
%1J   	PLFSUP.MAC;3  15.53   
	PSVLEF.MAC;33        7.108   7.112   8.49    12.295  12.322  14.50   14.56   15.15   15.34   
	PUPSEQ.MAC;35        4.166   12.112  12.369  13.121  13.145  
%1J%  	PUPSEQ.MAC;35        4.46    4.50    12.239  13.77   
%1O   	PSVLEF.MAC;33        7.5     7.21    7.50    7.65    11.8    15.8    16.10   17.9    18.7    19.5    20.29   20.77#  
	     21.68   
	PUPSEQ.MAC;35        4.169   8.72    8.75    8.118   10.157  11.375  11.399  11.403  12.92   12.101  
%1O%  	PSVLEF.MAC;33        12.337  
	PUPSEQ.MAC;35        9.37    9.49    9.58    9.69    13.87   
%1S   	PSVLEF.MAC;33        12.339  
%1T   	PUPSEQ.MAC;35        13.147  
%1U   	PSVLEF.MAC;33        10.157  20.53   
%1U%74	PSVLEF.MAC;33        10.151  
%2J%  	SMXACC.MAC;7  5.64    
%2O   	PSVLEF.MAC;33        7.50    8.38    20.53   
	PUPSEQ.MAC;35        8.72    8.75    11.375  
%2P   	PUPSEQ.MAC;35        4.169   
%2S   	PSVLEF.MAC;33        12.46   12.64   12.77   12.85   12.96   12.105  12.193  12.202  
	PUPSEQ.MAC;35        13.87   
%2S.%3	PSVLEF.MAC;33        13.36   
%2U   	PSVLEF.MAC;33        10.157  12.249  
%3D   	PSVLEF.MAC;33        8.38    
%3O   	PSVLEF.MAC;33        10.151  10.157  15.15#  15.34#  20.77   
	PUPSEQ.MAC;35        12.70   
%3S   	PUPSEQ.MAC;35        8.77    
%6O   	PUPSEQ.MAC;35        12.292  
%74I%1	PSVLEF.MAC;33        12.333  
%74I%2	PSVLEF.MAC;33        10.178  
                                   28-Jul-82 17:31     Page 7.1

%LETC 	PSVLEF.MAC;33        25.18#  
	PUPUUO.MAC;7  7.44    
%LETD 	PUPUUO.MAC;7  7.45    8.5#    
%LETF 	PUPUUO.MAC;7  7.47    8.12#   
%LETI 	PUPUUO.MAC;7  7.50    8.21#   
%LETJ 	PUPUUO.MAC;7  7.51    8.26#   
%LETO 	PUPUUO.MAC;7  7.56    8.42#   9.51    9.57    
%LETP 	PSVLEF.MAC;33        25.25#  
	PUPUUO.MAC;7  7.57    
%LETR 	PUPUUO.MAC;7  7.59    9.5#    
%LETS 	PUPUUO.MAC;7  7.60    9.36#   
%LETT 	PUPUUO.MAC;7  7.61    9.42#   
%LETU 	PUPUUO.MAC;7  7.62    9.48#   
%PRIN1	PUPUUO.MAC;7  3.49    3.53#   
%PRINT	PUPUUO.MAC;7  3.44#   
%UDTYP	PUPUUO.MAC;7  3.61#   
%UELOG	PSVLEF.MAC;33        25.11#  
%UERR2	PUPUUO.MAC;7  4.9     4.13#   
%UERR3	PUPUUO.MAC;7  4.8     4.24#   
%UERRO	PUPUUO.MAC;7  4.6#    
%UFTPM	PSVLEF.MAC;33        25.18#  
%ULOG 	PSVLEF.MAC;33        25.8#   
%UNOIS	PSVLEF.MAC;33        25.18#  
%UPROM	PSVLEF.MAC;33        25.18#  
%URUN1	PUPUUO.MAC;7  5.13    5.17#   
%URUNM	PSVLEF.MAC;33        25.18#  
	PUPUUO.MAC;7  5.6#    
%UTYP1	PUPUUO.MAC;7  3.70    3.74#   
%UTYPE	PUPUUO.MAC;7  3.67#   
%UWRI1	PUPUUO.MAC;7  4.38    4.43#   
%UWRI2	PUPUUO.MAC;7  4.39    4.51#   
%UWRIT	PUPUUO.MAC;7  4.37#   
.ASSIG	PUPDEF.MAC;11        3.48    3.49    3.50    3.51    
.ATPTY	PLFSUP.MAC;3  3.16    5.25#   
.CDDAC	PLFSUP.MAC;3  12.41   
.CDDGP	PLFSUP.MAC;3  12.37   
.CDDPT	PLFSUP.MAC;3  12.54   
.CDLEN	PLFSUP.MAC;3  12.25   
.CDPSW	PLFSUP.MAC;3  12.29   12.49   
.CDUGP	PLFSUP.MAC;3  12.33   
.CFGRP	PLFSUP.MAC;3  3.15    14.5#   
.CHARG	PLFSUP.MAC;3  11.14   14.28   14.39   15.13   16.16   
.CHK1 	PLFSUP.MAC;3  10.46   10.51#  
.CHKAC	PSVLEF.MAC;33        13.81   13.90   13.100# 
.CKAAC	PLFSUP.MAC;3  11.16   14.29   14.41   15.17   
	PSVLEF.MAC;33        13.79   13.87   
.CKACD	PLFSUP.MAC;3  15.39   
	PSVLEF.MAC;33        13.73   
.CKACF	PLFSUP.MAC;3  15.16   
.CKACN	PLFSUP.MAC;3  11.15   
.CKADL	PLFSUP.MAC;3  14.40   
.CKAEC	PLFSUP.MAC;3  15.41   
	PSVLEF.MAC;33        13.75   
                                   28-Jul-82 17:31     Page 7.2

.CKALD	PLFSUP.MAC;3  15.37   
	PSVLEF.MAC;33        13.71   
.CKAPR	PLFSUP.MAC;3  15.42   
.CKARD	PSVLEF.MAC;33        13.78   
.CKAUD	PLFSUP.MAC;3  15.35   
	PSVLEF.MAC;33        13.69   
.CKAWR	PLFSUP.MAC;3  15.14   
	PSVLEF.MAC;33        13.86   
.CNCHK	PLFSUP.MAC;3  9.32    9.54    10.17   10.28#  
	PSVLEF.MAC;33        10.226  
.CNCO0	PLFSUP.MAC;3  9.23#   9.47    10.10   
.CNCON	PLFSUP.MAC;3  3.15    9.20#   
.CNPSW	PLFSUP.MAC;3  3.15    10.7#   
.CNPXY	PLFSUP.MAC;3  3.15    9.44#   
.GDACC	PLFSUP.MAC;3  3.15    13.24#  
	PSVLEF.MAC;33        13.43   
.GE.  	PUPSEQ.MAC;35        3.83    
.JICPJ	PSVLEF.MAC;33        4.33    
.LOGCX	PSVLEF.MAC;33        10.102  10.115  10.138# 
.LOGF 	PSVLEF.MAC;33        10.21   10.24   10.39   10.51   10.72   10.100  10.113  10.126  10.131# 
.LOGIN	PSVLEF.MAC;33        10.9#   10.151# 10.157# 11.47   20.7    21.107  
.LOGS 	PSVLEF.MAC;33        10.34   10.57   10.83#  
.LOGX 	PSVLEF.MAC;33        10.79   10.87   10.128  10.145# 
.MENTR	PLFSUP.MAC;3  4.6#    4.11    9.28    9.50    10.13   13.31   
.MRETN	PLFSUP.MAC;3  3.33    3.38    4.13#   4.16    
.NOCAL	PUPSEQ.MAC;35        3.58    3.93    
.NOINT	PSQDEF.MAC;9  3.144   
	PSVLEF.MAC;33        3.35    
	PUPSEQ.MAC;35        3.54#   
.NULIO	PLFSUP.MAC;3  10.44   
.OKCAL	PUPSEQ.MAC;35        3.76    3.94    
.OKINT	PSQDEF.MAC;9  3.145   
	PSVLEF.MAC;33        3.35    
	PUPSEQ.MAC;35        3.72#   3.79    3.83    
.OPRFN	PLFSUP.MAC;3  3.15    5.7#    
.SFLWR	PLFSUP.MAC;3  8.36    
.SFUS0	PLFSUP.MAC;3  8.18#   8.22    
.SFUST	PLFSUP.MAC;3  3.16    8.6#    
.STDI1	PLFSUP.MAC;3  6.10#   6.23#   6.36    6.42    
.STDIR	PLFSUP.MAC;3  3.16    6.7#    
	PUPPRP.MAC;4  9.44    
.STUSR	PLFSUP.MAC;3  3.16    6.34#   8.24    
	PUPPRP.MAC;4  9.70    
.UDELF	PLFSUP.MAC;3  3.16    5.41#   
.VACCT	PLFSUP.MAC;3  3.15    13.57#  
A     	PLFSUP.MAC;3  5.43    5.49    6.10    6.14    6.15    6.20    6.23    6.25    6.39    7.14    7.15    7.18    7.20    
	      7.28    7.30    7.43    7.45    7.48    7.53    8.16    8.17    8.21    8.25    8.27    8.28    8.32    8.36    
	      8.39    14.41   
	PSQDEF.MAC;9  3.23#   
	PSVLEF.MAC;33        4.6     4.7     4.18    4.20    4.21    4.23    4.24    4.25    4.31    4.42    4.48    4.52    
	     5.13    5.14    5.15    5.19    5.22    5.23    5.24    5.26    5.27    5.42    5.43    5.44    5.48    5.51    
	     5.52    5.53    5.55    5.56    5.71    5.72    5.73    5.79    5.82    5.102   5.104   5.105   5.114   5.120   
	     5.134   5.135   5.136   5.140   6.6     6.7     6.8     6.9     6.10    6.39    6.40    6.42    6.43    6.45    
                                   28-Jul-82 17:31     Page 7.3

	     6.48    6.54    6.55    6.63    6.64    6.65    6.66    6.67    6.69    6.70    7.3     7.4     7.18    7.19    
	     7.20    7.28    7.31    7.35    7.36    7.37    7.39    7.46    7.49    7.54    7.55    7.64    7.103   7.104   
	     7.105   7.107   7.110   8.8     8.26    8.28    8.31    8.32    8.52    8.53    8.56    8.96    8.98    8.99    
	     8.102   8.105   8.109   8.111   8.149   8.151   8.152   8.153   8.155   8.159   9.12    9.15    9.16    9.17    
	     9.18    9.19    9.19    9.20    10.10   10.11   10.16   10.20   10.22   10.23   10.25   10.25   10.26   10.27   
	     10.31   10.32   10.33   10.36   10.38   10.40   10.41   10.45   10.49   10.50   10.53   10.59   10.60   10.64   
	     10.68   10.71   10.73   10.74   10.75   10.77   10.78   10.79   10.84   10.85   10.90   10.95   10.96   10.99   
	     10.101  10.103  10.107  10.108  10.111  10.112  10.118  10.122  10.125  10.127  10.138  10.148  10.154  10.169  
	     10.170  10.172  10.176  10.179  10.183  10.184  10.186  10.188  10.191  10.192  10.195  10.204  10.204  10.205  
	     10.206  10.209  10.210  10.216  10.224  10.229  11.7    11.19   11.20   11.23   11.26   11.26   11.36   11.41   
	     11.50   11.55   11.66   11.67   11.68   11.69   11.70   11.71   11.72   11.73   11.74   11.75   11.77   11.79   
	     11.81   11.85   12.17   12.21   12.110  12.111  12.145  12.206  12.207  12.238  12.246  12.262  12.263  12.265  
	     12.268  12.271  12.284  12.297  12.312  12.313  12.315  12.319  12.320  12.323  12.328  12.330  12.334  12.336  
	     12.338  12.341  12.352  12.358  12.367  12.377  12.387  12.406  12.407  12.408  12.412  12.414  13.13   13.14   
	     13.15   13.16   13.18   13.19   13.21   13.23   13.25   13.27   13.29   13.31   13.33   13.38   13.39   13.41   
	     13.45   13.46   13.48   13.52   13.53   13.54   13.54   13.55   13.55   13.67   13.69   13.70   13.71   13.72   
	     13.73   13.74   13.75   13.76   13.80   13.82   13.84   13.88   13.89   13.91   13.93   13.97   13.100  13.104  
	     13.114  13.118  13.120  13.123  13.127  13.128  13.130  13.133  13.141  13.145  13.147  13.152  13.156  13.158  
	     13.159  13.160  13.164  14.9    14.18   14.20   14.27   14.28   14.35   14.44   14.46   14.47   14.48   14.54   
	     15.7    15.13   15.16   15.18   15.27   15.28   15.31   15.32   15.39   15.40   15.41   15.45   15.49   15.51   
	     15.51   15.52   15.54   15.55   16.9    16.14   16.24   16.25   16.26   16.27   16.39   16.45   16.55   16.62   
	     16.77   16.80   16.85   16.86   16.86   16.87   16.88   16.89   16.90   16.95   17.7    17.13   17.24   17.25   
	     17.26   17.43   17.44   17.49   17.50   17.53   17.55   17.58   17.58   17.63   17.69   17.78   17.79   17.116  
	     18.6    18.11   18.14   18.15   18.17   18.18   18.22   18.23   18.28   18.31   18.32   18.38   19.4    19.6    
	     19.7    19.9    19.11   19.12   19.15   19.17   19.19   20.6    20.12   20.14   20.26   20.27   20.28   20.37   
	     20.41   20.43   20.45   20.49   20.51   20.60   20.64   20.66   20.68   20.72   20.74   21.67   21.76   21.80   
	     21.84   21.85   21.90   21.91   21.94   21.104  21.110  21.115  21.127  21.129  22.22   22.26   23.20   23.24   
	     23.24   23.25   23.27   23.28   23.32   23.58   23.59   23.60   23.61   23.71   23.72   23.73   23.74   23.83   
	     23.84   23.85   23.89   23.99   23.104  23.108  23.114  23.118  23.119  23.127  23.131  23.136  23.140  23.147  
	     23.151  23.154  23.158  23.165  23.168  23.177  23.185  23.189  23.197  23.201  23.209  23.213  23.222  23.225  
	     23.232  23.236  23.238  23.240  23.240  23.241  23.242  23.244  23.253  23.254  23.255  24.11   24.19   24.21   
	     24.22   24.24   24.27   24.37   24.46   24.51   24.62   24.65   24.68   24.83   24.93   24.97   24.104  24.104  
	     24.105  24.106  24.108  24.109  24.112  24.114  24.120  24.124  24.129  24.140  24.148  24.150  24.151  24.153  
	     24.156  24.166  24.175  24.180  24.191  24.194  24.197  24.211  25.25   25.32   25.34   25.46   25.48   25.59   
	     26.13   26.18   26.24   26.25   26.28   26.40   26.42   26.48   26.49   26.50   26.52   26.54   26.56   26.58   
	     26.59   27.8    27.9    27.11   27.12   27.36   27.43   27.45   27.48   27.51   27.52   27.60   27.61   27.64   
	     27.65   27.69   27.70   28.59   28.67   28.68   28.80   28.81   28.83   28.84   28.87   28.89   28.90   28.91   
	     28.92   28.99   28.108  28.109  28.110  28.113  28.116  28.120  28.124  28.128  28.132  28.141  28.145  28.146  
	     28.147  28.149  28.153  28.155  28.158  28.160  28.165  28.171  28.172  28.175  28.180  28.193  28.194  28.196  
	     28.197  28.198  28.198  28.199  28.200  28.201  28.212  
	PUPDEF.MAC;11        3.13#   4.9     4.56    
	PUPPRP.MAC;4  3.23    3.24    3.25    3.26    3.32    3.48    3.56    6.34    6.37    6.56    8.11    8.12    8.21    
	      9.10    9.15    9.20    9.21    9.43    9.46    9.69    10.15   10.18   10.47   10.50   10.52   10.53   11.16   
	      12.29   12.31   12.31   12.32   12.33   12.42   12.51   13.22   13.30   13.31   13.34   13.42   13.46   
	PUPSEQ.MAC;35        3.54    3.56    3.57    3.58    3.59    3.66    3.69    3.72    3.74    3.75    3.76    3.77    
	     3.85    3.88    4.12    4.14    4.15    4.18    4.19    4.20    4.27    4.44    4.52    4.53    4.55    4.57    
	     4.91    4.95    4.96    4.98    4.101   4.119   4.120   4.123   4.129   4.130   4.131   4.132   4.138   4.140   
	     4.142   4.143   4.144   4.147   4.149   4.150   4.153   4.154   4.157   4.158   4.160   4.161   4.168   4.174   
	     5.11    5.13    5.14    5.15    5.16    5.17    5.19    5.21    5.21    5.23    5.24    5.30    5.31    5.33    
	     5.34    5.35    5.35    5.36    5.37    5.38    5.39    5.40    5.41    5.42    5.48    5.50    5.52    5.53    
	     5.54    5.55    5.58    5.59    5.60    5.62    5.63    5.65    5.66    5.68    5.70    5.72    5.73    5.75    
	     5.76    5.77    5.78    5.79    5.80    5.81    5.82    5.84    5.85    5.86    5.87    5.88    5.89    5.92    
	     5.93    5.94    5.97    5.97    5.98    5.100   5.111   5.112   5.112   6.11    6.12    6.12    6.17    6.18    
                                   28-Jul-82 17:31     Page 7.4

	     6.21    6.22    6.31    6.32    6.32    7.24    8.20    8.22    8.23    8.26    8.27    8.32    8.40    8.41    
	     8.44    8.45    8.60    8.61    8.63    8.64    8.65    8.69    8.73    8.79    8.88    8.89    8.90    8.106   
	     8.107   8.111   8.113   8.114   8.115   8.116   8.116   8.117   8.119   8.122   8.123   8.127   8.128   8.131   
	     8.132   9.12    9.13    9.14    9.15    9.16    9.20    9.23    9.26    9.32    9.36    9.38    9.39    9.40    
	     9.45    9.48    9.52    9.57    9.63    9.64    9.66    9.67    9.68    10.5    10.6    10.7    10.14   10.15   
	     10.23   10.26   10.30   10.31   10.33   10.36   10.39   10.40   10.41   10.46   10.53   10.54   10.55   10.58   
	     10.62   10.65   10.70   10.73   10.78   10.82   10.86   10.87   10.90   10.91   10.92   10.93   10.96   10.97   
	     10.98   10.100  10.102  10.103  10.104  10.106  10.119  10.121  10.123  10.124  10.137  10.144  10.145  10.146  
	     10.152  10.153  10.154  10.156  11.19   11.22   11.23   11.24   11.27   11.29   11.30   11.34   11.35   11.37   
	     11.38   11.39   11.53   11.57   11.57   11.58   11.59   11.69   11.71   11.71   11.74   11.76   11.78   11.79   
	     11.80   11.87   11.97   11.100  11.102  11.103  11.106  11.115  11.115  11.116  11.117  11.120  11.123  11.125  
	     11.138  11.140  11.140  11.142  11.144  11.145  11.146  11.147  11.147  11.149  11.151  11.152  11.152  11.154  
	     11.156  11.157  11.159  11.162  11.163  11.164  11.164  11.165  11.166  11.167  11.169  11.170  11.170  11.171  
	     11.175  11.177  11.178  11.179  11.180  11.180  11.182  11.193  11.195  11.195  11.197  11.198  11.199  11.201  
	     11.202  11.202  11.204  11.206  11.207  11.207  11.209  11.211  11.213  11.214  11.216  11.219  11.222  11.224  
	     11.226  11.232  11.233  11.234  11.235  11.235  11.237  11.239  11.247  11.248  11.249  11.250  11.251  11.259  
	     11.264  11.265  11.267  11.273  11.278  11.279  11.281  11.289  11.302  11.312  11.319  11.320  11.323  11.324  
	     11.325  11.330  11.331  11.331  11.332  11.333  11.334  11.341  11.344  11.345  11.349  11.355  11.358  11.358  
	     11.372  11.373  11.387  11.389  11.395  11.396  11.396  11.397  11.398  11.401  11.402  11.405  11.406  11.411  
	     11.420  11.425  11.426  11.430  11.431  11.433  11.438  11.444  12.52   12.53   12.54   12.56   12.59   12.60   
	     12.61   12.62   12.63   12.64   12.68   12.78   12.84   12.85   12.86   12.87   12.88   12.89   12.91   12.100  
	     12.110  12.113  12.132  12.136  12.137  12.138  12.139  12.141  12.143  12.144  12.152  12.153  12.154  12.155  
	     12.157  12.158  12.158  12.159  12.161  12.163  12.165  12.169  12.170  12.177  12.183  12.185  12.189  12.213  
	     12.215  12.216  12.226  12.233  12.234  12.237  12.249  12.250  12.254  12.256  12.261  12.262  12.279  12.280  
	     12.281  12.283  12.284  12.285  12.286  12.297  12.298  12.300  12.301  12.325  12.329  12.336  12.339  12.341  
	     12.347  12.353  12.355  12.356  12.357  12.358  12.360  12.361  12.362  12.363  12.364  12.365  13.6    13.7    
	     13.8    13.9    13.11   13.16   13.18   13.84   13.85   13.86   13.89   13.90   13.91   13.103  13.105  13.106  
	     13.108  13.109  13.111  13.113  13.115  13.117  13.119  13.123  13.129  13.137  13.143  
	PUPUUO.MAC;7  3.24    3.25    3.26    3.27    3.28    3.44    3.45    3.46    3.47    3.50    3.52    3.54    3.74    
	      4.13    4.15    4.17    4.18    4.19    4.19    4.20    4.24    4.27    4.28    4.29    4.43    4.44    4.45    
	      4.46    4.47    4.47    4.52    4.54    4.55    5.6     5.7     5.8     5.9     5.12    5.14    5.18    6.16    
	      6.21    6.22    6.23    6.46    6.54    6.56    6.57    9.54    9.56    
ABOR  	PUPDEF.MAC;11        6.31    
ABORT 	PUPDEF.MAC;11        6.31    
ABORTI	PUPSEQ.MAC;35        13.92   
AC    	PUPDEF.MAC;11        4.54    4.55    
ACCOUN	PUPDEF.MAC;11        5.50    
	PUPPRP.MAC;4  8.17    
ACCTX1	SMXACC.MAC;7  4.29    
ACTCHN	PUPSEQ.MAC;35        13.14   13.26#  13.26   13.31#  
AIC   	PSVLEF.MAC;33        6.15    
	PUPSEQ.MAC;35        13.15   
ALL   	PSVLEF.MAC;33        20.53   20.77   
APPEND	PUPDEF.MAC;11        4.5#    4.17    4.18    4.21    
AQUEU1	PUPSEQ.MAC;35        11.71#  11.72   
AQUEUE	PUPSEQ.MAC;35        4.108   4.116   11.52#  
AQUEUX	PUPSEQ.MAC;35        11.66   11.85#  
ARE   	PUPDEF.MAC;11        6.30    
AS    	PUPPRP.MAC;4  7.52    
ASCIZ 	PSVLEF.MAC;33        8.115   8.116   8.117   8.118   8.119   8.120   8.121   8.122   8.123   8.124   8.125   8.126   
	     8.127   8.128   8.129   8.130   8.131   8.132   8.133   8.134   8.135   8.136   8.137   8.138   8.139   8.140   
	     8.141   8.142   11.37   11.56   16.15   16.19   17.14   17.18   17.96   17.126  18.12   21.116  22.23   22.27   
	     23.33   23.40   23.41   23.42   23.43   23.44   23.45   23.46   23.47   23.48   23.99   23.127  23.147  23.165  
                                   28-Jul-82 17:31     Page 7.5

	     23.185  23.197  23.209  23.232  23.242  23.244  26.35   26.54   27.37   27.39   
	PUPDEF.MAC;11        4.47    4.48    4.49    4.50    4.51    4.52    4.53    4.55    4.56    4.61    4.65    
	PUPPRP.MAC;4  4.6     6.24    6.25    6.26    7.41    7.42    7.43    
	PUPSEQ.MAC;35        4.32    4.35    4.39    4.42    11.413  11.416  13.51   13.54   13.57   13.60   13.63   13.66   
	     13.83   13.131  
	PUPUUO.MAC;7  8.30    
	SMXACC.MAC;7  5.13    
ASGFRE	PUPSEQ.MAC;35        11.21   11.28   11.247# 
AT    	PSVLEF.MAC;33        7.5     
	PUPSEQ.MAC;35        11.399  11.403  13.87   13.147  
ATI   	PUPSEQ.MAC;35        13.17   
ATNVT 	PLFSUP.MAC;3  5.32    
ATPTY 	PLFSUP.MAC;3  5.27    
ATTEMP	PUPSEQ.MAC;35        11.403  
AUTH  	PUPDEF.MAC;11        5.35    
AUTHOR	PUPDEF.MAC;11        5.35    
AWAKEN	PSVLEF.MAC;33        7.21    
B     	PLFSUP.MAC;3  5.41    5.44    5.48    6.14    6.25    7.6     7.7     7.8     7.9     7.11    7.21    7.38    7.39    
	      7.40    7.41    7.46    7.56    7.57    8.6     8.7     8.8     8.9     8.10    8.11    8.18    8.23    8.29    
	PSQDEF.MAC;9  3.24#   
	PSVLEF.MAC;33        4.20    4.24    4.32    5.10    5.11    5.12    5.17    5.39    5.40    5.41    5.46    5.74    
	     5.75    5.78    5.85    5.88    5.103   5.104   5.106   5.108   5.137   5.138   5.139   5.146   6.11    6.14    
	     7.47    7.48    7.100   7.101   8.9     8.33    8.35    8.37    8.39    8.48    8.49    8.50    8.51    8.53    
	     8.55    8.58    8.97    8.99    8.100   8.104   8.109   8.150   8.156   8.158   9.10    9.16    9.21    9.23    
	     10.12   10.14   10.17   10.28   10.30   10.35   10.46   10.54   10.56   10.61   10.65   10.67   10.69   10.89   
	     10.92   10.95   10.107  10.119  10.121  10.132  10.139  10.141  10.149  10.155  10.170  10.171  10.174  10.177  
	     10.184  10.185  10.188  10.189  10.190  10.191  10.194  10.211  10.217  11.9    11.13   11.18   11.19   11.23   
	     11.31   11.31   11.37   11.51   11.53   11.56   11.62   11.66   11.68   11.71   11.73   11.74   11.76   11.77   
	     11.78   11.79   11.80   11.81   11.82   12.18   12.34   12.43   12.45   12.61   12.63   12.70   12.74   12.76   
	     12.82   12.84   12.93   12.95   12.102  12.104  12.111  12.113  12.115  12.117  12.119  12.120  12.121  12.126  
	     12.130  12.132  12.135  12.138  12.140  12.149  12.163  12.164  12.165  12.169  12.170  12.171  12.175  12.179  
	     12.190  12.192  12.199  12.201  12.207  12.209  12.211  12.213  12.215  12.217  12.223  12.224  12.225  12.228  
	     12.232  12.234  12.235  12.242  12.247  12.248  12.279  12.281  12.283  12.293  12.297  12.298  12.329  12.331  
	     12.340  12.380  13.9    13.11   13.34   13.42   13.49   13.68   13.76   13.78   13.79   13.86   13.87   13.96   
	     13.101  13.115  13.124  13.126  13.127  13.132  13.142  13.153  13.155  13.158  13.160  13.163  14.10   14.12   
	     14.21   14.28   14.29   14.34   14.53   15.17   15.26   15.27   15.28   15.28   15.35   15.38   15.39   15.42   
	     15.48   15.49   15.58   16.15   16.17   16.18   16.19   16.21   16.22   16.23   16.25   16.27   16.28   16.30   
	     16.40   16.46   16.47   16.48   16.49   16.50   16.52   16.54   16.55   16.56   16.61   16.63   16.77   16.78   
	     16.79   16.80   17.14   17.16   17.17   17.18   17.20   17.21   17.22   17.23   17.25   17.38   17.41   17.47   
	     17.51   17.54   17.60   17.64   17.65   17.66   17.67   17.70   17.89   17.91   17.94   17.95   17.96   17.97   
	     17.101  17.105  17.110  17.113  17.114  17.115  17.116  17.117  17.120  17.126  17.127  17.129  17.130  17.131  
	     17.132  18.12   18.26   18.33   18.39   19.8    19.10   19.13   19.14   19.15   19.18   19.19   19.20   20.13   
	     20.14   20.15   20.40   20.41   20.45   20.48   20.52   20.63   20.64   20.68   20.71   20.75   21.77   21.79   
	     21.81   21.86   21.88   21.103  21.106  21.111  21.113  21.116  21.123  22.11   22.12   22.14   22.15   22.17   
	     22.23   22.27   23.14   23.16   23.20   23.22   23.28   23.33   23.36   23.55   23.56   23.57   23.60   23.68   
	     23.69   23.70   23.73   23.86   23.87   23.88   23.91   23.103  23.105  23.106  23.114  23.130  23.132  23.133  
	     23.135  23.135  23.140  23.150  23.158  23.168  23.169  23.177  23.188  23.190  23.191  23.200  23.202  23.203  
	     23.212  23.214  23.215  23.225  23.235  23.237  23.245  24.9    24.12   24.16   24.17   24.18   24.19   24.23   
	     24.29   24.30   24.39   24.40   24.50   24.63   24.64   24.69   24.79   24.80   24.82   24.94   24.99   24.101  
	     24.102  24.105  24.110  24.119  24.121  24.123  24.141  24.145  24.146  24.147  24.148  24.152  24.158  24.159  
	     24.168  24.169  24.178  24.192  24.193  24.198  24.208  24.210  25.33   25.35   25.49   25.50   25.60   26.14   
	     26.17   26.18   26.19   26.20   26.23   26.24   26.25   26.27   26.28   26.35   27.37   27.39   27.46   27.55   
	     28.58   28.60   28.61   28.62   28.63   28.64   28.65   28.66   28.67   28.69   28.81   28.83   28.85   28.87   
                                   28-Jul-82 17:31     Page 7.6

	     28.88   28.90   28.92   28.101  28.105  28.111  28.114  28.117  28.121  28.125  28.130  28.139  28.143  28.146  
	     28.149  28.151  28.157  28.167  28.173  28.177  28.182  28.196  28.203  28.205  28.207  28.208  
	PUPDEF.MAC;11        3.14#   
	PUPPRP.MAC;4  3.22    3.26    3.27    3.39    3.42    3.51    4.26    4.38    4.39    4.41    5.13    5.23    5.26    
	      5.33    6.7     6.16    6.20    6.20    6.21    6.31    6.54    6.57    6.61    7.6     7.9     7.15    7.27    
	      7.33    7.37    7.37    7.38    7.51    7.59    8.6     8.16    8.18    8.19    8.20    8.30    8.31    8.33    
	      8.39    8.42    9.11    9.22    9.80    9.84    10.12   10.13   10.14   10.29   10.42   10.43   10.45   10.48   
	      10.52   11.12   11.13   11.14   11.29   11.37   12.13   12.14   12.15   12.30   12.38   12.50   
	PUPSEQ.MAC;35        4.29    4.32    4.35    4.39    4.42    4.48    4.103   4.104   4.105   4.105   4.106   4.107   
	     4.111   4.112   4.113   4.113   4.114   4.115   4.126   4.149   4.175   5.12    5.14    5.15    5.25    5.26    
	     5.30    5.32    5.66    5.94    5.95    5.96    5.99    5.100   5.108   7.14    7.15    7.18    7.19    7.19    
	     7.20    7.22    7.24    7.26    7.27    7.31    7.32    7.33    7.35    7.36    8.29    8.30    8.70    8.74    
	     8.80    8.91    8.115   9.12    9.16    9.17    9.33    9.46    10.24   10.34   10.56   10.63   10.71   10.89   
	     10.94   10.120  10.138  11.27   11.29   11.30   11.33   11.34   11.36   11.37   11.54   11.58   11.59   11.60   
	     11.61   11.63   11.64   11.67   11.75   11.76   11.77   11.78   11.86   11.98   11.99   11.101  11.104  11.108  
	     11.108  11.109  11.110  11.112  11.112  11.116  11.117  11.119  11.121  11.122  11.124  11.139  11.143  11.144  
	     11.145  11.158  11.160  11.161  11.161  11.162  11.167  11.168  11.169  11.175  11.176  11.194  11.199  11.200  
	     11.215  11.217  11.218  11.219  11.221  11.224  11.225  11.238  11.260  11.262  11.263  11.264  11.266  11.274  
	     11.276  11.277  11.278  11.280  11.323  11.327  11.329  11.336  11.339  11.340  11.344  11.351  11.352  11.359  
	     11.361  11.374  11.413  11.416  11.421  11.424  11.429  11.430  11.433  11.434  11.436  11.437  12.57   12.61   
	     12.64   12.65   12.67   12.68   12.114  12.116  12.133  12.135  12.139  12.140  12.176  12.184  12.186  12.188  
	     12.217  12.282  12.283  12.299  12.300  12.326  12.330  12.337  12.340  12.348  12.351  12.354  12.366  12.367  
	     13.10   13.14   13.19   13.71   13.72   13.75   13.76   13.77   13.78   13.82   13.83   13.104  13.106  13.107  
	     13.109  13.110  13.112  13.115  13.116  13.119  13.120  13.121  13.122  13.125  13.126  13.128  13.138  
	PUPUUO.MAC;7  4.53    4.55    5.17    5.18    6.17    6.24    6.25    6.26    6.30    6.31    6.32    6.45    6.57    
	      7.14    7.15    7.17    7.17    7.18    7.22    7.25    7.27    8.12    8.21    8.26    8.29    8.30    8.32    
	      9.5     9.6     9.11    9.13    9.14    9.20    9.22    9.25    9.27    9.28    
BE    	PSVLEF.MAC;33        7.50    
BECOME	PUPSEQ.MAC;35        9.69    
BEGLO1	PSVLEF.MAC;33        26.26   26.27#  
BEGLOG	PSVLEF.MAC;33        25.13   26.12#  
BINSR1	PUPPRP.MAC;4  13.31#  13.41   
BINSR2	PUPPRP.MAC;4  13.32#  13.47   
BINSRC	PUPPRP.MAC;4  12.16   13.20#  
BINSRG	PUPPRP.MAC;4  13.37   13.41#  
BINSRL	PUPPRP.MAC;4  13.34   13.36   13.45#  
BKTDON	PLFSUP.MAC;3  7.13    7.25    7.31    7.56#   
BKTOF0	PLFSUP.MAC;3  7.45#   7.51    
BKTOFF	PLFSUP.MAC;3  3.16    6.9     7.37#   
BKTON 	PLFSUP.MAC;3  3.16    6.19    7.5#    
BKTON0	PLFSUP.MAC;3  7.20#   7.26    
BLOCK 	SMXACC.MAC;7  6.3     6.4     
BNTACS	PUPSEQ.MAC;35        12.21   12.22   12.23   12.24   12.40   14.2    
BNTLCK	PSVLEF.MAC;33        3.37    7.6     7.9     7.60    7.63    7.65    
	PUPSEQ.MAC;35        4.16    12.47   
BNTLKR	PSVLEF.MAC;33        3.37    7.7     7.61    
	PUPSEQ.MAC;35        4.17    12.48   
BNTPDL	PUPSEQ.MAC;35        12.20   12.42   12.317  13.7    
BNTS2A	PUPSEQ.MAC;35        12.109  12.113# 12.120# 
BNTSRV	PSVLEF.MAC;33        4.50    
	PUPSEQ.MAC;35        12.18#  12.44   
BNTSTK	PUPSEQ.MAC;35        12.315  13.6    
BNTSV0	PUPSEQ.MAC;35        12.33#  12.35   
                                   28-Jul-82 17:31     Page 7.7

BNTSV1	PUPSEQ.MAC;35        12.27   12.34   12.51#  12.70#  
BNTSV2	PUPSEQ.MAC;35        12.55   12.71   12.98#  12.101# 12.112# 
BNTSV4	PUPSEQ.MAC;35        12.32#  12.38   
BNTSV5	PUPSEQ.MAC;35        12.30   12.40#  
BODY  	PUPDEF.MAC;11        5.44    
	PUPPRP.MAC;4  6.42    6.55    
BOUT  	PUPUUO.MAC;7  6.55    
BREKSQ	PUPSEQ.MAC;35        12.271  12.324# 12.369# 12.370# 
BRKPUP	PUPSEQ.MAC;35        12.328  12.338  12.352  12.366  12.373  
BROK  	PSQDEF.MAC;9  3.72#   
	PUPSEQ.MAC;35        12.53   
BROKEN	PUPSEQ.MAC;35        9.37    
BUFFER	PUPSEQ.MAC;35        5.27    11.172  11.229  
BUT   	PSVLEF.MAC;33        7.50    
	PUPSEQ.MAC;35        3.63    
BY    	PSVLEF.MAC;33        7.65    20.77   
	PUPSEQ.MAC;35        11.403  
BYTCNT	PSVLEF.MAC;33        11.74   12.297  16.27   17.43   17.44   17.49   17.116  29.12   
BYTE  	PUPDEF.MAC;11        5.36    5.36    
	PUPPRP.MAC;4  4.37    4.40    
BYTSIZ	PSVLEF.MAC;33        13.127  13.160  17.55   24.27   24.53   24.71   24.97   24.156  24.182  24.200  29.11   
C     	PLFSUP.MAC;3  5.42    5.45    5.47    6.15    7.5     7.11    7.12    7.16    7.17    7.18    7.19    7.20    7.21    
	      7.22    7.23    7.26    7.27    7.28    7.29    7.30    7.37    7.45    7.46    7.47    7.50    7.51    7.52    
	      7.53    7.59    8.10    8.12    8.13    8.18    8.19    8.20    8.21    8.22    8.30    
	PSQDEF.MAC;9  3.25#   
	PSVLEF.MAC;33        4.33    5.8     5.17    5.18    5.19    5.26    5.29    5.37    5.46    5.47    5.48    5.55    
	     5.58    5.69    5.78    5.79    5.87    5.99    5.108   5.109   5.114   5.115   5.123   5.132   5.140   5.141   
	     5.143   5.145   5.152   5.154   5.156   5.158   6.40    6.48    6.55    7.37    7.38    7.39    7.40    7.42    
	     7.92    7.93    7.95    7.100   7.103   8.9     8.10    8.30    8.31    8.40    8.47    8.51    8.52    8.57    
	     8.100   9.13    9.14    9.15    9.17    10.52   10.58   10.59   10.62   10.114  10.116  10.132  10.150  10.156  
	     10.225  11.13   11.18   11.31   11.41   11.57   11.62   11.83   12.21   12.22   12.24   12.26   12.28   12.30   
	     12.32   12.34   12.35   12.42   12.43   12.44   12.46   12.60   12.61   12.62   12.64   12.70   12.73   12.74   
	     12.75   12.77   12.81   12.82   12.83   12.85   12.92   12.93   12.94   12.96   12.101  12.102  12.103  12.105  
	     12.127  12.146  12.176  12.189  12.190  12.191  12.193  12.198  12.199  12.200  12.202  12.229  12.239  12.284  
	     12.313  12.320  12.332  12.381  12.381  12.383  12.383  12.384  12.386  13.35   13.116  13.120  13.121  13.122  
	     13.125  13.130  13.131  13.143  13.147  13.148  13.150  13.151  13.152  13.154  13.162  14.11   14.13   14.16   
	     14.17   14.18   14.20   14.22   14.22   14.24   14.25   14.27   14.33   14.38   14.39   14.45   14.46   14.47   
	     14.52   15.9    15.13   15.18   15.19   16.11   16.17   16.26   16.31   16.34   16.35   16.36   16.37   16.38   
	     16.41   16.51   16.53   16.54   16.57   16.60   16.63   16.64   17.10   17.16   17.26   17.27   17.36   17.40   
	     17.41   17.43   17.44   17.45   17.48   17.49   17.55   17.56   17.59   17.68   17.71   17.78   17.92   17.100  
	     17.112  17.114  17.121  18.8    18.14   18.17   18.22   18.32   18.34   19.21   20.16   20.47   20.48   20.70   
	     20.71   20.76   21.69   21.70   21.85   21.89   21.91   21.96   21.117  21.123  21.129  22.9    22.11   22.14   
	     23.15   23.21   23.35   23.82   23.89   23.90   23.91   23.93   23.102  23.104  23.106  23.110  23.115  23.118  
	     23.129  23.131  23.133  23.137  23.141  23.149  23.151  23.155  23.159  23.167  23.169  23.171  23.174  23.178  
	     23.187  23.189  23.191  23.199  23.201  23.203  23.211  23.213  23.215  23.223  23.226  23.234  23.236  23.238  
	     23.248  24.9    24.13   24.14   24.22   24.27   24.28   24.31   24.32   24.41   24.42   24.49   24.55   24.58   
	     24.61   24.62   24.64   24.66   24.70   24.71   24.71   24.72   24.73   24.75   24.81   24.96   24.97   24.98   
	     24.103  24.121  24.142  24.143  24.151  24.156  24.157  24.160  24.161  24.170  24.171  24.179  24.184  24.187  
	     24.190  24.191  24.193  24.195  24.199  24.200  24.200  24.201  24.202  24.204  24.209  25.26   25.27   25.30   
	     25.31   25.32   25.33   25.35   25.47   25.51   25.61   26.15   26.21   26.37   26.39   26.56   27.35   27.36   
	     27.41   27.43   27.45   27.48   27.56   28.102  28.106  28.126  28.134  28.137  28.150  28.152  28.155  28.161  
	     28.181  28.202  28.204  28.205  28.206  28.207  
	PUPDEF.MAC;11        3.15#   
                                   28-Jul-82 17:31     Page 7.8

	PUPPRP.MAC;4  3.32    3.33    3.35    3.37    3.44    3.48    3.49    3.56    3.57    4.27    4.35    5.7     5.14    
	      5.34    6.8     6.32    6.42    6.55    7.16    7.24    7.53    7.60    8.7     8.13    8.27    9.15    9.16    
	      9.19    9.20    9.81    10.28   11.16   11.17   11.18   11.19   11.21   11.22   11.25   11.26   11.28   11.29   
	      11.33   11.36   11.37   12.16   12.33   12.34   12.36   12.37   12.39   12.44   13.21   13.22   13.23   13.23   
	      13.24   
	PUPSEQ.MAC;35        4.21    4.23    4.29    4.37    4.59    4.102   4.127   4.134   4.135   4.145   4.146   4.150   
	     4.154   4.155   5.56    5.57    7.10    7.33    7.34    7.35    7.39    8.71    8.72    8.75    8.76    10.123  
	     10.124  11.20   11.25   11.31   11.55   11.60   11.65   11.72   11.74   11.80   11.81   11.85   11.95   11.101  
	     11.102  11.103  11.106  11.107  11.107  11.109  11.110  11.127  11.322  11.346  11.347  11.348  11.349  11.356  
	     11.427  12.69   12.145  12.146  12.147  12.149  12.150  12.224  12.297  12.302  12.327  12.331  12.332  12.333  
	     12.344  12.349  12.350  13.20   
	PUPUUO.MAC;7  6.18    6.44    7.5     7.10    7.11    7.15    7.16    7.18    8.5     8.14    8.14    8.15    8.21    
	      8.27    8.33    8.42    9.7     9.8     9.15    9.16    9.17    9.29    9.36    9.42    
CALL  	PLFSUP.MAC;3  9.32    9.33    9.54    9.55    10.17   10.18   10.28   10.31   10.34   11.18   11.29   11.45   13.11   
	      13.42   14.30   14.43   15.19   
	PUPDEF.MAC;11        4.78#   
	PUPSEQ.MAC;35        3.79    3.83    
CALLF 	PSQDEF.MAC;9  3.41#   
CAN   	PUPSEQ.MAC;35        11.443  
CD%DAC	PLFSUP.MAC;3  12.39   13.41   
CD%DGP	PLFSUP.MAC;3  12.35   12.45   
CD%DPT	PLFSUP.MAC;3  12.53   
CD%PSW	PLFSUP.MAC;3  11.44   12.27   12.48   
CD%UGP	PLFSUP.MAC;3  12.31   12.43   
CDAT  	PUPDEF.MAC;11        5.39    
CFGRP 	PLFSUP.MAC;3  14.7    
	PUPSEQ.MAC;35        11.316  
CFIBF 	PUPUUO.MAC;7  4.16    
CFORK 	PUPSEQ.MAC;35        11.313  
	SMXACC.MAC;7  5.20    
CH    	PUPSEQ.MAC;35        13.25   13.26   13.27   
CHAIN 	PUPSEQ.MAC;35        5.27    11.172  11.229  
CHFDB 	PLFSUP.MAC;3  5.46    8.31    
	PSVLEF.MAC;33        17.52   17.57   28.209  
CHKAC 	PLFSUP.MAC;3  15.46   15.53   
	PSVLEF.MAC;33        13.102  
CHKACC	PSVLEF.MAC;33        12.286  13.67#  
CHKACF	PSVLEF.MAC;33        13.85   13.94   13.96#  
CHKAL1	PLFSUP.MAC;3  15.47   15.52#  
CHKALL	PLFSUP.MAC;3  11.18   14.30   14.43   15.19   15.35#  
CHKBLK	PSVLEF.MAC;33        13.69   13.71   13.73   13.75   13.79   13.87   13.101  13.108  
CHKCON	PSVLEF.MAC;33        10.124  10.204# 10.224# 
CHKDIR	PLFSUP.MAC;3  10.28   10.42#  
CHKDN1	PLFSUP.MAC;3  11.19   15.22#  15.28   
CHKDNE	PLFSUP.MAC;3  11.20   14.32   14.45   15.21#  
CHKDR 	PLFSUP.MAC;3  3.18    14.36#  
CHKDV0	PSVLEF.MAC;33        12.398  12.403# 
CHKDV1	PSVLEF.MAC;33        12.399  12.406# 
CHKDV2	PSVLEF.MAC;33        12.400  12.414# 
CHKDV3	PSVLEF.MAC;33        12.401  12.412# 
CHKDVD	PSVLEF.MAC;33        12.268  12.398# 
CHKEV0	PSVLEF.MAC;33        12.345  12.351# 
CHKEV1	PSVLEF.MAC;33        12.346  12.358# 12.366  
                                   28-Jul-82 17:31     Page 7.9

CHKEV2	PSVLEF.MAC;33        12.347  12.366# 
CHKEV3	PSVLEF.MAC;33        12.348  12.395# 
CHKEVD	PSVLEF.MAC;33        12.263  12.345# 
CHKF  	PLFSUP.MAC;3  14.31   14.44   15.20   15.26#  
CHKGRP	PLFSUP.MAC;3  10.31   11.11#  
CHKHD1	PSVLEF.MAC;33        22.10   22.13   22.22#  
CHKHD2	PSVLEF.MAC;33        22.16   22.26#  
CHKHDL	PSVLEF.MAC;33        11.14   11.32   15.10   16.12   17.11   18.9    21.71   22.9#   
CHKJFN	PLFSUP.MAC;3  11.11   14.25   14.36   15.8    15.10   15.15   15.44   16.17   
CHKPSW	PLFSUP.MAC;3  10.34   11.27#  
CHKRD 	PLFSUP.MAC;3  3.18    14.25#  
CHKV2A	PSVLEF.MAC;33        12.369  12.375# 
CHKVE1	PSVLEF.MAC;33        12.267  12.270# 
CHKVEN	PSVLEF.MAC;33        11.27   11.42   12.279# 
CHKVER	PSVLEF.MAC;33        11.61   12.262# 12.295# 12.304# 21.122  
CHKVF1	PSVLEF.MAC;33        12.264  12.269  12.273  12.324# 
CHKVRF	PSVLEF.MAC;33        12.287  12.292  12.312# 12.322# 12.325# 
CHKVRX	PSVLEF.MAC;33        12.305  12.328# 
CHKWR 	PLFSUP.MAC;3  3.18    15.10#  
CHKWRD	PLFSUP.MAC;3  3.18    15.8#   
CHNTAB	PSVLEF.MAC;33        6.7     6.9     6.11    
	PUPSEQ.MAC;35        13.10   13.27   13.32#  13.42   
CIS   	PSVLEF.MAC;33        7.11    
CK%JFN	PLFSUP.MAC;3  15.45   
	PSVLEF.MAC;33        13.100  
CKAX4 	PLFSUP.MAC;3  15.52   
CLAIMS	PUPSEQ.MAC;35        11.375  
CLEANF	PSVLEF.MAC;33        7.92#   7.108#  7.112#  
	PUPSEQ.MAC;35        12.107  
CLNF1 	PSVLEF.MAC;33        7.93#   7.95    
CLNF2 	PSVLEF.MAC;33        7.94    7.100#  
CLOBBE	PSVLEF.MAC;33        7.50    
CLOS  	PSQDEF.MAC;9  3.69#   
	PUPSEQ.MAC;35        10.92   
CLOSE 	PSVLEF.MAC;33        15.15   
	PUPSEQ.MAC;35        13.145  
CLOSF 	PSVLEF.MAC;33        7.108   14.50   15.56   27.58   
	PUPSEQ.MAC;35        12.111  13.144  
CLOSIN	PUPSEQ.MAC;35        12.101  12.112  
CLOSLF	PSVLEF.MAC;33        7.75    15.7#   
CLSX1 	PSVLEF.MAC;33        7.107   
CMPLEN	PSVLEF.MAC;33        5.99#   9.11    
CNAM  	PUPDEF.MAC;11        5.37    
CNDIR 	PLFSUP.MAC;3  9.23    
	PSVLEF.MAC;33        10.37   10.212  10.218  
CNDIX1	PLFSUP.MAC;3  9.6#    10.35   
CNDIX3	PLFSUP.MAC;3  9.7#    10.29   
CNDIX4	PLFSUP.MAC;3  9.8#    
CNDIX5	PLFSUP.MAC;3  9.9#    
CODE  	PUPDEF.MAC;11        4.58    
COMM  	PUPDEF.MAC;11        6.25    
COMMAN	PUPDEF.MAC;11        6.24    
COMMEN	PSVLEF.MAC;33        21.16   
                                   28-Jul-82 17:31     Page 7.10

	PUPDEF.MAC;11        6.25    
COMMON	PUPDEF.MAC;11        3.4     
COMSEQ	PUPSEQ.MAC;35        8.81    8.92    9.12#   
CONIN1	PUPSEQ.MAC;35        4.83#   4.85    
CONIN2	PUPSEQ.MAC;35        4.81    4.84    4.89#   
CONIN5	PUPSEQ.MAC;35        4.144   4.146   4.164   4.174#  
CONIN6	PUPSEQ.MAC;35        4.133   4.139#  
CONINI	PUPSEQ.MAC;35        4.80#   12.287  
CONNEC	PSVLEF.MAC;33        7.21    7.65    8.38    10.151  10.157  11.8    12.337  15.8    16.10   17.9    18.7    19.5    
	     20.29   20.53   20.53   20.77   20.77   21.68   
	PUPDEF.MAC;11        5.37    5.38    
	PUPPRP.MAC;4  5.6     
	PUPSEQ.MAC;35        4.166   4.169   8.118   9.37    9.49    9.58    9.69    10.157  11.375  12.70   12.92   12.101  
	     12.292  12.370  
CONNFK	PSVLEF.MAC;33        3.35    6.5     
	PUPSEQ.MAC;35        10.137  11.320  11.372  11.379  14.13   
CONNT 	PSQDEF.MAC;9  3.120#  
	PSVLEF.MAC;33        19.14   
	PUPSEQ.MAC;35        4.157   4.160   
CONNUM	PLFSUP.MAC;3  3.13    15.38   
	PSVLEF.MAC;33        3.35    7.96    10.77   10.101  10.114  10.127  10.149  10.155  12.247  13.72   29.15   
CONTAB	PSVLEF.MAC;33        3.35    20.45   20.68   
	PUPSEQ.MAC;35        4.13    4.14    4.14    4.15    4.83    4.90    12.33   12.118  12.203  12.265  12.278  12.309  
	     13.139  14.6    
CONTRO	PUPSEQ.MAC;35        8.65    8.106   8.131   9.63    9.67    9.69    10.30   14.16   
CONVEN	PUPDEF.MAC;11        5.42    
	PUPPRP.MAC;4  6.18    6.19    
CPOPJ 	PLFSUP.MAC;3  5.15    5.33    6.12    6.13    6.22    6.24    6.41    8.12    13.65   15.48   
	PSVLEF.MAC;33        12.39   12.41#  12.57   
	PUPPRP.MAC;4  10.16   10.19   10.28   11.35   13.42   13.45   
	PUPUUO.MAC;7  10.61#  
CPSW  	PUPDEF.MAC;11        5.38    
CPYDRN	PLFSUP.MAC;3  3.16    13.6#   
CPYPR0	PSVLEF.MAC;33        23.89#  23.92   
CPYPR1	PSVLEF.MAC;33        23.90   23.93#  
CPYPRP	PSVLEF.MAC;33        23.82#  23.100  23.128  23.148  23.166  23.186  23.198  23.210  23.233  23.246  
CR    	PUPDEF.MAC;11        5.9#    
	PUPUUO.MAC;7  3.46    
CRASHE	PSVLEF.MAC;33        7.5#    
	PUPSEQ.MAC;35        13.92   13.96   
CRASHX	PUPSEQ.MAC;35        13.50   13.53   13.56   13.59   13.62   13.65   13.69#  13.72   13.130  
CREATE	PUPSEQ.MAC;35        4.166   
CREATI	PUPDEF.MAC;11        5.39    
	PUPPRP.MAC;4  5.25    
CRSTIM	PUPSEQ.MAC;35        13.89   13.90   13.100  
CTRLTB	PUPSEQ.MAC;35        8.132   8.143#  
CURPAG	PSVLEF.MAC;33        15.38   15.44   24.106  24.108  24.112  24.132  
CVSKT 	PUPSEQ.MAC;35        4.124   12.342  
CX    	PLFSUP.MAC;3  13.33   15.36   15.38   
	PSQDEF.MAC;9  3.29#   
	PSVLEF.MAC;33        4.47    6.5     7.20    7.24    7.45    7.48    7.50    7.64    7.96    7.97    7.101   8.37    
	     10.32   10.41   10.52   10.74   10.77   10.101  10.114  10.127  10.148  10.149  10.150  10.154  10.155  10.156  
	     10.207  11.7    11.67   12.247  12.336  13.42   13.70   13.72   15.7    16.9    17.7    18.6    19.4    20.28   
                                   28-Jul-82 17:31     Page 7.11

	     20.38   20.39   20.39   20.40   20.43   20.50   20.51   20.52   20.61   20.62   20.62   20.63   20.66   20.73   
	     20.74   20.75   20.76   21.67   21.127  22.12   
	PUPSEQ.MAC;35        4.82    4.83    4.85    4.89    4.89    4.90    4.103   4.111   4.129   4.131   4.139   4.158   
	     4.161   4.167   4.168   8.117   8.123   9.36    9.48    9.57    9.68    10.137  10.148  10.156  11.262  11.265  
	     11.276  11.279  11.289  11.302  11.320  11.372  11.374  11.379  12.32   12.33   12.35   12.57   12.59   12.62   
	     12.69   12.75   12.78   12.82   12.84   12.91   12.100  12.102  12.103  12.104  12.105  12.118  12.202  12.203  
	     12.205  12.255  12.256  12.258  12.264  12.265  12.267  12.274  12.274  12.275  12.278  12.280  12.284  12.301  
	     12.302  12.305  12.309  13.136  13.139  13.141  
D     	PSQDEF.MAC;9  3.26#   
	PSVLEF.MAC;33        4.17    4.32    4.36    5.9     5.16    5.20    5.23    5.25    5.28    5.38    5.45    5.49    
	     5.52    5.54    5.57    5.70    5.74    5.76    5.77    5.80    5.82    5.83    5.84    5.86    5.100   5.109   
	     5.110   5.113   5.115   5.116   5.119   5.122   5.133   5.146   5.147   5.149   5.151   5.152   5.153   5.157   
	     6.41    6.45    6.50    6.52    8.25    8.28    8.29    8.30    8.32    12.19   12.36   12.39   12.57   12.71   
	     12.303  12.304  12.324  12.325  12.333  12.335  12.337  14.13   14.15   14.25   16.31   16.35   16.38   16.42   
	     16.44   16.45   16.48   16.50   16.51   16.59   16.64   16.65   17.21   17.28   17.30   17.34   17.62   17.63   
	     17.65   17.67   17.68   17.69   17.115  17.117  21.89   21.90   23.252  23.253  23.256  24.36   24.45   24.49   
	     24.50   24.52   24.53   24.53   24.54   24.165  24.174  24.178  24.179  24.181  24.182  24.182  24.183  25.31   
	PUPDEF.MAC;11        3.16#   
	PUPPRP.MAC;4  3.51    3.52    3.54    6.34    6.35    6.36    6.37    6.38    6.40    6.43    6.47    6.48    6.49    
	      6.49    6.50    6.50    6.51    6.52    6.53    6.54    6.56    6.57    6.60    6.61    8.11    8.21    10.15   
	      10.16   10.17   10.18   10.19   10.21   10.22   10.23   10.24   10.27   10.29   10.30   11.15   11.30   11.34   
	      11.35   12.38   12.39   12.40   12.41   12.42   12.44   12.46   12.49   13.26   13.26   13.28   
	PUPSEQ.MAC;35        7.11    7.12    7.29    7.34    7.38    11.52   11.64   11.65   11.66   11.67   11.77   11.81   
	     11.88   11.96   11.99   11.113  11.121  11.123  11.126  11.321  11.325  11.428  11.437  12.148  12.149  
	PUPUUO.MAC;7  4.44    4.51    4.52    6.19    6.41    6.42    6.43    7.6     7.7     7.8     7.11    7.16    7.19    
	      7.20    7.21    7.24    7.30    8.29    8.32    9.27    
DATA  	PUPSEQ.MAC;35        12.370  
DATE  	PUPDEF.MAC;11        5.39    5.45    5.54    
	PUPPRP.MAC;4  5.25    7.8     8.41    
DATERR	PUPSEQ.MAC;35        13.34   13.53#  
DEBRK 	PSVLEF.MAC;33        6.68    6.71    
	PUPSEQ.MAC;35        12.210  
DEBUGF	PSVLEF.MAC;33        4.14    4.27    4.37    7.23    7.43    16.7    17.8    21.65   26.41   27.38   
	PUPDEF.MAC;11        3.28#   
	PUPSEQ.MAC;35        3.55    3.73    8.67    
	PUPUUO.MAC;7  3.61    3.75    
DEF   	PUPDEF.MAC;11        4.5     4.6#    4.6     4.8     4.10    
DEFINE	PLFSUP.MAC;3  3.30    3.37    
	PSQDEF.MAC;9  3.144   3.145   
	PSVLEF.MAC;33        7.69    
	PUPDEF.MAC;11        3.40    3.41    3.42    3.43    3.47    3.48    3.49    3.50    3.51    4.5     4.6     4.8     
	     4.9     4.14    4.47    4.48    4.49    4.50    4.51    4.52    4.53    4.54    4.58    4.63    4.69    4.73    
	     5.34    5.60    6.18    6.43    6.47    
	PUPPRP.MAC;4  4.4     
	PUPSEQ.MAC;35        13.25   
DEFINI	PUPDEF.MAC;11        3.4     
DEFNTF	PSQDEF.MAC;9  3.42#   
	PUPSEQ.MAC;35        12.28   12.37   12.43   
DEL   	PUPDEF.MAC;11        5.12#   
DELE  	PUPDEF.MAC;11        6.32    
DELEL1	PSVLEF.MAC;33        18.16   18.38#  
DELELF	PSVLEF.MAC;33        7.76    18.6#   18.7#   
DELETE	PUPDEF.MAC;11        6.32    
                                   28-Jul-82 17:31     Page 7.12

DELF  	PSVLEF.MAC;33        18.21   
DESTRO	PUPSEQ.MAC;35        10.45   
DEVI  	PUPDEF.MAC;11        5.40    
DEVICE	PUPDEF.MAC;11        5.40    
DIR   	PUPDEF.MAC;11        6.28    
	PUPSEQ.MAC;35        3.68    
DIRE  	PUPDEF.MAC;11        5.41    
DIRECT	PUPDEF.MAC;11        5.41    6.28    
	PUPPRP.MAC;4  7.52    
DIRST 	PLFSUP.MAC;3  10.45   13.10   
	PSVLEF.MAC;33        23.109  28.159  
	PUPUUO.MAC;7  9.50    9.55    
	SMXACC.MAC;7  3.38    4.23    
DISCAR	PUPSEQ.MAC;35        12.251  
DISMS 	PSVLEF.MAC;33        4.8     4.49    6.46    
	PUPSEQ.MAC;35        5.18    8.42    10.147  11.150  11.205  12.162  
	PUPUUO.MAC;7  4.14    
	SMXACC.MAC;7  5.22    5.71    
DISP  	PUPDEF.MAC;11        4.14    4.17    4.18    4.18    
	PUPSEQ.MAC;35        13.25   13.28   
DLLY  	PSQDEF.MAC;9  3.71#   
	PUPSEQ.MAC;35        10.53   12.87   
DMPLO1	PSVLEF.MAC;33        26.61   27.35#  
DMPLO2	PSVLEF.MAC;33        27.36#  27.42   
DMPLO3	PSVLEF.MAC;33        27.44   27.54   27.69#  
DMPLO4	PSVLEF.MAC;33        27.53   27.62#  
DMPLO5	PSVLEF.MAC;33        27.33   27.63#  27.72   
DMPLOG	PSVLEF.MAC;33        4.53    27.32#  
	PUPSEQ.MAC;35        13.93   13.97   13.142  
DOATTR	PSVLEF.MAC;33        12.153  12.163# 12.218  
DOBE  	PSVLEF.MAC;33        26.43   26.53   
	PUPUUO.MAC;7  3.76    
DOLUUO	PUPUUO.MAC;7  3.19    3.24#   
DQUEUE	PUPSEQ.MAC;35        8.31    11.191# 
DROPPI	PUPSEQ.MAC;35        9.58    
DSTR  	PSQDEF.MAC;9  3.73#   
	PSVLEF.MAC;33        20.47   20.70   
	PUPSEQ.MAC;35        9.38    10.39   10.153  12.54   12.88   12.233  
DTYPE 	PUPDEF.MAC;11        4.50#   
	PUPPRP.MAC;4  3.43    
	PUPSEQ.MAC;35        5.27    9.49    9.58    9.69    10.45   12.292  
DUE   	SMXACC.MAC;7  5.64    
DUPLIC	PUPSEQ.MAC;35        9.58    
EIR   	PSVLEF.MAC;33        6.13    
	PUPSEQ.MAC;35        3.87    13.13   
ELOG  	PSVLEF.MAC;33        7.5     7.50    12.295  
	PUPDEF.MAC;11        4.48#   
	PUPSEQ.MAC;35        4.46    4.50    8.118   10.157  11.172  11.229  11.375  11.399  11.403  12.70   12.112  12.120  
	     12.369  13.92   13.96   13.145  
	SMXACC.MAC;7  5.64    
ELSLOC	PSQDEF.MAC;9  3.125#  3.133   
EMPTY 	PSVLEF.MAC;33        7.21    
ENABLF	PUPDEF.MAC;11        3.29#   
                                   28-Jul-82 17:31     Page 7.13

END   	PLFDEF.MAC;5  1.73    
	PLFSUP.MAC;3  16.20   
	PSQDEF.MAC;9  3.156   
	PSVLEF.MAC;33        29.24   
	PUPDEF.MAC;11        5.42    6.24    6.58    
	PUPPRP.MAC;4  6.18    6.19    13.50   
	PUPSEQ.MAC;35        14.30   
	PUPUUO.MAC;7  10.64   
	SMXACC.MAC;7  6.5     
ENDLO2	PSVLEF.MAC;33        26.44   26.56#  
ENDLO3	PSVLEF.MAC;33        26.46   26.51   26.58#  
ENDLOG	PSVLEF.MAC;33        25.14   26.35#  
EOC   	PUPDEF.MAC;11        6.24    
EOCF  	PUPDEF.MAC;11        4.58    4.59    
EOL   	PUPDEF.MAC;11        5.13#   
	PUPUUO.MAC;7  3.47    
EOLC  	PUPDEF.MAC;11        5.42    
EOLTAB	PUPPRP.MAC;4  6.16    6.24#   
EPCAP 	PUPSEQ.MAC;35        4.30    4.60    
ERACDN	PLFDEF.MAC;5  1.52#   
ERBDHN	PLFDEF.MAC;5  1.62#   
	PSVLEF.MAC;33        22.22   
ERBDLF	PLFDEF.MAC;5  1.61#   
	PSVLEF.MAC;33        8.8     
ERBKLF	PLFDEF.MAC;5  1.60#   
	PSVLEF.MAC;33        22.26   
ERCAL 	PLFSUP.MAC;3  12.52   
	PSQDEF.MAC;9  3.148   3.150#  
	PSVLEF.MAC;33        4.35    10.110  13.103  
	PUPSEQ.MAC;35        4.46    4.50    4.125   4.137   4.152   12.168  12.211  12.343  13.107  
	SMXACC.MAC;7  5.28    
ERCONN	PLFDEF.MAC;5  1.58#   
	PSVLEF.MAC;33        10.99   10.112  
ERCONP	PLFDEF.MAC;5  1.59#   
	PSVLEF.MAC;33        10.125  
ERFILS	PLFDEF.MAC;5  1.57#   
	PSVLEF.MAC;33        10.23   
ERFLBZ	PLFDEF.MAC;5  1.53#   
	PSVLEF.MAC;33        11.36   
ERILRD	PLFDEF.MAC;5  1.63#   
	PSVLEF.MAC;33        16.14   16.95   
ERILVR	PLFDEF.MAC;5  1.51#   
	PSVLEF.MAC;33        12.352  12.387  
ERILWR	PLFDEF.MAC;5  1.64#   
	PSVLEF.MAC;33        17.13   17.79   
ERJMP 	PLFSUP.MAC;3  5.15    5.33    6.22    6.41    8.38    13.65   15.47   
	PSVLEF.MAC;33        10.48   
	PUPUUO.MAC;7  9.56    
ERNMML	PLFDEF.MAC;5  1.50#   
	PSVLEF.MAC;33        11.55   21.115  
ERNTDL	PLFDEF.MAC;5  1.54#   
	PSVLEF.MAC;33        18.11   18.38   
ERRAC 	PLFSUP.MAC;3  3.30    3.32    
                                   28-Jul-82 17:31     Page 7.14

ERRALC	PSQDEF.MAC;9  3.106#  
ERRBRO	PSQDEF.MAC;9  3.105#  
	PUPSEQ.MAC;35        10.26   
ERRDES	PSQDEF.MAC;9  3.107#  
	PUPSEQ.MAC;35        9.40    10.41   10.46   10.65   12.226  
ERRLF 	PSVLEF.MAC;33        8.11    8.25#   8.38#   10.133  11.25   11.38   11.58   11.63   16.16   16.96   17.15   17.80   
	     18.13   18.27   18.40   21.118  21.124  22.24   22.28   23.34   
ERROR 	PLFSUP.MAC;3  3.30    3.31    15.53   
	PSVLEF.MAC;33        7.108#  7.112#  8.38    12.295  14.50   14.56   
	PUPDEF.MAC;11        4.53#   
	PUPSEQ.MAC;35        4.166   12.369# 13.121  
ERRTIM	PSQDEF.MAC;9  3.108#  
	PUPSEQ.MAC;35        8.45    
ERSTR 	PUPUUO.MAC;7  8.28    
ERUSRN	PLFDEF.MAC;5  1.55#   
	PSVLEF.MAC;33        10.20   10.50   
ERUSRP	PLFDEF.MAC;5  1.56#   
	PSVLEF.MAC;33        10.38   10.71   
ESHLOC	PSQDEF.MAC;9  3.127#  3.136   
EXCEPT	PUPDEF.MAC;11        6.37    
EXP   	PUPUUO.MAC;7  3.37    
EXPAND	PUPDEF.MAC;11        4.8#    
	PUPUUO.MAC;7  3.36    
EXTERN	PLFSUP.MAC;3  3.13    
	PSVLEF.MAC;33        3.35    3.36    3.37    
	PUPSEQ.MAC;35        3.7     
	PUPUUO.MAC;7  3.36    
F     	PSQDEF.MAC;9  3.21#   
	PSVLEF.MAC;33        4.13    4.14    4.27    4.37    7.23    7.43    12.16   12.40   12.47   12.51   12.53   12.58   
	     12.65   12.69   12.72   12.78   12.80   12.86   12.91   12.97   12.98   12.100  12.106  12.122  12.124  12.133  
	     12.136  12.143  12.150  12.166  12.172  12.180  12.186  12.188  12.194  12.195  12.197  12.203  12.221  12.226  
	     12.236  12.243  12.245  12.250  12.266  12.351  16.7    17.8    17.29   17.42   17.46   17.107  17.125  21.65   
	     25.8    25.11   26.41   26.45   27.38   
	PUPDEF.MAC;11        3.11#   
	PUPPRP.MAC;4  3.53    5.15    5.32    6.6     6.33    6.44    7.61    8.8     10.26   
	PUPSEQ.MAC;35        3.55    3.73    5.101   5.110   6.14    6.15    6.30    8.67    10.122  10.126  12.28   12.37   
	     12.43   12.150  12.172  
	PUPUUO.MAC;7  3.61    3.67    3.75    4.25    8.13    
FAILED	PSVLEF.MAC;33        12.322  12.325  15.15   15.34   
	PUPSEQ.MAC;35        4.46    4.50    4.166   
FAILUR	PLFSUP.MAC;3  15.53#  
	PUPSEQ.MAC;35        12.239  
FATAL 	PUPSEQ.MAC;35        13.121  
FBOUT 	PUPUUO.MAC;7  6.36    6.54#   7.26    8.22    9.12    9.21    9.26    
FDBBLK	PSVLEF.MAC;33        28.106  28.110  28.113  28.116  28.120  28.145  28.157  28.197  29.2    
FF    	PUPDEF.MAC;11        5.11#   
FFORK 	SMXACC.MAC;7  5.35    
FILACT	PSVLEF.MAC;33        12.424  13.41   13.45   
FILDEV	PSVLEF.MAC;33        12.9    12.44   12.420  13.25   13.26   
FILDIR	PSVLEF.MAC;33        12.10   12.62   12.246  12.330  12.421  13.29   13.30   
FILE  	PSVLEF.MAC;33        12.304  12.325  
	PUPDEF.MAC;11        6.23    6.23    
FILENA	PUPDEF.MAC;11        5.47    
                                   28-Jul-82 17:31     Page 7.15

FILES 	PUPPRP.MAC;4  7.52    
FILET 	PSQDEF.MAC;9  3.121#  
	PSVLEF.MAC;33        19.12   
	PUPSEQ.MAC;35        4.157   4.160   
FILEXT	PSVLEF.MAC;33        12.12   12.83   12.103  12.200  12.332  12.423  13.35   
FILFLG	PSVLEF.MAC;33        12.14   12.165  12.171  12.426  13.14   
FILNAM	PSVLEF.MAC;33        12.11   12.75   12.94   12.191  12.331  12.422  13.34   
FILPRT	PSVLEF.MAC;33        12.15   12.179  12.425  13.38   
FILQUO	PUPPRP.MAC;4  6.49    6.65#   
FILVER	PSVLEF.MAC;33        12.13   12.121  12.135  12.149  12.225  12.235  12.242  12.334  12.375  12.376  12.385  12.386  
	     12.407  12.415  12.427  13.15   
FIXC0 	PSVLEF.MAC;33        10.170# 10.174  
FIXC1 	PSVLEF.MAC;33        10.188# 10.194  
FIXCON	PSVLEF.MAC;33        10.94   10.106  10.169# 10.183# 
FLAGS 	PUPDEF.MAC;11        6.43    6.47    
FLSEOP	PSVLEF.MAC;33        8.149#  11.16   11.28   11.34   11.40   11.43   11.49   16.13   16.97   17.12   17.81   18.10   
	     20.9    21.72   21.83   21.109  
FLUSH 	PUPDEF.MAC;11        6.36    
FMAI  	PUPDEF.MAC;11        6.36    
FNDKEY	PSVLEF.MAC;33        23.17   
	PUPPRP.MAC;4  3.40    6.17    7.34    10.42#  
FOR   	PSVLEF.MAC;33        8.38    11.8    12.337  15.8    16.10   17.9    18.7    19.5    20.29   21.68   
	PUPSEQ.MAC;35        8.118   9.49    9.58    11.375  12.370  
FORK  	PSVLEF.MAC;33        7.5     
	PUPSEQ.MAC;35        4.166#  11.375  
FORMA1	PUPUUO.MAC;7  6.36#   7.23    7.28    
FORMA2	PUPUUO.MAC;7  6.31    6.40#   
FORMA3	PUPUUO.MAC;7  6.33    7.5#    
FORMA4	PUPUUO.MAC;7  7.6#    7.12    
FORMA5	PUPUUO.MAC;7  7.9     7.14#   
FORMAL	PUPUUO.MAC;7  6.30#   6.37    7.31    
FORMAT	PSVLEF.MAC;33        25.12   
	PUPUUO.MAC;7  3.69    4.7     4.37    5.11    6.16#   
FPAUTH	PSVLEF.MAC;33        23.40   23.98#  
FPBYTE	PSVLEF.MAC;33        23.41   23.126# 
FPCDAT	PSVLEF.MAC;33        23.43   23.208# 
FPCFIL	PSVLEF.MAC;33        23.42   23.164# 
FPDATE	PSVLEF.MAC;33        23.193  23.205  23.222# 
FPPROP	PSVLEF.MAC;33        23.44   23.252# 23.254  
FPPRP1	PSVLEF.MAC;33        23.253# 23.256  
FPRDAT	PSVLEF.MAC;33        23.45   23.184# 
FPSIZE	PSVLEF.MAC;33        23.46   23.146# 
FPTYPE	PSVLEF.MAC;33        23.47   23.231# 
FPWDAT	PSVLEF.MAC;33        23.48   23.196# 
FREPNT	PUPSEQ.MAC;35        4.19    11.247  11.250  14.17   
FREQUE	PUPSEQ.MAC;35        4.20    4.66    4.101   12.113  13.92   
FROM  	PSVLEF.MAC;33        20.53   20.77   
	PUPSEQ.MAC;35        4.169   
FT10X 	PSQDEF.MAC;9  3.147   
	PSVLEF.MAC;33        10.15   10.93   10.147  10.182  10.203  23.101  23.170  28.119  28.133  28.156  
	PUPDEF.MAC;11        3.7     3.42    3.43    
	PUPSEQ.MAC;35        4.31    4.38    4.56    11.412  
FT20  	PSVLEF.MAC;33        10.44   10.105  10.153  10.168  10.223  13.59   16.74   16.83   23.117  23.173  28.136  28.170  
                                   28-Jul-82 17:31     Page 7.16

	PUPDEF.MAC;11        3.40    3.41    
	PUPSEQ.MAC;35        4.34    4.41    11.415  
FTIME 	PUPSEQ.MAC;35        4.161   11.262  11.302  14.12   
FTPM  	PUPDEF.MAC;11        4.58#   
	PUPPRP.MAC;4  3.28    3.38    3.41    3.46    3.50    3.58    4.29    4.37    4.40    5.5     5.6     5.17    5.25    
	      5.36    6.10    6.18    6.19    6.35    6.38    6.42    6.55    7.8     7.18    7.26    7.35    7.36    7.49    
	      7.50    7.52    7.63    8.10    8.17    8.29    8.32    8.41    
FX    	PSQDEF.MAC;9  3.38#   
	PSVLEF.MAC;33        4.10    4.11    4.47    6.5     7.7     7.61    26.19   27.18   27.21   
	PUPSEQ.MAC;35        11.389  11.402  11.439  11.447  12.26   12.98   12.198  
GDACC 	PLFSUP.MAC;3  3.24#   13.26   
GDACX1	SMXACC.MAC;7  4.24    
GDACX2	PLFSUP.MAC;3  13.22#  13.44   
	SMXACC.MAC;7  4.32    
GDATM 	PUPPRP.MAC;4  5.24    7.7     8.40    9.10#   
GDSTS 	PUPSEQ.MAC;35        4.136   
GENFP 	PSVLEF.MAC;33        21.82   23.14#  
GENFPE	PSVLEF.MAC;33        23.18   23.19   23.32#  
GET   	PUPSEQ.MAC;35        4.46    
	SMXACC.MAC;7  5.27    5.68    
GETAB 	PSVLEF.MAC;33        4.22    
	PUPSEQ.MAC;35        4.151   
GETDIR	PLFSUP.MAC;3  11.45   12.12#  13.42   
GETER 	PUPSEQ.MAC;35        13.118  
	SMXACC.MAC;7  5.62    
GETJF1	PSVLEF.MAC;33        13.44   13.48#  
GETJFN	PSVLEF.MAC;33        12.272  12.359  12.378  13.9#   
GETJI 	PSVLEF.MAC;33        4.34    
GETNA1	PUPPRP.MAC;4  11.16#  11.30   11.34   
GETNA2	PUPPRP.MAC;4  11.20   11.24   11.29#  
GETNA3	PUPPRP.MAC;4  11.27   11.33#  
GETNAM	PUPPRP.MAC;4  10.44   11.12#  
GETPAG	PSVLEF.MAC;33        24.15   24.67   24.93#  24.144  24.196  
GETPG1	PSVLEF.MAC;33        24.107  24.119# 
GETPG2	PSVLEF.MAC;33        24.95   24.128# 
GETPSW	PLFSUP.MAC;3  11.29   11.43#  
GETPTR	PSVLEF.MAC;33        13.119  13.129  13.146  13.157  24.20   24.149  28.58#  28.82   28.129  28.142  28.148  28.154  
	     28.166  28.176  28.195  
GETSIZ	PSVLEF.MAC;33        12.300  13.114# 24.26   24.155  
GETX2 	SMXACC.MAC;7  5.65    
GFACC 	PSVLEF.MAC;33        10.208  
GFUST 	PSVLEF.MAC;33        23.120  28.174  
GJFX10	PSVLEF.MAC;33        8.68    
GJFX11	PSVLEF.MAC;33        8.69    
GJFX12	PSVLEF.MAC;33        8.70    
GJFX16	PSVLEF.MAC;33        8.71    
GJFX17	PSVLEF.MAC;33        8.72    
GJFX18	PSVLEF.MAC;33        8.73    
GJFX19	PSVLEF.MAC;33        8.74    
GJFX20	PSVLEF.MAC;33        8.75    12.367  
GJFX24	PSVLEF.MAC;33        8.76    
GJFX27	PSVLEF.MAC;33        8.77    
GJFX31	PSVLEF.MAC;33        8.78    
                                   28-Jul-82 17:31     Page 7.17

GJFX32	PSVLEF.MAC;33        8.79    
GJFX34	PSVLEF.MAC;33        8.80    
GJFX35	PLFSUP.MAC;3  15.26   
	PSVLEF.MAC;33        8.81    
GJFX4 	PSVLEF.MAC;33        8.62    
GJFX5 	PSVLEF.MAC;33        8.63    
GJFX6 	PSVLEF.MAC;33        8.64    
GJFX7 	PSVLEF.MAC;33        8.65    
GJFX8 	PSVLEF.MAC;33        8.66    
GJFX9 	PSVLEF.MAC;33        8.67    
GJINF 	PSVLEF.MAC;33        4.16    
	SMXACC.MAC;7  3.34    4.19    
GNJFN 	PSVLEF.MAC;33        11.24   
GNPEND	PSVLEF.MAC;33        23.26   23.68#  23.122  23.142  23.160  23.179  23.227  23.247  
GNPSTA	PSVLEF.MAC;33        23.23   23.55#  23.98   23.126  23.146  23.164  23.184  23.196  23.208  23.231  
GS    	PSVLEF.MAC;33        27.74   27.75   27.76   27.77   27.78   29.9    29.10   29.11   29.12   29.15   29.16   29.17   
	PUPDEF.MAC;11        3.50#   
	PUPSEQ.MAC;35        12.47   12.48   14.6    14.7    14.8    14.9    14.10   14.11   14.12   14.13   14.15   14.25   
	     14.26   14.28   
GSP   	PUPDEF.MAC;11        3.51#   
GSPVAR	PUPDEF.MAC;11        3.47    3.47    3.51    
GSTBAD	PUPPRP.MAC;4  9.45    9.50#   9.71    
GSTDIR	PUPPRP.MAC;4  5.4     9.34#   
GSTDR 	PUPPRP.MAC;4  9.37    9.43#   
GSTOK 	PUPPRP.MAC;4  9.46#   9.72    
GSTUS 	PUPPRP.MAC;4  9.63    9.69#   
GSTUSR	PUPPRP.MAC;4  7.48    9.60#   
GSTVAL	PUPPRP.MAC;4  9.34    9.60    9.80#   
GSVAR 	PUPDEF.MAC;11        3.47    3.47    3.50    
GTAD  	PSVLEF.MAC;33        4.5     
	PUPSEQ.MAC;35        13.146  
GTDIR 	PLFSUP.MAC;3  12.51   
	PSVLEF.MAC;33        10.63   
GTDLEN	PLFSUP.MAC;3  12.16   12.19   12.22   12.24   16.12#  16.13   16.14   16.15   
GTDPRT	PSVLEF.MAC;33        25.29   25.46#  
GTFDB 	PSVLEF.MAC;33        12.382  14.14   14.23   23.107  23.134  23.192  23.204  23.216  23.239  28.107  
GTJBLK	PSVLEF.MAC;33        12.419  13.9    13.9    13.10   13.11   13.16   13.19   13.21   13.21   13.22   13.23   13.27   
	     13.31   13.39   13.46   13.48   
GTJFN 	PSVLEF.MAC;33        13.50   27.40   
	PUPSEQ.MAC;35        4.45    11.418  
	SMXACC.MAC;7  5.14    
GTPVA1	PUPPRP.MAC;4  10.15#  10.30   
GTPVA2	PUPPRP.MAC;4  10.20   10.25   10.28#  
GTPVAL	PUPPRP.MAC;4  3.45    4.28    5.16    5.35    6.9     7.17    7.62    8.9     9.82    10.12#  
GTSPRT	PSVLEF.MAC;33        25.30   25.59#  
HALTED	PUPSEQ.MAC;35        13.147  
HALTF 	PUPSEQ.MAC;35        13.94   13.148  
HANDLE	PUPSEQ.MAC;35        11.375  
HDLACK	PUPSEQ.MAC;35        8.144   10.82#  
HDLBRK	PUPSEQ.MAC;35        8.149   10.109# 
HDLBRO	PUPSEQ.MAC;35        8.155   10.110# 
HDLCHK	PUPSEQ.MAC;35        8.147   10.69#  
HDLCLD	PUPSEQ.MAC;35        8.151   10.111# 
                                   28-Jul-82 17:31     Page 7.18

HDLDAL	PUPSEQ.MAC;35        8.153   10.62#  
HDLDAT	PUPSEQ.MAC;35        8.143   10.86#  
HDLDES	PUPSEQ.MAC;35        8.152   10.53#  
HDLNOP	PUPSEQ.MAC;35        8.145   10.70#  
HDLQUI	PUPSEQ.MAC;35        8.154   10.112# 
HDLRES	PUPSEQ.MAC;35        8.146   10.77#  
HDLSEQ	PUPSEQ.MAC;35        8.59#   8.72#   8.118#  12.225  
HDLSQ1	PUPSEQ.MAC;35        8.88#   9.70    
HDLSQ2	PUPSEQ.MAC;35        8.131#  10.20   
HDLSQ3	PUPSEQ.MAC;35        8.94    8.106#  
HDLSQ4	PUPSEQ.MAC;35        8.68    8.79#   
HDLSQ5	PUPSEQ.MAC;35        8.99    8.110   8.127#  
HERE  	PUPDEF.MAC;11        6.23    6.29    
HIGHAC	PLFSUP.MAC;3  4.5#    4.7     4.7     4.8     4.9     4.9     4.14    4.15    4.15    
IDLE1 	PLFDEF.MAC;5  1.68#   
	PSVLEF.MAC;33        6.39    
IDLE2 	PLFDEF.MAC;5  1.69#   
	PSVLEF.MAC;33        6.54    
IDTIM 	PUPPRP.MAC;4  9.12    9.23    
IF2   	PUPPRP.MAC;4  4.5     
	PUPUUO.MAC;7  3.36    
IFB   	PUPDEF.MAC;11        4.17    4.56    
IFDEF 	PSVLEF.MAC;33        7.70    
IFE   	PUPDEF.MAC;11        3.41    3.43    
	PUPUUO.MAC;7  3.18    3.23    
IFN   	PLFSUP.MAC;3  3.22    
	PSQDEF.MAC;9  3.147   
	PSVLEF.MAC;33        10.15   10.44   10.93   10.105  10.147  10.153  10.168  10.182  10.203  10.223  13.59   16.74   
	     16.83   23.101  23.117  23.170  23.173  28.119  28.133  28.136  28.156  28.170  
	PUPDEF.MAC;11        3.40    3.42    
	PUPSEQ.MAC;35        4.31    4.34    4.38    4.41    4.56    11.412  11.415  
	PUPUUO.MAC;7  3.15    
IFNB  	PUPDEF.MAC;11        4.9     4.18    4.55    4.59    
IFNDEF	PLFSUP.MAC;3  3.9     
	PSQDEF.MAC;9  3.148   
	PSVLEF.MAC;33        7.71    
	PUPDEF.MAC;11        3.7     
	PUPPRP.MAC;4  4.5     
	PUPUUO.MAC;7  3.10    3.36    
IFSDF 	PSVLEF.MAC;33        8.34    8.96#   
IFSDF0	PSVLEF.MAC;33        8.99#   8.102   
IFSDF1	PSVLEF.MAC;33        8.101   8.109#  
IFSDFT	PSVLEF.MAC;33        8.99    8.109   8.115#  8.143   
IIC   	PUPSEQ.MAC;35        10.139  
ILLEGA	PSVLEF.MAC;33        7.5     
	PUPPRP.MAC;4  5.6     6.18    6.19    7.35    7.36    7.50    7.52    8.17    8.32    
ILLINS	PUPSEQ.MAC;35        13.35   13.103# 
ILLRED	PUPSEQ.MAC;35        13.36   13.56#  
ILLSIZ	PUPSEQ.MAC;35        13.39   13.65#  
ILLWRT	PUPSEQ.MAC;35        13.37   13.59#  
ILLXCT	PUPSEQ.MAC;35        13.38   13.62#  
ILSLOC	PSQDEF.MAC;9  3.124#  3.132   
	PUPSEQ.MAC;35        11.424  11.426  
                                   28-Jul-82 17:31     Page 7.19

IMPROP	PUPSEQ.MAC;35        11.403  
IN    	PUPPRP.MAC;4  4.40    
	PUPSEQ.MAC;35        10.45   
INBNTF	PSQDEF.MAC;9  3.43#   
INCOMI	PUPSEQ.MAC;35        9.69    
INILOG	PSVLEF.MAC;33        4.40    27.8#   
INPSEQ	PSVLEF.MAC;33        7.29    
	PUPSEQ.MAC;35        8.20#   
INPSQ0	PUPSEQ.MAC;35        8.28    8.39#   
INPSQ1	PUPSEQ.MAC;35        8.26#   8.43    
INPUT 	PSVLEF.MAC;33        7.21    
INSEQU	PUPSEQ.MAC;35        10.105  10.119# 
INSTRU	PSVLEF.MAC;33        7.5     
INTDEF	PUPSEQ.MAC;35        3.60    3.63    3.67    3.78    3.79    3.83    3.86    3.91    13.5    
INTERN	PLFSUP.MAC;3  3.15    3.16    3.18    
INTERR	PUPSEQ.MAC;35        3.63    3.83    
IOWD  	PSVLEF.MAC;33        4.12    6.4     
	PUPSEQ.MAC;35        13.6    13.8    
IRP   	PUPDEF.MAC;11        4.9     4.70    4.74    
IS    	PSVLEF.MAC;33        7.50    
	PUPDEF.MAC;11        6.23    6.29    
	PUPSEQ.MAC;35        11.399  
ISHLOC	PSQDEF.MAC;9  3.126#  3.135   
	PUPSEQ.MAC;35        11.345  
ITEM  	PUPDEF.MAC;11        4.5     4.6     4.9     4.9     4.9     
	PUPUUO.MAC;7  3.36    3.36    3.37    
JERR  	PSVLEF.MAC;33        10.48   10.110  13.103  
	PUPSEQ.MAC;35        4.125   4.137   4.152   5.28    11.173  11.230  12.168  12.211  12.343  13.75#  
JFN   	PSVLEF.MAC;33        12.322# 15.15   15.34   
JFNS  	PSVLEF.MAC;33        23.176  28.127  28.140  
	PUPUUO.MAC;7  8.16    
JFNTAB	PSVLEF.MAC;33        7.93    7.100   11.66   11.67   14.18   14.46   15.27   15.32   15.51   15.54   16.17   17.16   
	     18.14   18.23   18.28   21.89   21.127  22.9    22.11   22.14   29.9    
JSIFST	PSVLEF.MAC;33        8.51    8.53    8.62#   8.88    
JSTIF1	PSVLEF.MAC;33        8.51#   8.55    
JSTIF2	PSVLEF.MAC;33        8.54    8.57#   
JSTIFS	PSVLEF.MAC;33        8.27    8.47#   
JSYS  	PSVLEF.MAC;33        12.295  
	PUPSEQ.MAC;35        13.116  13.121  
KFORK 	PUPSEQ.MAC;35        11.377  
	SMXACC.MAC;7  5.44    
KILLFK	PUPSEQ.MAC;35        11.372# 12.108  
KILSR1	PUPSEQ.MAC;35        13.139# 13.141  
KILSRV	PUPSEQ.MAC;35        13.40   13.136# 13.145# 
LDRAUT	PSVLEF.MAC;33        28.47#  28.165  28.175  
LDRBIT	PSVLEF.MAC;33        28.42#  
LDRBKP	PSVLEF.MAC;33        28.48#  28.121  
LDRBYT	PSVLEF.MAC;33        13.128  13.156  28.50#  28.147  
LDRCNM	PSVLEF.MAC;33        28.45#  28.141  
LDRCRE	PSVLEF.MAC;33        28.35#  28.111  
LDRDFP	PSVLEF.MAC;33        28.43#  
LDRFIL	PSVLEF.MAC;33        15.48   28.99   28.103  28.109  28.186  28.200  28.211  
LDRFLG	PSVLEF.MAC;33        28.51#  
                                   28-Jul-82 17:31     Page 7.20

LDRHNT	PSVLEF.MAC;33        28.44#  
LDRINH	PSVLEF.MAC;33        28.46#  
LDRNAM	PSVLEF.MAC;33        28.38#  28.128  
LDRPAG	PSVLEF.MAC;33        28.68   28.185  
LDRPR1	PSVLEF.MAC;33        28.41#  
LDRPRP	PSVLEF.MAC;33        28.39#  
LDRREA	PSVLEF.MAC;33        28.37#  28.117  
LDRSPR	PSVLEF.MAC;33        28.40#  
LDRTYP	PSVLEF.MAC;33        13.118  13.145  28.49#  28.153  28.194  
LDRWRI	PSVLEF.MAC;33        28.36#  28.114  
LEAF  	PSVLEF.MAC;33        4.41    4.44    6.4#    7.12    8.38    
	PUPSEQ.MAC;35        11.361  13.96   13.147  
LEAFCL	PSVLEF.MAC;33        15.8    
LEAFCX	PSVLEF.MAC;33        7.24    7.45    7.49    29.22   
LEAFDE	PSVLEF.MAC;33        18.7    
LEAFFK	PSQDEF.MAC;9  3.90#   3.91    
	PSVLEF.MAC;33        6.37    6.53    
	PUPSEQ.MAC;35        10.135  11.319  11.378  
LEAFGE	PSVLEF.MAC;33        21.68   
LEAFGO	PSVLEF.MAC;33        6.44    6.69    6.73#   
LEAFL1	PSVLEF.MAC;33        6.42#   6.49    6.56    
LEAFLP	PSVLEF.MAC;33        6.37#   6.74    
LEAFOP	PSVLEF.MAC;33        8.41    9.10#   11.8    11.84   15.20   16.58   17.72   18.35   19.22   20.17   21.97   
LEAFPA	PSVLEF.MAC;33        19.5    
LEAFPK	PSVLEF.MAC;33        7.28    7.32    24.152  24.159  24.169  29.5    
LEAFRE	PSVLEF.MAC;33        16.10   20.29   
LEAFS0	PSVLEF.MAC;33        7.28#   7.56    
LEAFS1	PSVLEF.MAC;33        7.34#   7.52    
LEAFS2	PSVLEF.MAC;33        7.44    7.52#   
LEAFSK	PSQDEF.MAC;9  3.65#   
	PUPSEQ.MAC;35        4.140   
LEAFSL	PSVLEF.MAC;33        4.47#   4.54    
LEAFSV	PSVLEF.MAC;33        4.41#   4.44#   6.73    7.18#   15.8#   15.15#  15.34#  16.10#  17.9#   19.5#   20.29#  20.53#  
	     20.77#  21.68#  
	PUPSEQ.MAC;35        12.292# 
LEAFSX	PSVLEF.MAC;33        7.30    7.54#   
LEAFW1	PSVLEF.MAC;33        17.39   17.46#  
LEAFWR	PSVLEF.MAC;33        17.9    
LEFT  	PSVLEF.MAC;33        7.65    
LETDSP	PUPUUO.MAC;7  7.30    7.42#   
LEV   	PUPSEQ.MAC;35        13.25   13.28   
LEV1PC	PSVLEF.MAC;33        7.3     
	PUPSEQ.MAC;35        13.44   13.70   13.105  13.108  13.124  14.21   
LEV2PC	PUPSEQ.MAC;35        13.45   14.22   
LEV3PC	PSVLEF.MAC;33        6.63    6.70    
	PUPSEQ.MAC;35        13.46   14.23   
LEVTAB	PSVLEF.MAC;33        6.11    
	PUPSEQ.MAC;35        13.10   13.44#  
LF    	PUPDEF.MAC;11        5.10#   
LFANPK	PSVLEF.MAC;33        8.25    8.39    11.69   11.82   15.16   15.17   16.44   16.56   17.62   17.70   18.31   18.33   
	     19.17   19.20   20.12   20.15   21.84   21.88   24.9    24.23   24.30   24.40   29.6    
LFCLOS	PLFDEF.MAC;5  1.21#   
	PSVLEF.MAC;33        15.19   
                                   28-Jul-82 17:31     Page 7.21

LFDEL 	PLFDEF.MAC;5  1.22#   
	PSVLEF.MAC;33        18.34   
LFDISP	PSVLEF.MAC;33        7.69#   7.74    7.75    7.76    7.77    7.78    7.79    7.80    7.81    7.82    7.83    7.84    
	     7.85    
LFERR 	PLFDEF.MAC;5  1.19#   
LFINIT	PSVLEF.MAC;33        29.17   
	PUPSEQ.MAC;35        3.7     4.167   10.148  
LFINT 	PSVLEF.MAC;33        6.6     6.63#   
LFLEN 	PLFDEF.MAC;5  1.23#   
LFLPDL	PSVLEF.MAC;33        3.22#   6.4     29.20   
LFNOP 	PLFDEF.MAC;5  1.28#   
LFO.CR	PLFDEF.MAC;5  1.38#   
	PSVLEF.MAC;33        12.270  12.282  
LFO.DD	PLFDEF.MAC;5  1.43#   
LFO.DH	PLFDEF.MAC;5  1.45#   
LFO.DL	PLFDEF.MAC;5  1.44#   
LFO.DN	PLFDEF.MAC;5  1.46#   
LFO.EX	PLFDEF.MAC;5  1.36#   
	PSVLEF.MAC;33        12.282  
LFO.ML	PLFDEF.MAC;5  1.37#   
LFO.MW	PLFDEF.MAC;5  1.47#   
LFO.RD	PLFDEF.MAC;5  1.34#   
	PSVLEF.MAC;33        12.280  
LFO.VA	PLFDEF.MAC;5  1.42#   
LFO.VN	PLFDEF.MAC;5  1.39#   
LFO.VO	PLFDEF.MAC;5  1.40#   
LFO.VR	PLFDEF.MAC;5  1.41#   
LFO.WR	PLFDEF.MAC;5  1.35#   
	PSVLEF.MAC;33        12.282  
LFOPEN	PLFDEF.MAC;5  1.20#   
	PSVLEF.MAC;33        11.83   
LFOPER	PSVLEF.MAC;33        7.41    7.71    7.73    7.77    7.83    8.8#    
LFOPTB	PSVLEF.MAC;33        7.42    7.73#   7.86    
LFPARM	PLFDEF.MAC;5  1.29#   
	PSVLEF.MAC;33        19.21   
LFPDL 	PSVLEF.MAC;33        6.4     29.20   
LFPROP	PLFDEF.MAC;5  1.30#   
	PSVLEF.MAC;33        21.96   
LFREAD	PLFDEF.MAC;5  1.25#   
	PSVLEF.MAC;33        16.57   
LFREST	PLFDEF.MAC;5  1.27#   
	PSVLEF.MAC;33        20.16   
LFSLEP	PSVLEF.MAC;33        6.51    6.59#   
LFTRUN	PLFDEF.MAC;5  1.24#   
LFWAI1	PSVLEF.MAC;33        6.46#   6.65    
LFWAIT	PSVLEF.MAC;33        6.60#   6.66    6.67    
LFWRIT	PLFDEF.MAC;5  1.26#   
	PSVLEF.MAC;33        17.71   
LGTTYF	PSQDEF.MAC;9  3.44#   
	PSVLEF.MAC;33        25.8    25.11   26.45   
LINE  	PUPDEF.MAC;11        5.42    
	PUPPRP.MAC;4  6.18    6.19    
LIST  	PUPDEF.MAC;11        6.29    
                                   28-Jul-82 17:31     Page 7.22

	PUPPRP.MAC;4  3.28    3.38    
LOC   	PUPDEF.MAC;11        3.48    3.48    3.49    3.49    3.50    3.50    3.51    3.51    
	PUPUUO.MAC;7  3.14    
LOCK  	PUPSEQ.MAC;35        5.22    6.13    11.141  11.153  11.196  11.208  11.387# 11.399  11.403  12.164  
LOCKED	PSVLEF.MAC;33        7.65    
	PUPSEQ.MAC;35        11.399  
LOG   	PSVLEF.MAC;33        4.41    4.44    7.21    7.65    8.38    10.151  10.157  11.8    12.322  12.339  14.50   14.56   
	     15.8    15.15   15.34   16.10   17.9    18.7    19.5    20.29   20.53   20.77   21.68   
	PUPDEF.MAC;11        4.47#   
	PUPSEQ.MAC;35        4.169   8.77    9.37    11.443  12.92   12.101  12.251  12.370  13.87   
LOGBFS	PSVLEF.MAC;33        3.25#   26.59   27.52   27.76   
LOGBPT	PSVLEF.MAC;33        26.13   26.39   26.40   26.58   27.9    27.32   27.51   27.61   27.70   27.75   
LOGBUF	PSVLEF.MAC;33        26.59   27.8    27.52   27.55   27.60   27.69   27.76   
LOGIN 	PSVLEF.MAC;33        10.151  10.157  
LOGINP	PSVLEF.MAC;33        10.9    10.131  10.145  10.161  
LOGLAT	PSVLEF.MAC;33        3.24#   27.11   27.64   
LOGLKR	PSVLEF.MAC;33        27.18   27.21   27.78   
LOGLOK	PSVLEF.MAC;33        27.13   27.17   27.25   27.77   
LOGTIM	PSVLEF.MAC;33        4.52    27.12   27.65   27.74   
LOKLOG	PSVLEF.MAC;33        26.12   27.17#  27.34   
LONG  	PUPPRP.MAC;4  6.42    6.55    
LONGD 	PLFDEF.MAC;5  1.71#   
	PSVLEF.MAC;33        6.52    
LQUTAB	PSQDEF.MAC;9  3.99#   
	PUPSEQ.MAC;35        4.104   4.112   14.25   14.26   
LS    	PLFSUP.MAC;3  4.18    4.19    16.2    16.3    16.4    16.5    16.6    16.9    16.10   16.11   16.13   16.14   16.15   
	      16.16   16.17   
	PSVLEF.MAC;33        10.161  12.419  12.420  12.421  12.422  12.423  12.424  12.425  12.426  12.427  13.108  24.132  
	     26.63   28.186  29.2    29.3    29.4    29.5    29.6    29.19   29.20   29.22   
	PUPDEF.MAC;11        3.48#   
	PUPSEQ.MAC;35        3.91    3.93    3.94    4.64    4.65    4.66    11.43   12.314  12.315  12.316  12.317  12.373  
	     13.100  13.133  14.2    14.3    14.16   14.17   14.18   14.19   14.21   14.22   14.23   
	PUPUUO.MAC;7  5.21    5.22    
LSP   	PSVLEF.MAC;33        3.39    28.185  
	PUPDEF.MAC;11        3.49#   
LSPVAR	PUPDEF.MAC;11        3.47    3.49    
LST   	PUPDEF.MAC;11        4.69    4.70    4.70    4.73    4.74    4.74    
LSTPVR	PSQDEF.MAC;9  3.130#  
LSTVAR	PSQDEF.MAC;9  3.129#  
LSVAR 	PUPDEF.MAC;11        3.47    3.48    
LTIME 	PUPSEQ.MAC;35        4.158   11.276  11.289  12.59   12.62   14.11   
LTTTIM	PSVLEF.MAC;33        26.48   26.49   26.63   
MAIL  	PUPDEF.MAC;11        6.34    6.35    6.36    
MAILBO	PUPDEF.MAC;11        5.43    6.37    
MAKFK1	PUPSEQ.MAC;35        11.325# 11.341  
MAKFK2	PUPSEQ.MAC;35        11.339# 
MAKFK3	PUPSEQ.MAC;35        11.326  11.344# 
MAKFK4	PUPSEQ.MAC;35        11.350# 11.356  
MAKFRK	PUPSEQ.MAC;35        4.165   11.312# 
MAKLDR	PSVLEF.MAC;33        11.86   13.117  13.144  24.128  28.99#  
MALFOR	PUPPRP.MAC;4  3.28    3.38    3.41    3.46    3.50    3.58    4.29    4.37    5.5     5.17    5.25    5.36    6.10    
	      6.35    6.38    7.8     7.18    7.26    7.49    7.63    8.10    8.29    8.41    
MAPDA1	PUPSEQ.MAC;35        11.429# 11.438  
                                   28-Jul-82 17:31     Page 7.23

MAPDA2	PUPSEQ.MAC;35        11.439# 
MAPDAF	PUPSEQ.MAC;35        11.419  11.423  11.443# 
MAPDAT	PSVLEF.MAC;33        4.10    
	PUPSEQ.MAC;35        11.411# 
MARKS 	PUPDEF.MAC;11        6.18#   6.53    
MAXC  	PUPUUO.MAC;7  3.10    3.10#   3.15    3.18    3.23    
MAXOP 	PSVLEF.MAC;33        7.40    7.86#   
MBEX  	PUPDEF.MAC;11        6.37    
MDANYW	PSVLEF.MAC;33        17.31   17.85#  
MDCHKX	PSVLEF.MAC;33        17.34   17.105# 
MDDNTX	PSVLEF.MAC;33        17.33   17.110# 
MDDNX1	PSVLEF.MAC;33        17.118  17.125# 
MDDNXX	PSVLEF.MAC;33        17.120# 17.128  17.134  
MDNOHO	PSVLEF.MAC;33        17.32   17.89#  
MDNOHX	PSVLEF.MAC;33        17.98   17.100# 
MK    	PUPDEF.MAC;11        4.60    6.44    6.48    
MLBX  	PUPDEF.MAC;11        5.43    
MNPBLN	PSQDEF.MAC;9  3.113#  
	PUPSEQ.MAC;35        11.221  11.222  12.367  12.373  
MNPLEN	PSQDEF.MAC;9  3.111#  3.113   
	PUPSEQ.MAC;35        5.37    5.57    6.22    7.27    8.32    10.97   12.154  12.170  12.350  12.360  
MONSYM	PLFSUP.MAC;3  3.7     
	PSVLEF.MAC;33        3.7     
	PUPPRP.MAC;4  3.8     
	PUPSEQ.MAC;35        3.10    
	PUPUUO.MAC;7  3.8     
MORE  	PUPDEF.MAC;11        4.6     4.6     
MPP   	PLFSUP.MAC;3  3.34    4.10    4.19    
MQUE1 	PUPSEQ.MAC;35        11.27#  11.31   
MQUEUE	PUPSEQ.MAC;35        4.24    11.18#  
MQUEX 	PUPSEQ.MAC;35        11.25   11.33#  
MTOPR 	PUPSEQ.MAC;35        13.21   
MXAHED	PSQDEF.MAC;9  3.116#  3.118   
	PUPSEQ.MAC;35        9.17    
MXPBLN	PSQDEF.MAC;9  3.114#  
	PUPSEQ.MAC;35        11.249  12.217  14.18   14.19   
MXPLEN	PSQDEF.MAC;9  3.112#  3.114   
MY    	PUPSEQ.MAC;35        8.72    
NACTCN	PUPSEQ.MAC;35        12.18   12.119  12.120  12.121  12.293  14.15   
NAMB  	PUPDEF.MAC;11        5.44    
NAMCM1	PUPPRP.MAC;4  12.33#  12.46   
NAMCM2	PUPPRP.MAC;4  12.45   12.48#  
NAMCM3	PUPPRP.MAC;4  12.40   12.49#  
NAMCM4	PUPPRP.MAC;4  12.43   12.50#  
NAMCM5	PUPPRP.MAC;4  12.35   12.38#  
NAMCMP	PUPPRP.MAC;4  12.29#  
NAME  	PUPDEF.MAC;11        5.37    5.44    5.51    5.60    6.43    6.47    
	PUPPRP.MAC;4  3.41    4.4     5.6     6.42    6.55    7.50    7.52    
NAMSRC	PUPPRP.MAC;4  10.49   12.13#  
NAMSTL	PUPDEF.MAC;11        5.5#    5.6     5.44    
	PUPPRP.MAC;4  6.32    
NCONN 	PSQDEF.MAC;9  3.117#  
	PSVLEF.MAC;33        20.37   20.60   29.15   29.16   29.17   
                                   28-Jul-82 17:31     Page 7.24

	PUPSEQ.MAC;35        4.15    4.23    4.82    12.32   12.202  12.255  12.264  13.136  14.6    14.7    14.8    14.9    
	     14.10   14.11   14.12   14.13   14.25   14.26   14.28   
NEW   	PUPDEF.MAC;11        6.27    
NFETCH	PUPDEF.MAC;11        6.14#   6.23    6.24    
NIFSDF	PSVLEF.MAC;33        8.98    8.143#  
NIN   	PSVLEF.MAC;33        12.128  12.147  12.177  12.230  12.240  
	PUPPRP.MAC;4  4.36    7.25    8.14    8.28    
NJFN  	PSVLEF.MAC;33        3.23#   7.92    14.16   29.9    29.10   29.11   29.12   
NJSIFS	PSVLEF.MAC;33        8.50    8.88#   
NMARKS	PUPDEF.MAC;11        6.45#   6.45    6.49#   6.49    6.52#   
NO    	PUPDEF.MAC;11        6.22    6.22    
	PUPPRP.MAC;4  3.28    3.38    3.41    3.46    3.50    3.58    4.29    4.37    4.40    5.5     5.6     5.17    5.25    
	      5.36    6.10    6.18    6.19    6.35    6.38    6.42    6.55    7.8     7.18    7.26    7.35    7.36    7.49    
	      7.50    7.52    7.63    8.10    8.17    8.29    8.32    8.41    
	PUPSEQ.MAC;35        12.370  
NOINT 	PSQDEF.MAC;9  3.144#  
	PUPSEQ.MAC;35        7.9     
NOISE 	PUPDEF.MAC;11        4.51#   
NON   	PUPSEQ.MAC;35        12.251  
NONEXI	PUPSEQ.MAC;35        12.370  
NOPLF 	PSVLEF.MAC;33        7.82    
NOT   	PUPPRP.MAC;4  4.40    
	PUPSEQ.MAC;35        11.399  
NOTENE	PUPDEF.MAC;11        3.43#   
NOTOPS	PUPDEF.MAC;11        3.41#   
NOUT  	PSVLEF.MAC;33        23.111  23.138  23.156  26.22   28.162  
	PUPUUO.MAC;7  8.6     8.34    8.43    9.9     9.18    9.23    9.30    
NOWHER	PUPSEQ.MAC;35        5.27    11.172  11.229  
NPOP  	PUPDEF.MAC;11        4.53    4.53    4.58    
NPROPS	PSVLEF.MAC;33        23.16   23.49#  23.252  
	PUPPRP.MAC;4  3.39    4.11#   
NPUPBF	PSQDEF.MAC;9  3.118#  
	PUPSEQ.MAC;35        4.21    4.23    4.102   4.119   
NQUEUE	PUPSEQ.MAC;35        10.125  11.137# 
NSTO  	PUPDEF.MAC;11        6.27    
NW%ARP	PUPDEF.MAC;11        5.17#   
NW%CHS	PUPDEF.MAC;11        5.16#   
NW%DLN	PUPDEF.MAC;11        5.18#   
NW%LCL	PUPDEF.MAC;11        5.20#   
NW%SUN	PUPDEF.MAC;11        5.19#   5.20    
ODTIM 	PSVLEF.MAC;33        23.224  26.16   
	PUPUUO.MAC;7  9.43    
OF    	PSVLEF.MAC;33        12.304  
	PUPDEF.MAC;11        5.42    6.24    
	PUPPRP.MAC;4  6.18    6.19    
OF%RD 	PSVLEF.MAC;33        13.80   
OF%WR 	PSVLEF.MAC;33        13.89   
OFF   	PUPSEQ.MAC;35        3.63    
OFTEMP	PLFSUP.MAC;3  7.43    16.5    
OKINT 	PSQDEF.MAC;9  3.145#  
	PUPSEQ.MAC;35        7.40    
OKRETR	PUPDEF.MAC;11        6.15#   6.21    6.22    6.24    6.31    
OKSTOR	PUPDEF.MAC;11        6.16#   6.21    6.22    6.23    6.24    6.31    
                                   28-Jul-82 17:31     Page 7.25

ON    	PSVLEF.MAC;33        10.151  10.157  
	PUPSEQ.MAC;35        3.83    9.37    9.69    12.92   
ONLY  	PUPPRP.MAC;4  7.52    
ONTEMP	PLFSUP.MAC;3  7.14    16.6    
OP    	PUPDEF.MAC;11        4.8     4.9     4.14    4.16#   
OPDEF 	PLFSUP.MAC;3  3.24    3.25    
	PSQDEF.MAC;9  3.150   
	PUPDEF.MAC;11        4.16    4.78    4.79    
OPEN  	PSQDEF.MAC;9  3.70#   
	PSVLEF.MAC;33        12.304  12.325  20.26   
	PUPSEQ.MAC;35        4.50    10.14   10.87   
OPENED	PUPSEQ.MAC;35        4.169   12.292  
OPENF 	PSVLEF.MAC;33        12.291  14.55   14.56   27.47   
	PUPSEQ.MAC;35        4.49    11.422  
OPENL1	PSVLEF.MAC;33        11.29   11.44   11.66#  
OPENLF	PSVLEF.MAC;33        7.74    11.7#   11.8#   
OPMAC 	PUPDEF.MAC;11        4.9#    4.10    4.11    
OPNX1 	PSVLEF.MAC;33        8.82    
OPNX10	PSVLEF.MAC;33        8.87    
OPNX2 	PSVLEF.MAC;33        8.83    
OPNX3 	PSVLEF.MAC;33        8.84    13.82   
OPNX4 	PSVLEF.MAC;33        8.85    13.91   
OPNX9 	PSVLEF.MAC;33        8.86    12.312  12.315  
OPRFN 	PLFSUP.MAC;3  5.9     
OUT   	PUPSEQ.MAC;35        12.70   
OVERDE	PUPSEQ.MAC;35        8.118   12.120  
P     	PLFSUP.MAC;3  3.24    3.25    3.34    4.10    5.10    5.28    5.41    5.42    5.47    5.48    5.50    6.9     6.19    
	      7.5     7.9     7.10    7.15    7.16    7.19    7.24    7.37    7.41    7.42    7.48    7.56    7.57    7.58    
	      7.59    7.60    8.9     8.11    8.14    8.16    8.24    8.25    8.26    8.27    8.33    8.40    9.24    10.42   
	      10.48   10.51   11.12   11.13   11.17   11.27   11.28   11.33   11.34   11.35   11.43   11.46   12.12   12.13   
	      12.57   12.58   13.27   13.36   13.45   13.60   14.8    14.26   14.27   14.37   14.38   14.42   15.11   15.12   
	      15.18   15.21   15.22   15.23   15.27   15.55   
	PSQDEF.MAC;9  3.39#   3.144   3.145   
	PSVLEF.MAC;33        4.12    4.40    4.43    4.50    4.53    5.8     5.9     5.14    5.22    5.24    5.28    5.29    
	     5.30    5.37    5.38    5.44    5.51    5.53    5.57    5.58    5.59    5.69    5.70    5.77    5.83    5.86    
	     5.87    5.89    5.99    5.100   5.101   5.121   5.122   5.123   5.124   5.132   5.133   5.153   5.154   5.155   
	     5.157   5.158   5.159   5.160   6.4     6.73    7.22    7.25    7.26    7.27    7.29    7.42    7.46    7.47    
	     7.51    7.57    7.58    7.59    7.67    7.94    7.98    7.102   7.104   7.106   7.110   7.113   8.11    8.12    
	     8.27    8.34    8.36    8.41    8.42    8.47    8.57    8.59    8.96    8.97    8.103   8.104   8.105   8.106   
	     8.110   8.110   8.111   8.112   8.149   8.150   8.158   8.159   8.160   9.10    9.11    9.20    9.22    9.23    
	     9.24    10.9    10.10   10.13   10.26   10.29   10.31   10.33   10.40   10.55   10.58   10.66   10.70   10.73   
	     10.78   10.83   10.86   10.86   10.88   10.91   10.94   10.103  10.106  10.116  10.120  10.122  10.124  10.131  
	     10.133  10.134  10.140  10.145  10.146  10.159  10.173  10.180  10.187  10.193  10.196  10.205  10.210  10.214  
	     10.215  10.216  10.220  10.221  10.224  10.226  10.228  10.229  10.230  11.10   11.14   11.15   11.21   11.27   
	     11.28   11.32   11.33   11.38   11.39   11.42   11.43   11.47   11.48   11.52   11.54   11.58   11.59   11.60   
	     11.61   11.63   11.64   11.65   11.72   11.75   11.84   11.85   11.86   11.87   11.88   12.41   12.52   12.59   
	     12.88   12.123  12.129  12.131  12.134  12.144  12.148  12.153  12.154  12.167  12.168  12.173  12.174  12.178  
	     12.181  12.182  12.183  12.187  12.218  12.219  12.222  12.231  12.233  12.241  12.252  12.253  12.263  12.268  
	     12.272  12.286  12.287  12.289  12.290  12.292  12.293  12.296  12.298  12.299  12.300  12.314  12.317  12.318  
	     12.318  12.319  12.323  12.328  12.329  12.340  12.341  12.342  12.353  12.354  12.355  12.359  12.360  12.366  
	     12.368  12.375  12.378  12.379  12.385  12.388  12.391  12.392  12.403  13.43   13.51   13.56   13.57   13.67   
	     13.68   13.81   13.84   13.88   13.90   13.93   13.95   13.96   13.97   13.98   13.105  13.106  13.114  13.115  
	     13.116  13.117  13.119  13.123  13.129  13.131  13.132  13.133  13.134  13.141  13.142  13.143  13.144  13.146  
                                   28-Jul-82 17:31     Page 7.26

	     13.150  13.157  13.159  13.161  13.162  13.163  13.164  13.165  14.9    14.10   14.11   14.17   14.32   14.32   
	     14.33   14.34   14.35   14.36   14.38   14.45   14.49   14.52   14.53   14.54   14.57   14.58   14.59   15.10   
	     15.11   15.14   15.26   15.28   15.29   15.30   15.35   15.36   15.37   15.40   15.45   15.47   15.50   15.57   
	     15.58   15.59   16.12   16.39   16.40   16.41   16.42   16.43   16.46   16.52   16.58   16.59   16.60   16.61   
	     16.62   16.66   16.75   16.81   16.85   16.89   16.90   16.91   16.96   17.11   17.31   17.37   17.40   17.45   
	     17.47   17.48   17.59   17.60   17.80   17.91   17.92   17.95   17.97   17.99   17.100  17.101  17.102  17.112  
	     17.113  17.119  17.120  17.121  17.122  17.127  17.129  17.132  17.133  18.9    18.19   19.16   20.4    20.7    
	     20.8    20.10   20.11   20.30   20.38   20.50   20.54   20.61   20.73   20.78   21.71   21.78   21.82   21.87   
	     21.90   21.92   21.94   21.101  21.105  21.107  21.108  21.112  21.114  21.118  21.119  21.120  21.122  21.124  
	     21.125  21.126  21.128  22.18   22.19   22.20   23.14   23.15   23.17   23.21   23.22   23.23   23.25   23.26   
	     23.29   23.30   23.34   23.35   23.36   23.37   23.58   23.61   23.62   23.71   23.74   23.75   23.82   23.93   
	     23.94   23.98   23.100  23.102  23.103  23.108  23.115  23.122  23.123  23.126  23.128  23.129  23.130  23.136  
	     23.141  23.142  23.143  23.146  23.148  23.149  23.150  23.154  23.159  23.160  23.161  23.164  23.166  23.167  
	     23.178  23.179  23.180  23.184  23.186  23.187  23.188  23.196  23.198  23.199  23.200  23.208  23.210  23.211  
	     23.212  23.222  23.226  23.227  23.228  23.231  23.233  23.234  23.235  23.245  23.246  23.247  23.248  23.249  
	     23.255  23.257  24.10   24.11   24.12   24.13   24.15   24.16   24.20   24.24   24.26   24.37   24.46   24.52   
	     24.61   24.63   24.65   24.67   24.68   24.69   24.70   24.80   24.81   24.82   24.83   24.84   24.93   24.96   
	     24.103  24.114  24.115  24.119  24.123  24.124  24.125  24.128  24.129  24.130  24.140  24.141  24.142  24.144  
	     24.145  24.149  24.153  24.155  24.166  24.175  24.181  24.190  24.192  24.194  24.196  24.197  24.198  24.199  
	     24.209  24.210  24.211  24.212  25.12   25.13   25.14   25.15   25.18   25.25   25.28   25.29   25.30   25.34   
	     25.37   25.38   25.52   25.62   26.12   26.29   27.14   27.19   27.22   27.26   27.34   27.62   27.66   27.71   
	     28.58   28.69   28.70   28.80   28.82   28.84   28.85   28.86   28.88   28.93   28.100  28.101  28.102  28.104  
	     28.108  28.112  28.115  28.118  28.122  28.125  28.129  28.131  28.139  28.142  28.144  28.148  28.154  28.166  
	     28.168  28.171  28.176  28.178  28.180  28.181  28.182  28.183  28.193  28.195  28.212  28.213  
	PUPDEF.MAC;11        3.23#   4.70    4.74    4.78    4.79    
	PUPPRP.MAC;4  3.21    3.31    3.40    3.45    3.52    3.54    3.55    4.28    5.4     5.16    5.24    5.35    6.9     
	      6.17    6.47    6.51    7.7     7.17    7.34    7.48    7.62    8.9     8.40    9.10    9.13    9.13    9.14    
	      9.17    9.17    9.21    9.24    9.34    9.35    9.36    9.43    9.44    9.46    9.50    9.51    9.60    9.61    
	      9.62    9.69    9.70    9.82    9.83    10.42   10.44   10.45   10.46   10.47   10.49   10.50   10.53   12.29   
	      12.30   12.47   12.48   12.50   12.51   12.52   13.20   13.25   13.35   
	PUPSEQ.MAC;35        3.54    3.56    3.69    3.70    3.72    3.74    3.88    3.89    4.24    4.26    4.47    4.51    
	     4.53    4.54    4.55    4.62    4.86    4.108   4.109   4.116   4.117   4.165   4.170   4.171   4.176   4.177   
	     4.178   5.10    5.11    5.12    5.16    5.19    5.22    5.28    5.32    5.33    5.69    5.92    5.109   5.113   
	     5.114   5.115   5.116   6.10    6.13    6.18    6.19    6.23    6.28    6.28    6.29    6.33    6.34    7.10    
	     7.11    7.13    7.15    7.28    7.36    7.37    7.38    7.39    7.41    8.20    8.29    8.31    8.33    8.34    
	     8.44    8.46    8.81    8.92    8.112   8.116   8.119   9.18    9.19    9.21    9.22    9.24    9.25    9.27    
	     9.28    9.29    9.34    9.41    9.47    9.53    10.19   10.25   10.27   10.35   10.37   10.42   10.47   10.57   
	     10.59   10.64   10.66   10.72   10.74   10.77   10.79   10.83   10.99   10.101  10.105  10.107  10.125  10.127  
	     10.128  10.136  10.140  10.145  10.149  10.149  10.150  10.152  10.155  10.155  10.158  11.18   11.21   11.24   
	     11.28   11.36   11.40   11.41   11.52   11.53   11.54   11.55   11.63   11.69   11.75   11.79   11.83   11.83   
	     11.84   11.85   11.86   11.87   11.88   11.89   11.95   11.96   11.97   11.98   11.119  11.120  11.124  11.125  
	     11.126  11.127  11.128  11.137  11.138  11.139  11.141  11.142  11.146  11.148  11.151  11.153  11.154  11.160  
	     11.163  11.168  11.173  11.176  11.177  11.179  11.181  11.182  11.183  11.184  11.191  11.192  11.193  11.194  
	     11.196  11.197  11.201  11.203  11.206  11.208  11.209  11.212  11.217  11.220  11.225  11.226  11.230  11.234  
	     11.236  11.237  11.240  11.241  11.242  11.248  11.251  11.252  11.259  11.260  11.266  11.267  11.268  11.273  
	     11.274  11.280  11.281  11.282  11.290  11.303  11.314  11.317  11.327  11.330  11.334  11.336  11.339  11.363  
	     11.364  11.376  11.380  11.390  11.395  11.398  11.401  11.404  11.407  12.19   12.20   12.27   12.34   12.42   
	     12.45   12.65   12.67   12.76   12.79   12.83   12.90   12.93   12.94   12.99   12.107  12.108  12.115  12.117  
	     12.122  12.123  12.132  12.133  12.134  12.152  12.155  12.159  12.160  12.163  12.164  12.165  12.174  12.175  
	     12.176  12.177  12.178  12.182  12.183  12.184  12.187  12.188  12.189  12.190  12.193  12.199  12.204  12.209  
	     12.221  12.225  12.235  12.238  12.240  12.247  12.252  12.253  12.270  12.287  12.288  12.289  12.290  12.291  
	     12.294  12.310  12.311  12.312  12.371  13.18   13.22   13.70   13.71   13.75   13.82   13.84   13.85   13.93   
	     13.97   13.103  13.104  13.112  13.113  13.122  13.123  13.124  13.125  13.128  13.129  13.140  13.142  
                                   28-Jul-82 17:31     Page 7.27

	PUPUUO.MAC;7  3.16    3.19    3.24    3.28    3.29    3.30    3.55    3.62    3.68    3.69    3.70    3.72    3.77    
	      4.6     4.7     4.8     4.9     4.10    4.10    4.11    4.17    4.20    4.21    4.26    4.30    4.37    4.38    
	      4.39    4.40    4.45    4.46    4.48    4.51    4.56    5.6     5.11    5.13    5.14    5.15    5.19    6.16    
	      6.17    6.18    6.19    6.20    6.26    6.30    6.36    6.40    6.41    6.43    6.44    6.45    6.46    6.58    
	      7.6     7.14    7.26    7.29    7.30    8.7     8.8     8.17    8.35    8.36    8.37    8.38    8.44    8.45    
	      9.7     9.10    9.12    9.13    9.16    9.19    9.21    9.22    9.24    9.26    9.31    9.32    9.38    9.44    
	      9.54    9.56    9.58    9.58    9.60    10.12   10.13   10.14   10.15   10.18   10.19   10.20   10.21   10.22   
	      10.25   10.26   10.27   10.28   10.29   10.30   10.33   10.34   10.35   10.36   10.37   10.38   10.39   10.41   
	      10.42   10.43   10.44   10.45   10.46   10.58   10.59   10.60   10.61   
	SMXACC.MAC;7  3.7#    3.16    3.17    3.18    3.19    3.23    3.25    3.26    3.32    3.33    3.35    3.36    3.41    
	      3.53    3.54    3.60    3.61    3.64    3.68    3.69    3.70    3.71    3.72    4.9     4.10    4.11    4.17    
	      4.18    4.20    4.21    4.28    4.34    4.35    4.39    4.47    4.48    4.49    4.50    4.51    4.52    4.53    
	      5.10    5.11    5.15    5.16    5.17    5.18    5.24    5.26    5.29    5.30    5.32    5.36    5.43    5.45    
	      5.48    5.52    5.53    5.54    5.55    5.56    5.59    5.60    5.66    5.72    5.73    5.74    5.75    5.76    
	      5.77    
P.    	PUPDEF.MAC;11        5.61    
P.AUTH	PUPPRP.MAC;4  4.26    
P.BYTE	PUPPRP.MAC;4  4.41    
P.CDAT	PUPPRP.MAC;4  5.26    
P.CNAM	PUPPRP.MAC;4  5.7     
P.CPSW	PUPPRP.MAC;4  5.13    
P.DEVI	PUPPRP.MAC;4  5.33    
P.DIRE	PUPPRP.MAC;4  6.7     
P.EOLC	PUPPRP.MAC;4  6.21    
P.NAMB	PUPPRP.MAC;4  6.31    
P.RDAT	PUPPRP.MAC;4  7.9     
P.SFIL	PUPPRP.MAC;4  7.15    
P.SIZE	PUPPRP.MAC;4  7.27    
P.TYPE	PUPPRP.MAC;4  7.38    
P.UACT	PUPPRP.MAC;4  8.6     8.12    8.19    8.20    
P.UNAM	PUPPRP.MAC;4  7.53    
P.UPSW	PUPPRP.MAC;4  7.59    
P.VERS	PUPPRP.MAC;4  8.33    
P.WDAT	PUPPRP.MAC;4  8.42    
P1    	PSQDEF.MAC;9  3.32#   
	PSVLEF.MAC;33        7.25    7.31    7.38    7.52    7.59    
	PUPDEF.MAC;11        3.18#   
	PUPPRP.MAC;4  3.22    4.26    4.41    5.7     5.13    5.26    5.33    6.7     6.21    6.31    7.9     7.15    7.27    
	      7.38    7.53    7.59    8.6     8.12    8.19    8.20    8.33    8.42    13.27   13.28   13.29   13.29   13.31   
	      13.32   13.33   13.41   13.45   13.46   
	PUPSEQ.MAC;35        4.91    4.93    4.123   11.18   11.19   11.20   11.22   11.23   11.33   11.38   11.40   11.191  
	     11.213  11.239  11.241  11.420  11.425  11.444  
	PUPUUO.MAC;7  10.12   10.13   10.18   10.19   10.25   10.26   10.33   10.34   10.44   10.52   10.52   
P1SKP 	PUPUUO.MAC;7  10.16   10.44#  
P2    	PSQDEF.MAC;9  3.33#   
	PSVLEF.MAC;33        7.26    7.32    7.34    7.35    7.58    8.151   8.154   8.155   8.157   10.12   10.14   10.28   
	     10.30   10.54   10.56   10.65   10.67   10.83   10.84   10.85   10.88   10.89   10.92   10.119  10.121  10.139  
	     10.141  11.9    11.11   11.51   11.53   15.9    16.11   16.21   16.24   16.32   16.34   17.10   17.20   17.24   
	     17.27   18.8    19.6    19.7    19.8    20.5    21.69   21.75   21.77   21.79   21.102  21.103  21.106  21.111  
	     21.113  
	PUPDEF.MAC;11        3.19#   
	PUPPRP.MAC;4  13.21   13.35   
	PUPSEQ.MAC;35        11.429  11.434  
                                   28-Jul-82 17:31     Page 7.28

	PUPUUO.MAC;7  10.20   10.27   10.35   10.43   
P2SKP 	PUPUUO.MAC;7  10.23   10.43#  
P3    	PSQDEF.MAC;9  3.34#   
	PSVLEF.MAC;33        11.10   11.11   11.12   11.15   11.33   11.39   11.48   11.59   11.64   11.87   12.262  12.265  
	     12.270  12.280  12.282  12.289  20.4    20.5    20.8    20.11   20.23   20.24   21.101  21.102  21.108  21.119  
	     21.121  21.125  21.128  
	PUPDEF.MAC;11        3.20#   
	PUPUUO.MAC;7  10.28   10.36   10.42   
P3SKP 	PUPUUO.MAC;7  10.31   10.42#  
P4    	PSQDEF.MAC;9  3.35#   
	PSVLEF.MAC;33        7.27    7.36    7.57    8.29    
	PUPDEF.MAC;11        3.21#   
	PUPUUO.MAC;7  10.37   10.41   
P5    	PSQDEF.MAC;9  3.36#   
	PSVLEF.MAC;33        7.34    8.154   
PAC   	PLFSUP.MAC;3  3.32    4.7     4.8     4.9     4.14    4.18    
PACKET	PUPSEQ.MAC;35        8.75    9.58    10.45   12.251  
PARMLF	PSVLEF.MAC;33        7.84    19.4#   
PASSWO	PUPDEF.MAC;11        5.38    5.52    
PB    	PSQDEF.MAC;9  3.30#   
	PSVLEF.MAC;33        25.46   25.47   
	PUPSEQ.MAC;35        3.28    3.29    3.30    3.33    3.34    3.35    3.36    3.39    3.40    3.41    3.44    3.45    
	     3.46    3.49    5.10    5.24    5.25    5.98    5.99    5.108   5.114   6.10    6.16    6.19    6.24    6.24    
	     6.29    7.13    7.16    7.17    7.17    7.20    7.32    7.37    8.59    10.120  11.137  11.143  11.166  11.183  
	     11.192  11.198  11.218  11.227  11.227  11.228  11.232  11.240  12.134  12.135  12.140  12.175  12.247  12.248  
	     12.252  12.270  12.288  12.290  12.310  12.324  12.328  12.335  12.338  12.346  12.352  
PBCONT	PUPSEQ.MAC;35        3.52#   5.98    5.99    
PBHEAD	PSVLEF.MAC;33        3.35    25.46   25.47   
	PUPSEQ.MAC;35        3.27#   3.28    3.29    3.30    3.33    3.34    3.35    3.36    3.39    3.40    3.41    3.44    
	     3.45    3.46    3.49    3.52    10.120  11.143  11.162  11.165  11.166  11.218  11.249  12.140  12.248  12.324  
	     12.328  12.335  12.338  12.346  12.352  
PBLINK	PUPSEQ.MAC;35        3.23#   
PBOUT 	PUPUUO.MAC;7  3.51    3.53    
PBSTAT	PUPSEQ.MAC;35        3.24#   
PDLOVF	PUPSEQ.MAC;35        13.33   13.50#  
PLDISP	PSVLEF.MAC;33        23.16   23.40#  23.49   23.252  
	PUPPRP.MAC;4  3.39    4.9#    4.11    
PLFDEF	PLFDEF.MAC;5  1.4     
	PLFSUP.MAC;3  3.5     
	PSVLEF.MAC;33        3.3     
PLSIZE	PUPDEF.MAC;11        5.62#   5.62    5.64#   
PLST  	PUPDEF.MAC;11        6.29    
PMADR 	PSVLEF.MAC;33        3.39    3.40    24.32   24.33   24.34   24.35   24.36   24.42   24.43   24.44   24.45   24.55   
	     24.58   24.73   24.75   24.161  24.162  24.163  24.164  24.165  24.171  24.172  24.173  24.174  24.184  24.187  
	     24.202  24.204  
PMAP  	PSVLEF.MAC;33        15.43   24.111  24.113  
	PUPSEQ.MAC;35        11.337  11.432  11.435  
PMPAG 	PSVLEF.MAC;33        3.40#   15.42   24.110  24.120  
PNAMES	PUPDEF.MAC;11        5.34#   5.66    
	PUPPRP.MAC;4  4.9     
PNOACK	PSQDEF.MAC;9  3.102#  
POINT 	PLFSUP.MAC;3  7.8     7.14    7.40    7.43    8.8     8.17    12.28   12.40   
	PSVLEF.MAC;33        5.12    5.41    5.73    5.108   5.114   5.136   5.139   7.32    7.37    7.39    8.25    8.39    
                                   28-Jul-82 17:31     Page 7.29

	     8.151   10.169  10.183  10.192  10.195  11.69   11.82   12.17   12.18   12.45   12.63   12.76   12.84   12.95   
	     12.104  12.110  12.145  12.192  12.201  12.206  12.238  12.262  12.265  15.16   15.17   16.44   16.56   17.21   
	     17.62   17.70   18.31   18.33   19.17   19.20   20.12   20.15   21.80   21.81   21.84   21.88   23.57   23.70   
	     23.85   23.88   23.135  23.240  24.9    24.23   24.30   24.32   24.33   24.34   24.35   24.36   24.40   24.42   
	     24.43   24.44   24.45   24.55   24.58   24.73   24.75   24.152  24.159  24.161  24.162  24.163  24.164  24.165  
	     24.169  24.171  24.172  24.173  24.174  24.184  24.187  24.202  24.204  27.8    27.60   27.69   28.146  28.198  
	     28.207  
	PUPPRP.MAC;4  3.25    6.31    10.14   11.14   12.15   12.32   
	PUPSEQ.MAC;35        3.28    3.29    3.30    3.33    3.34    3.35    3.36    3.39    3.40    3.41    3.44    3.45    
	     3.46    3.49    4.154   
	PUPUUO.MAC;7  4.17    4.43    6.23    6.25    
	SMXACC.MAC;7  3.49    4.38    
POINTS	PUPSEQ.MAC;35        5.27    11.172  11.229  
PORT  	PUPSEQ.MAC;35        12.112# 
PP    	PUPPRP.MAC;4  4.5     4.6     
PPAUTH	PUPPRP.MAC;4  4.26#   
PPBYTE	PUPPRP.MAC;4  4.35#   
PPCDAT	PUPPRP.MAC;4  5.23#   
PPCNAM	PUPPRP.MAC;4  5.4#    
PPCPSW	PUPPRP.MAC;4  5.13#   
PPDEVI	PUPPRP.MAC;4  5.32#   
PPDIRE	PUPPRP.MAC;4  6.6#    
PPEOLC	PUPPRP.MAC;4  6.16#   
PPNAM1	PUPPRP.MAC;4  6.34#   6.58    
PPNAM2	PUPPRP.MAC;4  6.46    6.53#   
PPNAM3	PUPPRP.MAC;4  6.45    6.52    6.56#   
PPNAM4	PUPPRP.MAC;4  6.41    6.60#   
PPNAMB	PUPPRP.MAC;4  6.31#   
PPRDAT	PUPPRP.MAC;4  7.6#    
PPSFIL	PUPPRP.MAC;4  7.15#   
PPSIZE	PUPPRP.MAC;4  7.24#   
PPTYPE	PUPPRP.MAC;4  7.33#   
PPUAC1	PUPPRP.MAC;4  8.15    8.19#   
PPUACT	PUPPRP.MAC;4  8.6#    
PPUNAM	PUPPRP.MAC;4  7.48#   
PPUPD0	PSVLEF.MAC;33        3.36    
	PUPSEQ.MAC;35        3.41#   5.82    12.333  
PPUPD1	PSVLEF.MAC;33        3.36    
	PUPSEQ.MAC;35        3.44#   5.80    12.331  
PPUPDH	PSVLEF.MAC;33        3.36    
	PUPSEQ.MAC;35        3.40#   5.78    12.330  12.337  
PPUPDN	PSVLEF.MAC;33        3.36    
	PUPSEQ.MAC;35        3.39#   5.76    12.329  12.336  
PPUPSH	PSVLEF.MAC;33        3.36    25.60   
	PUPSEQ.MAC;35        3.46#   5.87    12.281  12.298  12.326  12.340  
PPUPSN	PSVLEF.MAC;33        3.36    25.59   
	PUPSEQ.MAC;35        3.45#   5.85    12.282  12.299  12.325  12.339  
PPUPSS	PSVLEF.MAC;33        3.36    25.61   
	PUPSEQ.MAC;35        3.49#   5.89    12.254  12.279  12.327  12.344  
PPUPSW	PUPPRP.MAC;4  7.59#   
PPVERS	PUPPRP.MAC;4  8.27#   
PPWDAT	PUPPRP.MAC;4  8.39#   
PQUOTE	PUPDEF.MAC;11        5.8#    
                                   28-Jul-82 17:31     Page 7.30

	PUPPRP.MAC;4  6.36    10.17   
PRINT 	PUPDEF.MAC;11        4.27    
PROCES	PUPSEQ.MAC;35        11.403  
PROMPT	PUPDEF.MAC;11        4.52#   
PROPER	PUPDEF.MAC;11        6.29    
	PUPPRP.MAC;4  3.28    3.38    3.41    3.43    3.46    3.50    3.58    4.29    5.5     5.17    5.36    6.10    6.35    
	      6.38    7.18    7.49    7.63    8.10    
PROPL2	PSVLEF.MAC;33        21.66   21.69#  
PROPL3	PSVLEF.MAC;33        21.70   21.101# 
PROPL4	PSVLEF.MAC;33        21.80#  21.130  
PROPLF	PSVLEF.MAC;33        7.85    21.65#  
PRSATR	PSVLEF.MAC;33        12.139  12.141  12.153# 
PRSDEV	PSVLEF.MAC;33        12.23   12.39#  
PRSDIR	PSVLEF.MAC;33        12.27   12.57#  
PRSDOT	PSVLEF.MAC;33        12.29   12.69#  
PRSDRS	PSVLEF.MAC;33        12.25   12.51#  
PRSFI0	PSVLEF.MAC;33        12.18#  12.48   12.54   12.66   12.79   12.87   12.99   12.107  12.125  12.137  12.151  12.155  
PRSFI1	PSVLEF.MAC;33        12.21#  12.36   12.71   
PRSFI2	PSVLEF.MAC;33        12.35   12.186# 
PRSFI4	PSVLEF.MAC;33        12.196  12.204  12.220  12.227  12.237  12.245# 
PRSFIL	PSVLEF.MAC;33        11.54   12.9#   21.114  
PRSSMI	PSVLEF.MAC;33        12.31   12.33   12.91#  
PS%ATR	PSVLEF.MAC;33        3.33#   12.16   12.122  12.133  12.143  12.166  12.172  12.180  12.221  
PS%DEV	PSVLEF.MAC;33        3.27#   12.16   12.40   12.47   
PS%DIR	PSVLEF.MAC;33        3.28#   12.16   12.40   12.51   12.65   12.245  12.250  
PS%DRS	PSVLEF.MAC;33        3.32#   12.16   12.51   12.53   12.58   12.65   12.69   12.186  
PS%EXT	PSVLEF.MAC;33        3.30#   12.16   12.80   12.86   12.98   12.100  12.106  12.195  12.197  12.203  
PS%NAM	PSVLEF.MAC;33        3.29#   12.16   12.40   12.51   12.72   12.78   12.91   12.97   12.188  12.194  
PS%VER	PSVLEF.MAC;33        3.31#   12.16   12.124  12.136  12.150  12.221  12.226  12.236  12.243  12.266  12.351  
PSHPVR	PSQDEF.MAC;9  3.136#  
	PSVLEF.MAC;33        3.4     
	PUPSEQ.MAC;35        3.5     
PSHVAR	PSQDEF.MAC;9  3.135#  
	PSVLEF.MAC;33        3.4     
	PUPSEQ.MAC;35        3.5     
PSI   	PUPSEQ.MAC;35        13.25#  13.32   13.33   13.34   13.35   13.36   13.37   13.38   13.39   13.40   
	SMXACC.MAC;7  5.64    
PSIINI	PUPSEQ.MAC;35        4.54    13.5#   
PSIRET	PUPSEQ.MAC;35        13.110  13.114  13.133  
PSISIZ	PSQDEF.MAC;9  3.140#  
	PUPSEQ.MAC;35        12.314  12.315  13.6    13.8    
PSOUT 	PSVLEF.MAC;33        26.55   26.57   
PSQDEF	PLFSUP.MAC;3  3.5     
	PSQDEF.MAC;9  3.2     
	PSVLEF.MAC;33        3.3     
	PUPSEQ.MAC;35        3.4     
PSVDEF	SMXACC.MAC;7  3.5     
PUPBUF	PSQDEF.MAC;9  3.138#  
	PUPSEQ.MAC;35        4.18    
PUPDEF	PLFDEF.MAC;5  1.6     
	PLFSUP.MAC;3  3.5     
	PSQDEF.MAC;9  3.4     
	PSVLEF.MAC;33        3.3     
                                   28-Jul-82 17:31     Page 7.31

	PUPDEF.MAC;11        3.4     
	PUPPRP.MAC;4  3.7     
	PUPSEQ.MAC;35        3.4     
	PUPUUO.MAC;7  3.7     
	SMXACC.MAC;7  3.5     
PUPFNH	PSVLEF.MAC;33        3.37    20.63   20.64   20.74   20.75   
	PUPSEQ.MAC;35        4.129   12.103  12.284  12.301  14.10   
PUPFSK	PUPSEQ.MAC;35        4.131   12.102  12.256  12.280  12.302  14.9    
PUPFTP	PUPDEF.MAC;11        3.4     
PUPI  	PUPSEQ.MAC;35        12.218  12.239  
PUPLEN	PUPSEQ.MAC;35        3.28#   5.38    5.56    6.21    7.26    10.96   11.156  11.211  12.136  12.153  12.169  12.349  
	     12.361  
PUPNM 	PSVLEF.MAC;33        25.36   
PUPO  	PUPSEQ.MAC;35        12.167  12.368  12.369  
PUPSRV	PUPDEF.MAC;11        3.4     
PUPTCB	PUPSEQ.MAC;35        3.29#   5.40    
PUPTYP	PUPSEQ.MAC;35        3.30#   5.42    12.249  12.363  
PUPX3 	PUPSEQ.MAC;35        12.237  
PURGE 	PUPDEF.MAC;11        4.11    
QUCNT 	PSQDEF.MAC;9  3.96#   
	PSVLEF.MAC;33        6.43    
	PUPSEQ.MAC;35        5.15    
QUEMAX	PUPSEQ.MAC;35        11.35   11.43   11.346  
QUEUE 	PSVLEF.MAC;33        7.21    
QULCKR	PSQDEF.MAC;9  3.98#   3.99    
QULOCK	PSQDEF.MAC;9  3.97#   
	PUPSEQ.MAC;35        4.107   4.115   5.21    5.112   6.12    6.32    11.140  11.147  11.152  11.180  11.195  11.202  
	     11.207  11.235  12.158  
QUPTRS	PSQDEF.MAC;9  3.94#   
QUSIZE	PSQDEF.MAC;9  3.95#   
	PUPSEQ.MAC;35        5.14    
RAISEF	PUPDEF.MAC;11        3.33#   
	PUPPRP.MAC;4  3.53    5.15    5.32    6.6     6.33    6.44    7.61    8.8     10.26   
RANGE 	PUPPRP.MAC;4  4.40    
RC%AMB	PSVLEF.MAC;33        10.49   10.111  
RC%EMO	PLFSUP.MAC;3  6.20    6.39    
	PSVLEF.MAC;33        10.45   10.108  
RC%NOM	PLFSUP.MAC;3  6.23    
	PSVLEF.MAC;33        10.49   10.111  
RCDIR 	PLFSUP.MAC;3  6.21    
	PSVLEF.MAC;33        10.109  
RCUSR 	PLFSUP.MAC;3  6.40    
	PSVLEF.MAC;33        10.47   
RCVD  	PUPSEQ.MAC;35        12.370  
RDAT  	PUPDEF.MAC;11        5.45    
READ  	PUPDEF.MAC;11        5.45    
	PUPPRP.MAC;4  7.8     
READER	PSVLEF.MAC;33        16.20   16.95#  
READL1	PSVLEF.MAC;33        16.33   16.36#  16.65   
READL2	PSVLEF.MAC;33        16.8    16.11#  
READLF	PSVLEF.MAC;33        7.79    16.7#   
RECEIV	PSVLEF.MAC;33        11.8    15.8    16.10   17.9    18.7    19.5    20.29   21.68   
	PUPSEQ.MAC;35        10.45   
                                   28-Jul-82 17:31     Page 7.32

RECV  	PUPSEQ.MAC;35        8.72    8.75    
RECVSQ	PSQDEF.MAC;9  3.77#   
	PUPSEQ.MAC;35        5.53    8.69    8.80    10.102  10.104  
REFILL	PUPPRP.MAC;4  3.31    
RELEAS	PSVLEF.MAC;33        7.65    12.322  15.34   
RELOC 	PUPSEQ.MAC;35        13.27   13.42   
	PUPUUO.MAC;7  3.21    
RELSEQ	PUPSEQ.MAC;35        7.9#    8.112   
RELSQ0	PUPSEQ.MAC;35        7.17#   7.29    
RELSQ1	PUPSEQ.MAC;35        7.21    7.25    7.31#   
RENA  	PUPDEF.MAC;11        6.33    
RENAME	PUPDEF.MAC;11        6.33    
REPEAT	PUPSEQ.MAC;35        5.49    
RESET 	PSVLEF.MAC;33        4.4     20.53   20.77   
RESTAR	PSVLEF.MAC;33        4.41    
	PUPSEQ.MAC;35        9.69    13.96   
RESTLF	PSVLEF.MAC;33        7.81    20.4#   
RET   	PLFSUP.MAC;3  3.35    10.52   11.36   11.47   12.59   13.12   15.24   
	PUPDEF.MAC;11        4.79#   
RETERR	PLFSUP.MAC;3  3.30#   10.29   10.35   13.44   
RETGD 	PLFSUP.MAC;3  3.37#   9.34    9.56    10.19   13.48   
RETHDL	PUPSEQ.MAC;35        9.52#   9.59    9.65    
RETR  	PUPDEF.MAC;11        6.19    
RETRIE	PUPDEF.MAC;11        6.19    6.35    
RFACS 	SMXACC.MAC;7  5.37    
RFSTS 	SMXACC.MAC;7  5.38    
RIFSS1	PSVLEF.MAC;33        5.78#   5.80    
RIFSS2	PSVLEF.MAC;33        5.76    5.82#   
RIFSST	PSVLEF.MAC;33        5.69#   10.13   10.29   10.55   10.66   10.91   10.120  10.140  11.52   21.78   21.105  21.112  
RLJFN 	PSVLEF.MAC;33        7.111   7.112   12.321  12.361  12.370  12.389  15.33   18.24   18.29   27.49   
	PUPSEQ.MAC;35        11.445  
	SMXACC.MAC;7  5.46    
RMAI  	PUPDEF.MAC;11        6.35    
RNERR 	PUPUUO.MAC;7  4.29    5.12    5.22    
RNSTAT	PUPUUO.MAC;7  4.28    5.9     5.21    
RNTACS	PUPSEQ.MAC;35        12.194  12.195  12.196  12.207  14.3    
RNTPDL	PUPSEQ.MAC;35        12.193  12.209  12.316  13.9    
RNTS4A	PUPSEQ.MAC;35        12.256# 12.258  
RNTS4B	PUPSEQ.MAC;35        12.265# 12.267  
RNTS4C	PUPSEQ.MAC;35        12.266  12.274# 
RNTS4D	PUPSEQ.MAC;35        12.257  12.297# 
RNTS4E	PUPSEQ.MAC;35        12.301# 12.305  
RNTS4F	PUPSEQ.MAC;35        12.303  12.309# 
RNTS4G	PUPSEQ.MAC;35        12.261# 12.306  
RNTS4X	PUPSEQ.MAC;35        12.263  12.270# 
RNTSRV	PUPSEQ.MAC;35        12.193# 12.239# 13.32   
RNTSTK	PUPSEQ.MAC;35        12.314  13.8    
RNTSV0	PUPSEQ.MAC;35        12.203# 12.205  
RNTSV1	PUPSEQ.MAC;35        12.199  12.204  12.213# 12.222  12.228  
RNTSV2	PUPSEQ.MAC;35        12.227  12.233# 
RNTSV3	PUPSEQ.MAC;35        12.219  12.237# 
RNTSV4	PUPSEQ.MAC;35        12.221  12.247# 12.251# 
RNTSV5	PUPSEQ.MAC;35        12.200  12.207# 
                                   28-Jul-82 17:31     Page 7.33

ROOM  	PUPSEQ.MAC;35        12.370  
RPACS 	PUPSEQ.MAC;35        11.328  11.350  
RPCAP 	PUPSEQ.MAC;35        4.28    4.58    
	SMXACC.MAC;7  3.21    
RQUEU1	PUPSEQ.MAC;35        11.112# 11.113  
RQUEUE	PUPSEQ.MAC;35        11.95#  12.115  12.117  
RQUEUX	PUPSEQ.MAC;35        11.105  11.124# 
RSIN  	PSVLEF.MAC;33        16.43   24.9#   
RSIN1 	PSVLEF.MAC;33        24.25   24.38   24.49#  24.57   24.59   24.74   24.76   
RSIN2 	PSVLEF.MAC;33        24.51   24.79#  
RSIN3 	PSVLEF.MAC;33        24.56   24.61#  
RSNSEQ	PUPSEQ.MAC;35        6.10#   10.77   
RSNSQ1	PUPSEQ.MAC;35        6.19#   6.25    
RSNSQ2	PUPSEQ.MAC;35        6.24#   
RSNSQ3	PUPSEQ.MAC;35        6.20    6.28#   
RSOUT 	PSVLEF.MAC;33        17.37   24.140# 
RSOUT1	PSVLEF.MAC;33        24.154  24.167  24.178# 24.186  24.188  24.203  24.205  
RSOUT2	PSVLEF.MAC;33        24.180  24.208# 
RSOUT3	PSVLEF.MAC;33        24.185  24.190# 
RSTCON	PSVLEF.MAC;33        20.10   20.23#  
RSTHS0	PSVLEF.MAC;33        20.63#  20.72   
RSTHS1	PSVLEF.MAC;33        20.65   20.67   20.69   20.72#  
RSTHST	PSVLEF.MAC;33        20.23   20.60#  
RSTR  	PUPDEF.MAC;11        4.73#   
RSTUS0	PSVLEF.MAC;33        20.40#  20.49   
RSTUS1	PSVLEF.MAC;33        20.42   20.44   20.46   20.49#  
RSTUSR	PSVLEF.MAC;33        20.25   20.37#  
RUNF  	PUPDEF.MAC;11        3.31#   
	PUPUUO.MAC;7  3.67    4.25    
RUNM  	PUPDEF.MAC;11        4.63#   
RUNNIN	PSVLEF.MAC;33        4.44    
RXTAB 	PUPSEQ.MAC;35        4.113   14.26   
RXTIME	PUPSEQ.MAC;35        11.279  12.57   12.82   12.84   12.104  14.7    
SAVE  	PUPDEF.MAC;11        4.69#   
SAVE1 	PUPPRP.MAC;4  3.21    
	PUPUUO.MAC;7  10.12#  
SAVE2 	PUPPRP.MAC;4  13.20   
	PUPUUO.MAC;7  10.18#  
SAVE3 	PUPUUO.MAC;7  10.25#  
SAVE4 	PUPUUO.MAC;7  10.33#  
SAVJMP	PUPUUO.MAC;7  10.14   10.21   10.29   10.38   10.52#  
SC%CTC	PSVLEF.MAC;33        13.74   
SC%GTB	PSVLEF.MAC;33        13.74   
SC%LOG	PSVLEF.MAC;33        13.74   
SCNPR1	PUPPRP.MAC;4  3.31#   3.34    3.59    
SCNPR3	PUPPRP.MAC;4  3.47    3.56#   
SCNPRP	PUPPRP.MAC;4  3.21#   
SCREW1	PUPSEQ.MAC;35        13.73   13.79   13.84#  13.127  
SCREWU	PLFSUP.MAC;3  9.33    9.55    10.18   12.52   13.11   
	PSVLEF.MAC;33        4.35    7.51    25.18   25.28   25.37   
	PUPSEQ.MAC;35        8.148   8.150   11.404  13.81#  
	PUPUUO.MAC;7  7.29    7.42    7.43    7.46    7.48    7.49    7.52    7.53    7.54    7.55    7.58    7.63    7.64    
	      7.65    7.66    7.67    8.7     8.35    8.37    8.44    9.10    9.19    9.24    9.31    
                                   28-Jul-82 17:31     Page 7.34

SEARCH	PLFDEF.MAC;5  1.6     
	PLFSUP.MAC;3  3.5     3.6     3.7     
	PSQDEF.MAC;9  3.4     
	PSVLEF.MAC;33        3.3     3.6     3.7     
	PUPDEF.MAC;11        3.7     
	PUPPRP.MAC;4  3.7     3.8     
	PUPSEQ.MAC;35        3.4     3.9     3.10    
	PUPUUO.MAC;7  3.7     3.8     
	SMXACC.MAC;7  3.5     
SEND  	PUPSEQ.MAC;35        8.72    8.75    
SENDER	PUPDEF.MAC;11        5.46    
SENDIN	PSVLEF.MAC;33        8.38    
	PUPSEQ.MAC;35        9.49    
SENDSQ	PSQDEF.MAC;9  3.78#   
	PUPSEQ.MAC;35        4.99    5.55    5.60    8.70    8.91    
SENSEQ	PSVLEF.MAC;33        9.22    
	PUPSEQ.MAC;35        4.176   5.10#   9.34    9.47    10.25   10.35   10.57   10.64   10.72   10.99   12.187  13.140  
SENSQ1	PUPSEQ.MAC;35        5.34    5.37#   
SENSQ2	PUPSEQ.MAC;35        5.67    5.73#   
SENSQ3	PUPSEQ.MAC;35        5.108#  6.23    
SENSQ4	PUPSEQ.MAC;35        5.61    5.65#   
SENSQ5	PUPSEQ.MAC;35        5.93    5.101#  
SEQACK	PSQDEF.MAC;9  3.50#   
	PUPSEQ.MAC;35        10.71   10.89   
SEQALC	PUPSEQ.MAC;35        3.33#   5.52    8.88    
SEQALL	PSQDEF.MAC;9  3.80#   
	PUPSEQ.MAC;35        4.120   5.50    8.89    12.145  12.356  
SEQBRK	PSQDEF.MAC;9  3.55#   
SEQBRO	PSQDEF.MAC;9  3.61#   
	PUPSEQ.MAC;35        9.33    10.24   12.357  13.138  
SEQCHK	PSQDEF.MAC;9  3.53#   
SEQCLD	PSQDEF.MAC;9  3.57#   
	PUPSEQ.MAC;35        10.94   
SEQCLS	PSQDEF.MAC;9  3.56#   
	PUPSEQ.MAC;35        8.63    10.91   
SEQCON	PUPSEQ.MAC;35        3.35#   5.73    8.60    10.5    10.90   12.261  12.358  
SEQDAL	PSQDEF.MAC;9  3.59#   
	PUPSEQ.MAC;35        10.34   10.56   
SEQDAT	PSQDEF.MAC;9  3.49#   
	PUPSEQ.MAC;35        5.68    8.64    9.64    10.6    
SEQDES	PSQDEF.MAC;9  3.58#   
SEQFNH	PSQDEF.MAC;9  3.85#   
	PUPSEQ.MAC;35        4.130   4.134   4.145   5.75    5.77    
SEQFSK	PSQDEF.MAC;9  3.86#   
	PUPSEQ.MAC;35        4.132   4.141   4.142   5.79    
SEQINI	PSVLEF.MAC;33        4.43    
	PUPSEQ.MAC;35        4.12#   
SEQLNH	PSQDEF.MAC;9  3.83#   
	PUPSEQ.MAC;35        4.126   4.143   4.155   5.84    5.86    
SEQLSK	PSQDEF.MAC;9  3.84#   
	PUPSEQ.MAC;35        4.127   5.88    
SEQNOP	PSQDEF.MAC;9  3.51#   
	PUPSEQ.MAC;35        5.70    12.186  
                                   28-Jul-82 17:31     Page 7.35

SEQOPN	PSQDEF.MAC;9  3.54#   
	PUPSEQ.MAC;35        4.175   5.72    8.61    10.7    12.262  
SEQOUT	PSQDEF.MAC;9  3.89#   
	PUPSEQ.MAC;35        8.97    8.98    8.108   8.109   8.113   8.118   8.120   8.122   12.148  12.173  
SEQQUI	PSQDEF.MAC;9  3.60#   
	PUPSEQ.MAC;35        10.31   10.63   
SEQREC	PUPSEQ.MAC;35        3.34#   5.54    8.74    8.90    8.111   12.347  12.354  
SEQRES	PSQDEF.MAC;9  3.52#   
	PUPSEQ.MAC;35        8.107   9.46    9.66    
SEQSEN	PUPSEQ.MAC;35        3.36#   5.65    7.22    8.73    8.79    12.348  12.353  
SEQSTA	PSQDEF.MAC;9  3.79#   
	PSVLEF.MAC;33        14.28   20.27   20.48   20.71   
	PUPSEQ.MAC;35        5.71    8.127   9.39    10.15   10.40   10.54   10.86   10.93   10.154  12.52   12.86   12.89   
	     12.234  
SEQTYP	PSQDEF.MAC;9  3.66#   
	PUPSEQ.MAC;35        5.41    12.250  12.362  
SEQUIN	PUPSEQ.MAC;35        9.37    9.49    12.251  12.292  12.370  
SERVER	PSVLEF.MAC;33        4.41    4.44    7.5     
	PUPDEF.MAC;11        5.47    
	PUPSEQ.MAC;35        4.12    4.22    4.25    4.46    4.50    4.65    4.80    4.92    4.128   4.163   11.375  12.106  
	     12.142  12.181  12.197  12.214  12.220  13.96   13.145  13.147  
SERVF 	PUPDEF.MAC;11        3.30#   
	PUPUUO.MAC;7  8.13    
SETSIZ	PSVLEF.MAC;33        13.141# 
SETSZ1	PSVLEF.MAC;33        13.149  13.162# 
SFACS 	PUPSEQ.MAC;35        11.360  
	SMXACC.MAC;7  5.31    
SFIL  	PUPDEF.MAC;11        5.47    
SFNSTL	PUPDEF.MAC;11        5.6#    5.47    
	PUPPRP.MAC;4  7.16    
SFORK 	PUPSEQ.MAC;35        11.362  
SFRKV 	SMXACC.MAC;7  5.33    
SFTEMP	PLFSUP.MAC;3  8.17    8.23    16.4    
SFUST 	PLFSUP.MAC;3  8.37    
SGLEAF	PUPSEQ.MAC;35        10.127  10.135# 
SGLF1 	PUPSEQ.MAC;35        10.143# 
SGLF1A	PUPSEQ.MAC;35        10.146# 10.159  
SHORT 	PUPSEQ.MAC;35        12.92   
SHOULD	PSVLEF.MAC;33        7.50    
SHRTD 	PLFDEF.MAC;5  1.70#   
	PSVLEF.MAC;33        6.41    6.50    
SHXFLG	PUPDEF.MAC;11        3.34#   
SHXINT	PUPDEF.MAC;11        5.22#   
SIGCHN	PSQDEF.MAC;9  3.141#  
	PSVLEF.MAC;33        6.14    
	PUPSEQ.MAC;35        10.138  
SIR   	PSVLEF.MAC;33        6.12    
	PUPSEQ.MAC;35        13.12   
SIXBIT	PSVLEF.MAC;33        4.18    
	PUPSEQ.MAC;35        4.147   
SIZE  	PUPDEF.MAC;11        3.48    3.48    3.49    3.49    3.50    3.50    3.51    3.51    5.36    5.48    5.48    5.60    
	     5.62    
	PUPPRP.MAC;4  4.4     4.37    4.40    7.26    
                                   28-Jul-82 17:31     Page 7.36

SIZEF 	PSVLEF.MAC;33        12.294  17.93   23.152  
SK2RET	PUPPRP.MAC;4  10.54   
	PUPUUO.MAC;7  6.47    10.59#  
SK3RET	PUPUUO.MAC;7  10.58#  
SKPIR 	PUPSEQ.MAC;35        3.62    3.81    
SKPRET	PLFSUP.MAC;3  3.39    5.11    5.16    5.29    5.34    6.16    6.26    9.25    10.33   10.36   10.49   13.28   13.61   
	      13.66   14.10   15.49   
	PSVLEF.MAC;33        12.354# 12.363  12.372  12.395  12.409  12.416  17.85   17.90   17.106  17.111  
	PUPPRP.MAC;4  3.36    4.30    4.42    5.8     5.18    5.27    5.37    6.11    6.22    6.62    7.10    7.19    7.28    
	      7.39    7.54    7.64    8.22    8.34    8.43    9.18    9.25    9.47    9.85    10.31   10.51   11.38   13.38   
	PUPUUO.MAC;7  10.60#  
SMAI  	PUPDEF.MAC;11        6.34    
SMON  	PLFSUP.MAC;3  5.14    
SNDNOP	PUPSEQ.MAC;35        12.79   12.181# 
SNDPP1	PUPSEQ.MAC;35        12.145# 12.166  
SNDPP2	PUPSEQ.MAC;35        12.171  12.174# 
SNDPUP	PUPSEQ.MAC;35        5.109   12.132# 
SNDR  	PUPDEF.MAC;11        5.46    
SNDTMP	PUPSEQ.MAC;35        14.18   
SOCKET	PUPSEQ.MAC;35        4.46#   4.50#   13.145# 
SOUT  	PSVLEF.MAC;33        26.38   27.57   
	PUPUUO.MAC;7  8.31    9.37    
SPACS 	PSVLEF.MAC;33        24.122  
	PUPSEQ.MAC;35        11.353  
SPJFN 	PSVLEF.MAC;33        4.26    
SQ    	PSQDEF.MAC;9  3.28#   
	PSVLEF.MAC;33        6.37    6.42    6.53    7.18    7.54    20.27   
	PUPSEQ.MAC;35        4.90    4.95    4.96    4.97    4.98    4.99    4.106   4.114   4.120   4.126   4.127   4.130   
	     4.132   4.134   4.138   4.139   4.141   4.142   4.143   4.145   4.155   5.13    5.23    5.50    5.53    5.55    
	     5.60    5.71    5.75    5.77    5.79    5.84    5.86    5.88    5.111   6.11    6.16    6.17    6.31    7.16    
	     7.18    7.31    8.23    8.26    8.40    8.69    8.70    8.80    8.89    8.91    8.97    8.98    8.108   8.109   
	     8.113   8.120   8.122   8.127   9.39    10.15   10.40   10.54   10.86   10.93   10.102  10.104  10.119  10.135  
	     10.154  11.319  11.378  12.33   12.52   12.86   12.89   12.110  12.114  12.116  12.141  12.145  12.148  12.157  
	     12.173  12.203  12.215  12.234  12.275  12.276  12.277  12.277  12.278  12.286  12.309  13.139  
SQBLEN	PSQDEF.MAC;9  3.91#   
	PUPSEQ.MAC;35        4.98    12.276  14.28   
SQBTAB	PUPSEQ.MAC;35        12.277  14.28   
SQCHNG	PUPSEQ.MAC;35        8.85    9.63#   9.69#   
SQDUPL	PUPSEQ.MAC;35        8.84    8.95    9.57#   9.58#   
SQFAIL	PUPSEQ.MAC;35        8.82    8.93    9.32#   9.37#   10.88   10.112  
SQJFNX	PSQDEF.MAC;9  3.87#   
	PUPSEQ.MAC;35        4.138   4.139   12.110  12.141  12.215  12.286  
SQRQRE	PUPSEQ.MAC;35        8.83    9.45#   9.49#   
SQRTRN	PSQDEF.MAC;9  3.154#  
	PUPSEQ.MAC;35        6.15    6.30    12.150  12.172  
SQRXCU	PSQDEF.MAC;9  3.82#   
	PSVLEF.MAC;33        6.42    7.18    7.54    
	PUPSEQ.MAC;35        4.114   8.26    10.119  12.116  
SQTIME	PSQDEF.MAC;9  3.88#   
	PUPSEQ.MAC;35        8.23    8.40    
SQTMIN	PSQDEF.MAC;9  3.122#  
	PUPSEQ.MAC;35        8.22    
SQTXCU	PSQDEF.MAC;9  3.81#   
                                   28-Jul-82 17:31     Page 7.37

	PUPSEQ.MAC;35        4.106   5.13    5.23    5.111   6.11    6.16    6.17    6.31    7.16    7.18    7.31    12.114  
	     12.157  
SRVCRS	PSVLEF.MAC;33        6.8     7.3#    
SRVJFN	PUPSEQ.MAC;35        4.52    4.64    4.93    12.143  12.213  12.285  12.341  12.364  13.143  
SRVSTT	PSVLEF.MAC;33        4.3#    
	PUPSEQ.MAC;35        13.95   13.98   13.149  
STACK 	PSVLEF.MAC;33        4.12    29.19   
START 	PSVLEF.MAC;33        4.4#    29.24   
STATE 	PUPSEQ.MAC;35        10.45   
STATTB	PUPSEQ.MAC;35        8.128   8.135#  
STBROK	PUPSEQ.MAC;35        8.138   10.23#  
STCLOS	PUPSEQ.MAC;35        8.135   10.5#   
STCMP 	PLFSUP.MAC;3  11.31   
STDIR 	PLFSUP.MAC;3  6.11    
	PSVLEF.MAC;33        10.18   10.97   
STDLLY	PUPSEQ.MAC;35        8.137   10.30#  
STDLY1	PUPSEQ.MAC;35        10.32   10.39#  
STDSTR	PUPSEQ.MAC;35        8.139   10.45#  10.45#  
STENEX	PLFSUP.MAC;3  3.6     
	PSVLEF.MAC;33        3.6     
	PUPSEQ.MAC;35        3.9     
	SMXACC.MAC;7  3.5     
STFNTM	PUPSEQ.MAC;35        11.302# 
STKSIZ	PSQDEF.MAC;9  3.139#  
	PSVLEF.MAC;33        3.21#   4.12    29.19   
STLCTM	PSVLEF.MAC;33        19.16   
	PUPSEQ.MAC;35        11.289# 
STOPEN	PUPSEQ.MAC;35        8.136   10.9    10.19#  
STOR  	PUPDEF.MAC;11        6.20    
STORE 	PUPDEF.MAC;11        6.20    6.27    6.34    
STOTIM	PSVLEF.MAC;33        28.80#  28.112  28.115  28.118  28.122  
STRCM1	PSVLEF.MAC;33        5.140#  5.156   
STRCMP	PSVLEF.MAC;33        5.132#  10.70   
STRING	PUPDEF.MAC;11        4.47    4.48    4.49    4.50    4.51    4.52    4.53    4.54    4.55    4.56    4.58    4.63    
STRXTM	PUPSEQ.MAC;35        10.19   11.273# 12.83   
STTIMD	PUPSEQ.MAC;35        8.140   10.8    10.14#  
STTXTM	PUPSEQ.MAC;35        11.259# 12.76   12.174  
SUBR  	PSVLEF.MAC;33        7.69    7.70    7.70    7.71    
SUBTTL	PLFDEF.MAC;5  1.5     
	PLFSUP.MAC;3  3.3     
	PSQDEF.MAC;9  3.3     
	PSVLEF.MAC;33        3.2     4.1     5.1     6.1     8.1     9.1     10.1    11.1    12.1    13.1    14.1    15.1    
	     16.1    17.1    18.1    19.1    20.1    21.1    22.1    23.2    24.1    28.2    
	PUPDEF.MAC;11        3.5     
	PUPPRP.MAC;4  3.5     
	PUPSEQ.MAC;35        3.3     4.1     5.1     6.1     7.1     8.1     9.1     11.1    12.1    13.1    14.1    
	PUPUUO.MAC;7  3.5     
	SMXACC.MAC;7  3.3     
SUMEX 	PLFSUP.MAC;3  3.9     3.9#    3.22    
SYM   	PUPDEF.MAC;11        5.60    6.43    6.47    
	PUPPRP.MAC;4  4.4     4.5     
SYSDEF	PUPDEF.MAC;11        3.7     
SYSGT 	PSVLEF.MAC;33        4.19    
                                   28-Jul-82 17:31     Page 7.38

	PUPSEQ.MAC;35        4.148   
TEMP  	PSVLEF.MAC;33        8.48    8.58    10.11   10.17   10.27   10.35   10.46   10.53   10.61   10.62   10.64   10.68   
	     10.69   10.90   10.118  10.138  10.169  10.172  10.176  10.177  10.179  10.183  10.186  10.192  10.195  10.217  
	     11.50   12.17   12.18   12.45   12.63   12.76   12.84   12.95   12.104  12.110  12.145  12.192  12.201  12.206  
	     12.238  12.303  12.324  12.338  13.33   13.49   16.30   21.110  28.124  28.130  28.132  28.143  28.158  28.160  
	     28.167  28.173  28.177  29.3    
	PUPPRP.MAC;4  3.42    9.80    9.84    10.43   10.48   
	PUPSEQ.MAC;35        8.71    8.76    13.76   13.78   13.120  13.126  
TEMP2 	PSVLEF.MAC;33        21.76   21.80   21.81   21.86   21.104  29.4    
TEMPF1	PSQDEF.MAC;9  3.46#   
	PSVLEF.MAC;33        17.29   17.42   17.46   
	PUPSEQ.MAC;35        5.101   5.110   6.14    10.122  10.126  
TEMPF2	PSQDEF.MAC;9  3.47#   
	PSVLEF.MAC;33        17.107  17.125  
TENEX 	PLFSUP.MAC;3  3.6     3.21    5.8     5.26    6.8     6.35    8.15    9.21    9.45    10.8    13.25   13.58   14.6    
	PSVLEF.MAC;33        3.6     4.15    
	PUPDEF.MAC;11        3.42#   
	PUPSEQ.MAC;35        3.9     11.315  13.147  
	PUPUUO.MAC;7  9.49    
TERM  	PUPSEQ.MAC;35        12.92   
TIMALT	PSVLEF.MAC;33        16.73#  28.86   
TIMD  	PSQDEF.MAC;9  3.74#   
	PSVLEF.MAC;33        14.29   
	PUPSEQ.MAC;35        12.56   12.85   
TIME  	PSVLEF.MAC;33        4.51    6.38    6.47    26.47   27.10   27.63   
	PUPSEQ.MAC;35        8.21    8.39    10.143  10.151  11.261  11.275  12.66   12.77   13.88   
TIMED 	PUPSEQ.MAC;35        12.70   
TIMEOU	PUPSEQ.MAC;35        12.92   
TIMTNX	PSVLEF.MAC;33        16.75   16.85#  
TITLE 	PLFSUP.MAC;3  3.2     
	PSVLEF.MAC;33        3.1     
	PUPPRP.MAC;4  3.4     
	PUPSEQ.MAC;35        3.2     
	PUPUUO.MAC;7  3.4     
	SMXACC.MAC;7  3.2     
TMPREC	PUPSEQ.MAC;35        8.59    12.217  12.224  12.248  12.324  12.335  12.346  14.19   
TO    	PSVLEF.MAC;33        12.322  12.325  15.15   15.34   
	PUPDEF.MAC;11        3.4     
	PUPSEQ.MAC;35        3.79    3.83    4.46    4.50    4.166   5.27    11.403  13.145  
	SMXACC.MAC;7  5.64    
TOO   	PUPPRP.MAC;4  6.42    6.55    
	PUPSEQ.MAC;35        13.92   
TOPPVR	PLFSUP.MAC;3  3.11    
	PSQDEF.MAC;9  3.133#  
	PSVLEF.MAC;33        3.4     
	PUPSEQ.MAC;35        3.5     
	PUPUUO.MAC;7  3.12    
TOPS20	PLFSUP.MAC;3  3.7     3.17    5.13    5.31    6.18    6.38    8.35    9.4     9.27    9.49    10.12   11.2    12.2    
	      13.7    13.30   13.63   14.13   15.2    16.8    
	PSVLEF.MAC;33        3.7     4.30    12.285  
	PUPDEF.MAC;11        3.40#   
	PUPSEQ.MAC;35        3.10    
	PUPUUO.MAC;7  9.53    
                                   28-Jul-82 17:31     Page 7.39

TOPVAR	PLFSUP.MAC;3  3.11    
	PSQDEF.MAC;9  3.132#  
	PSVLEF.MAC;33        3.4     
	PUPSEQ.MAC;35        3.5     
	PUPUUO.MAC;7  3.12    
TRUNLF	PSVLEF.MAC;33        7.78    
TXTAB 	PUPSEQ.MAC;35        4.105   14.25   
TXTIME	PUPSEQ.MAC;35        11.265  12.75   12.78   12.105  14.8    
TYPE  	PSVLEF.MAC;33        7.108   7.112   
	PUPDEF.MAC;11        4.49#   4.58    4.63    4.64    5.49    5.49    6.43    6.47    
	PUPPRP.MAC;4  7.35    7.36    
	PUPSEQ.MAC;35        3.63    3.79    3.83    12.239  13.147  
TYPTAB	PUPPRP.MAC;4  7.33    7.41#   
UACBLK	SMXACC.MAC;7  3.27    3.28    3.28    3.29    3.37    3.45    3.49    3.63    4.12    4.13    4.13    4.14    4.22    
	      4.26    4.37    4.38    6.3#    
UACT  	PUPDEF.MAC;11        5.50    
UDTYPE	PUPDEF.MAC;11        4.29    4.50    
UELOG 	PUPDEF.MAC;11        4.36    4.48    
UERROR	PUPDEF.MAC;11        4.40    4.53    
UFTPM 	PUPDEF.MAC;11        4.31    4.60    
ULKLOG	PSVLEF.MAC;33        26.60   27.25#  27.62   27.71   
ULOG  	PUPDEF.MAC;11        4.35    4.47    
UNABLE	PUPSEQ.MAC;35        13.145  
UNAM  	PUPDEF.MAC;11        5.51    
UNEXPE	PSVLEF.MAC;33        12.295  
UNIVER	PLFDEF.MAC;5  1.4     
	PSQDEF.MAC;9  3.2     
	PUPDEF.MAC;11        3.4     
UNLCK0	PSVLEF.MAC;33        14.17#  14.39   
UNLCK1	PSVLEF.MAC;33        14.19   14.26   14.38#  
UNLCK2	PSVLEF.MAC;33        14.30   14.44#  14.50#  14.56#  
UNLCK3	PSVLEF.MAC;33        14.32#  14.51   
UNLCK4	PSVLEF.MAC;33        14.33#  14.40   
UNLOCK	PSVLEF.MAC;33        12.314  14.9#   
	PUPSEQ.MAC;35        5.113   6.33    11.148  11.181  11.203  11.236  11.395# 11.403  12.160  
UNOISE	PUPDEF.MAC;11        4.41    4.51    
UNRECO	PUPPRP.MAC;4  3.43    
UPDL  	SMXACC.MAC;7  3.16    4.9     5.76    6.4#    
UPROMP	PUPDEF.MAC;11        4.42    4.52    
UPSHJ 	PUPUUO.MAC;7  3.16    
UPSW  	PUPDEF.MAC;11        5.52    
URUNM 	PUPDEF.MAC;11        4.43    4.64    
USEACT	PLFSUP.MAC;3  12.40   13.37   13.38   13.38   13.39   13.43   13.46   16.10   
USEPSW	PLFSUP.MAC;3  11.30   12.28   16.9    
USER  	PSVLEF.MAC;33        10.151  10.157  
	PUPDEF.MAC;11        5.50    5.51    5.52    6.30    
	PUPPRP.MAC;4  7.50    7.52    8.17    
USEVAR	PLFSUP.MAC;3  3.11    
	PSVLEF.MAC;33        3.4     
	PUPDEF.MAC;11        3.47#   
	PUPSEQ.MAC;35        3.5     
	PUPUUO.MAC;7  3.12    
USRCDN	PLFSUP.MAC;3  16.3    
                                   28-Jul-82 17:31     Page 7.40

USRDGP	PLFSUP.MAC;3  12.20   12.20   12.21   12.22   12.36   12.46   16.15   
USRDIR	PLFSUP.MAC;3  12.14   12.14   12.15   12.16   12.23   12.49   16.13   
USRDPT	PLFSUP.MAC;3  12.55   16.11   
USRLGN	PLFSUP.MAC;3  16.2    
USRNUM	PLFSUP.MAC;3  3.13    13.33   15.36   
	PSVLEF.MAC;33        3.35    7.97    10.32   10.41   10.52   10.74   10.148  10.154  10.207  13.42   13.70   20.40   
	     20.41   20.51   29.16   
USRSTL	PLFSUP.MAC;3  13.39   13.47   16.2    16.3    16.4    16.5    16.6    16.9    16.10   
	PUPDEF.MAC;11        5.4#    5.6     5.35    5.38    5.40    5.41    5.46    5.50    5.52    
	PUPPRP.MAC;4  4.27    5.14    5.34    6.8     7.60    8.7     9.81    
USRUGP	PLFSUP.MAC;3  12.17   12.17   12.18   12.19   12.32   12.44   16.14   
UTYPE 	PUPDEF.MAC;11        4.28    4.49    
UUO   	PUPDEF.MAC;11        4.14#   4.27    4.28    4.29    4.30    4.31    4.35    4.36    4.40    4.41    4.42    4.43    
UUODSP	PUPUUO.MAC;7  3.16    3.27    3.36#   
UUON  	PUPDEF.MAC;11        4.15#   4.15    4.16    4.22#   
UUOS  	PUPDEF.MAC;11        4.17    4.18    4.21    
	PUPUUO.MAC;7  3.36    
UWRITE	PUPDEF.MAC;11        4.30    4.55    4.56    
VACCT 	PLFSUP.MAC;3  3.25#   13.59   13.64   
VACX1 	SMXACC.MAC;7  3.39    
VACX2 	SMXACC.MAC;7  3.67    
VERS  	PUPDEF.MAC;11        5.53    
VERSIO	PUPDEF.MAC;11        5.53    
	PUPPRP.MAC;4  8.29    8.32    
WAIT  	PSVLEF.MAC;33        6.60    
WBCPS1	PSVLEF.MAC;33        5.46#   5.49    
WBCPS2	PSVLEF.MAC;33        5.47    5.51#   
WBCPST	PSVLEF.MAC;33        5.37#   28.131  28.144  28.168  28.178  
WDAT  	PUPDEF.MAC;11        5.54    
WFORK 	SMXACC.MAC;7  5.34    
WHILE 	PUPSEQ.MAC;35        10.45   12.112  
WIFSS1	PSVLEF.MAC;33        5.17#   5.20    
WIFSS2	PSVLEF.MAC;33        5.18    5.22#   
WIFSST	PSVLEF.MAC;33        5.8#    8.36    21.87   
WILDFT	PSVLEF.MAC;33        11.23   13.52   13.54   15.31   15.52   15.55   29.10   
WITH  	PSVLEF.MAC;33        7.21    
	PUPSEQ.MAC;35        3.79    3.83    
WON   	PUPSEQ.MAC;35        10.157  
WRITE 	PSVLEF.MAC;33        8.49    10.178  12.46   12.64   12.77   12.85   12.96   12.105  12.193  12.202  12.249  12.304  
	     12.325  12.333  12.335  12.337  13.36   
	PUPDEF.MAC;11        4.54#   5.54    
	PUPPRP.MAC;4  8.41    
	PUPSEQ.MAC;35        8.72    8.75    13.77   13.121  
WRITER	PSVLEF.MAC;33        17.19   17.35   17.78#  
WRITLF	PSVLEF.MAC;33        7.80    17.7#   
WRTLDR	PSVLEF.MAC;33        15.50   28.104  28.193# 
WRTLF1	PSVLEF.MAC;33        17.62#  
X     	PUPDEF.MAC;11        5.35    5.36    5.37    5.38    5.39    5.40    5.41    5.42    5.43    5.44    5.45    5.46    
	     5.47    5.48    5.49    5.50    5.51    5.52    5.53    5.54    5.60#   
	PUPPRP.MAC;4  4.4#    
XN    	PUPDEF.MAC;11        6.19    6.20    6.23    6.24    6.25    6.27    6.28    6.29    6.30    6.31    6.32    6.33    
	     6.34    6.35    6.36    6.43#   
XS    	PUPDEF.MAC;11        6.21    6.22    6.37    6.47#   
                                   28-Jul-82 17:31     Page 7.41

XX    	PUPDEF.MAC;11        4.6     4.6     
YES   	PUPDEF.MAC;11        6.21    6.21    
YOU   	PUPDEF.MAC;11        6.30    
YUSR  	PUPDEF.MAC;11        6.30    
ZZ    	PUPDEF.MAC;11        4.59#   
