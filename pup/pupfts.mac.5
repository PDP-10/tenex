;<PUP>PUPFTS.MAC.7  10-Jul-80 13:40:36, Edit by SCHOEN
; tops20: in LOGCH7, missed a halfword directory number store from tenex
;<PUP>PUPFTS.MAC;6  7-Jul-80 13:24:22, Edit by SCHOEN
; Tops20: Added calls to CHKXX routines to check for file access priveleges
;	  for users
;<PUP>PUPFTS.MAC;5  12-Jun-80  12:42:00  Edit by Schoen
; Fixed error in LOGCH1 by which AC2 not loaded with directory number
; for ULOG which did DIRST
; Tops20 VACCT, unlike Tenex VACCT, is a +1,+2 JSYS
;<PUP>PUPFTS.MAC.4, 12-Jun-80 09:33:24, Edit by GILMURRAY
; Fixed PUSHJ's attempted to be called via CALL
; which wasn't opdefed.
;<PUP>PUPFTS.MAC;3     5-Apr-80 01:00:19    EDIT BY SCHOEN
; Add "SEARCH SYSDEF" to determine which machine we're compiling on
; Add Tops20/Tenex assembly conditionals
; (Tops20) Added simulations of GDACC, CNDIR code in file JSIM.MAC
; (Tops20) Modified FIXNAM so it uses USRCDN (in JSIM.MAC) if no directory
; 	   is specified.
;<PUP>PUPFTS.MAC;3     3/21/80			EDIT BY RINDFLEISCH
; Added simulation of VACCT and GDACC JSYSs
;<PUP>PUPFTS.MAC;2     6-Dec-79 15:59:30    EDIT BY SWEER
; removed VACCT and GDACC JSYSs
;<PUP>PUPFTS.MAC;36     4-NOV-79 12:24:55    EDIT BY TAFT
; Set creation date during [Store] if present in property list
;<PUP>PUPFTS.MAC;35     2-SEP-79 15:59:33    EDIT BY TAFT
;<PUP>PUPFTS.MAC;34    16-JAN-79 14:26:59    EDIT BY TAFT
;<PUP>PUPFTS.MAC;33     8-OCT-78 19:49:40    EDIT BY TAFT
; Rejuvenate watchdog timer in REFILL procedure so we don't get
; nailed while processing long mail distribution lists
;<PUP>PUPFTS.MAC;32     4-SEP-78 13:05:01    EDIT BY TAFT
; Add Rename error code 112
;<PUP>PUPFTS.MAC;31     4-JUL-78 16:41:36    EDIT BY TAFT
; Fix bug in Rename failure code
;<PUP>PUPFTS.MAC;30    24-MAY-78 18:26:44    EDIT BY TAFT
; Add [New-store] command
;<PUP>PUPFTS.MAC;29     3-FEB-78 19:46:55    EDIT BY TAFT
; Add distinct error code for file busy
;<PUP>PUPFTS.MAC;28    16-SEP-77 10:14:14    EDIT BY TAFT
;<PUP>PUPFTS.MAC;27     1-SEP-77 15:54:44    EDIT BY TAFT
; Make a few things internal for the mail server
;<PUP>PUPFTS.MAC;26    26-JUL-77 14:58:18    EDIT BY TAFT
; "Directory" defaults server filename to *.*;*
; Reset watchdog timer in appropriate places
;<PUP>PUPFTS.MAC;25     3-JUN-77 13:09:16    EDIT BY TAFT
; Add "Rename" command
;<PUP>PUPFTS.MAC;24    15-APR-77 09:55:20    EDIT BY TAFT
; Move some flag bits to avoid conflict with PUPDEF
; Default version to lowest in "Delete"
;<PUP>PUPFTS.MAC;23     7-APR-77 17:42:08    EDIT BY TAFT
; Zero memory cells holding JFNs when they are closed or released.
;<PUP>PUPFTS.MAC;22    31-MAR-77 21:10:00    EDIT BY TAFT
; Add hooks for mail server
;<PUP>PUPFTS.MAC;20    19-MAR-77 20:05:57    EDIT BY TAFT
; Add "Delete" command
;<PUP>PUPFTS.MAC;19    19-MAR-77 13:39:42    EDIT BY TAFT
; Fix bugs in Tenex-paged stuff
;<PUP>PUPFTS.MAC;18    18-MAR-77 19:13:59    EDIT BY TAFT
; Add REFILL procedure for property list parser
;<PUP>PUPFTS.MAC;16    18-MAR-77 17:41:10    EDIT BY TAFT
; Rip out property list parser and data transfer code --
; now share these modules with PUPFTP.
; Add checks for Tenex-paged type.
;<PUP>PUPFTS.MAC;14    17-OCT-76 00:41:41    EDIT BY TAFT
; Permit retrieving a 36-bit file with any byte size, but
; generate a suitable warning message
;<PUP>PUPFTS.MAC;13    30-JUN-76 17:21:38    EDIT BY TAFT
; Remove various utility routines to PUPUTL.MAC
;<PUP>PUPFTS.MAC;11     1-JUN-76 19:41:50    EDIT BY TAFT
; Change FIXNAM to apply generic filename properties as defaults
;<PUP>PUPFTS.MAC;8     1-JUN-76 16:43:58    EDIT BY TAFT
; "Directory" returns properties as separate commands for each file
;<PUP>PUPFTS.MAC;7    31-MAY-76 19:13:49    EDIT BY TAFT
; Include dates in retrieve property lists
;<PUP>PUPFTS.MAC;5    14-MAY-76 20:07:10    EDIT BY TAFT
; Add code to handle CLOSF failure at FTPEND
;<PUP>PUPFTS.MAC;4    27-MAR-76 18:01:12    EDIT BY TAFT
; Straighten out defaulting of account during store
;<PUP>PUPFTS.MAC;3    26-MAR-76 02:12:08    EDIT BY TAFT
; Convert lower-case password properties to upper-case

; Copyright 1979 by Xerox Corporation

	TITLE PUPFTS -- FTP SERVER FORK OF PUP SERVER
	SUBTTL E. A. Taft / October, 1975

	SEARCH SYSDEF
	SEARCH PUPDEF,PSVDEF
tenex,< SEARCH STENEX >
tops20,<SEARCH MONSYM>

	USEVAR FTPVAR,FTPPVR


; Parameters

; Herald for version reply
VERTXT:	ASCIZ /1.20 4-Nov-79/
FTPVER==1		; Protocol version implemented


; Local flags

LOGCKF==1B27		; Login parameters have been checked
ACTCKF==1B28		; Account has been checked
CONCKF==1B29		; Connect parameters have been checked
DSKDVF==1B30		; Current file is on disk

; Assemble main command dispatch table

DEFINE XN(SYM,TYPE,NAME,FLAGS) <
REPEAT TYPE-<.-MRKDSP>,<0>
IF2,<IFNDEF C.'SYM,<EXTERN C.'SYM>>
	0 ,, C.'SYM
>
DEFINE XS(SYM,TYPE,NAME,FLAGS) <
REPEAT TYPE-<.-MRKDSP>,<0>
IF2,<IFNDEF C.'SYM,<EXTERN C.'SYM>>
	0 ,, C.'SYM
>

MRKDSP::MARKS


; Assemble Mark names and flags

DEFINE XN(SYM,TYPE,NAME,FLAGS) <
REPEAT TYPE-<.-MRKNAM>,<0>
	FLAGS + [ASCIZ /NAME/]
>
DEFINE XS(SYM,TYPE,NAME,FLAGS) <
REPEAT TYPE-<.-MRKNAM>,<0>
	1B0+FLAGS + [ASCIZ /NAME/]
>

MRKNAM::MARKS

NMARKS==.-MRKNAM

; -----------------------------------------------------------------
;	Initialization, Main Loop, Termination
; -----------------------------------------------------------------

; Server fork started here
; Initialize

FTPFRK::JSYS FRKINI##		; Initialize ac's and stuff
	MOVEI A,400000		; Initialize psi system
	MOVE B,[LEVTAB##,,CHNTAB]
	SIR
	EIR
	MOVE B,[ACTCHN]		; Activate channels
	AIC

tops20,<
	MOVEI A,.FHSLF		; Tops20 FTP service must run enabled
	RPCAP			; in order to verify passwords.
	MOVE 3,2		; Corresponding change was made in 
	EPCAP			; PUPSRV to pass down wheel privs
>
	HRRZ A,FRKJFN(FX)	; Get address of foreign port
	MOVE C,[2,,C]
	GDSTS
	HRROI A,FRNHST		; Get foreign host name
	MOVE B,[1B1+1B2+C]
	SETZ D,
	PUPNM
	 PUSHJ P,SCREWUP##

; Main command loop
COMLP:	PUSHJ P,GETCMD		; Get next command
	 JRST FTPEND		; End received, close connection
	MOVE P1,MRKDSP(A)	; Get dispatch
	PUSHJ P,0(P1)		; Process the command
	JRST COMLP		; Repeat for next

; Here when End received
FTPEND::HLRZ A,FRKJFN(FX)	; Get Pup input JFN
	CLOSF			; Close it
	 PUSHJ P,SCREWUP##
	HRRZS A,FRKJFN(FX)	; Now same for output JFN
	CLOSF
	 JRST [	ELOG <Connection closed uncleanly%/ - %1J>
		HRRZ A,FRKJFN(FX)  ; Should work a second time
		CLOSF
		 HALTF
		JRST .+1]
	SETZM FRKJFN(FX)	; Note that no JFNs exist now
	HALTF			; Terminate normally

; -----------------------------------------------------------------
;	Individual command handlers
; -----------------------------------------------------------------

; "End-Of-Command"

C.EOC:	FTPM(EOC,,,1)		; Just send answering EOC


; "Version"

C.VERS:	HRROI A,VERTXT		; Give version string for text
	HRROI B,LCLHST##	; Local host name string
	FTPM(VERS,FTPVER,<%2S Pup FTP Server %1S>,1)



; Commands that should never be received at top level

C.YES:				; "Yes"
C.NO:				; "No"
C.FILE:				; "Here-is-file"
C.PLST:				; "Here-is-property-list"
	DTYPE <  - Unexpected command%/>

; Commands that are ignored

C.ABOR:				; "Abort" (no-op at top level)
C.COMM:	POPJ P,			; "Comment"


; Commands that aren't implemented yet

C.YUSR:				; "You-are-User"
	FTPM(NO,1,<Unimplemented command>,1)

; "Retrieve"

C.RETR:	SETZM FILPRP		; Clear out property list
	MOVE A,[FILPRP,,FILPRP+1]
	BLT A,FILPRP+PLSIZE-1
	HRROI A,NETBUF		; Set pointer to argument string
	MOVEI B,FILPRP		; File property list
	PUSHJ P,SCNPRP##	; Scan property list
	 POPJ P,		; Failed
	MOVEI A,FILPRP
	PUSHJ P,LOGCHK		; Check login/connect parameters
	 POPJ P,		; Failed
	MOVEI A,TEMP		; Where to build GTJFN command list
	MOVEI B,FILPRP		; Where property list is now
	PUSHJ P,FIXNAM		; Fix args, build command list
	MOVSI C,(1B2+1B11)	; Old file, permit "*"
	HLLM C,TEMP
	GTJFN			; Lookup the Server-Filename string
	 JRST RGJFER		; Failed, give reason and quit
	MOVEM A,SRCJFN##	; Ok, save source JFN and flags
tops20,<
	PUSHJ P,CHKWR##		; See if user is allowed to read this file
	 JRST C.RET8		; System says no, try another
>
	HRRZS A
	PUSHJ P,CHKDSK		; Check device type
	HRRZ A,FILPRP+P.TYPE	; Get transfer type
	CAIN A,3		; Paged?
	TRNE F,DSKDVF		; Yes, device other than disk?
	 JRST C.RET1		; No, ok
	HRRZ A,SRCJFN##		; Yes, release JFN
	RLJFN
	 PUSHJ P,SCREWUP##
	SETZM SRCJFN##
	FTPM(NO,15,<Type Tenex-Paged illegal for non-disk files>,1)

; Now have JFN (possibly indexable)
; Back here for each file referenced by the JFN
C.RET1:	MOVE A,[FILPRP,,TMPPRP]	; Copy supplied property list
	BLT A,TMPPRP+PLSIZE-1	;  into temps for this retrieval
	HRRZ A,SRCJFN##		; Get file JFN
	MOVEI B,TMPPRP		; Set pointer to property list
	PUSHJ P,CKRPAR		; Check retrieval parameters
	 JRST C.RET8		; Bad, bypass this file
	PUSHJ P,GNRPRP		; Generate property list reply

; Await "Yes" or "No" from user
C.RET2:	PUSHJ P,GETCMD		; Get next command
	 JRST [	HRRZ A,SRCJFN##	; Connection closed, release JFN
		RLJFN
		 PUSHJ P,SCREWUP##
		SETZM SRCJFN##
		JRST FTPEND]	; Handle EOF normally
	CAIN A,MKNO		; Check command
	 JRST C.RET8		; "No", skip this file
	CAIN A,MKYES
	 JRST C.RET6		; "Yes", send this file
	MOVE C,MRKNAM(A)	; Not one of those, get dispatch
	TLNN C,(OKRETR)		; Command ok in this context?
	 JRST [	HRRZ A,SRCJFN##	; No, flush file JFN
		RLJFN
		 PUSHJ P,SCREWUP##
		SETZM SRCJFN##
		HRROS C		; Make string ptr to command name
		FTPM(NO,3,<Command [%3S] out of sequence during Retrieve>,1)]
	MOVE C,MRKDSP(A)	; Ok, get command dispatch
	PUSHJ P,0(C)		; Do the command
	JRST C.RET2		; Look for another

; "Retrieve" (cont'd)

; Here when "Yes" encountered.  Now send the file.
C.RET6:	PUSHJ P,OPNRET		; Open file for retrieve
	 JRST C.RET8		; Failed
	HRRZ A,SRCJFN##		; Ok, get file JFN
	LOG <Retrieve %1F>	; Make log entry
	MOVEI A,MKFILE		; Insert "Here-Is-File" mark
	SETZ B,
	PUSHJ P,BEGCMD
	HRRZ A,FRKJFN(FX)	; Destination is net
	MOVEM A,DSTJFN##
	MOVEI A,TMPPRP		; Property list
	PUSHJ P,SNDDAT##	; Do the retrieval
	 JRST [	HRRZ A,SRCJFN##	; Data error, get JFN
		FTPM(NO,103,<Data error in %1F, Retrieve aborted>)
		JRST C.RET7]
	HRRZ A,SRCJFN##
	FTPM(YES,0,<Retrieve of %1F completed>)
C.RET7:	HRLI A,400000		; Close file, don't release JFN
	CLOSF
	 PUSHJ P,SCREWUP##

; Here when done retrieval of one file.  Check for more to do
C.RET8:	SETZM DSTJFN##
	MOVE A,SRCJFN##		; Get JFN with flags
	GNJFN			; Step to next file if any
	 JRST [	SETZM SRCJFN##	; No more, done (JFN released)
		POPJ P,]
tops20,<
	PUSHJ P,CHKRD##
	 JRST C.RET8
>
	JRST C.RET1		; Another, go retrieve it

; "Retrieve" subroutines ...

; Check and/or default parameters for "Retrieve" command
;	A/ JFN for file being retrieved
;	B/ Pointer to property list
; Returns +1:  Error, reply message already generated (as Comment)
;	+2:  Ok, type and byte size filled in appropriately
; Clobbers B-D

CKRPAR:	PUSHJ P,SAVE1##		; Preserve another ac
	MOVE P1,B		; Put the plist pointer there
	SETZ B,			; Assume don't know byte size
	TRNN F,DSKDVF		; Retrieving from disk?
	 JRST CKRPA2		; No
	MOVE B,[1,,11]		; Yes, read byte size from FDB
	MOVEI C,C		; Put it here
	GTFDB
	LDB B,[POINT 6,C,11]	; Extract byte size
CKRPA2:	HRRZ C,P.TYPE(P1)	; Get specified transfer type
	HRRZ D,P.BYTE(P1)	; Get specified byte size
	JRST @[	RTYUNS		; Dispatch on type:  Unspecified
		RTYTXT		; Text
		RTYBIN		; Binary
		RTYPAG](C)	; Paged

; Here for type unspecified
RTYUNS:	SKIPN D,B		; File byte size known?
	 FTPM(COMM,,<Type specification required to retrieve %1F>,1)
	MOVEI C,2		; Assume binary
	CAIN B,7		; 7-bit file?
	 MOVEI C,1		; Yes, assume text
	JRST CKRPA4		; Go set parameters

; Here for type Text
RTYTXT:	SKIPE D,B		; File byte size known?
	CAIN D,^D36		; Yes, 36 bit words?
	 MOVEI D,7		; Not known or 36, assume 7 bit
	CAIE D,7		; Legal byte size?
	CAIN D,8
	 JRST CKRPA4		; Yes
	FTPM(COMM,,<Type Text inconsistent with byte size %4D of file %1F>,1)

; Here for type Binary
RTYBIN:	JUMPN D,.+3		; Transfer byte size specified?
	SKIPN D,B		; No, substitute file byte size
	 FTPM(COMM,,<Byte size specification required to retrieve %1F>,1)
	JUMPE B,CKRPA4		; Ok if file byte size unknown
	CAMN B,D		; Both known, consistent?
	 JRST CKRPA4		; Yes
	CAIE B,^D36		; No, allow only if file byte size is 36
	 FTPM(COMM,,<File %1F not retrieved:
 requested byte size = %4D but actual file byte size = %2D>,1)
	FTPM(COMM,,<File %1F byte size = %2D being retrieved
 with byte size = %4D.  This may be incorrect -- beware!>)
	JRST CKRPA4

; Here for type Tenex-Paged
RTYPAG:	TRNN F,DSKDVF		; Is local file on disk?
	 PUSHJ P,SCREWUP##	; No (should not get here)
	MOVEI D,^D36		; Set local byte size to 36

; All cases converge here
; C/ Transfer type, D/ Transfer byte size
CKRPA4:	MOVEM C,P.TYPE(P1)	; Store type and byte size
	MOVEM D,P.BYTE(P1)
	JRST SKPRET##		; Return +2

; "Retrieve" subroutines ...

; Generate retrieval property list reply
; Specifically, generate Here-is-Property-List command
; Assumes TMPPRP and SRCJFN setup
; Returns +1
; Clobbers A-D

GNRPRP:	HRROI A,NETBUF		; Where to buffer property list
	HRRZ B,SRCJFN##		; Get file JFN
	PUSHJ P,GFNPRP		; Generate filename properties
	HRRZ B,TMPPRP+P.TYPE	; Get type
	HRRZ C,TMPPRP+P.BYTE	; Get byte size
	XCT [			; Append properties as appropriate
		WRITE <(Type Text)>
		WRITE <(Type Binary)(Byte-Size %3D)>
		WRITE <(Type Tenex-Paged)>
	    ]-1(B)
	TRNN F,DSKDVF		; Is file on disk?
	 JRST GNRPR2		; No, omit remaining properties
	PUSH P,A		; Yes, save dest designator
	HRRZ A,SRCJFN##		; Get file JFN
	MOVE B,[3,,13]		; Read FDBCRE, FDBWRT, FDBRED
	MOVEI C,B		; Put them in B, C, D
	GTFDB
	POP P,A			; Restore dest designator
	WRITE <(Creation-date %2T)(Write-date %3T)>
	SKIPE D			; Skip if never read
	 WRITE <(Read-date %4T)>
GNRPR2:	HRROI A,NETBUF		; Make ptr to property list
	FTPM(PLST,,<(%1S)>,1)	; Send off command and return


; Open file for retrieval
; Assumes file JFN is in SRCJFN
; and that transfer parameters are in TMPPRP
; Returns +1:  Failed, "No" reply already generated
;	+2:  Succeeded, file open
; Clobbers A-D

OPNRET:	TRNN F,DSKDVF		; Is file on disk?
	 JRST OPNRT1		; No, bypass extension check
	HRROI A,TEMP		; Yes, buffer file extension here
	SETZM TEMP
	HRRZ B,SRCJFN##
	MOVSI C,(1B11)		; Get extension only
	JFNS
	MOVEI B,1B19+1B25	; Assume want to open thawed
	MOVE A,TEMP		; Get the extension
	CAME A,[ASCII /SAV/]	; Leave thawed if .SAV
OPNRT1:	MOVEI B,1B19		; Open in frozen mode
	MOVE A,TMPPRP+P.BYTE	; Get transfer byte size
	DPB A,[POINT 6,B,5]	; Put in position
	HRRZ A,SRCJFN##		; Setup JFN
	OPENF			; Attempt to open
	 JRST [	TRC B,1B25	; Failed, try flipping thawed bit
		HRRZ A,SRCJFN##
		OPENF
		 JRST ROPNER	; Failed again, give error
		JRST .+1]	; Succeeded, continue
	JRST SKPRET##		; Return +2

; "New-store"

C.NSTO:	HRROS 0(P)		; Signal that this is a new-store
	JRST .+2

; "Store"

C.STOR:	HRRZS 0(P)		; Signal that this is an old-store
	SETZM FILPRP		; Clear out property list
	MOVE A,[FILPRP,,FILPRP+1]
	BLT A,FILPRP+PLSIZE-1
	HRROI A,NETBUF		; Set pointer to argument string
	MOVEI B,FILPRP		; File property list
	PUSHJ P,SCNPRP##	; Scan property list
	 POPJ P,		; Failed
	MOVEI A,FILPRP
	PUSHJ P,LOGCHK		; Check login/connect parameters
	 POPJ P,		; Failed
	MOVEI A,TEMP		; Where to build GTJFN command list
	MOVEI B,FILPRP		; Where property list is
	PUSHJ P,FIXNAM		; Fix args, build command list
	MOVSI C,(1B0)		; For output use
	HLLM C,TEMP
	MOVE C,C.UACT		; Current user account designator
	MOVEM C,TEMP+7
	GTJFN			; Get a JFN for the file
	 JRST SGJFER		; Failed, give reason and quit
tops20,<
	PUSHJ P,CHKWR##		; See if user can access this file
	 JRST SGJFER	 	; Can't
>
	MOVEM A,DSTJFN##	; Ok, save destination JFN

	MOVE B,[FILPRP,,TMPPRP]	; Copy supplied property list
	BLT B,TMPPRP+PLSIZE-1	;  into temps for this Store
	PUSHJ P,CHKDSK		; Check device type
	MOVEI B,TMPPRP		; Set pointer to property list
	PUSHJ P,CKSPAR		; Check store parameters
	 JRST C.STO8		; Bad, quit
	PUSHJ P,OPNSTO		; Open file for store
	 JRST C.STO8		; Failed

; Set file creation date to the date supplied in the property list
	SKIPE C,TMPPRP+P.CDAT	; Date present in property list?
	TRNN F,DSKDVF		; File on disk?
	 JRST C.STO2		; No
	HRRZ A,DSTJFN##		; Yes, set creation date
	HRLI A,13
	SETO B,
	CHFDB

; Now that we have the file open, generate the positive reply
;  and then await the "Here-is-file" command and file data
C.STO2:	SKIPGE 0(P)		; Which kind of store?
	 JRST [	HRROI A,NETBUF	; New, buffer property list here
		HRRZ B,DSTJFN##
		PUSHJ P,GFNPRP	; Generate filename properties
		HRROI A,NETBUF	; Send Here-is-property-list reply
		FTPM(PLST,,<(%1S)>)
		JRST C.STO3]
	HRRZ A,DSTJFN##		; Get JFN for use in message
	FTPM(YES,0,<File %1F open, ready for data>)
C.STO3:	PUSHJ P,GETCMD		; Get next command
	 JRST STOEND		; End received
	CAIN A,MKFILE		; "Here-is-file"?
	 JRST C.STO7		; Yes, go receive file
	CAIN A,MKNO		; "No"? (i.e. abort)
	 JRST [	HRRZ A,DSTJFN##	; Yes, report abortion
		LOG <Store of %1F aborted>
		JRST KILFIL]	; Flush output file and return
	MOVE C,MRKNAM(A)	; No, get dispatch
	TLNN C,(OKSTOR)		; Command ok during "Store"?
	 JRST [	HRRO C,MRKNAM(A)  ; No, make ptr to command name
		FTPM(NO,3,<Command [%3S] out of sequence during Store>)
		JRST KILFIL]	; Flush output file and return
	MOVE C,MRKDSP(A)	; Ok, get dispatch
	PUSHJ P,0(C)		; Do the command
	JRST C.STO3		; Look for another

; Store (cont'd)

; Here when "Here-is-file" command encountered
C.STO7:	HRRZ A,DSTJFN		; Get file JFN
	LOG <Store %1F>		; Make log entry
	HLRZ A,FRKJFN(FX)	; Source is net
	MOVEM A,SRCJFN##
	MOVEI A,TMPPRP		; Property list being used
	PUSHJ P,RECDAT##	; Do the store
	 JRST [	PUSHJ P,GETCMD	; Failed, suck up next command
		 JRST STOEND	; End received
		HRRZ A,DSTJFN##	; Report failure
		LOG <Data error during Store of %1F>
		FTPM(NO,103,<Data error during Store of %1F>)
		SETZM SRCJFN##
		JRST KILFIL]	; Flush output file and return
	SETZM SRCJFN##
	PUSHJ P,GETCMD		; Done, get next command
	 JRST STOEND		; End received
	CAIN A,MKNO		; Terminated by "No"?
	 JRST [	HRRZ A,DSTJFN##	; Report abortion
		LOG <Store of %1F aborted>
		FTPM(NO,106,<Store of %1F not completed>)
		JRST KILFIL]	; Flush output file and return
	CAIE A,MKYES		; Terminated by "Yes"?
	 JRST [	HRRO C,MRKNAM(A)  ; No, make ptr to command name
		FTPM(NO,3,<Command [%3S] out of sequence during Store>)
		JRST KILFIL]	; Flush output file and return
	HRRZ A,DSTJFN##		; Transfer ok
	FTPM(YES,0,<Store of %1F completed>)
	CLOSF			; Close file
	 ELOG <Unlikely CLOSF error: %1J%/>
	SETZM DSTJFN##
	POPJ P,			; Done

; Here to give up before opening file
C.STO8:	HRRZ A,DSTJFN##		; Just release JFN
	RLJFN
	 PUSHJ P,SCREWUP
	SETZM DSTJFN##
	POPJ P,			; Done

; Here when End received in the middle of a Store
STOEND:	HRRZ A,DSTJFN##		; Report abortion
	LOG <Store of %1F aborted>
	PUSHJ P,KILFIL		; Delete output file if possible
	JRST FTPEND		; Handle EOF normally

; "Store" subroutines ...

; Check and/or default parameters for "Store" command
;	A/ JFN for file being stored
;	B/ Pointer to property list
; Returns +1:  Error, reply message already generated
;	+2:  Ok, type and byte size filled in appropriately
; Clobbers B-D

CKSPAR:	HRRZ D,P.BYTE(B)	; Get bytesize specification
	HRRZ C,P.TYPE(B)	; Dispatch on type
	JRST @[	STYUNS		; Unspecified
		STYTXT		; Text
		STYBIN		; Binary
		STYPAG](C)	; Paged

STYUNS:	FTPM(NO,102,<Type specification required to store %1F>,1)

STYPAG:	TRNN F,DSKDVF		; Paged, devide disk?
	 FTPM(NO,15,<Type Tenex-Paged illegal for non-disk files>,1)
	MOVEI D,^D36		; Byte size is 36
	JRST .+2

STYTXT:	MOVEI D,7		; Text, use byte size 7
STYBIN:	SKIPN D			; Ensure have byte size
	 FTPM(NO,102,<Byte size specification required to store %1F>,1)
	HRRM D,P.BYTE(B)	; Store byte size in property list
	JRST SKPRET##		; Return +2


; Open file for store
; Assumes file JFN is in DSTJFN
; and that transfer parameters are in TMPPRP
; Returns +1:  Failed, reply already generated
;	+2:  Succeeded, file open
; Clobbers A-D

OPNSTO:	MOVE B,TMPPRP+P.BYTE	; Get transfer byte size
	ROT B,-6		; Put in position
	HRRI B,1B20		; Say opening for writing
	HRRZ A,DSTJFN##		; Setup JFN
	OPENF			; Attempt to open
	 JRST SOPNER		; Failed, give error
	JRST SKPRET##		; Succeeded, return +2

tops20,<
; Check to see if user is allowed to create files in a directory
; accepts 2/address of property list from user
; returns +1/ Failure.  AC1 contains GTJFN error code corresponding
;	      to invalid dir privs
;	  +2/ Success. AC's unchanged

WRCHK:	PUSH P,1			; Save acs
	PUSH P,2
	SKIPN 1,P.DIRE(2)		; Get directory name to connect to
	 SKIPA 1,C.UNAM			; if nothing there, use login
	TLO 1,-1			; Convert name to string ptr
	PUSHJ P,CHKWRD##		; see if write access allowed
	 JRST [MOVEM 1,-1(P)		; fail
	       JRST .+2]
	AOS -2(P)
	POP P,2
	POP P,1
	POPJ P,
> ;end tops20

; "Directory"

C.DIR:	SETZM FILPRP		; Clear out property list
	MOVE A,[FILPRP,,FILPRP+1]
	BLT A,FILPRP+PLSIZE-1
	HRROI A,NETBUF		; Set pointer to argument string
	MOVEI B,FILPRP		; File property list
	PUSHJ P,SCNPRP##	; Scan property list
	 POPJ P,		; Failed
	MOVEI A,FILPRP
	PUSHJ P,LOGCHK		; Check login/connect parameters
	 POPJ P,		; Failed
	MOVEI A,TEMP		; Where to build GTJFN command list
	MOVEI B,FILPRP		; Where property list is now
	PUSHJ P,FIXNAM		; Fix args, build command list
	SKIPN C,0(A)		; Version specified?
	 MOVEI C,-3		; No, default to *
	HRLI C,(1B2+1B11)	; Old file, permit "*"
	MOVEM C,0(A)
	HRROI C,[ASCIZ /*/]	; Default name and extension to *
	MOVEM C,4(A)
	MOVEM C,5(A)
	GTJFN			; Lookup the Server-Filename string
	 JRST RGJFER		; Failed, give reason and quit
tops20,<
	PUSHJ P,CHKDR##		; See if user allowed to see this one
	 JRST C.DIR3		; nope
>	 
	MOVEM A,SRCJFN##	; Ok, save JFN and flags

; Loop to generate file property list(s)
C.DIR2:	PUSHJ P,SETWDT##	; Reset watchdog timer
	HRRZ A,SRCJFN##		; Get JFN for file
	PUSHJ P,CHKDSK		; Check device type
	HRROI A,NETBUF		; Buffer the property list here
	HRRZ B,SRCJFN##		; File JFN
	PUSHJ P,GENPRP		; Generate property list for file
	HRROI A,NETBUF
	FTPM(PLST,0,<%1S>)	; Send it off
tops20,<
C.DIR3:
>
	MOVE A,SRCJFN##		; Recover JFN and flags
	GNJFN			; Step to next if any
	 JRST [	SETZM SRCJFN##	; No more, done
		POPJ P,]
tops20,<
	PUSHJ P,CHKDR##
	 JRST C.DIR3
>
	JRST C.DIR2		; More, repeat

; Generate complete file property list for supplied JFN
;	A/ Destination designator
;	B/ JFN
; Returns +1 always:  A/ Designator (updated if string ptr)
; Clobbers B-D

GENPRP:	HRLM B,0(P)		; Preserve file JFN
	WRITE <(>		; Start property list
	PUSHJ P,GFNPRP		; Generate filename properties
	MOVE D,A		; Move designator to D
	TRNN F,DSKDVF		; Is file on disk?
	 JRST GENPR9		; No, no more attributes

; For disk, output all interesting things in the FDB
	HLRZ A,0(P)
	MOVE B,[25,,0]		; Read entire FDB
	MOVEI C,TEMP		; Put it here
	GTFDB
	LDB B,[POINT 6,TEMP+11,11]  ; Get byte size
	JUMPE B,GENPR2		; Jump if unknown
	CAIN B,7		; Say Text if byte size 7
	 WRITE D,<(Type Text)>
	CAIE B,7		; Binary for anything else
	 WRITE D,<(Type Binary)(Byte-size %2D)>
	MOVE B,TEMP+12		; Get file length
	WRITE D,<(Size %2D)>
GENPR2:	MOVE B,TEMP+13		; Get creation date
	MOVE C,TEMP+14		; Get write date
	WRITE D,<(Creation-date %2T)(Write-date %3T)>
	SKIPE B,TEMP+15		; Get read date if there is one
	 WRITE D,<(Read-date %2T)>
	HLRZ B,TEMP+6		; Get author
	SKIPE B			; Output if present
	 WRITE D,<(Author %2U)>

GENPR9:	MOVE A,D		; Destination designator back to A
	WRITE <)>		; End property list
	POPJ P,			; Done

; "Delete"

C.DELE:	SETZM FILPRP		; Clear out property list
	MOVE A,[FILPRP,,FILPRP+1]
	BLT A,FILPRP+PLSIZE-1
	HRROI A,NETBUF		; Set pointer to argument string
	MOVEI B,FILPRP		; File property list
	PUSHJ P,SCNPRP##	; Scan property list
	 POPJ P,		; Failed
	MOVEI A,FILPRP
	PUSHJ P,LOGCHK		; Check login/connect parameters
	 POPJ P,		; Failed
	MOVEI A,TEMP		; Where to build GTJFN command list
	MOVEI B,FILPRP		; Where property list is now
	PUSHJ P,FIXNAM		; Fix args, build command list
	SKIPN C,0(A)		; Was version specified?
	 MOVEI C,-2		; No, default to lowest
	HRLI C,(1B2+1B11)	; Old file, permit "*"
	MOVEM C,0(A)
	GTJFN			; Lookup the Server-Filename string
	 JRST RGJFER		; Failed, give reason and quit
tops20,<
	PUSHJ P,CHKWR##		; see if write access allowed
	 JRST RGJFER
>
	MOVEM A,SRCJFN##	; Ok, save source JFN and flags
	HRRZS A
	PUSHJ P,CHKDSK		; Check device type

; Now have JFN (possibly indexable)
; Back here for each file referenced by the JFN
C.DEL1:	PUSHJ P,SETWDT##	; Reset watchdog timer
	HRROI A,NETBUF		; Where to buffer property list
	HRRZ B,SRCJFN##		; Get file JFN
	PUSHJ P,GFNPRP		; Generate filename properties
	HRROI A,NETBUF		; Make ptr to property list
	FTPM(PLST,,<(%1S)>)	; Send it off

; Await "Yes" or "No" from user
C.DEL2:	PUSHJ P,GETCMD		; Get next command
	 JRST [	HRRZ A,SRCJFN##	; Connection closed, release JFN
		RLJFN
		 PUSHJ P,SCREWUP##
		SETZM SRCJFN##
		JRST FTPEND]	; Handle EOF normally
	CAIN A,MKNO		; Check command
	 JRST C.DEL8		; "No", skip this file
	CAIN A,MKYES
	 JRST C.DEL6		; "Yes", delete this file
	MOVE C,MRKNAM(A)	; Not one of those, get dispatch
	TLNN C,(OKRETR)		; Command ok in this context?
	 JRST [	HRRZ A,SRCJFN##	; No, flush file JFN
		RLJFN
		 PUSHJ P,SCREWUP##
		SETZM SRCJFN##
		HRROS C		; Make string ptr to command name
		FTPM(NO,3,<Command [%3S] out of sequence during Delete>,1)]
	MOVE C,MRKDSP(A)	; Ok, get command dispatch
	PUSHJ P,0(C)		; Do the command
	JRST C.DEL2		; Look for another

; Here when "Yes" encountered.  Now delete the file.
C.DEL6:	HRRZ A,SRCJFN##		; Get file JFN
	LOG <Delete %1F>	; Make log entry
	HRLI A,400000		; Don't release JFN
	DELF			; Delete file
	 JRST [	LOG <Delete failed - %1J>
		PUSHJ P,DELERR	; Report reason
		JRST C.DEL8]	; On to next
	HRRZ A,SRCJFN##		; Succeeded, report
	FTPM(YES,0,<File %1F deleted>)

; Here when done deleting one file.  Check for more to do
C.DEL8:	MOVE A,SRCJFN##		; Get JFN with flags
	GNJFN			; Step to next file if any
	 JRST [	SETZM SRCJFN##	; No more, done (JFN released)
		POPJ P,]
tops20,<
	PUSHJ P,CHKWR##
	 JRST C.DEL8
>
	JRST C.DEL1		; Another, go delete it

; "Rename"

C.RENA:	SETZM FILPRP		; Clear out property list
	MOVE A,[FILPRP,,FILPRP+1]
	BLT A,FILPRP+PLSIZE-1
	SETZM TMPPRP		; Clear out another property list
	MOVE A,[TMPPRP,,TMPPRP+1]
	BLT A,TMPPRP+PLSIZE-1
	HRROI A,NETBUF		; Set pointer to argument string
	MOVEI B,FILPRP		; Where to put properties
	PUSHJ P,SCNPRP##	; Scan property list
	 POPJ P,		; Failed
	MOVEI B,TMPPRP
	PUSHJ P,SCNPRP##	; Scan second property list
	 POPJ P,
	MOVEI A,FILPRP
	PUSHJ P,LOGCHK		; Check login/connect parameters
	 POPJ P,		; Failed
	MOVEI A,TEMP		; Where to build GTJFN command list
	MOVEI B,FILPRP		; Where "old" property list is now
	PUSHJ P,FIXNAM		; Fix args, build command list
	MOVSI C,(1B2)		; Old file required
	IORM C,0(A)
	GTJFN			; Lookup the "old" server filename
	 JRST RGJFER		; Failed, give reason and quit
tops20,<PUSHJ P,CHKWR##
	 JRST RGJFER
>
	MOVEM A,SRCJFN##	; Ok, save JFN
	MOVEI A,TEMP		; Where to build GTJFN command list
	MOVEI B,TMPPRP		; Where "new" property list is now
tops20,<PUSHJ P,WRCHK
	 JRST .+4
>
	PUSHJ P,FIXNAM		; Fix args, build command list
	MOVSI C,(1B0+1B1)	; Output use, new file only
	IORM C,0(A)
	GTJFN			; Get JFN for new file
	 JRST [	PUSHJ P,RENGJF	; Failed, give reason
		HRRZ A,SRCJFN##	; Release old JFN
		RLJFN
		 PUSHJ P,SCREWUP##
		SETZM SRCJFN##
		POPJ P,]
	MOVE B,A		; Ok, get new JFN
	MOVE A,SRCJFN##		; Old JFN
	RNAMF			; Attempt rename
	 JRST [	PUSHJ P,RENERR	; Failed, give reason
		HRRZ A,SRCJFN##	; Release old JFN
		RLJFN
		 PUSHJ P,SCREWUP##
		JRST .+2]
	FTPM(YES,0,<Rename to %2F successful>)
	SETZM SRCJFN##		; Old JFN now released
	MOVE A,B		; Release new JFN
	RLJFN
	 PUSHJ P,SCREWUP##
	POPJ P,			; Done

; Generate filename properties given JFN
;	A/ Destination designator
;	B/ JFN
; Assumes DSKDVF set properly
; Returns +1 always:  A/ Designator (updated if string ptr)
; Generates Device, Directory, Name-Body, Version, and
; Server-Filename properties as appropriate
; Clobbers B-D

GFNPRP:	HRLM B,0(P)		; Preserve file JFN
	MOVE D,A		; Put dest designator in D
	TRNE F,DSKDVF		; Device disk?
	 JRST GFNPR1		; Yes, omit device property
	MOVSI C,(1B2)		; Print just device
	PUSHJ P,DOJFNS		; Convert device name to string
	WRITE D,<(Device %2S)>	; Generate property
GFNPR1:	TRNN F,DSKDVF		; Device disk?
	 JRST GFNPR2		; No, omit directory
	HLRZ B,0(P)		; Yes, get file JFN
	MOVSI C,(1B5)		; Want just directory
	PUSHJ P,DOJFNS		; Convert directory to string
	WRITE D,<(Directory %2S)>; Generate property
GFNPR2:	HLRZ B,0(P)		; Get file JFN
	MOVE C,[1B8+1B11+1B35]	; Want name and ext, punctuated
	PUSHJ P,DOJFNS		; Convert to string
	WRITE D,<(Name-Body %2S)>; Generate property
	TRNN F,DSKDVF		; Device disk?
	 JRST GFNPR3		; No, omit version
	HLRZ B,0(P)		; Yes, get file JFN
	MOVSI C,(1B14)		; Want just version
	PUSHJ P,DOJFNS		; Convert version to string
	WRITE D,<(Version %2S)>	; Generate property
GFNPR3:	HLRZ B,0(P)		; Get file JFN
	TRNN F,DSKDVF		; Device disk?
	 TDZA C,C		; No, print in default format
	 MOVE C,[2B2+1B5+1B8+1B11+1B14+1B21+1B35] ; Yes, force dir
	PUSHJ P,DOJFNS		; Convert filename to string
	WRITE D,<(Server-Filename %2S)>; Generate property
	MOVE A,D		; Put designator back in A
	POPJ P,			; Done


; Do JFNS with output suitable for inclusion in property list
;	B/ File JFN
;	C/ JFNS flags
; Returns +1:
;	B/ String ptr to JFNS text
; Clobbers A-C

DOJFNS:	MOVE A,[POINT 7,TEMP]	; Where to put temp text
	JFNS			; Convert to string
	MOVE A,[POINT 7,TEMP]	; Source string
	MOVE B,[POINT 7,TEMP+100]  ; Destination string
DOJFN1:	ILDB C,A		; Get a char
	CAIN C,"V"-100		; Tenex filename quote?
	 JRST DOJFN1		; Yes, flush it
	CAIE C,"("		; Character need to be quoted?
	CAIN C,")"
	 JRST .+3		; Yes
	CAIE C,PQUOTE
	 JRST DOJFN2		; No
	MOVEI C,PQUOTE		; Yes, insert quote character
	IDPB C,B
	LDB C,A			; Recover character
DOJFN2:	IDPB C,B		; Store the character
	JUMPN C,DOJFN1		; Repeat if not at end
	MOVE B,[POINT 7,TEMP+100]  ; Where result string is now
	POPJ P,			; Done

; Here to handle GTJFN errors peculiar to "Retrieve"
RGJFER::CAIL A,GJFX18		; File not found errors
	CAILE A,GJFX21
	 CAIN A,GJFX24
	  FTPM(NO,100,<No such file exists>,1)
	JRST GJFERR		; Handle rest same as Store

; GTJFN errors peculiar to "Rename"
RENGJF:	CAIE A,GJFX27		; New file only
	CAIN A,GJFX20		; No such version (?? -- really flakey)
	 FTPM(NO,112,<Rename "to" file already exists>,1)

; GTJFN errors peculiar to "Store"
SGJFER:	CAIL A,GJFX18		; File not found errors
	CAILE A,GJFX21		; Really mean can't create file
	 CAIN A,GJFX24
	  FTPM(NO,101,<No access to create that file>,1)

; Here for errors common to "Retrieve" and "Store"
GJFERR:	CAIL A,GJFX4		; Illegal format errors
	CAILE A,GJFX15
	 CAIN A,GJFX31
	  FTPM(NO,11,<Illegal filename>,1)
	CAIE A,GJFX33		; More illegal format errors
	CAIN A,GJFX34
	 FTPM(NO,11,<Illegal filename>,1)
	CAIN A,GJFX16		; More file not found errors
	 FTPM(NO,100,<No such device exists>,1)
	CAIN A,GJFX17
	 FTPM(NO,100,<No such directory exists>,1)
	CAIN A,GJFX32
	 FTPM(NO,100,<No such file exists>,1)
	FTPM(NO,0,<Filename error: %1J>,1)  ; All others


; Here to handle OPENF errors peculiar to "Retrieve"
ROPNER::HRRZ C,SRCJFN##		; Setup JFN for reply message
	JRST OPNERR		; Join common code

; Here to handle OPENF errors peculiar to "Store"
SOPNER:	HRRZ C,DSTJFN##		; Setup JFN for message

; OPENF failure code common to "Retrieve" and "Store"
OPNERR:	CAIL A,OPNX3		; Check for protection errors
	CAILE A,OPNX6
	 CAIN A,OPNX13
	  FTPM(NO,101,<Access denied to file %3F>,1)
	CAIN A,OPNX23
	 FTPM(NO,101,<Access denied to directory containing %3F>,1)
	CAIN A,OPNX9		; File busy error
	 FTPM(NO,111,<File %3F busy>,1)
	CAIN A,OPNX10		; Disk full error
	 FTPM(NO,104,<No room for file %3F>,1)
	CAIN A,SFBSX2		; Byte size error
	 FTPM(NO,102,<Illegal byte size for file %3F>,1)
	FTPM(NO,0,<File open error: %1J for file %3F>,1)  ; Other


; "Delete" errors
DELERR:	HRRZ C,SRCJFN##
	CAIN A,DELFX1
	 FTPM(NO,101,<Delete access denied to file %3F>,1)
	FTPM(NO,0,<Delete error: %1J for file %3F>,1)


; "Rename" errors
RENERR:	HRRZ C,SRCJFN##		; Get "from" JFN
	CAIN A,RNAMX3
	 FTPM(NO,101,<Access denied to new file %2F>,1)
	CAIN A,RNAMX5
	 FTPM(NO,111,<File %2F busy>,1)
	CAIN A,RNAMX8
	 FTPM(NO,101,<Access denied to existing file %3F>,1)
	CAIN A,RNMX10
	 FTPM(NO,101,<File %3F busy>,1)
	FTPM(NO,0,<Rename %3F to %2F failed: %1J>,1)

; -----------------------------------------------------------------
;	File system utilities
; -----------------------------------------------------------------

; Check for device disk
;	A/ JFN for file being retrieved or stored
; Returns +1 always
; Sets DSKDVF flag appropriately
; Clobbers B, C

CHKDSK:	PUSH P,A		; Save JFN
	DVCHR			; Get device characteristics
	POP P,A			; Restore JFN
	TLNN B,377		; Check device type
	 TROA F,DSKDVF		; Device is a disk
	 TRZ F,DSKDVF		; Device is not a disk
	POPJ P,


; "Kill" destination file, i.e. delete all its pages and
; try very hard to make it go away (works only for disk).
; Assumes DSTJFN contains open output JFN and that DSKDVF
; has already been set appropriately.
; Returns +1 always
; Closes and releases JFN
; Clobbers A-D

KILFIL::HRRZ A,DSTJFN##		; Get destination JFN
	DELF			; First attempt to delete file
	 JRST KILFI5		; Non-directory or no access, stop
	TRNN F,DSKDVF		; Output to disk?
	 JRST KILFI5		; No, just close file
	MOVE B,[1,,1]		; Yes, get FDBCTL word
	MOVEI C,C
	GTFDB
	TLNN C,(1B4)		; FDBNXF set?
	 JRST KILFI5		; No, file previously existed
	PUSHJ P,DELPGS		; Yes, delete all pages in file
	HRRZ A,DSTJFN##		; Close the file
	HRLI A,400000		;  but don't release JFN
	CLOSF
	 POPJ P,		; Failed?  give up
	HRLI A,1		; Now set FDBNXF to make the
	MOVSI B,(1B4)		;  file look invisible
	MOVSI C,(1B4)
	CHFDB
	HRRZ A,DSTJFN##		; Release JFN
	RLJFN
	 CAI
	SETZM DSTJFN##
	POPJ P,			; Done

; Here to just close file
KILFI5:	HRRZ A,DSTJFN##
	CLOSF
	 CAI
	SETZM DSTJFN##
	POPJ P,


; Delete all pages in a disk file
; Assumes file open for writing
;	A/ JFN
; Returns +1 always
; Clobbers A, B

DELPGS::HRLZ A,A		; Make designator for file page 0
	SETO B,			; Set arg for deleting pages
DELPG1:	FFUFP			; Find next existing page
	 POPJ P,		; No more, done
	EXCH A,B		; Found one, delete it
	PMAP
	EXCH A,B
	AOJA A,DELPG1		; On to next

; Fix up filename strings for Retrieve, Store, etc.
;	A/ Where to build command list for GTJFN
;	B/ Property list pointer
; Specifically, if a Server-Filename was not supplied, construct
; one from the Name-Body property.  Then setup the remaining
; properties (if any) as defaults.
; Returns +1:
;	A/ unchanged
;	B/ main string pointer (for GTJFN)
; Clobbers B, C

FIXNAM:	HRRZ C,P.VERS(B)	; Default version
	MOVEM C,0(A)
	MOVE C,[377777,,377777]	; No file i/o for GTJFN
	MOVEM C,1(A)
	SKIPE C,P.DEVI(B)	; Device supplied?
	 HRROI C,P.DEVI(B)	; Yes, set default device
	MOVEM C,2(A)
tenex,<
	SKIPE C,P.DIRE(B)	; Directory supplied?
	 HRROI C,P.DIRE(B)	; Yes, set default directory
>
tops20,<
	SKIPE C,P.DIRE(B)	; Get supplied directory
	 TLOA C,777777		; Directory supplied, make implicit bp
	HRROI C,USRCDN##	; then use connected directory
>
	MOVEM C,3(A)
	SETZM 4(A)		; No default name
	SETZM 5(A)		; No default extension
	SETZM 6(A)		; No default protection
	SETZM 7(A)		; No default account
	HRROI B,P.SFIL(B)	; Make string ptr to server name
	SKIPN 0(B)		; Is there one?
	 HRRI B,P.NAMB-P.SFIL(B)  ; No, use name body
	POPJ P,

; Check and apply login/connect parameters
;	A/ Property list pointer
; Returns +1:  Incorrect, reply already generated
;	+2:  Parameters correct
; Updates flags LOGCKF, ACTCKF, and CONCKF appropriately
; Clobbers A-D

LOGCHK::PUSHJ P,SAVE1##		; Save P1
	MOVE P1,A		; Setup property list pointer

; Check login directory # and password
	SKIPN A,P.UNAM(P1)	; Setup supplied dir #
	 FTPM(NO,2,<User-Name and Password required>,1)
	CAME A,C.UNAM		; Same as current?
	 JRST LOGCH1		; No, have to re-check
	HRROI A,P.UPSW(P1)	; Same password?
	HRROI B,C.UPSW
	PUSHJ P,STRCMP##
LOGCH1:	 TRZ F,LOGCKF+ACTCKF+CONCKF  ; No, invalidate parameters
	TRNE F,LOGCKF		; Need to check name/password?
	 JRST LOGCH2		; No, bypass

; Name and/or password not the same as before (or not logged in
; previously).  "Log in" this fork as specified.

; ****  Tops20 differences  ****
; Tops-20 directory numbers are 36-bit.  Thus, the function bits
; CNDIR expects in the left half if AC1 are impossible to supply.
; Thus, Tops20 PUPFTS implements three CNDIR simulations (.CNCON, 
; which simulates a connect, .CNPSW, which does an explicit password
; check, and .CNPXY, which simulates the "proxy login."
; Also, since Tops20 does not have the notion of fork groups, the CFGRP
; JSYS is simulated.  

tenex,<
	HRRZ A,P.UNAM(P1)	; Get dir #
	HRLI A,(1B1)		; Want proxy login
>
tops20,<
	MOVE A,P.UNAM(P1)
>
	HRROI B,P.UPSW(P1)	; String ptr to password
tenex,< CNDIR >			; Do login of fork group
tops20,<PUSHJ P,.CNPXY##>
	 JRST [	CAIN A,CNDIX1	; Failed, check error
		 FTPM(NO,21,<User-Password incorrect>,1)
		FTPM(NO,20,<Login failure: %1J>,1)]
tenex,<
; *** Explicitly verify password, since it's not checked if
; logging in under the "current" login directory (e.g. SYSTEM)
; (Tops20) .CNPXY does explicit password check
	HRLI A,(1B0)		; Say check password
	CNDIR
	 FTPM(NO,21,<User-Password incorrect>,1)
; ***
>

; Now successfully "logged in".  Record successful name/password
; combination for future checks.
tenex,<
	HRRZ B,P.UNAM(P1)	; Ok, record current user name
	MOVEM B,C.UNAM
	MOVEM B,C.CNAM		; Now connected to that dir also
> ;.CNPXY does this on Tops20
tops20,<MOVE B,C.UNAM>		; Put 36-bit directory # in B
	MOVSI A,P.UPSW(P1)	; Record successful password
	HRRI A,C.UPSW
	BLT A,C.UPSW+USRSTL/5
	TRO F,LOGCKF+CONCKF	; Say logged in and connected ok
	LOG <Login as user %2U>	; Make log entry
	HRROI A,C.UACT+1	; Where to put default acct string
tops20,<PUSHJ P,.GDACC##>
tenex,<	GDACC >			; Get default account
	 SETZ A,		; None, remember so
	MOVEM A,C.UACT		; Store account designator

; LOGCHK (cont'd)

; See whether account is same as before.
LOGCH2:	SKIPN B,C.UACT		; Get current account designator
	 JRST LOGCH3		; None, force check of new one
	SKIPE A,P.UACT(P1)	; Get specified account designator
	CAMN A,B		; Numeric and same as current?
	 JRST LOGCH4		; Yes (or none), don't force check
	TLC A,(5B2)		; Zero B0-2 if numeric
	TLC B,(5B2)
	TLNE A,(7B2)		; Both string?
	TLNN B,(7B2)
	 JRST LOGCH3		; No, need to re-check
	TLC A,(5B2)		; Yes, fix string pointers
	TLC B,(5B2)
	PUSHJ P,STRCMP##	; Compare strings
LOGCH3:	 TRZ F,ACTCKF		; Not equal, force check
LOGCH4:	TRNE F,ACTCKF		; Need to check account?
	 JRST LOGCH6		; No

; Account different from before, check new one.
tenex,<	HRRZ A,C.UNAM >		; Yes, setup dir # of user
tops20,<MOVE A,C.UNAM>
	SKIPN B,P.UACT(P1)	; Get account designator if given
	SKIPE B,C.UACT		; Default if not given
	 VACCT			; Verify account
tenex,<	 
	  FTPM(NO,22,<User-Account invalid>,1)
>
tops20,<  ERCAL [FTPM(NO,22,<User-Account invalid>,1)
		 POPJ P,]
>

; New account is ok.  Remember it for future checks.
	SKIPN A,P.UACT(P1)	; Get supplied designator
	 JRST LOGCH5		; Not supplied, remember default
	MOVSI B,P.UACT(P1)	; Copy string if there is one
	HRRI B,C.UACT
	BLT B,C.UACT+USRSTL/5+1
	HRROI B,C.UACT+1	; Make string ptr
	TLC A,(5B2)		; Is designator numeric?
	TLNE A,(7B2)
	 MOVEM B,C.UACT		; No, store string ptr
LOGCH5:	TRO F,ACTCKF		; Note that acct has been checked

; See whether connected dir # and password are same as before
LOGCH6:	SKIPN A,P.CNAM(P1)	; Get specified connected dir #
	 MOVE A,C.UNAM		; None, assume same as login
	CAME A,C.CNAM		; Same as current?
	 JRST LOGCH7		; No, have to re-check
	HRROI A,P.CPSW(P1)	; Same password?
	HRROI B,C.CPSW
	PUSHJ P,STRCMP##
LOGCH7:	 TRZ F,CONCKF		; No, invalidate parameters
	TRNE F,CONCKF		; Need to check name/password?
	 JRST SKPRET##		; No, done, return +2

; Not the same, do new "connect" of fork to dir.
tenex,<	HRRZ A,P.CNAM(P1) >	; Get connect dir #
tops20,<MOVE A,P.CNAM(P1)>
	HRROI B,P.CPSW(P1)	; Password
tops20,<PUSHJ P,.CNCON##>
tenex,<	CNDIR >			; Connect to directory
	 JRST [	CAIN A,CNDIX1	; Failed, check error code
		 FTPM(NO,24,<Connect-Password incorrect>,1)
		FTPM(NO,23,<Connect failure: %1J>,1)]
tops20,<MOVEM A,C.CNAM>		; tops20: 36 lousy bits
tenex,<	HRRZM A,C.CNAM >	; Succeeded, save current dir #
	MOVSI A,P.CPSW(P1)	; Record successful password
	HRRI A,C.CPSW
	BLT A,C.CPSW+USRSTL/5
	TRO F,CONCKF		; Say connected ok
	JRST SKPRET##		; Done, return +2

; -----------------------------------------------------------------
;	Subroutines
; -----------------------------------------------------------------
; Get next command
; Returns +1:  End received
;	+2:  Ok, A/ Mark type, B/ Subcommand byte (if any)
; Clobbers A-D

; Check status to distinguish between Mark and End
GETCMD::PUSHJ P,SETWDT##	; Reset watchdog timer
	HLRZ A,FRKJFN(FX)	; Get input JFN
	SETZ C,			; Don't want address stuff
	GDSTS			; Get status
	TLNE B,(1B5)		; End received?
	 POPJ P,		; Yes, fail return
	TLZN B,(1B4)		; Mark received?
	 JRST GETCM4		; No, go flush extraneous data

; Got Mark, prepare to process command
	SDSTS			; Clear flag
	MOVEI B,23		; Get the Mark byte
	MTOPR
	CAIGE C,NMARKS		; Mark byte in range?
	SKIPN D,MRKNAM(C)	; Yes, fetch name pointer
	 JRST GETCME		; No or undefined
	PUSH P,C		; Save Mark byte
	TLNE D,(NFETCH)		; Want to pre-fetch command text?
	 JRST GETCM2		; No
	HRROI B,NETBUF		; Yes, buffer as 7-bit ASCII
	MOVNI C,5000		; Max # bytes in buffer
	SIN
	SETZ A,
	SKIPGE C		; Unless completely filled buffer,
	 IDPB A,B		; Put null on end
	SKIPA D,[POINT 7,NETBUF]  ; Init string ptr
GETCM2:	 SETZB D,NETBUF		; Here if no text
	POP P,A			; Recover Mark byte
	HRRO C,MRKNAM(A)	; Get name string
	SKIPGE MRKNAM(A)	; Does command have subcommands?
	 JRST GETCM3		; Yes
	DTYPE <U: [%3S] %4S%/>	; No, print command if debugging
	JRST SKPRET##		; Return +2

GETCM3:	ILDB B,D		; Get subcommand
	DTYPE <U: [%3S] <%2O> %4S%/>; Print command if debugging
	JRST SKPRET##		; Return +2

; Here if command undefined
GETCME:	FTPM(NO,1,<Undefined command [%3O]>)

; Flush byte stream data to next Mark
GETCM4:	HLRZ A,FRKJFN(FX)	; Get input JFN
	MOVE B,[POINT 8,NETBUF]	; Byte ptr to buffer
	MOVNI C,4000		; # bytes in buffer
	SIN			; Suck bytes from net
	JUMPGE C,GETCM4		; Repeat if didn't get it all
	JRST GETCMD		; Go look again for Mark

; Refill the command buffer if necessary
;	A/ used string pointer into NETBUF
; Returns +1:
;	A/ updated string pointer
; Clobbers B-D

REFILL::TRNN A,400		; Have we read half the buffer?
	 POPJ P,		; No, nothing to do
	MOVE B,[NETBUF+400,,NETBUF]  ; Yes, move upper half down
	BLT B,NETBUF+377
	SUBI A,400		; Fix pointer
	PUSH P,A		; Save it
	HLRZ A,FRKJFN(FX)	; Get net input JFN
	HRROI B,NETBUF+400	; Where to put more input
	MOVNI C,400*5		; Max # chars
	SIN			; Get more input
	SETZ A,
	SKIPGE C		; Unless buffer filled,
	 IDPB A,B		; Put null on end
	PUSHJ P,SETWDT##	; Reset watchdog timer
	POP P,A			; Restore byte ptr
	POPJ P,

; FTPM (mark type, sub-code, <string>, pop count)
; UUO to generate FTP reply message

%UFTPM::PUSH P,@40		; Preserve control word
	AOS 40			; Advance to start of string
	PUSHJ P,FORMAT##	; Call UUO output formatter
	 HRROI A,TEMP+600	; Setup -- buffer reply here
	 PUSHJ P,UFTPM2		; Completion -- send off reply
	HRLS 0(P)		; Put pop count (+1) in both halves
	SUB P,0(P)		; Pop stack appropriately
	POPJ P,			; Return from UUO (or from caller)

; FTPM completion
UFTPM2:	SETZ B,			; Terminate string with null
	IDPB B,A
	LDB A,[POINT 8,-6(P),7]	; Get Mark type
	LDB C,[POINT 8,-6(P),15]  ; Get subcommand code if any
	HRROI B,TEMP+600	; Point to buffered reply
;	JRST SNDCMD		; Send off the command and return


; Send a command
;	A/ Command number (Mark type)
;	B/ String ptr to command text (0 => none)
;	C/ Subcommand (iff command requires one)
; Returns +1
; Clobbers A-D

SNDCMD:	PUSHJ P,BEGCMD		; Do the work
	JRST ENDCMD		; Force transmission

; Begin command, i.e. do all the output but don't force
; transmission.  Calling sequence same as SNDCMD

BEGCMD::HRRO D,MRKNAM(A)	; Get string ptr to command name
	SKIPL MRKNAM(A)		; Does command have subcommands?
	 DTYPE <S: [%4S] %2S%/>	; No
	SKIPGE MRKNAM(A)
	 DTYPE <S: [%4S] <%3O> %2S%/>; Yes
	MOVE D,B		; Save string ptr
	HRLM C,0(P)		; Save subcommand if any
	MOVE C,A		; Copy command number
	HRRZ A,FRKJFN(FX)	; Get output JFN
	MOVEI B,3		; Send Mark
	MTOPR
	HLRZ B,0(P)		; Get subcommand if any
	SKIPGE MRKNAM(C)	; Does command have subcommands?
	 BOUT			; Yes, send subcommand code
	SETZ C,
	SKIPE B,D		; Is there a string?
	 SOUT			; Yes, send it
	POPJ P,			; Done

; End command by forcing the byte stream
; Returns +1
; Clobbers A, B

ENDCMD:	HRRZ A,FRKJFN(FX)	; Get output JFN
	MOVEI B,21		; Force transmission
	MTOPR
	POPJ P,

; PSI channel definitions

DEFINE PSI(CH,LEV,DISP) <
	ACTCHN==ACTCHN!1B<CH>
RELOC CHNTAB+^D<CH>
	LEV ,, DISP
>

	ACTCHN==0

CHNTAB:	PSI(9,1,PDLOVF##)	; Pushdown overflow
	PSI(11,1,FTSDTE)	; Data error
	PSI(15,1,ILLINS##)	; Illegal instruction
	PSI(16,1,ILLRED##)	; Illegal read
	PSI(17,1,ILLWRT##)	; Illegal write
	PSI(18,1,ILLXCT##)	; Illegal execute
	PSI(20,1,ILLSIZ##)	; Machine size exceeded

RELOC CHNTAB+^D36

; Handling for data error in FTP server fork
FTSDTE:	PUSH P,A		; Save an ac
	SKIPL A,SRCDSP		; Check for error dispatches
	SKIPGE A,DSTDSP
	 TRNN A,-1		; Both specified and armed?
	  JRST DATERR##		; No, treat as fatal error
	HRRZM A,CH1PC		; Armed, clobber interrupt pc
	SETZM SRCDSP		; Disarm errors
	SETZM DSTDSP
	POP P,A
	MOVE P,ERRPDP		; Go to correct stack level
	DEBRK			; Break to error dispatch

; Storage

LSP NETBUF,1		; Network I/O buffer
LSP FILBUF,1		; Local file buffer

LS ERRPDP		; Stack pointer to restore on data error
LS SRCDSP		; Source file data error dispatch
LS DSTDSP		; Destination file data error dispatch

LS C.UNAM		; Current login dir #
LS C.UPSW,USRSTL/5+1	; Current login password
LS C.UACT,USRSTL/5+2	; Current account designator
LS C.CNAM		; Current connected dir #
LS C.CPSW,USRSTL/5+1	; Current connect password

LS FILPRP,PLSIZE	; File property list (Store/Retrieve)
LS TMPPRP,PLSIZE	; Temp property list (for one transfer)

LS FRNHST,10		; Foreign host name as a string


	END
