

; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 1

;<3-BELL>PUP.MAC.132,  7-Aug-78 15:37:59, Ed: BELL                     |
;Turn off pupbug typeout                                               |
;<3-BELL>PUP.MAC.130,  5-Aug-78 20:42:47, Ed: BELL                     |
;Integrate into Tops-20                                                |
;<134>PUP.MAC;87    12-NOV-77 19:36:57    EDIT BY TAFT
; Fix PUPCLZ to turn FILLFW bit back on before waiting
;<134>PUP.MAC;86    18-JUL-77 15:24:14    EDIT BY TAFT
; Raise IBWDLY to 500 ms
;<134>PUP.MAC;85     6-JUL-77 10:19:34    EDIT BY TAFT
; Change BSP dispatch to update activity timeout only for certain types
;<134>PUP.MAC;84     6-JUL-77 09:56:08    EDIT BY TAFT
; Fix error introduced into RCVERR in last edit
;<134>PUP.MAC;83     3-JUL-77 15:06:09    EDIT BY TAFT
; Increase retransmission timeout when port IQ or gateway OQ error occurs
; Run background fork on SPQ
; Try to direct more freed PBs onto FREIBQ to reduce overhead
; Remove state saving code in previous edit
;<134>PUP.MAC;82     7-MAY-77 21:18:19    EDIT BY TAFT
; Add code to record state of Pup background fork when a port IQ overflows
;<134>PUP.MAC;81    28-APR-77 21:45:23    EDIT BY TAFT
; Make PBGCNT resident, dummy
;<134>PUP.MAC;80    22-APR-77 10:36:47    EDIT BY TAFT
; Add logic to detect potential deadlocks arising from timing marks
;<134>PUP.MAC;79    21-APR-77 16:59:02    EDIT BY TAFT
; Add PUPBGT -- hash table for counting PUPBUGs
;<134>PUP.MAC;78    15-APR-77 12:13:29    EDIT BY TAFT
; Make TTYPUP internal
;<134>PUP.MAC;77     6-APR-77 10:08:59    EDIT BY TAFT
; Lock out PSIs in PNVCOB so interrupt and DM will both be sent
;<134>PUP.MAC;76    25-JAN-77 21:18:40    EDIT BY TAFT
; Parameterize initial routing table
; Put gateway-dependent stuff in GATEWF conditional
; Other changes for Maxc2
;<134>PUP.MAC;74    21-SEP-76 01:43:21    EDIT BY TAFT
; Update routing table
;<134>PUP.MAC;73    17-JUL-76 18:33:51    EDIT BY TAFT
; Add net 6 to routing table
;<134>PUP.MAC;72    13-MAY-76 16:59:15    EDIT BY TAFT
; Repair bad call to RELPKT at FLSBS3+1
;<134>PUP.MAC;71    20-APR-76 22:53:22    EDIT BY TAFT
; Bug fixes
; Generate timing mark reply immediately if a fork is blocked for input
;<134>PUP.MAC;70    20-APR-76 17:42:56    EDIT BY TAFT
; Fix glitch at NVTSYN
;<134>PUP.MAC;69    19-APR-76 00:51:07    EDIT BY TAFT
; Add PUPROU function for OPRFN
;<134>PUP.MAC;67    18-APR-76 21:20:21    EDIT BY TAFT
; Add Telnet timing mark logic
;<134>PUP.MAC;66    18-APR-76 18:39:17    EDIT BY TAFT
; Add code to handle Error Pups
;<134>PUP.MAC;65    17-APR-76 15:33:03    EDIT BY TAFT
; Redo background wakeup strategy -- protective delay without
; added latency in most cases.
;<134>PUP.MAC;64    14-APR-76 20:21:41    EDIT BY TAFT
; Improve hashing algorithm, remove restriction that NPUPUN be prime
;<134>PUP.MAC;63    29-MAR-76 17:35:58    EDIT BY TAFT
; At PUPIN5, force immediate rather than delayed wakeup of background
;  process for NVT ports
;<134>PUP.MAC;62    27-MAR-76 20:08:33    EDIT BY TAFT
; Increase some of the BSP retransmission timeouts
; Change probing strategy on zero allocation
;<134>PUP.MAC;61     7-MAR-76 00:53:56    EDIT BY TAFT
; Reject Pups claiming to be from host zero
;<134>PUP.MAC;60    23-FEB-76 17:24:03    EDIT BY TAFT
; Fix glitch in setting of NVT terminal type
;<134>PUP.MAC;59    25-JAN-76 17:32:23    EDIT BY TAFT
; Take out code to force AData in ATPNVT -- first data will do it anyway
;<134>PUP.MAC;58    22-JAN-76 16:12:41    EDIT BY TAFT
; Background fork back on HIQ -- SETHIQ bug was found
;<134>PUP.MAC;57    20-JAN-76 17:15:26    EDIT BY TAFT
; Run background fork in SPQ (SETHIQ seems not to work)
;<134>PUP.MAC;56    20-JAN-76 03:07:54    EDIT BY TAFT
; Pup received PSI now generated via scheduler request rather
;  than by direct call to PSIRQ from interrupt level.
;<134>PUP.MAC;55    11-JAN-76 21:34:42    EDIT BY TAFT
; Fix assembly glitch -- need () around LOCK/UNLOCK macro args
; Add some ##
;<134>PUP.MAC;54    10-JAN-76 23:48:50    EDIT BY TAFT
; Revise LOCK/UNLOCK calls for 1.34 scheduler handling
; Background fork always runs in HIQ
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 2

	SEARCH PROKS,PROLOG                                            |
	TTITLE PUP                                                     |
	SUBTTL PUP I/O DRIVER FOR MAXC  /  E. A. Taft    March 1975


; -----------------------------------------------------------------
;	Pup Parameter Definitions
; -----------------------------------------------------------------


; Parameters defined in PARAMS.MAC
;  NPUPUN	# Pup "Units".
;  NPUPLN	# Pup NVT's.
;  PUPLO	TTY # of lowest Pup NVT
;  PUPHI	TTY # of highest Pup NVT
;  NPNETS	Maximum # of networks in routing table
;  NPKTBF	# pages of storage for packet buffer allocator
;  NPUPBF	# pages for other Pup storage

;  PUPCHN	PI assignment for Pup I/O interrupts

;  PUPIBG	Begin Pup input device # (Maxc -> NVIO)
;  PUPOBG	Begin Pup output device # (Maxc -> NVIO)
;  PUPIDN	Pup input done device # (NVIO -> Maxc)
;  PUPODN	Pup output done device # (NVIO -> Maxc)

;  XPUPIB	Pup input packet address
;  XPUPOB	Pup output packet address

; Accumulator assignments
; A-D		; Temps
; UNIT		; Pup "Unit" number -- for port-indexed tables
;  PB		; Packet Buffer pointer                                |
;  BSP	; BSP data block pointer                                       |
DEFAC(UNIT,Q1)                                                         |
DEFAC(IOS,Q2)                                                          |
DEFAC(STS,P1)                                                          |
DEFAC(JFN,P2)                                                          |
DEFAC(F1,P5)                                                           |
DEFAC(E,Q3)                                                            |
DEFAC(BSP,P3)                                                          |
DEFAC(PB,P4)                                                           |
                                                                       |
IFNDEF PIESLC,<PIESLC==0>                                              |
DEFINE MX(FOO1,FOO2) <>                                                |
;RS PRSBEG,0	; Start of Pup resident storage                        |
;NR PNRBEG,0	; Start of Pup nonresident storage                     |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 3

; Parameters and byte pointers defining the structure of a Packet Buffer (PB)

PBSIZE==0
 PBLCKF==1B0			; PB is locked in core
 PPUPUN: POINT 9,PBSIZE(PB),17	; Unit # of owning port
 ; B18-35			; Size of PB in words

PBPHYS==1	; Physical packet parameters, passed to/from NVIO
 PPBPHN:: POINT 8,PBPHYS(PB),7	; Physical network number              |
 PPBPHH:: POINT 8,PBPHYS(PB),15	; Physical host number                 |
 PPBPHS:: POINT 12,PBPHYS(PB),31	; Packet size (Maxc words)     |
 PPBPLN:: POINT 3,PBPHYS(PB),19	; Physical line number                 |
 PPBPRT:: POINT 1,PBPHYS(PB),32	; SLA routing packet flag              |
 PPBPBC:: POINT 1,PBPHYS(PB),33	; Line is broadcasting packet          |
 PPBPAL:: POINT 1,PBPHYS(PB),34	; PKT is going to all lines            |

PBBSID==PBPHYS	; Byte ID, right-justified (used by BSP input)

PBIOBQ==2	; I/O buffer queue link word
		; 0 => not on any queue, -1 => being output by NVIO

PBBSPQ==3	; BSP buffer queue link word
		; 0 => not owned by BSP processor
		; -1 => owned by BSP but not on any queue

PBTIME==4	; Time stamp (TODCLK format), used for BSP output

PBBSBC==PBTIME	; Byte count for data (used by BSP input)

PBHEAD==:5	; Start of Pup Header                                  |
 PUPLEN: POINT 16,PBHEAD(PB),15	; Pup Length
 PUPTCB: POINT 8,PBHEAD(PB),23	; Transport Control Byte
 PUPTYP: POINT 8,PBHEAD(PB),31	; Pup Type

; PBHEAD+1
 ; B0-31			; Pup ID

; PBHEAD+2
 PPUPDN: POINT 8,PBHEAD+2(PB),7	; Destination Network
 PPUPDH: POINT 8,PBHEAD+2(PB),15  ; Destination Host
 PPUPD0: POINT 16,PBHEAD+2(PB),31  ; High 16 bits of Destination Socket

; PBHEAD+3
 PPUPD1: POINT 16,PBHEAD+3(PB),15  ; Low 16 bits of Destination Socket
 PPUPSN: POINT 8,PBHEAD+3(PB),23  ; Source Network
 PPUPSH: POINT 8,PBHEAD+3(PB),31  ; Source Host

; PBHEAD+4
 PPUPSS: POINT 32,PBHEAD+4(PB),31  ; Source Socket

PBCONT==PBHEAD+5  ; Start of Pup Contents

MNPLEN==^D22	; Minimum Pup Length (bytes), incl header and checksum
MXPLEN==^D554	; Maximum Pup Length (=> 532 data bytes)
MNPBLN==PBHEAD+<MNPLEN+3>/4  ; Minimum size of PB, in words
MXPBLN==PBHEAD+<MXPLEN+3>/4  ; Maximum size of PB, in words


; Pup Type assignments

PT.ECH==1	; Echo Me
PT.IEC==2	; I'm An Echo
PT.BEC==3	; I'm A Bad Echo
PT.ERR==4	; Error
PT.RFC==10	; Request for Connection
PT.ABT==11	; Abort
PT.END==12	; End
PT.ENR==13	; End Reply
PT.DAT==20	; Data
PT.ADA==21	; AData
PT.ACK==22	; Acknowledgment
PT.MRK==23	; Mark
PT.INT==24	; Interrupt
PT.INR==25	; Interrupt Reply
PT.AMA==26	; AMark
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 4

; Network-dependent stuff


; Network tables, indexed by net # -1

			; The following is a documented GETAB table
;RS PUPROU,NPNETS	; Network routing table                        |
 ; B0				; Network inaccessible
 BROADF==1B1			; Broadcast packets allowed on net
 ; B2-17			; Net/host to which packets should
				;  be routed (0 => route directly)
 ; B18-35			; Address of Maxc on this net (0 => not on net)


                                                                       |
                                                                       |
RESCD                                                                  |


; Pup storage parameters and assignments

;RS PKTFRE,7	; Packet buffer free storage header (standard ASGFRE form)
                                                                       |
;NRP PKTBUF,<NPKTBF*PGSIZ>  ; Packet buffer free storage region        |
;RS PUPFRE,7	; Pup free storage header                              |
;NRP PUPBUF,<NPUPBF*PGSIZ>  ; Pup free storage region                  |
                                                                       |
;NPKTBW==NPKTBF*1000  ; # words of packet buffer storage               |
;MAXIQW==NPKTBW/^D15  ; Max # words on one port's input queue          |
MAXIQB==^D15	; Max # buffers on one port's input queue              |
;MAXOQW==NPKTBW/^D15  ; Max # words on one port's output queue         |
MAXOQB==^D15	; Max # buffers on one port's output queue             |
;MAXGQW==NPKTBW/^D10  ; Max # words allowed on gateway queue           |
MAXGQB==^D20	; Max # buffers allowed on gateway queue
MINFIB==^D12	; Min # free input buffers to maintain
MAXFIB==^D20	; Max # free input buffers to maintain


SWAPCD                                                                 |
                                                                       |
; Pup parameter GETAB table                                            |
;PUPPAR::-NPUPLN,,PUPLO	; (0) -# of Pup NVT's, TTY# of first NVT       |
;	PUPBUF		; (1) Start of Pup free storage                |
;	GATEWF		; (2) B0 set if we are a gateway               |
                                                                       |
;NPUPPR==:.-PUPPAR	; Length of this table                         |
                                                                       |
RESCD                                                                  |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 5

; Pup queues

; All queues are doubly-linked through 36-bit link words.
; A queue header is in the form
;	Pointer to queue tail ,, Pointer to queue head
;  where self-pointers denote an empty queue.
; A queue item (e.g. a packet link word) is in the form
;	Pointer to predecessor ,, Pointer to successor
; All pointers point to other queue items or to header words.
; This permits uniform queue management without special cases.

; All Packet Buffers are linked through PBIOBQ except as noted

;RS PBQBEG,0		; Start of queue header block                  |
                                                                       |
; Queues referenced by input interrupt:                                |
                                                                       |
;RS FREIBQ		; Free input buffer queue.                     |
			; Consists of max-length buffers, locked       |
			;  into core, for use by input interrupt       |
                                                                       |
;RS PUPIBQ,NPUPUN	; Input buffer queue, one per port.            |
			; Packets received for that port               |
                                                                       |
;RS DSCIBQ		; Discarded input buffer queue.                |
			; Packets waiting to be logged and discarded
			;  by job 0 or error process


; Queues referenced by output interrupt:

;RS PUPOBQ		; Pup output buffer queue.                     |
			; Packets awaiting service by output interrupt |
                                                                       |
;RS FREOBQ		; Free (discarded) output buffer queue.        |
			; Waiting to be returned to free storage       |
                                                                       |
;RS PBQEND,0		; End of queue header block                    |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 6

; Port-indexed tables

; ** The following are documented GETAB tables **

;RS PUPLSK,NPUPUN	; Local socket number hash table               |
			; 0 => free, -1 => deleted                     |
                                                                       |
;RS PUPLNH,NPUPUN	; Local Net/Host and BSP linkage               |
 PPRTLN: POINT 8,PUPLNH(UNIT),7	; Local net # (0 => wildcard)
 PPRTLH: POINT 8,PUPLNH(UNIT),15 ; Local host # (0 => wildcard)
 ; B16-17			; Unused
 ; B18-35			; Pointer to BSP data block
				; 0 => not a BSP port

;NR PUPFPT,NPUPUN	; Foreign port:  -length,,adr-1 of address table
                                                                       |
			; 0 => foreign port is fully wildcard          |
                                                                       |
;RS PUPSTS,NPUPUN	; Port status word (mostly for BSP)            |
 BSLCKF==1B0			; Port is locked (must be sign)
 BSWAKF==1B1			; BSP wakeup request pending
 BSINPF==1B2			; Input available
 BSOUTF==1B3			; Output possible
 BSMRKF==1B4			; Mark encountered in stream
 BSENDF==1B5			; End encountered in stream
 BSTIMF==1B6			; Timeout
 BSNCHK==1B7			; Supress checksumming
 BSOPNR==1B8			; Port open for reading
 BSOPNW==1B9			; Port open for writing
 DSCRNF==1B10			; Random discard enabled
 BSSAKF==1B11			; Need to send Ack
 BSRAKF==1B12			; Received Ack
 BSZALF==1B13			; Sent Ack with zero allocation
 BSINTF==1B14			; Interrupt outstanding
 BSLISF==1B15			; Port is or has been listening
 BSNOQF==1B16			; BSP output queue is non-empty
 BSERRF==1B17			; Set if port gets in bad state
 ; B18-31 unused
 PBSSTM: POINT 4,PUPSTS(UNIT),35  ; State # in memory
 PBSSTA: POINT 4,PUPSTS(A),35	; State # in memory, indexed by A
 PBSSTT: POINT 4,IOS,35		; State # in usual ac

; ** End of documented GETAB tables **

;RS PUPIBC,NPUPUN	; Input buffer counts                          |
 ; B0-17			; Number of buffers allocated          |
 ; B18-35			; Number of words allocated            |
                                                                       |
;RS PUPOBC,NPUPUN+1	; Output buffer counts                         |
 ; B0-17			; Number of buffers allocated
 ; B18-35			; Number of words allocated
			; Extra entry is for gateway output

;RS PUPPSI,NPUPUN	; Port PSI assignments and other stuff         |
 INTPSI: POINT 6,PUPPSI(UNIT),5	; BSP Interrupt PSI channel
 RECPSI: POINT 6,PUPPSI(UNIT),11  ; Received Packet PSI channel
 STCPSI: POINT 6,PUPPSI(UNIT),17  ; BSP State Change PSI channel
 ; 18-35			; Fork to interrupt (-1 => none)
				;  or 400000 + attached TTY #

; ***** Do not change the order of the following *****

;RS PUPTQH		; Timer queue head                             |
;RS PUPTMQ,NPUPUN	; Timer queue linkage                          |
                                                                       |
;RS PUPFTM		; Time word corresponding to PUPTQH            |
;RS PUPTIM,NPUPUN	; BSP timer                                    |
			; TODCLK at which BSP processing next
			;  required for timing retransmissions

PUPTQD==NPUPUN+1	; PUPTIM-PUPTMQ displacement

; ***** End of do not change *****
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 7

; Definition of BSP data block

DEFINE BSWRD(LABEL) <
	LABEL==BSPSIZ
	BSPSIZ==BSPSIZ+1
>

BSPSIZ==0

BSWRD(BSPHDR)		; Header word
 PBSMRK: POINT 8,BSPHDR(BSP),7	; Value of most recent Mark
 PBSTMO: POINT 8,BSPHDR(BSP),15	; Error timeout interval / 2^12 ms
 ; B16-17			; Unused
 ; B18-35			; Size of BSP data block (words)

BSWRD(BSPTIM)		; BSP timing parameters
 ; B0-17			; Estimated round-trip delay (ms)
 ; B18-35			; Pointer to received Abort if any

; Timer words (TODCLK format) - for flow control and retransmission
BSWRD(BSPACT)		; Time of most recent activity
BSWRD(BSPDTM)		; Time at which to do BSP retransmissions
BSWRD(BSPATM)		; Time last AData was sent
			; 0 => No AData outstanding
BSWRD(BSPITM)		; Time at which to retransmit Interrupt
BSWRD(BSPFTM)		; Time at which to check FSM
BSWRD(BSPSTM)		; Time of most recent FSM state change

; Packet buffer pointers and queues
BSWRD(BSPCUR)		; Current buffers being packed/unpacked
 ; B0-17			; Current input buffer (0 => none)
 ; B18-35			; Current output buffer (0 => none)
BSWRD(BSPIBQ)		; BSP Input queue (linked thru PBBSPQ)
BSWRD(BSPOBQ)		; BSP Output queue (linked thru PBBSPQ)

; Sequence numbers, allocations, counters, etc.
BSWRD(BSPCID)		; BSP Connection ID
			; -1 => no ID assigned yet (listening)
BSWRD(BSPRII)		; BSP Receive Interrupt ID
BSWRD(BSPSII)		; BSP Send Interrupt ID
 ; B0 set => B18-35 point to unacknowledged send Interrupt PB

BSWRD(BSPILW)		; BSP Input left window edge
			; ID of next byte to be removed by
			;  inputting process
BSWRD(BSPIQL)		; BSP Input queue length
 ; B0-17			; # Pups in BSP input queue
 ; B18-35			; # bytes from BSPILW to first hole
BSWRD(BSPIAL)		; BSP Input allocation
 PBSIAP: POINT 8,BSPIAL(BSP),7	; Total input Pups allowed
 PBSIBP: POINT 10,BSPIAL(BSP),17 ; Maximum data bytes/Pup
 ; B18-35			; Maximum # bytes allowed

BSWRD(BSPOLW)		; BSP Output left window edge
			; Pup ID of last received Ack
BSWRD(BSPOQL)		; BSP Output queue length
 ; B0-17			; # Pups in BSP output queue
 ; B18-35			; # bytes spanned by BSP output queue
BSWRD(BSPOAL)		; BSP Output allocation
 PBSOAP: POINT 8,BSPOAL(BSP),7	; Additional Pups allowed
 PBSOBP: POINT 10,BSPOAL(BSP),17 ; Maximum data bytes/Pup
 ; B18-35			; Additional bytes allowed


; Statistics
BSWRD(BSPOPG)		; BSP Output packets generated
BSWRD(BSPOPR)		; BSP Output packets retransmitted
BSWRD(BSPPPG)		; BSP Probe packets generated
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 8

; BSP-related parameters

MXBSIP==3*MAXIQB/4	; Max # Pups we allow on BSP input queue
;MXBSIB==3*<4*MAXIQW>/4	; Max # bytes we allow on BSP input queue      |
MXBSOP==3*MAXOQB/4	; Max # Pups we allow on BSP output queue      |
;MXBSOB==3*<4*MAXOQW>/4	; Max # bytes we allow on BSP output queue     |
MXSACK==0		; Max # Pos/NegAck blocks per Ack Pup
			; 0 => Ignore incoming Pos/NegAcks also
MXPTXT==^D75		; Max # bytes of text in Interrupt, Abort

MINBWI==^D100		; Minimum background wakeup interval (ms)
			; Background process waits at least this long
			; when it dismisses before waking up again.
IBWDLY==^D500		; Input background wakeup delay (ms)
			; When an input packet arrives, wakeup of the
			; background process is delayed this long in
			; hopes that the user fork will process the input
RETINT==^D250		; Nominal retransmission interval (ms)
MAXRET==^D2500		; Maximum retransmission interval
HLDINT==^D1000		; Hold interval (expiration forces AData)
PRBINT==^D15000		; Probe interval for idle connection (ms)
DETINT==^D120		; Default error timeout interval (sec)

ALLPCT==^D25		; % of total allocation (Pups or bytes)
			;  below which an AData is sent to request
			;  new allocation


; Macro to assemble bits corresponding to up to 8 listed port states
; Call by:	STTBTS(STATE1,STATE2, ...)

DEFINE STTBTS(A,B,C,D,E,F,G,H) <<$S(A)+$S(B)+$S(C)+$S(D)+$S(E)+$S(F)+$S(G)+$S(H)>>

DEFINE $S(STATE) <IFNB <STATE>,<1B<S.'STATE>>>


; Macro to assemble code to skip if current state is among those listed
; Call by:	CHKSTT(<STATE1,STATE2, ...>,AC)
; Assumes UNIT setup, clobbers A unless AC specified

DEFINE CHKSTT(STATES,AC<A>) <
	LDB AC,PBSSTT		; Get current state
	MOVE AC,BITS##(AC)	; Get bit corresponding to state
	TLNN AC,(STTBTS(STATES))  ; Skip if among those listed
>



; Pup NVT data
; Indexed by Pup NVT # (= TTY # - PUPLO)
; ** This is a documented GETAB table **

;RS NVTPUP,NPUPLN	; NVT data                                     |
;TTYPUP		; NVTPUP indexable directly by TTY #                   |
 ; B0				; 1 => NVT assigned
 PSYNCT: POINT 3,TTYPUP(B),3	; Sync count (Int's - DM's)
 SYNCNT==7B3			; Mask of bits in sync count
 PSYNTM: POINT 3,TTYPUP(B),6	; Sync timer
 PNVSTT: POINT 2,TTYPUP(B),8	; NVT state for input processing
 PNVMRK: POINT 4,TTYPUP(B),12	; Pending Mark type if any
 HUREQF==1B13			; Hangup request already made
 PTMKCT: POINT 3,TTYPUP(B),16	; Count of incoming timing marks pending
 TMKPNF==1B17			; Outgoing timing mark pending
 ; B18-35			; Pup unit # of attached port


SYNCHI==^D10000		; Sync check interval (ms)
SYNTMO==^D20000/SYNCHI	; Sync timeout interval (20 seconds)

;RS NVTLCK		; Lock for NVT assignment and management       |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 9

; Error handling

; In addition to the usual BUGHLT, BUGCHK, and BUGNTE (for reporting
;  internal errors), there is a collection of BUG types for
;  reporting anomalies associated with a particular Pup and/or
;  discarding that Pup.

; BUGP(PUP,<message>,X)                                                |
;  Copies the header of the packet pointed to by PB into cells
;  looked at by job 0.  If PUPBGF is nonzero, this data is printed
;  on the logging console by job 0.

; BUGP(DIP,<message>,X)                                                |
;  Appends the packet pointer to by PB to the discarded input
;  packet queue (DSCIBQ).  The PC of the BUG is stored in the RH
;  of the PBBSPQ word.  If PUPBGF is nonzero, information
;  about this packet is printed on the logging console by job 0.
;  (Later we may provide a mechanism whereby a user process can
;  arrange to receive all discarded Pups).  The buffer is then
;  deallocated.

; BUGP(DPR,<message>,X)                                                |
;  Same as BUGP(DIP,...) except that an extra POPJ is executed         |
;  so that the routine invoking the BUG is exited.                     |
                                                                       |
DEFINE BUGP(TYP,MSG) <	CALL BGR'TYP >                                 |



; JSYS error macros, adapted from JSYS.MAC

DEFINE ERROR(ERRORN,EXTRA,WHERE) <
IFB <ERRORN'EXTRA>,<JRST WHERE>
IFNB <ERRORN'EXTRA>,<
	JRST [	EXTRA
		IFNB <ERRORN>,<MOVEI A,ERRORN>
		JRST WHERE]
>>

; Load error code and do POPJ P,
DEFINE ERPOPJ(ERRORN,EXTRA) <ERROR(ERRORN,<EXTRA>,R##)>                |
                                                                       |
; Store error code, unlock JFN, and give error return from JSYS        |
DEFINE ERUNLK(ERRORN,EXTRA) <RETERR(ERRORN,<EXTRA                      |
			<CALL UNLCKF>>)>                               |
                                                                       |
; Store error code, unlock JFN, and generate instruction trap          |
DEFINE FILABT(ERRORN,EXTRA) <ITERR(ERRORN,<EXTRA                       |
		<CALL UNLCKF>>)>                                       |
                                                                       |
; Store error code, unlock JFN, and give i/o data error psi            |
DEFINE FILINT(ERRORN,EXTRA) <ERROR(ERRORN,<EXTRA>,DOINT)>              |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 10

; Macro to activate Pup background process.
; SIGPBP(XXX) causes bit PBFXXX to be set in PUPFLG.  This causes
;  the Pup background process to wakeup and call the routine
;  implementing the requested background task (see PUPBAK).
; Optional arguments:
;	SIGPBP(FLAG,<INSTRUCTION>,AC)
; If <INSTRUCTION> is specified, the flag is set iff the
; instruction does not skip.  If AC is specified, it (instead of
; A) is the ac clobbered by the generated code.

DEFINE SIGPBP(FLAG,INST,AC<A>) <
	MOVSI AC,(PBF'FLAG)
	INST
	IORM AC,PUPFLG
>

;RS PUPFLG		; Records Pup background process requests      |
;RS NXTWAK		; Earliest time at which next wakeup permitted |


; Random other data referenced in more than one place.
; (Storage used in only one place is defined at that place)

;RS PRTLCK		; Lock for changes to port tables              |
;RS LSKNDL		; # of deleted entries in local socket table   |
;RS FREIBN		; # buffers in FREIBQ                          |
;RS PUPFRK		; FORKX of Pup background process              |
                                                                       |
;RS SYNTIM		; Time for next sync timeout check             |


; Notes on handling of locks:
; PRTLCK should be locked while attempting to lock a port, then
;  unlocked once the port is locked.
; NVTLCK should be locked while doing anything to an NVT.
; No lock should be held while waiting for a port lock to become free.
; If both NVTLCK and PRTLCK need be locked simultaneously, NVTLCK
;  must be locked first to prevent deadlocks.
; Lockers of PRTLCK should invoke SPQ (Special Queue), unless it is
;  known that the locker is the Pup background fork, which already
;  runs on HIQ.
; Lockers of NVTLCK should invoke HIQ unless it is known that the
;  locker is the Pup background fork.
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 11


; -----------------------------------------------------------------
;	Standard JSYS Routines for Pup
; -----------------------------------------------------------------

SWAPCD                                                                 |
                                                                       |
; Pup device dispatch table                                            |
                                                                       |
PUPDTB::DTBDSP (PUPSET)		; Directory setup                      |
	DTBDSP (PUPNAM)		; Name lookup                          |
	DTBDSP (PUPEXT)		; Extension lookup                     |
	DTBDSP (GJSRET)		; Version lookup                       |
	DTBBAD (DESX9)		; Insert protection                    |
	DTBBAD (DESX9)		; Insert account                       |
	DTBBAD (DESX9)		; Insert status                        |
	DTBDSP (PUPOPN)		; Open                                 |
	DTBDSP (PUPSQI)		; Sequential input                     |
	DTBDSP (PUPSQO)		; Sequential output                    |
	DTBDSP (PUPCLZ)		; Close                                |
	DTBBAD (DESX9)		; Rename                               |
	DTBBAD (DESX9)		; Delete                               |
	DTBBAD (DESX9)		; Dump input                           |
	DTBBAD (DESX9)		; Dump output                          |
	DTBBAD (DESX9)		; Mount                                |
	DTBBAD (DESX9)		; Dismount                             |
	DTBBAD (DESX9)		; Initialize directory                 |
	DTBDSP (PUPMTP)		; MTOPR                                |
	DTBDSP (PUPGST)		; Get status                           |
	DTBDSP (PUPSST)		; Set status                           |
	DTBSKP			; RECORD OUT                           |
	DTBDSP (RFTADN)		; READ TAD                             |
	DTBDSP (SFTADN)		; SET TAD                              |
	DTBDSP (BIOINP)		; SET JFN FOR INPUT                    |
	DTBDSP (BIOOUT)		; SET JFN FOR OUTPUT                   |
	DTBBAD (GJFX49)		; CHECK ATTRIBUTE                      |
                                                                       |
DTBLEN==:.-PUPDTB                                                      |


; Lookup routines called by GTJFN

DEFINE GJERR(ERRORN) <ERROR(ERRORN,,GJERRX)>


; Directory setup routine

PUPSET:	NOINT
	JRST SK2RET##		; Always successful


; Name lookup routine

PUPNAM:	JUMPE A,[GJERR(GJFX31)]	; * not allowed
	HRLI A,(POINT 7,,35)	; Make string pointer
	PUSHJ P,PNMDEC		; Decode name string
	 GJERR(GJFX18)		; Bad, say no such name
	JRST GJ2RET		; Ok, take success return


; Extension lookup routine

PUPEXT:	JUMPE A,[GJERR(GJFX31)]	; * not allowed
	HRLI A,(POINT 7,,35)	; Make string pointer
	PUSHJ P,PEXDEC		; Decode extension string
	 GJERR(GJFX19)		; Bad, say no such extension
	MOVEI B,(A)		; Ok, now just throw the block away
	PUSHJ P,RELPFR
;	JRST GJ2RET		; Take success return


; Version lookup routine (always succeeds, does nothing)


; Returns from GTJFN routines
GJ2RET:	AOS 0(P)		; Double skip
GJSRET:	AOS 0(P)		; Single skip
	TQNE <UNLKF>		; Should we unlock?                    |
	 POPJ P,		; No
GJERRX:	OKINT			; Yes
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 12

; Open Pup network file (OPENF)

DEFINE OPNERR(ERRORN,EXTRA) <ERROR(ERRORN,<EXTRA>,OPNERX)>

; Check mode and byte size
PUPOPN:	TQNN <XCTF,RNDF>	; Xct and append are illegal           |
	TQNN <READF,WRTF>	; Must be reading or writing           |
	 ERPOPJ(OPNX13)		; Illegal access                       |
	TRNE STS,10		; Raw packet mode (16)?                |
	 JRST PUPOP0		; Yes, skip some checks                |
	TQC <READF,WRTF>	; BSP can do only one or the other     |
	TQCN <READF,WRTF>                                              |
	 ERPOPJ(OPNX13)		; Both read and write is illegal
	LDB A,PBYTSZ##		; Get byte size
	CAIE A,7		; Only 7 and 8 allowed
	CAIN A,8
	 CAIA
	 ERPOPJ(SFBSX2)		; Illegal byte size

; Re-parse the name and extension strings to yield addresses
PUPOP0:	HRRZ A,FILNEN(JFN)	; Make byte ptr to extension
	HRLI A,(POINT 7,,35)
	PUSHJ P,PEXDEC		; Decode Pup extension string
	 ERPOPJ(OPNX2)		; Failed (maybe net dir changed?)
	MOVE E,A		; Save address table pointer
	HLRZ A,FILNEN(JFN)	; Make byte ptr to filename
	HRLI A,(POINT 7,,35)
	PUSHJ P,PNMDEC		; Decode Pup name string
	 OPNERR(OPNX2)		; Failed (maybe net dir changed?)

; Now have A/ <net>B7 + <host>B15, B/ socket for local port.
; Check for correct access to the specified socket number
	MOVE C,CAPENB##		; Get privilege bits
	TRNE C,SC%WHL!SC%OPR	; Wheel or operator?                   |
	 JRST PUPOP1		; Yes, can have any socket             |
	MOVE C,B		; No, get high 17 bits                 |
	LSH C,-^D15                                                    |
	MOVE D,JOBNO##		; Get job number                       |
	MOVE D,JOBDIR##(D)	; Connected,,login dir if top fork     |
	CAIN C,(D)		; User-relative for login dir?
	 JRST PUPOP1		; Yes, ok
	HLRZ D,D		; Try connected dir
	CAIL C,^D50000		; Socket in free-for-all range?
	 CAILE C,^D99999
	 CAIN C,(D)		; No, user-relative for this fork?
	 JRST PUPOP1		; Either of those, socket ok
	MOVE D,JOBNO		; No, get job number
	CAIE C,^D100000(D)	; Job-relative for this job?
	 OPNERR(OPNX13)		; No, illegal access to socket
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 13

; OPENF (cont'd)

; If mode 0, 1, or 4, ensure foreign port is not multiple or wild
PUPOP1:	TRNE STS,12		; Ok if mode 2, 3, or 16
	 JRST PUPOP3
	CAML E,[-2,,0]		; Multiple?
	 JRST PUPOP2		; No, go check for wildcard

; Multiple foreign address
; Pick the first one on a directly-connected network, or else the
;  first one that is accessible.
	PUSH P,A		; Save local port address
	PUSH P,B
	MOVE D,E		; Copy foreign address table ptr
	SETZ C,			; No choice yet
PUPO1A:	HLRZ A,1(D)		; Get a net from table
	CAIL A,1		; In range?
	 CAILE A,NPNETS
	 JRST PUPO1B		; No
	SKIPGE B,PUPROU-1(A)	; Yes, get entry
	 JRST PUPO1B		; Inaccessible, ignore
	SKIPN C			; Ok, already have saved index?
	 MOVE C,D		; No, save index
	TLNN B,(177777B17)	; Routing directly to net?
	 JRST PUPO1C		; Yes, use this entry
PUPO1B:	AOBJN D,.+1		; Advance table pointer (2 words)
	AOBJN D,PUPO1A		; Try next if any remain
PUPO1C:	JUMPE C,[POP P,B	; Fail if none found
		POP P,A
		OPNERR(PUPX2)]
	MOVE A,1(C)		; Store selected address at
	MOVEM A,1(E)		;  start of block
	MOVE A,2(C)
	MOVEM A,2(E)
	MOVEI A,0(E)		; Copy pointer to block
	MOVEI B,3		; New size of block
	PUSHJ P,TRMPFR		; Trim the address block
	HRLI E,-2		; Now just 2 words in table
	POP P,B			; Recover local port
	POP P,A

; Give error if foreign port now has any wildcard elements.
; Substitute appropriate values for wildcard local net/host
PUPOP2:	SKIPN 2(E)		; Wild socket?
	 OPNERR(PUPX2)		; Yes, address error
	HLRZ C,1(E)		; Get net
	SKIPE C			; Wildcard?
	 CAILE C,NPNETS		; Out of range?
	 OPNERR(PUPX2)		; Yes, address error
	HRRZ D,1(E)		; Get host
	SKIPE D			; Wildcard?
	 SKIPGE D,PUPROU-1(C)	; Dest net inaccessible?
	 OPNERR(PUPX2)		; Yes, address error
	JUMPN A,PUPOP3		; Local net/host specified?
	TRNN D,-1		; No, are we on dest net?
	 LDB C,[POINT 8,PUPROU-1(C),9]  ; No, use net of gateway
	HRRZ D,PUPROU-1(C)	; Get our address on that net
	ROT D,-8		; Concatenate net/host
	LSHC C,-8		; Left-justify in D
	MOVE A,D		; Put in proper ac
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 14

; OPENF (cont'd)

; Now have A/ <net>B7 + <host>B15, B/ socket for local port.
; Attempt to assign the local port
PUPOP3:	PUSHJ P,ASGPRT		; Assign local port
	 OPNERR(OPNX10)		; Failed, tables full
	 JRST PUPOP6		; Duplicate, check for legal cases
	HRLM UNIT,FILSKT(JFN)                                          |
	MOVE A,FORKX##		; Record fork owning port
	HRRM A,PUPPSI(UNIT)
	MOVEM E,PUPFPT(UNIT)	; Save address table pointer
	TRNN STS,10		; Raw packet mode?
	 JRST PUPOP4		; No, BSP, more to do

; Successful open in raw packet mode, finish up and return
	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Unlock local socket table
	SKIPN 1(E)		; Is foreign port fully wildcard?
	SKIPE 2(E)
	RETSKP			; No, done                             |
	SETZM PUPFPT(UNIT)	; Yes, remember so                     |
	MOVEI B,(E)		; Release the address block            |
	PUSHJ P,RELPFR                                                 |
	RETSKP			; Done, skip return                    |

; Here if BSP mode.  Lock port and setup BSP data block
PUPOP4:	PUSHJ P,BLDBSP		; Allocate and build BSP data block
	 OPNERR(OPNX10,<UNLOCK(PRTLCK,RESIDENT,SPQ)>)  ; Failed
	HRRM BSP,PUPLNH(UNIT)	; Store pointer in standard place
	MOVSI IOS,(BSLCKF+BSOPNR)  ; Assume opening for reading
	TQNE <WRTF>		; Writing?                             |
	 MOVSI IOS,(BSLCKF+BSOPNW)  ; Yes                              |
	MOVEM IOS,PUPSTS(UNIT)	; Initialize port status word          |
	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Unlock local socket table       |
	XCTU [HLRZ A,2]	; Get lh 2 from user                           |
	TRNE A,377		; Timeout interval specified?
	 DPB A,PBSTMO		; Yes, set it

; Initiate appropriate operations to open a connection
	TRNE STS,2		; Listening?
	 JRST [	TLO IOS,(BSLISF)  ; Yes, remember so
		MOVEI A,E.OPNL	; Generate event OPENF(L)
		JRST PUPOP5]
	TRNE STS,4		; Direct open (no rendezvous)?
	 JRST [	UMOVE A,3	; Yes, get Connection ID from user
		PUSHJ P,SETCID	; Set it in data block
		MOVEI A,E.OPNN	; Generate event OPENF(N)
		JRST PUPOP5]
	MOVEI A,E.OPNC		; Initiating rendezvous, OPENF(C)
PUPOP5:	PUSHJ P,PUPFSM		; Activate the FSM appropriately
	JRST PUPOP7		; Go wait if necessary

; Here if local port already in use, check for legal case
PUPOP6:	HRRZ BSP,PUPLNH(UNIT)
	SKIPE BSP		; Already open in raw packet mode?
	TRNE STS,10		; Opening in raw packet mode?
	 OPNERR(OPNX9,<UNLOCK(PRTLCK,RESIDENT,SPQ)>)  ; Yes, fail
	HRRZ A,PUPPSI(UNIT)	; No, get fork that did first open
	HLRZ A,FKJOB##(A)	; Get job
	CAME A,JOBNO		; Same as me?
	 OPNERR(OPNX9,<UNLOCK(PRTLCK,RESIDENT,SPQ)>)  ; No, fail
	MOVEI B,(E)		; Ok, get rid of address table
	PUSHJ P,RELPFR
	PUSHJ P,LCKBSA		; Attempt to lock the port
	 JRST [	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Can't, unlock the table
		MOVSI A,(UNIT)	; Set scheduler test
		HRRI A,BSLCKT	;  for port unlocked
		MDISMS		; Wait until unlocked                  |
		JRST PUPOP0]	; Try again
	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Ok, unlock the table
	PUSHJ P,SETRWB		; Setup read/write bit for this opening
	TDOE IOS,A		; Flag opening, check for conflict
	 ERPOPJ(OPNX9,<PUSHJ P,ULKBSP>)  ; Already open, fail
	HRLM UNIT,FILSKT(JFN)                                          |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 15

; OPENF (cont'd)

; Here to wait for completion if necessary
PUPOP7:	CHKSTT <OPEN,ENDI,ENDO,DALY,ABOR,CLOS>  ; Beyond LIST/RFCO state?
	 TRNE STS,5		; Immediate return OPENF?
	 JRST PUPOP8		; Yes, bypass waiting
	PUSHJ P,ULKBSP		; Unlock port
	TQO <OPNF>		; Mark JFN as being open               |
	MOVSI A,1		; Fix reference count (?)
	IORM A,FILLFW(JFN)
	PUSHJ P,UNLCKF##	; Unlock file, go OKINT
	MOVSI A,(ALLSTT-STTBTS(LIST,RFCO))
	PUSHJ P,WATSTT		; In desired state now?
	MDISMS			; No, wait until get there             |

; Check whether the connection was opened successfully
; This is somewhat hairy since a PSI or another fork could have
;  released and re-used the JFN in the meantime
	PUSH P,JFN+1                                                   |
	IDIVI JFN,MLJFN		; CONVERT FROM INTERNAL FORMAT         |
	POP P,JFN+1                                                    |
	PUSHJ P,CHKJFN##	; NOINT, lock JFN again                |
	 RETERR()		; Huh? (released by PSI maybe)         |
	 ERUNLK(DESX4)                                                 |
	 ERUNLK(DESX4)                                                 |
	HRRZ A,FILDEV(JFN)	; Get DTB                              |
	CAIE A,PUPDTB		; Is it a PUP                          |
	 ERPOPJ(DESX5)                                                 |
	HLRZ A,FILSKT(JFN)	; Make sure JFN still refers to        |
	CAIE A,(UNIT)                                                  |
	 ERPOPJ(DESX5)		; Not, fail                            |
	TQNE <OPNF>		; Make sure JFN still open             |
	 PUSHJ P,LCKBSQ		; Lock the port again
	 ERPOPJ(DESX5)		; Not open or not BSP port
	MOVSI A,1		; Undo reference count diddle
	ANDCAM A,FILLFW(JFN)

; Come directly here in immediate-return modes
PUPOP8:	CHKSTT <CLOS,ABOR>	; Connection closed or aborted?
	 TDZA A,A		; No, assume no error
	 MOVEI A,OPNX21		; Yes, assume rejected by foreign host
	TLNE IOS,(BSTIMF)	; Timed out?
	 MOVEI A,OPNX20		; Yes, assume nobody there
	JUMPN A,PUPOP9		; Jump if failed to open
	PUSHJ P,ULKBSP		; Succeeded, unlock port
	RETSKP			; Give success return                  |

; Here if rendezvous attempt failed
; Clean up and give error return, A/ error code
PUPOP9:	HRLM A,0(P)		; Save error code
	MOVEI A,E.CLST		; Generate CLOSF(T) event
	HRROI C,0		; Set code for Abort if any
	HRROI D,[ASCIZ /Connection attempt timed out/]
	PUSHJ P,PUPFSM		; Force state to closed
	PUSHJ P,PUPCL3		; Delete port if appropriate
	 BUG(HLT,PUPOPA,<PUPOPN: Impossible +1 return from PUPCL3>)    |
	TQZ <OPNF>		; JFN no longer open                   |
	HLRZ A,0(P)		; Recover error code
	POPJ P,			; Fail return from OPENF



; Here to fail return from early parts of the OPENF when we have
;  address table assigned but port not open yet (OPNERR macro)
; A/ error code, E/ address table pointer
OPNERX:	PUSH P,A		; Save error code
	MOVEI B,(E)		; Release address table
	PUSHJ P,RELPFR
	POP P,A
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 16

; Close Pup network file (CLOSF)

PUPCLZ:	HLRZ UNIT,FILSKT(JFN)	; Setup Pup unit #                     |
	PUSHJ P,LCKBSQ		; Lock port if BSP
	 JRST PUPCL8		; Not BSP, jump around BSP logic
	SETZM FILCNT(JFN)	; Allow no further i/o
	TLZE IOS,(BSTIMF)	; Timed out?
	 JRST [	MOVEI A,E.CLST	; Yes, generate CLOSF(T) event
		HRROI C,0	; Abort Code = 0 (need registered code ******)
		HRROI D,[ASCIZ /Connection timed out/]
		PUSHJ P,PUPFSM
		TQO <ERRF>	; Set JFN error flag                   |
		ERPOPJ(IOX5,<PUSHJ P,ULKBSP>)]  ; Give error return    |
	TQNN <WRTF>		; Closing output JFN?                  |
	 JRST [	TLNN IOS,(BSOPNW)  ; No, is port also open for writing?|
		 JRST PUPCL2	; No, generate close event             |
		JRST PUPCL3]	; Yes, do nothing for input close      |
	UMOVE A,1		; Get flags from call                  |
	TLNE A,(CZ%ABT)		; Was this an abort?                   |
	 JRST [	MOVEI A,E.CLST	; Yes, then send an abort              |
		JRST PUPCL4 ]	; Skip actions that might block        |
	CHKSTT <OPEN,ENDI>	; State ok for BSP output?
	 JRST PUPCL2		; No, skip this
	MOVE A,FILBYT(JFN)	; Yes, get byte ptr to last byte stored
	PUSHJ P,FRCBSP		; Force out remaining data if any
	PUSHJ P,CHKBOQ		; Any output pending?
	 JRST CLZWAT		; Yes, back out and wait til done
PUPCL2:	MOVEI A,E.CLSN		; Generate CLOSF(N) event
PUPCL4:	HRROI C,0		; Need registered code ************    |
	HRROI D,[ASCIZ /Connection attempt abandoned/]  ; In case RFC Out
	PUSHJ P,PUPFSM
	MOVSI A,(STTBTS(CLOS,ABOR))  ; Specify desired states
	PUSHJ P,WATSTT		; Now closed or aborted?
	 JRST CLZWAT		; No, back out and wait until it is
	LDB A,PBSSTT		; Yes, get current state
	CAIE A,S.CLOS		; Now closed?
	 ERPOPJ(IOX5,<PUSHJ P,ULKBSP>)  ; No, give error return

; Called here from OPENF code to clean up after rendezvous failure
PUPCL3:	PUSHJ P,SETRWB		; Setup status bit for this opening
	ANDCM IOS,A		; Mark no longer open this way
	TLNE IOS,(BSOPNR+BSOPNW)  ; Still open the other way?
	 JRST [	PUSHJ P,ULKBSP	; Yes, don't delete port yet
		RETSKP	]	; Success return                       |
	PUSHJ P,FLSBSQ		; Now closed both ways, flush queues

; Now delete the port (still locked if BSP port)
PUPCL8:	MOVEI A,PUPOBC(UNIT)	; Check output counts
	SKIPE 0(A)		; Output pending for this port?
	 PUSHJ P,DISE##		; Yes, wait until all gone
	PUSHJ P,DELPRT		; Delete the port
	RETSKP			; Done, skip return                    |

; Must set bit in FILLFW before backing out of CLOSF.
; I don't really understand what the FILLFW bullshit is all about.
CLZWAT:	MOVSI B,1
	IORM B,FILLFW(JFN)
	JRST ULKWAT



; Setup read/write bit appropriately for this opening of port
;	STS/ File status
; Returns +1:  A/ BSOPNR or BSOPNW set

SETRWB:	MOVSI A,(BSOPNR)	; Assume opening for reading
	TQNE <WRTF>		; Writing?                             |
	 MOVSI A,(BSOPNW)	; Yes, say so
	POPJ P,


; Pup kill fork
; Called to clean up Pup tables when a fork is killed
; Returns +1
; Clobbers A, UNIT

PUPKFK::MOVSI UNIT,-NPUPUN	; For all ports:
PUPKF1:	HRRE A,PUPPSI(UNIT)	; Get fork to be interrupted
	CAMN A,FORKX##		; Same as fork being killed?
	 SETOM PUPPSI(UNIT)	; Yes, deassign interrupt for port
	AOBJN UNIT,PUPKF1
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 17

; Pup sequential byte input
;	JFN, DEV, STS setup
; Returns +1 always, A/ the next byte (if no error)
; Clobbers A-D, UNIT, BSP, PB

PUPSQI:	SOSGE FILCNT(JFN)	; Decrement and test byte count
	 JRST PUPSI1		; Pup exhausted, get another
	ILDB A,FILBYT(JFN)	; Bytes remain, load next
	AOS FILBYN(JFN)		; Advance byte number
	POPJ P,			; Return

; Here when input Pup used up, attempt to get next
PUPSI1:	HLRZ UNIT,FILSKT(JFN)	; Get Pup unit #                       |
	PUSHJ P,LCKBSQ		; Lock port, check for BSP
	 FILABT(IOX1)		; Not BSP, sequential i/o illegal
	CHKSTT <OPEN,ENDI,ENDO,DALY>  ; Check for legal state
	 JRST PUPSQE		; Not good, set error bit
	TLNE IOS,(BSMRKF+BSENDF+BSTIMF)  ; Eof or errors?
	 JRST PUPSI2		; Yes, don't try for more Pups
	PUSHJ P,GETBSP		; No, get next Pup from stream
	 JRST [	CHKSTT(<ENDI,DALY>,B)  ; Empty, has End been received?
		 JRST ULKWAT	; No, back out and wait for data
		TLO IOS,(BSENDF)  ; Yes, set End encountered flag
		JRST PUPSI2]	; Do eof handling
	LDB A,PUPTYP		; Got one, get Pup Type
	CAIE A,PT.MRK		; Mark?
	 CAIN A,PT.AMA		; AMark?
	 JRST [	ILDB A,PBBSID(PB)  ; Yes, get the byte
		DPB A,PBSMRK	; Store in status word
		PUSHJ P,RELPKT	; Release the packet
		HRRZS BSPCUR(BSP)  ; Note no current packet
		TLO IOS,(BSMRKF)  ; Set Mark encountered flag
		JRST PUPSI2]	; Do eof handling
	PUSHJ P,ULKBSP		; Data or AData, unlock port
	MOVE A,PBBSBC(PB)	; Get byte count
	MOVEM A,FILCNT(JFN)	; Store it in standard place
	ADDM A,FILLEN(JFN)	; Extend file length
	MOVE A,PBBSID(PB)	; Get byte pointer
	MOVEM A,FILBYT(JFN)	; Store it in standard place
	JRST PUPSQI		; Back to get first byte

; Here if any error flags are set
PUPSI2:	TLNE IOS,(BSMRKF+BSENDF)  ; Mark or End encountered?
	 TQO <EOFF>		; Yes, set eof flag for JFN            |
	TLNE IOS,(BSTIMF)	; Timeout                              |
PUPSQE:	 TQO <ERRF>		; Yes, set error flag for JFN          |
	PUSHJ P,ULKBSP		; Unlock port
	POPJ P,			; Return with no data
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 18

; Pup sequential byte output
;	A/ Byte to be output
;	JFN, DEV, STS setup
; Returns +1 always
; Clobbers A-D, UNIT, BSP, PB

PUPSQO:	SOSGE FILCNT(JFN)	; Decrement and test byte count
	 JRST PUPSO1		; Pup full, attempt to send
	IDPB A,FILBYT(JFN)	; Still room, store byte
	AOS FILBYN(JFN)		; Advance byte number
	POPJ P,			; Return

; Here when output Pup full, attempt to send it and start another
PUPSO1:	HRLM A,0(P)		; Save the byte to be output
	HLRZ UNIT,FILSKT(JFN)	; Get Pup unit #                       |
	PUSHJ P,LCKBSQ		; Lock port, check for BSP
	 FILABT(IOX2)		; Not BSP, sequential i/o illegal
	CHKSTT <OPEN,ENDI>	; Check for reasonable state
	 JRST PUPSQE		; Not good, set error bit
	TLNE IOS,(BSTIMF)	; Timeout?
	 JRST PUPSQE		; Yes, set error flag
	MOVE A,FILBYT(JFN)	; Get ptr to last byte stored
	PUSHJ P,DMPBSP		; Force out current Pup if any
	PUSHJ P,CHKBSO		; See if more BSP output possible
	 JRST ULKWAT		; No, back out and wait for Ack
	PUSHJ P,BLDDAT		; Yes, build virgin Data packet
	 JRST ULKWAT		; Failed to allocate space
	MOVEM A,FILCNT(JFN)	; Store byte count
	MOVEM B,FILBYT(JFN)	; Store byte pointer
	PUSHJ P,ULKBSP		; Unlock port
	HLRZ A,0(P)		; Recover the new byte
	JRST PUPSQO		; Back to store it
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 19

; Get status (GDSTS)
;	User 3/ Size ,, address of block to return foreign port
;		address table in (see PUPNM), or 0 to omit table
; Returns +1:
;	A/ BSP status word (to be returned to user ac2)
;	User 3/ size of address table ,, unchanged

PUPGST:	TQNN <OPNF>		; Make sure open                       |
	 JRST [	SETZ A,		; Not open, return zero status         |
		XCTU [HRRZS 3]	; Zero address count                   |
		POPJ P,]                                               |
	HLRZ UNIT,FILSKT(JFN)	; Get Pup unit #                       |
	PUSHJ P,LCKBSQ		; Lock port if BSP
	 CAI			; Not BSP
	UMOVE E,3		; Get user block pointer
	JUMPLE E,PUPGS2		; Omit if none
	HLRZ D,E		; Get count
	SKIPN B,PUPFPT(UNIT)	; Have address table?
	 JRST [	SETZ A,		; No, make zero net/host
		HRLI E,A	; Make BLT "from" address
		MOVEI C,2	; Size is 2
		JRST PUPGS1]
	HLRE C,B		; Yes, get -count
	MOVN C,C		; Make positive
	HRLI E,1(B)		; Make BLT "from" address
PUPGS1:	XCTU [HRLM C,3]		; Return count                         |
	CAILE C,(D)		; Have more than user wants?           |
	 MOVEI C,(D)		; Yes, take minimum                    |
	ADDI C,(E)		; Make BLT end pointer                 |
	XBLTMU [BLT E,-1(C)]	; Copy address table to user           |
PUPGS2:	MOVE A,PUPSTS(UNIT)	; Get status
	PUSHJ P,ULKBSQ		; Unlock port if BSP
	POPJ P,


; Set status (SDSTS)
;	A/ BSP status word to set (from user ac2)
; Returns +1

PUPSST:	HLRZ UNIT,FILSKT(JFN)	; Get Pup unit #                       |
	PUSHJ P,LCKBSQ		; Lock port if BSP
	 CAI			; Not BSP
	MOVE B,A		; Copy new status
	AND A,BSSETB		; Mask bits user may set
	IOR IOS,A		; Set them
	ANDCA B,BSCLRB		; Mask bits user may clear
	ANDCM IOS,B		; Clear them
	TLNN IOS,(BSMRKF!BSENDF) ; Mark and end flags now clear?
	 TQZ <EOFF>		; Yes, clear jfn EOF flag              |
	TLNN IOS,(BSTIMF)	; Timeout flag now clear?              |
	 TQZ <ERRF>		; Yes, clear jfn error flag            |
	PUSHJ P,ULKBSQ		; Unlock port if BSP
	POPJ P,

BSSETB:	BSNCHK+DSCRNF		; Bits that user may set
BSCLRB:	BSMRKF+BSTIMF+BSNCHK+DSCRNF  ; Bits that user may clear
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 20

; Miscellaneous JSYS routines not dispatched through the standard
;  dispatch mechanism (PUPDTB)
; Convert jfn to absolute network socket number                        |
; Call:	1	; Jfn                                                  |
;	CVSKT                                                          |
; Returns                                                              |
;	+1	; Error                                                |
;	+2	; Ok, in 2 the absolute socket number                  |
                                                                       |
.CVSKT::MCENT                                                          |
	MOVE JFN,1                                                     |
	PUSHJ P,CHKJFN                                                 |
	 JRST CVSER0                                                   |
	 JRST CVSER0                                                   |
	 JRST CVSER0                                                   |
	HLRZ A,FILNEN(JFN)                                             |
	HRLI A,(<POINT 7,0,35>)                                        |
	HRRZ B,FILDEV(JFN)	; Get device                           |
	CAIN B,PUPDTB		; Is it a PUP JFN?                     |
	 JRST CVPSKT		; Yes, convert it                      |
                                                                       |
CVSER1:	PUSHJ P,UNLCKF                                                 |
	SKIPA A,[CVSKX2]                                               |
CVSER0:	MOVEI A,CVSKX1                                                 |
	JRST MRETNE                                                    |

; Return local port address (including absolute socket #) (CVSKT)
;	JFN (etc.)/ already setup (see .CVSKT in NETWRK)
;	A/ string ptr to filename string
; Returns +1 to user:  Unsuccessful, 1/ error #
;	+2 to user:  Successful,
;		user 2/ net ,, host
;		user 3/ socket

CVPSKT:	TQNN <OPNF>		; Open?                                |
	 JRST [	PUSHJ P,PNMDEC	; No, just decode filename             |
		 ERUNLK(CVSKX2)	; Failed (net dir changed?)            |
		JRST CVPSK1]                                           |
	HLRZ UNIT,FILSKT(JFN)	; Yes, get Pup unit #                  |
	MOVE A,PUPLNH(UNIT)	; Pick up local net/host
	MOVE B,PUPLSK(UNIT)	;  and socket
CVPSK1:	UMOVEM B,3		; Return socket in 3
	LSHC A,-^D<36-8>	; Reformat net/host to net,,host
	LSH A,^D<18-8>
	LSHC A,^D8
	UMOVEM A,2		; Return net,,host in 2
	PUSHJ P,UNLCKF
	JRST SKMRTN##		; Skip return to user



DEFINE ATPERR(ERRORN,EXTRA) <ERROR(ERRORN,<EXTRA>,ATPER4)>             |
                                                                       |
; Attach sockets to pty                                                |
; Call:	1	; Receive jfn of opened network connection             |
;	2	; Send jfn of opened network connection                |
;	ATNVT                                                          |
; Returns                                                              |
;	+1	; Cannot attach                                        |
;	+2	; Ok.  the jfns are released, ac 1 has line number of  |
;		; Attached pty.                                        |
                                                                       |
.ATNVT::MCENT                                                          |
	UMOVE JFN,1                                                    |
	HRRZS JFN                                                      |
	PUSHJ P,CHKJFN		; Check jfn of receive connection      |
	 JRST ATPER0		; Only real jfns are legal             |
	 JRST ATPER0                                                   |
	 JRST ATPER0                                                   |
	MOVEI A,ATNX2		; Error code if test skips             |
	TQNE <READF>		; MUST BE OPENED FOR READING           |
	PUSHJ P,CHKATP		; Check for dev=net, open, no buffer   |
	 JRST ATPER1		; Failed one of the above              |
	HLRZ UNIT,FILSKT(JFN)                                          |
	PUSH P,UNIT		;SAVE DEV AND JFN                      |
	PUSH P,JFN                                                     |
ATNVT1:	UMOVE JFN,2		; Get send jfn                         |
	PUSHJ P,CHKJFN		; Check it                             |
	JRST ATPER2		; Must also be a real jfn              |
	JRST ATPER2                                                    |
	JRST ATPER2                                                    |
	MOVEI A,ATNX2		; Becomes atNx8 at atper3              |
	TQNE <WRTF>		; THIS ONE MUST BE FOR WRITING         |
	PUSHJ P,CHKATP		; And dev=net, open, no buffer         |
	 JRST ATPER3		; Failed above tests                   |
	HLRZ UNIT,FILSKT(JFN)                                          |
                                                                       |
; Attach port to Pup NVT (ATPTY)
;	JFN/ Send JFN  (see .ATPTY in NETWRK)
;	DEV/ Send DEV
;	UNIT/ Send UNIT
;	0(P)/ Receive JFN
;	-1(P) Receive DEV
; Both JFN's locked and verified to be open Pup JFN's
; Returns +1 to user:  Error, 1/ error code
;	+2 to user:  Success, 1/ Attached TTY designator, JFN's released

ATPNVT:	MOVE A,0(P)		; Get send JFN                         |
	HLRZ A,FILSKT(A)	; Get send unit nbr                    |
	HLRZ B,FILSKT(JFN)	; Get rcv unit nbr                     |
	CAME A,B		; Both JFNs point to same port?        |
	 ATPERR(ATNX15)		; No, fail                             |
	PUSHJ P,LCKBSQ		; Yes, attempt to lock it              |
	 ATPERR(ATNX16)		; Not BSP port, fail                   |
	CHKSTT <OPEN>		; Connection must be open              |
	 ATPERR(ATNX17,<PUSHJ P,ULKBSP>)  ; Not, fail                  |
	PUSHJ P,ASPNVT		; Assign Pup NVT                       |
	 ATPERR(ATNX13,<PUSHJ P,ULKBSP>)  ; None available, fail       |
	MOVEI A,400000(B)	; Convert line # to TTY designator
	UMOVEM A,1		; Return it to user
	MOVE A,FILBYT(JFN)	; Get ptr to last byte stored
	PUSHJ P,DMPBSP		; Force out partial Pup if any
	PUSHJ P,ULKBSP		; Unlock port
	PUSHJ P,RELJFN##	; Release send JFN
	POP P,JFN
	PUSHJ P,RELJFN##	; Release receive JFN
	JRST SKMRTN##		; Skip return to user
                                                                       |
; Check validity of jfn for atpty                                      |
                                                                       |
CHKATP:	MOVEI A,ATNX3		; Receive not open                     |
	TQNN <OPNF>		; IS IT OPEN?                          |
	POPJ P,			; NO                                   |
	HRRZ B,FILDEV(JFN)                                             |
	MOVEI A,ATNX4                                                  |
	CAIN B,PUPDTB                                                  |
	AOS 0(P)                                                       |
	POPJ P,                                                        |
                                                                       |
ATPER2:	MOVEI A,ATNX7		; Bad send jfn                         |
	JRST ATPER5                                                    |
                                                                       |
ATPER3:	ADDI A,ATNX7-ATNX1	; Convert receive errors to send errors|
ATPER4:	PUSHJ P,UNLCKF                                                 |
ATPER5:	MOVE JFN,0(P)		;GET RECIEV JFN                        |
	MOVE STS,FILSTS(JFN)                                           |
ATPER1:	PUSHJ P,UNLCKF                                                 |
	JRST MRETNE		; Save error return in ac1             |
                                                                       |
ATPER0:	MOVEI A,ATNX1		; Bad receive jfn                      |
	JRST MRETNE                                                    |
^L                                                                     |


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 21

; PUPSK  - get net,host and socket for a pupnvt                        |
; Call: 1	; tty desgnator                                        |
;     PUPSK                                                            |
; Returns                                                              |
;	 +1	 2=net,,host                                           |
;                3= socket                                             |
;    itraps on any error                                               |
                                                                       |
.PUPSK::MCENT			; Enter monitor                        |
	UMOVE JFN,1		; Get tty desg                         |
	CALL CHKJFN		; See if valid tty                     |
	 RETERR()		; bad                                  |
	 JRST PUPSK1		; TTY desg                             |
	 ERUNLK(DESX4)		; byte ptr, bad                        |
	 ERUNLK(DESX4)		; file, bad                            |
PUPSK1:	HLRZ 2,13		; Get tty number from DEV              |
	CALL LCKTTY		; Lock tty                             |
	 JRST PUPSK3		; Doesnt really exist                  |
	CALL PUPCTY		; Is this a pup tty?                   |
	 JRST PUPSK3		; No, error                            |
	HRRZ A,TTYPUP(B)	; Get pup unit number                  |
	SKIPN C,PUPFPT(A)	; Get foreign port address             |
	 JRST PUPSK3		; Something wrong                      |
	MOVE A,1(C)		; Get net,,host                        |
	UMOVEM A,2		; Return it to caller                  |
	MOVE A,2(C)		; Get socket                           |
	UMOVEM A,3                                                     |
	CALL ULKTTY		; Unlock tty                           |
	CALL UNLCKF		; Unlock jfn                           |
	JRST SKMRTN		; Return it                            |
                                                                       |
PUPSK3:	CALL ULKTTY		; Unlock tty                           |
PUPSK2:	ERUNLK(PUPX9)		; Return error                         |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 22

; Dismiss until input buffer empty (DIBE)
;	JFN (etc.)/ already setup (see .DIBE in JSYS)
; Returns +1

PUDIBE::CALL CHKPUP		; Make sure this is a PUP jfn          |
	 RET			; No, return                           |
	AOS (P)			; At least a 1 skip return             |
	PUSHJ P,CHKBSP		; Check for good BSP JFN               |
	 JRST UNLCKF		; Not, ignore                          |
	 JRST [ MOVEI A,IOX5                                           |
		CALL DOINT                                             |
		CALL UNLCKF                                            |
		RET ]		; Bad state, give i/o data error       |
	HRRZ A,BSPIQL(BSP)	; Any input bytes queued?
	JUMPE A,ULKBSP		; Return now if none
	MOVEI A,PDIBET		; Yes, set scheduler test
	HRLI A,(UNIT)
	TLO IOS,(BSINPF)	; Flag that input is queued
	CALL ULKWAT		; Back out and wait                    |
	JRST UNLCKF		; Unlock jfn                           |
                                                                       |
RESCD                                                                  |

; Scheduler test for input buffer empty (or error)
; Arg is Pup unit index

PDIBET:	MOVE B,PUPSTS(A)	; Get port status word
	TLNE B,(BSINPF)		; Input buffer empty?
	 TLNE B,(BSTIMF+BSERRF)	; No, error?
	 JRST 1(D)		; Yes, wakeup
	JRST 0(D)		; No, wait

SWAPCD                                                                 |


; Dismiss until output buffer empty (DOBE)
;	JFN (etc.)/ already setup (see .DOBE in JSYS)
; Returns +1

PUDOBE::CALL CHKPUP		; Make sure this is a PUP jfn          |
	 RET			; No, return                           |
	AOS (P)			; At least a 1 skip return             |
	PUSHJ P,CHKBSP		; Check for good BSP JFN               |
	 JRST UNLCKF		; Not, ignore                          |
	 FILINT(IOX5)		; Bad state, give i/o data error       |
	TQNN <WRTF>		; Open for writing?                    |
	 FILABT(IOX2,<PUSHJ P,ULKBSP>)  ; No, generate instruction trap|
	CHKSTT <OPEN,ENDI>	; Check for reasonable state           |
	 JRST [	TQO <ERRF>	; Bad, give error                      |
		POPJ P,]
	MOVE A,FILBYT(JFN)	; Get ptr to last byte stored
	PUSHJ P,FRCBSP		; Force out partial Pup if any
	SETZM FILCNT(JFN)	; Zero byte count
	PUSHJ P,CHKBOQ		; Check for empty output queue
	 JRST ULKWAT		; Not empty, back out and wait
	CALL ULKBSP		; Empty, done                          |
	JRST UNLCKF		; Unlock file                          |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 23

; Skip if input buffer empty (SIBE)
;	JFN (etc.)/ already setup (see .SIBE in JSYS)
; Returns +1:  Not empty, A/ # of buffered bytes
;	+2:  Empty

PUSIBE::CALL CHKPUP		; Make sure this is a PUP jfn          |
	 RET			; No, return                           |
	AOS (P)			; At least a 1 skip return             |
	PUSHJ P,CHKBSP		; Check for good BSP JFN               |
	 JRST [ CALL UNLCKF	; Unlock JFN                           |
		RETSKP ]	; Not, give empty return               |
	 JRST [ CALL UNLCKF                                            |
		RETSKP ]	; Bad state, give empty return         |
	HRRZ A,BSPIQL(BSP)	; Get # of input bytes available
	SKIPL FILCNT(JFN)	; Any bytes in current buffer?
	 ADD A,FILCNT(JFN)	; Yes, include those too
	SKIPG A			; Any bytes available?
	 AOS 0(P)		; No, preset skip return
	CALL ULKBSP		; Unlock port and return               |
	JRST UNLCKF                                                    |


; Skip if output buffer empty (SOBE)
;	JFN (etc.)/ already setup (see .SOBE in JSYS)
; Returns +1:  Not empty, A/ # of buffered bytes
;	+2:  Empty

PUSOBE::CALL CHKPUP		; Make sure this is a PUP jfn          |
	 RET			; No, return                           |
	AOS (P)			; At least a 1 skip return             |
	PUSHJ P,CHKBSP		; Check for good BSP JFN               |
	 JRST [	CALL UNLCKF                                            |
		RETSKP ]	; Not, give empty return               |
	 JRST [	CALL UNLCKF                                            |
		RETSKP ]	; Bad state, give empty return         |
	HRRZ A,BSPOQL(BSP)	; Get # of output bytes pending        |
	SKIPG A			; Are there any?                       |
	 AOS 0(P)		; No, preset skip return               |
	CALL ULKBSP		; Unlock port and return               |
	JRST UNLCKF                                                    |


; Skip if output buffer full (SOBF)
;	JFN (etc.)/ already setup (see .SOBF in JSYS)
; Returns +1:  Not full (i.e. can output more bytes)
;	+2:  Full (next byte output would block you)
;		A/ # of buffered bytes, on either return

PUSOBF::CALL CHKPUP		; Make sure this is a PUP jfn          |
	 RET			; No, return                           |
	AOS (P)			; At least a 1 skip return             |
	PUSHJ P,CHKBSP		; Check for good BSP JFN               |
	 CAI			; Not, give not full return            |
	 JRST [	CALL UNLCKF                                            |
		SETZ A,		; Bad state, give not full return      |
		POPJ P,]
	SKIPLE FILCNT(JFN)	; Room in current buffer?
	 JRST .+3		; Yes
	PUSHJ P,CHKBSO		; No, check for BSP output possible
	 AOS 0(P)		; Not possible, preset skip return
	HRRZ A,BSPOQL(BSP)	; Return # of output bytes pending
	CALL ULKBSP		; Unlock port and return               |
	JRST UNLCKF                                                    |
                                                                       |
                                                                       |
CHKPUP:	PUSH P,A		; Save A                               |
	CALL CHKJFN		; See if valid pupjfn                  |
	 JRST CHKPU1		; no                                   |
	 JRST CHKPU1		; no                                   |
	 JRST CHKPU1		; no                                   |
	HRRZ A,FILDEV(JFN)	; Get DTB                              |
	CAIN A,PUPDTB		; Is it a PUP                          |
	 AOS -1(P)		; yes                                  |
CHKPU1:	POP P,A                                                        |
	RET                                                            |
^L                                                                     |


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 24

; Set Pup routing table entry (PUPROU function of OPRFN)
;	B/ Net number
;	C/ Mask of bits to change
;	D/ New value of those bits
; Returns +1:  Error (OPRFX2 code in ac1)
;	+2: Successful
;	user ac4/ Value of routing table entry (updated)
; Note: to read the existing contents of an entry, just use a zero mask

SETRTE::UMOVE B,2                                                      |
	UMOVE C,3                                                      |
	UMOVE D,4                                                      |
	CAIL B,1		; Make sure net number in range        |
	CAILE B,NPNETS                                                 |
	ITERR(OPRFX2)                                                  |
	NOSKED
	AND D,C			; Mask bits to be changed
	ANDCA C,PUPROU-1(B)	; Mask bits to be retained
	IOR D,C			; Combine
	MOVEM D,PUPROU-1(B)	; Put back in routing table
	OKSKED
	UMOVEM D,4		; Give back to caller
	RET                                                            |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 25

; Pup device-dependent operations (MTOPR)
;	JFN (etc.)/ already setup
;	B/ operation
; Returns +1 always;  results depend on operation.

PUPMTP:	TQNN <OPNF>		; Open?                                |
	 RETSKP		; No, do nothing                               |
	CAIN B,3		; Write eof?
	 MOVEI B,20		; Yes, use different index
	CAIL B,20		; Defined operation?
	CAIL B,20+PUPMTN
	 RETSKP		; No, do nothing                               |
	HLRZ UNIT,FILSKT(JFN)	; Setup Pup unit #                     |
	MOVE A,PUPMTT-20(B)	; Get dispatch                         |
	JUMPGE A,[CALL 0(A)	; Dispatch if BSP not required         |
		RETSKP ]                                               |
	PUSHJ P,LCKBSQ		; See if BSP port, lock if so          |
	 RETSKP		; Not, do nothing                              |
	TLNN A,(1B1)		; Do errors matter?                    |
	 JRST [	PUSHJ P,0(A)	; No, just dispatch                    |
		CALL ULKBSP                                            |
		RETSKP ]	; Unlock port and return               |
	TLNN IOS,(BSTIMF)	; Yes, timeout?                        |
	 PUSHJ P,0(A)		; No, do operation                     |
	TLNE IOS,(BSTIMF)	; Timeout?                             |
	 TQO <ERRF>		; Yes, set error flag                  |
	PUSHJ P,ULKBSP		; Unlock port                          |
	TQNE <ERRF>		; Error flag set?                      |
	 FILINT(IOX5)		; Yes, give i/o data error psi         |
	RETSKP                                                         |

; Pup MTOPR dispatch table
; B0 set => port required to be open in BSP mode
; B1 set => generate error psi on timeout
PUPMTT:	1B0+1B1+MTSMRK		; 20 (really 3) send Mark
	1B0+1B1+MTFORC		; 21 Force transmission of partial Pup
	1B0+1B1+MTSINT		; 22 Send Interrupt
	1B0+MTGMRK		; 23 Return most recent Mark byte
	EXP MTAINT		; 24 Assign interrupt channels
	1B0+MTSABT		; 25 Abort connection
	1B0+MTGABT		; 26 Return Abort data

PUPMTN==.-PUPMTT	; Number of defined functions


; Send Mark (MTOPR function 3)
;	3/ Mark byte

MTSMRK:	TQNN <WRTF>		; Open for writing?                    |
	 FILABT(IOX2,<PUSHJ P,ULKBSP>)  ; No, generate instruction trap|
	CHKSTT <OPEN,ENDI>	; Check for reasonable state           |
	 JRST [	TQO <ERRF>	; Bad, give error                      |
		RET]                                                   |
	MOVE A,FILBYT(JFN)	; Get ptr to last byte stored
	PUSHJ P,DMPBSP		; Dump partial Pup if any
	SETZM FILCNT(JFN)	; Zero byte count
	UMOVE A,3		; Get Mark byte from user
	PUSHJ P,SNDMRK		; Send Mark
	 JRST ULKWAT		; Can't, back out and wait for Ack
	RET                                                            |


; Get content byte of most recently received Mark (MTOPR function 23)
; Returns user 3/ Mark byte

MTGMRK:	LDB A,PBSMRK		; Get the byte
	UMOVEM A,3		; Return byte to user
	RET                                                            |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 26

; MTOPR routines (cont'd)

; Force out partial Pup (MTOPR function 21)

MTFORC:	TQNN <WRTF>		; Open for writing?                    |
	 FILABT(IOX2,<PUSHJ P,ULKBSP>)  ; No, generate instruction trap|
	CHKSTT <OPEN,ENDI>	; Check for reasonable state           |
	 JRST [	TQO <ERRF>	; Bad, give error                      |
		RET]                                                   |
	MOVE A,FILBYT(JFN)	; Get ptr to last byte stored          |
	PUSHJ P,DMPBSP		; Force out partial Pup if any         |
	SETZM FILCNT(JFN)	; Zero byte count                      |
	RET                                                            |


; Send Interrupt (MTOPR function 22)
;	3/ Interrupt code
;	4/ If nonzero, string ptr to Interrupt text

MTSINT:	CHKSTT <OPEN,ENDI,ENDO>  ; Check for reasonable state
	 JRST [	TQO <ERRF>	; Bad, give error                      |
		RET]                                                   |
	UMOVE A,3		; Get code
	UMOVE B,4		; Get string ptr if any
	PUSHJ P,SNDINT		; Send Interrupt
	 JRST ULKWAT		; Can't, back out and wait
	RET                                                            |


; Assign interrupt channels (MTOPR function 24)
;	3/ B0-5:   "Interrupt" PSI channel ( >35 => disable)
;	   B6-11:  "Received Pup" PSI channel
;	   B12-17: "State Change" PSI channel

MTAINT:	UMOVE A,3		; Get user arg
	HRR A,FORKX##		; Direct interrupts to this fork
	MOVEM A,PUPPSI(UNIT)	; Store in table
	RET                                                            |


; Abort connection
;	3/ Abort code
;	4/ If nonzero, string ptr to Abort text

MTSABT:	MOVEI A,E.CLST		; Generate CLOSF(T) event
	XCTU [HRRZ C,3]	; Get Abort Code (lh=0 => user call)           |
	UMOVE D,4		; Get string ptr to text if any        |
	PUSHJ P,PUPFSM		; Activate the FSM                     |
	SETZM FILCNT(JFN)	; No further i/o                       |
	RET                                                            |


; Get Abort data
;	4/ If nonzero, string ptr to store Abort text
; Returns 3/ Abort code, 4/ updated pointer

MTGABT:	HRRZ PB,BSPTIM(BSP)	; Get ptr to saved Abort
	JUMPE PB,CPOPJ##	; Do nothing if none
	LDB A,[POINT 16,PBCONT(PB),15]  ; Get Abort Code
	UMOVEM A,3		; Give to user
	UMOVE D,4		; Get user string ptr
	JUMPE D,CPOPJ##		; Stop here if none
	TLC D,-1		; Fix -1 lh
	TLCN D,-1
	 HRLI D,(POINT 7)
	LDB C,PUPLEN		; Get Pup Length
	SUBI C,MNPLEN+2		; Subtract overhead
	JUMPLE C,MTGAB2		; Jump if none
	MOVE B,[POINT 8,PBCONT(PB),15]  ; Init byte ptr
MTGAB1:	ILDB A,B		; Get byte from packet
	XCTBU [IDPB A,D]	; Give to user
	SOJG C,MTGAB1		; Repeat until exhausted
MTGAB2:	UMOVEM D,4		; Return updated pointer
	XCTBU [IDPB C,D]	; Append null
	RET                                                            |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 27

; Decode Pup name string
;	A/ String pointer to name
; Returns +1:  Unsuccessful
;	+2:  Successful:
;		A/ <net>B7 + <host>B15 (0 => wildcard)
;		B/ socket (right-justified)
; Clobbers A-D

	ADRBSZ==^D20	; Size of address block to allocate

PNMDEC:	MOVEI B,1(P)		; Set address tbl loc for PUPNM
	ADD P,[ADRBSZ,,ADRBSZ]	; Allocate space on stack
	JUMPGE P,MSTKOV##	; Check for overflow
	MOVEM A,0(P)		; Save string ptr
	MOVEI D,"U"		; Default mode is user-relative
	ILDB C,A		; Get first char
	CAIE C,0		; Empty string?
	CAIN C,"!"		; Or just mode specifier?
	 JRST [	SETZM 0(B)	; Yes, default all fields
		SETZM 1(B)
		HRLI B,2	; Say just one address input
		JRST PNMDE1]	; Handle mode if any
	MOVE A,0(P)		; Non-null, recover string ptr
	HRLI B,(1B0+<ADRBSZ>B17)  ; Name to address, set size
	PUPNM			; Translate string to address(es)
	 JRST PNMDE9		; Error
	LDB C,A			; Ok, get terminator
PNMDE1:	CAIE C,"!"		; Mode being given?
	 JRST PNMDE2		; No
	ILDB D,A		; Yes, get mode specifier
	JUMPE D,PNMDE9		; Make sure not null
	ILDB C,A		; Get terminator
PNMDE2:	JUMPN C,PNMDE9		; Error if non-null
	HLRZ C,B		; Ok, get returned adr tbl length
	CAIG C,ADRBSZ		; Make sure block was big enough
	 JRST .+3		; Yes
	BUG(CHK,PNMDEA,<PNMDEC: ADRBSZ too small for address table>)   |
	MOVEI C,ADRBSZ		; Use only what we have
	MOVN C,C		; Negate
	HRLI B,(C)		; Make AOBJN ptr to address table

; Now have B/ -length,,address of address table
; D/ Mode character for local socket defaulting (not yet checked).
; Now compute the absolute local socket on the basis of the first
;  entry in the address table
	SKIPN A,1(B)		; Get local socket from first entry
	 JRST [	MOVEI A,(JFN)	; Zero, default to 8*JFN
		PUSH P,A+1	; SAVE FROM EFFECT OF DIVIDE           |
		IDIVI A,MLJFN	; CONVERT FROM INTERNAL FORMAT         |
		LSH A,3		; GET 8*JFN                            |
		POP P,A+1	; RESTORE CLOBBERED AC                 |
		JRST PNMDE3]	; Make user- or job-relative
	CAIN D,"A"		; Want absolute socket?
	 JRST PNMDE5		; Yes, skip following
PNMDE3:	CAIE D,"J"		; Want job or user-relative?
	CAIN D,"U"
	 CAILE A,77777		; Yes, can only specify these bits
	 JRST PNMDE9		; Bad
	CAIN D,"J"
	 JRST [	MOVE C,JOBNO	; Job-relative, get job number
		ADDI C,^D100000	; Add offset
		JRST PNMDE4]
	MOVE C,JOBNO##		; User-relative, get fork number       |
	HLRZ C,JOBDIR##(C)	; Connected,,login dir                 |
PNMDE4:	LSH C,^D15		; Use this for high-order bits
	IOR A,C
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 28

; PNMDEC (cont'd)

; Now A/ absolute local socket, B/ -length,,adr of address table.
; Scan the address table and (1) make sure that any nonzero
;  net/host entries specify a real Maxc address, (2) make sure
;  all socket specifications are the same, and (3) make net/host
;  wildcard if appropriate.
PNMDE5:	MOVE C,1(B)		; Get socket # of this entry
	CAME C,-ADRBSZ+2(P)	; Consistent with first?
	 JRST PNMDE9		; No, bad
	SKIPN C,0(B)		; Get specified net/host
	 JRST PNMDE7		; Zero means default, always ok
	HLRZ D,C		; Get net
	CAIL D,1		; Check bounds
	CAILE D,NPNETS
	 JRST PNMDE9		; Bad
	HRRZ D,PUPROU-1(D)	; Ok, get Maxc adr on net
	JUMPE D,PNMDE9		; Bad if Maxc not on that net
	TRNN C,-1		; Host specified?
	 JRST [	HRRM D,0(B)	; No, substitute default
		JRST PNMDE7]
	CAIE D,(C)		; Yes, correct?
	 JRST PNMDE9		; No, bad
PNMDE7:	MOVE C,0(B)		; This net/host same as first?
	CAME C,-ADRBSZ+1(P)
	 SETZM -ADRBSZ+1(P)	; No, make fully wildcard
	AOBJN B,.+1		; Repeat for all adr tbl entries
	AOBJN B,PNMDE5
	MOVE C,-ADRBSZ+1(P)	; Done, get resulting net/host
	SETZ B,			; Convert to <net>B7 + <host>B15
	ROTC B,-8
	LSH C,-^D<18-8>
	ROTC B,-8
	EXCH A,B		; Net/host to A, socket to B
	AOS -ADRBSZ(P)		; Preset skip return

; Here to fail return from PNMDEC
PNMDE9:	SUB P,[ADRBSZ,,ADRBSZ]	; Flush address table
	POPJ P,			; Non-skip return
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 29

; Decode Pup extension string
;	A/ String pointer to name
; Returns +1:  Unsuccessful
;	+2:  Successful, A/ -Used length,,address of address block
;		(note the rh points to the header word -- the
;		address table starts at 1(A))
; Clobbers A-D

PEXDEC:	PUSH P,A		; Save string ptr
	MOVEI B,ADRBSZ+1	; Allocate space for address table
	PUSHJ P,ASGPFR
	 JRST [	POP P,A		; No room, fail
		POPJ P,]
	MOVEI B,1(A)		; Set address tbl loc for PUPNM
	EXCH A,0(P)		; Save pointer, get back string
	MOVE D,A		; Copy string ptr
	ILDB C,D		; Get first char
	JUMPE C,[SETZM 0(B)	; If null, default all fields
		SETZM 1(B)
		HRLI B,2	; Say just one address input
		JRST PEXDE1]	; Go exit
	HRLI B,(1B0+<ADRBSZ>B17)  ; Name to address, set size
	PUPNM			; Translate string to address(es)
	 JRST PEXDE9		; Error
	LDB C,A			; Ok, get terminator
	JUMPN C,PEXDE9		; Error if non-null
PEXDE1:	HLRZ B,B		; Ok, get returned adr tbl length
	CAIG B,ADRBSZ		; Make sure block was big enough
	 JRST PEXDE2		; Yes
	BUG(CHK,PEXDEA,<PEXDEC: ADRBSZ too small for address table>)   |
	MOVEI B,ADRBSZ		; Use only what we have
PEXDE2:	MOVN A,B		; Negate
	HRLM A,0(P)		; Make AOBJN ptr to address table
	HRRZ A,0(P)		; Get pointer to block
	MOVEI B,1(B)		; Include overhead in size
	PUSHJ P,TRMPFR		; Trim block to required size
	POP P,A			; Get AOBJN ptr to address table
	RETSKP			; Done, take skip return               |

; Here to fail return from PEXDEC
PEXDE9:	POP P,B			; Release address block
	PUSHJ P,RELPFR
	POPJ P,			; Fail return
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 30

; Check for open BSP port in good state
;	JFN/ Pup JFN (locked at JSYS level)
; Returns +1:  Not open or not BSP port
;	+2:  BSP port but timed out or in bad state (Closed, Abort)
;	+3:  Ok, port locked

CHKBSP:	HLRZ UNIT,FILSKT(JFN)	; Get Pup unit #                       |
	TQNE <OPNF>		; File open?                           |
	 PUSHJ P,LCKBSQ		; Yes, check for BSP and lock it
	 POPJ P,		; Not open or not BSP, return +1
	TLNE IOS,(BSTIMF+BSERRF)  ; Open, in good state?
	 JRST [	PUSHJ P,ULKBSP	; No, unlock port
		TQO <ERRF>	; Set JFN error flag                   |
		RETSKP	]	; Return +2                            |
	JRST SK2RET##		; Yes, return +3


; Unlock BSP port, unlock file, and wait for some condition
;	A/ EDISMS argument word
; Does not return to caller, but rather backs up the user PC
;  and returns to the caller of the JSYS, hence causing the
;  JSYS to be started over.

ULKWAT:	PUSHJ P,ULKBSP		; Unlock the port


; Unlock file and wait for some condition
;	A/ EDISMS argument word
; Does not return to caller, but rather backs up the user PC
;  and returns to the caller of the JSYS, hence causing the
;  JSYS to be started over.

BAKWAT:	PUSHJ P,UNLCKF##	; Unlock file, go OKINT
	MDISMS			; Dismiss until condition satisfied    |
	MOVE P,MPP		; Flush to top of monitor stack        |
	MOVE A,-1(P)		; Get return PC                        |
	HRRI A,-1(A)		; Back it up, avoiding carries         |
	MOVEM A,-1(P)                                                  |
	JRST MRETN##		; Return from JSYS, start it over
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 31


; -----------------------------------------------------------------
;	JSYSes for Raw Packet I/O
; -----------------------------------------------------------------


; Input Pup in raw packet mode
;	1/	B0: Never dismiss for I/O, give PUPX3 error instead
;		B1: Check Pup Checksum, give PUPX5 error if bad
;		B2: Perform source address check, give PUPX7 error
;		    if incorrect
;		RH: JFN for port open in raw packet mode
;	2/	LH: Length of user block (36-bit words)
;		RH: Address of user block
; Returns +1:  Unsuccessful, 1/ Error #
;	+2:  Successful

.PUPI::	MCENT                                                          |
	PUSHJ P,SETRAW		; Setup and check arguments            |
	TQNN <READF>                                                   |
	 ERUNLK(IOX1)		; Not open for reading
	PUSHJ P,GETPUP		; Get Pup from input queue
	 JRST WATRAW		; Empty, back out and wait for input
	LDB A,PUPLEN		; Get Pup Length in bytes
	ADDI A,3		; Convert to words
	LSH A,-2
	CAILE D,(A)		; User want more than we have?
	 MOVEI D,(A)		; Yes, cut him down to size
	MOVSI B,PBHEAD(PB)	; Set up BLT pointer
	HRRI B,(E)
	ADDI E,(D)		; Compute end of BLT
	XBLTMU [BLT B,-1(E)]	; Copy Pup to user block               |
	CAIGE D,(A)		; Was user block big enough?
	 ERUNLK(PUPX1,<PUSHJ P,RELPKT>)  ; No, give error
	TLNN E,(1B1)		; Want checksum checked?
	 JRST .+3		; No
	PUSHJ P,CHKCKS		; Yes, check the checksum
	 ERUNLK(PUPX5,<PUSHJ P,RELPKT>)  ; Checksum incorrect
	TLNN E,(1B2)		; Want source address check?
	 JRST .+3		; No
	PUSHJ P,CHKSRC		; Yes, check for correct source adr
	 ERUNLK(PUPX7,<PUSHJ P,RELPKT>)  ; Source address incorrect
	PUSHJ P,RELPKT		; All ok, release the buffer
	PUSHJ P,UNLCKF##	; Unlock file
	JRST SKMRTN##		; Skip return to user
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 32

; Output Pup in raw packet mode
;	1/	B0: Never dismiss for I/O, give PUPX3 error instead
;		B1: Compute Pup Checksum
;		RH: JFN for port open in raw packet mode
;	2/	LH: Length of user block (36-bit words)
;		RH: Address of user block
; Returns +1:  Unsuccessful, 1/ Error #
;	+2:  Successful

.PUPO::	MCENT                                                          |
	PUSHJ P,SETRAW		; Setup and check arguments            |
	TQNN <WRTF>                                                    |
	 ERUNLK(IOX2)		; Not open for writing                 |
	MOVEI PB,-PBHEAD(E)	; Offset for looking at Pup header     |
	XCTBMU [LDB A,PUPLEN]	; Fetch Pup Length                     |
	CAIL A,MNPLEN		; Check for legal length
	CAILE A,MXPLEN
	 ERUNLK(PUPX1)		; Size error
	ADDI A,3		; Compute # 36-bit words
	LSH A,-2
	CAILE A,(D)		; Check length consistency
	 ERUNLK(PUPX1)		; User block too short for Pup length
	ADDI A,PBHEAD		; Ok, include overhead in size
	PUSHJ P,CHKOQL		; See if this much can be queued
	 JRST WATRAW		; No, wait until queue less full
	MOVEI B,(A)		; Ok, get size
	PUSHJ P,ASGPKT		; Allocate packet buffer
	 JRST WATRAW		; Can't, back out and wait for space
	MOVSI B,(E)		; Make BLT pointer
	HRRI B,PBHEAD(PB)
	HRRZ C,PBSIZE(PB)	; Compute end of BLT
	ADDI C,(PB)
	XBLTUM [BLT B,-1(C)]	; Copy Pup to packet buffer            |

; Check that the Pup source is consistent with the local port
; and Maxc's network address, and default elements where necessary.
	LDB A,PPUPSN		; Get source net from Pup
	LDB B,PPRTLN		; Get local net from port
	JUMPN A,.+3		; Net specified in Pup?
	MOVE A,B		; No, get from port specification
	DPB A,PPUPSN		; Default source net in Pup
	CAME A,B		; Pup and port agree?
	 JUMPN B,PUPOAE		; No, fail if port not wildcard
	CAIL A,1		; Net in range?
	 CAILE A,NPNETS
	 ERUNLK(PUPX2,<PUSHJ P,RELPKT>)  ; No, give address error
	HRRZ C,PUPROU-1(A)	; Yes, get Maxc address on net
	JUMPE C,PUPOAE		; Fail if not on net

	LDB A,PPUPSH		; Get source host from Pup
	LDB B,PPRTLH		; Get local host from port
	JUMPE A,.+3		; Host specified in Pup?
	CAME A,C		; Yes, agree with Maxc address?
	 ERUNLK(PUPX2,<PUSHJ P,RELPKT>)  ; No, give address error
	JUMPE B,.+3		; Host specified in port?
	CAME B,C		; Yes, agree with Maxc address?
	 ERUNLK(PUPX2,<PUSHJ P,RELPKT>)  ; No, give address error
	DPB C,PPUPSH		; Deposit required Maxc host #

	LDB A,PPUPSS		; Get source socket from Pup
	JUMPN A,.+3		; Socket specified in Pup?
	MOVE A,PUPLSK(UNIT)	; No, get local socket from port
	DPB A,PPUPSS		; Default source socket in Pup
	CAME A,PUPLSK(UNIT)	; Pup and port agree?
PUPOAE:	 ERUNLK(PUPX2,<PUSHJ P,RELPKT>)  ; No, give address error
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 33

; PUPO (cont'd)

; Substitute defaults for zero elements in the Pup destination
	SKIPE D,PUPFPT(UNIT)	; Get foreign port descriptor
	CAMGE D,[-2,,0]		; Multiple?
	 MOVEI D,[EXP 0,0]-1	; Yes, can't default
	LDB A,PPUPDN		; Destination net
	JUMPN A,PUPO1		; Jump if specified
	HLRZ A,1(D)		; Unspecified, get default
	JUMPE A,PUPOAE		; Error if multiple or wildcard
	DPB A,PPUPDN		; Store replacement value
PUPO1:	CAIL A,1		; Net number in bounds?
	CAILE A,NPNETS
	 ERUNLK(PUPX2,<PUSHJ P,RELPKT>)  ; No, give address error

	LDB B,PPUPDH		; Destination host
	JUMPN B,PUPO2		; Jump if specified
	HRRZ B,1(D)		; Unspecified, get default
	JUMPE B,[MOVE B,PUPROU-1(A)  ; None, check net table
		TLNN B,(BROADF)	; Broadcast allowed?
		 ERUNLK(PUPX2,<PUSHJ P,RELPKT>)  ; No, give error
		JRST PUPO2]	; Yes, allow zero for dest host
	DPB B,PPUPDH		; Store replacement value

PUPO2:	LDB A,PPUPD0		; Destination socket
	MOVE B,PBHEAD+3(PB)
	LSHC A,^D16
	JUMPN A,PUPO3		; Jump if specified
	MOVE A,2(D)		; Unspecified, get default
	JUMPE A,PUPOAE		; Error if multiple or wildcard
	DPB A,PPUPD1		; Store replacement value
	LSH A,-^D16
	DPB A,PPUPD0

; Done defaulting address fields
; Compute checksum if required and queue the Pup for output
PUPO3:	TLNE E,(1B1)		; Want checksum generated?
	 PUSHJ P,SETCKS		; Yes, do so
	PUSHJ P,PUTPUP		; Queue packet for output
	 JRST [	PUSH P,A	; Can't, release buffer
		PUSHJ P,RELPKT
		POP P,A
		JRST WATRAW]	; Back out and wait
	PUSHJ P,UNLCKF##	; Unlock file
	JRST SKMRTN##		; Skip return to user
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 34

; Common setup code for PUPI and PUPO
;	1/ User's ac1
; Returns +1:
;	UNIT/ Pup unit #
;	E/ lh: Flags (from lh of user's ac1)
;	   rh: Block location (from rh of user's ac2)
;	D/ Block size (lh of user's ac2)
; Does not return if error

SETRAW:	HRRZ JFN,1		; Get JFN
	PUSHJ P,CHKJFN##	; Check it
	RETERR()		; Bad JFN                              |
	 ERUNLK(DESX4)		; TTY not legal                        |
	 ERUNLK(DESX4)		; String pointer not legal             |
	TQNN <OPNF>		; Test file status                     |
	 ERUNLK(DESX5)		; Not open                             |
	HRRZ A,FILDEV(JFN)	; Check device                         |
	CAIE A,PUPDTB
	 ERUNLK(PUPX8)		; Not device PUP:
	MOVE A,STS		; Check mode
	ANDI A,17
	CAIE A,16
	 ERUNLK(PUPX6)		; Not open in mode 16
	UMOVE E,2		; Get user block length,,adr
	HLRE D,E		; Isolate length
	XCTU [HLL E,1]		; Put flags in lh of E                 |
	MOVEI A,(E)		; Copy block address
	ADDI A,-1(D)		; Compute last address
	CAIL D,<MNPLEN+3>/4	; Error if smaller than Pup header
	CAILE A,777777		; Error if cross end of memory
	 ERUNLK(PUPX1)		; Size error
	HLRZ UNIT,FILSKT(JFN)	; Get Pup unit                         |
	POPJ P,


; Common code to unlock file, go OKINT, dismiss for some condition,
;  then back up the PC and return to the user in such a way that
;  the JSYS will be started over
;	A/ EDISMS argument word (test data,,test routine)

WATRAW:	JUMPGE E,BAKWAT		; Allowed to dismiss?
	ERUNLK(PUPX3)		; No, give error return
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 35

; -----------------------------------------------------------------
;	Pup Background Process, Initialization, Bug Reporting
; -----------------------------------------------------------------


; Routine to start Pup background process
; Called only once (from SWPMON during system initialization)
; Returns +1
; Clobbers A, B

PUPBEG::MOVSI A,(1B1)		; Transmit capabilities
	CFORK			; Create fork
	 BUG(HLT,PUPBEA,<PUPBEG: Can't create Pup background fork>)    |
	MOVEI B,PUPBAK		; Start in monitor mode
	MSFRK
	POPJ P,


; Background process starts here

PUPBAK:	SE1ENT                                                         |
	MCENTR			; SETUP CONTEXT                        |
	MOVE A,[ITFPC,,PUPUXI]	; Trap fatal interrupts
	MOVEM A,MONBK
	MOVE A,CHNSON##
	MOVEM A,MONCHN
IFE PIESLC,<
	MOVEI A,202		; Don't fall below Q2
	MOVEM A,JOBBIT
>IFN PIESLC,<
	PUSHJ P,SETSPQ##	; Always run on special queue
>
	PUSHJ P,PUPINI		; Initialize all Pup data

	MOVE A,FORKX##		; Record our fork number
	MOVEM A,PUPFRK
                                                                       |
                                                                       |
	PUSHJ P,GETIRT		; Get and discard incremental runtime
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 36

; Main loop of background process
; Look for something to do
PUPBK1:	MOVE A,PUPFLG		; Get flags
	JFFO A,PUPBK2		; Any requests in?
	JSP D,PUPBKT		; Re-check timers
	 JRST PUPBK3		; Nothing to do, go dismiss
	JRST PUPBK1		; Back to top of loop

; Here when have a request to process
; B/ Flag bit position
PUPBK2:	MOVE A,BITS##(B)	; Clear the bit
	ANDCAM A,PUPFLG
	CAIL B,PUPBKN		; Make sure task number in range
	 BUG(HLT,PUPBKA,<PUPBAK: Background task number out of range>) |
	PUSH P,B		; Ok, save task number
	PUSHJ P,@PBKTAB(B)	; Perform the task
	PUSHJ P,GETIRT		; Get incremental runtime
	POP P,B			; Restore task number
	ADDM A,PBKTIM(B)	; Accumulate time used by task
	AOS PBKCNT(B)		; Count number of task executions
	JRST PUPBK1		; Loop

; Here on fatal interrupt
PUPUXI:	BUG(CHK,PUPBKB,<PUPBAK: Fatal error interrupt, continuing>)    |
	SE1ENT                                                         |
	MCENTR                                                         |
	JRST PUPBK1		; Restart at top of loop

; Here when no more work to do
PUPBK3:	MOVE A,TODCLK		; Get now
	ADDI A,MINBWI		; Minimum background wait interval
	MOVEM A,NXTWAK		; Set earliest time of next wakeup
	MOVEI A,PUPBKT		; Scheduler test
	MDISMS			; Dismiss until something to do        |
	JRST PUPBK1		; Back to top of loop                  |
                                                                       |
RESCD                                                                  |

; Scheduler test for Pup background process wakeup

PUPBKT:	MOVE B,TODCLK		; Get now
	CAMGE B,NXTWAK		; Has minimum wait period elapsed?
	 JRST 0(D)		; No, don't wake up
	HRRZ C,PUPTQH		; Get head of timer queue
	CAML B,PUPTQD(C)	; Time to service request?
	 JRST [	SIGPBP(BSP)	; Yes, set flag
		JRST 1(D)]	; Wakeup
	CAML B,SYNTIM		; Time to check syncs?
	 JRST [	SIGPBP(SYN)	; Yes, set flag
		JRST 1(D)]	; Wakeup
	CAML B,RTETIM                                                  |
	 JRST [	SIGPBP(RTS)	; Time to send rouing pkt              |
		JRST 1(D) ]                                            |
	SKIPN PUPFLG		; Any requests in?
	 JRST 0(D)		; No
	JRST 1(D)		; Yes, wakeup

SWAPCD                                                                 |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 37

; Definition of background task requests

DEFINE PBTASK(BIT,ROUTINE) <
	PBF'BIT==1B<.-PBKTAB>	;; Assign bit number
	EXP ROUTINE		;; Assemble dispatch
>

; Dispatch table
PBKTAB:	PBTASK(FRE,RELOPB)	; Release free output buffers
	PBTASK(ASG,GETIPB)	; Assign new input buffers
	PBTASK(GCS,GCPLSK)	; GC local socket table
	PBTASK(BSP,BSPBAK)	; Do BSP background processing
	PBTASK(NVT,BSPNVT)	; Scan for NVT input/output
	PBTASK(SYN,SYNCHK)	; Check for sync timeout errors
	PBTASK(RTE,RTERCV)	; Recvd routing packet                 |
	PBTASK(RTS,RTESND)	; Time to send a routing pkt           |

PUPBKN==.-PBKTAB	; Number of background tasks in table

; Statistics
;RS PUPSTA,0		; GETAB table of Pup statistics                |
;RS PBKCNT,PUPBKN	; Number of executions of each task            |
;RS PBKTIM,PUPBKN	; Time spent executing each task               |
;RS PBKRT		; Total runtime consumed by Pup process        |

NPUPST==:2*PUPBKN+1	; Length of PUPSTA GETAB table


RESCD                                                                  |

; Routine to get incremental runtime (since last call)
; Returns +1, A/ Runtime since last call (ms)

GETIRT:	NOSKED
	MOVE A,FKRT		; Get total runtime charged to fork
;***	ADD A,JOBRTT##		; Add runtime not yet charged          |
	SUBM A,PBKRT		; Compute time since last update
	EXCH A,PBKRT		; Save new total, get delta time
	OKSKED
	POPJ P,


SWAPCD                                                                 |

; Routines to perform miscellaneous background tasks

; Release output packet buffers that have become unused

RELOPB:	MOVEI A,FREOBQ		; Free output buffer queue header
	PUSHJ P,REMIBQ		; Remove packet from queue
	 POPJ P,		; Queue empty
	PUSHJ P,RELPKT		; Release the buffer
	JRST RELOPB		; Repeat until queue empty


; Allocate and lock new input buffers if necessary

GETIPB:	MOVE A,FREIBN		; Get # of buffers now allocated
	CAIGE A,MAXFIB		; Greater than max # we want?
GETIP1:	PUSHJ P,ASGIPB		; No, assign a buffer for input
	 POPJ P,		; Failed, forget it
	MOVE A,FREIBN		; Less than minimum # we want?
	CAIGE A,MINFIB
	 JRST GETIP1		; Yes, assign more
	POPJ P,			; No, done


; Process requests on timer queue

BSPBAK:	PUSHJ P,REMTQP		; Remove request from head of queue
	 POPJ P,		; No more pending requests
	PUSHJ P,DOBSP		; Got one, do BSP processing for it
	JRST BSPBAK		; Repeat until run out
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 38

; Time to send routing packet and to check if any line has timed out   |
RTESND:	MOVE A,TODCLK		; Calculate time to check next         |
	ADDI A,^D5000		; In 5 seconds                         |
	MOVEM A,RTETIM                                                 |
	CALL CHKLIN		; See if any lines have become inactive|
	CALL SNDRTT		; Send our routing pkt                 |
	RET                                                            |
                                                                       |
; A routing pkt exists, process it                                     |
RTERCV:	MOVEI UNIT,NPUPUN	; Use this unit for routing pkts       |
	CALL GETPUP		; Get the pkt                          |
	 RET			; No more                              |
	MOVE B,[POINT 8,PBHEAD(PB),]	; Get byte pointer to pkt cont |
	LDB A,PPBPLN		; Get line number it came in on        |
	NOSKED			; Dont let table be inconsistent       |
	CALL CLSTRT		; Clear host table for this line       |
	ILDB C,B		; get host number of source host       |
	CAIN C,MYHSTN		; Is this line looped back?            |
	 JRST RTERC1		; Yes                                  |
	ILDB C,B		; Get number of host entries           |
	CAILE C,NBRHST		; Bigger than my view?                 |
	 MOVEI C,NBRHST		; Use my size then                     |
	MOVN C,C		; Make AOBJN ptr                       |
	HRLZ C,C                                                       |
RTERC2:	ILDB D,B		; Get hop count                        |
	IBP B			; Skip over his line nbr               |
	ADDI D,1		; We are 1 hop further                 |
	CAIL D,15		; Too far away?                        |
	 JRST RTERC3		; Yes, ignore                          |
	HLRZ E,HOSTRT(C)	; Get current best hop count           |
	CAMLE D,E		; Is his equal or better?              |
	 JRST RTERC3		; No, ignore it                        |
	HRLM D,HOSTRT(C)	; Save hop count                       |
	HRRM A,HOSTRT(C)	; Save this line number                |
RTERC3:	AOBJN C,RTERC2		; Keep getting entries                 |
	MOVEI C,4		; Say its up, and wait 20 seconds      |
RTERC4:	MOVEM C,LINERT(A)	; Put in line table                    |
	OKSKED                                                         |
	CALL RELPKT		; Release pkt                          |
	JRST RTERCV		; See if more pkts                     |
                                                                       |
RTERC1:	MOVEI C,1		; Say one hop                          |
	HRLM C,HOSTRT+MYHSTN-1                                         |
	HRRM A,HOSTRT+MYHSTN-1	; Say which line                       |
	MOVE C,[1,,4]		; Say line is looped back              |
	JRST RTERC4                                                    |
                                                                       |
; Clear line from host table. A/ line number                           |
                                                                       |
CLSTRT:	PUSH P,B		; Save B                               |
	MOVSI B,-NBRHST		; Get number of entries                |
CLSTR1:	HRRZ C,HOSTRT(B)	; Get line for this entry              |
	CAMN C,A		; Is it the same?                      |
	 SETOM HOSTRT(B)	; Yes, invalidate it                   |
	AOBJN B,CLSTR1		; Keep trying                          |
	POP P,B                                                        |
	RET                                                            |
                                                                       |
; Check if a line has gone dead.                                       |
                                                                       |
CHKLIN:	MOVEI A,7		; Get last line                        |
CHKLI1:	SKIPGE LINERT(A)		; Was line alive?              |
	 JRST CHKLI2		; No, just ignore                      |
	HRRE B,LINERT(A)		; Get timer                    |
	SUBI B,1		; Make it 5 sec less                   |
	HRRM B,LINERT(A)		; Update it                    |
	JUMPGE B,CHKLI2		; Still ok                             |
	SETOM LINERT(A)		; Invalidate it                        |
	CALL CLSTRT		; CLeat it's entries from host tab     |
CHKLI2:	SOJGE A,CHKLI1		; Try next line                        |
	RET                                                            |
                                                                       |
; Make and send a pkt with our routing table                           |
SNDRTT:	MOVEI A,PBHEAD+<<2+<NBRHST*2>+3>/4>                            |
	MOVEI UNIT,NPUPUN		; Get gateway unit             |
	CALL CHKGQL		; Will it fit on queue                 |
	 RET			; No, try later                        |
	MOVEI B,(A)	; Get size                                     |
	CALL ASGPKT		; Get a pkt                            |
	 RET			; Cant, wait                           |
	MOVE B,[POINT 8,PBHEAD(PB),] ; Get ptr to contents             |
	MOVEI A,MYHSTN		; Get source host number               |
	IDPB A,B			; Put in pkt                   |
	MOVEI A,NBRHST		; Get nbr of entries                   |
	IDPB A,B			; Put in pkt                   |
	MOVEI D,NBRHST		; Get number of entries                |
	SETZ C,                                                        |
SNDRT1:	HLRZ A,HOSTRT(C)	; Get hop cnt for this host            |
	CAIN C,MYHSTN-1		; Is this me?                          |
	 SETZ A,		; My hop cnt is 0                      |
	IDPB A,B			; Put in pkt                   |
	HRRZ A,HOSTRT(C)	; Get line nbr                         |
	IDPB A,B                                                       |
	ADDI C,1		; Increment line nbr                   |
	SOJG D,SNDRT1		; Do all hosts                         |
                                                                       |
	SETZM PBPHYS(PB)	; Clear immeadiate dest                |
	DPB UNIT,PPUPUN		; Save this unit                       |
	MOVEI A,<2+<2*NBRHST>+3>                                       |
	DPB A,PPBPHS		; Set size to send                     |
	SETO A,                                                        |
	DPB A,PPBPAL		; Say this goes to all lines           |
	DPB A,PPBPRT		; Say it is a routing pkt              |
	MOVEI A,MYNETN		; Say its going to net 15              |
	DPB A,PPBPHN                                                   |
	MOVEI A,0		; Say line zero                        |
	DPB A,PPBPLN                                                   |
	HRRZ A,PBSIZE(PB)	; Get size                             |
	CALL CHKGQL		; Make sure still ok                   |
	 BUGP(DPR,<SNDRTT: Cant send routing table>)                   |
	ADDM A,PUPOBC(UNIT)	; Account for pkt on queue             |
	CALL SETDST		; Set destination, return queue header |
	 JRST [	LDB UNIT,PPUPUN	; Get index of originating port        |
		HRRZ A,PBSIZE(PB) ; Get length of packet just output   |
		PUSHJ P,DECOQL	; Decrement buffer counts for port     |
		JRST RELPKT ]	; Bad destination or... , discard pkt  |
	CALL APPOBQ		; Append to queue                      |
	CALL PUPOGO                                                    |
	RET                                                            |
^L                                                                     |


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 39

; Timer queue logic                                                    |
                                                                       |
RESCD                                                                  |

; Add port to timer queue, callable from process level
;	A/ Time at which wakeup is desired (377777777777 => never)
;	UNIT/ Pup unit #
; Returns +1
; Clobbers A-C

ADDTQP:	NOSKD1                                                         |
	CHNOFF PUPCHN		; No races                             |
	CAME A,[377777777777]	; Do nothing for infinity              |
	 PUSHJ P,ADDTQI		; Do the work                          |
	CHNON PUPCHN                                                   |
	OKSKD1                                                         |
	POPJ P,

; Same routine, callable from interrupt level
ADDTQI:	SKIPN C,PUPTMQ(UNIT)	; Port already on timer queue?
	 JRST ADDTQ1		; No, just put new request on
	CAML A,PUPTIM(UNIT)	; Yes, new request sooner than old?
	 POPJ P,		; No, done
	MOVS B,C		; Yes, get predecessor ptr in rh
	HRLM B,(C)		; Remove this port from queue
	HRRM C,(B)
ADDTQ1:	MOVEM A,PUPTIM(UNIT)	; Store new time for port

; Scan timer queue from head to find place for new request.
; Note that no end test is needed since the PUPTIM corresponding
;  to the queue header word contains infinity.
	MOVEI B,PUPTQH		; Start at header of timer queue
ADDTQ2:	HRRZ B,0(B)		; Get successor
	CAMLE A,PUPTQD(B)	; Compare new time to one on queue
	 JRST ADDTQ2		; Still later, keep searching

; Found the desired place, B/ new successor
	MOVEI A,PUPTMQ(UNIT)	; Compute address of new item
	HLRZ C,0(B)		; Get new predecessor
	HRLZM C,0(A)		; Link item into queue
	HRRM B,0(A)
	HRLM A,0(B)
	HRRM A,0(C)
	POPJ P,			; Done


; Delete port from timer queue, callable from process level
;	UNIT/ Pup unit #
; Returns +1
; Clobbers A-B

DELTQP:	NOSKD1                                                         |
	CHNOFF PUPCHN		; No races                             |
	SKIPN A,PUPTMQ(UNIT)	; Port now on timer queue
	 JRST DELTQ1		; No, do nothing
	MOVS B,A		; Yes, get predecessor ptr in rh
	HRLM B,(A)		; Remove this port from queue
	HRRM A,(B)
	SETZM PUPTMQ(UNIT)	; Mark no longer queued
DELTQ1:	CHNON PUPCHN
	OKSKD1                                                         |
	POPJ P,


; Remove request from front of timer queue
; Called only from Pup background fork
; Returns +1:  No more
;	+2:  UNIT/ Pup unit # of request
; Clobbers A, UNIT

REMTQP:	NOSKD1                                                         |
	CHNOFF PUPCHN		; No races                             |
	HRRZ UNIT,PUPTQH	; Get head of queue
	MOVE A,PUPTQD(UNIT)	; Get time of first request
	CAMLE A,TODCLK		; Now due?
	 JRST [	CHNON PUPCHN	; No (or empty), return +1
		OKSKD1                                                 |
		POPJ P,]
	MOVE A,0(UNIT)		; Yes, get predecessor ,, successor
	HRRM A,PUPTQH		; Remove this port from queue
	HLLM A,0(A)
	SETZM 0(UNIT)		; Mark no longer queued
	SUBI UNIT,PUPTMQ	; Convert pointer to index
	CHNON PUPCHN
	OKSKD1                                                         |
	RETSKP			; Return +2                            |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 40

; Initialize Pup queues and data structures
; Returns +1
; Clobbers A-D, UNIT, PB

SWAPCD                                                                 |
                                                                       |
PUPINI:                                                                |
	SETZM PRSBEG		; Clear Pup resident storage
	MOVE A,[PRSBEG,,PRSBEG+1]
	BLT A,PRSEND-1
	SETZM PNRBEG		; Clear Pup nonresident storage
	MOVE A,[PNRBEG,,PNRBEG+1]
	BLT A,PNREND-1

	MOVE A,[[PKTBUF,,-1	; Initialize packet buffer free storage
		-1		;  header (see ASGFRE for format)
		NPKTBF*1000
		MXPBLN
		PKTBUF+NPKTBF*1000,,PKTBUF],,PKTFRE]
	BLT A,PKTFRE+4
	MOVEI A,NPKTBF*1000	; Initially all one big block
	MOVEM A,PKTBUF

	MOVE A,[[PUPBUF,,-1	; Initialize Pup free storage
		-1		;  header (see ASGFRE for format)
		NPUPBF*1000
		BSPSIZ
		PUPBUF+NPUPBF*1000,,PUPBUF],,PUPFRE]
	BLT A,PUPFRE+4
	MOVEI A,NPUPBF*1000	; Initially all one big block
	MOVEM A,PUPBUF

	MOVEI A,PBQBEG		; Initialize queues to empty
	HRRM A,(A)
	HRLM A,(A)
	CAIGE A,PBQEND-1	; More?
	 AOJA A,.-3		; Yes, repeat for all

	MOVSI UNIT,-NPUPUN	; Initialize all ports
	PUSHJ P,INIPRT
	AOBJN UNIT,.-1

	MOVSI A,(1B0)		; Initialize routing table to all empty
	MOVEM A,PUPROU
	MOVE A,[PUPROU,,PUPROU+1]
	BLT A,PUPROU+NPNETS-1
	MOVSI A,-LPUPIR		; Setup entries for directly-connected nets
PUPII1:	MOVE B,PUPIRT(A)	; Get table entry
	LDB C,[POINT 16,B,17]	; Get net number
	TLZ B,177777		; Flush from entry
	MOVEM B,PUPROU-1(C)	; Put entry in routing table
	AOBJN A,PUPII1

	MOVE A,[GATEWF]                                                |
	MOVEM A,PUPPAR+1	; Initialize PUPPAR getab              |
	MOVEI A,PUPBUF		; Start of free storage                |
	MOVEM A,PUPPAR+1                                               |
                                                                       |
	MOVE A,[LINERT,,LINERT+1] ; Initialize line state table        |
	SETOM LINERT		;  to all dead                         |
	BLT A,LINERT+7                                                 |
                                                                       |
	MOVE A,[HOSTRT,,HOSTRT+1] ; Initialize host route table        |
	SETOM HOSTRT                                                   |
	BLT A,HOSTRT+NBRHST-1                                          |
                                                                       |
	MOVE A,[PUPTQH,,PUPTQH]	; Initialize timer queue to empty
	MOVEM A,PUPTQH
	HRLOI A,377777		; Make corresponding time infinite
	MOVEM A,PUPFTM

	SETOM PRTLCK		; Unlock port table lock
	SETOM NVTLCK		; Unlock NVT assignment lock

	SETOM NTDLCK                                                   |
	CALL NTDINI		; INITIALIZE PUPNM DIR                 |
	 BUG(CHK,NTDINO,<NTDINI: FAILED TO INITIALIZE PUPNM DIRECTORY>)|
                                                                       |
	CALL PDZINI		; Init Dz driver                       |
	PUSHJ P,PUPRST		; Initialize NVIO communication        |
	POPJ P,                                                        |
^L                                                                     |


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 41

RESCD                                                                  |

; Restart Pup I/O
; Called from PUPINI and from SYSRST in PISRV
; Returns +1
; Clobbers A

PUPRST::                                                               |
	MOVSI A,776000                                                 |
	MOVEM A,XPUPIW		; Say all lines need servicing         |
	MOVEM A,XPUPOW		; Same for output                      |
                                                                       |
	ISB PUPCHN		; Yes, do next output                  |

	MOVSI A,(PBFFRE!PBFASG!PBFBSP)  ; Run some background tasks
	IORM A,PUPFLG

	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 42

; Code to handle Pup Bugs

; BUGP(PUP,<message>,X)                                                |
; Copy header of packet PB for later printout by job 0

BGRPUP:	AOS PUPBGC		; Count occurrences
	PUSH P,A
	PUSH P,B
	PUSH P,C
	SKIPE PUPBGP		; Already have unprocessed Pup bug?
	 JRST BGRPU1		; Yes, don't store this one
	MOVSI A,(PB)		; Save data from PB header
	HRRI A,PUPBGH
	BLT A,PUPBGH+PBCONT-1
	HRRZ A,-3(P)		; Get pc of bug
	HRL A,PUPBGC		; Put bug number in lh
	MOVEM A,PUPBGP		; Save in stored header
	SKIPE PUPBGF		; Logging enabled?
	 AOS JB0FLG##		; Yes, awaken job 0
BGRPU1:	HRRZ A,-3(P)		; Get pc of bug
	PUSHJ P,PBGCNT		; Count this bug in hash table
	POP P,C
	POP P,B
	POP P,A
	POPJ P,


; BUGP(DIP,<message>,X)                                                |
; Discard input packet PB after printout by job 0 if enabled

BGRDIP:	HRRZS 0(P)		; Flag extra return not desired
	JRST BGRDP1		; Enter common bug code


; BUGP(DPR,<message>,X)                                                |
; Discard input packet PB as above, then execute an extra POPJ
;  so the routine invoking the BUG is exited

BGRDPR:	HRROS 0(P)		; Flag extra return desired
BGRDP1:	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	AOS A,PUPBGC		; Count occurrences, get count
	HRL A,-4(P)		; Get pc of bug
	MOVSM A,PBBSPQ(PB)	; Save count,,pc in packet buffer
	CONSZ PI,1B<20+PUPCHN>	; At interrupt level?
	 JRST BGRDP2		; Yes
	SKIPN PUPBGF		; No, logging enabled?
	 JRST [	PUSHJ P,RELPKT	; No, just release packet
		JRST BGRDP4]
	PUSHJ P,LOCKPB		; Yes, have to lock the buffer
	NOSKD1                                                         |
	CHNOFF PUPCHN		; Interlock
BGRDP2:	SKIPN PUPBGF		; Pup bug logging enabled?
	 JRST [	PUSHJ P,RELPBI	; No, just release the buffer
		JRST BGRDP3]
	MOVEI A,DSCIBQ		; Yes, append to discard queue
	PUSHJ P,APPIBQ		;  for processing by job 0
	AOS JB0FLG##		; Awaken job 0
BGRDP3:	CONSZ PI,1B<20+PUPCHN>	; At interrupt level?                  |
	JRST .+3                                                       |
	 CHNON PUPCHN		; No, uninterlock                      |
	 OKSKD1                                                        |
BGRDP4:	HRRZ A,-4(P)		; Get pc of bug
	PUSHJ P,PBGCNT		; Count this bug in hash table
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	SKIPGE 0(P)		; Which call?
	 SUB P,BHC##+1		; DPR, pop off another return
	POPJ P,


; Bug-related data

;RS PUPBGF		; Nonzero to log Pup bugs                      |
;RS PUPBGC		; Count of Pup bugs                            |
RS PUPBGH,PBBSPQ	; PB header and Pup header for last BUGP(PUP,...)
                                                                       |
RS PUPBGP,PBCONT-PBBSPQ	; PC of last BUGP(PUP,...)                     |
^L                                                                     |


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 43

SWAPCD                                                                 |

; Log Pup bugs;  called from job 0 (see SWPMON)
; Returns +1
; Clobbers A-D, PB, and probably others (see CHKBG1 in SWPMON)

PBGLOG::SKIPN PUPBGP		; Have bug pc?
	 JRST PBGLG1		; No
	MOVEI PB,PUPBGH		; Yes, set pointer to saved header
	PUSHJ P,PBGPRT		; Print Pup bug
	SETZM PUPBGP		; Clear, enable for next
PBGLG1:	HRRZ A,DSCIBQ		; Check discarded input queue
	CAIN A,DSCIBQ		; Empty?
	 POPJ P,		; Yes, done
	MOVE A,TODCLK		; No, set time limit for printing
	ADDI A,^D10000		; 10 seconds from now
	PUSH P,A
PBGLG2:	MOVEI A,DSCIBQ		; Get packet from queue
	PUSHJ P,REMIBQ
	 JRST [	SUB P,BHC##+1	; Empty, fix stack and exit
		POPJ P,]
	MOVE A,TODCLK		; Check time limit
	CAMG A,0(P)		; Skip if exceeded
	 PUSHJ P,PBGPRT		; Print bug
	PUSHJ P,RELPKT		; Release packet buffer
	JRST PBGLG2		; Repeat for all packets in queue


; Internal routine to print Pup bugs
;	PB/ Packet buffer pointer

PBGPRT:	SKIPN PUPBGF		; Want to print Pup bugs?
	 POPJ P,		; No
	HRROI A,[ASCIZ /**PUPBUG /]
	PSOUT
	HLRZ B,PBBSPQ(PB)	; Get bug number
	MOVEI a,101                                                    |
	MOVEI C,^D10                                                   |
	NOUT			; Print in decimal                     |
	 JFCL                                                          |
	HRROI A,[ASCIZ / D=/]
	PSOUT
	MOVE B,PBHEAD+2(PB)	; Get high dest socket
	LSH B,-4		; Right-justify
	MOVE C,PBHEAD+3(PB)	; Get low dest socket
	LSHC B,-^D16		; Concatenate
	LSH C,-4		; Right-justify
	LDB A,PPUPDN		; Dest net
	LDB B,PPUPDH		; Dest host
	PUSHJ P,PBGPNM		; Print name string
	HRROI A,[ASCIZ / S=/]
	PSOUT
	LDB A,PPUPSN		; Source net
	LDB B,PPUPSH		; Source host
	MOVE C,PBHEAD+4(PB)	; Source socket
	LSH C,-4		; Right-justify
	PUSHJ P,PBGPNM		; Print name string
	HRROI A,[ASCIZ /
  PS=/]
	PSOUT
	LDB A,PPBPHN		; Phys src net
	LDB B,PPBPHH		; Phys src host
	SETZ C,			; No socket
	PUSHJ P,PBGPNM		; Print name string
	HRROI A,[ASCIZ / T=/]
	PSOUT
	LDB B,PUPTYP		; Print Pup type in octal
	MOVEI A,101		; Primary output                       |
	MOVEI C,10		; in octal                             |
	NOUT                                                           |
	 JFCL                                                          |
	HRROI A,[ASCIZ / at /]                                         |
	PSOUT                                                          |
	HRRZ B,PBBSPQ(PB)	; Get pc of bug                        |
	SOJA B,CHKBG1		; Print PC, date, time, message        |
;*** This routine should be augmented to type the bug string           |
CHKBG1:	MOVEI 1,101                                                    |
	MOVEI 3,10                                                     |
	NOUT                                                           |
	JFCL                                                           |
	MOVEI 1,15                                                     |
	PBOUT                                                          |
	MOVEI 1,12                                                     |
	PBOUT                                                          |
	RET                                                            |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 44

; Internal routine to print name string
;	A/ Net
;	B/ Host
;	C/ Socket

PBGPNM:	HRLI B,(A)		; Make net,,host
	PUSH P,B		; Put on stack
	PUSH P,C		; Put socket on stack
	MOVEI A,101		; Output to tty
	MOVEI B,-1(P)		; Location of address block
	HRLI B,(1B2)		; Flag number substitution ok
	PUPNM			; Convert address to name
	 BUG(CHK,PBGPNA,<PBGPNM: Impossible failure of PUPNM>)         |
	SUB P,BHC##+2		; Fix stack
	POPJ P,


RESCD                                                                  |
                                                                       |
;LG2PBT==6		; Log(2) size of Pup bug table                 |
;LENPBT==:1_LG2PBT	; Length of Pup bug table                      |
;RS PUPBGT,LENPBT	; Hash table of bug count,,pc pairs.           |

; Count a Pup bug in the hash table
;	A/ pc
; Returns +1
; Clobbers A-C

PBGCNT:	MOVEI B,(A)		; Copy just rh of pc
	IMULI B,^D162013	; Hash - 2^18/golden ratio
	LSH B,-<^D18-LG2PBT>	; Keep topmost  LG2PBT bits
	ANDI B,LENPBT-1
	MOVNI C,(B)		; Keep negative index for wraparound
	HRLI A,(C)
	HRLI B,-LENPBT(B)	; Make AOBJN pointer
PBGCN1:	HRRZ C,PUPBGT(B)	; Get current entry
	CAIN C,(A)		; Same as pc of new bug?
	 JRST PBGCN3		; Yes
	JUMPE C,PBGCN2		; No, found free entry?
	AOBJN B,PBGCN1		; Collision, reprobe linearly
	HLLZ B,A		; Wrap around end of table
	HRLI A,0		; In case get here again
	JUMPN B,PBGCN1
	POPJ P,			; Table is full, forget it

; Here to insert new entry
PBGCN2:	HRRZM A,PUPBGT(B)	; Store pc of bug

; Here to increment count for existing entry
PBGCN3:	MOVSI C,1
	ADDM C,PUPBGT(B)
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 45

MX(<  ; Maxc1 only
; NVIO bug strings

; General Pup errors
NVBUG(30,<Incorrect Pup length>)
NVBUG(31,<Pup length greater than physical packet length>)
NVBUG(32,<Failed to allocate packet buffer>)

; Ethernet errors
NVBUG(40,<Incorrect Ethernet receiver status>)
NVBUG(41,<Incorrect Ethernet message length>)
NVBUG(42,<Incorrect Ethernet source address>)
NVBUG(43,<Incorrect Ethernet destination address>)
NVBUG(44,<Incorrect Ethernet packet type>)
NVBUG(45,<Ethernet transmitter timed out by software>)
NVBUG(46,<Incorrect Ethernet transmitter status>)
NVBUG(47,<Ethernet load overflow>)

; MCA errors
NVBUG(50,<MCA input timeout>)
NVBUG(51,<MCA message too long>)
NVBUG(52,<MCA input sync error>)
NVBUG(53,<MCA Pup output timeout>)

; Imp errors
NVBUG(60,<Imp message too long>)
NVBUG(61,<Imp state changed>)
NVBUG(62,<Imp input host-host protocol packet discarded>)
>,)
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 46

; -----------------------------------------------------------------
;	Byte Stream Protocol
; -----------------------------------------------------------------

; Note:  In the calling sequences, "Assumes port is locked"
; means that UNIT, BSP, and IOS must be setup before the call,
; and the subroutine updates IOS appropriately.

SWAPCD                                                                 |

; Get Pup from BSP input queue
; Assumes port is locked
; Returns +1:  Can't, A/ argument word for EDISMS
;	+2:  Ok, PB/ Packet buffer pointer
;		PBBSBC(PB)/ Byte count
;		PBBSID(PB)/ Byte pointer (ILDB gets first byte)
; Note that the returned packet may be a Data, AData, or Mark
; Clobbers A-D, PB

GETBSP:	HLRZ PB,BSPCUR(BSP)	; Is there a current input packet?
	JUMPE PB,.+3
	PUSHJ P,RELPKT		; Yes, release it
	HRRZS BSPCUR(BSP)	; Clear current input packet ptr

; Get next packet if there is one
GETBS1:	HRRZ A,BSPIQL(BSP)	; Get number of bytes available
	JUMPE A,[TLZ IOS,(BSINPF)  ; If none, clear input flag
		PUSHJ P,DOBSPL	; Make sure BSP data up-to-date
		TLNE IOS,(BSINPF)  ; New input available?
		 JRST GETBS1	; Yes, try again
		MOVSI A,(UNIT)	; No, set scheduler test
		HRRI A,BSITST
		POPJ P,]	; Take fail return
	MOVEI A,BSPIBQ(BSP)	; Data available, get queue header
	PUSHJ P,REMITQ		; Remove item from BSP input queue
	 BUG(HLT,GETBSA,<GETBSP: Count nonzero but queue empty>)       |
	MOVEI PB,-PBBSPQ(B)	; Set pointer to head of PB
	HRLM PB,BSPCUR(BSP)	; Save as current input packet
	MOVSI A,-1		; Decrement count of packets
	ADDB A,BSPIQL(BSP)
	SKIPGE A		; Check for over-decrementing
	 BUG(CHK,GETBSB,<GETBSP: Over-decrementing BSP input count>)   |

; Compute and update byte sequence numbers and counts
	MOVE A,BSPILW(BSP)	; Get left window edge
	SUB A,PBBSID(PB)	; Compute offset from start of PB
	TLZ A,(-1B3)		;  mod 2^32
	TLNE A,(1B4)		; Make sure positive
	 BUG(HLT,GETBSC,<GETBSP: Byte sequence numbers screwed up>)    |
	CAML A,PBBSBC(PB)	; Any bytes in window?
	 JRST GETBSP		; No, discard (can this happen?)
	MOVN B,A		; Yes, make negative
	ADDB B,PBBSBC(PB)	; Decrease count by first byte #
	MOVN C,B		; Decrement # bytes available
	ADDB C,BSPIQL(BSP)	; Decrement # bytes available
	TRNE C,400000		; Check for over-decrementing
	 BUG(HLT,GETBSD,<GETBSP: Over-decremented BSP byte count>)     |
	ADD B,BSPILW(BSP)	; Update left window edge to
	TLZ B,(-1B3)		;  first byte beyond this Pup
	MOVEM B,BSPILW(BSP)
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 47

; GETBSP (cont'd)

; Initialize byte pointer to start of byte stream
	MOVEI B,PBCONT(PB)	; Make byte ptr to start of
	HRLI B,(POINT 8)	;  Pup Contents
	ROT A,-2		; Separate word and byte numbers
	ADDI B,(A)		; Advance word index in byte ptr
	HRRI A,0		; Clear word except byte # in B0-1
	LSH A,-1		; Byte # to B1-2, i.e. 8*# in B0-5
	SUB B,A			; Modify byte ptr for starting byte
	MOVEM B,PBBSID(PB)	; Store byte ptr in PB header

; Do any necessary BSP processing before returning
	PUSHJ P,DOBSPQ		; Do BSP processing if needed
	TLNE IOS,(BSZALF)	; Did we send zero allocation?
	 PUSHJ P,SNDACK		; Yes, send another Ack (presumably nonzero now)
	HLRZ PB,BSPCUR(BSP)	; Recover packet buffer pointer
	RETSKP			; Take skip return                     |
                                                                       |
RESCD                                                                  |

; Scheduler test for BSP input available
; Arg is Pup unit #

BSITST:	MOVSI B,(BSINPF+BSTIMF+BSERRF+BSWAKF)  ; Anything to do?
	TDNN B,PUPSTS(A)
	 JRST 0(D)		; No
	JRST 1(D)		; Yes, wakeup

SWAPCD                                                                 |



; Check for BSP output possible
; Assumes port is locked
; Returns +1:  Output not possible, A/ argument word for EDISMS
;	+2:  Output possible, A/ Max # bytes in next Pup
; Clobbers A-D, PB

CHKBSO:	LDB A,PBSOAP		; Get # additional Pups allowed
	JUMPE A,CHKBO3		; Fail if none
	HRRZ A,BSPOAL(BSP)	; Get # additional bytes allowed
	JUMPE A,CHKBO3		; Fail if none
	LDB B,PBSOBP		; Get max bytes/Pup
	JUMPE B,CHKBO3		; 0 => no Ack received yet
	CAILE A,(B)		; More than one Pups' worth?
	 MOVEI A,(B)		; Yes, cut down to max Pup length
	RETSKP			; Success, skip return                 |

; Here when output not possible
CHKBO3:	TLZ IOS,(BSOUTF)	; Clear output flag
	PUSHJ P,DOBSPL		; Make sure BSP data up-to-date
	TLNE IOS,(BSOUTF)	; Output possible now?
	 JRST CHKBSO		; Maybe, try again
	SKIPN BSPATM(BSP)	; No, is AData outstanding?
	 PUSHJ P,SNDADA		; No, force AData to be sent
	MOVSI A,(UNIT)		; Set scheduler test
	HRRI A,BSOTST
	POPJ P,			; Take fail return

RESCD                                                                  |

; Scheduler test for BSP output possible
; Arg is Pup unit #

BSOTST:	MOVSI B,(BSOUTF+BSTIMF+BSERRF+BSWAKF)  ; Anything to do?
	TDNN B,PUPSTS(A)
	 JRST 0(D)		; No
	JRST 1(D)		; Yes, wakeup

SWAPCD                                                                 |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 48

; Build BSP Data packet
;	A/ # data bytes to be stored in Pup
; Assumes port is locked
; Returns +1:  Failed, A/ argument word for EDISMS
;	+2:  Succeeded:
;		A/ Byte count (same as call)
;		B/ Byte ptr (IDPB stores first data byte)
;		PB/ Packet buffer pointer
; Clobbers A-D, PB

BLDDAT:	HRLM A,0(P)		; Save byte count
	MOVEI B,4*PBHEAD+MNPLEN+3(A)  ; Include header and overhead
	LSH B,-2		; Convert to words
	PUSHJ P,ASGPKT		; Allocate packet buffer
	 POPJ P,		; Failed
	HRRM PB,BSPCUR(BSP)	; Ok, save current buffer ptr
	MOVEI A,PT.DAT		; Set Type = Data
	DPB A,PUPTYP
	HLRZ A,0(P)		; Recover byte count
	MOVEI B,PBCONT(PB)	; Construct byte pointer
	HRLI B,(POINT 8)
	RETSKP			; Done, skip return                    |



; Finish up and send current Data Pup, if any
;	A/ Byte ptr to last byte stored (if any)
; Assumes port is locked
; Returns +1 always
; Clobbers A-D, PB

DMPBSP:	HRRZ PB,BSPCUR(BSP)	; Get ptr to current output PB
	JUMPE PB,CPOPJ##	; Do nothing if none
	HLLZS BSPCUR(BSP)	; Zero pointer in data block
	PUSHJ P,ENDPUP		; Compute length, trim excess
	PUSHJ P,SNDBSP		; Send it on its way
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 49

; "Force" BSP output, i.e. send the current Pup as an AData,
;  or send a null AData
;	A/ Byte ptr to last byte stored in current Pup (if any)
; Assumes port is locked
; Returns +1 always
; Clobbers A-D, PB

FRCBSP:	HRRZ PB,BSPCUR(BSP)	; Get ptr to current output PB
	JUMPE PB,FRCBS1		; Jump if none
	HLLZS BSPCUR(BSP)	; Zero pointer in data block
	PUSHJ P,ENDPUP		; Compute length, trim excess
	MOVEI A,PT.ADA		; Set Type = AData
	DPB A,PUPTYP
	PUSHJ P,SNDBSP		; Send it on its way
	POPJ P,

; Here when there is no current output packet
FRCBS1:	PUSHJ P,DOBSPQ		; Do housekeeping
	HLRZ A,BSPOBQ(BSP)	; Get tail of output queue
	CAIN A,BSPOBQ(BSP)	; Queue empty?
	 POPJ P,		; Yes, nothing to do
	MOVEI PB,-PBBSPQ(A)	; No, point to head of tail packet
	LDB A,PUPTYP		; Get Pup Type
	CAIE A,PT.ADA		; An AData?
	 CAIN A,PT.AMA		; An AMark?
	 POPJ P,		; Yes, nothing more to do
	PUSHJ P,RETADA		; No, retransmit it as AData/AMark
	POPJ P,



; Check for empty BSP output queue
; Assumes port is locked
; Returns +1:  Not empty, A/ Scheduler test, B/ # buffered bytes
;	+2:  Empty

CHKBOQ:	HRRZ A,BSPOBQ(BSP)	; Get queue head
	CAIN A,BSPOBQ(BSP)	; Empty?
	 RETSKP			; Yes, skip return                     |
	TLO IOS,(BSNOQF)	; No, set nonempty output queue flag
	PUSHJ P,DOBSPL		; Do any necessary processing
	TLNN IOS,(BSNOQF)	; Now empty?
	 JRST CHKBOQ		; Maybe, check again
	MOVSI A,(UNIT)		; No, set scheduler test
	HRRI A,BSEOQT
	HRRZ B,BSPOQL(BSP)	; Return # buffered bytes
	POPJ P,			; Take non-skip return

RESCD                                                                  |

; Scheduler test for empty BSP output queue
; Arg is Pup unit #

BSEOQT:	MOVE B,PUPSTS(A)	; Get port status
	TLNE B,(BSNOQF)		; Output queue now empty?
	TLNE B,(BSTIMF+BSERRF+BSWAKF)  ; Error or work to do?
	 JRST 1(D)		; Yes, wakeup
	JRST 0(D)		; No, wait

SWAPCD                                                                 |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 50

; Send BSP data packet (including AData, Mark, or AMark)
;	PB/ Packet buffer ptr
; Assumes port is locked
; Returns +1 always
; Caller is expected to have checked for allocation beforehand
;  (by calling CHKBSO)
; Caller should set up Length and Type, we do the rest
; Clobbers A-D, PB

SNDBSP:	MOVEI A,BSPOBQ(BSP)	; Point to output queue header
	MOVEI B,PBBSPQ(PB)	; Point to link word in this PB
	PUSHJ P,APPITQ		; Append new Pup to BSP queue
	HLLZS BSPCUR(BSP)	; Clear current output PB ptr

; Compute and store Pup ID
	HRRZ A,BSPOQL(BSP)	; Get current # bytes queued
	ADD A,BSPOLW(BSP)	; Compute ID for this Pup
	LSH A,4			; Left-justify
	MOVEM A,PBHEAD+1(PB)	; Set Pup ID

; Update Pup and byte counts for this port
	LDB A,PUPLEN		; Get Pup Length
	SUBI A,MNPLEN		; Subtract overhead
	HRLI A,1		; Count 1 Pup
	ADDM A,BSPOQL(BSP)	; Update Pups and bytes queued
	LDB C,PBSOAP		; Get additional Pups allowed
	SOSL C			; Decrement
	 DPB C,PBSOAP		; Store back unless negative
	HRRZ D,BSPOAL(BSP)	; Get additional bytes allowed
	SUBI D,(A)		; Decrement by # bytes in new Pup
	SKIPGE D		; Make sure non-negative
	 SETZ D,
	HRRM D,BSPOAL(BSP)	; Store back

; Check allocation and change Data to AData or Mark to AMark if appropriate
	LDB A,PUPTYP		; Get Pup Type
	CAIE A,PT.ADA		; Already an AData?
	 CAIN A,PT.AMA		; Already an AMark?
	 JRST SNDBS5		; Yes, nothing more needed
	PUSHJ P,CHKADA		; Check hold time and allocation
	 JRST [	MOVE D,BSPDTM(BSP)  ; Still ok, save timer
		PUSHJ P,SETTMH	; Set timer to hold time
		CAMGE D,BSPDTM(BSP)  ; Compare to previous timer
		 MOVEM D,BSPDTM(BSP)  ; Use earlier
		JRST SNDBS6]	; Go finish up
	LDB A,PUPTYP		; Time to send AData, get current type
	CAIN A,PT.DAT		; Data?
	 MOVEI A,PT.ADA		; Yes, change to AData
	CAIN A,PT.MRK		; Mark?
	 MOVEI A,PT.AMA		; Yes, change to AMark
	DPB A,PUPTYP
SNDBS5:	MOVE A,TODCLK		; Record sending AData now
	MOVEM A,BSPATM(BSP)
	PUSHJ P,SETTMR		; Set timer for retransmission

; Finish up and send the Pup
SNDBS6:	SETZ A,			; Clear transport control byte
	DPB A,PUPTCB
	PUSHJ P,SETPRT		; Set up source and dest ports
	PUSHJ P,SETCHK		; Set Pup Checksum appropriately
	MOVE A,TODCLK		; Time stamp the Pup
	MOVEM A,PBTIME(PB)
	PUSHJ P,PUTPUP		; Queue Pup for output
	 BUGP(PUP,<SNDBSP: Output queue overflowed>,X)                 |
	PUSHJ P,DOBSPQ		; Do housekeeping if needed
	PUSHJ P,SETPTM		; Put port on timer queue
	AOS BSPOPG(BSP)		; Count packets generated
	POPJ P,			; Done
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 51

; Send an Interrupt
;	A/ Interrupt code
;	B/ If nonzero, string ptr to Interrupt text (see BLDIAB)
; Assumes port is locked
; Returns +1:  Can't (interrupt already outstanding)
;		A/ argument word for EDISMS
;	+2:  Successfully sent
; Clobbers A-D, PB

SNDINT:	SKIPGE BSPSII(BSP)	; Interrupt already outstanding?
	 JRST [	TLO IOS,(BSINTF)  ; Yes, ensure flag is set
		PUSHJ P,DOBSPL	; Ensure BSP data up-to-date
		SKIPL BSPSII(BSP)  ; Still outstanding?
		 JRST .+1	; No, continue
		MOVSI A,(UNIT)	; Yes, set scheduler test
		HRRI A,INOTST
		POPJ P,]	; Take fail return
	PUSHJ P,BLDIAB		; Ok, build the Pup
	 POPJ P,		; Failed, take non-skip return
	MOVEI A,PT.INT		; Set Type = Interrupt
	DPB A,PUPTYP
	SETZ A,			; Zero out Transport control byte
	DPB A,PUPTCB
	HRROI A,0(PB)		; Make PB ptr with sign set
	EXCH A,BSPSII(BSP)	; Store it, get Interrupt ID
	LSH A,4			; Left-justify
	MOVEM A,PBHEAD+1(PB)	; Store in Pup
	PUSHJ P,SETPRT		; Set up source and dest ports
	PUSHJ P,SETCHK		; Set Pup Checksum appropriately
	SETOM PBBSPQ(PB)	; Mark PB as owned by BSP process
	MOVE A,TODCLK		; Time stamp
	MOVEM A,PBTIME(PB)
	HLRZ B,BSPTIM(BSP)	; Get retransmission timeout
	ADDI A,(B)		; Compute time for next check
	MOVEM A,BSPITM(BSP)	; Store in data block
	PUSHJ P,PUTPUP		; Queue Pup for output
	 BUGP(PUP,<SNDINT: Output queue overflowed>,X)                 |
	TLO IOS,(BSINTF)	; Ensure flag is set                   |
	PUSHJ P,DOBSPQ		; Check for work to be done            |
	PUSHJ P,SETPTM		; Put port on timer queue              |
	RETSKP			; Finished, skip return                |
                                                                       |
RESCD                                                                  |

; Scheduler test for Interrupt no longer outstanding
; Arg is Pup unit #

INOTST:	MOVE B,PUPSTS(A)	; Get port status
	TLNE B,(BSINTF)		; Interrupt no longer outstanding?
	TLNE B,(BSTIMF+BSERRF+BSWAKF)  ; Error or work to do?
	 JRST 1(D)		; Yes, wakeup
	JRST 0(D)		; No, wait

SWAPCD                                                                 |



; Send an Abort
;	A/ Abort code
;	B/ If nonzero, string ptr to Abort text (see BLDIAB)
; Assumes port is locked
; Returns +1 always
; Clobbers A-D, PB

SNDABT:	PUSHJ P,BLDIAB		; Build the Pup
	 POPJ P,		; Failed, forget it
	MOVE A,BSPCID(BSP)	; Get Connection ID
	LSH A,4			; Left-justify
	MOVEM A,PBHEAD+1(PB)	; Store as Pup ID
	MOVEI A,PT.ABT		; Set Type = Abort
	PUSHJ P,SNDPUP		; Finish up and send the Pup
	 CAI			; Ignore failure
	POPJ P,			; Done
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 52

; Build Interrupt or Abort (common code)
;	A/ B0 clear if called from user, set if from monitor
;	   rh: Interrupt or Abort Code
;	B/ If nonzero, string ptr to text in appropriate space
; Assumes port is locked
; Returns +1:  Can't (no room), A/ argument word for EDISMS
;	+2:  Successful, PB/ ptr to packet buffer

BLDIAB:	HLLM A,0(P)		; Save address space indicator
	PUSH P,B		; Save string ptr to text
	PUSH P,A		; Save code
	MOVEI B,PBHEAD+<MNPLEN+MXPTXT+2+3>/4
	PUSHJ P,ASGPKT		; Assign packet buffer
	 JRST [	SUB P,BHC##+2	; Can't, flush args
		POPJ P,]	; Fail return
	POP P,B			; Recover code
	DPB B,[POINT 16,PBCONT(PB),15]  ; Store in Pup
	MOVE A,[POINT 8,PBCONT(PB),15]  ; Init ptr for storing text
	POP P,B			; Recover string ptr to text
	JUMPE B,BLDIA2		; Jump if no text
	TLC B,-1		; Left half = -1?
	TLCN B,-1
	 HRLI B,(POINT 7)	; Yes, change to string ptr
	MOVEI C,MXPTXT		; Init byte counter
BLDIA1:	SKIPGE 0(P)		; Check address space indicator
	 ILDB D,B		; Get byte from monitor
	SKIPL 0(P)
	 XCTBU .-2		; Get byte from user
	JUMPE D,BLDIA2		; Jump if end
	IDPB D,A		; Put byte in Pup
	SOJG C,BLDIA1		; Repeat if still room
BLDIA2:	PUSHJ P,ENDPUP		; Compute length, trim excess
	RETSKP			; Skip return                          |



; Send an AMark
;	A/ Mark byte (right-justified)
; Assumes port is locked
; Returns +1:  Can't, A/ argument word for EDISMS
;	+2:  Successfully sent
; Note caller is expected to have finished any preceding data Pup
; Clobbers A-D, PB, BSP, IOS

SNDAMA:	IORI A,400000		; Flag to send Amark
				; Fall into Mark code


; Send a Mark
;	A/ Mark byte (right-justified)
; Assumes port is locked
; Returns +1:  Can't, A/ argument word for EDISMS
;	+2:  Successfully sent
; Note caller is expected to have finished any preceding data Pup
; Clobbers A-D, PB, BSP, IOS

SNDMRK:	HRLM A,0(P)		; Save Mark byte
	PUSHJ P,CHKBSO		; Check for BSP output possible
	 POPJ P,		; Not now, take fail return
	MOVEI B,PBHEAD+<MNPLEN+1+3>/4
	PUSHJ P,ASGPKT		; Allocate packet buffer
	 POPJ P,		; Couldn't, take fail return
	HLRZ A,0(P)		; Ok, get back the byte
	MOVEI B,PT.MRK		; Assume want to send Mark
	TRZE A,400000		; AMark flag set?
	 MOVEI B,PT.AMA		; Yes
	DPB A,[POINT 8,PBCONT(PB),7]  ; Store Mark byte
	DPB B,PUPTYP		; Set Pup Type
	MOVEI A,MNPLEN+1	; Set Pup Length appropriately
	DPB A,PUPLEN
	PUSHJ P,SNDBSP		; Send it on its way
	RETSKP			; Done, skip return                    |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 53

; Perform BSP processing for a port, if possible
; Called only from background
;	UNIT/ Pup unit #
; Returns +1
; Clobbers most everything besides UNIT

DOBSP:	LOCK(PRTLCK,,SPQ)	; Lock out changes to port table
	HRRZ BSP,PUPLNH(UNIT)	; Get BSP linkage if any
	JUMPE BSP,[UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Do nothing if not BSP port
		POPJ P,]
	PUSHJ P,LCKBSA		; Attempt to lock BSP port
	 JRST [	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Can't, unlock table
		MOVE A,TODCLK	; Request delayed background processing
		ADDI A,IBWDLY	; Input background wakeup delay interval
		PUSHJ P,ADDTQP	; Add port to timer queue
		POPJ P,]	; Return having done nothing
	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Ok, unlock the table
	PUSHJ P,DOBSPB		; Do the real work
	PUSHJ P,ULKBSP		; Update status, unlock BSP port
	POPJ P,			; Done


; Perform BSP processing for port locked by caller
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
;	IOS/ Port status
; Returns +1 always, does not unlock port
; Clobbers A-D, PB

; Enter here to perform processing only if requested
DOBSPQ:	TLNE IOS,(BSWAKF)	; Specifically woken up?
	 JRST DOBSPL		; Yes, always do it
	MOVE A,TODCLK		; No, get now
	SKIPE PUPTMQ(UNIT)	; Is there a timer request in?
	 CAMGE A,PUPTIM(UNIT)	; Yes, is it due?
	 POPJ P,		; No, do nothing

; Enter here to reset possibly pending requests first
DOBSPL:	PUSHJ P,DELTQP		; Delete timer request if pending

; Enter here from DOBSP (background only)
DOBSPB:	TLZ IOS,(BSWAKF)	; Cancel wakeup request
	MOVEM IOS,PUPSTS(UNIT)	; Update in core too

; Process packets on input queue
DOBSP1:	PUSHJ P,GETPUP		; Get packet from input queue
	 JRST DOBSP2		; Queue empty
	PUSH P,E
	PUSHJ P,DOBSPI		; Process the packet
	POP P,E
	JRST DOBSP1		; Repeat until queue empty

; Send Ack if needed
DOBSP2:	TLZE IOS,(BSSAKF)	; Need to send Ack?
	 PUSHJ P,SNDACK		; Yes, do so

; See if time yet to check for BSP retransmissions
	MOVE A,TODCLK		; Get now
	CAMGE A,BSPDTM(BSP)	; Time for check?
	TLNE IOS,(BSRAKF)	; Received Ack?
	 PUSHJ P,DOBSPO		; Yes, do output processing

; Check outstanding Interrupts
	MOVE A,TODCLK		; Get now
	CAML A,BSPITM(BSP)	; Time for check?
	 PUSHJ P,CKPINT		; Yes, do so

; Check FSM if required
	MOVE A,TODCLK		; Get now
	CAML A,BSPFTM(BSP)	; Time for FSM check?
	 PUSHJ P,[MOVEI A,E.TIMO  ; Yes, generate timeout event
		JRST PUPFSC]

; Compute time for next service
	JRST SETPTM		; Set time and return
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 54

; Process input packet for BSP port
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
;	IOS/ Port status
;	PB/ Packet buffer pointer
; Returns +1
; Clobbers A-D, E
; Updates IOS where appropriate

DOBSPI:
; Check Pup Checksum unless inhibited by user
	TLNE IOS,(BSNCHK)	; Checksumming inhibited?
	 JRST .+3		; Yes, bypass
	PUSHJ P,CHKCKS		; No, check checksum
	 BUGP(DPR,<DOBSPI: Pup Checksum incorrect>,X)                  |

; Check Pup Type and get dispatch
	LDB E,PUPTYP		; Get Pup Type
	CAIGE E,NBSDSP		; Within bounds?
	 SKIPN E,BSPDSP(E)	; Yes, get flags and dispatch
	 BUGP(DPR,<DOBSPI: BSP Pup of unknown type>,X)                 |

; Perform pre-dispatch checking of Pup depending on flags
	TLNN E,(1B16)		; Check Source Port?
	 JRST .+3		; No
	PUSHJ P,CHKSRC		; Yes, perform source port check
	 BUGP(DPR,<DOBSPI: BSP Pup from incorrect Source Port>,X)      |

	TLNN E,(1B17)		; Check Pup ID?
	 JRST DOBSI1		; No
	MOVE A,PBHEAD+1(PB)	; Yes, get word containing Pup ID
	LSH A,-4		; Right-justify
	CAME A,BSPCID(BSP)	; Same as Connection ID?
	 BUGP(DPR,<DOBSPI: BSP Pup with incorrect ID>,X)               |
                                                                       |
DOBSI1:	LDB A,PBSSTT		; Get current state                    |
	TDNN E,BITS##(A)	; Reasonable type for this state?      |
	 BUGP(DPR,<DOBSPI: Improper port state for received Pup>,X)    |

	MOVE A,TODCLK		; Get now
	TLNE E,(1B15)		; Want to reset timeout?
	 MOVEM A,BSPACT(BSP)	; Remember time of last activity
	JRST 0(E)		; Dispatch to processing routine


; BSP dispatch table, indexed by Pup Type
; Flags:
;	B0 - max state #:  Proper port states for this type
;	B15: Update activity timeout before dispatch
;	B16: Check Source Port before dispatch
;	B17: Check for Pup ID = Connection ID before dispatch

BSPDSP:	0			; (0)
	ALLSTT+1B16+RCVECH	; (1) Echo Me
	ALLSTT+1B16+RCVIEC	; (2) I'm An Echo
	ALLSTT+1B16+RCVBEC	; (3) I'm A Bad Echo
	ALLSTT+RCVERR		; (4) Error
	0			; (5)
	0			; (6)
	0			; (7)
	STTBTS(RFCO,LIST,OPEN,ENDO)+1B15+RCVRFC  ; (10) Request for Connection
	ALLSTT+1B16+1B17+RCVABT	; (11) Abort
	ALLSTT+1B15+1B16+1B17+RCVEND  ; (12) End
	ALLSTT+1B15+1B16+1B17+RCVENR  ; (13) End Reply
	0			; (14)
	0			; (15)
	0			; (16)
	0			; (17)
	STTBTS(OPEN,ENDO)+1B15+1B16+RCVDAT  ; (20) Data
	STTBTS(OPEN,ENDO)+1B15+1B16+RCVADA  ; (21) AData
	STTBTS(OPEN,ENDI)+1B15+1B16+RCVACK  ; (22) Acknowledgment
	STTBTS(OPEN,ENDO)+1B15+1B16+RCVMRK  ; (23) Mark
	STTBTS(OPEN,ENDI,ENDO)+1B15+1B16+RCVINT  ; (24) Interrupt
	STTBTS(OPEN,ENDI,ENDO)+1B15+1B16+RCVINR  ; (25) Interrupt Reply
	STTBTS(OPEN,ENDO)+1B15+1B16+RCVAMA  ; (26) AMark

NBSDSP==.-BSPDSP	; Length of the dispatch table
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 55

; Individual BSP Pup input processing routines
; All routines have the following calling sequence:
;	PB/ Packet buffer ptr
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
;	IOS/ BSPSTS(BSP)
; Returns +1 always
; Routine is expected to dispose of the packet
; Clobbers A-D
; Routines to handle RFC, Abort, End, and End Reply are located
;  near the FSM routines


; Echo
; ----

RCVECH:	MOVEI A,PT.IEC		; Set type = "I'm an Echo"
	DPB A,PUPTYP
	PUSHJ P,SWPPRT		; Swap source and destination ports
	PUSHJ P,SNDPU1		; Setup and send
	 CAI			; Ignore if failed
	POPJ P,			; Done, packet buffer re-used


; I'm an Echo
; -----------

RCVIEC:				; Discard (we don't send EchoMe's)


; I'm a Bad Echo
; --------------

RCVBEC:	JRST RELPKT		; Discard (we don't send EchoMe's)



; Error
; -----

RCVERR:	BUGP(PUP,<RCVERR: Received Error Pup>,X)                       |
	LDB A,[POINT 16,PBCONT+5(PB),15]  ; Get error type
	CAIE A,3		; Port IQ overflow?
	CAIN A,1007		; Gateway OQ overflow?
	 JRST RCVER1		; Yes
	CAIN A,2		; No such port?
	 PUSHJ P,CHKSRC		; Yes, make sure source correct
	  JRST RELPKT		; Not, discard
	JRST RCVABT		; Yes, treat same as Abort

RCVER1:	HLRZ A,BSPTIM(BSP)	; Get retransmission timeout
	IMULI A,9		; Increase by 1/8
	LSH A,-3
	CAIG A,MAXRET		; Within maximum?
	 HRLM A,BSPTIM(BSP)	; Yes, update
	JRST RELPKT		; Discard packet and return
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 56

; Input Pup processing routines (cont'd)

; AMark
; -----

RCVAMA:	TLO IOS,(BSSAKF)	; Request that an Ack be sent

; Mark
; ----

RCVMRK:	LDB A,PUPLEN		; Make sure it contains just 1 byte
	CAIE A,MNPLEN+1
	 BUGP(DPR,<RCVMRK: Received Mark with incorrect length>,X)     |
	JRST RCVDAT		; Handle Mark like Data


; AData
; -----

RCVADA:	TLO IOS,(BSSAKF)	; Request that an Ack be sent

; Data
; ----

RCVDAT:	HRLM PB,0(P)		; Save PB pointer
	MOVEI A,17		; Get Pup ID and clear garbage bits
	ANDCAB A,PBHEAD+1(PB)
	LSH A,-4		; Right-justify
	MOVEM A,PBBSID(PB)	; Store in more convenient form
	LDB B,PUPLEN		; Get Pup Length
	SUBI B,MNPLEN		; Compute # data bytes
	JUMPE B,RELPKT		; Flush packet if none
	MOVEM B,PBBSBC(PB)	; Store in more convenient form
	MOVE C,BSPILW(BSP)	; Get left window edge
	HRRZ D,BSPIAL(BSP)	; Get width of window
	PUSHJ P,CMPIVL		; Compare intervals
	 JRST RCVDA1		; Identical (ok but most unlikely)
	 JRST RCVDA1		; Pup subinterval of window
	 BUGP(DPR,<RCVDAT: Received Data Pup larger than window>,X)    |
	 JRST RCVDA1		; Intersect but not contained
	 JRST RELPKT		; Outside window, discard quietly

; Scan the BSP input queue and find where this packet belongs
RCVDA1:	MOVEI C,BSPIBQ(BSP)	; Start at tail of input queue
RCVDA2:	HLRZ C,0(C)		; Get predecessor
	CAIN C,BSPIBQ(BSP)	; Reached head of queue?
	 JRST [	HRRZ A,0(C)	; Yes, must belong here
		JRST RCVDA4]
	MOVE A,PBHEAD+1(PB)	; No, get back ID of new Pup
	SUB A,PBHEAD+1-PBBSPQ(C) ; Compare to ID of queued Pup
	JUMPL A,RCVDA2		; Repeat if existing ID larger

; Now C points to PBBSPQ of last old Pup with ID <= new Pup's ID
; B still contains the new Pup's length
	MOVE A,PBBSID(PB)	; Get back ID of new Pup
	MOVEI PB,-PBBSPQ(C)	; Point to head of existing packet
	MOVE C,PBBSID(PB)	; Get its ID
	MOVE D,PBBSBC(PB)	; Get # data bytes in it
	PUSHJ P,CMPIVL		; Compare intervals
	 CAI			; +1: Identical, discard new packet
	 JRST [	HLRZ PB,0(P)	; +2: New packet is contained by
		JRST RELPKT]	;  existing one, discard new
	 JRST [	MOVEI A,PBBSPQ(PB)  ; +3: Existing contained by
		JRST RCVDA4]	;    new, insert new before it
	 CAI			; +4: Intersect without containment
	HRRZ A,PBBSPQ(PB)	; +5: Disjoint, get successor
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 57

; Input Pup processing routines (cont'd)

; Data (cont'd)
; ----

; Now ready to put the new packet on the input queue.
; A points to PBBSPQ word of packet before which the new packet
;  is to be inserted (i.e. to be the new packet's successor).
RCVDA4:	HLRZ PB,0(P)		; Recover new PB pointer
	HLRZ C,BSPIQL(BSP)	; Get # Pups already on queue
	LDB B,PBSIAP		; Get max # Pups allowed
	CAIL C,(B)		; Allocation exhausted?
	 BUGP(DPR,<RCVDAT: Received Data exceeding Pup allocation>,X)  |
	MOVSI C,1		; No, add to count
	ADDM C,BSPIQL(BSP)
	MOVEI B,PBBSPQ(PB)	; Make ptr to queue link word
	PUSHJ P,INSITQ		; Insert into queue

; Scan successor Pups for ones completely swallowed by the new one
RCVDA5:	HRRZ A,PBBSPQ(PB)	; Get new Pup's successor
	CAIN A,BSPIBQ(BSP)	; Make sure there is one
	 JRST RCVDA6		; None, skip this
	MOVE C,PBBSID-PBBSPQ(A)	; Get ID of existing Pup
	MOVE D,PBBSBC-PBBSPQ(A)	; Get # data bytes in it
	MOVE A,PBBSID(PB)	; Get ID of new Pup
	MOVE B,PBBSBC(PB)	; Get # data bytes in it
	PUSHJ P,CMPIVL		; Compare intervals
	 BUG(HLT,RCVDAA,<RCVDAT: Impossible +1 return from CMPIVL>)    |
	 BUG(HLT,RCVDAB,<RCVDAT: Impossible +2 return from CMPIVL>)    |
	 JRST [	HRRZ A,PBBSPQ(PB)  ; +3: Existing contained by
		MOVEI PB,-PBBSPQ(A) ;  new, delete existing
		PUSHJ P,DELBIQ
		HLRZ PB,0(P)	; Recover new PB pointer
		JRST RCVDA5]	; Repeat for new successor
	 CAI			; +4: Intersect without containment
				; +5: Disjoint

; If we filled in a hole, update byte count
RCVDA6:	MOVE A,PBBSID(PB)	; Get ID of new Pup
	SUB A,BSPILW(BSP)	; Compute bytes from left edge
	TLZ A,(-1B3)		;  mod 2^32
	HRRZ B,BSPIQL(BSP)	; Get # bytes to first hole
	CAILE A,(B)		; New Pup starts before or at hole?
	 JRST RCVDA7		; No
	ADD A,PBBSBC(PB)	; Yes, add # bytes in new Pup
	CAILE A,(B)		; Now past start of hole?
	 HRRM A,BSPIQL(BSP)	; Yes, update # bytes available
	HRRZ A,PBBSPQ(PB)	; Advance to successor Pup
	MOVEI PB,-PBBSPQ(A)
	JRST RCVDA6		; Repeat until hit new hole

RCVDA7:	SKIPE B			; Bytes now available?
	 PUSHJ P,WAKBSI		; Yes, awaken input
	POPJ P,			; Done
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 58

; Input Pup processing routines (cont'd)

; Acknowledgment
; --------------

RCVACK:	LDB A,PUPLEN		; Get Pup Length
	CAIGE A,MNPLEN+6	; Make sure big enough
	 BUGP(DPR,<RCVACK: Pup too small>,X)                           |
	MOVE A,PBHEAD+1(PB)	; Get Pup ID
	LSH A,-4		; Right-justify
	MOVE B,A		; Copy it
	SUB B,BSPOLW(BSP)	; Compute distance from left window edge
	TLZ B,(-1B3)		;  modulo 2^32
	HRRZ C,BSPOQL(BSP)	; Get width of window
	CAILE B,(C)		; Pup ID in window?
	 BUGP(DPR,<RCVACK: Received Ack with unreasonable ID>,X)       |
	MOVEM A,BSPOLW(BSP)	; Yes, store new left window edge
	SUBI C,(B)		; Compute updated width
	HRRM C,BSPOQL(BSP)
	HRLM PB,0(P)		; Save pointer to Ack packet
	TLO IOS,(BSRAKF)	; Note that we received an Ack

; Scan BSP output queue and discard packets now lying entirely
;  outside the updated window.  Ignore Pos/NegAcks ****************
RCVAC1:	HRRZ A,BSPOBQ(BSP)	; Get BSP output queue head
	CAIN A,BSPOBQ(BSP)	; Now empty?
	 JRST RCVAC5		; Yes
	MOVEI PB,-PBBSPQ(A)	; No, make ptr to head PB
	MOVE A,PBHEAD+1(PB)	; Get Pup ID
	LSH A,-4		; Right-justify
	LDB B,PUPLEN		; Get Pup Length
	ADDI A,-MNPLEN-1(B)	; Compute ID of last byte in Pup
	SUB A,BSPOLW(BSP)	; Compare to left window edge
	LSH A,4
	JUMPGE A,RCVAC5		; Jump if in window
	PUSHJ P,DELBOQ		; Outside, delete from output queue
	JRST RCVAC1		; Continue with next

; Update the allocations
RCVAC5:	HLRZ PB,0(P)		; Recover ptr to Ack packet
	MOVE D,[POINT 16,PBCONT(PB)]  ; Init byte ptr to data  
	ILDB A,D		; Get "Max bytes/Pup" field
	CAILE A,MXPLEN-MNPLEN	; More than what we allow anyway?
	 MOVEI A,MXPLEN-MNPLEN	; Yes, cut down
	LDB B,PBSOBP		; Get current bytes/Pup
	CAIGE A,(B)		; Decreasing?
	 BUGP(PUP,<RCVACK: Allocated decreasing bytes per Pup>,X)      |
	DPB A,PBSOBP		; Store updated bytes/Pup
	ILDB A,D		; Get "Number of Pups" field
	CAILE A,MXBSOP		; More than maximum we allow?
	 MOVEI A,MXBSOP		; Yes, limit
	HLRZ B,BSPOQL(BSP)	; Get # Pups already queued
	SUBI A,(B)		; Compute additional Pups
	SKIPGE A		; Make sure positive
	 SETZ A,		; Force to zero otherwise
	DPB A,PBSOAP		; Store # additional Pups allowed
	ILDB A,D		; Get "Number of bytes" field
	CAILE A,MXBSOB		; More than maximum we allow?
	 MOVEI A,MXBSOB		; Yes, limit
	HRRZ B,BSPOQL(BSP)	; Get # bytes already queued
	SUBI A,(B)		; Compute additional bytes allowed
	SKIPGE A		; Make sure positive
	 SETZ A,		; Force to zero otherwise
	HRRM A,BSPOAL(BSP)	; Store # additional bytes allowed

; Update status and return
	HRRZ A,BSPOBQ(BSP)	; Get output queue head
	CAIN A,BSPOBQ(BSP)	; Now empty?
	 TLZ IOS,(BSNOQF)	; Yes, notify anyone watching this
	MOVE A,BSPOAL(BSP)	; Get additional allocation
	TLNE A,(-1B7)		; Can send more Pups?
	TRNN A,-1		; Can send more bytes?
	 CAIA			; No
	 PUSHJ P,WAKBSO		; Yes, awaken BSP output
	JRST RELPKT		; Discard the Ack and return
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 59

; Input Pup processing routines (cont'd)

; Interrupt
; ---------

RCVINT:	MOVE A,PBHEAD+1(PB)	; Get Pup ID
	LSH A,-4		; Right-justify
	CAME A,BSPRII(BSP)	; Same as next expected?
	 AOJA A,RCVIN2		; No
	HRRE B,PUPPSI(UNIT)	; Yes, get fork to interrupt
	JUMPGE B,[LDB A,INTPSI	; Get PSI channel to interrupt on
		CAIGE A,^D36	; Armed?
		 PUSHJ P,PSIRQF ; Yes, initiate PSI on channel         |
		JRST RCVIN1]                                           |
	AOJE B,RCVIN1		; Jump if no assignment                |
	CALL LCKTTY		; Lock tty , get dynamic data          |
	 JRST RCVI1		; No tty, shouldnt happen              |
	PUSH P,B		; Save data                            |
	PUSHJ P,NVTINT		; Process the interrupt                |
	POP P,B                                                        |
RCVI1:	CALL ULKTTY		; Unlock tty                           |
RCVIN1:	AOS BSPRII(BSP)		; Advance receive interrupt ID
	MOVSI A,(-1B3)		;  modulo 2^32
	ANDCAM A,BSPRII(BSP)
	JRST RCVIN3		; Go send reply

; Here if Pup ID is not the same as expected
; If it is the expected ID -1, it is a duplicate which we
;  should acknowledge but not generate an interrupt.  Else flush.
; A/ Pup ID +1
RCVIN2:	TLZ A,(-1B3)		; Make +1 modulo 2^32
	CAME A,BSPRII(BSP)	; Was this a duplicate?
	 BUGP(DPR,<RCVINT: Received Interrupt with incorrect ID>,X)    |

; Here to send the acknowledging Interrupt Reply
RCVIN3:	MOVEI A,PT.INR		; Set type = "Interrupt Reply"
	PUSHJ P,SNDPUP		; Setup and send it back
	 CAI			; Ignore if failed
	POPJ P,			; Done, packet buffer re-used


; Interrupt Reply
; ---------------

RCVINR:	SKIPL A,BSPSII(BSP)	; Check for outstanding Interrupt
	 BUGP(DPR,<RCVINR: Received unexpected Interrupt Reply>,X)     |
	MOVE B,PBHEAD+1(PB)	; Get Pup ID                           |
	ANDCMI B,17		; Clear garbage bits                   |
	CAME B,PBHEAD+1(A)	; Same as outstanding Interrupt's ID?  |
	 BUGP(DPR,<RCVINR: Received Interrupt Reply with incorrect ID>,X)
                                                                       |
	PUSHJ P,RELPKT		; Yes, release the Interrupt Reply
	HRRZ PB,BSPSII(BSP)	; Get ptr to Interrupt again
	MOVE A,PBHEAD+1(PB)	; Get Pup ID
	ADDI A,20		; Increment and right-justify
	LSH A,-4
	MOVEM A,BSPSII(BSP)	; Store updated send Interrupt ID
	PUSHJ P,DELOBQ		; Unqueue and release saved Interrupt
	HRLOI A,377777		; Set Interrupt timer to infinity
	MOVEM A,BSPITM(BSP)
	TLZ IOS,(BSINTF)	; Clear Interrupt outstanding flag
	POPJ P,			; Done, packet disposed of



; Check for retransmission of Interrupt Pup
; Assumes port locked and ac's setup
; Returns +1
; Clobbers A-D, PB

CKPINT:	SKIPL PB,BSPSII(BSP)	; Have outstanding Interrupt?
	 JRST [	HRLOI A,377777	; No, reset timer to infinity
		JRST CKPIN1]
	PUSHJ P,RETPUP		; Yes, queue for retransmission
	MOVE A,PBTIME(PB)	; Get time of original transmission
	PUSHJ P,NXTTIM		; Compute time of next check
CKPIN1:	MOVEM A,BSPITM(BSP)	; Store in data block
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 60

; Do BSP output processing -- flow control and retransmission
; Assumes port locked and ac's setup
; Returns +1 always
; Clobbers A-D, PB

DOBSPO:	CHKSTT <OPEN,ENDI>	; Reasonable state for BSP output?
	 JRST [	HRLOI A,377777	; No, set timer to infinity
		MOVEM A,BSPDTM(BSP)
		TLZ IOS,(BSRAKF)  ; Clear rec'd Ack flag
		POPJ P,]	; Return having done nothing
	TLZN IOS,(BSRAKF)	; Received Ack?
	 JRST DOBSO6		; No, just check timers

; Ack was received
; See if we have any packets to retransmit
	HRRZ A,BSPOBQ(BSP)	; Get head of queue
	CAIN A,BSPOBQ(BSP)	; Empty?
	 JRST SETTMI		; Yes, set idle interval and return
	HLRZ D,BSPTIM(BSP)	; No, get round-trip time
	ADD D,PBTIME-PBBSPQ(A)	; Check time stamp of first packet
	CAMLE D,TODCLK		; Older than round-trip time?
	 JRST [	PUSHJ P,CHKADA	; No retransmittable packets, want to send AData?
		 JRST SETTMH	; No, set hold interval and return
		PUSHJ P,SETTMR	; Yes, compute time of next probe
		JRST SNDADA]	; Send null AData and return

; Retransmit all unacknowledged packets older than the estimated
;  round-trip delay
DOBSO1:	MOVEI PB,-PBBSPQ(A)	; Make pointer to head of PB
	HLRZ D,BSPTIM(BSP)	; Get round-trip time
	MOVN D,D		; Make negative
	ADD D,TODCLK		; Compute cutoff time
	HRRZ A,PBBSPQ(PB)	; Get successor of current packet
	CAIE A,BSPOBQ(BSP)	; Is there one?
	 CAMGE D,PBTIME-PBBSPQ(A)  ; Yes, also retransmittable?
	 JRST DOBSO2		; No, possibly want to send AData
	PUSHJ P,RETDAT		; Yes, retransmit current as Data
	HRRZ A,PBBSPQ(PB)	; Get successor again
	JRST DOBSO1		; Repeat for it

; Here when have last retransmittable packet
DOBSO2:	PUSHJ P,CHKADA		; Timer expired or allocation low?
	 JRST [	PUSHJ P,RETDAT	; No, retransmit as Data
		JRST SETTMH]	; Set hold interval, return
	PUSHJ P,RETADA		; Yes, retransmit as AData
	JRST SETTMR		; Set retransmission interval, exit

; Here if no Ack was received
; If data timer ran out, send an AData if necessary
; Also check error timer
DOBSO6:	MOVE A,TODCLK		; Get now
	CAMGE A,BSPDTM(BSP)	; Timed out?
	 POPJ P,		; No, done
	SUB A,BSPACT(BSP)	; Yes, compute time since last activity
	LDB B,PBSTMO		; Get error timeout interval
	LSH B,^D12		; Convert to ms
	CAML A,B		; Too long?
	 PUSHJ P,BSPTMO		; Yes, signal error timeout

	PUSHJ P,SETTMI		; Compute time for next probe
	PUSHJ P,SNDADA		; Send null AData
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 61

; Determine whether want to (re)transmit AData, i.e.,
;  compute the predicate:
;	~ ADataOut and (AllocAlmostGone or Time[Oldest]<Now-Hold)
; Assumes port is locked and ac's setup
; Returns +1:  Don't send AData
;	+2:  Send AData
; Clobbers A, B

CHKADA:	HLRZ A,BSPTIM(BSP)	; Get round-trip delay
	ADD A,BSPATM(BSP)	; Add to time of last AData
	CAML A,TODCLK		; More recent than round-trip time?
	 POPJ P,		; Yes, don't send another
	HRRZ A,BSPOBQ(BSP)	; No, get head of queue
	CAIN A,BSPOBQ(BSP)	; Empty?
	 JRST CHKALL		; Yes, skip this test
	MOVE A,PBTIME-PBBSPQ(A)	; No, get packet's time stamp
	ADDI A,HLDINT		; Add hold time
	CAMGE A,TODCLK		; Packet older than hold time?
	 RETSKP			; Yes, return +2: send AData           |
				; No, fall into CHKALL


; Check for allocation being low
; Assumes port is locked and ac's setup
; Returns +1:  allocation sufficient
;	+2:  allocation exhausted or almost exhausted
; Clobbers A, B

CHKALL:	LDB A,PBSOAP		; Get # Pups allocation
	HLRZ B,BSPOQL(BSP)	; Get # Pups already queued
	ADDI B,(A)		; Derive initial allocation
	IMULI A,^D100/ALLPCT	; Below threshold?
	CAMG A,B
	 RETSKP			; Yes, return +2: almost exhausted     |
	HRRZ A,BSPOAL(BSP)	; No, now get # bytes allocation
	HRRZ B,BSPOQL(BSP)	; Get # bytes already queued
	ADDI B,(A)		; Derive initial allocation
	IMULI A,^D100/ALLPCT	; Below threshold?
	CAMG A,B
	 RETSKP			; Yes, return +2: almost exhausted     |
	POPJ P,			; No, +1:  allocation sufficient



; Routines to compute and store new timeout
; All return +1 and clobber A, B

; Enter here to set timer to Time[Oldest]+HoldTime
; If the queue is empty, the idle probe interval is used
SETTMH:	HRRZ B,BSPOBQ(BSP)	; Get head of queue
	CAIN B,BSPOBQ(BSP)	; Empty?
	 JRST SETTM2		; Yes, use idle interval
	MOVE A,PBTIME-PBBSPQ(B)	; Get age of packet
	ADDI A,HLDINT		; Compute remaining hold time
	SUB A,TODCLK
	HLRZ B,BSPTIM(BSP)	; Get retransmission timeout
	CAIGE A,(B)		; Hold at least that long
	 MOVEI A,(B)
	JRST SETTM3		; Go set new time

; Enter here to set timer to Now + Retransmission interval
SETTMR:	HLRZ A,BSPTIM(BSP)	; Get retransmission timeout
	JRST SETTM3		; Go set new time

; Enter here to set timer to idle probe interval, i.e.:
;  if AllocExhausted then Now+HLDINT else Now+IDLINT
SETTMI:	MOVE A,BSPOAL(BSP)	; Get allocations
	TLNE A,(-1B7)		; Pups exhausted?
	TRNN A,-1		; Bytes exhausted?
	 SKIPA A,[HLDINT]	; Yes, use hold interval (shorter)
SETTM2:	MOVEI A,PRBINT		; Not exhausted, use idle interval
SETTM3:	ADD A,TODCLK		; Add increment to now
SETTM4:	MOVEM A,BSPDTM(BSP)	; Set time of next check
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 62

; Retransmit Data/Mark Pup as AData/AMark
;	PB/ Packet buffer ptr
; Assumes port is locked and ac's setup
; Returns +1 always
; Clobbers A-D

RETADA:	LDB A,PUPTYP		; Get existing type
	CAIN A,PT.DAT		; Data?
	 MOVEI A,PT.ADA		; Yes, change to AData
	CAIN A,PT.MRK		; Mark?
	 MOVEI A,PT.AMA		; Yes, change to AMark
	MOVE B,TODCLK		; Save time we sent it
	MOVEM B,BSPATM(BSP)
	JRST RETDA1		; Join common code

; Retransmit Data/Mark Pup as Data/Mark
;	PB/ Packet buffer ptr
; Assumes port is locked and ac's setup
; Returns +1 always
; Clobbers A-D

RETDAT:	LDB A,PUPTYP		; Get existing type
	CAIN A,PT.ADA		; AData?
	 MOVEI A,PT.DAT		; Yes, change to Data
	CAIN A,PT.AMA		; AMark?
	 MOVEI A,PT.MRK		; Yes, change to Mark
RETDA1:	MOVE B,PUPTYP		; Get byte ptr to existing type
	LDB C,B			; Get existing Pup Type
	CAIE A,(C)		; Changing type?
	 PUSHJ P,UPDCKS		; Yes, do so and fix checksum
	AOS BSPOPR(BSP)		; Count retransmitted packets

; Fall into RETPUP
; Note there is a potential race here whose worst effect would
; be sending a Pup with a bad checksum.


; Retransmit a Pup
;	PB/ Packet buffer ptr
; Assumes port is locked and ac's setup
; Returns +1 always
; Clobbers A-D

RETPUP:	SKIPE PBIOBQ(PB)	; Already queued for transmission?
	 JRST RETPU1		; Yes
	PUSHJ P,PUTPUP		; No, put on queue
	 BUGP(PUP,<RETPUP: Output queue overflowed>,X)                 |
	POPJ P,                                                        |
                                                                       |
RETPU1:	BUGP(PUP,<RETPUP: Pup already on transmission queue>,X)        |
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 63

; Compute time of next check (for retransmissions)
; Retransmission intervals start at the nominal interval
;  given by LH BSPTIM and double for each retransmission,
;  with a maximum given by the constant PRBINT (~15 seconds)
;	A/ Time of previous check
; Assumes port is locked and ac's setup
; Returns +1:  A/ Time of next check
; Generates timeout error if appropriate
; Clobbers A, B

NXTTIM:	SUB A,TODCLK		; Get -(now-then)
	MOVNS A			; Make positive
	PUSH P,A		; Save it
	LDB B,PBSTMO		; Get error timeout interval
	LSH B,^D12		; Convert to ms
	CAML A,B		; Too long?
	 PUSHJ P,BSPTMO		; Yes, signal timeout error
	POP P,A			; Recover interval
	ASH A,1			; Double it
	HLRZ B,BSPTIM(BSP)	; Get retransmission timeout
	CAIGE A,(B)		; Use whichever is greater
	 MOVEI A,(B)
	CAILE A,PRBINT		; But never greater than
	 MOVEI A,PRBINT		;  probe interval while idle
	ADD A,TODCLK		; Add offset to now
	POPJ P,



; Set timer for port
; Call after changing BSPDTM, BSPITM, or BSPFTM
; Returns +1
; Clobbers A-D

SETPTM:	PUSHJ P,DELTQP		; Delete from timer queue if on it
	MOVE A,BSPDTM(BSP)	; Get time to send next AData
	CAMLE A,BSPITM(BSP)	; Retransmit Interrupt sooner?
	 MOVE A,BSPITM(BSP)	; Yes, use it
	CAMLE A,BSPFTM(BSP)	; Check FSM sooner?
	 MOVE A,BSPFTM(BSP)	; Yes, use that
	PUSHJ P,ADDTQP		; Add port to timer queue
	POPJ P,



; Send a null AData (for probing)
;	BSP/ BSP data block ptr
; Returns +1 always
; Clobbers A-D, PB

SNDADA:	MOVEI B,MNPBLN		; Allocate minimum-length Pup
	PUSHJ P,ASGPKT
	 POPJ P,		; Can't, forget it
	MOVEI A,MNPLEN		; Set Pup Length
	DPB A,PUPLEN
	HRRZ A,BSPOQL(BSP)	; Get # of bytes queued
	ADD A,BSPOLW(BSP)	; Compute ID of first byte not sent
	LSH A,4			; Left-justify
	MOVEM A,PBHEAD+1(PB)	; Store ID in packet
	MOVEI A,PT.ADA		; Pup Type = AData
	PUSHJ P,SNDPUP		; Send it
	 CAI			; Ignore failure
	MOVE A,TODCLK		; Remember time of last AData
	MOVEM A,BSPATM(BSP)
	AOS BSPPPG(BSP)		; Count probe packets generated
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 64

; Send an Ack
;	UNIT/ Pup unit #
;	BSP/ BSP data block pointer
;	IOS/ BSPSTS(BSP)
; Returns +1 always
; Clobbers A-D, PB

SNDACK:	MOVEI B,PBHEAD+<MNPLEN+6+6*MXSACK+3>/4  ; Max-length Ack
	PUSHJ P,ASGPKT		; Assign packet buffer
	 JRST [	TLO IOS,(BSSAKF)  ; Failed, note ack still needed
		POPJ P,]

; Compute Pup ID for cumulative acknowledgement
	HRRZ A,BSPIQL(BSP)	; Get offset from left edge to hole
	ADD A,BSPILW(BSP)	; Compute ID of first hole
	LSH A,4			; Left-justify
	MOVEM A,PBHEAD+1(PB)	; Set Pup ID

; Setup the allocation block
	PUSH P,[POINT 16,PBCONT(PB)]  ; Init byte ptr into Pup
	LDB A,PBSIBP		; Get maximum bytes/Pup
	IDPB A,0(P)		; Store in Pup
	LDB A,PBSIAP		; Get maximum # Pups allowed
	HLRZ C,BSPIQL(BSP)	; Get # Pups already on queue
	SUBI A,(C)		; Compute remainder
	SKIPGE A		; Make sure positive
	 SETZ A,		; Make zero if negative
	IDPB A,0(P)		; Store # Pups allowed into Pup
	HRRZ B,BSPIAL(BSP)	; Get maximum # bytes allowed
	SUB B,BSPIQL(BSP)	; Subtract # bytes used
	TRNE B,400000		; Make sure positive
	 SETZ B,		; Make zero if negative
	IDPB B,0(P)		; Store # bytes allowed into Pup
	SKIPE A			; Sending zero # Pups allocation?
	 TRNN B,-1		; Sending zero # bytes allocation?
	 TLOA IOS,(BSZALF)	; Yes, remember we did this
	 TLZ IOS,(BSZALF)	; No, clear flag

IFG MXSACK,<		; Only if allowed to send specific Acks
; Specifically acknowledge Pups beyond first hole
; First, scan forward from tail to find first packet past hole
	MOVEI A,BSPIBQ(BSP)	; Get pointer to queue header
SNDAC2:	HLRZ A,0(A)		; Get predecessor
	CAIN A,BSPIBQ(BSP)	; Reached head?
	 JRST SNDAC3		; Yes
	MOVE B,PBHEAD+1-PBBSPQ(A)  ; No, get ID of this packet
	SUB B,PBHEAD+1(PB)	; Compare to ID of Ack
	JUMPGE B,SNDAC2		; Repeat if still beyond hole
SNDAC3:	HRRZ A,0(A)		; Ok, now get successor
	CAIN A,BSPIBQ(BSP)	; Make sure there is one
	 JRST SNDAC7		; No Pups to specifically ack

; Now A/ pointer to PBBSPQ of first Pup past hole
; Build PosAck blocks
	MOVSI D,-MXSACK		; Init max # of specific acks
SNDAC4:	HRRI D,(A)		; Save ptr to start of range
SNDAC5:	MOVE B,PBBSID-PBBSPQ(A)  ; Get ID right-justified
	ADD B,PBBSBC-PBBSPQ(A)	; Add number of bytes in packet
	LSH B,4			; Left-justify
	HRRZ A,0(A)		; Get successor
	CAIN A,BSPIBQ(BSP)	; Make sure there is one
	 JRST SNDAC6		; No, end of queue
	MOVE C,PBHEAD+1-PBBSPQ(A)  ; Yes, get its ID left-justified
	SUB C,B			; See if touch or overlap previous
	JUMPLE C,SNDAC5		; Loop if so, to combine ranges
SNDAC6:	SUB B,PBHEAD+1-PBBSPQ(D)  ; No, compute length of range
	LSH B,-4		; Right-justify
	IORI B,100000		; Set flag to note PosAck
	IDPB B,0(P)		; Store flag and # bytes in Pup
	MOVE B,PBBSID-PBBSPQ(D)	; Get starting ID right-justified
	ROT B,-^D16		; Right-justify high 16 bits
	IDPB B,0(P)		; Store in Pup
	ROT B,^D16		; Right-justify low 16 bits
	IDPB B,0(P)		; Store in Pup
	CAIE A,BSPIBQ(BSP)	; Reached end of queue?
	 AOBJN D,SNDAC4		; No, repeat if not past limit

; Still in IFG MXSACK conditional
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 65

; SNDACK (cont'd)

; Now finish up and send the Ack
SNDAC7:	POP P,A			; Restore byte pointer
	PUSHJ P,ENDPUP		; Compute length and trim packet
> ; End IFG MXSACK
IFE MXSACK,<
	SUB P,BHC##+1		; Flush byte ptr from stack
	MOVEI A,MNPLEN+6	; Constant if no specific acks
	DPB A,PUPLEN		; Store Pup Length
>
	MOVEI A,PT.ACK		; Pup type = "Ack"
	PUSHJ P,SNDPUP		; Setup header and send it
	 TLO IOS,(BSSAKF)	; Couldn't, note Ack still needed
	POPJ P,			; Done



; Compute Pup Length given byte pointer, and trim excess
;	A/ Byte ptr to last byte stored
;	PB/ Packet buffer ptr
; Returns +1 always
; Clobbers A-D

ENDPUP:	MOVEI B,@A		; Compute address of last word
	SUBI B,PBHEAD-1(PB)	; Compute # 36-bit words used
	LSH B,2			; Convert to bytes
	LSH A,-^D33		; Get bytes not used in last word
	SUBI B,(A)		; Compute Pup Length
	ADDI B,2		; Include checksum
	DPB B,PUPLEN		; Store it
	PUSHJ P,TRMUPB		; Trim excess from packet buffer
	POPJ P,



; Set up header and send Pup
;	A/ Pup Type to be stored in packet
;	PB/ Packet buffer pointer
;	UNIT/ Pup unit #
;	IOS/ BSPSTS(BSP)
; Caller is expected to setup Pup Length and ID
; A Pup once passed here is gone forever
; Returns +1:  Failed, packet buffer discarded
;	+2:  Succeeded, packet buffer queued for output
; Clobbers A-D

SNDPUP:	DPB A,PUPTYP		; Store Pup Type in packet
	PUSHJ P,SETPRT		; Set up source and dest ports

; Enter here if type and ports are already setup
SNDPU1:	SETZB A,PBBSPQ(PB)	; Clear BSP queue linkages
	DPB A,PUPTCB		; Zero out Transport Control byte
	PUSHJ P,SETCHK		; Set Pup Checksum appropriately
	PUSHJ P,PUTPUP		; Queue Pup for output
	 BUGP(DPR,<SNDPUP: Output queue overflowed>,X)                 |
	RETSKP			; Done, skip return                    |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 66

; Set up Source and Destination Ports in Pup
;	PB/ Packet buffer pointer
;	UNIT/ Pup unit #
; Returns +1 always

SETPRT:	SKIPN C,PUPFPT(UNIT)	; Get foreign port descriptor
	 BUG(HLT,SETPRA,<SETPRT: Attempt to send Pup to wildcard port>)|
	MOVE A,1(C)		; Get destination net,,host
	MOVE B,2(C)		; Get destination socket
	LSH B,4			; Left-justify socket
	LSHC A,-8		; Concatenate host and socket
	LSH A,-^D10		; Right-justify net
	LSHC A,-8		; Concatenate net/host/high socket
	MOVEM B,PBHEAD+2(PB)	; Store dest net/host/high socket
	MOVE A,2(C)		; Get dest socket again
	MOVE B,PUPLNH(UNIT)	; Get local net/host left-justified
	LSHC A,-^D16		; Concatenate low dest socket to it
	MOVEM B,PBHEAD+3(PB)	; Store source net/host, high dest socket
	MOVE A,PUPLSK(UNIT)	; Get local socket
	LSH A,4			; Left-justify
	MOVEM A,PBHEAD+4(PB)	; Store source socket in PB
	POPJ P,


; Set Pup Checksum appropriately
;	PB/ Packet buffer pointer
;	IOS/ BSPSTS(BSP)
; Returns +1 always
; Clobbers A-D

SETCHK:	TLNN IOS,(BSNCHK)	; Checksumming inhibited?
	 JRST SETCKS		; No, compute and set checksum
	PUSHJ P,GPTCKS		; Yes, get ptr to checksum field
	SETO A,			; Deposit nil checksum
	DPB A,B
	POPJ P,



; Compare sequence number intervals
;	A/ Left edge of interval 1
;	B/ Length of interval 1
;	C/ Left edge of interval 2
;	D/ Length of interval 2
; Returns +1:  Intervals are identical
;	+2:  Interval 1 is a subinterval of 2
;	+3:  Interval 2 is a subinterval of 1
;	+4:  Intervals intersect but neither contains the other
;	+5:  Intervals are disjoint
; Clobbers A, C

CMPIVL:	SUBM C,A		; A _ (L2 - L1) mod 2^32
	TLZ A,(-1B3)
	MOVN C,A		; C _ (L1 - L2) mod 2^32
	TLZ C,(-1B3)
	CAMN B,D		; Lengths same?
	 JUMPE A,CPOPJ##	; Yes, return +1 if left edges same
	CAMGE A,B		; Check for overlaps
	 JRST CMPIV1		; Overlap, maybe 2 subinterval of 1
	CAMGE C,D
	 JRST CMPIV2		; Overlap, maybe 1 subinterval of 2
	POP P,A			; No overlap, return +5
	JRST 4(A)

; Here on overlap with possibility of 2 being a subinterval of 1
CMPIV1:	ADD A,D			; Add 2's size to its offset from 1
	CAMLE A,B		; 2 completely contained by 1?
	 JRST SK3RET##		; No, return +4
	JRST SK2RET##		; Yes, return +3

; Here on overlap with possibility of 1 being a subinterval of 2
CMPIV2:	ADD C,B			; Add 1's size to its offset from 2
	CAMLE C,D		; 1 completely contained by 2?
	 JRST SK3RET##		; No, return +4
	RETSKP			; Yes, return +2                       |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 67

; Flush all packets from BSP queues
; Assumes port is locked
; Returns +1 always
; Clobbers A-D, PB

FLSBSQ:	HLRZ PB,BSPCUR(BSP)	; Delete current input PB if any
	SKIPE PB
	 PUSHJ P,RELPKT
	HRRZ PB,BSPCUR(BSP)	; Delete current output PB if any
	SKIPE PB
	 PUSHJ P,RELPKT
	SETZM BSPCUR(BSP)	; Mark no current PB's
FLSBS1:	HRRZ A,BSPIBQ(BSP)	; Get head of BSP input queue
	CAIN A,BSPIBQ(BSP)	; Empty?
	 JRST FLSBS2		; Yes
	MOVEI PB,-PBBSPQ(A)	; No, get ptr to head of PB
	PUSHJ P,DELBIQ		; Delete from queue
	JRST FLSBS1		; Repeat until empty
FLSBS2:	HRRZ A,BSPOBQ(BSP)	; Get head of BSP output queue
	CAIN A,BSPOBQ(BSP)	; Empty?
	 JRST FLSBS3		; Yes
	MOVEI PB,-PBBSPQ(A)	; No, get ptr to head of PB
	PUSHJ P,DELBOQ		; Delete from queue
	JRST FLSBS2		; Repeat until empty
FLSBS3:	SKIPGE PB,BSPSII(BSP)	; Have pending send Interrupt?
	 PUSHJ P,DELOBQ		; Yes, release PB
	SETZM BSPSII(BSP)	; Clear pointer
	HRRZ PB,BSPTIM(BSP)	; Have a saved Abort packet?
	SKIPE PB
	 PUSHJ P,RELPKT		; Yes, release it
	HLLZS BSPTIM(BSP)	; Clear pointer
	POPJ P,


; Delete Pup from BSP input queue
;	PB/ Packet buffer ptr
; Assumes port is locked
; Returns +1, releases packet buffer, updates Pup count
; Clobbers A-D

DELBIQ:	MOVEI A,PBBSPQ(PB)	; Make ptr to link word
	PUSHJ P,DELITQ		; Delete item from queue
	PUSHJ P,RELPKT		; Release packet buffer
	MOVSI A,-1		; Decrement # Pups in BSP queue
	ADDB A,BSPIQL(BSP)
	SKIPGE A		; Check for over-decrementing
	 BUG(CHK,DELBIZ,<DELBIQ: Over-decrementing BSP input count>)   |
	POPJ P,


; Delete Pup from BSP output queue
;	PB/ Packet buffer ptr
; Assumes port is locked
; Returns +1, releases packet buffer, updates Pup count
; Clobbers A-D

DELBOQ:	HLRZ A,PBBSPQ(PB)	; Get predecessor
	HRRZ B,PBBSPQ(PB)	; Get successor
	HRLM A,(B)		; Fix links between predecessor
	HRRM B,(A)		;  and successor
	PUSHJ P,DELOBQ		; Remove from PUPOBQ if on it
	MOVSI A,-1		; Decrement # Pups in BSP queue
	ADDB A,BSPOQL(BSP)
	SKIPGE A		; Check for over-decrementing
	 BUG(CHK,DELBOZ,<DELBOQ: Over-decrementing BSP output count>)  |
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 68

; Routines to lock/unlock BSP port
; Note:  While a port is locked, the up-to-date flags are
;  carried in IOS, and are stored in PUPSTS(UNIT) when the
;  port is unlocked.  Exception:  the BSWAKF flag is always
;  updated in core (while the port is locked by someone else).


; Lock port iff it is a BSP port
;	UNIT/ Pup unit #
; Returns +1:  Not a BSP port, BSP/ 0
;	+2:  Port locked,
;	BSP/ BSP data block pointer
;	IOS/ PUPSTS(UNIT)
; Clobbers nothing else

LCKBSQ:	HRRZ BSP,PUPLNH(UNIT)	; Get BSP linkage
	JUMPE BSP,CPOPJ##	; Return +1 if not BSP port
	AOS 0(P)		; Ok, preset skip return


; Lock BSP port (wait if already locked)
;	UNIT/ Pup unit #
; Returns +1 always:
;	BSP/ BSP data block pointer
;	IOS/ PUPSTS(UNIT)
; Clobbers nothing else

LCKBSP:	LOCK(PRTLCK,,SPQ)	; Lock out changes to port table
	PUSHJ P,LCKBSA		; Attempt to lock port
	 JRST [	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Can't, unlock table
		PUSH P,A	; Save an ac
		MOVSI A,(UNIT)	; Set scheduler test
		HRRI A,BSLCKT
		MDISMS		; Wait until port unlocked             |
		POP P,A
		JRST LCKBSP]	; Try again to lock
	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Ok, unlock table
	POPJ P,			; Return

RESCD                                                                  |

; Scheduler test for BSP port unlocked
; Arg is Pup unit #

BSLCKT:	MOVSI B,(BSLCKF)	; Flag to test
	TDNE B,PUPSTS(A)	; Locked?
	 JRST 0(D)		; Yes, wait
	JRST 1(D)		; Unlocked, wakeup

SWAPCD                                                                 |


; Attempt to lock BSP port
; PRTLCK must be locked by caller
;	UNIT/ Pup unit #
; Returns +1: Failed, already locked, IOS clobbered
;	+2: Ok, we have locked it:
;		BSP/ BSP data block pointer
;		IOS/ PUPSTS(UNIT)
; Clobbers nothing else

LCKBSA:	HRRZ BSP,PUPLNH(UNIT)	; Get linkage
	SKIPN BSP		; Make sure have BSP port
	 BUG(HLT,LCKBSZ,<LCKBSA: Attempt to lock non-BSP port>)        |
	MOVSI IOS,(BSLCKF)	; Flag to test
	TDNE IOS,PUPSTS(UNIT)	; Already locked?
	 POPJ P,		; Yes, fail
	IORB IOS,PUPSTS(UNIT)	; Lock port, setup IOS
	RETSKP			; Give success return                  |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 69

; Unlock port iff it is a BSP port
;	UNIT/ Pup unit #
;	BSP/ BSP data block pointer (0 if none, see LCKBSQ)
;	IOS/ Status
; Returns +1, Clobbers nothing

ULKBSQ:	JUMPE BSP,CPOPJ##	; Do nothing if not BSP port


; Unlock BSP port
;	UNIT/ Pup unit #
;	IOS/ Status
; Returns +1, Clobbers nothing

ULKBSP:	TLZN IOS,(BSLCKF)	; Clear BSP lock bit
	 BUG(HLT,ULKBSZ,<ULKBSP: Attempt to unlock port not locked>)   |
	EXCH IOS,PUPSTS(UNIT)	; Store updated status word
	AND IOS,[BSWAKF]	; If wakeup pending,
	IORB IOS,PUPSTS(UNIT)	;  be sure bit stays on
	POPJ P,



; Generate BSP error timeout
; Assumes port is locked and ac's setup
; Returns +1
; Clobbers A, B

BSPTMO:	TLON IOS,(BSTIMF)	; Ignore if already timed out
	 PUSHJ P,PUPSTC		; Generate state change interrupt
	POPJ P,



; Awaken BSP input if necessary
; Assumes port is locked and ac's setup
; Returns +1
; Clobbers A, B

WAKBSI:	TLO IOS,(BSINPF)	; Flag input possible now
	HRRE B,PUPPSI(UNIT)	; Get port owner
	AOJGE B,CPOPJ##		; Done if unassigned or assigned to fork
	SIGPBP(NVT)		; Request NVT scan
	POPJ P,


; Awaken BSP output if necessary
; Assumes port is locked and ac's setup
; Returns +1
; Clobbers A, B

WAKBSO:	TLO IOS,(BSOUTF)	; Flag output possible now
	HRRE B,PUPPSI(UNIT)	; Get port owner
	AOJGE B,CPOPJ##		; Done if unassigned or assigned to fork
	MOVEI B,-400001(B)	; Assigned to NVT, get TTY #
	NOSKED			; Dont let dynamic data change         |
	CALL STADYN		; Get dynamic data                     |
	 JRST WAKBS1                                                   |
	CALL PPSOBE		; Any chars to be processed?           |
	 JRST [	SIGPBP(NVT)	; Request NVT scan                     |
		JRST WAKBS1 ]                                          |
WAKBS1:	OKSKED                                                         |
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 70

; Build BSP data block
; Returns +1:  Failed (no room)
;	+2:  Ok, BSP/ pointer to block
; Clobbers A-D, BSP

BLDBSP:	MOVEI B,BSPSIZ		; Size of BSP data block
	PUSHJ P,ASGPFR		; Allocate a block
	 POPJ P,		; Can't, fail
	MOVEI BSP,(A)		; Ok, put ptr in standard ac
	AOS 0(P)		; Preset skip, fall into INIBSP


; Initialize BSP data block
;	BSP/ Data block ptr
; Returns +1 always
; Clobbers A, B

INIBSP:	MOVSI A,-BSPSIZ		; Set AOBJN ptr
	HRLI BSP,A		; Set index register for store
INIBS1:	XCT IBSTAB(A)		; Get an initial value
	MOVEM B,@BSP		; Store in block
	AOBJN A,INIBS1		; Repeat for all
	POPJ P,

; Initialization table
; Each entry loads B with the corresponding initial value

DEFINE X(LOC,INST) <
IFL LOC-<.-IBSTAB>,<PRINTX ?IBSTAB entries out of order>
REPEAT LOC-<.-IBSTAB>,<SETZ B,>
	INST
>

IBSTAB:	X BSPHDR,<MOVE B,[<DETINT*^D1000/10000>B15+BSPSIZ]>
	X BSPTIM,<MOVSI B,RETINT>
	X BSPACT,<MOVE B,TODCLK>
	X BSPDTM,<HRLOI B,377777>
	X BSPITM,<HRLOI B,377777>
	X BSPFTM,<HRLOI B,377777>
	X BSPSTM,<MOVE B,TODCLK>
	X BSPIBQ,<PUSHJ P,INIBSQ>
	X BSPOBQ,<PUSHJ P,INIBSQ>
	X BSPCID,<SETO B,>
	X BSPIAL,<MOVE B,[<MXBSIP>B7+<MXPLEN-MNPLEN>B17+MXBSIB]>
	X BSPSIZ,<>

INIBSQ:	MOVEI B,@BSP
	HRLI B,(B)
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 71

; -----------------------------------------------------------------
;	Pup Finite State Machine (rendezvous, termination)
; -----------------------------------------------------------------

SWAPCD                                                                 |


; Port states

S.CLOS==0	; Closed
S.RFCO==1	; RFC Outstanding
S.LIST==2	; Listening
S.OPEN==3	; Open
S.ENDI==4	; End In
S.ENDO==5	; End Outstanding
S.DALY==6	; Dallying
S.ABOR==7	; Abort

NPSTAT==10	; Number of states
ALLSTT==-1B<NPSTAT-1>  ; Bit mask corresponding to all states


; Events

E.OPNC==0	; OPENF mode 0 or 1 (connect)
E.OPNL==1	; OPENF mode 2 or 3 (listen)
E.OPNN==2	; OPENF mode 4 (no rendezvous)
E.CLSN==3	; Normal CLOSF
E.CLST==4	; CLOSF after timeout
E.RRFC==5	; Received RFC
E.RABT==6	; Received Abort
E.REND==7	; Received End
E.RENR==10	; Received End Reply
E.TIMO==11	; Timeout (for retransmissions)


; Actions

A.NOOP==0	; No action
A.SRF1==1	; Send RFC (initiate connection)
A.SRF2==2	; Send RFC (respond to incoming RFC)
A.OPNC==3	; Open connection
A.SEND==4	; Send End
A.SENR==5	; Send End Reply
A.SABT==6	; Send Abort
A.LERR==7	; Local error (improper locally-generated event)
A.FERR==10	; Foreign error (improper Pup type received)


A.==<S.==0>	; For unused fields in action/transition matrices
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 72

; Routines to generate events
; All assume the port is locked and ac's UNIT, BSP, IOS setup.
; If the event is generated by an incoming Pup, PB points to the
;  packet buffer.


; Routine called from DOBSPI upon receipt of an RFC
;	PB/ Packet buffer pointer
; Returns +1 always
; Clobbers A-D, releases packet buffer always

RCVRFC:	LDB A,PUPLEN		; Get Pup Length
	CAIGE A,MNPLEN+6	; Make sure big enough
	 BUGP(DPR,<RCVRFC: Pup too small>,X)                           |
	PUSHJ P,GTCPRT		; Get Connection Port                  |
	 BUGP(DPR,<RCVRFC: RFC with improper Connection port>,X)       |
	LDB D,PBSSTT		; Get current port state
	CAIN D,S.RFCO		; RFC Out?
	 JRST RCVRF1		; Yes
	CAIN D,S.LIST		; Listening?
	 JRST RCVRF2		; Yes

; Open (or End Out), probably a retransmission
	PUSHJ P,CHKSR1		; See if matches foreign port
	 BUGP(DPR,<RCVRFC: RFC with non-matching Connection Port>,X)   |
	MOVE A,PBHEAD+1(PB)	; Get Pup ID                           |
	LSH A,-4		; Right-justify                        |
	CAME A,BSPCID(BSP)	; Compare to Connection ID             |
	 BUGP(DPR,<RCVRFC: RFC with incorrect ID>,X)                   |
	TLNN IOS,(BSLISF)	; Formerly in listening state?
	 JRST RCVRF4		; No, discard packet and ignore
	JRST RCVRF3		; Yes, go generate event

; RFC Out, ID must match our Connection ID
RCVRF1:	MOVE A,PBHEAD+1(PB)	; Get Pup ID
	LSH A,-4		; Right-justify
	CAME A,BSPCID(BSP)	; Compare to Connection ID
	 BUGP(DPR,<RCVRFC: RFC with incorrect ID>,X)                   |
                                                                       |
; Listening or RFC Out, Source Port must pass address filter           |
RCVRF2:	PUSHJ P,CHKSRC		; Check Source Port                    |
	 BUGP(DPR,<RCVRFC: RFC from incorrect Source Port>,X)          |
RCVRF3:	MOVEI A,E.RRFC		; Ok, generate Received RFC event
	PUSHJ P,PUPFSM
RCVRF4:	PUSHJ P,RELPKT		; Release packet buffer
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 73

; Routine called from DOBSPI upon receipt of an End
;	PB/ Packet buffer pointer
; Returns +1 always
; Clobbers A-D, releases packet buffer always

RCVEND:	MOVEI A,E.REND		; Generate Received End event
	JRST RCVEN1

; Routine called from DOBSPI upon receipt of an End Reply
;	PB/ Packet buffer pointer
; Returns +1 always
; Clobbers A-D, releases packet buffer always

RCVENR:	MOVEI A,E.RENR		; Generate Received End Reply event
RCVEN1:	PUSHJ P,PUPFSM
	PUSHJ P,RELPKT		; Release packet buffer
	POPJ P,


; Routine called from DOBSPI upon receipt of an Abort
;	PB/ Packet buffer pointer
; Returns +1 always
; Clobbers A-D, disposes of packet buffer always

RCVABT:	MOVEI A,E.RABT		; Generate Received Abort event
	PUSHJ P,PUPFSM
	HRRZ A,BSPTIM(BSP)	; See if already have Abort packet
	JUMPN A,RELPKT		; If so, just discard this
	HRRM PB,BSPTIM(BSP)	; Don't have one, store this
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 74

; Routine to step FSM for port
;	A/ Event number
;	C, D/ Arguments for action routine, if appropriate
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
;	IOS/ Port status word
;	PB/ Pointer to incoming packet, if any
; Returns +1
; Clobbers A-D, updates others where appropriate

PUPFSM:	PUSHJ P,PUPFSC		; Do the work
	PUSHJ P,SETPTM		; Set timer appropriately
	POPJ P,

; Enter here from DOBSP only
PUPFSC:	HRLM A,0(P)		; Save event number
	PUSH P,PB		; Save packet buffer ptr if any
	LDB B,PBSSTT		; Get current port state
	LDB A,PFSACT(B)		; Get action index
	XCT EVNACT(A)		; Do action associated with event
	HLRZ A,-1(P)		; Recover event number
	LDB B,PBSSTT		; Get current port state
	LDB A,PFSTRN(B)		; Get successor from transition tbl
	DPB A,PBSSTT		; Store in port status word
	DPB A,PBSSTM		; Store in memory also
	CAIE A,S.CLOS		; Entering Closed or Abort state?
	 CAIN A,S.ABOR
	 TLO IOS,(BSERRF)	; Yes, signal bad state for BSP
	CAIN A,(B)		; State changed?
	 JRST PUPFS2		; No
	MOVE B,TODCLK		; Yes, record time of state change
	MOVEM B,BSPSTM(BSP)
	CAIE A,S.OPEN		; Entering Open state?
	 JRST PUPFS1		; No
	MOVEM B,BSPDTM(BSP)	; Yes, activate data probing
	MOVEM B,BSPATM(BSP)
PUPFS1:	PUSHJ P,PUPSTC		; Generate state change psi
PUPFS2:	POP P,PB		; Restore packet buffer ptr
	LDB A,PBSSTT		; Get new state
	CAIE A,S.RFCO		; RFC or End Outstanding?
	 CAIN A,S.ENDO
	 JRST [	MOVE A,BSPSTM(BSP)  ; Yes, get time of last state change
		PUSHJ P,NXTTIM	; Compute time for next check
		JRST PUPFS3]	; Go set it
	CAIN A,S.DALY		; No, dallying?
	 JRST [	HLRZ A,BSPTIM(BSP)  ; Yes, get retransmission timeout
		IMULI A,5	; Dally this long
		ADD A,TODCLK	; Compute time of next check
		JRST PUPFS3]	; Go set it
	HRLOI A,377777		; Set timer to infinity for other states
PUPFS3:	MOVEM A,BSPFTM(BSP)	; Store time of next check
	POPJ P,


; Byte pointers for accessing action and transition tables
; Indexed by current state #, expects event # in A

PFSACT:
REPEAT NPSTAT,<
	POINT 4,FSMACT(A),4*<.-PFSACT>+3
>


PFSTRN:
REPEAT NPSTAT,<
	POINT 4,FSMTRN(A),4*<.-PFSTRN>+3
>
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 75

; Action table
; Event yields row, current state yields column

DEFINE XX ($1,$2,$3,$4,$5,$6,$7,$8,$9) <
	BYTE(4) A.'$1, A.'$2, A.'$3, A.'$4, A.'$5, A.'$6, A.'$7, A.'$8, A.'$9
>

; Current state						; Event
;	   CLOS RFCO LIST OPEN ENDI ENDO DALY ABOR

FSMACT:	XX SRF1,LERR,LERR,LERR,LERR,LERR,LERR,LERR	; OPNC
	XX NOOP,LERR,LERR,LERR,LERR,LERR,LERR,LERR	; OPNL
	XX NOOP,LERR,LERR,LERR,LERR,LERR,LERR,LERR	; OPNN
	XX NOOP,SABT,NOOP,SEND,SENR,NOOP,NOOP,NOOP	; CLSN
	XX NOOP,SABT,NOOP,SABT,SABT,SABT,NOOP,NOOP	; CLST
	XX FERR,OPNC,SRF2,SRF2,FERR,SRF2,FERR,FERR	; RRFC
	XX FERR,NOOP,FERR,NOOP,NOOP,NOOP,NOOP,NOOP	; RABT
	XX FERR,FERR,FERR,NOOP,NOOP,SENR,SENR,FERR	; REND
	XX FERR,FERR,FERR,FERR,FERR,SENR,NOOP,FERR	; RENR
	XX NOOP,SRF1,NOOP,NOOP,NOOP,SEND,NOOP,NOOP	; TIMO


; Transition table
; Event yields row, current state yields column

DEFINE XX ($1,$2,$3,$4,$5,$6,$7,$8,$9) <
	BYTE(4) S.'$1, S.'$2, S.'$3, S.'$4, S.'$5, S.'$6, S.'$7, S.'$8, S.'$9
>

; Current state						; Event
;	   CLOS RFCO LIST OPEN ENDI ENDO DALY ABOR

FSMTRN:	XX RFCO,RFCO,LIST,OPEN,ENDI,ENDO,DALY,ABOR	; OPNC
	XX LIST,RFCO,LIST,OPEN,ENDI,ENDO,DALY,ABOR	; OPNL
	XX OPEN,RFCO,LIST,OPEN,ENDI,ENDO,DALY,ABOR	; OPNN
	XX CLOS,CLOS,CLOS,ENDO,DALY,ENDO,DALY,CLOS	; CLSN
	XX CLOS,CLOS,CLOS,CLOS,CLOS,CLOS,CLOS,CLOS	; CLST
	XX CLOS,OPEN,OPEN,OPEN,ENDI,ENDO,DALY,ABOR	; RRFC
	XX CLOS,ABOR,LIST,ABOR,ABOR,ABOR,ABOR,ABOR	; RABT
	XX CLOS,RFCO,LIST,ENDI,ENDI,DALY,DALY,ABOR	; REND
	XX CLOS,RFCO,LIST,OPEN,ENDI,CLOS,CLOS,ABOR	; RENR
	XX CLOS,RFCO,LIST,OPEN,ENDI,ENDO,CLOS,ABOR	; TIMO


; Table of actions in event/action matrix

EVNACT:	CAI			; NOOP - No action
	PUSHJ P,SNDIRF		; SRF1 - Send initiating RFC
	PUSHJ P,SNDARF		; SRF2 - Send answering RFC
	PUSHJ P,OPNCON		; OPNC - Open connection
	PUSHJ P,SNDEND		; SEND - Send End
	PUSHJ P,SNDENR		; SENR - Send End Reply
	PUSHJ P,ABORT		; SABT - Send Abort
	PUSHJ P,LCLERR		; LERR - Local error
	PUSHJ P,FORERR		; FERR - Foreign error
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 76

; Action routines
; All have the following calling sequence:
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
;	IOS/ BSP status
;	PB/ Pointer to received packet buffer, if appropriate
; Returns +1 always
; May clobber A-D, PB


; Send initiating RFC

SNDIRF:	MOVEI B,PBHEAD+<MNPLEN+6+3>/4
	PUSHJ P,ASGPKT		; Allocate packet buffer for RFC
	 POPJ P,		; Failed, forget it
	MOVEI A,MNPLEN+6	; Set Pup Length
	DPB A,PUPLEN
	SKIPL A,BSPCID(BSP)	; Connection ID already assigned?
	 JRST SNDIR1		; Yes, use it (retransmission)
	MOVE A,TODCLK		; No, get now in milliseconds
	LSH A,7			; Convert to units of ~8 usec
	PUSHJ P,SETCID		; Set Connection ID
SNDIR1:	LSH A,4			; Left-justify
	MOVEM A,PBHEAD+1(PB)	; Set Pup ID
	PUSHJ P,STCPRT		; Set Connection Port = local port
	MOVEI A,PT.RFC		; Type = RFC
	PUSHJ P,SNDPUP		; Finish up and send the Pup
	 CAI			; Ignore failure
	POPJ P,


; Send answering RFC

SNDARF:	SKIPL BSPCID(BSP)	; Connection parameters already set?
	 JRST SNDAR1		; Yes, bypass this
	MOVE A,PBHEAD+1(PB)	; Get Pup ID from incoming RFC
	LSH A,-4		; Right-justify
	PUSHJ P,SETCID		; Set Connection ID
	LDB A,PPUPDN		; Copy Destination net/host to
	DPB A,PPRTLN		;  local net/host in case wildcard
	LDB A,PPUPDH
	DPB A,PPRTLH
	PUSHJ P,OPNCON		; Set foreign port for connection
SNDAR1:	HRLM PB,0(P)		; Save ptr to received RFC
	MOVEI B,PBHEAD+<MNPLEN+6+3>/4
	PUSHJ P,ASGPKT		; Allocate packet buffer for reply
	 POPJ P,		; Failed, forget it
	HLRZ A,0(P)		; Ok, recover ptr to received RFC
	MOVSI A,PBHEAD(A)	; Copy the header
	HRRI A,PBHEAD(PB)	;  into the answering RFC
	BLT A,PBCONT-1(PB)
	PUSHJ P,SWPPRT		; Swap source and dest ports in RFC
	PUSHJ P,STCPRT		; Set Connection Port = local port
	PUSHJ P,SNDPU1		; Finish up and send the Pup
	 CAI			; Ignore failure
	POPJ P,


; Open connection in response to answering RFC

OPNCON:	PUSHJ P,GTCPRT		; Get Connection Port from RFC
	 BUG(HLT,OPNCOZ,<OPNCON: GTCPRT failed unaccountably>)         |
	PUSHJ P,STFPRT		; Set foreign port for connection
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 77

; Action routines (cont'd)

; Send End

SNDEND:	MOVEI A,PT.END		; Type = End
	JRST SNDEN1		; Jump to common code


; Send End Reply

SNDENR:	MOVEI A,PT.ENR		; Type = End Reply
SNDEN1:	HRLM A,0(P)		; Save type
	MOVEI B,MNPBLN		; Minimum length
	PUSHJ P,ASGPKT		; Allocate packet buffer
	 POPJ P,		; Failed, forget it
	MOVEI A,MNPLEN		; Set Pup Length
	DPB A,PUPLEN
	MOVE A,BSPCID(BSP)	; Get Connection ID
	LSH A,4			; Left-justify
	MOVEM A,PBHEAD+1(PB)	; Set Pup ID
	HLRZ A,0(P)		; Recover Pup Type
	PUSHJ P,SNDPUP		; Finish up and send the Pup
	 CAI			; Ignore failure
	POPJ P,


; Send Abort
;	C/ Abort Code (B0 set => call from monitor)
;	D/ If nonzero, string ptr to Abort Text in caller space

ABORT:	MOVE A,C		; Copy args to proper ac's
	MOVE B,D
	PUSHJ P,SNDABT		; Build and send the Abort
	POPJ P,



; Signal local error

LCLERR:	BUG(CHK,PUPFSZ,<PUPFSM: Improper port state for local event>)  |
	POPJ P,



; Signal foreign error

FORERR:	BUGP(PUP,<PUPFSM: Improper port state for received Pup>,X)     |
	POPJ P,

^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 78

; Get Connection Port parameters from RFC Pup
;	PB/ Packet buffer pointer
; Returns +1:  Error, illegal address
;	+2:  Ok,  A/ Net, B/ Host, C/ Socket, right-justified

GTCPRT:	MOVE A,PBCONT(PB)	; Get net/host/high socket
	LSHC A,-^D28		; Right-justify net
	LSH B,-^D12		; Right-justify host/high socket
	MOVE C,PBCONT+1(PB)	; Get low socket
	LSHC B,-^D16		; Right-justify host
	LSH C,-4		; Concatenate, right-justify socket
	SKIPN A			; Net specified?
	 LDB A,PPUPSN		; No, assume same as Rendezvous
	JUMPE B,CPOPJ##		; Error if zero host
	JUMPE C,CPOPJ##		; Error if zero socket
	RETSKP			; Ok, take success return              |


; Set Connection Port = local port in outgoing RFC
;	PB/ Packet buffer pointer
;	UNIT/ Pup unit #
; Returns +1 always
; Clobbers A

STCPRT:	HLLZ A,PUPLNH(UNIT)	; Get local net/host
	TLNE A,(377B7)		; Make sure fully specified
	TLNN A,(377B15)
	 BUG(HLT,STCPRZ,<STCPRT: Called for wildcard local port>)      |
	MOVEM A,PBCONT(PB)	; Store in Connection Port field
	MOVE A,PUPLSK(UNIT)	; Get local socket
	ROT A,-^D16		; Right-justify high 16 bits
	DPB A,[POINT 16,PBCONT(PB),31]  ; Store in the RFC
	MOVEM A,PBCONT+1(PB)	; Store low 16 bits
	POPJ P,


; Store foreign connection port
;	A/ Net, B/ Host, C/ Socket, right-justified
; Assumes port is locked
; Returns +1
; Clobbers A-D

STFPRT:	SKIPN D,PUPFPT(UNIT)	; Get address table
	 BUG(HLT,STFPRZ,<STFPRT: No address table assigned>)           |
	HRLM A,1(D)		; Store foreign address in table
	HRRM B,1(D)
	MOVEM C,2(D)
	HRLI D,-2		; Now just one address in table
	MOVEM D,PUPFPT(UNIT)
	MOVEI A,0(D)		; Copy pointer to block
	MOVEI B,3		; New size of block
	PUSHJ P,TRMPFR		; Trim it
	POPJ P,


; Set Connection ID
;	A/ Connection ID, right-justified
; Assumes port is locked
; Returns +1

SETCID:	TLZ A,(-1B3)		; Truncate to 32 bits
	MOVEM A,BSPCID(BSP)	; Set Connection ID
	MOVEM A,BSPILW(BSP)	; Init input Byte ID
	MOVEM A,BSPOLW(BSP)	; Init output Byte ID
	MOVEM A,BSPRII(BSP)	; Init receive Interrupt ID
	MOVEM A,BSPSII(BSP)	; Init send Interrupt ID
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 79

; Generate Pup state change interrupt
;	A/ New state
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
; Returns +1 always
; Clobbers A, B

PUPSTC:	HRRE B,PUPPSI(UNIT)	; Get port owner
	JUMPL B,PUPST1		; Jump if not fork
	LDB A,STCPSI		; Get state change PSI channel
	CAIGE A,^D36		; Assigned?
	 PUSHJ P,PSIRQF		; Yes, initiate PSI                    |
PUPST1:	PUSHJ P,WAKBSI		; Awaken fork or NVT processor
	POPJ P,



; Setup to wait for port to enter a specified state (or time out)
;	A/ Bit mask of desired state(s) [STTBTS macro]
; Assumes port is locked
; Returns +1:  Port not yet in specified state, A/ EDISMS argument
;	+2:  Port already in specified state
; Clobbers A, B

WATSTT:	LDB B,PBSSTT		; Get current state
	TDNN A,BITS##(B)	; Already in specified state?
	 TLNE IOS,(BSTIMF)	; Timed out?
	 RETSKP			; Yes, give skip return                |
	HRRI A,STTTST		; No, set scheduler test
	TLO A,(UNIT)		; Set Pup unit index
	POPJ P,			; Non-skip return

RESCD                                                                  |

; Scheduler test for entering specified state(s)
; Arg is state bit mask in B18-26, Pup unit # in B27-35

STTTST:	MOVSI B,(A)		; Copy bit mask
	ANDI A,777		; Isolate Pup unit #
	MOVE C,PUPSTS(A)	; Get status word
	LDB A,PBSSTA		; Get port state
	TDNN B,BITS##(A)	; Now in specified state(s)?
	 TLNE C,(BSTIMF)	; Timeout?
	 JRST 1(D)		; Yes, wakeup
	JRST 0(D)		; No, wait

SWAPCD                                                                 |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 80

; -----------------------------------------------------------------
;	Pup NVT handling
; -----------------------------------------------------------------

SWAPCD                                                                 |

; Background routine to scan for Pup NVT input/output

BSPNVT:	LOCK NVTLCK		; No messing with table
	MOVE B,PUPPAR		; Set to first Pup NVT                 |
BSPNV1:	PUSH P,B		; Save line                            |
	CALL LCKTTY		; Lock tty                             |
	 JRST BSPNV2		; not full tty                         |
	SKIPGE UNIT,TTYPUP(B)	; Assigned?                            |
	 SKIPGE IOS,PUPSTS(UNIT)  ; Yes, port unlocked?                |
	 JRST BSPNV2		; No                                   |
	TLNE IOS,(BSINPF+BSTIMF+BSERRF)  ; Input available or error?   |
	 JRST BSPNV3                                                   |
	TLNN IOS,(BSOUTF)	; Output possible?                     |
	 JRST BSPNV2		; Cant do output                       |
	CALL PPSOBE		; Any output chars to proceess?        |
BSPNV3:	 PUSHJ P,DONVTP		; One of those, service this NVT       |
BSPNV2:	CALL ULKTTY		; Unlock tty                           |
	POP P,B			; Restore static line                  |
	AOBJN B,BSPNV1		; Any more lines ?                     |
	UNLOCK NVTLCK
	POPJ P,			; Yes, done


; Do Pup NVT processing for one line
;	B/ TTY Line #
;	UNIT/ Pup unit #
; Returns +1 always
; Clobbers A, C, D, BSP, IOS;  preserves B

DONVTP:	LOCK PRTLCK		; Lock out changes to port table
	PUSHJ P,LCKBSA		; Attempt to lock the port
	 JRST [	UNLOCK PRTLCK	; Failed, forget it
		POPJ P,]
	UNLOCK PRTLCK		; Ok, unlock table
	MOVSI A,(HUREQF)	; Is a hangup occuring?                |
	TDNN A,TTYPUP(B)                                               |
	TLNE IOS,(BSERRF+BSTIMF)  ; Errors?
	 JRST DONVTE		; Yes, go handle

; Note that doing input first and then output generally ensures
;  that echos will be transmitted immediately
	TLNE IOS,(BSINPF)	; Input pending?
	 PUSHJ P,DONVTI		; Yes, process it
	CALL PPSOBE		; Output pending?                      |
	 PUSHJ P,DONVTO		; Yes, process it

	LDB A,PBSSTT		; Get current port state
	CAIN A,S.OPEN		; Still open?
	 JRST ULKBSP		; Yes, just unlock port and return

; Here if port no longer open or timed out, kill the connection
DONVTE:	PUSHJ P,CLPNVT		; Initiate close of connection
	 PUSHJ P,ULKBSP		; Have to wait, unlock port and quit
	POPJ P,			; Connection gone, no need to unlock
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 81

; Process NVT input
;	B/ TTY Line #
;	UNIT/ Pup unit #
; Assumes port is locked
; Returns +1 always
; Clobbers A, C, D, PB;  preserves B

DONVTI:	LDB A,PNVSTT		; Get current NVT input state
	JRST @NVTSTD(A)		; Dispatch on state

; Dispatch table for current NVT state
NVTSTD:	NVTDAT		; (0) Normal data
	NVTMRK		; (1) Mark pending
	NVTSYN		; (2) Sync in progress

; Dispatched-to code should jump to one of these labels when
;  it can't do any more processing
NVTST0:	JSP A,DONVTX		; Set state to 0 (normal data)
NVTST1:	JSP A,DONVTX		; Set state to 1 (Mark pending)
NVTST2:	JSP A,DONVTX		; Set state to 2 (Sync in progress)

DONVTX:	SUBI A,NVTST0+1		; Convert pc to state index
	DPB A,PNVSTT		; Store new state
	POPJ P,			; Return from DONVTI


; Dispatch here to process normal data
NVTDAT:	CALL PUPIFL		; Is input full?                       |
	 JRST NVTST0		; Yes, stop (state _ 0)
	PUSHJ P,GNVBYT		; No, get next byte
	 JRST NVTST0		; No more (state _ 0)
	 JRST NVTMR1		; Mark encountered
	HRLI UNIT,(B)		; B clobbered by TTCHI
	PUSH P,UNIT		; =5, clobbered by TTCHI
	PUSH P,IOS		; =6
	SETZ IOS,		; Would you believe this is an arg?
	NOSKED			; TTCHI requires this
	HRRZ B,1(B)		; Get static line number               |
	PUSHJ P,TTCHI##		; Stuff character in input buffer
	OKSKED
	POP P,IOS		; Restore ac's
	POP P,UNIT
	HLRZ B,UNIT
	JRST NVTDAT		; Repeat


; Dispatch here when sync in progress
; Also get here after processing Mark
NVTSYN:	LDB A,PSYNCT		; Check sync counter
	JUMPE A,NVTDAT		; Resume processing if now balanced
	CAIE A,SYNCNT/<SYNCNT&-SYNCNT>  ; Skip if -1 (waiting for Int)
NVTSY1:	 PUSHJ P,GNVBYT		; Scanning for DM, get next byte
	 JRST NVTST2		; No more (state _ 2)
	 JRST NVTMR1		; Mark encountered, process it
	JRST NVTSY1		; Normal data, flush it


; Dispatch here to process pending Mark
NVTMRK:	LDB A,PNVMRK		; Recover the Mark byte

; Here when Mark first encountered, A/ Mark byte
NVTMR1:	CAIL A,NNVMRK		; See if in range
	 JRST NVTSYN		; No, ignore
	JRST @MRKDSP(A)		; Yes, perform operation

; Dispatch table for received Mark types
; Code should finish by going to NVTST1 if must defer,
;  NVTSYN normally (to check sync count)
MRKDSP:	NVTSYN		; (0) Unassigned
	NVTDM		; (1) Data Mark
	NVTLW		; (2) Line Width
	NVTPL		; (3) Page Length
	NVTTYP		; (4) Terminal Type
	NVTTMK		; (5) Timing Mark
	NVTTMR		; (6) Timing Mark Reply

NNVMRK==.-MRKDSP	; Number of Mark types recognized
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 82

; DONVTI (cont'd)
; Code to process specific Mark types

; Process Data Mark (DM, Mark type 1)
NVTDM:	MOVEI A,SYNTMO		; Reset sync timer
	DPB A,PSYNTM
	LDB A,PSYNCT		; Get sync count
	SUBI A,1		; DM counts as -1
	DPB A,PSYNCT		; Put it back
	PUSHJ P,TTCIBF##	; Clear TTY input buffer
	JRST NVTSYN		; Go reconsider state

; Set Line Width (Mark type 2)
NVTLW:	PUSHJ P,GNVBYT		; Get argument byte
	 JRST NVTST1		; Can't, defer (state _ 1)
	 JRST NVTMR1		; Another Mark, ignore this
	CAIL A,10		; Range check (see .STPAR in TTYSRV)
	 CAIL A,200
	 SETZ A,		; Use default if out of bounds
	CALL PUPWID		; Store in TTY status                  |
	JRST NVTSYN		; Done

; Set Page Length (Mark type 3)
NVTPL:	PUSHJ P,GNVBYT		; Get argument byte
	 JRST NVTST1		; Can't, defer (state _ 1)
	 JRST NVTMR1		; Another Mark, ignore this
	CAIL A,10		; Range check (see .STPAR in TTYSRV)
	 CAIL A,200
	 MOVEI A,^D66		; Use default if out of bounds
	CALL PUPLN		; Store in TTY status                  |
	JRST NVTSYN		; Done

; Set Terminal Type (Mark type 4)
NVTTYP:	PUSHJ P,GNVBYT		; Get argument byte
	 JRST NVTST1		; Can't, defer (state _ 1)
	 JRST NVTMR1		; Another Mark, ignore this
	CALL PUPSTP		; Set terminal type                    |
	JRST NVTSYN		; Done

; Timing Mark (Mark type 5)
NVTTMK:	HRRE A,TTFORK##(B)	; Is there a fork blocked for input?
	JUMPL A,NVTTM1
	HRLM B,0(P)		; Yes, save line #
	MOVEI A,6		; Generate immediate timing mark reply
	PUSHJ P,SNDAMA
	 JRST [	HLRZ B,0(P)	; Can't, defer processing of timing mark
		JRST NVTST1]	; (State _ 1)
	HLRZ B,0(P)		; Ok, recover line #
	JRST NVTSYN		; Done

; Here if no fork waiting.  Increment count so as to cause reply
; to be generated when somebody exhausts the input buffer.
NVTTM1:	LDB A,PTMKCT		; Get current count of timing marks
	ADDI A,1		; Increment it
	DPB A,PTMKCT
	JRST NVTSYN		; Done

; Timing Mark Reply (Mark type 6)
NVTTMR:	MOVSI A,(TMKPNF)	; Clear timing mark pending flag
	ANDCAM A,TTYPUP(B)	; This wakes up anywone waiting
	JRST NVTSYN		; Done
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 83

; Get input byte for NVT
;	B/ TTY Line #
; Assumes port is locked and ac's setup
; Returns +1:  Input exhausted
;	+2:  Mark encountered, A/ the byte (also stored via PNVMRK)
;	+3:  Normal, A/ the byte
; Clobbers A, C-D, PB;  does not clobber B

GNVBYT:	HLRZ PB,BSPCUR(BSP)	; Get current buffer ptr if any
	JUMPN PB,GNVBY2		; Jump if already have a buffer
GNVBY1:	HRLM B,0(P)		; Save line #
	PUSHJ P,GETBSP		; Get the next packet
	 JRST [	HLRZ B,0(P)	; No more, recover line #
		POPJ P,]	; Return +1
	HLRZ B,0(P)		; Recover line #
	LDB A,PUPTYP		; Get Pup Type
	CAIE A,PT.MRK		; Mark?
	 CAIN A,PT.AMA		; AMark?
	 JRST [	ILDB A,PBBSID(PB)  ; Yes, get the byte
		DPB A,PNVMRK	; Save away in case need to defer
		SETZM PBBSBC(PB)  ; No more bytes in this packet
		RETSKP	]	; Return +2                            |

GNVBY2:	SOSGE PBBSBC(PB)	; Count down bytes in packet
	 JRST GNVBY1		; Exhausted, try next packet
	ILDB A,PBBSID(PB)	; Get the next byte
	JRST SK2RET##		; Return +3
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 84

; Do NVT output processing for one line
;	B/ TTY Line #
; Assumes port is locked
; Returns +1 always
; Clobbers A, C, D, PB;  preserves B

DONVTO:	CHKSTT <OPEN>		; Connection still open?
	 POPJ P,		; No, do nothing
	HRLM B,0(P)		; Preserve line #
	PUSHJ P,CHKBSO		; Check for BSP output possible
	 JRST [	HLRZ B,0(P)	; Not possible, recover line #
		POPJ P,]	; Return having done nothing
	PUSHJ P,BLDDAT		; Build packet of appropriate size
	 JRST [	HLRZ B,0(P)	; Failed to allocate, recover line#
		POPJ P,]	; Return having done nothing
	MOVEM B,PBBSID(PB)	; Store byte pointer
	HLRZ B,0(P)		; Recover line #
	NOSKED			; No races

; Pack bytes from output buffer                                        |
	CALL PUPACT		; Set line to active                   |
	PUSH P,A		; Save remaining count                 |
DONOV3:	PUSH P,B		; Save dynamic data                    |
	CALL TTSND		; Get the char                         |
	POP P,B			; Restore data                         |
	CALL PUPTAC		; Line still active?                   |
	 JRST DONOV5		; No                                   |
	IDPB C,PBBSID(PB)	; Store in packet                      |
	SOSLE 0(P)		; Any space left in packet?            |
	 JRST DONOV3		; Yes                                  |
	CALL PUPIAC		; Set line to inactive                 |
                                                                       |
; Finish up and send the packet                                        |
                                                                       |
DONOV5:	POP P,A			; Pop stack                            |
	OKSKED                                                         |
	MOVE A,PBBSID(PB)	; Get ptr to last byte stored
	PUSHJ P,DMPBSP		; Finish up and send the packet
	HLRZ B,0(P)		; Recover line #
	POPJ P,			; Done
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 85

; Routine called upon receipt of an Interrupt for a port
;  attached to an NVT
;	B/ Line #
;	PB/ Packet buffer pointer
; Assumes port is locked
; Returns +1 always
; Clobbers A-D

NVTINT:	LOCK NVTLCK		; No messing with NVT table
	MOVEI A,SYNTMO		; Reset sync timer
	DPB A,PSYNTM
	LDB A,PSYNCT		; Get sync count (Int's - DM's)
	AOS A			; Interrupt counts as +1
	DPB A,PSYNCT		; Put it back
	JUMPE A,[UNLOCK NVTLCK	; Done if Ints and DMs now balance
		JRST WAKBSI]
	LDB A,PNVSTT		; Get current input state
	SKIPN A			; Normal input?
	 MOVEI A,2		; Yes, change to sync in progress
	DPB A,PNVSTT		; Put it back
	UNLOCK NVTLCK
	PUSHJ P,TTCIBF##	; Clear TTY input buffer
	PUSHJ P,WAKBSI		; Make NVT processor notice change
	POPJ P,			; Done



; Background routine to time out syncs
; Called periodically from Pup background process
; Returns +1
; Clobbers A-D, UNIT, BSP, IOS

SYNCHK:	LOCK NVTLCK		; No messing with NVT table
	MOVE B,PUPPAR		; Prepare to scan all NVT's            |
SYNCH1:	PUSH P,B		; Save static line number              |
	CALL LCKTTY		; Lock tty, get dynamic data           |
	 JRST SYNCH3		; Not really there                     |
	SKIPGE UNIT,TTYPUP(B)	; NVT assigned?                        |
	 TLNN UNIT,(SYNCNT)	; Yes, sync in progress?
	 JRST SYNCH3		; No
	LDB A,PSYNTM		; Yes, get timer
	SOJL A,[SETZ A,		; If timed out, clear sync count
		DPB A,PSYNCT
		UNLOCK NVTLCK	; Prevent deadlocks!
		PUSH P,B	; Preserve line #
		PUSHJ P,LCKBSP	; Lock port
		PUSHJ P,WAKBSI	; Make NVT processor notice change
		PUSHJ P,ULKBSP	; Unlock port
		POP P,B
		LOCK NVTLCK	; Re-lock NVT table
		JRST SYNCH3]
	DPB A,PSYNTM		; Not timed out yet, put it back
SYNCH3:	CALL ULKTTY		; Unlock tty                           |
	POP P,B			; Restore static line                  |
	AOBJN B,SYNCH1		; Any more NVTs?                       |
	UNLOCK NVTLCK
	SIGPBP(NVT)		; Scan NVT's at least this often
	MOVEI A,SYNCHI		; Get sync check interval
	ADD A,TODCLK		; Compute time of next check
	MOVEM A,SYNTIM
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 86

; Assign Pup NVT
;	UNIT/ Pup unit #
; Returns +1:  Failed, none free
;	+2:  B/ Line #
; Clobbers A, B

ASPNVT:	MOVE B,PUPPAR		; Prepare to scan all NVT's            |
	LOCK(NVTLCK,,HIQ)	; Lock the table                       |
	NOSKED                                                         |
ASPNV1:	PUSH P,B		; Keep static line number              |
	CALL STADYN		; See if active line                   |
	 JUMPE B,ASPNV4		; Line totally inactive                |
ASPNV2:	POP P,B			; Restore line                         |
	AOBJN B,ASPNV1		; Keep trying                          |
	OKSKED                                                         |
	UNLOCK(NVTLCK,RESIDENT,HIQ)  ; Fail return if none available   |
	POPJ P,                                                        |
ASPNV4:	HRRZ T2,0(P)		; Get static line number               |
	CALL TTYASC		; Assign the line                      |
	 JRST ASPNV2		; Couldnt, try another line            |
	CALL LCKTTY		; Lock the tty                         |
	 BUG(HLT,ASPNVZ,<ASPNVT: Failure of LCKTTY>)                   |
	OKSKED                                                         |
	CALL PUPTIN		; Say its permanent                    |
	MOVEI A,(UNIT)		; Found one, copy Pup index            |
	HRLI A,(1B0)		; Set assignment flag                  |
	MOVEM A,TTYPUP(B)	; Assign NVT                           |
	HRRZ A,0(P)		; Get static line number               |
	MOVEI A,400000(A)	; Point port to NVT                    |
	HRROM A,PUPPSI(UNIT)	;  and clear interrupt assignments
	UNLOCK(NVTLCK,RESIDENT,HIQ)  ; Unlock table
	MOVEI B,(B)		; Clear lh of line #
	PUSHJ P,TTCOBI##	; Clear output buffer
	PUSHJ P,TTCIBF##	; Clear input buffer
	CALL ULKTTY		; Unlock tty                           |
	POP P,B			; Get back static line number          |
	RETSKP			; Success return                       |


; Close Pup NVT
;	B/ Line #
; Assumes NVTLCK and port are locked and UNIT, BSP, IOS setup
; Returns +1:  Port not yet closed (try again later)
;		Wait test on TTYPUP=0 in A                             |
;	+2:  Now closed, port deleted, NVT released                    |
; Clobbers A, C-D, PB;  preserves B                                    |
                                                                       |
CLPNVT:	SKIPN TTYPUP(B)		; Currently assigned?                  |
	 RETSKP			; Yes, succeed                         |
	HRLM B,0(P)		; Preserve line #                      |
	PUSHJ P,TTCIBF##	; Clear TTY input buffer
	PUSHJ P,TTCOBI##	; Clear TTY output buffer
	MOVSI A,(HUREQF)	; Hangup requested flag
	TDNN A,TTYPUP(B)	; Already done?
	SKIPGE TTFORK##(B)	; Is there a job attached?
	 JRST CLPNV1		; Already done or no job, bypass
	IORM A,TTYPUP(B)	; Yes, remember we did it
	PUSH P,UNIT		; =5, clobbered by NVTCOF
	HRRZ B,1(B)		; Get static line number               |
	PUSHJ P,NTYCF1##	; Initiate carrier-off psi             |
	POP P,UNIT		;  (NVTCOF also clobbers B)
CLPNV1:	LDB A,PBSSTT		; Get current state
	CAIE A,S.CLOS		; Now closed or aborted?
	 CAIN A,S.ABOR
	 JRST CLPNV5		; Yes, just flush port
	TLNE IOS,(BSTIMF)	; Timed out?
	 JRST [	MOVEI A,E.CLST	; Yes, generate CLOSF(T) event
		HRROI C,0	; Need registered code ************
		HRROI D,[ASCIZ /Connection timed out/]
		JRST CLPNV3]
	CHKSTT <OPEN,ENDI>	; No, state ok for BSP output?
	 JRST CLPNV2		; No
	PUSHJ P,FRCBSP		; Yes, force the byte stream
	PUSHJ P,CHKBOQ		; Any unacknowledged output?
	 JRST CLPNV6		; Yes, have to wait                    |
CLPNV2:	MOVEI A,E.CLSN		; Generate CLOSF(N) event              |
CLPNV3:	PUSHJ P,PUPFSM		; Activate the FSM                     |
	CHKSTT <CLOS,ABOR>	; Now closed or aborted?               |
	 JRST CLPNV6		; No, have to wait                     |
CLPNV5:	PUSHJ P,FLSBSQ		; Yes, flush all queues                |
	SKIPE PUPOBC(UNIT)	; Any pending output on port queue?    |
	 JRST CLPNV6		; Yes, have to wait                    |
	PUSHJ P,DELPRT		; No, delete the port                  |
	HLRZ B,0(P)		; Recover line #                       |
	CALL PUPTUN		; Turn off perm bit                    |
	SETZM TTYPUP(B)		; Release the NVT                      |
	RETSKP			; Done                                 |
                                                                       |
CLPNV6:	HLRZ B,0(P)		; Have to wait                         |
	MOVE A,[1B0!TTPPWT]	; Get wait test                        |
	RET                                                            |
                                                                       |
RESCD                                                                  |
; Wait test for Pup being closed so block can be deassigned            |
                                                                       |
TTPPWT:	MOVE B,A		; Get static line number               |
	CALL STADYN		; Get dynamic block                    |
	 JRST 1(D)		; No longer there, succeed             |
	SKIPN TTYPUP(B)		; pup nvt not closed                   |
	 JRST 1(D)		; =0 -> closed                         |
	JRST 0(D)                                                      |
SWAPCD                                                                 |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 87

; Pup NVT routines called from TTYSRV

; Clear TTY output buffers for Pup NVT
;	B/ Line #
; Returns +1 always
; Clobbers A, C-D;  preserves B, UNIT, BSP, IOS

PNVCOB::PUSHJ P,CHKPNV		; Check and lock NVT                   |
	 POPJ P,		; No port attached, do nothing
	TLNE IOS,(BSTIMF+BSERRF)  ; Any errors?
	 JRST PNVCO2		; Yes, forget it
	HRROI A,0		; Need registered code ************
	HRROI B,[ASCIZ /Sync/]
	PUSHJ P,SNDINT		; Send Interrupt
	 JRST [	PUSHJ P,ULKNVT	; Can't, undo all locks
		CALL TTYDIS	; Unlock tty if it doesnt come back    |
		MDISMS		; Wait until can send Interrupt        |
		CALL TTYAWK	; Remove entry                         |
		JRST PNVCOB]	; Try again
PNVCO1:	MOVEI A,1		; Mark type = 1 (DM)
	PUSHJ P,SNDAMA		; Send AMark
	 JRST [	NOINT		; Can't, lock out PSIs while waiting
		PUSHJ P,ULKNVT	; Undo all locks
		MDISMS		; Wait until can send Mark             |
		PUSHJ P,CHKPNV	; Lock everything again                |
		 JRST [	OKINT	; Port went away, give up
			POPJ P,]
		OKINT
		TLNE IOS,(BSTIMF+BSERRF)  ; Any errors?
		 JRST PNVCO2	; Yes, forget it
		JRST PNVCO1]	; Try again to send Mark
PNVCO2:	PUSHJ P,ULKNVT		; Unlock
	POPJ P,


; Dismiss until output buffer empty, called from TTDOBE
;	B/ Line #
; Returns +1 always
; Clobbers A, C-D;  preserves B, UNIT, BSP, IOS

PNVDOB::PUSHJ P,CHKPNV		; Check and lock NVT                   |
	 POPJ P,		; No port attached, do nothing
	TLNE IOS,(BSTIMF+BSERRF)  ; Any errors?
	 JRST [	PUSHJ P,ULKNVT	; Yes, forget it
		POPJ P,]
	MOVEI A,5		; Mark type = 5 (Timing Mark)
	PUSHJ P,SNDAMA		; Send AMark
	 JRST [	PUSHJ P,ULKNVT	; Can't, undo locks
		CALL TTYDIS	; Unlock tty if this doesnt return     |
		MDISMS		; Wait until can send Mark             |
		CALL TTYAWK	; Remove entry to unlock tty           |
		JRST PNVDOB]	; Try again
	MOVE B,0(P)		; Recover line #
	MOVSI A,(TMKPNF)	; Set timing mark pending flag
	IORM A,TTYPUP(B)
	PUSHJ P,ULKNVT		; Unlock, go OKINT
	MOVEI A,PNVDBT		; Set scheduler test
	HRLI A,(B)		; This line
	CALL TTYDIS		; Become interruptable                 |
	MDISMS			; Wait until Timing Mark Reply received|
	CALL TTYAWK		; Relock TTY                           |
	POPJ P,                                                        |
                                                                       |
RESCD                                                                  |

; Scheduler test for timing mark not outstanding
; Arg is line #

PNVDBT:	MOVSI B,(TMKPNF)	; Timing mark pending?
	TDNN B,TTYPUP(A)
	 JRST 1(D)		; No, wakeup
	MOVE B,A		; Yes, see if input buffer is full
	JRST PUPDFL		; Wakeup if input buffer full          |
                                                                       |
SWAPCD                                                                 |
^L                                                                     |


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 88

; Hang up Pup NVT line, i.e. close connection, release NVT             |
;	B/ Line #                                                      |
; Returns +1 with wait test in ac1 if not completed                    |
;           +2- succeded                                               |
; Clobbers A, C-D;  preserves B, UNIT, BSP, IOS                        |
                                                                       |
PNVCLZ::PUSH P,B                                                       |
	CALL LCKTTY		; Lock tty                             |
	 JRST PNVCL9                                                   |
	PUSHJ P,CHKPNV		; Check and lock NVT                   |
	 JRST PNVCL9		; No port attached, do nothing         |
	PUSHJ P,CLPNVT		; Initiate close                       |
	 JRST PNVCL8		; Must wait return                     |
	PUSHJ P,ULKNV2		; Now closed, port gone                |
PNVCL9:	CALL ULKTTY		; Unlock TTy                           |
	POP P,B			; Restore line nbr                     |
	RETSKP                                                         |
                                                                       |
PNVCL8:	PUSHJ P,ULKNVT		; Not finished yet, unlock             |
	CALL ULKTTY		; Unlock tty                           |
	POP P,B                                                        |
	RET			 ; Try again later                     |
                                                                       |
                                                                       |
RESCD                                                                  |

; Awaken Pup NVT processor (called from TCI and TCOUT)
;	B/ Line #
; Returns +1 always
; Clobbers A

PNVWAK::SKIPL TTYPUP(B)		; Is there a port attached?
	 JRST TTCOBI##		; No, flush output and return
	PUSH P,A		; Yes, protect clobbered ac
	SIGPBP(NVT)		; Request NVT scan
	POP P,A
	POPJ P,


; Routine called when TTY input buffer becomes empty (or is cleared)
;	B/ Line #
; Returns +1 always
; Clobbers nothing

PNVIBE::CALL PNVWAK		; Wakeup background                    |
	PUSH P,A		; Save an ac                           |
	LDB A,PTMKCT		; Get count of timing marks pending    |
	JUMPE A,PNVIB3		; Jump if none                         |
PNVIB0:	SKIPN NSKED		; Make sure not NOSKED                 |
	 PUSHJ P,CHKPNV		; Check and lock NVT                   |
	  JRST PNVIB3		; No port attached, do nothing
	CHKSTT <OPEN,ENDI>	; Port in good state for output?
	 JRST PNVIB2		; No, do nothing
	LDB A,PTMKCT		; Yes, get count of marks pending
	JUMPE A,PNVIB2		; Jump if none
PNVIB1:	MOVEI A,6		; Mark type = Timing Mark Reply
	PUSHJ P,SNDAMA		; Try to send AMark
	 JRST [	PUSHJ P,ULKNVT	; Can't, unlock NVT
		CALL TTYDIS	; Become interruptable                 |
		MDISMS		; Wait until can send Mark             |
		CALL TTYAWK	; Lock tty again                       |
		JRST PNVIB0]	; Try again
	MOVE B,0(P)		; Recover line #
	LDB A,PTMKCT		; Decrement timing mark count
	SOSL A
	 DPB A,PTMKCT
	JUMPG A,PNVIB1		; Repeat if more timing marks pending
PNVIB2:	PUSHJ P,ULKNVT
PNVIB3:	POP P,A
	POPJ P,

SWAPCD                                                                 |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 89

; Check and lock Pup NVT and save ac's (for TTY level routines)
;	B/ Line #
; Returns +1:  Not attached to Pup port
;	+2:  Ok, NVT table and port locked and UNIT, BSP, IOS setup
; The +2 return is made at a stack level deeper than the call.
; B is saved at 0(P).  Return must be via ULKNVT
; Clobbers A

CHKPNV:	CALL PUPCTY		; Consistency check                    |
	 BUG(HLT,CHKNVZ,<CHKPNV: Line # not Pup NVT>)                  |
	EXCH UNIT,0(P)		; Save vulnerable ac's
	PUSH P,BSP
	PUSH P,IOS
	PUSH P,PB
	PUSH P,B
	PUSH P,UNIT		; Put return pc on top
CHKNV1:	NOINT			; Protect locks
	LOCK(NVTLCK,,HIQ)	; Lock the NVT table
	SKIPL UNIT,TTYPUP(B)	; Get and check linkage
	 JRST ULKNV2		; Not attached to Pup port
	LOCK PRTLCK		; Ok, lock port table
	PUSHJ P,LCKBSA		; Attempt to lock port
	 JRST [	UNLOCK PRTLCK	; Can't, unlock port table
		UNLOCK(NVTLCK,RESIDENT,HIQ)  ; Avoid deadlocks
		OKINT
		MOVSI A,(UNIT)	; Set scheduler test
		HRRI A,BSLCKT
		CALL TTYDIS	; Become interuptable                  |
		MDISMS		; Wait until port unlocked             |
		CALL TTYAWK	; Lock tty again                       |
		JRST CHKNV1]	; Try again                            |
	UNLOCK PRTLCK		; Ok, unlock port table                |
	RETSKP			; Skip return, NVT locked              |
                                                                       |
                                                                       |
; Unlock Pup NVT and restore AC's                                      |
; UNIT, BSP, IOS setup from previous call to CHKPNV                    |
; Returns +1, restores B, UNIT, BSP, IOS

ULKNVT:	PUSHJ P,ULKBSP		; Unlock port

; Enter here if port wasn't locked (or has been deleted)
ULKNV2:	UNLOCK(NVTLCK,RESIDENT,HIQ)  ; Unlock NVT table
	OKINT
	POP P,UNIT		; Pop off return pc
	POP P,B			; Restore saved ac's
	POP P,PB
	POP P,IOS
	POP P,BSP
	EXCH UNIT,0(P)		; Restore UNIT, put back pc
	POPJ P,			; Return
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 90


; -----------------------------------------------------------------
;	Pup Interrupt Routines
; -----------------------------------------------------------------


RESCD                                                                  |
                                                                       |
; Pup input interrupt service                                          |
                                                                       |
;RS CURIPB		; Pointer to current input packet buffer       |
;RS PUPFII		; Count of false input interrupts              |
;RS PUPNFI		; Count of times we had no free input buffers  |
                                                                       |
PISC5::                                                                |
PUPISV::XWD PUPSVR,.+1                                                 |
	CLSB PUPCHN                                                    |
	MOVEM P,PUPACS+17	; Save P                               |
	MOVE P,[0,,PUPACS]	; Save A-UNIT                          |
	BLT P,PUPACS+16                                                |
	MOVE P,PPSTKP		; Setup stack                          |
	MOVE A,XPUPIW		; Find which lines need service        |
PUPIS4:	JFFO A,.+2		; Jump if none need service            |
	JRST PUPIS3                                                    |
	ANDCM A,BITS(B)		; Clear the bit                        |
	PUSH P,A		; Save remaining lines                 |
	PUSH P,B                                                       |
	CAILE B,10		; Valid line number?                   |
	 BUG(HLT,PUPIV1,<PUPISV: Bad line requesting service>)         |
	SKIPN A,XPUPIB(B)	; See if packet being input            |
	 JRST PUPIS1		; No, just start input                 |
	JUMPG A,PUPIS5		; Check for next line                  |
	MOVE PB,CURIPB(B)	; Ok, get packet buffer ptr            |
	PUSHJ P,PUPINP		; Process input Pup

; Handler returns via POPJ when done with the packet.
; Now setup to start reading next packet
PUPIS1:	MOVEI A,FREIBQ		; Header of free input buffer queue
	PUSHJ P,REMOBQ		; Remove first free input buffer
	 JRST [	AOS PUPNFI	; Queue empty, count occurrences
		MOVE B,0(P)                                            |
		SETZM XPUPIB(B)	; Shut off input                       |
		JRST PUPIS2]	; Request assignment, dismiss interrupt|
	SOS FREIBN		; Got one, decrement free count        |
	MOVE B,0(P)                                                    |
	MOVEM PB,CURIPB(B)	; Save packet buffer ptr               |
	MOVEI A,(PB)		; Make length,,address                 |
	HRL A,0(A)                                                     |
	MOVEM A,XPUPIB(B)	; Store for NVIO                       |
PUPIS5:	MOVEI A,BITS(B)		; Get requesting bit                   |
	ANDCAM A,XPUPIW		; Done with this line                  |
PUPIS2:	POP P,B                                                        |
	POP P,A			; Restore flag bits                    |
	JUMPN A,PUPIS4		; Any more lines to do?                |
PUPIS3:	SIGPBP(ASG,<MOVE B,FREIBN ; Request buffer assignment          |
		CAIGE B,MINFIB>)  ;  if below minimum level            |
	JRST PUPOSV		; Check Output                         |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 91

; Routine to process input Pup
;	PB/ Packet Buffer pointer
; Returns +1 always
; Clobbers A-D, disposes of input Pup always

; Check for reasonable Pup Length
PUPINP:	LDB A,PPBPRT		; See if routing pkt                   |
	JUMPN A,PUPIN6		; yes                                  |
	LDB A,PUPLEN		; Get Pup Length field                 |
	CAIL A,MNPLEN		; Check for legal length               |
	CAILE A,MXPLEN                                                 |
	 BUGP(DPR,<PUPINP: Pup Length out of bounds>,X)                |
	ADDI A,1		; Round to 16 bit boundary             |
	TRZ A,1                                                        |
	LDB B,PPBPHS		; Get actual # words NVIO gave us      |
	CAIE A,(B)		; Same?                                |
	 BUGP(DPR,<PUPINP: Packet size inconsistency>,X)               |

; Check for reasonable physical source network
	LDB C,PPBPHN		; Get phys source network
	CAIL C,1		; Check bounds
	CAILE C,NPNETS
	 BUGP(DPR,<PUPINP: Bad physical source network number>,X)      |

; Reject packet if it claims to be from host zero
	LDB C,PPUPSH		; Get Pup source host
	SKIPN C
	 BUGP(DPR,<PUPINP: Bad Pup source host number>,X)              |

; Default zero network fields to the physical source network
	LDB A,PPUPSN		; Get Pup source network
	JUMPN A,PUPIN1		; Src net = 0?
	LDB A,PPBPHN		; Yes, src net _ phys src net
	MOVE B,PPUPSN
	PUSHJ P,UPDCKS		; Update src net and fix checksum
PUPIN1:	LDB A,PPUPDN		; Get Pup destination network
	JUMPN A,PUPIN2		; Dst net = 0?
	LDB A,PPBPHN		; Yes, dst net _ phys src net
	MOVE B,PPUPDN
	PUSHJ P,UPDCKS		; Update dst net and fix checksum
	LDB A,PPUPDN		; Recover dst net for next check

; Check for destination = Maxc
PUPIN2:	CAIL A,1		; Check for legal destination net
	CAILE A,NPNETS
	 JRST PUPIE1		; Unknown, give error and discard
	HRRZ C,PUPROU-1(A)	; Get Maxc address on dest net
	LDB B,PPUPDH		; Get Pup destination host
	CAIE B,(C)		; Pup destination = Maxc?
	 JUMPN B,GATEWY		; No, pass Pup to gateway processor

; Destination is Maxc (or broadcast), lookup destination port.
; Note that broadcast Pups will match only host-wildcard ports
	MOVE A,PBHEAD+2(PB)	; Get dst net/host and high socket
	LSH A,-4		; Right-justify high socket
	MOVE B,PBHEAD+3(PB)	; Get low dst socket
	LSHC A,-^D16		; Concatenate high and low socket
	LSH B,-4		; Right-justify dst socket
	LSH A,^D20		; Left-justify dst net/host
	PUSHJ P,PRTLUK		; Lookup local port, set UNIT
	 JRST PUPIE2		; Not found, give error and discard
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 92

; PUPINP (cont'd)

; Found destination port
; Check for requested random discard
	PUSHJ P,DSCRAN		; Want to discard packet?
	 JRST RELPBI		; Yes, do so

; Check for exceeding maximum port input buffer queue length
	LDB A,PUPLEN		; Get Pup Length (bytes)
	ADDI A,4*PBHEAD+3	; Convert to words, add overhead
	LSH A,-2
	PUSHJ P,CHKIQL		; Check for exceeding maximum
	 JRST PUPIE3		; Overflowed, give error and discard

; Append Pup to port input buffer queue
	PUSHJ P,TRMLPB		; Trim packet buffer to size of Pup
	HRRZ A,PBSIZE(PB)	; Get size of trimmed block
	HRLI A,1		; One new buffer
	ADDM A,PUPIBC(UNIT)	; Add to total for port
	MOVEI A,PUPIBQ(UNIT)	; Get adr of input queue header
	PUSHJ P,APPIBQ		; Append Pup to queue

; Give Pup-Received interrupt to fork, if armed
	HRRE B,PUPPSI(UNIT)	; Get fork to interrupt
	JUMPL B,PUPIN5		; -1 => none
	LDB A,RECPSI		; Get PSI channel to interrupt on
	CAIL A,^D36		; Armed?
	 JRST PUPIN5		; No
	MOVEI A,PRQINT		; Yes, initiate scheduler request
	HRLI A,(UNIT)		; Wakeup for this port
	PUSHJ P,SCDRQ7##	; Queue the request

PUPIN5:	HRRZ A,PUPLNH(UNIT)	; Get BSP linkage if any
	JUMPE A,CPOPJ##		; Done now if not BSP port
	MOVSI A,(BSWAKF)	; Set flag to awaken BSP processor
	IORM A,PUPSTS(UNIT)
	MOVE A,TODCLK		; Queue request for background task
	AOJL B,.+2		; Immediately if NVT
	ADDI A,IBWDLY		; Delayed otherwise
	PUSHJ P,ADDTQI		; Add port to timer queue
	POPJ P,			; Done
                                                                       |
;Routing pkt rcvd                                                      |
PUPIN6:	MOVEI UNIT,NPUPUN	; Use extra queue                      |
	HRRZ A,PBSIZE(PB)	; Get size of block                    |
	CALL CHKIQL		; See if room                          |
	 JRST PUPIE3		; no                                   |
	ADDM A,PUPIBC(UNIT)	; Add in resources used                |
	MOVEI A,PUPIBQ(UNIT)	; Get its queue                        |
	CALL APPIBQ		; Put on queue                         |
	SIGPBP(RTE)		; Signal background                    |
	RET                                                            |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 93

; Gateway processor
; Enter with PB/ Packet Buffer pointer
;	A/ Destination network
;	B/ Destination host
; Returns +1 always
; Clobbers A-D, disposes of packet always

GATEWY:
	SKIPN [GATEWF]                                                 |
	JRST NOTGAT		; NOT A GATEWAY                        |
	MOVE B,PUPTCB		; Get byte ptr to transport control byte
	LDB A,B			; Get current value of byte
	ADDI A,1B31		; Increment hop count (B1-3 of byte)
	TRNN A,7B31		; Overflow?
	 JRST PUPIE4		; Yes, give error and discard
	PUSHJ P,UPDCKS		; Ok, set new value and fix checksum
	MOVEI UNIT,NPUPUN	; Set fake unit # for gateway
	DPB UNIT,PPUPUN
	HRRZ A,PBSIZE(PB)	; Get length of this packet buffer
	PUSHJ P,CHKGQL		; Check for exceeding maximum
	 BUGP(DPR,<GATEWY: Excessive gateway Pups queued>,X)           |
	ADDM A,PUPOBC(UNIT)	; Ok, update counts                    |
	SETZM PBPHYS(PB)	; Clear immeadiate dest                |
	CALL SETDST		; Set destination, return queue header |
	 JRST [	LDB UNIT,PPUPUN	; Get index of originating port        |
		HRRZ A,PBSIZE(PB) ; Get length of packet just output   |
		PUSHJ P,DECOQL	; Decrement buffer counts for port     |
		JRST RELPBI ]	; Bad destination or... , discard pkt  |
	MOVEI B,PBIOBQ(PB)                                             |
	PUSHJ P,APPITQ                                                 |
	PUSHJ P,PUPOG1		; Wake up output if necessary          |
	POPJ P,			; Return from gateway handler          |
NOTGAT:	BUGP(PUP,<GATEWY: Received Pup not for me and I'm not a gateway>,X)
                                                                       |
	MOVEI A,1006		; Registered error code                |
	HRROI B,[ASCIZ /I'm not a gateway/]                            |
	JRST PUPIE8		; Go send Error Pup                    |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 94

; Here on various Pup input errors detected at interrupt level.
; Generate appropriate "Error" Pup where possible.

; Here if destination network is unknown or unreachable
PUPIE1:	BUGP(PUP,<PUPINP: Unknown Pup destination network>,X)          |
	MOVEI A,1002		; Set Error type
	HRROI B,[ASCIZ /Destination net not in routing table/]
	JRST PUPIE8		; Go make Error and send it

; Here if Pup received for nonexistent local port
PUPIE2:	BUGP(PUP,<PUPINP: Received Pup for nonexistent local port>,X)  |
	MOVEI A,2		; Set Error type                       |
	HRROI B,[ASCIZ /No process at destination port/]               |
	MOVE C,FACTSW##		; Check startup flags                  |
	TXNN C,SF%NVT		; Logins allowed?                      |
	 HRROI B,[ASCIZ /Tenex not available/]                         |
	JRST PUPIE7		; Go make and send Error               |
                                                                       |
; Here if port input queue overflowed                                  |
PUPIE3:	BUGP(PUP,<PUPINP: Exceeded maximum input buffer queue length for port>,X)
                                                                       |
	MOVEI A,3		; Set Error type
	HRROI B,[ASCIZ /Port input queue overflowed/]
	JRST PUPIE7		; Go make and send Error

; Here if gateway hop count overflowed
PUPIE4:	BUGP(PUP,<GATEWY: Discarding Pup at 8th gateway>,X)            |
	MOVEI A,1004		; Set Error type
	HRROI B,[ASCIZ /Discarded at 8th gateway/]
	JRST PUPIE8		; Go make and send Error


; Here to make and send Error arising from original Pup destination
PUPIE7:	PUSHJ P,MAKERR		; Make Error Pup
	 JRST RELPBI		; Can't, just flush packet
	JRST PUPIEX		; Go send Error

; Here to make and send Error arising from Maxc NCP
PUPIE8:	PUSHJ P,MAKERR		; Make Error Pup
	 JRST RELPBI		; Can't, just flush packet
	LDB A,PPBPHN		; Set source net/host to be
	DPB A,PPUPSN		;  phys net/host at which Pup
	LDB A,PPBPHH		;  was received
	DPB A,PPUPSH
	SETZM PBHEAD+4(PB)	; Set source socket to zero

; Send Error packet via gateway queue
PUPIEX:	MOVEI UNIT,NPUPUN	; Set fake unit # for gateway
	DPB UNIT,PPUPUN
	HRRZ A,PBSIZE(PB)	; Get length of this packet buffer
	PUSHJ P,CHKGQL		; Check for exceeding maximum
	 JRST RELPBI		; Overflowed, just chuck it
	ADDM A,PUPOBC(UNIT)	; Ok, update counts
	SETZM PBPHYS(PB)	; Clear immeadiate dest                |
	CALL SETDST		; Set destination, get queue header    |
	 JRST [	LDB UNIT,PPUPUN	; Get index of originating port        |
		HRRZ A,PBSIZE(PB) ; Get length of packet just output   |
		PUSHJ P,DECOQL	; Decrement buffer counts for port     |
		JRST RELPBI ]	; Bad destination or... , discard pkt  |
	MOVEI B,PBIOBQ(PB)                                             |
	PUSHJ P,APPITQ                                                 |
	PUSHJ P,PUPOG1		; Wake up output if necessary          |
	POPJ P,			; Return from gateway handler
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 95

; Pup output interrupt service

;RS CUROPB		; Pointer to current output packet buffer      |
;RS PUPFOI		; Count of false output interrupts             |
                                                                       |
PUPOS3:	POP P,B			; Restore stack                        |
PUPOSV:	MOVE A,XPUPOW		; Get flag saying which lines need work|
	JFFO A,.+2		; Find first line that needs service   |
	JRST PUPSVX		; None do, return                      |
	MOVE A,BITS(B)		; Get bit to clear                     |
	CAILE B,7		; Valid line number?                   |
	BUG(HLT,PPOSV,<PUPOSV: Invalid requset for line>)              |
	ANDCAM A,XPUPOW		; Clear request                        |
	PUSH P,B		; Save line number                     |
	SKIPN A,XPUPOB(B)	; Packet being output?                 |
	 JRST PUPOS2		; No                                   |
	JUMPG A,PUPOS3                                                 |
	SETZM XPUPOB(B)		; Clear communication cell             |
	MOVE PB,CUROPB(B)	; Get packet buffer ptr                |
                                                                       |
; Here from code below to discard packet before attempting output      |
PUPOS1:	CALL SETNDS		; See if it should be sent to more hosts
                                                                       |
	 JRST PUPOS5		; No                                   |
	MOVEI B,PBIOBQ(PB)	; Get link cell                        |
	CALL APPITQ		; Yes, put on queue                    |
	CALL PUPOG1		; Say this line needs service          |
	JRST PUPOS2                                                    |
PUPOS5:	LDB UNIT,PPUPUN		; Get index of originating port        |
	HRRZ A,PBSIZE(PB)	; Get length of packet just output
	PUSHJ P,DECOQL		; Decrement buffer counts for port
	SKIPE PBBSPQ(PB)	; Packet on BSP output queue?
	 JRST [	PUSHJ P,UNLKPB	; Yes, unlock from core
		SETZM PBIOBQ(PB) ; Mark PB no longer being serviced
		JRST PUPOS2]	; But don't deallocate
	PUSHJ P,RELPBI		; No, just release packet buffer

; Now look for a Pup queued for output
PUPOS2:	MOVE B,0(P)		; Get back line number                 |
	MOVEI A,PUPOBQ(B)	; Output buffer queue header           |
	PUSHJ P,REMOBQ		; Remove packet from queue             |
	 JRST PUPOS3		; Queue empty                          |
	POP P,B                                                        |
	MOVEM PB,CUROPB(B)	; Save ptr to packet being output      |
	SETOM PBIOBQ(PB)	; Note not done with packet yet        |
	MOVEI A,(PB)		; Make length,,address                 |
	HRL A,0(A)                                                     |
	MOVEM A,XPUPOB(B)	; Store for NVIO                       |
	MOVE A,DZBASE		; Start up DZ line                     |
	MOVE B,PPBITS(B)                                               |
	BSIOB B,4(A)                                                   |
	JRST PUPOSV		; Try next line                        |


; Restore AC's and dismiss interrupt

PUPSVX:	MOVS P,[0,,PUPACS]                                             |
	BLT P,17                                                       |
	XJEN PUPSVR		; Dismiss                              |
                                                                       |
PPSTKP:	IOWD 100,PUPSTK                                                |
RS PUPSVR,4                                                            |
RS PUPACS,20                                                           |
RS PUPSTK,100                                                          |
^L                                                                     |


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 96

; Set destination network, host, line.  This increments to the         |
;  next alive host if doing a broadcast.                               |
;        PB/ packet buffer ointer                                      |
; Returns +1:  Discard packet, any BUG(PUP) has been done              |
;         +2: Put buffer on queue, A has correct queue header          |
                                                                       |
SETDST:	PUSH P,B                                                       |
	LDB UNIT,PPUPUN		; Get index of originating port        |
	LDB A,PPBPAL		; See if this is being sent to all lines
                                                                       |
	JUMPN A,[ SETZ A,	; Yes, send to line 0 first            |
		JRST SETDS1 ]                                          |
	PUSHJ P,SETPHD		; Setup physical destination           |
	 JRST SETDS2		; Dest net inaccessible                |
	PUSHJ P,DSCRAN		; See if want random discard           |
	 JRST SETDSR			; Yes, do so                   |
	LDB A,PPBPHN		; Get network                          |
	CAIE A,MYNETN		; This SLA net is 15                   |
	 JRST SETDS2		; anything else is inaccessible        |
	LDB A,PPBPHH		; Get host to send to                  |
	JUMPE A,SETDS4		; Host 0, broadcast                    |
	CAIL A,NBRHST		; Valid host?                          |
	 JRST SETDS5		; No                                   |
	SKIPGE HOSTRT-1(A)	; Is host availablie                   |
	JRST SETDS5		; Not accessible now                   |
	HRRZ A,HOSTRT-1(A)	; Get line nbr                         |
SETDS1:	DPB A,PPBPLN		; Remember which line to use           |
	MOVEI A,PUPOBQ(A)	; Get head of queue                    |
	POP P,B                                                        |
	RETSKP                                                         |
                                                                       |
SETDS4:	SETO A,                                                        |
	DPB A,PPBPBC		; Remember this is to be broadcast     |
	TDZA B,B		; Zero host                            |
SETDS3:	LDB B,PPBPHH		; Get last host sent to                |
SETDS7:	ADDI B,1		; Try next host                        |
	CAIL B,NBRHST		; Tried all hosts?                     |
	 JRST SETDSR			; Yes, done                    |
	SKIPGE HOSTRT-1(B)	; See if this host is up               |
	 JRST SETDS7		; No, try next one                     |
	HRRZ A,HOSTRT-1(B)	; Get line to use                      |
	DPB B,PPBPHH		; Save host                            |
	JRST SETDS1                                                    |
                                                                       |
; Here if can't transmit packet because dest net is inaccessible       |
SETDS2:	BUGP(PUP,<SETDST: Destination network inaccessible>,X)         |
	JRST SETDSR		; Indicate it is to be flushed         |
SETDS5:	BUGP(PUP,<SETDST: Destination host inaccessible>,X)            |
	JRST SETDSR                                                    |
                                                                       |
; Set next destination- called after sending packet once               |
; to determine if it should be sent again.                             |
                                                                       |
SETNDS:	PUSH P,B                                                       |
	LDB A,PPBPBC		; Broadcast?                           |
	JUMPN A,SETDS3		; Yes                                  |
	LDB A,PPBPAL		; All lines?                           |
	JUMPN A,SETDS6		; Yes                                  |
SETDSR:	POP P,B                                                        |
	RET			; All done with the pkt                |
                                                                       |
; Sending to all lines                                                 |
SETDS6:	LDB A,PPBPLN		; Get current line                     |
	ADDI A,1		; Go to next one                       |
	CAIL A,10		; At last line?                        |
	 JRST SETDSR		; Yes, discard msg                     |
	JRST SETDS1		; Get proper queue header              |
^L                                                                     |


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 97

; Check for requested random discard
;	UNIT/ Pup unit #
; Returns +1:  Discard packet
;	+2:  Don't discard packet
; Clobbers A, B

DSCRAN:	MOVSI A,(DSCRNF)	; Random discard requested?
	CAIE UNIT,NPUPUN	; And not gateway "port"?
	TDNN A,PUPSTS(UNIT)
	 RETSKP			; No                                   |
	SKIPN A,RANNUM		; Yes, get current random number
	 MOVS A,TODCLK		; None, initialize to clock
	MULI A,6065		; Compute next
	DIV A,[377777777741]
	MOVSM B,RANNUM		; Store remainder for next call
	TLNE B,(-1B5)		; Discard 1 packet in 32
	 AOS 0(P)
	POPJ P,

;RS RANNUM		; Last random number                           |


; Routine called from scheduler to request Pup received PSI on port
;	A/ Pup unit #
; Returns +1
; Clobbers A, B, UNIT

PRQINT:	MOVEI UNIT,(A)		; Put port index in right ac
	HRRE B,PUPPSI(UNIT)	; Get fork to interrupt
	JUMPL B,CPOPJ##		; Forget it if none
	LDB A,RECPSI		; Get PSI channel to interrupt on
	CAIGE A,^D36		; Armed?
	 PUSHJ P,PSIRQ##	; Yes, initiate interrupt
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 98

; Set physical destination and message length for Pup
;	PB/ Packet Buffer pointer
; Returns +1:  Destination unreachable
;	+2:  PBPHYS word set up

SETPHD:	LDB B,PPUPDN		; Get destination net
	CAIL B,1		; Check bounds (probably redundant)
	CAILE B,NPNETS
	 POPJ P,		; Error
	SKIPGE A,PUPROU-1(B)	; Ok, get routing table entry
	 POPJ P,		; Net known to be unreachable
	LSH A,2			; Left-justify net/host
	TLNN A,(177777B15)	; Dest net directly connected?
	 MOVE A,PBHEAD+2(PB)	; Yes, use final destination
	AND A,[777774,,0]	; Clear bits which arent host,net      |
	MOVEM A,PBPHYS(PB)	; Store phys net/host                  |
	LDB A,PUPLEN		; Get Pup length                       |
	DPB A,PPBPHS		; Set physical size for NVIO           |
	RETSKP			; Give skip return                     |



; Start NVIO input going if necessary.
; Call after putting something on FREIBQ
; Returns +1, clobbers nothing

PUPIGO:	SKIPN XPUPIB		; Input already turned on?
	 ISB PUPCHN		; No, initiate manual interrupt        |
	POPJ P,


; Start NVIO output going if necessary.
; Call after putting something on PUPOBQ
; Returns +1, clobbers nothing

PUPOGO:	CALL PUPOG1		; Set flag                             |
	ISB PUPCHN		; No, initiate manual interrupt        |
	POPJ P,                                                        |
                                                                       |
PUPOG1:	LDB B,PPBPLN		; Get line to send this on             |
	SKIPE XPUPOB(B)		; Output already in progress?          |
	 RET			; Already outputing, it will check     |
	MOVE B,BITS(B)		; Get bit for this line                |
	IORM B,XPUPOW		; Ask for service                      |
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 99


; -----------------------------------------------------------------
;	General Pup Subroutines
; -----------------------------------------------------------------

; Port table management

SWAPCD                                                                 |

; Assign local port
;	A/ <net>B7 + <host>B15
;	B/ Socket (right-justified)
; Returns +1:  Error, no slots available
;	+2:  Port already in use, UNIT/ Pup unit #
;	+3:  Successful, UNIT/ Pup unit #
; +1 return with PRTLCK unlocked, +2 and +3 with PRTLCK locked.
; Clobbers C, D, UNIT

ASGPRT:	LOCK(PRTLCK,,SPQ)	; Lock the table
	MOVSI UNIT,(1B0+1B2)	; Set flags for port conflict check
	PUSHJ P,PRTLU0		; Lookup local port
	 CAIA			; Not found
	RETSKP			; Found, take single skip return       |
	JUMPL UNIT,[
		UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Unlock and fail if table full
		POPJ P,]
	PUSHJ P,INIPRT		; Initialize port
	SKIPE PUPLSK(UNIT)	; Skip if entry is free
	 SOS LSKNDL		; Deleted, decrement delete count
	HLLZM A,PUPLNH(UNIT)	; Store net/host
	MOVEM B,PUPLSK(UNIT)	; Store socket #, assigning port
	JRST SK2RET##		; Take success return


; Delete local port
;	UNIT/ Pup unit #
; The port itself must be locked if it is a BSP port
; Returns +1 always
; Clobbers A-D, PB

DELPRT:	LOCK(PRTLCK,,SPQ)	; Lock the table
	SETOM PUPLSK(UNIT)	; Mark entry deleted
	PUSHJ P,DELTQP		; Delete port from timer queue
	MOVEI A,PUPIBQ(UNIT)	; Input packet buffer queue header
	PUSHJ P,FSHPBQ		; Flush packet buffer queue
	SKIPE B,PUPFPT(UNIT)	; Have foreign port address table?
	 PUSHJ P,RELPFR		; Yes, deallocate it
	HRRZ B,PUPLNH(UNIT)	; Have BSP data block?
	SKIPE B
	 PUSHJ P,RELPFR		; Yes, deallocate it
	SETZM PUPLNH(UNIT)	; Zero net/host and BSP linkage
	PUSHJ P,INIPRT		; Initialize port for cleanliness
	AOS B,LSKNDL		; Increment # of deleted entries
	SIGPBP(GCS,<CAIL B,NPUPUN/4>) ; Request GC of table if worthwhile
	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Unlock the table
	POPJ P,


; Initialize local port
;	UNIT/ Pup unit #
; Returns +1 always, after setting the port's entry in all port-
;  indexed tables to a virgin state.
; Clobbers C

INIPRT:	SETZM PUPFPT(UNIT)	; Clear foreign port
	MOVEI C,PUPIBQ(UNIT)	; Set input buffer queue to empty
	HRLI C,(C)
	MOVEM C,(C)
	SETZM PUPIBC(UNIT)	; Set queue counts to zero
	SETZM PUPOBC(UNIT)
	SETOM PUPPSI(UNIT)	; Disable PSI stuff
	SETZM PUPSTS(UNIT)	; Clear status word
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 100

RESCD                                                                  |

; Garbage collect Pup local socket table by setting free as many
;  deleted entries as possible.  This is done by first changing
;  all deleted entries to be free, then looking up each in-use
;  entry and marking deleted all free cells encountered.
; Clobbers A-D, UNIT, E

GCPLSK:	LOCK PRTLCK		; Lock the table
	NOSKD1                                                         |
	CHNOFF PUPCHN		; Lock out interrupt-level accesses
	MOVSI E,-NPUPUN		; For all entries:
	SKIPGE PUPLSK(E)	; Deleted?
	 SETZM PUPLSK(E)	; Yes, set free
	AOBJN E,.-2
	SETZM LSKNDL		; Init count of deleted entries
	MOVSI E,-NPUPUN		; For all entries:
GCPLS1:	SKIPG B,PUPLSK(E)	; In use?
	 JRST GCPLS2		; No
	MOVE A,PUPLNH(E)	; Yes, fetch net/host
	MOVSI UNIT,(1B1)	; Set special flag
	PUSHJ P,PRTLU0		; Lookup, setting free entries to deleted
	 BUG(HLT,GCPLSZ,<GCPLSK: Impossible fail return from PRTLU0>)  |
GCPLS2:	AOBJN E,GCPLS1                                                 |
	CHNON PUPCHN		; Unlock and return                    |
	OKSKD1                                                         |
	UNLOCK PRTLCK
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 101

; Lookup local port
;	A/ <net>B7 + <host>B15
;	B/ Socket (right-justified)
; Returns +1: fail, UNIT/ Index of first free slot (B0 set => full)
;	  +2: found, UNIT/ Index of matching entry
; Non-interrupt-level callers should lock PRTLCK before calling
;  if they intend to use UNIT on either return.
; Clobbers C, D, UNIT

PRTLUK:	MOVSI UNIT,(1B0)	; Note no free entries found yet

; Enter here for various flavors of lookup controlled by lh UNIT:
;  B0	No free entries found yet (should always be set on call)
;  B1	Doing gc marking (setting free entries to deleted)
;  B2	Doing port conflict check (wildcard in either arg or port
;	constitutes a match)

PRTLU0:	MOVE C,[^D2654435769_3]	; Constant relatively prime to 2^32
	MUL C,B			; D _ 32-bit fraction in range [0,1)
	MOVEI C,NPUPUN		; Normalize to range [0,NPUPUN)
	MULM C,D
	MOVNI C,(D)		; Save neg index for wraparound
	HRLM C,0(P)
	HRLI D,-NPUPUN(D)	; Make AOBJN ptr, here to end
PRTLU1:	CAMN B,PUPLSK(D)	; Socket number match this entry?
	 JUMPN B,[MOVE C,PUPLNH(D)  ; Yes, compare net/host
		XOR C,A
		HLR C,PUPLNH(D)	; Wildcard check
		TLNE UNIT,(1B2)	; Port conflict check?
		 TLNE A,(377B7)	; Yes, check arg for wildcard
		TRNN C,377B25
		 TLZ C,(377B7)	; Net wildcard
		TLNE UNIT,(1B2)	; Port conflict check?
		 TLNE A,(377B15)  ; Yes, check arg for wildcard
		TRNN C,377B33
		 TLZ C,(377B15)	; Host wildcard
		TLNE C,(177777B15)
		 JRST PRTLU2	; Mismatch, continue search
		MOVEI UNIT,(D)	; Match, return index
		RETSKP	]                                              |
	SKIPG C,PUPLSK(D)	; No match, free or deleted?
	 JRST [	TLNE UNIT,(1B1)	; Yes, doing gc marking?
		 JRST [	JUMPL C,PRTLU2	; Yes, ignore if deleted
			SETOM PUPLSK(D)	; Free, mark deleted
			AOS LSKNDL	; Bump delete count
			JRST PRTLU2]	; Continue search
		TLZE UNIT,(1B0)	; No, already have free/deleted index?
		 HRRI UNIT,(D)	; No, remember this
		JUMPL C,PRTLU2	; Keep searching if deleted entry
		POPJ P,]	; Fail if free entry, i.e. not found	
PRTLU2:	AOBJN D,PRTLU1		; Search linearly thru table
	HLLZ D,0(P)		; At end, wraparound
	HRRZS 0(P)		; Clear count in case get here again
	JUMPL D,PRTLU1		; Do portion before initial probe
	POPJ P,			; Searched whole table, not found
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 102

SWAPCD                                                                 |

; Check Pup source field
;	PB/ Packet buffer pointer
;	UNIT/ Pup unit #
; Returns +1:  Source incorrect
;	+2:  Source correct, i.e. matches foreign port
; Clobbers A-D

CHKSRC:	LDB A,PPUPSN		; Get source net from Pup
	LDB B,PPUPSH		; Source host
	LDB C,PPUPSS		; Source socket

; Enter here with A/ net, B/ host, C/ socket to be checked
CHKSR1:	SKIPN D,PUPFPT(UNIT)	; Have foreign port address table?
	 RETSKP			; No, fully wildcard, skip return      |
	PUSH P,E		; Get another ac
CHKSR2:	HLRZ E,1(D)		; Get net from table
	CAIE A,(E)		; Match?
	 JUMPN E,CHKSR3		; No, fail unless wildcard
	HRRZ E,1(D)		; Yes, get host from table
	CAIE B,(E)		; Match?
	 JUMPN E,CHKSR3		; No, fail unless wildcard
	CAME C,2(D)		; Yes, check socket
	 SKIPN 2(D)		; Mismatch, fail unless wildcard
	AOSA -1(P)		; Matched, take skip return
CHKSR3:	AOBJN D,CHKSR2		; Table entry mismatched, try next
	POP P,E			; Matched (skip preset) or no more
	POPJ P,


; Set Pup checksum
;	PB/ Packet Buffer pointer
; Returns +1:
; Clobbers A-D

SETCKS:	PUSHJ P,PUPCKS		; Compute checksum
	MOVE C,A		; Save it
	PUSHJ P,GPTCKS		; Get byte pointer to checksum
	DPB C,B			; Store checksum in Pup
	POPJ P,


; Check Pup checksum
;	PB/ Packet Buffer pointer
; Returns +1:  Checksum incorrect
;	+2:  Checksum correct
; Clobbers A-D

CHKCKS:	PUSHJ P,GPTCKS		; Get byte pointer to checksum
	LDB C,B			; Get checksum from Pup
	CAIN C,177777		; Real checksum?
	 RETSKP			; No, unchecksummed Pup always ok      |
	PUSH P,C		; Yes, save checksum from Pup
	PUSHJ P,PUPCKS		; Recompute checksum
	POP P,C
	CAMN A,C		; Correct?
	 AOS 0(P)		; Yes, skip return
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 103

RESCD                                                                  |

; Update Pup checksum
;	PB/ Packet Buffer pointer
;	A/ New value of field to be updated
;	B/ Byte pointer denoting field to be changed
;	   Must be indexed by PB and cannot cross 16-bit boundary
; Returns +1 after storing new value as specified and updating the
;	   checksum (if appropriate)
; Clobbers A-D

UPDCKS:	MOVE C,A		; Save new value
	MOVEI A,(B)		; Compute Maxc-word offset of field
	LSH A,1			; Convert to 16-bit word offset
	HLRZ D,B		; Which byte?
	CAIGE D,^D20B23
	 ADDI A,1		; Right, add 1 to offset
	PUSH P,B		; Save byte ptr arg
	PUSHJ P,GPTWRD		; Get pointer to 16-bit word
	LDB D,B			; Fetch old contents of word
	DPB C,0(P)		; Store new value into field being changed
	SUB P,BHC##+1		; Fix stack
	LDB C,B			; Fetch new contents of word
	SUBI C,(D)		; Compute 16-bit 1's complement difference
	JUMPGE C,.+2
	 ADDI C,177777
	MOVE D,A		; Save offset
	PUSHJ P,GPTCKS		; Return offset and ptr to checksum
	SUBI A,(D)		; Compute difference in offsets
	ANDI A,17		; Modulo 16
	LSH C,(A)		; Shift checksum correction appropriately
	LDB A,B			; Fetch old checksum
	CAIN A,177777		; Real checksum?
	 POPJ P,		; No, unchecksummed Pup, don't update
	ADD A,C			; Compute new sum
	MOVE D,B		; Save byte ptr
	PUSHJ P,CKFOLD		; Fold computed checksum to 16 bits
	CAIN A,177777		; Check for minus zero
	 SETZ A,		; Convert to plus zero
	DPB A,D			; Store new checksum
	POPJ P,


; Get pointer to Pup checksum
;	PB/ Packet Buffer pointer
; Returns +1:
;	A/ Packet-Buffer-relative offset of 16-bit checksum word
;	B/ Byte pointer to Pup checksum
; No other ac's clobbered

GPTCKS:	LDB A,PUPLEN		; Get Pup length in bytes
	ADDI A,4*PBHEAD-1	; Compute PB-relative 16-bit word offset
	LSH A,-1		;  of Pup checksum
				; Fall into GPTWRD


; Get pointer to 16-bit word in Pup
;	A/ Packet-Buffer-relative offset of word
;	   e.g. 2*PBHEAD denotes offset of Pup Length field
; Returns +1:
;	B/ Byte ptr to selected word (indexed by PB)
; No ac's clobbered (besides B)

GPTWRD:	MOVEI B,(A)		; Copy offset
	ROT B,-1		; Compute Maxc-word offset
	JUMPL B,.+2		; Which byte?
	 TLOA B,(POINT 16,(PB),15)  ; Left
	 HRLI B,(POINT 16,(PB),31)  ; Right
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 104

SWAPCD                                                                 |

; Compute Pup checksum
;	PB/ Packet Buffer pointer
; Returns +1:
;	A/ 16-bit checksum, right-justified
; Clobbers B-D

PUPCKS:	LDB C,PUPLEN		; Pup length in bytes
	SUBI C,1		; Compute # full words to checksum
	LSHC C,-2		; (i.e. exclusive of checksum word)
	PUSH P,D		; Sign bit set if leftover 16-bits
	ROT C,-3		; Divide # full words by 8
	MOVEI D,1(C)		; # 8-fold cycles +1
	LSH C,-^D<18-3>		; # leftover bytes in lh
	MOVN C,C		; Make AOBJN pointer to Pup
	HRRI C,PBHEAD(PB)
	SETZ A,			; Init checksum to zero
	TLNN C,-1		; Use leftover count first
	 JRST PUPCK4		; None, start full 8-fold cycles
PUPCK2:	MOVE B,0(C)		; Get a word
	ANDCMI B,17		; Clear garbage bits
	ROT B,^D16		; High 16 bits to B20-35, clear B18-19
	ADDI A,(B)		; Add to checksum
	LSH A,2			; Shift checksum twice
	LSH B,-^D<36-16-1>	; Justify previous low 16 bits to B34
	ADDI A,(B)		; Add to checksum (pre-shifted)
	AOBJN C,PUPCK2		; Repeat for this group
	PUSHJ P,CKFOLD		; Fold 36 bits to 16
PUPCK4:	HRLI C,-8		; Set to do next group
	SOJG D,PUPCK2		; Repeat if more to do
	POP P,D			; Done, have a leftover 16 bits?
	JUMPGE D,PUPCK5
	MOVE B,0(C)		; Yes, add it in
	LSH B,-^D<36-16>
	ADDI A,(B)
	LSH A,1
	PUSHJ P,CKFOLD		; Fold to 16 bits
PUPCK5:	CAIN A,177777		; Minus zero?
	 SETZ A,		; Yes, make plus zero
	POPJ P,


RESCD                                                                  |

; Fold 36-bit add-and-left-shift checksum into 16-bit
;  ones-complement add-and-left-cycle checksum
;	A/ 36-bit checksum
; Returns +1:
;	A/ 16-bit checksum, right-justified
; Clobbers B

CKFOLD:	CAIG A,177777
	 POPJ P,		; No more folding to do
	LSHC A,-^D16		; Overflow bits in A, low 16 in B
	LSH B,-^D<36-16>
	ADDI A,(B)		; Fold
	JRST CKFOLD		; Check again
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 105

; Pup free storage management routines

SWAPCD                                                                 |

; Assign Pup free storage block from the PUPFRE region
;	B/ Size of block needed (words)
; Returns +1: Failed
;	+2: A/ Pointer to block
; Clobbers A-D

ASGPFR:	MOVEI A,PUPFRE		; Point to free storage header
	JRST ASGFRE##		; Just call standard routine



; Release Pup free storage block
;	B/ Pointer to block
; Returns +1 always
; Clobbers A-D

RELPFR:	MOVEI A,PUPFRE		; Point to free storage header
	HRRZS (B)		; Clear unit nbr                       |
	JRST RELFRE##		; Just call standard routine



; Trim Pup storage block
;	A/ Pointer to block
;	B/ # words to retain
; Returns +1 always
; Clobbers A-D

TRMPFR:	HRRZ C,0(A)		; Get current size
	SUB C,B			; Compute excess words
	JUMPLE C,CPOPJ##	; Quit if none
	HRRM B,0(A)		; Store new size
	ADDI B,(A)		; Point to start of excess
	HRRM C,0(B)		; Store size at head of block
	PUSHJ P,RELPFR		; Release excess block
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 106

; Assign packet buffer
;	B/ Size of buffer needed (words)
; Returns +1:  Failed, A/ appropriate arg for EDISMS
;	+2:  PB/ Packet Buffer pointer
; The buffer returned has the size setup (PBSIZE) and all else zeroed.
; Clobbers A-D

ASGPKT:	MOVEI A,PKTFRE		; Free storage header
	PUSHJ P,ASGFRE##	; Assign the block
	 JRST ASGPK1		; Can't
	MOVEI PB,(A)		; Ok, put buffer adr in PB
	PUSHJ P,CLRPBH		; Clear header
	RETSKP			; Skip return                          |
                                                                       |
; Here when fail to allocate                                           |
ASGPK1:	BUG(INF,ASGPKZ,<ASGPKT: Free storage exhausted>)               |
	MOVSI A,(B)		; Set scheduler test word
	HRRI A,PKTFRT		; Size,,routine
	SETZM PKTRLF		; Init wakeup condition
	POPJ P,			; Take fail return

RESCD                                                                  |

; Scheduler test for process dismissed after ASGPKT failure
; Arg is size of packet buffer needed (words)

;RS PKTRLF		; Set nonzero when storage has been released   |

PKTFRT:	CAMG A,PKTFRE+2		; Don't wakeup if total space insufficient
	SKIPN PKTRLF		; Wakeup if RELPKT has been called
	 JRST 0(D)
	JRST 1(D)


SWAPCD                                                                 |

; Release packet buffer
;	PB/ Packet Buffer pointer
; Returns +1
; Clobbers A-D, PB

RELPKT:	MOVSI A,(PBLCKF)	; Make sure not locked
	TDNE A,PBSIZE(PB)
	 BUG(HLT,RELPKZ,<RELPKT: Attempt to release locked packet buffer>)
                                                                       |
	HRRZ A,PBSIZE(PB)	; Check size
	MOVE B,FREIBN		; Get free input buffer count
	CAIL A,MXPBLN		; Releasing maximum-size buffer?
	CAIL B,MAXFIB		; Yes, want to add more input buffers?
	 JRST [	MOVEI A,PKTFRE	; No, just release the storage
		MOVEI B,(PB)
		HRRZS (B)	; Clear unit nbr                       |
		PUSHJ P,RELFRE##
		SETOM PKTRLF	; Note space has been released
		POPJ P,]
	PUSHJ P,CLRPBH		; Yes, clear header
	JRST ASGIP1		; Go put on FREIBQ and return
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 107

; Assign input packet buffer, add to FREIBQ, and start up input if necessary
; Returns +1: failed
;	+2: succeeded
; Clobbers A-D and PB

ASGIPB:	MOVEI B,MXPBLN		; Get maximum-size packet buffer
	PUSHJ P,ASGPKT
	 POPJ P,		; Failed, forget it
	AOS 0(P)		; Ok, preset skip return

; Here from RELPKT with PB/ ptr to maximum-size packet buffer
ASGIP1:	MOVEI A,FREIBQ		; Free input buffer queue header
	PUSHJ P,APPOBQ		; Lock and append to queue
	AOS FREIBN		; Fix count
	PUSHJ P,PUPIGO		; Start input if necessary
	POPJ P,


RESCD                                                                  |

; Release packet buffer at interrupt level
;	PB/ Packet buffer ptr
; Returns +1
; Callable only at interrupt level;  PB must be locked
; Clobbers A-C

RELPBI:	MOVSI A,(PBLCKF)	; Make sure locked
	TDNN A,PBSIZE(PB)
	 BUG(HLT,RELPBZ,<RELPBI: Called with unlocked PB>)             |
	HRRZ A,PBSIZE(PB)	; Get size of PB
	MOVE B,FREIBN		; Get # of buffers already available
	CAIL A,MXPBLN		; This PB too small?
	CAIL B,MAXFIB		; Already enough PBs available?
	 JRST [	MOVEI A,FREOBQ	; Yes, put PB on queue to be freed
		PUSHJ P,APPIBQ
		SIGPBP(FRE)	; Request service by deallocator
		POPJ P,]
	PUSHJ P,CLRPBH		; No, clear header
	MOVSI A,(PBLCKF)	; Set locked flag again
	IORM A,PBSIZE(PB)
	MOVEI A,FREIBQ		; Free input buffer queue header
	MOVEI B,PBIOBQ(PB)	; Make ptr to link word in PB
	PUSHJ P,APPITQ		; Append to queue
	AOS FREIBN		; Fix count
	PUSHJ P,PUPIGO		; Start input if necessary
	POPJ P,


; Clear packet buffer header
;	PB/ Packet buffer ptr
; Returns +1, clobbers nothing

CLRPBH:	HRRZS PBSIZE(PB)	; Clear lh of PBSIZE
	SETZM PBIOBQ(PB)	; Clear I/O queue links
	SETZM PBBSPQ(PB)	; Clear BSP queue links
	SETZM PBTIME(PB)	; Clear time stamp word
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 108

; Packet buffer queueing and unqueueing routines
SWAPCD                                                                 |

; Get Pup from port input queue
;	UNIT/ Pup unit #
; Returns +1:  Queue empty, A/ Appropriate arg for EDISMS
;	+2:  PB/ Packet Buffer pointer, counts updated appropriately
; Clobbers A-C

GETPUP:	MOVEI A,PUPIBQ(UNIT)	; Set adr of port input queue hdr
	PUSHJ P,REMIBQ		; Get packet buffer from queue
	 JRST [	MOVEI A,NEPBQT	; Empty, set scheduler test word
		HRLI A,PUPIBQ(UNIT)
		POPJ P,]	; Fail return
	HRRZ A,PBSIZE(PB)	; Got one, get packet buffer length
	PUSHJ P,DECIQL		; Decrement input queue length counts
	RETSKP			; Skip return                          |
                                                                       |
RESCD                                                                  |

; Scheduler test for non-empty packet buffer queue
; Arg is address of queue header

NEPBQT:	HRRZ B,(A)		; Get head item in queue
	CAIN B,(A)		; Self-pointer?
	 JRST 0(D)		; Yes, queue still empty
	JRST 1(D)		; Non-empty, wakeup


SWAPCD                                                                 |

; Put Pup on output queue
;	PB/ Packet Buffer pointer
;	UNIT/ Pup unit #
; Returns +1:  Queue too long, A/ Appropriate arg for EDISMS
;	+2:  Ok, queue length updated appropriately
; Clobbers A-C

PUTPUP:	DPB UNIT,PPUPUN		; Store unit # in Pup
	HRRZ A,PBSIZE(PB)	; Get length of new packet buffer
	PUSHJ P,CHKOQL		; Check for exceeding output queue length
	 POPJ P,		; Too much, fail return
	ADDM A,PUPOBC(UNIT)	; Ok, update count
	SETZM PBPHYS(PB)	; Clear immeadiate dest                |
	CALL SETDST		; Set destination, get queue header    |
	 JRST PUPPP1		; not accessible                       |
	PUSHJ P,APPOBQ		; Lock and append Pup to queue         |
	PUSHJ P,PUPOGO		; Start output going if necessary      |
	RETSKP			; Skip return                          |
                                                                       |
PUPPP1:	LDB UNIT,PPUPUN		; Get index of originating port        |
	HRRZ A,PBSIZE(PB)	; Get length of packet just output     |
	PUSHJ P,DECOQL		; Decrement buffer counts for port     |
	SKIPN PBBSPQ(PB)	; Is this on BSP?                      |
	CALL RELPKT		; No, release it                       |
	RETSKP			; Pretend it worked                    |
                                                                       |
                                                                       |
RESCD                                                                  |

; Delete Pup from output queue if still on it
; Pup must be marked as owned by BSP processor (PBBSPQ nonzero)
;	PB/ Packet buffer pointer
;	UNIT/ Pup unit #
; Returns +1, releases or disposes of packet buffer always
; Clobbers A-C

DELOBQ:	SKIPN PBBSPQ(PB)	; Make sure owned by BSP processor
	 BUG(HLT,DELOBZ,<DELOBQ: Called for unowned packet buffer>)    |
	SKIPN PBIOBQ(PB)	; Now on output queue?
	 JRST DELOB2		; No, just release the packet
	NOSKED			; Prevent swapouts
	SKIP PBIOBQ(PB)		; Make sure in core
	CHNOFF PUPCHN		; Lock out interrupts
	SKIPN A,PBIOBQ(PB)	; Still on output queue?
	 JRST DELOB1		; No, just release the packet
	AOJE A,[SETZM PBBSPQ(PB)  ; Now being output by NVIO,
		CHNON PUPCHN	;  mark unowned so output interrupt
		OKSKED		;  deallocates it when done
		POPJ P,]
	MOVEI A,PBIOBQ(PB)	; On output queue, unlink it
	PUSHJ P,DELITQ
	HRRZ A,PBSIZE(PB)	; Get size of packet buffer
	PUSHJ P,DECOQL		; Decrement counts
	PUSHJ P,UNLKPB		; Unlock packet buffer
DELOB1:	CHNON PUPCHN		; Uninterlock
	OKSKED
DELOB2:	PUSHJ P,RELPKT		; Release the packet buffer
	POPJ P,			; Done
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 109

; Check input queue length
;	A/ Size of packet about to be added to input queue
;	UNIT/ Pup unit #
; Returns +1:  Error, queue too full
;	+2:  Ok, A/ 1,,size (ready to be added to PUPIBC(UNIT))
; Clobbers B, C

CHKIQL:	HLRZ B,PUPIBC(UNIT)	; Get buffer count
	HRRZ C,PUPIBC(UNIT)	; Get word count
	ADDI C,(A)		; Add new size to it
	CAIGE B,MAXIQB		; Enough buffers already?
	CAILE C,MAXIQW		; Too many words?
	 POPJ P,		; Yes, fail
	HRLI A,1		; No, set to add count
	RETSKP			; Skip return                          |


; Decrement input queue length
;	A/ Size of packet just removed from input queue
;	UNIT/ Pup unit #
; Returns +1 always
; Clobbers A

DECIQL:	HRLI A,1		; Set to count one buffer
	MOVNS A			; Negate buffer and word counts
	ADDB A,PUPIBC(UNIT)	; Decrement them
	TDNE A,[1B0+1B18]	; Check for over-decrementing
	 BUG(CHK,DECIQZ,<DECIQL: Over-decrementing Pup input count>)   |
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 110

; Check output queue length
;	A/ Size of packet about to be added to output queue
;	UNIT/ Pup unit #
; Returns +1:  Error, queue too full, A/ EDISMS argument word
;	+2:  Ok, A/ 1,,size (ready to be added to PUPOBC(UNIT))
; Clobbers B, C

CHKOQL:	HLRZ B,PUPOBC(UNIT)	; Get buffer count
	HRRZ C,PUPOBC(UNIT)	; Get word count
	ADDI C,(A)		; Add new size to it
	CAIGE B,MAXOQB		; Enough buffers already?
	CAILE C,MAXOQW		; Too many words?
	 JRST [	LSH A,^D<35-8>	; Yes, position size to B8
		TLO A,(UNIT)	; Unit # at B17
		HRRI A,FOPBQT	; Set scheduler test
		POPJ P,]	; Fail return
	HRLI A,1		; No, set to add count
	RETSKP			; Skip return                          |

; Scheduler test for full output packet buffer queue
; Arg is in form <size of new packet>B26 + Pup unit #

FOPBQT:	LSHC A,-^D9		; Separate size and unit
	LSH B,-^D<36-9>		; Size to A, unit # to B
	HRRZ C,PUPOBC(B)	; Get word count
	HLRZ B,PUPOBC(B)	; Get buffer count
	ADDI C,(A)		; Add new length to word count
	CAIGE B,MAXOQB		; Within bounds?
	CAILE C,MAXOQW
	 JRST 0(D)		; No
	JRST 1(D)		; Yes, wakeup


; Decrement output queue length
;	A/ Size of packet just removed from output queue
;	UNIT/ Pup unit #
; Returns +1 always
; Clobbers A

DECOQL:	HRLI A,1		; Set to count one buffer
	MOVNS A			; Negate buffer and word counts
	ADDB A,PUPOBC(UNIT)	; Decrement them
	TDNE A,[1B0+1B18]	; Check for over-decrementing
	 BUG(CHK,DECOQZ,<DECOQL: Over-decrementing Pup output count>)  |
	POPJ P,


; Check gateway queue length
;	A/ Size of packet about to be added to gateway queue
;	UNIT/ Pup unit # of gateway queue (NPUPUN)
; Returns +1:  Error, queue too full
;	+2:  Ok, A/ 1,,size (ready to be added to PUPOBC(UNIT))
; Clobbers B, C

CHKGQL:	HLRZ B,PUPOBC(UNIT)	; Get buffer count
	HRRZ C,PUPOBC(UNIT)	; Get word count
	ADDI C,(A)		; Add new size to it
	CAIGE B,MAXGQB		; Enough buffers already?
	CAILE C,MAXGQW		; Too many words?
	 POPJ P,		; Yes, fail
	HRLI A,1		; No, set to add count
	RETSKP			; Skip return                          |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 111

; Append packet buffer to input queue at interrupt level
;	PB/ Packet Buffer pointer
;	A/ Address of queue header
; Returns +1
; Previous tail (if any) must of course be locked, and is
;  unlocked by this routine.
; Clobbers A-C

APPIBQ:	MOVEI B,PBIOBQ(PB)	; Get adr of new PB's link word
	PUSHJ P,APPITQ		; Append item to queue
	CAIN C,(A)		; Was queue previously empty?
	 POPJ P,		; Yes, done
	PUSH P,PB		; No, save current PB
	MOVEI PB,-PBIOBQ(C)	; Compute real adr of old tail PB
	PUSHJ P,UNLKPB		; Unlock it
	POP P,PB
	POPJ P,


; Remove packet buffer from input queue at non-interrupt level,
;  and unlock it if necessary
;	A/ Address of queue header
; Returns +1:  Queue empty
;	+2:  PB/ Address of packet buffer
; Clobbers A-C

REMIBQ:	MOVE B,(A)		; Get queue header word
	MOVE B,(B)		; Reference head packet
	SKIP (B)		; Reference successor
	NOSKED			; Prevent swapouts
	MOVE B,(A)		; Do references again in case
	MOVE B,(B)		;  pages sneaked away (page fault
	SKIP (B)		;  while CHNOFF is death)
	CHNOFF PUPCHN		; Interlock
	PUSHJ P,REMITQ		; Remove item from queue
	 JRST [	CHNON PUPCHN	; Empty, fail
		OKSKED
		POPJ P,]
	CHNON PUPCHN
	MOVEI PB,-PBIOBQ(B)	; Get real adr of new PB
	CAIN C,(A)		; Was this the only PB in the queue?
	 PUSHJ P,UNLKPB		; Yes, have to unlock it
	OKSKED
	SETZM PBIOBQ(PB)	; Mark PB as not in queue
	RETSKP			; Skip return                          |


; Lock and append packet to output queue at non-interrupt level
;	A/ Address of queue header
;	PB/ Packet Buffer pointer
; Returns +1
; Clobbers B,C

APPOBQ:	PUSH P,A
	PUSHJ P,LOCKPB		; Lock the packet buffer
	POP P,A
	MOVEI B,PBIOBQ(PB)	; Get adr of new PB's link word
	NOSKD1                                                         |
	CHNOFF PUPCHN		; Interlock                            |
	PUSHJ P,APPITQ		; Append to queue                      |
	CHNON PUPCHN                                                   |
	OKSKD1                                                         |
	POPJ P,


; Remove packet buffer from output queue at interrupt level,
;  but do not unlock it
;	A/ Address of queue header
; Returns +1:  Queue empty
;	+2:  PB/ Address of packet buffer
; Clobbers A-C

REMOBQ:	PUSHJ P,REMITQ		; Remove item from head of queue
	 POPJ P,		; Empty, fail
	MOVEI PB,-PBIOBQ(B)	; Get real adr of new PB
	RETSKP			; Skip return                          |
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 112

; Primitive queueing/unqueueing routines.
; The caller is responsible for interlocking queue access for
;  race prevention.


; Insert item into queue
;	A/ Address of item which is to be the new item's successor,
;	    i.e. before which the new item is to be inserted
;	B/ Address of item to insert
; Returns +1:
;	C/ Address of new item's predecessor
; No other ac's affected

INSITQ:				; Same as APPITQ


; Append item to queue
;	A/ Address of queue header
;	B/ Address of item to append
; Returns +1:
;	C/ Address of previous tail item
; No other ac's affected

APPITQ:	HLRZ C,(A)		; Get current tail
	HRLM B,(A)		; Queue tail _ new PB
	HRRZM A,(B)		; New PB's successor _ queue header
	HRLM C,(B)		; New PB's predecessor _ old tail
	HRRM B,(C)		; Old tail's successor _ new PB
	POPJ P,


; Remove item from head of queue
;	A/ Address of queue header
; Returns +1:  Queue empty
;	+2:  B/ Address of item removed
;	     C/ Address of new head item
; No other ac's affected

REMITQ:	HRRZ B,(A)		; Get current head
	CAIN B,(A)		; Empty?
	 POPJ P,		; Yes, fail
	HRRZ C,(B)		; No, get successor
	HRRM C,(A)		; Queue head _ successor
	HRLM A,(C)		; Successor's predecessor _ queue header
	SETZM (B)		; Clear links in removed item
	RETSKP			; Skip return                          |


; Delete item from queue, i.e. unlink it, wherever it is in queue
;	A/ Address of item to be deleted
; Returns +1:
;	B/ Address of item that was predecessor to this one
;	C/ Address of item that was successor to this one
; No other ac's affected

DELITQ:	HLRZ B,(A)		; Get this item's predecessor
	HRRZ C,(A)		; Get this item's successor
	HRLM B,(C)		; Fix links between predecessor
	HRRM C,(B)		;  and successor
	SETZM (A)		; Clear links in deleted item
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 113

; Miscellaneous subroutines

SWAPCD                                                                 |

; Flush packet buffer queue
;	A/ Address of queue header
; Returns +1 always.
; Caller must do any necessary race prevention
; Clobbers A-D, PB

FSHPBQ:	HRLM A,0(P)		; Save pointer to queue header
FSHPB1:	PUSHJ P,REMITQ		; Remove item from head of queue
	 POPJ P,		; Queue empty, done
	MOVEI PB,-PBIOBQ(B)	; Got one, set pointer
	MOVSI A,(PBLCKF)	; Is packet buffer locked?
	TDNE A,PBSIZE(PB)
	 PUSHJ P,UNLKPB		; Yes, unlock it
	PUSHJ P,RELPKT		; Release packet buffer
	HLRZ A,0(P)		; Restore queue header pointer
	JRST FSHPB1		; Repeat till queue empty


; Trim unlocked packet buffer and liberate excess
; Callable only from process level
;	PB/ Packet buffer ptr
; Returns +1 always
; Clobbers A-D

TRMUPB:	LDB A,PUPLEN		; Get Pup Length (bytes)
	ADDI A,4*PBHEAD+3	; Add overhead and convert to words
	LSH A,-2
	HRRZ B,PBSIZE(PB)	; Get current size of packet buffer
	SUBI B,(A)		; Compute excess
	CAIG B,^D20		; Worth releasing excess?
	 POPJ P,		; No, forget it
	HRRM A,PBSIZE(PB)	; Reduce size of packet
	PUSH P,PB		; Save packet buffer ptr
	ADDI PB,(A)		; Make ptr to excess block
	MOVEM B,PBSIZE(PB)	; Put size at head of excess
	PUSHJ P,RELPKT		; Release excess block
	POP P,PB		; Restore original PB ptr
	POPJ P,


RESCD                                                                  |

; Trim locked packet buffer and put excess on FREOBQ to be freed
; Callable only from interrupt level
;	PB/ Packet buffer ptr
; Returns +1 always
; Clobbers A, B

TRMLPB:	LDB A,PUPLEN		; Get Pup Length (bytes)
	ADDI A,4*PBHEAD+3	; Add overhead and convert to words
	LSH A,-2
	HRRZ B,PBSIZE(PB)	; Get current size of packet buffer
	SUBI B,(A)		; Compute excess
	CAIG B,^D20		; Worth releasing excess?
	 POPJ P,		; No, forget it
	HRRM A,PBSIZE(PB)	; Reduce size of packet
	PUSH P,PB		; Save packet buffer ptr
	ADDB PB,A		; Point to first word of excess
	HRLI B,(PBLCKF)		; Set locked flag
	MOVEM B,PBSIZE(PB)	; Put size at head of excess
	TRNE PB,777		; Split other than at page boundary?
	 PUSHJ P,MLKMCA		; Yes, lock start of excess block      |
	PUSHJ P,RELPBI		; Release excess block                 |
	POP P,PB		; Restore original PB ptr              |
	POPJ P,                                                        |
; Lock monitor page known to be in core and assigned                   |
; Page must be private to the monitor map.                             |
; Call with monitor virtual address in 1                               |
                                                                       |
;This is here instead of in pagem to minimize changed modules          |
                                                                       |
MLKMCA:	LSH 1,-9		; Convert address to page #            |
	SKIPE 1,MMAP(1)		; Get monitor entry for page           |
	TLNE 1,(NCORTM)		 ;Error if not in core                 |
	 BUG(HLT,MLKMC2,<MLKMCA: Page not monitor private or not in core>)
                                                                       |
	MOVSI 2,(PLKV)		; Ok, increment lock count             |
	ADDB 2,CST1(1)	                                               |
	TLNE 2,(-PLKV_1)	; Was page previously locked?          |
	 JRST MLKMC3                                                   |
	AOS LOKPGS		; No, increment # of locked pages      |
	AOS BALSHC                                                     |
	AOS GNPBAS                                                     |
	AOS SUMNR                                                      |
MLKMC3:	AOS LOKSUM		; Increment total # of locks           |
	RET                                                            |
^L                                                                     |


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 114

SWAPCD                                                                 |

; Lock packet buffer
;	PB/ Packet Buffer pointer
; Returns +1
; Callable only from process level
; Clobbers A

LOCKPB:	MOVSI A,(PBLCKF)	; Make sure not already locked
	TDNE A,PBSIZE(PB)
	 BUG(HLT,LOCKPZ,<LOCKPB: Attempt to lock packet buffer already locked>)
                                                                       |
	IORM A,PBSIZE(PB)	; Mark locked
	MOVEI A,0(PB)		; Lock page in which PB starts
	PUSHJ P,MLKMA##
	HRRZ A,PBSIZE(PB)	; Get length of PB
	ADDI A,-1(PB)		; Compute adr of last word in PB
	ANDI A,777000		; Find start adr of page
	CAILE A,(PB)		; Does PB cross page boundary?
	 PUSHJ P,MLKMA##	; Yes, lock page in which PB ends
	POPJ P,


RESCD                                                                  |

; Unlock packet buffer
;	PB/ Packet Buffer pointer
; Returns +1
; Must be called NOSKED, INSKED, CHNOFF, or at interrupt level
; Clobbers A

UNLKPB:	MOVSI A,(PBLCKF)	; Make sure really locked
	TDNN A,PBSIZE(PB)
	 BUG(HLT,UNLKPZ,<UNLKPB: Attempt to unlock packet buffer not locked>)
                                                                       |
	ANDCAM A,PBSIZE(PB)	; Mark unlocked
	MOVEI A,0(PB)		; Unlock page in which PB starts
	PUSHJ P,MULKMP##
	HRRZ A,PBSIZE(PB)	; Get length of PB
	ADDI A,-1(PB)		; Compute adr of last word in PB
	ANDI A,777000		; Find start adr of page
	CAILE A,(PB)		; Does PB cross page boundary?
	 PUSHJ P,MULKMP##	; Yes, unlock page in which PB ends
	POPJ P,
^L


; PUP.MAC.132 & PUP.MAC.1 28-Sep-78 1202	PAGE 115

; Make Error Pup out of Pup about which it is complaining
;	PB/ Packet buffer ptr (packet buffer must be big enough)
;	A/ Error type
;	B/ String ptr to error text
; Returns +1:  Don't send Error
;	+2:  Error ready to be sent
; Clobbers A-D

MAKERR:	LDB C,PUPTYP		; Get existing Pup Type
	CAIN C,PT.ERR		; Already of type Error?
	 POPJ P,		; Yes, don't give Error for Error
	LDB C,PPUPDH		; Check destination host
	JUMPE C,CPOPJ##		; Don't respond to broadcast Pups
	MOVSI C,PBHEAD(PB)	; Make BLT pointer
	HRRI C,PBCONT(PB)	; Copy header into contents
	BLT C,PBCONT+<PBCONT-PBHEAD>-1(PB)
	LSH A,^D20		; Left-justify Error type
	MOVEM A,PBCONT+<PBCONT-PBHEAD>(PB)  ; Store type, zero arg
	MOVE A,[POINT 8,PBCONT+<PBCONT-PBHEAD>+1(PB)]
	TLC B,-1		; String arg lh = -1?
	TLCN B,-1
	 HRLI B,(POINT 7)	; Yes, make standard byte ptr
MAKER1:	ILDB C,B		; Get byte from string
	JUMPE C,MAKER2		; Jump if end
	IDPB C,A		; Store in Pup
	JRST MAKER1

MAKER2:	MOVEI B,@A		; Compute address of last word
	SUBI B,PBHEAD-1(PB)	; Compute # 36-bit words used
	LSH B,2			; Convert to bytes
	LSH A,-^D33		; Get bytes not used in last word
	SUBI B,(A)		; Compute Pup Length
	ADDI B,2		; Include checksum
	DPB B,PUPLEN		; Store it
	MOVEI A,PT.ERR		; Set Pup Type = Error
	DPB A,PUPTYP
	SETZ A,			; Zero Transport Control
	DPB A,PUPTCB
	PUSHJ P,SWPPRT		; Swap source and dest ports
	PUSHJ P,GPTCKS		; Get pointer to Pup Checksum
	SETO A,			; Store -1 to mean unchecksummed
	DPB A,B
	RETSKP			; Return +2                            |


; Swap Source and Destination Ports in Pup
;	PB/ Packet buffer pointer
; Returns +1 always
; Clobbers A, B

SWPPRT:	MOVE A,PBHEAD+2(PB)	; Get dest net/host/high socket
	MOVE B,PBHEAD+3(PB)	; Get dest low socket
	LSH A,-4		; Concatenate socket
	LSHC A,-^D16		;  and right-justify dest net/host
	EXCH B,PBHEAD+4(PB)	; Exchange source and dest sockets
	LSH A,^D20		; Left-justify dest net/host
	LSH B,-4		; Right-justify source socket
	ROTC A,-^D16		; Concatenate src low skt to dest net/host
	EXCH A,PBHEAD+3(PB)	; Exchange for dst low skt, src net/host
	LSH A,-4		; Right-justify
	LSH B,^D20		; Left-justify source high socket
	LSHC A,-^D16		; Concatenate src net/host/high skt
	MOVEM B,PBHEAD+2(PB)	; Store in header
	POPJ P,

PSIRQF:	NOSKED                                                         |
	CALL PSIRQ                                                     |
	OKSKED                                                         |
	RET                                                            |
                                                                       |
                                                                       |
;RS PRSEND,0		; End of Pup resident storage                  |
;NR PNREND,0		; End of Pup nonresident storage               |
                                                                       |
	TNXEND                                                         |
	END
