;<PUP>PUPFTP.MAC;11  8-Sep-81 13:11:20, Edit by SCHOEN
; LIST command now has OUTPUT (to file) subcommand,
;  all output from LIST now buffered on a per-line basis
; OPNCON checks net status (PUPON) before attempting connection
;<PUP>PUPFTP.MAC;6	26-Jan-81 10:56:27	Edit by SCHOEN
; On Tops20, don't clobber terminator to filename input after
; call to GETJFN## in C.RET6.
;<PUP>PUPFTP.MAC;6	21-Jan-81 12:28:50	Edit by SCHOEN
; Modify C.CONN, C.DIRE, C.BYTE, C.EOL, C.TYPE so they can be 
; called from PROCNO
;<PUP>PUPFTP.MAC;6	20-Jan-81 20:19:20	Edit by SCHOEN
; Make Tenex/Tops20 runtime selectable
; Use routines from PFUDIR.MAC to read PUP network directory
;  and create command table for OPEN command
; Use newly defined attributes under OP-SYS to replace hardwired
;  table of TWENEX hosts on the network
; Use newly defined attributes under SERVICES to check for
;  lineprinter on remote host (LPT/PRINT command)
;<PUP>PUPFTP.MAC;5	24-Nov-80 13:39:34	Edit by SCHOEN
; Implement PRINT (LPT) command
;<PUP>PUPFTP.MAC;4	4-Sept-80 11:54:11	Edit by SCHOEN
; Implement auto retrieve
;<PUP>PUPFTP.MAC;3	3-Sept-80 8:50:13   Edit by SCHOEN
; Implement lower fork runnable option of PUPFTP.  Start at 
; EntVec+2, pass commands via shared page (SHRPAG)
; only auto store implemented
;<PUP>PUPFTP.MAC;2     3/21/80			EDIT BY RINDFLEISCH
; Converted MAXC defaults to SUMEX
;<PUP>PUPFTP.MAC;26     4-NOV-79 12:35:06    EDIT BY TAFT
; Revise MAXTAB
; Set file creation date from incoming property list during Retrieve
;<PUP>PUPFTP.MAC;25     2-SEP-79 16:00:11    EDIT BY TAFT
;<PUP>PUPFTP.MAC;24    28-AUG-77 17:39:38    EDIT BY TAFT
; Fix "Rename" to send default directory in both property lists
;<PUP>PUPFTP.MAC;23    24-JUL-77 16:52:33    EDIT BY TAFT
; Repair buggy NOUT in List command
;<PUP>PUPFTP.MAC;22     3-JUN-77 11:23:07    EDIT BY TAFT
; Add "List" and "Rename" commands
;<PUP>PUPFTP.MAC;19     2-JUN-77 19:16:37    EDIT BY TAFT
; Split out some subroutines into separate module PFUUTL.MAC
;<PUP>PUPFTP.MAC;18    12-APR-77 10:39:42    EDIT BY TAFT
; Move VERTXT here
; Add "Exec" and "Halt" commands
;<PUP>PUPFTP.MAC;17     2-APR-77 16:49:49    EDIT BY TAFT
; Add dummy routines for mail-related properties
;<PUP>PUPFTP.MAC;16    19-MAR-77 20:04:57    EDIT BY TAFT
; Add "Delete" command
; Add "Preserve Version"
; Add "No" prefix for "Debug" and "Preserve"
; Straighten out who clobbers what property lists.
;<PUP>PUPFTP.MAC;14    19-MAR-77 13:46:36    EDIT BY TAFT
; Fix crash caused by typing in ";?"
;<PUP>PUPFTP.MAC;13    18-MAR-77 18:09:13    EDIT BY TAFT
; Add REFILL procedure for property list parser
;<PUP>PUPFTP.MAC;12    18-MAR-77 17:18:12    EDIT BY TAFT
; Just send EOC when SCNPRP fails since SCNPRP now generates the
; appropriate "No" response internally.
;<PUP>PUPFTP.MAC;11    15-MAR-77 19:25:28    EDIT BY TAFT
; Change "Selective" to "Automatic", add "List" and "Version".
; "Quit" now closes connection.
; Call "Login" command automatically in appropriate places.
; Default user name in "Login".
; Add Tenex-paged type
; Add kludge to make Tenex-paged the default when connect to Maxc
;<PUP>PUPFTP.MAC;8    10-MAR-77 14:37:48    EDIT BY TAFT
; Break out major pieces of the program:
; PUPDEF.MAC -- definitions shared by PUPFTP and PUPSRV
; PFUDEF.MAC -- definitions specific to PUPFTP
; PFUCMD.MAC -- keyboard command interpreter
; PFUPRP.MAC -- property list parser
; PUPXFR.MAC -- data transfer routines, shared with PUPSRV
; PUPUUO.MAC -- UUO handler, shared with PUPSRV
; What remain are the top-level command handlers and various
; subroutines.
;<PUP>PUPFTP.MAC;5     8-APR-76 01:53:54    EDIT BY TAFT
; Make "Debug" toggle the debug flag on and off
; Add command for setting eol convention
; Add common procedure GNTPAR for generating type, byte size, eol
; convention properties
;<PUP>PUPFTP.MAC;3    25-MAR-76 22:38:34    EDIT BY TAFT
; Add "Close" command (equivalent to "Disconnect")
;<PUP>PUPFTP.MAC;2    25-MAR-76 00:56:33    EDIT BY TAFT
; Send Type and Byte-Size in "Retrieve" property list if we have them
; Properly handle error returns from INKEY

; Copyright 1979 by Xerox Corporation

	TITLE PUPFTP -- PUP FTP USER PROGRAM
	SUBTTL E. A. Taft / January, 1976

	SEARCH PUPDEF,PFUDEF,SYSDEF
	SEARCH MONSYM
	USEVAR FTPVAR,FTPPVR


VERTXT:	ASCIZ /1.13 26-Jan-81/


; Assemble Mark names and flags

DEFINE XN(SYM,TYPE,NAME,FLAGS) <
REPEAT TYPE-<.-MRKNAM>,<0>
	FLAGS + [ASCIZ /NAME/]
>
DEFINE XS(SYM,TYPE,NAME,FLAGS) <
REPEAT TYPE-<.-MRKNAM>,<0>
	1B0+FLAGS + [ASCIZ /NAME/]
>

MRKNAM::MARKS

; Define commands for lower fork runnable version
; Command name in the form RVxxxx, where xxxx is SYM
DEFINE XN(SYM,TYPE,NAME,FLAGS) <
	RV'SYM==TYPE
>
DEFINE XS(SYM,TYPE,NAME,FLAGS) <
	RV'SYM==0
>
	MARKS


; Assemble command dispatch tables

DEFINE X(NAME,HELP,FLAGS) <
	[ASCIZ /NAME/] ,, C.'NAME
>

CMDDSP:	COMMANDS

NCMDS==.-CMDDSP		; Length of main command table

AUTDSP:	AUTCMDS

NAUTCM==.-AUTDSP	; Length of "Automatic" command table

NODSP:	NOCMDS

NNOCMD==.-NODSP		; Length of "No" command table


; Assemble flags and help table

DEFINE X(NAME,HELP,FLAGS) <
	<FLAGS> + [ASCIZ /HELP/]
>

CMDHLP:	COMMANDS
; -----------------------------------------------------------------
;	Entry vectors
; -----------------------------------------------------------------

ENTVEC:	JRST PUPFTP		; Primary
	JRST PUPFTP		; Reenter
	JRST RUNFTP		; Entry if run as lower fork
NVEC==.-ENTVEC			; Length of entry vector

; Once only code to initialize PUPFTP entry vectors
START:	RESET
	MOVE P,[IOWD STKLEN,STACK]  ; Setup stack
	SETZ F,			; Clear flags
	MOVE A,[112,,11]
	CALLI A,41		; GETAB
	 MOVEI A,30000		; Assume TENEX
	SETZM IFT20
	CAIN A,40000		; Is it DEC20?
	 SETOM IFT20		; Yes
	MOVEI A,400000
	MOVE B,[NVEC,,ENTVEC]
	SEVEC
	HRROI A,[ASCIZ/Entry vector: PC/]
	PSOUT
	MOVEI A,101
	MOVEI B,(B)
	MOVE C,[1B2+6B17+10B35]
	NOUT
	 JFCL
	HRROI A,[ASCIZ/, length /]
	PSOUT
	MOVEI A,101
	MOVEI B,NVEC
	MOVEI C,^D10
	NOUT
	 JFCL
	HRROI A,[ASCIZ/
OK to SSAVE/]
	SKIPE IFT20
	HRROI A,[ASCIZ/
OK to SAVE/]
	PSOUT
	HALTF
	JRST ENTVEC

; -----------------------------------------------------------------
;	Lower fork runnable startup.  Commands from shared page
; -----------------------------------------------------------------

RUNFTP::RESET
	MOVE P,[IOWD STKLEN,STACK]
	SETZ F,
	TLO F,(RUNF)		; Say this is PUPFTP lower fork version
	JRST PUPFT1		; Join common initialization code

; Lower fork version command loop
; Commands are passed through RNCMND by the superior fork.
; PUPFTP SETOMs the command word when it is done with a function.
; Thus, the superior fork should wake up periodically and attempt
; to "get" the command word via the standard lock test:
;	AOSE RNCMND
;	 JRST <wait a time>
;	<got the command word>
;
; If PUPFTP is awaiting confirmation, then RNSTAT will NOT be zero.
; This means PUPFTP wants confirmation, a file name, etc.  RNSTAT
; will contain the code of PUPFTP's request.  If RNSTAT IS 0, then
; PUPFTP is done with a command.  The request codes are defined in
; both PFUDEF.MAC and <DOC>PUPFTP.PROGRAM-CALLABLE.

; The commands are, strangely enough, the MARK types used internally
; by PUPFTP and PUPSRV.  The symbols RVxxxx are derived from the MARKS
; MACRO defined in PUPDEF and expanded in the beginning of PUPFTP.
; Since MARKS contains certain non-commands (yes, version, mailbox-
; exception), the XS macro has been defined to expand these to 0, 
; and 0 is taken as a noop command.

; See PFUDEF.MAC for addresses of shared page symbols
; RNCMND is the command word
; RNSTAT contains status information returned by PUPFTP

; The following are strings, 39 characters long if not specified

; RNERR contains error strings generated by PUPFTP, 80 characters long
; RNHOST contains the host name, and is supplied by the user
; RNUNAM contains user name
; RNUPAS contains user password
; RNCNAM contains connected directory name
; RNCPAS contains connected directory password
; RNVERS contains version numbers in case preserving versions numbers
; RNTYPE contains transfer type (0-unspec, 1-text,2-binary,3-paged)

; Then follow four file name blocks, RNFIl1 - RNFIL4.  They are filled
; in order of their use during an interaction, either by the user or
; by PUPFTP.  

; To do an automatic send of a file group (same names on remote site),
; fill these locations with:
;	RNCMND := RVSTOR
;	RNFIL1 := <filegroup>

; To send a single file to another site under a different name, do:
;	RNCMND := -1,,RVSTOR
;	RNFIL1 := <local file name>
;	RNFIL2 := <remote file name>

; Dispatch table for commands
DEFINE XN(SYM,TYPE,NAME,FLAGS),<
	IFDEF R.'SYM, <R.'SYM>
	IFNDEF R.'SYM,<LFKWT>
>
DEFINE XS(SYM,TYPE,NAME,FLAGS) <
	LFKWT
>

LFKDSP:	MARKS

LFKLP::	MOVE A,[RNERR,,RNERR+1]
	SETZM RNERR
	BLT A,RNERR+17
	TRO F,AUTOF
	MOVE A,RNCMND		; Get command
	SKIPG A			; Want automatic command?
	TRZ F,AUTOF		; No
	JUMPE A,LFKWT		; Nothing to do
	SETZM RNSTAT		; No error occurred yet
	PUSHJ P,@LFKDSP-1(A)

LFKWT:	SKIPN RNSTAT
	 SETZM RNSTAT
	SETOM RNCMND
	HALTF
	JRST LFKLP

; This code obsolete!
; Here to wake up by interrupt
LFKWAK:	MOVE A,CH3PC		; Change the return PC
	HRRI A,LFKLP
	MOVEM A,CH3PC
	DEBRK			; Leave interrupt routine
; ****

; -----------------------------------------------------------------
;	Main loop and user command handling
; -----------------------------------------------------------------

; Start of program

PUPFTP::RESET
	MOVE P,[IOWD STKLEN,STACK]  ; Setup stack
	SETZ F,			; Clear flags

PUPFT1:	MOVSI D,-<ELSLOC-ILSLOC>/1000  ; Set count of storage pages
	SETO A,			; Delete page
	MOVSI B,400000		; This fork
	HRRI B,ILSLOC/1000(D)	; Unmap and delete storage page
	SETZ C,
	PMAP
	AOBJN D,.-2

	MOVEI A,400000		; Get capabilities
	RPCAP
	TRNE C,1B18+1B19	; Wheel or operator?
	 TLO F,(ENABLF)		; Yes, remember so

	MOVE A,[112,,11]
	CALLI A,41		; Determine operating system
	 MOVEI A,30000		; Assume TENEX
	SETZM IFT20
	CAIN A,40000		; Is it DEC20?
	 SETOM IFT20		; Yes

	GJINF
	HRRZ B,A		; Assume Tenex
	SKIPE IFT20		; Is it?
	MOVE B,A		; no
	HRROI A,USRNAM		; Generate default user name
	DIRST
	 PUSHJ P,SCREWUP

	PUSHJ P,GTNTD##		; Read the network directory

	PUSHJ P,INIPSI		; Initialize psi system

	TLNE F,(RUNF)		; Check for lower fork version
	 JRST LFKLP		; Get commands from the lower fork
	MOVEI A,100		; Get terminator of command used
	BKJFN			;  to start subsystem
	 JRST COMLP
	PBIN
	CAIE A," "		; Space?
	 JRST COMLP		; No, prompt for first command
	PUSHJ P,INIEDT##	; Yes, omit prompt, init editor
	PUSHJ P,C.OPE0		; Fake "Open" command

; Main command loop
COMLP:	PUSHJ P,CRIF##		; Go to left margin
	PUSHJ P,INIEDT##	; Initialize command editor
	PROMPT <*>		; Print prompt
	HRRI F,0		; Clear temporary flags

	MOVE A,[-NCMDS,,CMDDSP]	; Setup ptr to dispatch table
	PUSHJ P,INKEY##		; Input and lookup command keyword
	 JRST COMLP2		; None found or other error

; Found command.  Check flags before dispatching
	MOVE P1,0(A)		; Get dispatch word
	MOVE C,CMDHLP-CMDDSP(A)	; Get flags and help string

	TLNE C,(SPCREQ)		; Space required after command?
	TLNE D,(C.SPAC)		; Yes, was there one?
	 CAIA			; Yes or not needed
	 JRST COMLP3		; No and needed, give error

	TLNE C,(CONREQ)		; Required to have connection open?
	TLNE F,(CONOPF)		; Yes, is it?
	 CAIA			; No or not needed
	 JRST [	ERROR <%/Please "Open" a connection first>
		JRST COMLP]

	TLNN C,(PRECNF)		; Confirm command before dispatch?
	 JRST .+3		; No
	PUSHJ P,CONFRM##	; Yes, await confirming EOL
	 JRST COMLP		; Not confirmed

	PUSHJ P,0(P1)		; Dispatch to command handler
	 CAI			; Some handlers return +2
	JRST COMLP		; Back to top

; Here if command not found or other error
COMLP2:	TLNE D,(C.CDEL)		; Command delete?
	 JRST COMLP		; Yes, just give another prompt
	SKIPE WRDLEN##		; Null word input?
	 JRST COMLP4		; No
	TLNE D,(C.CEOL)		; Yes, followed by eol?
	 JRST COMLP		; Yes, just prompt for more input
	LDB A,CMDBYT##		; No, get terminator
	CAIN A,";"		; Start of comment?
	 JRST [	MOVSI B,(C.ALPH+C.NUM+C.PUNC+C.SPAC+C.CTRL)  ; Yes
		HRROI A,[ASCIZ /Comment/]
		PUSHJ P,INWORD## ; Input and discard rest of line
		 JRST COMLP	; Line delete
		JRST COMLP]	; Normal (must be eol), done
COMLP3:	ERROR < ? >		; Not legal syntax, complain
	JRST COMLP		; Prompt for more input

; Finally, try to parse first word as a host name
COMLP4:	TLNE F,(CONOPF)		; Is there already a connection?
	 JRST COMLP3		; Yes, don't try to parse host name
	PUSHJ P,[		; Get stack level right
		MOVEM P,WRDPDP## ; Fake up INWORD state to look
		MOVEI C,C.OPE1	;  like it was called from C.OPEN
		MOVEM C,WRDXIT##
		MOVSI C,(C.ALPH+C.NUM+C.HSTC)
		MOVEM C,WRDATR##
		LDB A,CMDBYT##	; Recover terminator
		TLNN D,(C.HSTC)	; Was it punct legal inside name?
		 JRST C.OPE2	; No, enter "Open" code
		IBP CMDBYT##	; Yes, include char in word
		AOS WRDLEN##
		JRST APWORD##]	; Get more input from user
	JRST COMLP		; When done, resume main loop

; Here for command error if delete not typed
DELERR:	TLNE D,(C.CDEL)
	 POPJ P,

; Here for garden-variety command errors from routines called
; from the main loop
CERR:	ERROR < ? >,1



; "Help" -- print out more detailed help message

C.HELP:	PUSHJ P,CRIF##		; Go to left margin
	MOVSI A,-NCMDS		; Init table counter
C.HEL1:	HLRO B,CMDDSP(A)	; Get command name
	HRRO C,CMDHLP(A)	; Get help text
	TYPE < %2S %3S%/>	; Print both
	AOBJN A,C.HEL1		; Repeat for all commands
	TLNN F,(CONOPF)		; Connection open?
	 TYPE < host-name%/>	; No, host names are legal, then
	TYPE < ; comment%/>	; Additional info
	POPJ P,


; "Quit"

C.QUIT:	NOISE <and close any open connection>
	TLNE F,(CONOPF)		; Connection open?
	 PUSHJ P,C.DIS1		; Yes, close it
	CAIA

; "Halt"

C.HALT:	NOISE <without closing any connection>
	HALTF			; Exit PUPFTP
	POPJ P,			; Back to command loop if resumed


; "Debug" -- turn on verbose printouts and other information

C.DEBU:	NOISE <printout enabled>
	PUSHJ P,CONFRM##	; Request confirmation
	 POPJ P,		; Forget it
	TRNE F,NOPREF		; Ok, prefixed by "No"?
	 TLZA F,(DEBUGF)	; Yes, turn debugging off
	 TLO F,(DEBUGF)		; No, turn it on
	POPJ P,


; "Version"

C.VERS:	PUSHJ P,CRIF##
	HRROI A,VERTXT
	SKIPE IFT20
	 JRST C.VER0
	TYPE < Tenex Pup FTP User %1S>
	POPJ P,

C.VER0:	TYPE < Tops20 Pup FTP User %1S>
	POPJ P,


; "Exec"

C.EXEC:	MOVSI A,(1B2+1B17)	; Old file
	HRROI B,[ASCIZ /<SYSTEM>EXEC.SAV/]
	SKIPE  IFT20		; Tops20?
	HRROI B,[ASCIZ /SYSTEM:EXEC.EXE/] ;Yes
	GTJFN
	 ERROR <Exec not available: %1J>,1
	MOVE B,A		; Save jfn
	MOVSI A,(1B1)		; Transmit capabilities
	CFORK
	 JRST [	ERROR <%1J>
		MOVE A,B
		RLJFN
		 PUSHJ P,SCREWUP
		POPJ P,]
	MOVSI A,(A)		; Get fork,,jfn
	HRRI A,(B)
	GET			; Get file into fork
	HLRZ A,A		; Fork handle
	SETZ B,			; Entry point 0
	SFRKV			; Start fork
	WFORK			; Wait for it to terminate
	KFORK			; Kill it
	POPJ P,


; "No" prefix for other commands

C.NO:	MOVE A,[-NNOCMD,,NODSP]	; Setup ptr to dispatch table
	PUSHJ P,INKEY##		; Input following keyword
	 JRST DELERR		; Line delete or error
	TRO F,NOPREF		; Ok, set "No" prefix flag
	MOVE D,0(A)		; Get dispatch
	JRST 0(D)		; Enter regular command handler


; Unimplemented commands
UNIMP:	ERROR <%/Not implemented yet>,1

; "Disconnect"

C.CLOS:	NOISE <current connection>
	JRST .+2
C.DISC:	NOISE <from remote host>
	PUSHJ P,CONFRM##	; Confirm command
	 POPJ P,		; Not confirmed
	JRST C.DIS1

; Here from most other places when "End" encountered
DISCON:	TYPE <Connection terminated by server%/>
	JRST C.DIS1		; Go disconnect

; Here to handle EOC syncronization error
UNSEOC:	TYPE <Unsynchronized EOC -- aborting connection%/>
	HRRZ A,CONJFN		; Abort the connection
	MOVEI B,25
	SETZ C,
	HRROI D,[ASCIZ /FTP sequence error/]
	MTOPR

R.CLOS:
R.DISC:
C.DIS1:	HRRZ A,CONJFN		; Get output JFN
	CLOSF			; Close connection
	 JRST [	TYPE <Timeout during disconnect sequence%/>
		HRRZ A,CONJFN	; Failed, probably timeout
		SETZ B,		; Clear error flags
		SDSTS
		CLOSF		; Try again
		 PUSHJ P,SCREWUP
		JRST .+1]
	HLRZ A,CONJFN		; Now close input JFN
	CLOSF
	 PUSHJ P,SCREWUP	; Can't fail
	SETZM CONJFN		; Forget JFNs
	TLZ F,(CONOPF)		; Say no connection open
	POPJ P,


; "Preserve"
; At present only "Preserve Version (numbers)" is implemented

C.PRES:	HRROI A,[[ASCIZ /VERSION/],,0]
	PUSHJ P,INKEY##		; Input following keyword
	 JRST DELERR		; Line delete or error
	NOISE <numbers>
	PUSHJ P,CONFRM##	; Input confirmation
	 POPJ P,		; Forget it
	TRNE F,NOPREF		; Ok, have "No" prefix?
	 TLZA F,(PREVRF)	; Yes, turn off preserving versions
	 TLO F,(PREVRF)		; No, turn it on
	POPJ P,

; "Byte" -- supply byte size for unknown cases

C.BYTE::NOISE <size is>
	HRROI A,[ASCIZ /Decimal number 0-36/]
	MOVSI B,(C.NUM)		; Allow numbers only
	PUSHJ P,INWORD##	; Input a word
	 POPJ P,		; Line delete
	MOVE A,WRDBYT##		; Get string ptr to word
	MOVEI C,^D10		; Decimal radix
	NIN			; Convert to number
	 JRST CERR
	CAIL B,0		; Ensure in range
	CAILE B,^D36
	 JRST CERR
	HRLM B,0(P)		; Ok, save it
	PUSHJ P,CONFRM##	; Confirm command
	 POPJ P,		; Line delete
	HLRZ B,0(P)		; Ok, recover byte size
	MOVEM B,DEFPRP+P.BYTE	; Set default byte size
	MOVEM B,FILPRP+P.BYTE	; Also fix up this transaction (for PROCNO)
	JRST SKPRET		; Return +2 for PROCNO


; "Type" -- supply type for unknown cases

C.TYPE::MOVE A,[-4,,TYPDSP]	; Set ptr to keyword table
	PUSHJ P,INKEY##		; Input following keyword
	 JRST DELERR		; Line delete or error
	HRRZ A,0(A)		; Got it, get type code
	HRLM A,0(P)		; Save it
	PUSHJ P,CONFRM##	; Confirm command
	 POPJ P,		; Line delete
	HLRZ A,0(P)		; Ok, recover type code
	MOVEM A,DEFPRP+P.TYPE	; Set default type
	MOVEM A,FILPRP+P.TYPE	; Also for current store
	JRST SKPRET		; Return +2 for PROCNO

TYPDSP:	[ASCIZ /BINARY/],,2
	[ASCIZ /PAGED/],,3
	[ASCIZ /TEXT/],,1
	[ASCIZ /UNSPECIFIED/],,0


; "EOL" -- supply end of line convention for unknown cases

C.EOL::	NOISE <convention>
	MOVE A,[-3,,EOLDSP]	; Set ptr to keyword table
	PUSHJ P,INKEY##		; Input following keyword
	 JRST DELERR		; Line delete or error
	HRRZ A,0(A)		; Got it, get eol code
	HRLM A,0(P)		; Save it
	PUSHJ P,CONFRM##	; Confirm command
	 POPJ P,		; Line delete
	HLRZ A,0(P)		; Ok, recover eol code
	MOVEM A,DEFPRP+P.EOLC	; Set default eol convention
	MOVEM A,FILPRP+P.EOLC	; Set current eol convention
	JRST SKPRET		; return +2 for PROCNO

EOLDSP:	[ASCIZ /CR/],,0
	[ASCIZ /CRLF/],,1
	[ASCIZ /TRANSPARENT/],,2

; "Open" -- initiate connection to foreign port

C.OPE2:	TRO F,TEMPF2
C.OPEN:	TLNE F,(CONOPF)		; Is there already a connection?
	 ERROR <There is already an open connection>,1
	TRNN F,TEMPF2		; No noise if called from COMLP
	NOISE <connection to>
C.OPE0:	MOVE A,HOSTAB##		; Point to Host table
	TRZE F,TEMPF2
	 JRST [MOVE C,WRDLEN##
	       PUSHJ P,INKEY0##
		JRST DELERR
	       JRST .+3]
	PUSHJ P,INKEY##		; Parse input
	 JRST DELERR		; Line delete or error
	HLRO B,(A)		; Put host name string pointer into A
	HRROI A,HSTNLY		; Put host only in a safe place
	WRITE <%2S>
	HRROI A,HSTNAM		; Copy name into a safe place
	WRITE <%2S>
	PUSH P,A		; Save the pointer
	HRROI A,HSTNAM		; get address
	MOVE B,[1B0+100B17+TEMP]; Buffer net addresses here
	PUPNM			; Attempt to parse as net address
	 JRST DELERR		; Shouldn't fail
	POP P,A			; Recover tail to HSTNAM
	SKIPN TEMP+1		; Foreign socket specified?
	 WRITE <+FTP>		; No, go to the FTP
	PUSHJ P,CONFRM##	; Confirm command
C.OPE1:	 POPJ P,		; Line delete

	PUSHJ P,OPNCON		; Open the connection
	 POPJ P,		; Failed (message already typed)

; "Open" (cont'd)

; Now do version handshake
	HRROI A,VERTXT		; Ok, set ptr to version text
	SKIPL IFT20		; Tops20?
	 JRST C.OPEX		; No, give Tenex herald
	FTPM(VERS,FTPVER,<Tops20 Pup FTP user %1S>,,EOC)  ; Send it
	JRST C.OPE5

C.OPEX:	FTPM(VERS,FTPVER,<Tenex Pup FTP user %1S>,,EOC)  ; Send it
C.OPE5:	PUSHJ P,GETRSP##	; Get response
	 JRST DISCON		; End
	 JRST UNSEOC		; EOC
	CAIE A,MKVERS		; Correct response?
	 JRST [	HRRO C,MRKNAM(A)  ; No, give error
		TYPE <Improper response "[%3S] %4S" to version query%/>
		JRST C.OPE5]	; Try again
	TYPE( < %4S%/)		; Ok, print server herald
	CAIE B,FTPVER		; Correct protocol version?
	 JRST [	ERROR <Server protocol incompatible -- aborting%/>
		JRST C.DIS1]	; Go disconnect
	PUSHJ P,FLSEOC##	; All ok, scan past EOC
	 JRST DISCON		; End

	PUSHJ P,CKPAGE
	POPJ P,


; Lower fork runnable OPEN connection
R.OPEN:	HRROI A,RNHOST		; Get string ptr to start of word
	MOVE B,[1B0+100B17+TEMP]  ; Buffer net addresses here
	PUPNM			; Attempt to parse as net address
	 JRST [	RUNM (<(A)>,<PUPNM error: %1J>)
		POPJ P,]
	MOVE A,[POINT 7,RNHOST]	; Ok, build string for GTJFN
	ILDB B,A
	JUMPN B,.-1
	BKJFN
	 PUSHJ P,SCREWUP
	SKIPN TEMP+1		; Foreign socket specified?
	 WRITE <+FTP>		; No, append to specification
	PUSHJ P,OPNCON		; Open the connection
	 POPJ P,		; Failed (message already typed)
	HRROI A,VERTXT		; Ok, set ptr to version text
	SKIPL IFT20
	 JRST R.OPEX
	FTPM(VERS,FTPVER,<Tops20 Pup FTP user %1S>,,EOC)  ; Send it
	JRST R.OPE1

R.OPEX:	FTPM(VERS,FTPVER,<Tenex Pup FTP user %1S>,,EOC)  ; Send it
R.OPE1:	PUSHJ P,GETRSP##	; Get response
	 JRST DISCON		; End
	 JRST UNSEOC		; EOC
	CAIE A,MKVERS		; Correct response?
	 JRST R.OPE1		; No, try again
	CAIE B,FTPVER		; Correct protocol version?
 	 JRST [	RUNM (RE.SPI,<Server protocol incompatible -- aborting>)
		JRST C.DIS1]	; Go disconnect
	PUSHJ P,FLSEOC##	; All ok, scan past EOC
	 JRST DISCON		; End

; check for remote host being a Twenex
	PUSHJ P,CKPAGE
	POPJ P,

; Check for foreign host being a TWENEX, and if so set the
; default transfer type to "Paged".
; PUPADR should contain NET,,HOST for remote host
CKPAGE:	MOVE D,[-NPAGTP,,PAGTYP]; Pointer to table of TWENEX compatible OS
	HRROI B,[ASCIZ/OP-SYS/]	; Look under operating system
	HRRO A,(D)		; Try an operating system
	PUSH P,D
	PUSHJ P,CKATTR##
	 JRST [POP P,D
  	       AOBJN D,.-4
	       HRRZ A,DEFPRP+P.TYPE ; Not a paged host. Check current setting
	       CAIN A,3		; Currently paged?
	        SETZM DEFPRP+P.TYPE ; Yes, reset to unspecified
	       POPJ P,]
	POP P,D
	MOVEI A,3
	MOVEM A,DEFPRP+P.TYPE
	TLNN F,(RUNF)
	TYPE <Type defaulted to "Paged"%/>
	POPJ P,

; Table of TWENEX style operating systems
; This may be expanded in the future to include non-twenex systems
; such as Tops-10, WAITS, and ITS
PAGTYP:	[ASCIZ/TENEX/]
	[ASCIZ/TOPS-20/]
NPAGTP==.-PAGTYP

; Make sure remote host is a SERVER
; Call : PUPADR contains NET,,HOST
; Returns +1: not a server
;	  +2: server
; All ACs preserved
CKSRVR: PUSH P,A
	PUSH P,B
	HRROI A,[ASCIZ/SERVER/]
	HRROI B,[ASCIZ/FUNCTION/]
	AOS -2(P)
	PUSHJ P,CKATTR##
	 SOS -2(P)
	POP P,B
	POP P,A
	POPJ P,

; Open Pup connection port
; Assumes foreign port specification in HSTNAM, RNHOST if RUNF
; Returns +1:  Failed, message already printed
;	+2:  Succeeded, nothing printed
;	     input,,output JFNs in CONJFN
; Clobbers A-D

OPNCON:	MOVE A,[SIXBIT/PUPON/]	; Make sure net is running
	SYSGT
	JUMPE B,.+3		; Assume so if table doesn't exist
	SKIPN A			; PUPON .ne. 0 if net is on
	 ERROR <Ethernet is down>,1
	HRROI A,HSTNAM
	MOVE B,[1B0+2B17+C]
	PUPNM
	 ERROR <PUPNM failure: %1J>,1
	MOVEM C,PUPADR##
	SETZM PUPADR##+1

; Make sure host is a server
	HRROI B,HSTNLY		; Prepare an error message
	TLNE F,(RUNF)
	 HRROI B,RNHOST
	PUSHJ P,CKSRVR		; Check for server
	 TYPE < (%2S is not a server.  Proceed at your own risk)%/>

; Do GTJFN stuff
	HRROI A,TEMP		; Build complete name here
	HRROI B,HSTNAM
	TLNE F,(RUNF)
	 HRROI B,RNHOST
	WRITE <PUP:!J.%2S>	; Build the string
	MOVSI A,(1B2+1B17)	; Short form, name from string
	HRROI B,TEMP
	GTJFN			; Get a JFN for the port
	 ERROR <Connect failure: %1J>,1  ; Shouldn't ever fail
	HRLZM A,CONJFN		; Ok, save input JFN
	MOVE B,[8B5+8B17+1B19]	; Bytesize 8, 30-second timeout
	OPENF			; Initiate rendezvous
	 JRST OPNCO4		; Failed

; Now make name string and open same port for output
	CVSKT			; Get local port address
	 PUSHJ P,SCREWUP
	HRROI A,TEMP		; Where to build name
	WRITE <PUP:%3O!A.>	; Start it off
	PUSH P,A
	HLRZ A,CONJFN
	MOVE C,[2,,C]		; Get foreign port address
	GDSTS
	HLRZ B,C		; Separate net and host
	HRRZS C
	POP P,A
	WRITE <%2O#%3O#%4O>	; Append foreign port to string
	MOVSI A,(1B2+1B17)	; Short form, name from string
	HRROI B,TEMP
	GTJFN			; Get a JFN for the port
	 JRST OPNCO6		; Failed (unlikely)
	HRRM A,CONJFN		; Ok, save output JFN
	MOVE B,[8B5+1B20]	; Bytesize 8, open for output
	OPENF
	 JRST OPNCO5		; Failed (unlikely)
	TLO F,(CONOPF)		; Succeeded, remember open
	JRST SKPRET##		; Return +2

; Failure from first OPENF
OPNCO4:	HRLM A,0(P)		; Save error code
	HLRZ A,CONJFN		; Recover JFN
	RLJFN			; Release it
	 PUSHJ P,SCREWUP
	SETZM CONJFN		; Insurance...
	HLRZ A,0(P)		; Recover error code
	CAIN A,OPNX20		; Check for special cases
	 ERROR <Connection attempt timed out>,1
	CAIN A,OPNX21
	 ERROR <Connection attempt rejected by remote host>,1
	ERROR <Connection failure: %1J>,1  ; Catchall

; Failure from second OPENF
OPNCO5:	HRLM A,0(P)		; Save error code
	HRRZ A,CONJFN		; Release the output JFN
	RLJFN
	 PUSHJ P,SCREWUP
	HLRZ A,0(P)		; Recover error code

; Failure from second GTJFN
OPNCO6:	ERROR <Connection failure: %1J>
	HLRZ A,CONJFN		; Get input JFN
	MOVEI B,25		; Abort function
	SETZ C,			; No code assigned
	HRROI D,[ASCIZ /Connection attempt aborted/]  ; Abort text
	MTOPR			; Abort the connection
	CLOSF			; Close the port
	 PUSHJ P,SCREWUP	; Can't fail after abort done
	SETZM CONJFN		; Forget connection JFNs
	POPJ P,			; Take fail return
	
; "Login"
; Also called as a subroutine from PROCNO.
; Returns +2 upon successful completion.

C.LOGI::SETZM TEMP		; Clear temp page
	MOVE A,[TEMP,,TEMP+1]
	BLT A,TEMP+3*<USRSTL/5+1>-1
	TLNN D,(C.SPAC+C.CEOL)	; Terminated by space or EOL?
	 JRST CERR		; No, complain
	TLNE D,(C.CEOL)		; EOL?
	 TRO F,ESCAPF		; Yes, pretend Escape was hit
	NOISE <user>
	HRROI A,[ASCIZ /Remote user name/]
	MOVSI B,(C.ALPH+C.NUM+C.PUNC)  ; Alphanumerics & punct.
	PUSHJ P,INWORD##	; Input a word
	 POPJ P,		; Line delete
	JUMPE C,[TLNN D,(C.ESC)	; Null input ended by escape?
		 JRST CERR	; No, error
		PUSHJ P,BAKBYT##  ; Yes, back up over the escape
		HRROI A,USRNAM	; Supply default user name
		PROMPT <%1S >
		JRST C.LOG1]
	PUSHJ P,ESPACE##	; Print space for escape
	TLNN D,(C.SPAC+C.CEOL+C.ESC)  ; Error if not space or EOL
	 JRST CERR
	CAILE C,USRSTL		; Make sure not too long
	 ERROR <%/Word too long>,1
C.LOG1:	HRROI A,TEMP		; Where to buffer user name
	PUSHJ P,CPYWRD##	; Copy the word that was input
	TLNE D,(C.CEOL)		; End of command?
	 JRST C.LOG5		; Yes
	PUSHJ P,NOECHO##	; No, turn off echoing for next
	NOISE <password>
	HRROI A,[ASCIZ /Password/]
	MOVSI B,(C.ALPH+C.NUM+C.PUNC)
	PUSHJ P,INWORD##	; Input the password
	 POPJ P,		; Line delete
	TRNN F,ESCAPF		; Unless Escape hit
	 PRINT 0(A)		;  print the terminator
	PUSHJ P,ESPACE##	; Print space for Escape
	PUSHJ P,OKECHO##	; Echoing back on
	TLNN D,(C.SPAC+C.CEOL+C.ESC)  ; Error if not space or EOL
	 JRST CERR
	CAILE C,USRSTL		; Make sure not too long
	 ERROR <%/Word too long>,1
	HRROI A,TEMP+<USRSTL/5+1>  ; Where to buffer user password
	PUSHJ P,CPYWRD##	; Copy the word that was input
	LDB A,CMDBYT##		; Get terminating character
	MOVE B,WRDBYT##		; Flush password from command
	MOVEM B,CMDBYT##	;  string (so ^R won't type it)
	IDPB A,CMDBYT##		; Append password terminator
	TLNE D,(C.CEOL)		; End of command?
	 JRST C.LOG5		; Yes
	NOISE <account>
	HRROI A,[ASCIZ /Account/]
	MOVSI B,(C.ALPH+C.NUM+C.PUNC)
	PUSHJ P,INWORD##	; Input the account
	 POPJ P,		; Line delete
	PUSHJ P,ESPACE##	; Print space for Escape
	CAILE C,USRSTL		; Make sure not too long
	 ERROR <%/Word too long>,1
	HRROI A,TEMP+2*<USRSTL/5+1>  ; Where to buffer user account
	PUSHJ P,CPYWRD##	; Copy the word that was input

C.LOG5:	PUSHJ P,CONFRM##	; Await confirming EOL
	 POPJ P,		; Line delete
	MOVE A,[TEMP,,USRNAM]	; Ok, remember all parameters
	BLT A,USRNAM+3*<USRSTL/5+1>-1
	JRST SKPRET##		; Done, signal success

R.LOGI:	HRROI A,RNUNAM		; Copy the name
	HRROI B,USRNAM
	SETZ C,
	SOUT
	HRROI A,RNUPAS		; Copy the password
	HRROI B,USRPSW
	SOUT
	HRROI A,RNUACT		; Copy the account
	HRROI B,USRACT
	SOUT
	POPJ P,


; "Connect"
; Also called as a subroutine from PROCNO
C.CONN::SETZM TEMP		; Clear temp page
	MOVE A,[TEMP,,TEMP+1]
	BLT A,TEMP+2*<USRSTL/5+1>-1
	NOISE <to directory>
	HRROI A,[ASCIZ /Remote directory name/]
	MOVSI B,(C.ALPH+C.NUM+C.PUNC)  ; Alphanumerics & punct.
	PUSHJ P,INWORD##	; Input a word
	 POPJ P,		; Line delete
	PUSHJ P,ESPACE##	; Print space for Escape
	TLNN D,(C.SPAC+C.CEOL+C.ESC)  ; Error if not space or EOL
	 JRST CERR
	TLNE D,(C.CEOL)		; Null input followed by EOL?
	 JUMPE C,C.CON2		; Yes, zap connect parameters
	CAILE C,USRSTL		; Make sure not too long
	 ERROR <%/Word too long>,1
	HRROI A,TEMP		; Where to buffer connect name
	PUSHJ P,CPYWRD##	; Copy the word that was input
	TLNE D,(C.CEOL)		; End of command?
	 JRST C.CON2		; Yes
	PUSHJ P,NOECHO##	; No, turn off echoing for next
	NOISE <password>
	HRROI A,[ASCIZ /Password/]
	MOVSI B,(C.ALPH+C.NUM+C.PUNC)
	PUSHJ P,INWORD##	; Input the password
	 POPJ P,		; Line delete
	TRNN F,ESCAPF		; Unless Escape hit
	 PRINT 0(A)		;  print the terminator
	PUSHJ P,ESPACE##	; Print space for Escape
	PUSHJ P,OKECHO##	; Echoing back on
	TLNN D,(C.SPAC+C.CEOL+C.ESC)  ; Error if not space or EOL
	 JRST CERR
	CAILE C,USRSTL		; Make sure not too long
	 ERROR <%/Word too long>,1
	HRROI A,TEMP+<USRSTL/5+1>  ; Where to buffer password
	PUSHJ P,CPYWRD##	; Copy the word that was input
	LDB A,CMDBYT##		; Get terminating character
	MOVE B,WRDBYT##		; Flush password from command
	MOVEM B,CMDBYT##	;  string (so ^R won't type it)
	IDPB A,CMDBYT##		; Append password terminator
C.CON2:	PUSHJ P,CONFRM##	; Await confirming EOL
	 POPJ P,		; Line delete
	MOVE A,[TEMP,,CONNAM]	; Ok, remember all parameters
	BLT A,CONNAM+2*<USRSTL/5+1>-1
	AOS 0(P)		; EJS, 1/21/81 Ret +2 for PROCNO
	POPJ P,			; Done

; Lower fork connect
R.CONN:	HRROI A,RNCNAM
	HRROI B,CONNAM
	SETZ C,
	SOUT
	HRROI A,RNCPAS
	HRROI B,CONPSW
	SOUT
	POPJ P,


; "Directory" -- supply default directory

C.DIRE::SETZM TEMP		; Zero to detect null case
	HRROI A,[ASCIZ /Default remote directory name/]
	MOVSI B,(C.ALPH+C.NUM+C.PUNC)  ; Alphanumerics & punct.
	PUSHJ P,INWORD##	; Input a word
	 POPJ P,		; Line delete
	PUSHJ P,ESPACE##	; Print space for Escape
	TLNN D,(C.SPAC+C.CEOL+C.ESC)  ; Error if not space or EOL
	 JRST CERR
	CAILE C,USRSTL		; Make sure not too long
	 ERROR <%/Word too long>,1
	HRROI A,TEMP		; Where to buffer directory name
	PUSHJ P,CPYWRD##	; Copy the word that was input
	PUSHJ P,CONFRM##	; Await confirming EOL
	 POPJ P,		; Line delete
	MOVE A,[TEMP,,DEFPRP+P.DIRE]  ; Ok, copy default directory
	BLT A,DEFPRP+P.DIRE+USRSTL/5
	MOVE A,[TEMP,,FILPRP+P.DIRE]	; Also to current xfer
	BLT A,FILPRP+P.DIRE+USRSTL/5
	POPJ P,

; Lower fork default directory not implemented
R.DIRE: POPJ P,


; "Automatic" -- special kind of Retrieve, Store, or Delete

C.AUTO:	MOVE A,[-NAUTCM,,AUTDSP]  ; Setup ptr to dispatch table
	PUSHJ P,INKEY##		; Input following keyword
	 JRST DELERR		; Line delete or error
	TRO F,AUTOF		; Ok, set Automatic flag
	MOVE D,0(A)		; Get dispatch
	JRST 0(D)		; Enter regular command handler


; "Retrieve"
; Also get here on "Automatic Retrieve" with AUTOF on in F

C.RETR:
C.GET:	NOISE <remote file>
	HRROI A,[ASCIZ /Remote filename/]
	MOVSI B,(C.ALPH+C.NUM+C.PUNC+C.SPAC)  ; All printable chars
	PUSHJ P,INWORD##	; Input a word
	 POPJ P,		; Line delete
	TRNE F,ESCAPF		; Ended with Escape?
	 JRST [	ERROR <>	; Yes, can't recognize here
		JRST APWORD##]	; So just ask for more input
	TLNN D,(C.CEOL)		; Ended with eol?
	 JRST CERR		; No, give error
	JUMPE C,CERR		; Also bad if no input
	MOVE A,[DEFPRP,,FILPRP]	; Ok, init file property list
	BLT A,FILPRP+PLSIZE-1
	HRROI A,FILPRP+P.SFIL	; Where to put server filename
	PUSHJ P,CPYWRD##	; Do it

; Generate "Retrieve" command to server
C.RET1:	HRROI A,NETBUF		; Buffer property list here
	HRROI B,FILPRP+P.SFIL	; String ptr to server filename
	WRITE <(Server-Filename %2S)>; Generate property
	MOVEI B,FILPRP		; Default property list
	PUSHJ P,GNTPAR##	; Generate transfer parameters
	PUSHJ P,SNDLGN##	; Send login/connect parameters
	HRROI A,NETBUF		; Where property list is
	FTPM(RETR,,<(%1S)>,,EOC)  ; Send command and property list

; Wait for response
C.RET2:	PUSHJ P,GETRSP##	; Get response
	 JRST DISCON		; End
	 JRST [	TYPE <No files retrieved>
		POPJ P,]
	CAIN A,MKNO		; See if "No"
	 JRST [	ERROR( < %4S%/)	; Report failure to user
		HRLM B,0(P)	; Save "No" code
		PUSHJ P,FLSEOC##  ; Scan past EOC
		 JRST DISCON	; End
		HLRZ B,0(P)	; Recover "No" code
		PUSHJ P,PROCNO##  ; Process "No" code
		 POPJ P,	; Not recoverable, exit
		JRST C.RET1]	; Recoverable, retry
	CAIE A,MKPLST		; Here-is-property-list response?
	 JRST [	HRRO C,MRKNAM(A)  ; No, give error
		TYPE <Improper response "[%3S] %4S" to Retrieve request%/>
		JRST C.RET2]	; Try again
	JRST C.RET4		; Ok, go process

; "Retrieve" (cont'd)

; Loop here after each retrieval
C.RET3:	PUSHJ P,GETRSP##	; Get next command from server
	 JRST DISCON		; End
	 POPJ P,		; EOC, retrieve finished
	CAIE A,MKPLST		; Here-is-property-list response?
	 JRST [	HRRO C,MRKNAM(A)  ; No, give error
		TYPE <Improper response "[%3S] %4S" to Retrieve request%/>
		JRST C.RET3]	; Try again

; Interpret property list, check filename and properties
C.RET4:	MOVE A,[DEFPRP,,FILPRP]	; Copy default property list
	BLT A,FILPRP+PLSIZE-1
	HRROI A,NETBUF		; Where text is
	MOVEI B,FILPRP		; Where to put decoded properties
	PUSHJ P,SCNPRP##	; Interpret property list
	 JRST [	TYPE <Bad property list, one file bypassed%/>
		PUSHJ P,FLSEOC##  ; Scan past EOC
		 JRST DISCON	; End
		FTPM(EOC)	; Return control to server for next file
		JRST C.RET3]	; On to next
	PUSHJ P,FLSEOC##	; Scan past EOC
	 JRST DISCON		; End
	MOVEI A,FILPRP		; Construct Server-Filename if
	PUSHJ P,FIXNAM##	;  there isn't one already
	HRROI A,FILPRP+P.SFIL	; Make string ptr to filename
	MOVE B,FILPRP+P.TYPE	; Make sure type specified,
	CAIN B,2		; and also bytesize if binary
	 SKIPE FILPRP+P.BYTE
	 SKIPN FILPRP+P.TYPE
	  JRST [TYPE <Type/Byte-Size missing, file %1S bypassed%/>
		FTPM(NO,105,<Type/Byte-Size missing>,,EOC)
		JRST C.RET3]

; If "Automatic Retrieve", try to create a local filename using
; just the Name-Body property
	SKIPE FILPRP+P.SFIL	; Name supplied as property?
	TRNN F,AUTOF		; Automatic retrieve?
	 JRST C.RET6		; No, go ask
	TYPE <%1S (to local file) >; Type server filename for user
C.RET5:	MOVSI A,(1B0+1B17)	; No, name from string, short form
	TLNE F,(PREVRF)		; Want to preserve versions?
	 HRR A,FILPRP+P.VERS	; Yes, set default version
	HRROI B,FILPRP+P.NAMB	; String in Name-Body property
	GTJFN			; Get JFN for local output file
	 JRST [	HRROI B,FILPRP+P.NAMB  ; Failed, print string as is
		ERROR <%2S%/ %1J%/>
		JRST C.RET6]	; Go ask user for name
	HRRZM A,DSTJFN		; Ok, store file JFN
	TYPE <%1F%/>		; Type the filename
	JRST C.RET7		; Go try to open it

; "Retrieve" (cont'd)

; If not "Automatic Retrieve" or default filename didn't work,
; get local filename from user
C.RET6:	PUSHJ P,INIEDT##	; Initialize editor
	HRROI A,FILPRP+P.SFIL	; Get server filename string
	PROMPT <%1S (to local file) >; Prompt user
	TRO F,NEOLEF		; Say don't echo eols
	HRROI A,[ASCIZ /
Carriage Return to transfer to default local file,
Delete to bypass transfer of file,
or enter desired local filename/]
	MOVSI B,(C.ALPH+C.NUM)	; Terminate on non-alphanumerics
	PUSHJ P,INWORD##	; Input first field of reply
	 JRST [	SKIPE WRDLEN##	; Line delete, any previous input?
		 JRST C.RET6	; Yes, give user another try
		FTPM(NO,105,<Bypass this file>,,EOC) ; No, bypass
		JRST C.RET3]	; On to next file
	TRZ F,NEOLEF		; Normal echoing again
	TLNE D,(C.CEOL+C.ESC)	; Ended by eol or escape?
	 JUMPE C,C.RET5		; Yes, default if no word input
	MOVSI A,(1B0+1B3)	; Output use, "new version" etc.
	PUSHJ P,GETJFN##	; Do GTJFN and capture terminator
	 JRST [	TLNN D,(C.CDEL)	; Failed, command delete?
		 ERROR < ? >	; No, give brief error message
		JRST C.RET6]	; Try again
	HRRZM A,DSTJFN##	; Ok, store file JFN
	MOVEI A," "		; Pretend terminator was space
	SKIPL IFT20		; On Tops20, don't clobber the terminator
	DPB A,CMDBYT##
	PUSHJ P,CONFRM##	; Confirm command
	 JRST [	HRRZ A,DSTJFN##	; Line delete, release JFN
		RLJFN
		 PUSHJ P,SCREWUP
		JRST C.RET6]	; Request input again

; Now we have JFN for the local file.
; Open it and tell server to send file
C.RET7:	HRRZ A,DSTJFN##		; Get the JFN
	PUSHJ P,CHKDSK##	; Check for device disk
	HRRZ B,FILPRP+P.TYPE	; Dispatch on type
	JRST @[	SCREWUP		; Unspecified
		RTYTXT		; Text
		RTYBIN		; Binary
		RTYPAG](B)	; Paged

RTYPAG:	TRNN F,DSKDVF		; Paged, device disk?
	 JRST [	ERROR <"Type Paged" illegal for non-disk files>
		HRRZ A,DSTJFN##	; Release the JFN
		RLJFN
		 PUSHJ P,SCREWUP
		TLNE F,(RUNF)
		 JRST R.RET6
		JRST C.RET6]	; Ask for a new filename
	MOVEI B,^D36		; Byte size is 36
	JRST .+3

RTYBIN:	SKIPA B,FILPRP+P.BYTE	; Binary, use specified byte size
RTYTXT:	 MOVEI B,7		; Text, use byte size 7
	HRRZM B,FILPRP+P.BYTE	; Save byte size for transfer code
	ROT B,-6		; Position for OPENF
	HRRI B,1B20		; Open for output
	OPENF
	 JRST [	PUSHJ P,ROPNER##  ; Failed, print message
		HRRZ A,DSTJFN##	; Release the JFN
		RLJFN
		 PUSHJ P,SCREWUP
		TLNE F,(RUNF)
		 JRST R.RET6
		JRST C.RET6]	; Ask for a new filename
	FTPM(YES,0,<File open, ready for data>,,EOC) ; Tell server
	TLNE F,(RUNF)
	 JRST R.RETF

; Set file creation date to value given in property list, if present
	SKIPE C,FILPRP+P.CDAT	; Present in property list?
	TRNN F,DSKDVF		; Output file on disk?
	 JRST C.RET8		; No
	HRRZ A,DSTJFN##		; Yes, set creation date
	HRLI A,13
	SETO B,
	CHFDB

; "Retrieve" (cont'd)

; Await server's Here-is-File command and file data
C.RET8:	PUSHJ P,GETRSP##	; Get command from server
	 JRST RETEND		; End received
	 JRST RETEOC		; Unsynchronized EOC
	CAIN A,MKNO		; "No", i.e. abort?
	 JRST RETABT		; Go handle
	CAIE A,MKFILE		; "Here-is-File"?
	 JRST [	HRRO C,MRKNAM(A)  ; No, make ptr to command name
		TYPE <Improper response "[%3S] %4S" during Retrieve%/>
		JRST C.RET8]	; Ignore, look for another
	HLRZ A,CONJFN		; Set source JFN
	MOVEM A,SRCJFN##
	MOVEI A,FILPRP		; File property list
	PUSHJ P,RECDAT##	; Do the retrieval
	 JRST [	HRRZ A,DSTJFN##	; Failed, give local message
		TYPE <Data error during retrieve of %1F, aborted%/>
		PUSHJ P,GYESNO##  ; Flush rest of file, get command
		 JRST RETEND	; End
		 JRST RETEOC	; EOC
		 CAI		; Yes
		PUSHJ P,KILFIL##  ; No, flush local file
		JRST C.RET3]	; On to next file
	PUSHJ P,GYESNO##	; Retrieve finished, get terminator
	 JRST RETEND		; End
	 JRST RETEOC		; Unsynchronized EOC
	 CAIA			; Yes
	 JRST RETABT		; No, i.e. abort
	HRRZ A,DSTJFN		; Yes, transfer completed
	CLOSF			; Close local file
	 TYPE <Unlikely local CLOSF error: %1J%/>
	JRST C.RET3		; On to next file if any

; Here for errors during the actual retrieval
RETEND:	PUSHJ P,KILFIL##	; End received
	JRST DISCON

RETEOC:	PUSHJ P,KILFIL##	; Unsynchronized EOC
	JRST UNSEOC

RETABT:	HRRZ A,DSTJFN##
	TYPE <Retrieve of %1F aborted by server%/>
	PUSHJ P,KILFIL##	; Flush local file if possible
	JRST C.RET3		; On to next
	PROMPT < [Confirm] >
	PUSHJ P,CONFRM##	; Input confirmation
	 JRST [	HRRZ A,SRCJFN##	; Command delete
		RLJFN
		 PUSHJ P,SCREWUP
		POPJ P,]

; Lower fork runnable retrieve
R.GET:
R.RETR:	TLNN F,(CONOPF)		; Got a connection?
	 PUSHJ P,R.OPEN		; Nope, open one first
	HRROI A,NETBUF		; Buffer property list here
	HRROI B,RNFIL1		; String ptr to server filename
	WRITE <(Server-Filename %2S)>; Generate property
	MOVEI B,FILPRP		; Default property list
	PUSHJ P,GNTPAR##	; Generate transfer parameters
	PUSHJ P,SNDLGN##	; Send login/connect parameters
	HRROI A,NETBUF		; Where property list is
	FTPM(RETR,,<(%1S)>,,EOC)  ; Send command and property list

; Wait for response
R.RET2:	PUSHJ P,GETRSP##	; Get response
	 JRST DISCON		; End
	 JRST [	TYPE <No files retrieved>
		POPJ P,]
	CAIN A,MKNO		; See if "No"
	 POPJ P,
	CAIE A,MKPLST		; Here-is-property-list response?
	 JRST R.RET2		; TRY AGAIN
	JRST R.RET4		; Ok, go process

; "Retrieve" (cont'd)

; Loop here after each retrieval
R.RET3:	PUSHJ P,GETRSP##	; Get next command from server
	 JRST DISCON		; End
	 POPJ P,		; EOC, retrieve finished
	CAIE A,MKPLST		; Here-is-property-list response?
	 JRST R.RET3		; Try again

; Interpret property list, check filename and properties
R.RET4:	MOVE A,RNTYPE		; Save requested type
	MOVEM A,DEFPRP+P.TYPE
	MOVE A,[DEFPRP,,FILPRP]	; Copy default property list
	BLT A,FILPRP+PLSIZE-1
	HRROI A,NETBUF		; Where text is
	MOVEI B,FILPRP		; Where to put decoded properties
	PUSHJ P,SCNPRP##	; Interpret property list
	 JRST [ PUSHJ P,FLSEOC##  ; Scan past EOC
		 JRST DISCON	; End
		FTPM(EOC)	; Return control to server for next file
		JRST R.RET3]	; On to next
	PUSHJ P,FLSEOC##	; Scan past EOC
	 JRST DISCON		; End
	MOVEI A,FILPRP		; Construct Server-Filename if
	PUSHJ P,FIXNAM##	;  there isn't one already
	HRROI A,FILPRP+P.SFIL	; Make string ptr to filename
	MOVE B,FILPRP+P.TYPE	; Make sure type specified,
	CAIN B,2		; and also bytesize if binary
	 SKIPE FILPRP+P.BYTE
	 SKIPN FILPRP+P.TYPE
	  JRST [TYPE <Type/Byte-Size missing, file %1S bypassed%/>
		FTPM(NO,105,<Type/Byte-Size missing>,,EOC)
		JRST R.RET3]

; If "Automatic Retrieve", try to create a local filename using
; just the Name-Body property
; If not automatic retrieve, use RNFIL2
R.RET5:	MOVSI A,(1B0+1B17)	; No, name from string, short form
	TLNE F,(PREVRF)		; Want to preserve versions?
	 HRR A,FILPRP+P.VERS	; Yes, set default version
	HRROI B,FILPRP+P.NAMB	; String in Name-Body property
	TRNN F,AUTOF
	 HRROI B,RNFIL2		; manual, get name from here
	GTJFN			; Get JFN for local output file
	 JRST [	HRROI B,FILPRP+P.NAMB  ; Failed, print string as is
		TRNN F,AUTOF
		 HRROI B,RNFIL2
		ERROR <%2S%/ %1J%/>
		JRST R.RET6]	; Go ask user for name
	HRRZM A,DSTJFN		; Ok, store file JFN
; Fall through
; Now we have JFN for the local file.
; Open it and tell server to send file
R.RET7:	HRRZ A,DSTJFN##		; Get the JFN
	PUSHJ P,CHKDSK##	; Check for device disk
	HRRZ B,FILPRP+P.TYPE	; Dispatch on type
	JRST @[	SCREWUP		; Unspecified
		RTYTXT		; Text
		RTYBIN		; Binary
		RTYPAG](B)	; Paged

R.RET6:	ERROR <Default filename didn't work>
	POPJ P,

; Set file creation date to value given in property list, if present
R.RETF:	SKIPE C,FILPRP+P.CDAT	; Present in property list?
	TRNN F,DSKDVF		; Output file on disk?
	 JRST C.RET8		; No
	HRRZ A,DSTJFN##		; Yes, set creation date
	HRLI A,13
	SETO B,
	CHFDB

; "Retrieve" (cont'd)

; Await server's Here-is-File command and file data
R.RET8:	PUSHJ P,GETRSP##	; Get command from server
	 JRST RETEND		; End received
	 JRST RETEOC		; Unsynchronized EOC
	CAIN A,MKNO		; "No", i.e. abort?
	 JRST RETABT		; Go handle
	CAIE A,MKFILE		; "Here-is-File"?
	 JRST [	HRRO C,MRKNAM(A)  ; No, make ptr to command name
		TYPE <Improper response "[%3S] %4S" during Retrieve%/>
		JRST R.RET8]	; Ignore, look for another
	HLRZ A,CONJFN		; Set source JFN
	MOVEM A,SRCJFN##
	MOVEI A,FILPRP		; File property list
	PUSHJ P,RECDAT##	; Do the retrieval
	 JRST [	HRRZ A,DSTJFN##	; Failed, give local message
		TYPE <Data error during retrieve of %1F, aborted%/>
		PUSHJ P,GYESNO##  ; Flush rest of file, get command
		 JRST RETEND	; End
		 JRST RETEOC	; EOC
		 CAI		; Yes
		PUSHJ P,KILFIL##  ; No, flush local file
		JRST R.RET3]	; On to next file
	PUSHJ P,GYESNO##	; Retrieve finished, get terminator
	 JRST RETEND		; End
	 JRST RETEOC		; Unsynchronized EOC
	 CAIA			; Yes
	 JRST RETABT		; No, i.e. abort
	HRRZ A,DSTJFN		; Yes, transfer completed
	CLOSF			; Close local file
	 TYPE <Unlikely local CLOSF error: %1J%/>
	JRST R.RET3		; On to next file if any

; PRINT to remote site (copies to LPT: in TYPE TEXT)
C.PRIN:
C.LPT:  PUSHJ P,LPTCHK		; Make sure host has lineprinter 
	 ERROR <Host has no lineprinter service>,1
	NOISE <local file>
	HRROI A,[ASCIZ /Local filename/]
	MOVSI B,(C.ALPH+C.NUM)	; Terminate on non-alphanumerics
	PUSHJ P,INWORD##	; Input a word
	 POPJ P,		; Line delete
	MOVSI A,(1B2+1B11)	; Old file, "*" ok
	PUSHJ P,GETJFN##	; Do GTJFN, capture terminator
	 JRST [	TLNE D,(C.CDEL)	; Failed, command delete?
		 POPJ P,	; Yes, stop here
		ERROR < ? >	; No, give brief error message
		MOVE A,WRDBYT##	; Flush word that was input
		MOVEM A,CMDBYT##
		JRST C.STO1]	; Try again
	MOVEM A,SRCJFN##	; Ok, save JFN
	TLNE D,(C.CEOL)		; Terminated with EOL?
	 JRST C.LPT2		; Yes, no confirmation needed
	PROMPT < [Confirm] >
	PUSHJ P,CONFRM##
	 JRST [HRRZ A,SRCJFN##
	       RLJFN
		PUSHJ P,SCREWUP
	       POPJ P,]
	
; Loop here for each local file designated by JFN
C.LPT2:	MOVEI A,1		; Set type to TEXT
	MOVEM A,DEFPRP+P.TYPE	; Store it
	MOVE A,[DEFPRP,,FILPRP]	; Copy default property list
	BLT A,FILPRP+PLSIZE-1
	HRRZ A,SRCJFN##		; Get local JFN
	PUSHJ P,CHKDSK##	; Set DSKDVF appropriately

C.LPT6:	HRRZ A,SRCJFN##		; Get local JFN
	PUSHJ P,CKSPAR		; Check parameters
	 JRST C.LPT9		; Can't store this file
	PUSHJ P,OPNSTO		; Open local file
	 JRST C.LPT9		; Failed, bypass file

; Loop back here to retry after recoverable "No" responses
C.LPT7:	HRROI A,NETBUF		; Where to buffer property list
	WRITE <(Server-Filename LPT:)>	; Send Device
	MOVEI B,FILPRP		; File property list
	PUSHJ P,GNTPAR##	; Generate transfer parameters
	PUSHJ P,SNDLGN##	; Append Login/Connect properties
	HRROI A,NETBUF		; Where the property list is
	FTPM(STOR,,<(%1S)>,,EOC)  ; Send off command and properties

; LPT (cont'd)

; Await server's "Yes" or "No" reply, and do transfer if Yes
	PUSHJ P,GYESNO##	; Get reply
	 JRST STOEND		; End received
	 JRST STOEOC		; Unsynchronized EOC
	 CAIA			; Yes
	 JRST [	PUSHJ P,PROCNO##  ; No, process "No" code
		 CAIA		; Not recoverable
		 JRST [	PUSHJ P,FLSEOC##  ; Recoverable, try again
			 JRST DISCON
			JRST C.LPT7]
		JUMPE B,STOABT	; No, check error code
		CAIL B,20	; Username or password problem?
		CAILE B,24
		 CAIG B,3	; Or other global problem?
		  HRRZS SRCJFN##  ; Yes, disable indexing of JFN
		JRST STOABT]	;  so we stop with this file
	PUSHJ P,FLSEOC##	; Normal, flush following EOC
	 JRST STOEND		; End
	MOVEI A,MKFILE		; Insert "Here-Is-File" mark
	SETZ B,
	PUSHJ P,BEGCMD##
	HRRZ A,CONJFN		; Set destination JFN
	MOVEM A,DSTJFN##
	MOVEI A,FILPRP		; Property list
	PUSHJ P,SNDDAT##	; Do the actual store
	 JRST [	HRRZ A,SRCJFN##	; Failed, give local message
		TYPE <Data error in local file %1F, aborted%/>
		FTPM(NO,103,<File data error>,,EOC) ; Tell server
		PUSHJ P,GYESNO##  ; Await response
		 JRST STOEND	; End
		 JRST STOEOC	; EOC
		 CAI		; Yes (shouldn't happen)
		JRST STOABT]	; Go close file, on to next file
	FTPM(YES,0,<Transfer completed>,,EOC)  ; Done, tell server
	HRRZ A,SRCJFN##		; Close local file
	HRLI A,400000		; But don't release
	CLOSF
	 TYPE <Unlikely local CLOSF error: %1J%/>
	PUSHJ P,GYESNO##	; Get server's response
	 JRST DISCON		; End
	 JRST UNSEOC		; EOC
	 CAI			; Yes (i.e. successful)
	PUSHJ P,FLSEOC##	; No (message already typed)
	 JRST DISCON

; Here to advance to next file designated by local JFN
C.LPT9:	MOVE A,SRCJFN##		; Get JFN with flags
	GNJFN			; Step to next file
	 POPJ P,		; No more (JFN released).  Done.
	JRST C.LPT2		; More, go process

; routine to check host attribute for lineprinter service
LPTCHK:	HRROI A,[ASCIZ/LINEPRINTER/]
	HRROI B,[ASCIZ/SERVICES/]
	PUSHJ P,CKATTR##
	 POPJ P,
	AOS 0(P)
	POPJ P,

; "Store"
; Also get here on "Automatic Store" with AUTOF on in F

C.STOR:
C.SEND: NOISE <local file>
C.STO1:	HRROI A,[ASCIZ /Local filename/]
	MOVSI B,(C.ALPH+C.NUM)	; Terminate on non-alphanumerics
	PUSHJ P,INWORD##	; Input a word
	 POPJ P,		; Line delete
	MOVSI A,(1B2+1B11)	; Old file, "*" ok
	PUSHJ P,GETJFN##	; Do GTJFN, capture terminator
	 JRST [	TLNE D,(C.CDEL)	; Failed, command delete?
		 POPJ P,	; Yes, stop here
		ERROR < ? >	; No, give brief error message
		MOVE A,WRDBYT##	; Flush word that was input
		MOVEM A,CMDBYT##
		JRST C.STO1]	; Try again
	MOVEM A,SRCJFN##	; Ok, save JFN
	TLNE D,(C.CEOL)		; Terminated with EOL?
	 JRST C.STO2		; Yes, no confirmation needed
	PROMPT < [Confirm] >
	PUSHJ P,CONFRM##
	 JRST [HRRZ A,SRCJFN##
	       RLJFN
		PUSHJ P,SCREWUP
	       POPJ P,]
	
; Loop here for each local file designated by JFN
C.STO2:	MOVE A,[DEFPRP,,FILPRP]	; Copy default property list
	BLT A,FILPRP+PLSIZE-1
	HRRZ A,SRCJFN##		; Get local JFN
	PUSHJ P,CHKDSK##	; Set DSKDVF appropriately

; If "Automatic Store", create a remote filename using
; just the local name and extension
	TRNN F,AUTOF		; Automatic store?
	 JRST C.STO5		; No, go ask for foreign filename
	TYPE <%1F (to remote file) >; Type filename
C.STO3:	HRRZ B,SRCJFN##		; No, get source JFN
	MOVE C,[1B8+1B11+1B35]	; Name and ext with punctuation
	PUSHJ P,DOJFNS##	; Convert to string, quote if req'd
	HRROI A,FILPRP+P.NAMB	; Set Name-Body property
	WRITE <%2S>
	HRROI A,TEMP		; Where DOJFNS did JFNS to
	TYPE <%1S>		; Type foreign name for user
	TLNE F,(PREVRF)		; Preserving versions?
	TRNN F,DSKDVF		; Yes, is local file on disk?
	 JRST C.STO4		; No, can't do version stuff
	HRRZ A,SRCJFN##		; Yes, get version number from FDB
	MOVE B,[1,,7]
	MOVEI C,C		; Put it here
	GTFDB
	HLRZS C			; Put in RH
	MOVEM C,FILPRP+P.VERS	; Put in property list
	TYPE <;%3D>

C.STO4:	PRINT EOL
	JRST C.STO6		; Go begin store

; "Store" (cont'd)

; If not "Automatic Store", get remote filename from user
C.STO5:	PUSHJ P,INIEDT##	; Initialize editor
	HRRZ A,SRCJFN##		; Get local JFN
	PROMPT <%1F (to remote file) >; Prompt user
	TRO F,NEOLEF		; Say don't echo eols
	HRROI A,[ASCIZ /
Carriage Return to transfer to default remote file,
Delete to bypass transfer of file,
or enter desired remote filename/]
	MOVSI B,(C.ALPH+C.NUM+C.PUNC+C.SPAC)  ; All printable chars
	PUSHJ P,INWORD##	; Input remote filename
	 JRST [	SKIPE WRDLEN##	; Line delete, any input?
		 JRST C.STO5	; Yes, give user another try
		JRST C.STO9]	; No, skip over this file
	TLNE D,(C.CEOL+C.ESC)	; Terminated by eol or escape?
	 JUMPE C,C.STO3		; Yes, default if no word input
	TRNE F,ESCAPF		; Escape terminated?
	 JRST [	ERROR <>	; Yes, can't recognize here
		JRST APWORD##]	; So just ask for more input
	TLNN D,(C.CEOL)		; Ended by EOL?
	 JRST [	ERROR < ?%/>	; No, bad char or something
		JRST C.STO5]	; Try again
	PRINT EOL		; Print the EOL that was suppressed
	HRROI A,FILPRP+P.SFIL	; Copy to Server-Filename property
	PUSHJ P,CPYWRD##

; Here when ready to initiate Store
C.STO6:	HRRZ A,SRCJFN##		; Get local JFN
	PUSHJ P,CKSPAR		; Check parameters
	 JRST C.STO9		; Can't store this file
	PUSHJ P,OPNSTO		; Open local file
	 JRST C.STO9		; Failed, bypass file

; Loop back here to retry after recoverable "No" responses
C.STO7:	HRROI A,NETBUF		; Where to buffer property list
	HRROI B,FILPRP+P.SFIL	; Make ptr to Server-Filename
	SKIPE FILPRP+P.SFIL	; Was that specified?
	 WRITE <(Server-Filename %2S)>; Yes, send property
	HRROI B,FILPRP+P.NAMB	; Make ptr to Name-Body
	SKIPE FILPRP+P.NAMB	; Was that specified?
	 WRITE <(Name-Body %2S)>; Yes, send property
	SKIPE B,FILPRP+P.VERS	; Is there a version?
	 WRITE <(Version %2D)>	; Yes, send it
	MOVEI B,FILPRP		; File property list
	PUSHJ P,GNTPAR##	; Generate transfer parameters
	PUSHJ P,SNDLGN##	; Append Login/Connect properties
	HRROI A,NETBUF		; Where the property list is
	FTPM(STOR,,<(%1S)>,,EOC)  ; Send off command and properties

; "Store" (cont'd)

; Await server's "Yes" or "No" reply, and do transfer if Yes
	PUSHJ P,GYESNO##	; Get reply
	 JRST STOEND		; End received
	 JRST STOEOC		; Unsynchronized EOC
	 CAIA			; Yes
	 JRST [	PUSHJ P,PROCNO##  ; No, process "No" code
		 CAIA		; Not recoverable
		 JRST [	PUSHJ P,FLSEOC##  ; Recoverable, try again
			 JRST DISCON
			JRST C.STO7]
		JUMPE B,STOABT	; No, check error code
		CAIL B,20	; Username or password problem?
		CAILE B,24
		 CAIG B,3	; Or other global problem?
		  HRRZS SRCJFN##  ; Yes, disable indexing of JFN
		JRST STOABT]	;  so we stop with this file
	PUSHJ P,FLSEOC##	; Normal, flush following EOC
	 JRST STOEND		; End
	MOVEI A,MKFILE		; Insert "Here-Is-File" mark
	SETZ B,
	PUSHJ P,BEGCMD##
	HRRZ A,CONJFN		; Set destination JFN
	MOVEM A,DSTJFN##
	MOVEI A,FILPRP		; Property list
	PUSHJ P,SNDDAT##	; Do the actual store
	 JRST [	HRRZ A,SRCJFN##	; Failed, give local message
		TYPE <Data error in local file %1F, aborted%/>
		FTPM(NO,103,<File data error>,,EOC) ; Tell server
		PUSHJ P,GYESNO##  ; Await response
		 JRST STOEND	; End
		 JRST STOEOC	; EOC
		 CAI		; Yes (shouldn't happen)
		JRST STOABT]	; Go close file, on to next file
	FTPM(YES,0,<Transfer completed>,,EOC)  ; Done, tell server
	HRRZ A,SRCJFN##		; Close local file
	HRLI A,400000		; But don't release
	CLOSF
	 TYPE <Unlikely local CLOSF error: %1J%/>
	PUSHJ P,GYESNO##	; Get server's response
	 JRST DISCON		; End
	 JRST UNSEOC		; EOC
	 CAI			; Yes (i.e. successful)
	PUSHJ P,FLSEOC##	; No (message already typed)
	 JRST DISCON

; Here to advance to next file designated by local JFN
C.STO9:	MOVE A,SRCJFN##		; Get JFN with flags
	GNJFN			; Step to next file
	 POPJ P,		; No more (JFN released).  Done.
	JRST C.STO2		; More, go process

; Here for errors during the actual store
STOEND:	HRRZ A,SRCJFN##		; End received, close local file
	CLOSF			;  and release JFN
	 CAI
	JRST DISCON		; Handle disconnect

STOEOC:	HRRZ A,SRCJFN##		; Unsynchronized EOC
	CLOSF			; Close and release JFN
	 CAI
	JRST UNSEOC		; Go abort connection

STOABT:	HRRZ A,SRCJFN##		; Here if server said "No"
	HRLI A,400000		; Close file, don't release JFN
	CLOSF
	 CAI
	PUSHJ P,FLSEOC##	; Flush server's EOC
	 JRST DISCON		; End
	JRST C.STO9		; On to next file

; "Store" subroutines ...

; Check and/or default parameters for "Store" command
;	A/ JFN for file being stored
; Assumes transfer parameters are in FILPRP
; Returns +1:  Error, message already typed
;	+2:  Ok, type and byte size filled in appropriately
; Clobbers B-D

CKSPAR:	SETZ B,			; Assume don't know byte size
	TRNN F,DSKDVF		; Local file on disk?
	 JRST CKSPA2		; No
	MOVE B,[1,,11]		; Yes, read byte size from FDB
	MOVEI C,C		; Put it here
	GTFDB
	LDB B,[POINT 6,C,11]	; Extract byte size
CKSPA2:	HRRZ C,FILPRP+P.TYPE	; Get specified transfer type
	HRRZ D,FILPRP+P.BYTE	; Get specified byte size
	JRST @[	STYUNS		; Dispatch on type:  Unspecified
		STYTXT		; Text
		STYBIN		; Binary
		STYPAG](C)	; Paged

; Here for type unspecified
STYUNS:	SKIPN D,B		; File byte size known?
	 ERROR <Type specification required to store %1F>,1
	MOVEI C,2		; Assume binary
	CAIN B,7		; 7-bit file?
	 MOVEI C,1		; Yes, assume text
	JRST CKSPA4		; Go set parameters

; Here for type Text
STYTXT:	SKIPE D,B		; File byte size known?
	CAIN D,^D36		; Yes, 36 bit words?
	 MOVEI D,7		; Not known or 36, assume 7 bit
	CAIE D,7		; Legal byte size?
	CAIN D,8
	 JRST CKSPA4		; Yes
	ERROR <Type Text inconsistent with byte size %4D of file %1F>,1

; Here for type Binary
STYBIN:	JUMPN D,.+3		; Transfer byte size specified?
	SKIPN D,B		; No, substitute file byte size
	 ERROR <Byte size specification required to store %1F>,1
	JUMPE B,CKSPA4		; Ok if file byte size unknown
	CAME B,D		; Both known, make sure consistent
	 ERROR <Parameters inconsistent with byte size %4D of file %1F>,1
	JRST CKSPA4

; Here for type Tenex-Paged
STYPAG:	TRNN F,DSKDVF		; Is local file on disk?
	 ERROR <"Type Paged" illegal for non-disk files>,1
	MOVEI D,^D36		; Set local byte size to 36

; All cases converge here
; C/ Transfer type, D/ Transfer byte size
CKSPA4:	MOVEM C,FILPRP+P.TYPE	; Store type and byte size
	MOVEM D,FILPRP+P.BYTE
	JRST SKPRET##		; Return +2

; "Store" subroutines ...

; Open file for store
; Assumes file JFN is in SRCJFN
; and that transfer parameters are in FILPRP
; Returns +1:  Failed, error message already generated
;	+2:  Succeeded, file open
; Clobbers A-D

OPNSTO:	TRNN F,DSKDVF		; Is file on disk?
	 JRST OPNST1		; No, bypass extension check
	HRROI A,TEMP		; Yes, buffer file extension here
	SETZM TEMP
	HRRZ B,SRCJFN##
	MOVSI C,(1B11)		; Get extension only
	JFNS
	MOVEI B,1B19+1B25	; Assume want to open thawed
	MOVE A,TEMP		; Get the extension
	CAME A,[ASCII /SAV/]	; Leave thawed if .SAV
OPNST1:	MOVEI B,1B19		; Open in frozen mode
	MOVE A,FILPRP+P.BYTE	; Get transfer byte size
	DPB A,[POINT 6,B,5]	; Put in position
	HRRZ A,SRCJFN##		; Setup JFN
	OPENF			; Attempt to open
	 JRST [	TRC B,1B25	; Failed, try flipping thawed bit
		HRRZ A,SRCJFN##
		OPENF
		 JRST SOPNER##  ; Failed again, give error
		JRST .+1]	; Succeeded, continue
	JRST SKPRET##		; Return +2
; "Store" for lower fork version

R.STOR:
R.SEND:	TLNN F,(CONOPF)		; There a connection open?
	 PUSHJ P,R.OPEN		; Nope, open one
	SKIPGE RNSTAT		; Make sure no errors from R.OPEN
	 POPJ P,		; R.OPEN failed, die here
	MOVSI A,100101		; Read file name from shared page
	HRROI B,RNFIL1		; Old file only, allow wildcards
	GTJFN
	 JRST [RUNM (<(A)>,<No such file>) ; Failed, return with error
	       POPJ P,]
	MOVEM A,SRCJFN##	; Save JFN
R.STO2:	MOVE A,RNTYPE
	MOVEM A,DEFPRP+P.TYPE	; Save transfer type
	MOVE A,[DEFPRP,,FILPRP]	; Init default directory list
	BLT A,FILPRP+PLSIZE-1
	HRRZ A,SRCJFN##		; Set file device flags
	PUSHJ P,CHKDSK##
	HRRZ B,SRCJFN##		; Write out string, with necessary quotes
	MOVE C,[1B8+1B11+1B35]
	TRNN F,AUTOF
	 JRST R.STOM		; Manual store
	PUSHJ P,DOJFNS##
	HRROI A,RNFIL2		; Put it in the property list
	WRITE <%2S>
R.STOM:	TLNE F,(PREVRF)		; Preserving versions?
	TRNN F,DSKDVF		; File on disk
	 JRST R.STO4		; No on either account, can't supply version
	HRRZ A,SRCJFN##		; Get version from FDB
	MOVE B,[1,,7]
	MOVEI C,C
	GTFDB
	HLRZS C
	MOVEM C,RNVERS		; Store it
R.STO4:	HRRZ A,SRCJFN##		; Check store parameters
	PUSHJ P,CKSPAR
	 JRST R.STO9		; Can't do it
	PUSHJ P,OPNSTO		; Open the local file
	 JRST R.STO9		; Can't

; Loop back here to retry after recoverable "no" responses
R.STO5:	HRROI A,NETBUF		; Where to buffer property list
	HRROI B,RNFIL2		; Start writing the list
	SKIPE RNFIL2		; File name for server
	 WRITE <(Server-filename %2S)>
	SKIPE B,RNVERS		; Version if we want it
	 WRITE <(Version %2D)>
	MOVEI B,FILPRP		; Generate the rest of the parameters
	PUSHJ P,GNTPAR##
	PUSHJ P,SNDLGN##	; Append login/connect properties
	HRROI A,NETBUF		; Where the property list is
	FTPM(STOR,,<(%1S)>,,EOC)	; Send off command and properties

;Await servers's "Yes" or "No" reply, and do transfer if yes
	PUSHJ P,GYESNO##	; Wait for a reply
	 JRST STOEND		; End received
	 JRST STOEOC		; Unsychronized EOC
	 CAIA			; Yes, keep going
	 JRST [			; No, fill in error message
		RUNM (<(B)>,<No received from server>)
		HRRZS SRCJFN##
		JRST STOABT ]
	PUSHJ P,FLSEOC##
	 JRST STOEND
	MOVEI A,MKFILE
	SETZ B,
	PUSHJ P,BEGCMD##
	HRRZ A,CONJFN
	MOVEM A,DSTJFN##
	MOVEI A,FILPRP
	PUSHJ P,SNDDAT##
	 JRST [ PUSHJ P,GYESNO##
		 JRST STOEND
		 JRST STOEOC
		 CAI
		 JRST STOABT ]
	FTPM(YES,0,<Transfer completed>,,EOC)
	HRRZ A,SRCJFN##
	HRLI A,(1B0)
	CLOSF
	 CAI
	PUSHJ P,GYESNO##
	 JRST DISCON
	 JRST UNSEOC
	 CAI
	 PUSHJ P,FLSEOC##
	  JRST DISCON
R.STO9:	MOVE A,SRCJFN##
	GNJFN
	 CAIA
	JRST R.STO2
; here when done, no more files to send
	SETZM RNSTAT		; Say no error occurred
	POPJ P,

; "Delete"
; Also get here on "Automatic Delete" with AUTOF on in F

C.DELE:	NOISE <remote file>
	HRROI A,[ASCIZ /Remote filename/]
	MOVSI B,(C.ALPH+C.NUM+C.PUNC+C.SPAC)  ; All printable chars
	PUSHJ P,INWORD##	; Input a word
	 POPJ P,		; Line delete
	TRNE F,ESCAPF		; Ended with Escape?
	 JRST [	ERROR <>	; Yes, can't recognize here
		JRST APWORD##]	; So just ask for more input
	TLNN D,(C.CEOL)		; Ended with eol?
	 JRST CERR		; No, give error
	JUMPE C,CERR		; Also bad if no input
	MOVE A,[DEFPRP,,FILPRP]	; Ok, init file property list
	BLT A,FILPRP+PLSIZE-1
	HRROI A,FILPRP+P.SFIL	; Where to put server filename
	PUSHJ P,CPYWRD##	; Do it

; Generate "Delete" command to server
C.DEL1:	HRROI A,NETBUF		; Buffer property list here
	HRROI B,FILPRP+P.SFIL	; String ptr to server filename
	WRITE <(Server-Filename %2S)>; Generate property
	PUSHJ P,SNDLGN##	; Send login/connect parameters
	HRROI A,NETBUF		; Where property list is
	FTPM(DELE,,<(%1S)>,,EOC)  ; Send command and property list

; Wait for response
C.DEL2:	PUSHJ P,GETRSP##	; Get response
	 JRST DISCON		; End
	 JRST [	TYPE <No files deleted>
		POPJ P,]
	CAIN A,MKNO		; See if "No"
	 JRST [	ERROR( < %4S%/)	; Report failure to user
		HRLM B,0(P)	; Save "No" code
		PUSHJ P,FLSEOC##  ; Scan past EOC
		 JRST DISCON	; End
		HLRZ B,0(P)	; Recover "No" code
		PUSHJ P,PROCNO##  ; Process "No" code
		 POPJ P,	; Not recoverable, exit
		JRST C.DEL1]	; Recoverable, retry
	CAIE A,MKPLST		; Here-is-property-list response?
	 JRST [	HRRO C,MRKNAM(A)  ; No, give error
		TYPE <Improper response "[%3S] %4S" to Delete request%/>
		JRST C.DEL2]	; Try again
	JRST C.DEL4		; Ok, go process

; "Delete" (cont'd)

; Loop here after each file deleted
C.DEL3:	PUSHJ P,GETRSP##	; Get next command from server
	 JRST DISCON		; End
	 POPJ P,		; EOC, delete finished
	CAIE A,MKPLST		; Here-is-property-list response?
	 JRST [	HRRO C,MRKNAM(A)  ; No, give error
		TYPE <Improper response "[%3S] %4S" to Delete request%/>
		JRST C.DEL3]	; Try again

; Interpret property list, check filename and properties
C.DEL4:	MOVE A,[DEFPRP,,FILPRP]	; Copy default property list
	BLT A,FILPRP+PLSIZE-1
	HRROI A,NETBUF		; Where text is
	MOVEI B,FILPRP		; Where to put decoded properties
	PUSHJ P,SCNPRP##	; Interpret property list
	 JRST [	TYPE <Bad property list, one file bypassed%/>
		PUSHJ P,FLSEOC##  ; Scan past EOC
		 JRST DISCON	; End
		FTPM(EOC)	; Return control to server for next file
		JRST C.DEL3]	; On to next
	PUSHJ P,FLSEOC##	; Scan past EOC
	 JRST DISCON		; End
	MOVEI A,FILPRP		; Construct Server-Filename if
	PUSHJ P,FIXNAM##	;  there isn't one already

; If not "Automatic Delete", request confirmation from user
	PUSHJ P,INIEDT##	; Initialize editor
	HRROI A,FILPRP+P.SFIL	; Get server filename string
	PROMPT <Delete %1S>
	TRNE F,AUTOF		; Automatic delete?
	 JRST [	PRINT EOL	; Yes, charge ahead
		JRST C.DEL7]
	PROMPT < [Confirm] >
	PUSHJ P,CONFRM##	; Confirm command
	 JRST [	FTPM(NO,105,<Bypass this file>,,EOC)
		JRST C.DEL3]	; On to next file

; Tell server to delete file
C.DEL7:	FTPM(YES,0,<Delete it!>,,EOC)
	PUSHJ P,GYESNO##	; Get response from server
	 JRST DISCON		; End received
	 JRST UNSEOC		; Unsynchronized EOC
	 JRST C.DEL3		; Yes, finished
	 JRST C.DEL3		; No (message already printed)

; "Rename"

C.RENA:	NOISE <remote file>
	HRROI A,[ASCIZ /Existing remote filename/]
	MOVSI B,(C.ALPH+C.NUM+C.PUNC)  ; All printable chars
	PUSHJ P,INWORD##	; Input a word
	 POPJ P,		; Line delete
	TLNN D,(C.CEOL+C.SPAC+C.ESC)  ; Proper terminator?
	 JRST CERR		; No, complain
	JUMPE C,CERR		; Null input not allowed
	TLNE D,(C.CEOL)		; Terminated by EOL?
	 TRO F,ESCAPF		; Yes, pretend escape hit
	HRROI A,FILPRP+P.SFIL	; Where to put old server filename
	PUSHJ P,CPYWRD##	; Do it

	NOISE <to be>
	HRROI A,[ASCIZ /New remote filename/]
	MOVSI B,(C.ALPH+C.NUM+C.PUNC)  ; All printable chars
	PUSHJ P,INWORD##	; Input a word
	 POPJ P,		; Line delete
	TRNE F,ESCAPF		; Ended with escape?
	 JRST [	ERROR <>	; Yes, can't recognize here
		JRST APWORD##]	; So just ask for more input
	TLNN D,(C.CEOL)		; Proper terminator?
	 JRST CERR		; No, complain
	JUMPE C,CERR		; Null input not allowed
	HRROI A,FILBUF		; Where to put new server filename
	PUSHJ P,CPYWRD##	; Do it

; Generate "Rename" command to server
C.REN1:	HRROI A,NETBUF		; Buffer property list here
	HRROI B,FILPRP+P.SFIL	; String ptr to old name
	WRITE <(Server-Filename %2S)>; Generate property
	PUSHJ P,SNDLGN		; Send login/connect parameters
	WRITE <)(>		; End first property list, start second
	HRROI B,DEFPRP+P.DIRE
	SKIPE 0(B)		; Is there a default directory
	 WRITE <(Directory %2S)>
	HRROI A,NETBUF		; Result string
	HRROI B,FILBUF		; New server filename
	FTPM(RENA,,<(%1S(Server-Filename %2S))>,,EOC)  ; Send it

; Wait for response
	PUSHJ P,GYESNO##
	 JRST DISCON		; End
	 JRST UNSEOC		; Unsynchronized EOC
	 JRST [	PUSHJ P,FLSEOC##  ; "Yes", flush EOC
		 JRST DISCON
		POPJ P,]	; Done
	HRLM B,0(P)		; "No", save code
	PUSHJ P,FLSEOC##	; Flush EOC
	 JRST DISCON
	HLRZ B,0(P)		; Recover "No" code
	PUSHJ P,PROCNO##	; Process "No" code
	 POPJ P,		; Not recoverable, exit
	JRST C.REN1		; Recoverable, retry

; "List"

C.LIST:	PUSHJ P,SAVE1##
	MOVEI A,101		; Assume output to TTY
	MOVEM A,LISJFN
	SETZ P1,		; Reset list format flags
	NOISE <remote file designator>
	HRROI A,[ASCIZ /Remote file designator/]
	MOVSI B,(C.ALPH+C.NUM+C.PUNC+C.SPAC)  ; All printable chars
	PUSHJ P,INWORD##	; Input a word
	 POPJ P,		; Line delete
	TRNE F,ESCAPF		; Ended with Escape?
	 JRST [	ERROR <>	; Yes, can't recognize here
		JRST APWORD##]	; So just ask for more input
	TLNN D,(C.CEOL)		; Ended with eol?
	 JRST CERR		; No, give error
	JUMPE C,CERR		; Also bad if no input
	MOVE A,CMDBYT		; Get command byte pointer
	BKJFN			; Back it up
	 PUSHJ P,SCREWUP
	LDB D,A			; Get char before terminator
	CAIN D,","		; Comma?
	 MOVEM A,CMDBYT		; Yes, store backed up pointer
	HRROI A,FILPRP+P.SFIL	; Where to put server filename
	PUSHJ P,CPYWRD##	; Do it
	CAIE D,","		; Subcommands follow?
	 JRST C.LIS1		; No

; Loop to gather subcommands
C.LIS0:	PUSHJ P,CRIF##
	PUSHJ P,INIEDT##	; Reinitialize editor
	PROMPT <**>
	MOVE A,LSTSUB		; List subcommand dispatch table
	PUSHJ P,INKEY##		; Input keyword
	 JRST [	TLNE D,(C.CDEL)	; Command delete?
		 POPJ P,	; Yes, exit
		MOVE C,WRDLEN##	; Null input?
		TLNE D,(C.CEOL)	; Terminated by eol
		 JUMPE C,C.LIS1	; Yes, end of subcommands
		ERROR < ?>
		JRST C.LIS0]
	HRRZ A,0(A)		; Get list format flags for keyword
	TRNE A,LSOUTF		; Output to file command?
	 PUSHJ P,C.LISO		; Open the file (closing any previous ones)
	IORI P1,(A)		; Set them
	JRST C.LIS0		; Back for more subcommands

; Generate "List" command to server
C.LIS1:	HRROI A,NETBUF		; Buffer property list here
	HRROI B,FILPRP+P.SFIL	; String ptr to server filename
	WRITE <(Server-Filename %2S)>; Generate property
	PUSHJ P,SNDLGN##	; Send login/connect parameters
	HRROI A,NETBUF		; Where property list is
	FTPM(DIR,,<(%1S)>,,EOC)	; Send command and property list

; Output header if LIST going to a file
	TRNN P1,LSOUTF		; Output to file?
	 JRST C.LIS2		; No, go await response
	GTAD			; Get current time
	MOVE C,A
	HRROI A,TEMP		; Build buffer
	HRROI B,FILPRP+P.SFIL	; Server filename
	HRROI D,HSTNLY		; Server name
	WRITE <Files from [%4S]%2S at %3T%/> ; Write header
	MOVE A,LISJFN
	HRROI B,TEMP
	SETZ C,
	SOUT


; "List" (cont'd)

; Wait for response
C.LIS2:	PUSHJ P,GETRSP##
	 JRST DISCON		; End
	 JRST C.LISX		; Done
	CAIN A,MKNO		; See if "No"
	 JRST [	ERROR( < %4S%/)	; Report failure to user
		HRLM B,0(P)	; Save "No" code
		PUSHJ P,FLSEOC##  ; Scan past EOC
		 JRST DISCON	; End
		HLRZ B,0(P)	; Recover "No" code
		PUSHJ P,PROCNO	; Process "No" code
		 POPJ P,	; Not recoverable, exit
		JRST C.LIS1]	; Recoverable, retry
	CAIE A,MKPLST		; Here-is-property-list response?
	 JRST [	HRRO C,MRKNAM(A)  ; No, give error
		TYPE <Improper response "[%3S] %4S" to List request%/>
		JRST C.LIS2]	; Try again

; Parse property list
	SETZM FILPRP		; Zero it out
	MOVE A,[FILPRP,,FILPRP+1]
	BLT A,FILPRP+PLSIZE-1
	HRROI A,NETBUF		; Where text is
	MOVEI B,FILPRP		; Where to put decoded properties
	PUSHJ P,SCNPRP##	; Interpret property list
	 JRST [	TYPE <Bad property list, one file bypassed%/>
		JRST C.LIS2]

; Print header if necessary
	TLON P1,(1B0)		; Already printed?
	TRNN P1,-1		; Or printing only name?
	 JRST C.LIS3		; Yes
	HRROI A,TEMP		; Buffer string
	WRITE <%/                        >
	TRNE P1,LSTYPE		; Printing type?
	 WRITE < Type >
	TRNE P1,LSSIZE		; Printing size?
	 WRITE <  Size>
	SETZ B,			; For dates, assume no times
	TRNE P1,LSTIME		; List times?
	 HRROI B,[ASCIZ /      /]  ; Yes, extra space
	TRNE P1,LSCDAT		; Printing creation date?
	 WRITE <  Creation%2S>
	TRNE P1,LSWDAT		; Printing write date?
	 WRITE <  Write   %2S>
	TRNE P1,LSRDAT		; Printing read date?
	 WRITE <  Read    %2S>
	TRNE P1,LSAUTH		; Print author?
	 WRITE < Author>
	WRITE <%/%/>
	MOVE A,LISJFN
	HRROI B,TEMP
	SETZ C,
	SOUT

; "List" (cont'd)
; Now print listing for this file
C.LIS3:	HRROI A,TEMP
	HRROI B,FILPRP+P.SFIL	; Server filename
	MOVEI C,^D1000		; Get Tenex to count the bytes
	SETZ D,
	SOUT
	BKJFN			; Setup to clobber terminator
	 ERROR < ? %1J>		; Huh?
	TRNN P1,-1		; Anything else to print?
	 JRST C.LIS8		; No
	SUBI C,^D<1000-25>	; Reserve 25 chars for name
	WRITE < >		; Print spaces up to position 25
	SOJG C,.-1

	TRNN P1,LSTYPE		; List file type?
	 JRST C.LIS4		; No
	HRRZ C,FILPRP+P.TYPE	; Yes, get file type
	HRRZ B,FILPRP+P.BYTE	; Byte size
	XCT [	WRITE < ?    >	; Unspecified
		WRITE < Text >	; Text
		WRITE < B(%2D)>	; Binary
		WRITE < Paged>	; Paged (huh?)
	    ](C)
	CAIN C,2		; Binary?
	CAIL B,^D10		; Byte size less than 10?
	 CAIA
	 WRITE < >		; Yes, another space

C.LIS4:	TRNN P1,LSSIZE		; List file size?
	 JRST C.LIS5		; No
	MOVE B,FILPRP+P.SIZE	; Get file size
	MOVE C,[1B2+1B4+6B17+^D10]  ; Leading blanks, width 6
	NOUT
	 CAI			; Ok if number overflows

C.LIS5:	MOVE B,FILPRP+P.CDAT
	TRNE P1,LSCDAT		; List creation date?
	 PUSHJ P,PRDATE		; Yes, do so
	MOVE B,FILPRP+P.WDAT
	TRNE P1,LSWDAT		; List write date?
	 PUSHJ P,PRDATE		; Yes, do so
	MOVE B,FILPRP+P.RDAT
	TRNE P1,LSRDAT		; List read date?
	 PUSHJ P,PRDATE		; Yes, do so
	HRROI B,FILPRP+P.AUTH
	TRNE P1,LSAUTH		; List author?
	 WRITE < %2S>

; End of listing for this file
C.LIS8:	WRITE <%/>
	MOVE A,LISJFN
	HRROI B,TEMP
	SETZ C,
	SOUT
	JRST C.LIS2		; Back for next

; Print date in correct format for "List" command
;	A/ Destination designator (byte pointer or JFN)
;	B/ Tenex or Tops20 format date and time
;	P1/ List format flags
; Returns +1 always
; Clobbers B, C

PRDATE:	WRITE < >
	JUMPE B,[WRITE <   ---   >; Handling for unspecified date
		TRNE P1,LSTIME
		 WRITE <      >
		POPJ P,]
	MOVSI C,(1B9)		; Normally omit time
	TRNE P1,LSTIME		; Want to include time?
	 TLC C,(1B9+1B10)	; Yes, but omit seconds
	ODTIM			; Do it
	POPJ P,

; Routine to open output file for LIST
; CALL: PUSHJ P,C.LISO
; RETURNS: +1, always, LISJFN setup if no error occurred
C.LISO:	PUSH P,A			; Don't clobber A
	TLNN D,(C.SPAC!C.ESC)		; Command terminated by space or ESC?
	  ERROR < ? >,2
	NOISE <to file>
	MOVSI A,(1B0+1B15)		; Output use, extended long GTJFN
	SKIPL IFT20			; Tops20?
	 TLO A,(1B3+1B4)		; no, require confirmation
	MOVEM A,LISTAB
	SETO A,
	MOVEM A,LISTAB+1		; I/O from terminal
	SETZM LISTAB+2			; Default device
	MOVE A,[LISTAB+2,,LISTAB+3]	; Clear out rest of table
	BLT A,LISTAB+13
	MOVEI A,3
	MOVEM A,LISTAB+11		; Extended Long GTJFN table length
	PUSHJ P,APPNUL##
	HRROI A,CMDBUF##
	MOVEM A,LISTAB+14		; ^R prompt
C.LSO1:	MOVEI A,LISTAB
	SETZ B,
	GTJFN				; get a JFN
	 JRST  [CAIE A,GJFX34
		 JRST [ERROR < ? %1J>
		       JRST C.LSO2]
		TYPE < Output file name%/> ; Help for "?"
		HRROI A,CMDBUF##	; Retype buffer
		PSOUT		
		JRST C.LSO1]		; Try again
	MOVE B,[7B5+1B20]		; open 7 bit, write
	OPENF				; Try to open
	 JRST [ERROR < ? %1J>
	       JRST C.LSO2]
	MOVEI B,(A)			; Hold onto JFN
	MOVE A,LISJFN			; Get previous JFN
	CAIE A,101			; Don't close it if TTY
	 CLOSF
	  JFCL
	MOVEM B,LISJFN			; Save new output JFN
C.LSO2:	POP P,A				; Recover A
	POPJ P,				; Return

; Here to leave LIST command
C.LISX:	MOVE A,LISJFN
	CAIE A,101			; Output to TTY?
	 CLOSF				; No, close output file
	  JFCL
	POPJ P,				; Leave

; "List" subcommand definitions and keyword table

LSTYPE==1B18	; List type and byte size
LSSIZE==1B19	; List size
LSCDAT==1B20	; List creation date
LSWDAT==1B21	; List write date
LSRDAT==1B22	; List read date
LSTIME==1B23	; List times as well as dates
LSAUTH==1B24	; List author
LSOUTF==1B25	; Output to file

DEFINE X(KEY,FLAGS) <[ASCIZ /KEY/],,FLAGS>

LSUBTB:	X AUTHOR,LSAUTH
	X CREATION,LSCDAT
	X EVERYTHING,LSAUTH+LSCDAT+LSRDAT+LSSIZE+LSTIME+LSTYPE+LSWDAT
	X OUTPUT,LSOUTF
	X READ,LSRDAT
	X SIZE,LSSIZE
	X TIMES,LSTIME
	X TYPE,LSTYPE
	X VERBOSE,LSTYPE+LSWDAT+LSRDAT+LSAUTH
	X WRITE,LSWDAT

LSTSUB:	LSUBTB-.,,LSUBTB	; Table pointer

LS LISJFN			; JFN for output
LS LISTAB,15			; Long GTJFN table

; Initialize PSI system
; Returns +1
; Clobbers A, B

INIPSI:	MOVEI A,400000		; Initialize psi system
	MOVE B,[LEVTAB,,CHNTAB]
	SIR
	EIR
	MOVE B,[ACTCHN]		; Activate channels
	AIC
	POPJ P,


; PSI channel definitions

DEFINE PSI(CH,LEV,DISP) <
	ACTCHN==ACTCHN!1B<CH>
RELOC CHNTAB+^D<CH>
	LEV ,, DISP
>

	ACTCHN==0

CHNTAB:	PSI(9,1,PDLOVF)		; Pushdown overflow
	PSI(11,1,DATERR)	; Data error
	PSI(15,1,ILLINS)	; Illegal instruction
	PSI(16,1,ILLRED)	; Illegal read
	PSI(17,1,ILLWRT)	; Illegal write
	PSI(18,1,ILLXCT)	; Illegal execute
	PSI(20,1,ILLSIZ)	; Machine size exceeded
	PSI(23,3,LFKWAK)	; Wake up PUPFTP for a lower fork command


RELOC CHNTAB+^D36

LEVTAB:	CH1PC		; Level 1 - fatal errors
	CH2PC		; Level 2 - not used
	CH3PC		; Level 3 - normal wakeups, eof, etc.

; Interrupt routines

; Fatal errors

PDLOVF:	JSP B,CRASHX
	ASCIZ /Pushdown overflow/

DATERX:	JSP B,CRASHX
	ASCIZ /IO data error/

ILLINS:	JSP B,CRASHX
	ASCIZ /Illegal instruction/

ILLRED:	JSP B,CRASHX
	ASCIZ /Illegal read/

ILLWRT:	JSP B,CRASHX
	ASCIZ /Illegal write/

ILLXCT:	JSP B,CRASHX
	ASCIZ /Illegal execute/

ILLSIZ:	JSP B,CRASHX
	ASCIZ /Machine size exceeded/

; Common code for fatal error interrupts
CRASHX:	PUSH P,CH1PC		; Put trap pc on stack
	TLOA B,-1		; Make call pc into string ptr


; UUO handlers and FORMAT escape sequences not defined in PUPFTP
%ULOG:: %UELOG:: %LETC:: %LETP::

; Routine to call if an impossible error occurs
; Does not return

SCREWUP::HRROI B,[ASCIZ /An impossible error has occurred/]
	HRRZ A,0(P)		; Get return pc
	SUBI A,1		; Backup to call
	ERROR <%2S at %1O>
	HALTF

; Handling for data error
DATERR:	PUSH P,A		; Save an ac
	SKIPL A,SRCDSP		; Check for error dispatches
	SKIPGE A,DSTDSP
	 TRNN A,-1		; Both specified and armed?
	  JRST DATERX		; No, treat as fatal error
	HRRZM A,CH1PC		; Armed, clobber interrupt pc
	SETZM SRCDSP		; Disarm errors
	SETZM DSTDSP
	POP P,A
	MOVE P,ERRPDP		; Go to correct stack level
	DEBRK			; Break to error dispatch

; Storage assignments

LS CH1PC		; PSI return locations
LS CH2PC
LS CH3PC

LS STACK,STKLEN		; Local stack
LSP TEMP,1		; One page for general scratch use

LS CONJFN		; Network input,,output JFNs
LS IFT20		; Tops20/Tenex flag

LSP NETBUF,1		; Network I/O buffer
LSP FILBUF,1		; Local file buffer
LSP SHRPAG,1		; Shared commands page for lower fork version

; Macro to define storage within the shared page
DEFINE SHR (NAME,SIZE<1>),<
NAME=:..T
..T==..T+SIZE
>
..T==SHRPAG
SHR RNCMND
SHR RNSTAT
SHR RNERR,20
SHR RNHOST,USRSTL/5+1
SHR RNUNAM,USRSTL/5+1
SHR RNUPAS,USRSTL/5+1
SHR RNUACT,USRSTL/5+1
SHR RNCNAM,USRSTL/5+1
SHR RNCPAS,USRSTL/5+1
SHR RNVERS
SHR RNTYPE
SHR RNFIL1,25
SHR RNFIL2,25
SHR RNFIL3,25
SHR RNFIL4,25


LS ERRPDP		; Stack pointer to restore on data error
LS SRCDSP		; Source file data error dispatch
LS DSTDSP		; Destination file data error dispatch

LS HSTNAM,20		; Remote port name (from Host command)
LS HSTNLY,15		; Remote host name only (no port)

LS DEFPRP,PLSIZE	; Default property list
LS FILPRP,PLSIZE	; File property list (Store/Retrieve)

; *** Do not change the order of the following ***
LS USRNAM,USRSTL/5+1	; User-Name string
LS USRPSW,USRSTL/5+1	; User-Password string
LS USRACT,USRSTL/5+1	; User-Account string
LS CONNAM,USRSTL/5+1	; Connect-Name string
LS CONPSW,USRSTL/5+1	; Connect-Password string
; ***


	END START

