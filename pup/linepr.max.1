;<134>LINEPR.MAC;6509    16-FEB-79 12:10:37    EDIT BY TAFT
; Limit lines/page and chars/line to 7-bit numbers--all that will
; fit in the FILMOD word!
;<134>LINEPR.MAC;6508    24-OCT-78 10:59:21    EDIT BY TAFT
; Fix bug in LUKFNT
;<134>LINEPR.MAC;6507     7-JUN-78 15:25:18    EDIT BY TAFT
; Bug fixes
; Make FONT and FONTS, PFONT and PFONTS be synonyms
;<134>LINEPR.MAC;6506     5-JUN-78 17:56:03    EDIT BY TAFT
; Bug fixes
;<134>LINEPR.MAC;6505     5-JUN-78 15:26:13    EDIT BY TAFT
;<134>LINEPR.MAC;6504     5-JUN-78 13:22:09    EDIT BY TAFT
; Rewrite font lookup to use Press conventions and flush Ears stuff.
; Add INIFNT routine that reads FONTS.WIDTHS and builds an internal
; data structure for later font name lookup via LUKFNT.
;<134>LINEPR.MAC;6502     1-MAY-78 18:57:49    EDIT BY TAFT
; Diddle Ears page height for Press compatibility
;<134>LINEPR.MAC;6501     9-JAN-76 14:35:58    EDIT BY TAFT
; Soup merge to 1.34
;<134-TENEX>LINEPR.MAC;65    23-JUN-75 22:00:41    EDIT BY ALLEN
; EXTERNED BUGCHK
;<134-TENEX>LINEPR.MAC;64    28-APR-75 12:41:08    EDIT BY CLEMENTS
;<134-TENEX>LINEPR.MAC;63    28-APR-75 11:39:30    EDIT BY CLEMENTS
;<134-TENEX>LINEPR.MAC;62    24-APR-75 14:20:03    EDIT BY CLEMENTS
;<134-TENEX>LINEPR.MAC;61    29-JAN-75 13:42:34    EDIT BY CLEMENTS
; MAKE ARG TO ASGJFR LARGER FOR SPOOLED OPEN IN CASE OF 39 CHAR NAME.
;<134-TENEX>LINEPR.MAC;60    21-JAN-75 13:55:09    EDIT BY CLEMENTS
; REMOVE MULTIPLE FORMFEEDS FROM LPTCLZ. LEAVE THIS UP TO
; SPOOLERS OR OPERATORS. SAVE TREES.
;<133>LINEPR.MAC;5913     6-JAN-76 17:03:04    EDIT BY TAFT
; Implement general facility for numeric arguments to SPPAR
;<133>LINEPR.MAC;5911    21-NOV-75 15:03:25    EDIT BY TAFT
; Diddle Ears parameters some more
;<133>LINEPR.MAC;5910    22-AUG-75 19:23:09    EDIT BY TAFT
; Adjust parameters for landscape printing
;<133>LINEPR.MAC;5909    10-MAR-75 19:25:31    EDIT BY TAFT
; Bug fixes in new stuff
;<133>LINEPR.MAC;5908    26-FEB-75 14:28:51    EDIT BY TAFT
;<133>LINEPR.MAC;5906    21-FEB-75 17:59:10    EDIT BY TAFT
; More mods to printing parameter stuff:
; 1) Do font lookup in .SPPAR rather than LPTOPN
; 2) Gather information from user's DOCGEN.PRT file
; 3) Implement .EL extension and LANDSCAPE directive
;<133>LINEPR.MAC;5903    14-JAN-75 19:00:12    EDIT BY TAFT
; Tune Ears page length
;<133>LINEPR.MAC;5902     7-JAN-75 00:34:24    EDIT BY TAFT
; Set output file protection explicitly (temp).
; If file busy, retry with specific higher versions.
;<133>LINEPR.MAC;5901     4-JAN-75 18:50:29    EDIT BY TAFT
; SOUP merge to 1.33
;<132>LINEPR.MAC;5910    17-DEC-74 18:22:02    EDIT BY TAFT
; Change <PRINTER> filenames to LPT.user;next higher version
;<132>LINEPR.MAC;5909    13-NOV-74 15:07:33    EDIT BY TAFT
; Allow arbitrary parameter name in SPPAR, and add DICT parameter.
;<132>LINEPR.MAC;5908     5-NOV-74 16:32:29    EDIT BY TAFT
; Mods for Ears font file format change
;<132>LINEPR.MAC;5906    28-OCT-74 17:01:54    EDIT BY TAFT
; More tuning of Ears font parameters
;<132>LINEPR.MAC;5904    26-OCT-74 20:38:59    EDIT BY TAFT
; Mods due to confusion over Ears font file format
;<132>LINEPR.MAC;5903     8-OCT-74 22:25:39    EDIT BY TAFT
; Minor bug fixes in LPTEXT and .SPPAR
;<132>LINEPR.MAC;5902     4-OCT-74 16:34:53    EDIT BY TAFT
;<TAFT>LINEPR.MAC;4     2-OCT-74 16:06:39    EDIT BY TAFT
; Better handling of unrecognized and ambiguous extensions in LPTEXT
;<TAFT>LINEPR.MAC;3     1-OCT-74 23:30:48    EDIT BY TAFT
;<TAFT>LINEPR.MAC;2     1-OCT-74 18:29:04    EDIT BY TAFT
; New round of changes to impement redesign of printing strategy.
; Take out breakpage code, add Ears code, allow extension .EP,
; add SPPAR jsys.
;<132>LINEPR.MAC;5901    22-JUL-74 15:18:52    EDIT BY TAFT
; SOUP merge PARC 1.31 code into 1.32
;<TENEX-132>LINEPR.MAC;59     5-JUN-74 11:24:25    EDIT BY CLEMENTS
; GET RID OF SOME MORE "EOL" CHARS, PUT IN CRLF'S
;<TENEX-132>LINEPR.MAC;58     2-MAY-74 14:43:22	EDIT BY TOMLINSON
; SWITCHED TO NEW ASCII CHARACTERS
;<TENEX-132>LINEPR.MAC;57    17-APR-74 23:25:35	EDIT BY TOMLINSON
;<TENEX-132>LINEPR.MAC;56    16-APR-74 13:01:52	EDIT BY ALLEN
;<TENEX-132>LINEPR.MAC;55     5-APR-74 11:24:43	EDIT BY TOMLINSON
; SWAP UPARROW WITH CARAT AND UNDERLINE WITH LEFTAROW
;<TENEX-132>LINEPR.MAC;54    21-DEC-73 12:02:22	EDIT BY ALLEN
; ELIMINATE CALL TO ARCSQ
;<TENEX-132>LINEPR.MAC;53    20-NOV-73 22:26:06	EDIT BY CLEMENTS
; CHANGES TO RUN EITHER LP10 OR BBN PRINTER.
; REMOVED FORCED ACCOUNT SETTING ON SPOOLED LPT
; PRIORITY SETTING CALL TO ADJUST QUEUE AFTER I/O WAIT
;<131>LINEPR.MAC;4812    24-MAY-74 00:38:23    EDIT BY TAFT
; Fix remaining bugs in font lookup code
;<131>LINEPR.MAC;4811    23-MAY-74 15:34:03    EDIT BY TAFT
; Add fancier name lookup so can override long GTJFN default with DEFONT
;<131>LINEPR.MAC;4810    21-MAY-74 18:59:17    EDIT BY TAFT
; Fix up some conditionals.
; Don't output XPRINT command if font is DEFONT.
;<131>LINEPR.MAC;4809    18-MAY-74 23:30:20    EDIT BY TAFT
; Add code to lookup font files etc.
;<131>LINEPR.MAC;4808     3-APR-74 22:50:21	EDIT BY TAFT
; More bug fixes
;<131>LINEPR.MAC;4807    23-MAR-74 19:18:12	EDIT BY TAFT
; Change CALLs to PUSHJ P,'s.  Fix bugs in breakpage code.
;<131>LINEPR.MAC;4805    22-MAR-74 14:10:20	EDIT BY TAFT
; Take out <SYSTEM>BREAKPAGE stuff, add code to generate a Maxc-standard
;  breakpage.
;<131>LINEPR.MAC;4804    13-MAR-74  4:09:55	EDIT BY TAFT
; Conditionalize EXTERNs of LPTCHR and LPTTIM on LPTDVF
;<131>LINEPR.MAC;4802    11-MAR-74 21:53:49	EDIT BY TAFT
;<131>LINEPR.MAC;4801    11-MAR-74 21:43:02	EDIT BY TAFT
; Fix INTERNs so assembly works with no physical LPT.
; Spool files to <PRINTER>username/LPT.seqno, where seqno is unique.
; Prefix spooled files with <SYSTEM>BREAKPAGE.
;<FILESYSTEM>LINEPR.MAC;49    25-AUG-72 17:52:09	EDIT BY TOMLINSON
;<FILESYSTEM>LINEPR.MAC;48    29-JUN-72 12:47:57	EDIT BY TOMLINSON
;<FILESYSTEM>LINEPR.MAC;47    29-JUN-72 10:14:01	EDIT BY TOMLINSON

	SEARCH	STENEX,PROLOG
IFDEF LPTN,<
	TITLE	LINEPRINTER
	SUBTTL	R.S.Tomlinson

;ASSEMBLES FOR LP10 (DEC) OR BBN (ONE-OF-A-KIND) LINEPRINTER
;DEPENDING ON FLAGS LP10F AND BBNPF

; Externally defined symbols

EXTERN	PBYTPO,PBYTSZ,BUGCHK
EXTERN	ASGJFR,RELFRE,FPTA,GDIRST,JOBDIR,MLKPG,MPP,MULKPG,UNLCKF
EXTERN	CPOPJ,SKPRET,LCKTST,BUGHLT,BUGNTE,MRETN,DISL,CAPENB
IFDEF LPTDVF,<
EXTERN	LPTCHR		; Return from line printer interrupt
EXTERN	LPTTIM		; Lpt check timer
EXTERN	DISLE		; Disms til arg .le. 0

; Entries to this part

INTERN	LPTSV,LPTRST	; Interrupt routine
INTERN	LPTCHK		; Check routine

; Parameters and fixed core locations

   IFN BBNPF,<
LPTCCW==167		; Line printer control word location
LPT=124>		; Line printer device
PI==4
IOS=6

LS(LPTINR)		; Return address in interrupt routine
LPSTKL==10		; Interrupt stack length
LS(LPSTK,LPSTKL)	; Stack for interrupt routine
LS(LPTSTS)		; Status word
LS(LPTOFC)		; Off-line count
LS(LPTRLP)		; Real core address for line printer
LS(LPTCNT)		; Buffer counter
LS(LPTPOS)		; Page position word
LS(LPTJOB)		; Job of last lpt opener
NRP(LPTBUF,1000)
>
LS(LPTLCK)		; Lock on opening lpt

IFDEF LPTDVF,<
FLG(ALTP,L,IOS,400000)
FLG(ALTI,L,IOS,200000)
FLG(OUERR,L,IOS,100000)	; Output error
FLG(OPN,L,IOS,040000)	; Line printer open
IFN BBNPF,<FLG(ESC,L,IOS,020000)> ; Escape character seen
FLG(CRSW,L,IOS,010000)	; Carret seen

   IFN LP10F,<		;LP10 DEFS
LS LPTCLS,1		;LPTCHK CLOCK SWITCH
LS LPTCCW,1		;BLKI/O PTR
LS LPTCKT,1		;INTERVAL FOR LPTTIM

FLG(FSTBUF,L,IOS,020000) ;FIRST BUFFER
FLG(LAST,L,IOS,004000)	;LAST WORD SENT

LPTBOT==10*LPTCHN+LPTCHN ;PRINTER HAS 2 PI ASSMTS
LPTCLR==1B25		;CONI/O BITS
LPTERR==1B27
LPTBSY==1B28
LPTDON==1B29
   >			;END OF LP10 DEFINITIONS
>
IFDEF LPTSPL,<
NR(LPTDDN,1)		; Directory number of <PRINTER>
>

; Line printer dispatch table

SPLDTB::
LPTDTB::LPTDIR		; Set directory
	LPTNAM		; Name lookup
	LPTEXT		; Extension
	LPTVER		; Version
	CPOPJ		; Protection insertion
	CPOPJ		; Account
	CPOPJ
	LPTOPN
	CPOPJ
	LPTSQO		; Output
	LPTCLZ
	CPOPJ		; Rename
	CPOPJ		; Delete
	CPOPJ		; Dump
	CPOPJ
	CPOPJ		; Mount
	CPOPJ		; Dismount
	CPOPJ		; Initialize directory
	CPOPJ		; Mtape
	CPOPJ		; Get status
	CPOPJ		; Set status


; Initialize line printer

	USE	RESPC

LPTINI::IFDEF LPTDVF,<
   IFN LP10F,<
	MOVSI A,(1B1)
	MOVEM A,LPTCKT>		;LPTTIM INTERVAL
	SETZM LPTSTS
	SETOM LPTCNT
	SETZM LPTPOS>
	SETOM LPTLCK
	POPJ P,

LPTRST:	IFDEF LPTDVF,<
	MOVE IOS,LPTSTS
	SKIPL LPTCNT
	JRST LPTSTR>
	POPJ P,

	USE	SWAPPC
IFNDEF LPTSPL,<LPTDIR==<LPTNAM==<LPTEXT==<LPTVER==CPOPJ>>>>

IFDEF LPTSPL,<
; If spooling to disk, we allow a specification of LPT:fontname,
; which will cause fontname to be passed to LPTOPN and used for
; page length and width computation.

;Set directory
LPTDIR:
IFDEF LPTDVF,<
	HLRZ A,FILDDN(JFN)	; Get device name used
	MOVE A,1(A)
	CAME A,[ASCIZ /LPT/]	; Real or spooled?
	 POPJ P,		; Real LPT, fail return from dir setup
>
	TEST(NE,DIRSF)		; Star not allowed
	 JRST [	MOVEI A,GJFX31	; Illegal *
		JRST SKPRET##]
	JRST SK2RET##		; Always give success return

; Name lookup
LPTNAM:	JUMPE A,[MOVEI A,GJFX18	; Stars not allowed
		POPJ P,]	; Return "no such name"
	SKIPN 1(A)		; Null string?
	 JRST LPTNA4		; Yes, accept it (will default later)
	PUSH P,A		; Save lookup pointer
	MOVEI A,1(A)		; Point to first word of lookup name
	PUSHJ P,LUKFNT		; Lookup font name
	 JRST LPTNA3		; Not found
	POP P,A			; Found, restore lookup pointer
	JRST SK2RET##		; Give success return

; Failed to find font name.  Give error only if it was typed in explicitly.
; If it was defaulted (e.g., long GTJFN), zap the input string with null
; so as to default to a standard font.
LPTNA3:	POP P,A			; Restore lookup pointer
	MOVE B,FILCNT(JFN)	; Remaining chars in string just input
	TEST(NN,NAMTF)		; Has a name already been input?
	CAIE B,MAXLC##		; No, was the typed-in string empty?
	 POPJ P,		; Already input or non-empty, fail
LPTNA4:	SETZM 1(A)		; Smash name with null
	TEST(O,NNAMF)		; Set "nameless device" flag
	TEST(NN,UNLKF)		; Called from EXTLUK?
	 JRST SK2RET##		; No take success return
	JRST SKPRET##		; Yes take nameless device return

; Extension lookup
LPTEXT:	JUMPE A,[MOVEI A,GJFX19	; Stars not allowed
		POPJ P,]	; Return "no such extension"
	JRST SK2RET##		; Always give success return

; Version lookup
LPTVER:	TEST(NE,VERSF)		; Stars not allowed
	 JRST [	MOVEI A,GJFX20	; Return "no such version" for stars
		POPJ P,]
	TEST(O,NNAMF)		; Now say device "nameless"
	TEST(Z,OUTPF)		; Clear "for output use"
	JRST SKPRET##		; Always give success return
>

; Open line printer

LPTOPN:	IFDEF LPTSPL,<
	HLRZ A,FILDDN(JFN)
	MOVE A,1(A)
	CAME A,[ASCII /LPT/]
IFDEF LPTDVF,<
	 JRST [	MOVEI B,600000
		MOVEI A,WHELX1
		TDNN B,CAPENB
		 POPJ P,
		JRST LP1OPN]>
IFNDEF LPTDVF,<
	 JRST LP1OPN>

	MOVEI A,400000
	PUSH P,CAPENB		; Save current capenb
	IORM A,CAPENB		; Give ourselves wheel status
LPTOPA:	MOVEI B,^D8+3+1		; 8 WORDS FOR NAME, 3 FOR PREFIX, 1 HDR
	PUSHJ P,ASGJFR		; Get some job storage
	 JRST LPTOPC		; Fail to spool
	PUSH P,A
	HRLI A,(<POINT 7,0,35>)
	HRROI B,[ASCIZ /<PRINTER>LPT./]
	SETZ C,
	SOUT
	MOVE B,FORKX##		; Get login dir
	SKIPGE B,FKDIR##(B)
	 MOVE B,FKDIR##(B)
	HRRZS B
	DIRST
	 BUG(HLT,<LPTOPN: DIRST OF LOGIN DIRECTORY FAILED>)
	SETZ D,			; Initially try default version (next)
LPTOPB:	MOVE A,D		; Get version to try
	HRLI A,(1B0+1B1+1B8+1B17) ; Output, new file only, ign deleted
	MOVE B,0(P)
	HRLI B,(<POINT 7,0,35>)
	GTJFN
	 JRST [	CAIN A,GJFX27	; New file required error?
		TRNN D,-1	; Yes, trying explicit version?
		 JRST LPTOPF	; No, fail
		AOJA D,LPTOPB]	; Yes, try next higher version
	PUSH P,A		; Save JFN
	LDB B,PBYTSZ##		; Byte size user opened file in
	ROT B,-6		; Position for OPENF
	HRRI B,1B22		; Append
	OPENF
	 JRST [	CAIE A,OPNX9	; Busy?
		 JRST LPTOPG	; No, other error, fail
		POP P,A		; Yes, restore JFN
		MOVE B,[1,,FDBVER] ; Find what version GTJFN gave us
		MOVEI C,D
		GTFDB
		HLRZS D
		RLJFN		; Release this one
		 JFCL
		AOJA D,LPTOPB]	; Try next higher
	LSH A,SJFN		; Turn JFN into JSB index
	HRRZ B,FILDDN(A)	; Get dir # of <PRINTER>
	MOVEM B,LPTDDN		; Save for use in SPPAR JSYS
	MOVE B,[<DEFLPP>B10+<DEFCPL>B17+7B3]  ; Set default mode word
	MOVEM B,FILMOD(A)

; LPTOPN (cont'd)

	MOVE A,0(P)		; Restore spooler JFN
	UMOVE B,2		; Get caller ac2
	TLNN B,(1B10)		; Unless inhibited by special bit
	 PUSHJ P,RDEFLT		; Read default parameters from DOCGEN.PRT
	HLRZ D,FILNEN(JFN)	; Has a font been specified?
	SKIPN 1(D)
	 JRST LPTOPD		; No, skip parameter setup
	MOVE A,0(P)		; Get spooler JFN
	HRROI C,1(D)		; Make string pointer to font name
	HRROI B,[ASCIZ /FONT/]	; Set font name parameter for Ears
	SPPAR
	 BUG(CHK,<LPTOPN: SPPAR failed>)
	HRROI C,1(D)		; Make string pointer to font name
	HRROI B,[ASCIZ /PFONT/]	; Set same font name parameter for Press
	SPPAR
	 BUG(CHK,<LPTOPN: SPPAR failed>)

LPTOPD:	POP P,B			; Restore JFN
	EXCH B,0(P)		; Save again, get back storage ptr
	MOVEI A,JSBFRE		; Release the storage
	PUSHJ P,RELFRE
	NOINT
	PUSHJ P,UNLCKF
	POP P,A
	POP P,CAPENB
	MOVE B,JFN
	LSH B,-SJFN
	SWJFN
	RLJFN
	 JFCL
	MOVE A,MPP
	AOS (A)
	JRST MRETN

; Routine to read default printing parameters from DOCGEN.PRT
; A/ JFN of spooled output

RDEFLT:	HRLM A,0(P)		; Save JFN
	PUSHJ P,ASGPAG##	; Assign a page of job storage
	 POPJ P,		; Can't, forget it
	PUSH P,A		; Save page address
	HRLI A,(POINT 7)	; Build filename <login dir>DOCGEN.PRT
	MOVEI B,"<"
	BOUT
	MOVE B,FORKX##		; Get login dir
	SKIPGE B,FKDIR##(B)
	 MOVE B,FKDIR##(B)
	HRRZS B
	DIRST
	 BUG(HLT,<RDEFLT: DIRST of login directory failed>)
	HRROI B,[ASCIZ />DOCGEN.PRT/]
	SETZ C,
	SOUT
	MOVSI A,(1B2+1B17)	; Old file, name from string
	HRRO B,0(P)
	GTJFN
	 JRST RDEFL9		; Not found
	PUSH P,A		; Save JFN
	MOVE B,[7B5+1B19]	; Open for reading
	OPENF
	 JRST [	POP P,A		; Can't, forget it
		RLJFN
		 CAI
		JRST RDEFL9]
	MOVEI A,400000		; Kludge to disable EOF interrupts
	RCM			;  while reading file
	PUSH P,A		; Save channels that are on
	MOVEI A,400000		; Turn off EOF
	MOVSI B,(1B10)
	DIC
	MOVE A,-1(P)		; Read first page of file
	HRRO B,-2(P)		; (Hopefully the whole file)
	MOVNI C,4777
	SIN
	MOVEI A,400000
	IDPB A,B		; Null at end
	POP P,B			; Restore channels on
	AIC
	POP P,A			; Close file
	CLOSF
	 BUG(CHK,<RDEFLT: Unaccountable CLOSF failure>)
	MOVE D,0(P)		; Make byte ptr to start of text
	HRLI D,(POINT 7)
RDEFL1:	MOVE B,D		; Save starting point
	SETZ C,			; No arg string yet
	ILDB A,D		; Get a char
	JUMPE A,RDEFL9		; Jump if end
	ANDCMI A,40		; Lower to upper case
	CAIL A,"A"
	CAILE A,"Z"
	 JRST RDEFL1		; Skip over non-alphabetics
RDEFL2:	ILDB A,D		; Get a char
	JUMPE A,RDEFL9		; Jump if end
	CAIN A," "		; If space
	 JRST [	DPB C,D		; Clobber with null
		MOVE C,D	; Save start of arg
		JRST RDEFL2]
	CAIL A,40		; Treat any control char as terminator
	 JRST RDEFL2
	SETZ A,			; Replace with null
	DPB A,D
	HLRZ A,-1(P)		; Get output JFN
	HRLI A,(1B0)		; Say not to copy to output
	SPPAR			; Set parameter
	 CAI			; Ignore errors
	JRST RDEFL1		; Repeat
RDEFL9:	POP P,A			; End, restore job page address
	PUSHJ P,RELPAG##	; Release it
	POPJ P,

; Jsys to set printing parameters - SPPAR

; call:	1/ JFN of spooled file opened on LPT:  but no bytes output yet
;	B0 on:  Don't set parameters in output file, just read
;		for internal consumption
;	2/ String pointer to name of parameter to set
;	3/ Value of parameter to set
;	SPPAR
;	 +1: Error, code in 1
;	+2: Success, ac's unchanged

; Parameter name	Value
;  FONT			String ptr to font name(s) for Ears
;  PFONT		String ptr to font name(s) for Press
;			--Currently we treat FONT and PFONT as synonyms
;  Other (alphabetic)	5B2 + numeric value (to be converted to decimal)
;			or string ptr to parameter value string.
;			Tenex just copies it, doesn't look at it.
;			Examples are COPIES, DEVICE, PDEVICE

; Errors:
; The usual JFN errors for the JFN in 1, plus:
;  SPPAX1	JFN in 1 is not for spooled LPT:
;  SPPAX2	JFN not unused (bytes already output)
;  SPPAX3	Parameter name illegal (not alphabetic)
;  SPPAX4	Illegal parameter value


	PARBFW==^D50		; Size of temp buffer, words
	PARBFC==5*PARBFW-1	; Same, characters


; Some handy macros, adapted from JSYS.MAC

DEFINE ERUNLK(ERRORN,EXTRA) <
	JRST [	EXTRA
		IFDIF <ERRORN>,<>,<MOVEI A,ERRORN>
		JRST ERUNLL]
>
DEFINE ERR(ERRORN,EXTRA) <
	JRST [	EXTRA
		IFDIF <ERRORN>,<>,<MOVEI A,ERRORN>
		JRST ERRL]
>

ERUNLL:	PUSHJ P,RELLPB		; Release temp storage
	JRST ERUNLD##		; To common code to unlock file and return

ERRL:	PUSHJ P,RELLPB		; Release temp storage
	JRST ERRD##		; To common code to return error

.SPPAR::JSYS MENTR##
	SETZ E,			; Indicate don't have temp storage yet
	HRRZ JFN,1		; Get and check first arg
	PUSHJ P,CHKJFN##
	 ERR()			; Bad JFN
	 JFCL			; TTY
	 ERUNLK(DESX4)		; String ptr or funny designator
	HRRZ A,DEV		; Good file, see if it is on disk
	HRRZ B,FILDDN(JFN)	; and the directory is <PRINTER>
	CAIN A,DSKDTB##
	CAME B,LPTDDN
	 ERUNLK(SPPAX1)		; No, error
	TEST(NE,OPNF)		; Make sure open for write
	TEST(NN,WRTF)
	 ERUNLK(DESX5)		; No
	PUSHJ P,GETFDB##	; Ok, get pointer to FDB
	 BUG(HLT,<.SPPAR: GETFDB failed for open file>)
	HRRZ A,FDBUSW(A)	; Get user-settable word
	PUSHJ P,USTDIR##	; Unlock dir
	IDIVI A,5		; Compute # words already used for parameters
	MOVEI B,^D36
	LDB C,PBYTSZ##		; Get byte size file opened with
	IDIV B,C		; Bytes per word
	IMUL A,B		; # bytes used for parameters in file byte size units
	CAME A,FILBYN(JFN)	; Is that all there is in the file?
	 ERUNLK(SPPAX2)		; No,, error
	MOVEI B,PARBFW+1	; Ok, assign some free storage
	PUSHJ P,ASGJFR##	; 50 words needed for max-length JFNS string
	 ERUNLK(GJFX22)		; JSB full
	HRRZ E,A		; Save ptr to block (kept here for rest of JSYS)
	MOVE A,[-PRPLEN,,PRPLST] ; Make aobjn ptr to dispatch table
	UMOVE B,2		; Get user string ptr to parameter name
	PUSHJ P,KEYSRC		; Look in table
	 JRST SPPAR1		; Not found
	HRL E,(A)		; Found, save ptr to parameter name
	HLRZ A,(A)		; Dispatch
	JRST (A)

; Here when parameter name not found
SPPAR1:	MOVEI B,1(E)		; Make byte ptr to start
	HRLI B,(POINT 7)
SPPAR2:	ILDB A,B		; Get a char
	JUMPE A,SPPAR3		; Jump if end
	CAIL A,"A"		; Alphabetic?
	CAILE A,"Z"
	 ERUNLK(SPPAX3)		; No, error
	JRST SPPAR2
SPPAR3:	HRLI E,1(E)		; Ok, save ptr to parameter name
	MOVEI A,MAXLW##(E)	; Where to put value
	UMOVE B,3		; Get user argument
	TLC B,(5B2)		; See if numeric:
	TLNE B,(7B2)		; 5B2 + immediate value, or
	TLNN B,(77B11)		; zero in byte size field
	 JRST [	HRLI A,(POINT 7,,34)  ; Yes, make string ptr
		TLZ B,(7B2)
		MOVEI C,^D10	; Convert to decimal string
		NOUT
		 CAI
		JRST SPPAR0]
	TLC B,(5B2)		; No, assume byte pointer
	MOVEI C,PARBFC-5	; Max # chars available
	SUBI C,MAXLC##+1
	PUSHJ P,CPYFU2##	; Copy to temp storage
	 BUG(HLT,<.SPPAR: Impossible non-skip return from CPYFU2>)
SPPAR0:	MOVEI A,MAXLW##+1(E)	; Set pointer to string in block
	JRST SPPAR5		; Go process

; Dispatch table for parameter name
PRPLST:	FNTPRP,,[ASCIZ /FONT/]
	FNTPRP,,[ASCIZ /FONTS/]
	FNTPRP,,[ASCIZ /PFONT/]
	FNTPRP,,[ASCIZ /PFONTS/]

	PRPLEN==.-PRPLST

; Routines to process individual parameters

; FONT or PFONT
FNTPRP:	HRRZ A,E		; Use temp block
	UMOVE B,3		; Get user string ptr
	MOVEI C,PARBFC		; Max # chars allowed
	PUSHJ P,CPYFU2##	; Copy string from user to block
	 BUG(HLT,<.SPPAR: Impossible non-skip return from CPYFU2>)
	MOVEI A,1(E)
	PUSHJ P,LUKFNT		; Look up first font name
	 JRST SPPAR4		; Not found, just copy it

; Have lines/page in A, chars/line in B
	CAILE A,177		; Limit to 7 bits each
	 MOVEI A,177
	CAILE B,177
	 MOVEI B,177
	LSH A,^D<35-10>		; Position lines/page to B10
	TLO A,340000(B)		; Merge in chars/line at B17
	MOVEM A,FILMOD(JFN)	; Set mode word for JFN
	JRST SPPAR4		; Copy font specification to file


; Common return point for individual parameter routines.
; LH E has ptr to parameter name, parameter value string in temp block.
SPPAR4:	MOVEI A,1(E)		; Point to first word of string
SPPAR5:	UMOVE B,1		; Get user ac1
	JUMPL B,SPPAR8		; Skip output if B0 set
	HRLI A,(POINT 7)	; Make byte ptr
	PUSH P,A		; Save it
	LDB A,PBYTSZ##		; Get byte size file opened with
	PUSH P,A		; Save it
	CAIN A,7		; Already 7 bit bytes?
	 JRST SPPAR6		; Yes, skip this
	MOVEI B,7		; No, change byte size to 7
	PUSHJ P,NFBSZ##
	PUSHJ P,NEWWND##
SPPAR6:	HLRZ A,E		; Get ptr to parameter name
	HRLI A,(POINT 7)
	PUSHJ P,SPSOUT		; Output it to file
	MOVEI A," "		; Space
	PUSHJ P,SPBOUT
	MOVE A,-1(P)		; Get ptr to parameter value
	PUSHJ P,SPSOUT		; Output to file
	MOVEI A,15		; Cr, lf
	PUSHJ P,SPBOUT
	MOVEI A,12
SPPAR7:	PUSHJ P,SPBOUT
	MOVSI A,(76B5)		; At word boundary now?
	TDNE A,FILBYT(JFN)
	 JRST SPPAR7		; No, output a null
	PUSHJ P,GETFDB##	; Yes, get ptr to FDB again
	 BUG(HLT,<.SPPAR: GETFDB failed for open file>)
	MOVE B,FILBYN(JFN)	; Store # bytes output
	HRRM B,FDBUSW(A)	;  ..in user-settable word
	PUSHJ P,USTDIR##
	POP P,B			; Restore byte size file opened with
	CAIN B,7		; Was 7 bits?
	 JRST SPPAR8		; Yes, skip rest
	MOVEI A,7		; No, change back to original size
	PUSHJ P,NFBSZ##
	PUSHJ P,NEWWND##
SPPAR8:	PUSHJ P,RELLPB		; Release temp block
	PUSHJ P,UNLCKF##	; Unlock file
	JRST SKMRTN##		; Give skip return

; SPPAR subroutines

; Routine to lookup keyword string in table
;	A/ AOBJN ptr to keyword table
;	B/ User string ptr for string to be looked up
;	E/ Loc of free storage block
;	PUSHJ P,KEYSRC
;	  error, no match
;	found, A points to matching entry

KEYSRC:	PUSH P,A		; Save table ptr
	SETZM 1(E)		; Clear out region of temp block we will use
	MOVSI A,1(E)
	HRRI A,2(E)
	BLT A,MAXLW##(E)
	HRRZ A,E
	PUSHJ P,CPYFU1##	; Copy string from user into block
	 BUG(HLT,<KEYSRC: Impossible non-skip return from CPYFU1>)
	ADD A,[-1,,1]		; Turn lookup ptr into aobjn ptr to string
	EXCH A,0(P)		; Save, get back table ptr
KEYSR1:	MOVE B,0(P)		; Get ptr to string in temp block
	HRRZ C,0(A)		; Get ptr to string from keyword table
KEYSR2:	MOVE D,0(B)		; Get word from user string
	CAME D,0(C)		; Compare with word from table
	JRST KEYSR3		; No match, try next entry
	ADDI C,1		; Match, test next word in string
	AOBJN B,KEYSR2		; if any
	AOSA -1(P)		; If get here the string matched
KEYSR3:	AOBJN A,KEYSR1		; Repeat for entire table
	SUB P,BHC##+1		; Fix stack
	POPJ P,			; Return, ptr in A if success


; Routine to release the temp buffer if have one (ptr in RH E)
RELLPB:	HRRZ B,E		; Get loc of block
	JUMPE B,CPOPJ		; Return if none
	PUSH P,A		; Protect A
	MOVEI A,JSBFRE		; Return the block to free storage
	PUSHJ P,RELFRE##
	POP P,A
	POPJ P,


; Routine to do SOUT, string ptr in A
SPSOUT:	PUSH P,A
SPSOU1:	ILDB A,0(P)
	JUMPE A,[POP P,A
		POPJ P,]
	PUSHJ P,SPBOUT
	JRST SPSOU1

; Routine to do BOUT, byte in A
SPBOUT:	TEST(NE,ENDF)		; Test error conditions
	ERUNLK(IOX6)
	TEST(NE,ERRF)
	ERUNLK(IOX5)
	PUSHJ P,@BOUTD(DEV)	; Call device-dependent output routine
	POPJ P,

; Data structure derived from FONTS.WIDTHS:

MNFFAM==^D100			; Maximum number of font families
LFAMST==MNFFAM*<^D19+4>/5	; Storage reserved for family name strings
MNWSEG==^D500			; Maximum number of font width segments

NR NFFAM,1			; Number of font families
NR FNTFAM,MNFFAM		; <Ptr to family name> ,, <family code>
NR FAMSTR,LFAMST		; Storage for family name strings

NR NWDSEG,1			; Number of width segments

; The following tables are parallel.
; Font width index entries:
; BYTE (9) family code (9) face (18) rotation
NR FNTIDX,MNWSEG

; Font width segments:
; height ,, width
; If height is nonzero then the entry is absolute and both height and
; width are in micas.  If height is zero then the width is fractional.
NR FNTWDS,MNWSEG


; Page layout parameters (all in micas)
PORHIT==^D26162		; 10.3 inches (.5 top, .2 bottom, 11.0 total)
PORWID==^D17780		; 7.0 inches (1.0 left, .5 right, 8.5 total)
LANHIT==^D20549		; 8.09 inches (.25 top, .16 bottom, 8.5 total)
LANWID==^D12065		; 4.75 inches (.5 left, .25 right, 5.5 total)
ILSPCT==^D111		; Inter-line separation as percentage of font height

; Super-default parameters for Gacha8, used when all else fails:
DEFSIZ==^D<8*2540/72>			; Default font size in micas
DEFLPP==PORHIT/^D<DEFSIZ*ILSPCT/100>	; Default lines per page
DEFCPL==PORWID/^D<DEFSIZ*7/11>		; Default characters per line


; Lookup font name:
; <family-name><point-size><face><rotation>
; <face> = {M|B|L}{R|I}{R|C|E}  (default = MRR)
; <rotation> = {0|90}  (default = 0)
;	A/ address of name string (ASCIZ, terminated by null, space, comma,
;		or period)
; Returns +1:  not found or malformed
;	+2:  found, A/ page height in lines, B/ width in chars
; Clobbers A-D

LUKFNT:	ADD P,[10,,10]		; Make space for temp string on stack
	MOVSI B,-7(P)		; Zero it
	HRRI B,-6(P)
	SETZM -7(P)
	BLT B,0(P)
	MOVEI B,-7(P)		; Make string ptr to temp string
	HRLI B,(POINT 7)
	HRLI A,(POINT 7)	; Make string ptr to source
FAMSCN:	ILDB C,A		; Get char from source
	JUMPE C,LUKFNF		; Fail if run off end
	CAIL C,"a"		; Convert lower-case to upper
	CAILE C,"z"
	 CAIA
	 SUBI C,40
	CAIL C,"A"		; Alphabetic?
	CAILE C,"Z"
	 JRST FAMEND		; No
	IDPB C,B		; Yes, accumulate in temp string
	JRST FAMSCN

; LUKFNT (cont'd)

; Hit a non-alphabetic.  Family name is now in temp string.
; Look it up in font family table.
FAMEND:	PUSH P,A		; Save source string ptr
	MOVN A,NFFAM		; Number of font families
	MOVSI A,0(A)		; Make AOBJN pointer
FAMSRC:	HLRZ B,FNTFAM(A)	; Get ptr to family name string
	MOVEI C,-10(P)		; Name we are looking up
FAMSR1:	MOVE D,0(C)		; Get word of lookup name
	CAME D,0(B)		; Same as family name?
	 JRST FAMSR2		; No
	TRNN D,377		; Yes, last word?
	 JRST FAMFND		; Yes, found family name
	ADDI B,1		; No, advance to next word
	AOJA C,FAMSR1

FAMSR2:	AOBJN A,FAMSRC		; On to next family
	POP P,A			; End, did not find family name, fail
	JRST LUKFNF

; Found family name.  Save family code and parse rest of font name.
FAMFND:	HRRZ B,FNTFAM(A)	; Get family code
	POP P,A			; Recover source string ptr
	LSH B,^D27		; Put family code in top 9 bits, zero rest
	MOVEM B,-7(P)		; Start building index entry here
	LDB C,A			; Recover family name terminator

; Attempt to parse point size
	SETZ B,
PSZSCN:	CAIL C,"0"		; A digit?
	CAILE C,"9"
	 JRST PSZEND		; No
	IMULI B,^D10		; Yes, accumulate point size
	ADDI B,-"0"(C)
	CAIL B,^D1000		; Check reasonableness
	 JRST LUKFNF
	ILDB C,A		; Get next char
	JRST PSZSCN		; On to next

PSZEND:	JUMPE B,LUKFNF		; Zero is an unreasonable point size
	MOVEM B,-6(P)		; Save point size

; LUKFNT (cont'd)

; Attempt to interpret subsequent alphabetics as face identification
	SETZ B,			; Init face code
FACSCN:	CAIL C,"a"		; Lower case?
	CAILE C,"z"
	 CAIA
	 SUBI C,40		; Yes, convert to upper
	SETO D,			; Init this encoding to "none seen"
	CAIN C,"B"
	 MOVEI D,2		; Bold
	CAIN C,"L"
	 MOVEI D,4		; Light
	CAIN C,"I"
	 MOVEI D,1		; Italic
	CAIN C,"C"
	 MOVEI D,6		; Condensed
	CAIN C,"E"
	 MOVEI D,^D12		; Expanded
	CAIE C,"M"
	CAIN C,"R"
	 SETZ D,		; Medium or Regular
	JUMPL D,FACEND		; Jump if no match
	ADDI B,0(D)		; Match, accumulate face code
	ILDB C,A		; Get next char
	JRST FACSCN

; Here when non-face-code character encountered.
FACEND:	DPB B,[POINT 9,-7(P),17] ; Store face code in index entry

; Attempt to interpret subsequent digits as rotation.
	SETZ B,
ROTSCN:	CAIL C,"0"		; A digit?
	CAILE C,"9"
	 JRST ROTEND		; No
	IMULI B,^D10		; Yes, accumulate point size
	ADDI B,-"0"(C)
	ILDB C,A		; Get next
	JRST ROTSCN

ROTEND:	CAIE B,^D90		; Only zero and 90 are reasonable
	 JUMPN B,LUKFNF
	IMULI B,^D60		; Convert to minutes
	HRRM B,-7(P)		; Store rotation in index entry

; We must now be at the end of the font name, else error.
; Accept null, comma, space, or period as end of name.
	CAIE C,","
	CAIN C," "
	 JRST .+3
	CAIE C,"."
	 JUMPN C,LUKFNF

; LUKFNT (cont'd)

; Now have index entry to search for in -7(P) and point size in -6(P).
; Search for matching index entry with corresponding size, or, failing that,
; with zero size (fractional width).
	MOVN A,NWDSEG		; Number of width segments
	MOVSI A,0(A)		; Make AOBJN pointer
	SETZ B,			; Haven't seen matching fractional width
IDXSRC:	MOVE C,-7(P)		; Index entry being looked for
	XOR C,FNTIDX(A)		; Match index entry in table?
	JUMPN C,IDXSR2		; Jump if not
	HLRZ C,FNTWDS(A)	; Yes, get corresponding height
	JUMPE C,IDXSR3		; Jump if zero (fractional size)

; Found absolute entry, check point size
IDXSR1:	IMULI C,^D72		; Convert micas to points
	ADDI C,^D1270		; Round
	IDIVI C,^D2540
	CAMN C,-6(P)		; Match point size being looked up?
	 JRST IDXFND		; Yes, found
	JRST IDXSR5		; No, continue search

; Non-matching entry.  If it is fractional and differs from what we
; are looking for only in rotation, remember it as a possible candidate.
IDXSR2:	TLNE C,-1		; Family and face correct?
	 JRST IDXSR5		; No, give up on this entry
	JUMPN B,IDXSR5		; Ignore if already saw fractional entry
	HLRZ C,FNTWDS(A)	; Get entry height
	JUMPN C,IDXSR5		; Ignore if absolute
IDXSR3:	MOVE B,A		; Remember index of candidate fractional entry
IDXSR5:	AOBJN A,IDXSRC		; Continue search
	JUMPE B,LUKFNF		; Not found, fail unless saw fractional entry

; Found matching fractional entry.  Compute absolute parameters.
	MOVE A,B		; Save index of fractional entry
	MOVE B,-6(P)		; Get point size
	IMULI B,^D2540		; Convert to micas
	IDIVI B,^D72
	HRRZ C,FNTWDS(A)	; Get fractional width (1000ths of point size)
	IMUL C,B		; Convert to micas (absolute)
	IDIVI C,^D1000
	JRST COMPCP		; Go compute character-oriented parameters

; Found matching absolute entry.
IDXFND:	HLRZ B,FNTWDS(A)	; Get height in micas
	HRRZ C,FNTWDS(A)	; Get width in micas

; Now have height in B and width in C, both in micas.
; Convert to character-oriented parameters (lines/page, chars/line).
COMPCP:	PUSH P,C
	IMULI B,ILSPCT		; Compute inter-line separation
	IDIVI B,^D100
	POP P,C
	HRRZ A,-7(P)		; Portrait or landscape?
	JUMPN A,.+2
	 SKIPA D,[PORHIT,,PORWID]  ; Portrait
	 MOVE D,[LANHIT,,LANWID]  ; Landscape
	HLRZ A,D		; Page height in micas
	IDIVI A,(B)		; Compute page height in lines
	HRRZ B,D		; Page width in micas
	IDIVI B,(C)		; Compute page width in characters
	AOS -10(P)		; Preset skip return (success)

; Here upon lookup failure.  Pop temp storage from stack and return
LUKFNF:	SUB P,[10,,10]
	POPJ P,

; Initialize data structures from <FONTS>FONTS.WIDTHS file.
; Called during system initialization and by OPRFN 'INIFNT'.
; Returns +1:  Unsuccessful, A/ error code
;	+2:  Successful
; Clobbers A-D, UNIT, IOS, E, F.

INIFNT::MOVSI A,(1B2+1B17)	; Old file, name from string
	HRROI B,[ASCIZ /<FONTS>FONTS.WIDTHS/]
	GTJFN
	 POPJ P,		; Not found
	HRLM A,0(P)		; Ok, preserve JFN
	MOVE B,[^D16B5+1B19]	; 16-bit bytes, read
	OPENF
	 JRST [	PUSH P,A	; Failed, save error code
		HLRZ A,0(P)	; Recover JFN
		RLJFN		; Release it
		 CAI
		POP P,A		; Return error code
		POPJ P,]

; From this point on, we will overwrite the existing data structure,
; if there is one.  Setting NFFAM to zero will prevent any new family
; name lookups from succeeding until we have completely built the
; new data structure.
	SETZM NFFAM		; No font families
	SETZM NWDSEG		; No width segments
	SETZM FAMSTR		; Zero out name string region
	MOVE A,[FAMSTR,,FAMSTR+1]
	BLT A,FAMSTR+LFAMST-1
	MOVEI UNIT,FAMSTR	; Keep free storage pointer here
	MOVSI E,-MNFFAM		; Keep family table pointer here
	MOVSI F,-MNWSEG		; Keep width table pointer here
	SETZ IOS,		; Current width index file pointer
	ADD P,[10,,10]		; Allocate temp block on stack

; Loop to read FONTS.WIDTHS file
FWDLP:	HLRZ A,-10(P)		; Recover JFN
	MOVE C,IOS		; Current file pointer
	RIN			; Read index entry header
	LDB D,[POINT 4,B,23]	; Get entry type
	JUMPE D,FINFWD		; Type 0 means end of index
	LDB C,[POINT 12,B,35]	; Get entry length
	ADDI IOS,0(C)		; Advance pointer to next entry
	CAILE C,20		; Ignore entry if too big for temp block
	 JRST FWDLP
	MOVNI C,-1(C)		; -length, excluding header word
	MOVEI B,-7(P)		; Where to put it
	HRLI B,(POINT 16)
	SIN			; Read in the body of the block
	CAIN D,1
	 JRST FWDFAM		; Type 1 is family name entry
	CAIN D,4
	 JRST FWDIDX		; Type 4 is width index entry
	JRST FWDLP		; Ignore other types

; INIFNT (cont'd)

; Family name entry -- associates string name with family code.
FWDFAM:	JUMPGE E,IFFAIL		; Jump if family name table is full
	MOVE A,[POINT 8,-7(P),15]
	LDB B,A			; Get family code
	HRRZM B,FNTFAM(E)	; Put in table
	ILDB C,A		; Get string length
	CAIL C,1		; Within limits?
	CAILE C,^D19
	 JRST FWDLP		; No, ignore
	CAILE UNIT,FAMSTR+LFAMST-<^D19+4>/5  ; Room for another string?
	 JRST IFFAIL		; No, fail
	HRLM UNIT,FNTFAM(E)	; Put free storage pointer in table
	HRLI UNIT,(POINT 7)	; Start ASCIZ string here
FWDLP1:	ILDB B,A		; Get char of string
	CAIL B,"a"		; Lower case?
	CAILE B,"z"
	 CAIA
	 SUBI B,40		; Yes, make upper
	IDPB B,UNIT		; Store in new string
	SOJG C,FWDLP1		; Repeat until end
	IBP UNIT		; Point to terminating null
	MOVEI UNIT,1(UNIT)	; New start of free storage
	AOBJN E,.+1		; Advance table index
	JRST FWDLP

; Font width index entry
FWDIDX:	JUMPGE F,IFFAIL		; Jump if width table is full
	LDB A,[POINT 8,-7(P),7]	; Get family code
	LSH A,^D27		; Position to bits 0-8
	LDB B,[POINT 8,-7(P),15]  ; Get face
	TLO A,0(B)		; Insert in bits 9-17
	LDB B,[POINT 16,-6(P),31]  ; Get rotation
	HRRI A,0(B)		; Insert in bits 18-35
	MOVEM A,FNTIDX(F)	; Put width index entry into table
	LDB A,[POINT 16,-6(P),15]  ; Get size
	HRLZM A,FNTWDS(F)	; Store height in width segment table

; If both "A" and "a" exist in this font, compute the average font width
; as 1/5 the width of "A" plus 4/5 the width of "a".
	LDB D,[POINT 8,-7(P),23]  ; Get beginning character code (bc)
	LDB B,[POINT 8,-7(P),31]  ; Get ending character code (ec)
	CAIG D,"A"		; Does the interval contain "A" and "a"?
	CAIGE B,"a"
	 JRST PALTFW		; No, compute width differently
	LDB C,[POINT 32,-5(P),31]  ; Get segment starting address
	ADDI C,4		; Skip over bounding box info
	HLRZ A,-10(P)		; Recover JFN
	HRRZ B,FNTIDX(F)	; Font rotation
	JUMPE B,FWDID2		; Jump if portrait

; INIFNT (cont'd)

; Landscape font, use Y-width information
	RIN			; Read word containing X/YWidthFixed bits
	TRNE B,100000		; Fixed X-width?
	 AOJA C,FWDID1		; Yes, skip over just one word
	LDB A,[POINT 8,-7(P),31]  ; No, skip over entire X-width array
	ADDI C,1(A)		; = ec-bc+1 words
	SUBI C,0(D)
	HLRZ A,-10(P)		; Recover JFN
FWDID1:	TRNE B,40000		; Fixed Y-width?
	 AOJA C,FWDID4		; Yes, next word is width for whole font
	JRST FWDID3		; No, go index into Y-width array

; Portrait font, use X-width information
FWDID2:	RIN			; Read word containing X/YWidthFixed bits
	TRNE B,100000		; Fixed X-width?
	 AOJA C,FWDID4		; Yes, next word is width for whole font
FWDID3:	ADDI C,"A"+1		; Make widthData pointer for "A"
	SUBI C,0(D)
	RIN			; Read width of "A"
	MOVE D,B		; Save it
	ADDI C,"a"-"A"		; Make widthData pointer for "a"
	RIN			; Read width of "a"
	CAIE D,100000		; Test for nonexistent characters
	CAIN B,100000
	 JRST PALTFW		; Use alternate algorithm
	LSH B,2			; 4 * width of "a"
	ADDI B,0(D)		; + width of "A"
	IDIVI B,5		; /5 = "average" font width
	JRST STFWID		; Go store it

; Here to get width for fixed-pitch font -- C has file pointer
FWDID4:	RIN			; Read the width word
	JRST STFWID		; Go store in table

; If "A" or "a" is not present in this font, compute average width
; as 7/11 times its height.
PALTFW:	HLRZ B,FNTWDS(F)	; Recover font height
	SKIPN B			; Fractional?
	 MOVEI B,^D1000		; Yes, width will be fraction of height
	IMULI B,7		; * 7/11
	IDIVI B,^D11
STFWID:	HRRM B,FNTWDS(F)	; Store font width
	AOBJN F,.+1		; Advance index
	JRST FWDLP

; Here when reach end of index entries
FINFWD:	HRRZM E,NFFAM		; Store number of font families
	HRRZM F,NWDSEG		; Number of width segments
	AOSA -10(P)		; Preset skip return

; Here upon failure (table overflow, malformed file, etc.)
IFFAIL:	MOVEI A,OPRFX2		; Return some sort of error code
	SUB P,[10,,10]		; Flush temp block from stack
	HLRZ A,0(P)		; Recover JFN
	CLOSF			; Close the file
	 BUG(CHK,<INIFNT: Unaccountable CLOSF failure>)
	POPJ P,

LPTOPG:	POP P,A
	RLJFN
	  JFCL
LPTOPF:	POP P,B
	MOVEI A,JSBFRE
	PUSHJ P,RELFRE
LPTOPC:	POP P,CAPENB
LP1OPN:	IFNDEF LPTDVF,<
	MOVEI A,OPNX9
	POPJ P,

LPTSQO:
LPTCLZ:	BUG(CHK,<LPT: LPTSQO OR LPTCLZ CALLED WHEN NO LPT EXISTS>)
	POPJ P,
>>		; Close of ifdef at lptopn and lp1opn
IFDEF LPTDVF,<		;DEVICE CODE - HERE TO END OF FILE
   IFN BBNPF,<	;BBN PRINTER OPEN
	LOCK(LPTLCK,<PUSHJ P,LCKTST>)
	MOVE IOS,LPTSTS
	CONSO LPT,20
	JRST [	UNLOCK LPTLCK
		MOVEI A,OPNX8
		POPJ P,]
	TEST(OE,OPN)
	JRST [	UNLOCK LPTLCK
		MOVEI A,OPNX9
		POPJ P,]	; Busy
	TLZ IOS,ALTP!ALTI!OUERR!ESC
	MOVEM IOS,LPTSTS
	SETOM LPTCNT		; Lpt idle
	MOVEI A,LPTBUF
	MOVES (A)
	PUSHJ P,FPTA		; Get ptn.pn for buffer
	PUSHJ P,MLKPG		; Lock the page
	LSH A,9			; Real page number to real address
	TLO A,-400*4		; 400 word count
	MOVEM A,LPTRLP		; Save
	MOVEI A,8
	DPB A,PBYTSZ		; 8 bit bytes
	MOVEI A,0
	DPB A,PBYTPO		; Position
	MOVEI A,LPTBUF-1
	HRRM A,FILBYT(JFN)	; Point to buffer
	MOVEI A,400*3
	MOVEM A,FILBYN(JFN)	; Character count
	TEST(Z,WNDF)
	SETZM LPTPOS		; Column zero, line 0
	UNLOCK LPTLCK
	MOVEI A,240
	PUSHJ P,LPTOUT
	MOVEI A,77
	PUSHJ P,LPTOUT
	MOVE A,JOBNO
	MOVEM A,LPTJOB
	HRRZ A,JOBDIR(A)	; Get login directory number
	CAIN A,1		; If system
	 JRST SKPRET		; No heading
	PUSHJ P,GDIRST		; Get name string location
	JRST LPTOP4
	UNLOCK DIRLCK		; No need to keep directory locked
	OKINT
	HRLI A,(<POINT 7,0,35>)	; Make it a byte pointer
	PUSH P,A		; Save on stack
	PUSH P,[^D10]		; Number of lines of ident
	MOVEI C,3		; Compute names per ident line
	AOS C
	ILDB B,A
	JUMPN B,.-2
	MOVEI B,^D75
	IDIV B,C
	PUSH P,B

LPTOP1:	PUSH P,0(P)		; Number of names per line
LPTOP2:	PUSH P,-3(P)		; Copy byte pointer to stack
LPTOP3:	ILDB A,(P)		; Get byte from string
	JUMPE A,LPTOP4		; End
	PUSHJ P,LPTSQO		; Print it
	JRST LPTOP3		; And loop thru all characters

LPTOP4:	MOVEI A,4
	MOVEM A,0(P)		; Smash spent byte pointer
	MOVEI A,40
	PUSHJ P,LPTSQO
	SOSLE 0(P)
	 JRST .-3
	SUB P,[XWD 1,1]
	SOSLE (P)		; Count names per line
	JRST LPTOP2		; Repeat
	SUB P,[XWD 1,1]		; Flush spent count
	MOVEI A,15
	PUSHJ P,LPTSQO		; End line with CR-LF
	MOVEI A,12
	PUSHJ P,LPTSQO		; ..
	SOSLE -1(P)		; Count lines of heading
	JRST LPTOP1		; Repeat for each line
	SUB P,[XWD 3,3]		; Flush byte pointer, line cnt, name cnt
	MOVEI A,14
	PUSHJ P,LPTSQO		; Output form feed
	JRST SKPRET
   >			;END OF BBNP OPEN

   IFN LP10F,<		;LP10 OPEN
	LOCK LPTLCK,<PUSHJ P,LCKTST>
	MOVE IOS,LPTSTS
	CONSZ LPT,LPTERR	;SKIP IF ON LINE
	JRST [	UNLOCK LPTLCK
		MOVEI A,OPNX8
		POPJ P,]	;FAIL
	TEST(OE,OPN)
	JRST [	UNLOCK LPTLCK
		MOVEI A,OPNX9
		POPJ P,]	;FAIL
	TLZ IOS,ALTP!ALTI!OUERR!LAST
	TLO IOS,FSTBUF
	MOVEM IOS,LPTSTS
	SETOM LPTCNT		; Lpt idle
	SETZM LPTCLS
	MOVEI A,LPTBUF
	MOVES (A)
	PUSHJ P,FPTA		; Get ptn.pn for buffer
	PUSHJ P,MLKPG		; Lock the page
	MOVE A,[XWD -400,LPTBUF]
	MOVEM A,LPTRLP		; Save
	MOVEI A,7
	DPB A,PBYTSZ		; 7 bit bytes
	MOVEI A,0
	DPB A,PBYTPO		; Position
	MOVEI A,LPTBUF-1
	HRRM A,FILBYT(JFN)	; Point to buffer
	MOVEI A,400*5
	MOVEM A,FILBYN(JFN)	; Character count
	TEST(Z,WNDF)
	SETZM LPTPOS		; Column zero, line 0
	UNLOCK LPTLCK
	MOVEI A,14	;FORM FEED
	PUSHJ P,LPTSQO
	MOVE A,JOBNO
	MOVEM A,LPTJOB
	HRRZ A,JOBDIR(A)	; Get login directory number
	CAIN A,1		;SYSTEM?
	JRST SKPRET		;YES, NO HEADING
	PUSHJ P,GDIRST		; Get name string location
	JRST LPTOP4
	UNLOCK DIRLCK		; No need to keep directory locked
	OKINT
	HRLI A,(<POINT 7,0,35>)	; Make it a byte pointer
	PUSH P,A		; Save on stack
	PUSH P,[^D10]		; Number of lines of ident
LPTOP1:	PUSH P,[^D8]		; Number of names per line
LPTOP2:	PUSH P,-2(P)		; Copy byte pointer to stack
LPTOP3:	ILDB A,(P)		; Get byte from string
	JUMPE A,LPTOP4		; End
	PUSHJ P,LPTSQO		; Print it
	JRST LPTOP3		; And loop thru all characters

LPTOP4:	POP P,A			; Flush spent byte pointer
	MOVEI A,11
	PUSHJ P,LPTSQO		; Follow name with tab
	SOSLE (P)		; Count names per line
	JRST LPTOP2		; Repeat
	POP P,A			; Flush spent count
	MOVEI A,15
	PUSHJ P,LPTSQO		; End line with CR-LF
	MOVEI A,12
	PUSHJ P,LPTSQO
	SOSLE (P)		; Count lines of heading
	JRST LPTOP1		; Repeat for each line
	POP P,A			; Flush spent count
	MOVEI A,14
	PUSHJ P,LPTSQO		; Output form feed
	POP P,A			; Flush saved byte pointer
	JRST SKPRET
   >			;END OF LP10 OPEN

; Close line printer

LPTCLZ:	MOVEI A,40
	PUSHJ P,LPTSQO
REPEAT 0,<			; IN THE INTEREST OF SAVING TREES
	MOVE A,LPTPOS
	MOVEI B,4		; End with form feeds to expel listing
	TRNE A,777777		; Unless not at top of form
	ADDI B,1		; THEN ONE MORE
>
REPEAT 1,<
	MOVEI B,1		; FORCE OUT CURRENT PAGE
>
	PUSH P,B
	MOVEI A,14
	PUSHJ P,LPTSQO
	SOSLE (P)
	JRST .-3
	POP P,A
   IFN BBNPF,<
	MOVEI A,240
LPTCL0:	PUSHJ P,LPTOUT
	MOVEI A,200>
   IFN LP10F,<
LPTCL0:	SETZ A,
	PUSHJ P,LPTSQO>
	TEST(NN,WNDF)		; Wndf is set when full
	JRST LPTCL0
	MOVEI 1,LPTCNT
	PUSHJ P,DISL		; Wait for line printer to stop
	MOVEI A,LPTBUF
	PUSHJ P,FPTA
	PUSHJ P,MULKPG
	MOVSI IOS,OPN
	ANDCAM IOS,LPTSTS
	JRST SKPRET

; Line printer sequential character output

   IFN BBNPF,<		;BBNP SEQ OUTPUT
LPTSQO:	ANDI A,177
	MOVSI IOS,ESC
	TDNE IOS,LPTSTS
	JRST [	IORI A,400	; Make it look like no special char
		ANDCAM IOS,LPTSTS
		JRST LPTNOR]
	CAIN A,177
	JRST [	MOVSI IOS,ESC
		IORM IOS,LPTSTS
		POPJ P,]
;	CAIN A,37		; Check for special characters
;	JRST LPTEOL
	JUMPE A,CPOPJ
	CAIL A,12
	CAIL A,25
	JRST LPTNOR
	CAIN A,15
	JRST [	MOVSI IOS,CRSW
		IORM IOS,LPTSTS
		HRRZS LPTPOS
		POPJ P,]
LPTFRM:	SUBI A,12
	IDIVI A,6
	EXCH A,B
	MOVE C,LPTFR1(B)
	MOVE B,LPTFR2(B)
	IMULI A,6
	ROTC B,6(A)
	ANDI B,77
	ANDI C,77
	CAIN C,60
	JRST [	MOVE A,B
		JRST LPTNOR]
	MOVSI A,CRSW
	ANDCAM A,LPTSTS		; Forget about preceding cr's
	HRRZ A,LPTPOS		; Get current line#
	PUSH P,A		; Save
	ADDI A,(B)		; Add skip for this format control
	PUSH P,B		; Save skip
	IDIV A,B		; Reduce to nearest lesser line#
	IMUL A,(P)
	POP P,B
	POP P,B			; Get back old line#
	SUBM A,B		; Get line feeds needed to simulate
	CAIL A,^D60
	TRNE C,40		; Are we to skip end ofpage?
	JRST LPTFRR		; No
	SETZ A,
	MOVEI C,20

LPTFRR:	PUSH P,B		; Save line feed count for simulation
	IDIVI A,^D66		; Reduce new line# mod linesperpage
	HRRM B,LPTPOS
	PUSH P,LPTPOS		; Save current column
	PUSH P,C		; Save format character and bits
	MOVEI A,240
	PUSHJ P,LPTOUT		; Terminate current line
	HRRZS LPTPOS
	POP P,A
	CAIE A,77
	TRZE A,20		; Simulate?
	JRST LPTFRZ
LPTFRQ:	SOSG -1(P)
	JRST LPTFRX
	MOVEI A,240
	PUSHJ P,LPTOUT
	JRST LPTFRQ

LPTFRX:	MOVEI A,40
LPTFRZ:	PUSHJ P,LPTOUT
	POP P,A
	SUB P,[XWD 1,1]
	HLRZS A
	JRST LPTSPC

; Format control tables
; Lptfr1 has the line space count for each format character in
; The range 12 - 24. for non-format characters in this
; Range, it contains the original character code
; Lptfr2 contains the format character to use plus bits as follows
; 40 -- spaces over end of page
; 20 -- not to be simulated with line feeds

LPTFR1:	BYTE (6)1,^D20,^D60,0,16,17,^D30,2,3,1,^D10
LPTFR2:	BYTE (6)37,5,20,77,60,60,6,2,3,40,4

;LPTEOL:	HRRZS LPTPOS
;	MOVEI A,12
;	JRST LPTFRM

LPTCR:	MOVEI A,15
	JRST LPTFRM

LPTNOR:	MOVSI IOS,CRSW
	TDNE IOS,LPTSTS
	JRST [	ANDCAM IOS,LPTSTS
		PUSH P,A
		PUSHJ P,LPTCR
		POP P,A
		JRST .+1]
	CAIE A,177		; IS THE CHARACTER NEW UPARO
	CAIN A,136		; OR NEW CARAT?
	 XORI A,41		; YES, SWAP THE TWO
	CAIE A,137		; IS IT NEW UNDERLINE
	CAIN A,37		; OR OLD UNDERLINE
	 XORI A,100		; YES, EXCHANGE THE TWO
	CAIN A,11
	JRST LPTTAB
LPTNO1:	PUSHJ P,LPTOUT
	MOVSI A,1
	ADDM A,LPTPOS
	POPJ P,

LPTTAB:	HLRZ A,LPTPOS		; Get current column
	ADDI A,10
	ANDCMI A,7
	HLRZ B,LPTPOS
	SUB A,B
LPTSPC:	SOJL A,CPOPJ
	PUSH P,A
	MOVEI A,40
	PUSHJ P,LPTNO1
	POP P,A
	JRST LPTSPC

; Put 8-bit character in buffer

LPTOUT:	MOVSI IOS,OUERR
	TDNE IOS,LPTSTS
	 TEST(O,ERRF)
	ANDCAB IOS,LPTSTS
	TEST(NE,WNDF)
	PUSHJ P,BUFWAT
	HRLZI B,201000
	IBP FILBYT(JFN)
	CAMGE B,FILBYT(JFN)	; Left 12 bits are not used
	HLLM B,FILBYT(JFN)	; Skip them
	DPB A,FILBYT(JFN)
	SOSLE FILBYN(JFN)
	POPJ P,
	MOVE IOS,LPTSTS
	AOSN LPTCNT
	PUSHJ P,LPTSTR
	MOVSI IOS,ALTP
	XORB IOS,LPTSTS
	MOVEI B,LPTBUF-1
	TEST(NN,ALTP)
	HRRM B,FILBYT(JFN)
	MOVEI B,400*3
	MOVEM B,FILBYN(JFN)
	TEST(O,WNDF)
	POPJ P,
   >		;END OF BBNP SEQ OUT

   IFN LP10F,<		;LP10 SEQ OUT
LPTSQO:	ANDI A,177
;	CAIN A,37	;CONVERT EOL
;	MOVEI A,12	;TO LF
	TEST(NE,WNDF)
	PUSHJ P,BUFWAT
	IDPB A,FILBYT(JFN)
	SOSLE FILBYN(JFN)
	POPJ P,
	AOSN LPTCNT	;IF COUNT WAS -1
	PUSHJ P,LPTSTR	;START LPT, OTHERWISE IT WAS GOING
	MOVSI IOS,ALTP
	XORB IOS,LPTSTS
	MOVEI B,LPTBUF-1
	TEST(NN,ALTP)
	HRRM B,FILBYT(JFN)
	MOVEI B,400*5
	MOVEM B,FILBYN(JFN)
	TEST(O,WNDF)
	POPJ P,
   >		;END OF LP10 SEQ OUT

BUFWAT:	PUSH P,1
	SKIPLE LPTCNT
	JRST [	MOVEI 1,LPTCNT		;WAIT FOR COUNT TO GO TO 0
		PUSHJ P,DISLE
		JRST .+1]
	TEST(Z,WNDF)
	POP P,1
	POPJ P,

; Line printer interrupt

	USE	RESPC

   IFN BBNPF,<		;BBNP INT SRV
LPTSV:	XWD LPTINR,.+1
	CONSO LPT,10
	JRST @LPTINR
	MOVEI A,LPTCHR
	MOVEM A,LPTINR
	MOVEM P,LPSTK
	MOVE P,[IOWD LPSTKL-1,LPSTK+1]
	PUSH P,IOS
	MOVE IOS,LPTSTS
	CONI LPT,A
	ANDI A,1600
	TRNE A,1600		; Error?
	JRST LPTER
LPTSV1:	CONO LPT,70(A)		; Reset everything
	TEST(C,ALTI)
	MOVEM IOS,LPTSTS
	SOSL LPTCNT
	PUSHJ P,LPTSTR		; More to do
LPTXIT:	MOVEM IOS,LPTSTS
	POP P,IOS
	POP P,P
	JRST @LPTINR

LPTER:	TRNE A,600		; Nxm or parity?
	JRST LPTBER		; Yes, bad error
	HRLOI A,377777
	MOVEM A,LPTTIM
	JRST LPTXIT

LPTBER:	BUG(NTE,<LINE PRINTER: NXM OR PARITY ERROR.>)
	JRST LPTSV1
   >		;END BBNP INT SRV

   IFN LP10F,<		;LP10 INT SRV
LPTSV:	XWD LPTINR,.+1
	CONSZ LPT,LPTDON+LPTERR
	CONSO LPT,77		;IS PRINTER RUNNING
	JRST @LPTINR		;NO, NOT MY INTERRUPT
	MOVEM P,LPSTK
	MOVE P,[IOWD LPSTKL-1,LPSTK+1]
	PUSH P,IOS
	MOVE IOS,LPTSTS
	CONSZ LPT,LPTERR
	JRST LPTER	;ERROR
	TEST (ZE,LAST)
	JRST LPTNXT	;NO MORE DATA IN THIS BUFFER
LPTOUT:	MOVE A,LPTCCW
	DATAO LPT,0(A)	;OUTPUT NEXT DATA WOR
	AOBJP A,LPTLST	;LAST WORD IN BUFFER
	MOVEM A,LPTCCW
LPTXIT:	POP P,IOS
	POP P,P
	JRST LPTCHR	;RETURN FROM INTERRUPT

;NOTE THAT LAST WORD OF BUFFER WAS TRANSMITTED

LPTLST:	TEST (O,LAST)	;SET LAST FLAG
	MOVEM IOS,LPTSTS
	JRST LPTXIT

;BUFFER COMPLETE, SEE IF MORE TO DO

LPTNXT:	TEST (C,ALTI)	;TOGGLE INTERRUPT BUFFERS
	MOVEM IOS,LPTSTS
	SOSL LPTCNT	;ANOTHER BUFFER READY?
	JRST [	PUSHJ P,LPTSET	;YES, SET IT UP
		JRST LPTOUT]
	CONO LPT,0
	JRST LPTXIT

LPTER:	CONO LPT,0	;SHUT OFF PRINTER
	SETOM LPTCLS
	MOVEI A,^D2000	;SHORT TIME BETWEEN
	MOVEM A,LPTCKT	;LPTCHK'S WHILE PRINTER IS OFF LINE
	MOVEM A,LPTTIM
	JRST LPTXIT

LPTSTR:	PUSHJ P,LPTSET
	TEST(ZN,FSTBUF)		;THIS FIRST BUFFER SINCE OPENING?
	JRST [	CONO LPT,LPTBOT	;NO, JUST POKE PNTR AGAIN
		DATAO LPT,[0]
		POPJ P,]
	MOVEM IOS,LPTSTS
	CONO LPT,LPTBOT+LPTCLR	;YES, CLEAR AND GIVE PI ASSMT, WILL INT
	POPJ P,

LPTSET:	PUSH P,A
	MOVE IOS,LPTSTS
	MOVE A,LPTRLP
	TEST(NE,ALTI)
	ADDI A,400
	MOVEM A,LPTCCW
	POP P,A
	POPJ P,
   >		;END OF LP10 INT SRV

   IFN BBNPF,<		;BBNP PERIODIC CHECK
LPTCHK:	MOVEI A,^D60000
	MOVEM A,LPTTIM
	SKIPE LPTSTS
	SKIPGE LPTCNT		; If doing nothing
	 POPJ P,		; Just return
	CONSO LPT,1B31		; If not on-line
	 JRST [	SOSLE LPTOFC
		POPJ P,
		MOVSI A,OUERR
		IORM A,LPTSTS
		SETOM LPTCNT
		CONO LPT,1070
		POPJ P,]
	BUG(NTE,<LINE PRINTER: HUNG!>)
	CONO LPT,1070
LPTSTR:	PUSH P,A
	MOVE A,LPTRLP
	TEST(NE,ALTI)
	ADDI A,400
	MOVEM A,LPTCCW
	MOVEI A,5		; Minutes of off-line status before err
	MOVEM A,LPTOFC
	MOVEI A,^D60000		; Time to print full buffer of lf's
	MOVEM A,LPTTIM		;  at 10 lines per second
	CONO LPT,1110+LPTCHN
	POP P,A
	POPJ P,
   >		;END OF BBNP CHK

   IFN LP10F,<		;LP10 PERIODIC CHECK
LPTCHK:	MOVE A,LPTCKT
	MOVEM A,LPTTIM		;RESET ALARM
	SKIPN LPTCLS		;CHECKING NEEDED?
	POPJ P,			;NO
	CONSZ LPT,LPTERR	;STILL OFF LINE?
	POPJ P,			;YES
	SETZM LPTCLS		;NO, RESTART IT
	MOVSI A,(1B1)
	MOVEM A,LPTCKT		;MAKE INTERVAL LARGE
	CONO LPT,LPTBOT		;REASSIGN PI
	DATAO LPT,[0]
	POPJ P,
   >		;END OF LP10 CHK
>				; END OF DEVICE CODE AT LPTOP1
>				; End of ifdef lptf on page 1
	END
