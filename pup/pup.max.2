;<134>PUP.MAC;109    28-MAY-81 14:50:03    EDIT BY TAFT
; Fix foreign address selection in PUPOPN -- just plain didn't work!
;<134>PUP.MAC;108    27-MAY-81 19:46:30    EDIT BY TAFT
; Adjust maximum BSP allocations to assume that all Pups are maximum-size.
; This ensures that the byte allocation doesn't run out before the Pup
; allocation, which confuses some BSP implementations (though not this one).
;<134>PUP.MAC;106    15-MAR-81 14:00:27    EDIT BY TAFT
;<134>PUP.MAC;105    14-MAR-81 20:09:30    EDIT BY TAFT
; Fix long-standing Pup performance problems:
; Time-stamp outgoing Pup earlier in SNDBSP so as not to confuse CHKADA.
; Implement adaptive timeout for BSP transmissions.
; Make retransmission timeout be double the measured round-trip delay,
; and make the AData/retransmission cutoff be half the round-trip delay.
; Disable the overlapped Data/Ack feature to reduce the "shooting down
; your Ack" effect.
;<134>PUP.MAC;104    10-MAR-81 12:29:23    EDIT BY TAFT
; Invoke Maxc2 CSUM16 opcode for Pup checksum.
;<134>PUP.MAC;103     2-MAR-81 11:00:55    EDIT BY TAFT
;<134>PUP.MAC;102    28-FEB-81 13:41:22    EDIT BY TAFT
; Remove Pup format definitions to separate UNIVERSAL file PUPFMT.MAC
;<134>PUP.MAC;101    27-FEB-81 15:14:29    EDIT BY TAFT
; Put NTDCHF flag in PUPPAR table
;<134>PUP.MAC;100    17-FEB-81 18:24:08    EDIT BY TAFT
; Add timeout option to PUPI.
; Improve net number defaulting in PUPO.
; Add "default" net number to PUPPAR table.
;<134>PUP.MAC;99    10-FEB-81 16:16:39    EDIT BY TAFT
; Make primitive queue routines internal for new PUPNM
;<134>PUP.MAC;98    15-OCT-80 15:07:43    EDIT BY TAFT
; Speed ADDTQI queue search by unrolling the loop.
;<134>PUP.MAC;97    13-OCT-80 15:08:37    EDIT BY TAFT
; Speed Pup checksum computation by running the main loop in the ACs.
;<134>PUP.MAC;96     8-OCT-80 10:58:43    EDIT BY TAFT
; Do not use stack for address table in PNMDEC -- causes
; stack overflow when PUP OPENF executed from inside another JSYS.
;<134>PUP.MAC;95     5-OCT-80 18:48:09    EDIT BY TAFT
; Make BSP stream buffer setup routines externally callable (for MTANET).
;<134>PUP.MAC;94    27-JAN-80 17:15:01    EDIT BY TAFT
; Fix SNDINT to save args around call to DOBSPL
;<134>PUP.MAC;93    17-MAY-79 13:06:41    EDIT BY TAFT
; Increase size of hop count field to 4 bits.
; Assemble both gateway and non-gateway code and switch to correct version
; at runtime.
;<134>PUP.MAC;92    18-NOV-78 17:41:42    EDIT BY TAFT
; Fix editing error
;<134>PUP.MAC;91    21-OCT-78 13:10:13    EDIT BY TAFT
; If a Pup arrives from an inaccessible net, change the routing table
; to route to net via the immediate source net/host.
;<134>PUP.MAC;90    26-SEP-78 12:36:23    EDIT BY TAFT
; Insert missing end test in RCVDA6 loop!
;<134>PUP.MAC;89     8-SEP-78 10:22:42    EDIT BY TAFT
; Fix PNVDBT to wake up on errors also
;<134>PUP.MAC;88     4-JUL-78 18:24:51    EDIT BY TAFT
; Fix bug at PUPOP4 causing loss of local port if BLDBSP fails
;<134>PUP.MAC;87    12-NOV-77 19:36:57    EDIT BY TAFT
; Fix PUPCLZ to turn FILLFW bit back on before waiting
;<134>PUP.MAC;86    18-JUL-77 15:24:14    EDIT BY TAFT
; Raise IBWDLY to 500 ms
;<134>PUP.MAC;85     6-JUL-77 10:19:34    EDIT BY TAFT
; Change BSP dispatch to update activity timeout only for certain types
;<134>PUP.MAC;84     6-JUL-77 09:56:08    EDIT BY TAFT
; Fix error introduced into RCVERR in last edit
;<134>PUP.MAC;83     3-JUL-77 15:06:09    EDIT BY TAFT
; Increase retransmission timeout when port IQ or gateway OQ error occurs
; Run background fork on SPQ
; Try to direct more freed PBs onto FREIBQ to reduce overhead
; Remove state saving code in previous edit
;<134>PUP.MAC;82     7-MAY-77 21:18:19    EDIT BY TAFT
; Add code to record state of Pup background fork when a port IQ overflows
;<134>PUP.MAC;81    28-APR-77 21:45:23    EDIT BY TAFT
; Make PBGCNT resident, dummy
;<134>PUP.MAC;80    22-APR-77 10:36:47    EDIT BY TAFT
; Add logic to detect potential deadlocks arising from timing marks
;<134>PUP.MAC;79    21-APR-77 16:59:02    EDIT BY TAFT
; Add PUPBGT -- hash table for counting PUPBUGs
;<134>PUP.MAC;78    15-APR-77 12:13:29    EDIT BY TAFT
; Make TTYPUP internal
;<134>PUP.MAC;77     6-APR-77 10:08:59    EDIT BY TAFT
; Lock out PSIs in PNVCOB so interrupt and DM will both be sent
;<134>PUP.MAC;76    25-JAN-77 21:18:40    EDIT BY TAFT
; Parameterize initial routing table
; Put gateway-dependent stuff in GATEWF conditional
; Other changes for Maxc2
;<134>PUP.MAC;74    21-SEP-76 01:43:21    EDIT BY TAFT
; Update routing table
;<134>PUP.MAC;73    17-JUL-76 18:33:51    EDIT BY TAFT
; Add net 6 to routing table
;<134>PUP.MAC;72    13-MAY-76 16:59:15    EDIT BY TAFT
; Repair bad call to RELPKT at FLSBS3+1
;<134>PUP.MAC;71    20-APR-76 22:53:22    EDIT BY TAFT
; Bug fixes
; Generate timing mark reply immediately if a fork is blocked for input
;<134>PUP.MAC;70    20-APR-76 17:42:56    EDIT BY TAFT
; Fix glitch at NVTSYN
;<134>PUP.MAC;69    19-APR-76 00:51:07    EDIT BY TAFT
; Add PUPROU function for OPRFN
;<134>PUP.MAC;67    18-APR-76 21:20:21    EDIT BY TAFT
; Add Telnet timing mark logic
;<134>PUP.MAC;66    18-APR-76 18:39:17    EDIT BY TAFT
; Add code to handle Error Pups
;<134>PUP.MAC;65    17-APR-76 15:33:03    EDIT BY TAFT
; Redo background wakeup strategy -- protective delay without
; added latency in most cases.
;<134>PUP.MAC;64    14-APR-76 20:21:41    EDIT BY TAFT
; Improve hashing algorithm, remove restriction that NPUPUN be prime
;<134>PUP.MAC;63    29-MAR-76 17:35:58    EDIT BY TAFT
; At PUPIN5, force immediate rather than delayed wakeup of background
;  process for NVT ports
;<134>PUP.MAC;62    27-MAR-76 20:08:33    EDIT BY TAFT
; Increase some of the BSP retransmission timeouts
; Change probing strategy on zero allocation
;<134>PUP.MAC;61     7-MAR-76 00:53:56    EDIT BY TAFT
; Reject Pups claiming to be from host zero
;<134>PUP.MAC;60    23-FEB-76 17:24:03    EDIT BY TAFT
; Fix glitch in setting of NVT terminal type
;<134>PUP.MAC;59    25-JAN-76 17:32:23    EDIT BY TAFT
; Take out code to force AData in ATPNVT -- first data will do it anyway
;<134>PUP.MAC;58    22-JAN-76 16:12:41    EDIT BY TAFT
; Background fork back on HIQ -- SETHIQ bug was found
;<134>PUP.MAC;57    20-JAN-76 17:15:26    EDIT BY TAFT
; Run background fork in SPQ (SETHIQ seems not to work)
;<134>PUP.MAC;56    20-JAN-76 03:07:54    EDIT BY TAFT
; Pup received PSI now generated via scheduler request rather
;  than by direct call to PSIRQ from interrupt level.
;<134>PUP.MAC;55    11-JAN-76 21:34:42    EDIT BY TAFT
; Fix assembly glitch -- need () around LOCK/UNLOCK macro args
; Add some ##
;<134>PUP.MAC;54    10-JAN-76 23:48:50    EDIT BY TAFT
; Revise LOCK/UNLOCK calls for 1.34 scheduler handling
; Background fork always runs in HIQ

; Copyright Xerox Corporation 1979, 1980, 1981

; The following declaration ensures that the symbols are linked externally
; rather than binding to local PC values in the UNIVERSAL file.
	EXTERN PPUPUN,PPBPHN,PPBPHH,PPBPHS,PUPLEN,PUPTCB,PUPTYP
	EXTERN PUPID,PPUPDN,PPUPDH,PPUPD0,PPUPD1,PPUPSN,PPUPSH,PPUPSS

	SEARCH STENEX,PROLOG,PUPFMT
	TITLE PUP
	SUBTTL PUP I/O DRIVER FOR MAXC  /  E. A. Taft    March 1975


; -----------------------------------------------------------------
;	Pup Parameter Definitions
; -----------------------------------------------------------------


; Parameters defined in PARAMS.MAC
;  NPUPUN	# Pup "Units".
;  NPUPLN	# Pup NVT's.
;  PUPLO	TTY # of lowest Pup NVT
;  PUPHI	TTY # of highest Pup NVT
;  NPNETS	Maximum # of networks in routing table
;  NPKTBF	# pages of storage for packet buffer allocator
;  NPUPBF	# pages for other Pup storage

;  PUPCHN	PI assignment for Pup I/O interrupts

;  PUPIBG	Begin Pup input device # (Maxc -> NVIO)
;  PUPOBG	Begin Pup output device # (Maxc -> NVIO)
;  PUPIDN	Pup input done device # (NVIO -> Maxc)
;  PUPODN	Pup output done device # (NVIO -> Maxc)

;  XPUPIB	Pup input packet address
;  XPUPOB	Pup output packet address

; Accumulator assignments
; A-D		; Temps
; UNIT		; Pup "Unit" number -- for port-indexed tables
; PB=10		; Packet Buffer pointer
  BSP=12	; BSP data block pointer

; If UCSUMF=1 then invoke CSUM16 microcode for Pup checksum
UCSUMF==MX(0,1)


LS PRSBEG,0	; Start of Pup resident storage
NGS PNRBEG,0	; Start of Pup nonresident storage


; Pup Type assignments

PT.ECH==1	; Echo Me
PT.IEC==2	; I'm An Echo
PT.BEC==3	; I'm A Bad Echo
PT.ERR==4	; Error
PT.RFC==10	; Request for Connection
PT.ABT==11	; Abort
PT.END==12	; End
PT.ENR==13	; End Reply
PT.DAT==20	; Data
PT.ADA==21	; AData
PT.ACK==22	; Acknowledgment
PT.MRK==23	; Mark
PT.INT==24	; Interrupt
PT.INR==25	; Interrupt Reply
PT.AMA==26	; AMark

; Network-dependent stuff


; Network tables, indexed by net # -1

			; The following is a documented GETAB table
GS PUPROU,NPNETS	; Network routing table
 ; B0				; Network inaccessible
 BROADF==1B1			; Broadcast packets allowed on net
 ; B2-17			; Net/host to which packets should
				;  be routed (0 => route directly)
 ; B18-35			; Address of Maxc on this net (0 => not on net)


; Table for initializing routing table

USE SWAPPC

DEFINE HSTMAC(NET,HOST,BROADCAST) <
	<IFNB <BROADCAST>,<BROADF>>+<NET>B17+<HOST>B35>

PUPIRT:	PUPHST(HSTMAC)		; Expand def from PARAMS.MAC
LPUPIR==.-PUPIRT

USE RESPC


; Pup storage parameters and assignments

LS PKTFRE,7	; Packet buffer free storage header (standard ASGFRE form)
NGSP PKTBUF,NPKTBF  ; Packet buffer free storage region
LS PUPFRE,7	; Pup free storage header
NGSP PUPBUF,NPUPBF  ; Pup free storage region

NPKTBW==NPKTBF*1000  ; # words of packet buffer storage
MAXIQW==NPKTBW/^D15  ; Max # words on one port's input queue
MAXIQB==^D15	; Max # buffers on one port's input queue
MAXOQW==NPKTBW/^D15  ; Max # words on one port's output queue
MAXOQB==^D15	; Max # buffers on one port's output queue
MAXGQW==NPKTBW/^D10  ; Max # words allowed on gateway queue
MAXGQB==^D20	; Max # buffers allowed on gateway queue
MINFIB==^D12	; Min # free input buffers to maintain
MAXFIB==^D20	; Max # free input buffers to maintain


; Pup parameter GETAB table
; Must be resident because it is referenced by the GATEWY code
PUPPAR::-NPUPLN,,PUPLO	; (0) -# of Pup NVT's, TTY# of first NVT
	PUPBUF		; (1) Start of Pup free storage
DEFNET:	<GATEWF>B0+<NTDCHF>B1+DFPNET ; (2) B0 set if we are a gateway
			; B1 set if network directory is cached rather than kept in entirety
			; B18-35: Default directly-connected net number

NPUPPR==:.-PUPPAR	; Length of this table

; Pup queues

; All queues are doubly-linked through 36-bit link words.
; A queue header is in the form
;	Pointer to queue tail ,, Pointer to queue head
;  where self-pointers denote an empty queue.
; A queue item (e.g. a packet link word) is in the form
;	Pointer to predecessor ,, Pointer to successor
; All pointers point to other queue items or to header words.
; This permits uniform queue management without special cases.

; All Packet Buffers are linked through PBIOBQ except as noted

LS PBQBEG,0		; Start of queue header block

; Queues referenced by input interrupt:

LS FREIBQ		; Free input buffer queue.
			; Consists of max-length buffers, locked
			;  into core, for use by input interrupt

LS PUPIBQ,NPUPUN	; Input buffer queue, one per port.
			; Packets received for that port

LS DSCIBQ		; Discarded input buffer queue.
			; Packets waiting to be logged and discarded
			;  by job 0 or error process


; Queues referenced by output interrupt:

LS PUPOBQ		; Pup output buffer queue.
			; Packets awaiting service by output interrupt

LS FREOBQ		; Free (discarded) output buffer queue.
			; Waiting to be returned to free storage

LS PBQEND,0		; End of queue header block

; Port-indexed tables

; ** The following are documented GETAB tables **

GS PUPLSK,NPUPUN	; Local socket number hash table
			; 0 => free, -1 => deleted

GS PUPLNH,NPUPUN	; Local Net/Host and BSP linkage
 PPRTLN: POINT 8,PUPLNH(UNIT),7	; Local net # (0 => wildcard)
 PPRTLH: POINT 8,PUPLNH(UNIT),15 ; Local host # (0 => wildcard)
 ; B16-17			; Unused
 ; B18-35			; Pointer to BSP data block
				; 0 => not a BSP port

NGS PUPFPT,NPUPUN	; Foreign port:  -length,,adr-1 of address table
			; 0 => foreign port is fully wildcard

GS PUPSTS,NPUPUN	; Port status word (mostly for BSP)
 BSLCKF==1B0			; Port is locked (must be sign)
 BSWAKF==1B1			; BSP wakeup request pending
 BSINPF==1B2			; Input available
 BSOUTF==1B3			; Output possible
 BSMRKF==1B4			; Mark encountered in stream
 BSENDF==1B5			; End encountered in stream
 BSTIMF==1B6			; Timeout
 BSNCHK==1B7			; Supress checksumming
 BSOPNR==1B8			; Port open for reading
 BSOPNW==1B9			; Port open for writing
 DSCRNF==1B10			; Random discard enabled
 BSSAKF==1B11			; Need to send Ack
 BSRAKF==1B12			; Received Ack
 BSZALF==1B13			; Sent Ack with zero allocation
 BSINTF==1B14			; Interrupt outstanding
 BSLISF==1B15			; Port is or has been listening
 BSNOQF==1B16			; BSP output queue is non-empty
 BSERRF==1B17			; Set if port gets in bad state
 ; B18-31 unused
 PBSSTM: POINT 4,PUPSTS(UNIT),35  ; State # in memory
 PBSSTA: POINT 4,PUPSTS(A),35	; State # in memory, indexed by A
 PBSSTT: POINT 4,IOS,35		; State # in usual ac

; ** End of documented GETAB tables **

LS PUPIBC,NPUPUN	; Input buffer counts
 ; B0-17			; Number of buffers allocated
 ; B18-35			; Number of words allocated

LS PUPOBC,NPUPUN+1	; Output buffer counts
 ; B0-17			; Number of buffers allocated
 ; B18-35			; Number of words allocated
			; Extra entry is for gateway output

LS PUPPSI,NPUPUN	; Port PSI assignments and other stuff
 INTPSI: POINT 6,PUPPSI(UNIT),5	; BSP Interrupt PSI channel
 RECPSI: POINT 6,PUPPSI(UNIT),11  ; Received Packet PSI channel
 STCPSI: POINT 6,PUPPSI(UNIT),17  ; BSP State Change PSI channel
 ; 18-35			; Fork to interrupt (-1 => none)
				;  or 400000 + attached TTY #

; ***** Do not change the order of the following *****

LS PUPTQH		; Timer queue head
LS PUPTMQ,NPUPUN	; Timer queue linkage

LS PUPFTM		; Time word corresponding to PUPTQH
LS PUPTIM,NPUPUN	; BSP timer
			; TODCLK at which BSP processing next
			;  required for timing retransmissions

PUPTQD==NPUPUN+1	; PUPTIM-PUPTMQ displacement

; ***** End of do not change *****

; Definition of BSP data block

DEFINE BSWRD(LABEL) <
	LABEL==BSPSIZ
	BSPSIZ==BSPSIZ+1
>

BSPSIZ==0

BSWRD(BSPHDR)		; Header word
 PBSMRK: POINT 8,BSPHDR(BSP),7	; Value of most recent Mark
 PBSTMO: POINT 8,BSPHDR(BSP),15	; Error timeout interval / 2^12 ms
 ; B16-17			; Unused
 ; B18-35			; Size of BSP data block (words)

BSWRD(BSPTIM)		; BSP timing parameters
 ; B0-17			; Estimated round-trip delay (ms)
 ; B18-35			; Pointer to received Abort if any

; Timer words (TODCLK format) - for flow control and retransmission
BSWRD(BSPACT)		; Time of most recent activity
BSWRD(BSPDTM)		; Time at which to do BSP retransmissions
BSWRD(BSPATM)		; Time last AData was sent
			; 0 => No AData outstanding
BSWRD(BSPITM)		; Time at which to retransmit Interrupt
BSWRD(BSPFTM)		; Time at which to check FSM
BSWRD(BSPSTM)		; Time of most recent FSM state change

; Packet buffer pointers and queues
BSWRD(BSPCUR)		; Current buffers being packed/unpacked
 ; B0-17			; Current input buffer (0 => none)
 ; B18-35			; Current output buffer (0 => none)
BSWRD(BSPIBQ)		; BSP Input queue (linked thru PBBSPQ)
BSWRD(BSPOBQ)		; BSP Output queue (linked thru PBBSPQ)

; Sequence numbers, allocations, counters, etc.
BSWRD(BSPCID)		; BSP Connection ID
			; -1 => no ID assigned yet (listening)
BSWRD(BSPRII)		; BSP Receive Interrupt ID
BSWRD(BSPSII)		; BSP Send Interrupt ID
 ; B0 set => B18-35 point to unacknowledged send Interrupt PB

BSWRD(BSPILW)		; BSP Input left window edge
			; ID of next byte to be removed by
			;  inputting process
BSWRD(BSPIQL)		; BSP Input queue length
 ; B0-17			; # Pups in BSP input queue
 ; B18-35			; # bytes from BSPILW to first hole
BSWRD(BSPIAL)		; BSP Input allocation
 PBSIAP: POINT 8,BSPIAL(BSP),7	; Total input Pups allowed
 PBSIBP: POINT 10,BSPIAL(BSP),17 ; Maximum data bytes/Pup
 ; B18-35			; Maximum # bytes allowed

BSWRD(BSPOLW)		; BSP Output left window edge
			; Pup ID of last received Ack
BSWRD(BSPOQL)		; BSP Output queue length
 ; B0-17			; # Pups in BSP output queue
 ; B18-35			; # bytes spanned by BSP output queue
BSWRD(BSPOAL)		; BSP Output allocation
 PBSOAP: POINT 8,BSPOAL(BSP),7	; Additional Pups allowed
 PBSOBP: POINT 10,BSPOAL(BSP),17 ; Maximum data bytes/Pup
 ; B18-35			; Additional bytes allowed


; Statistics
BSWRD(BSPOPG)		; BSP Output packets generated
BSWRD(BSPOPR)		; BSP Output packets retransmitted
BSWRD(BSPPPG)		; BSP Probe packets generated

; BSP-related parameters

MXBSIP==<MAXIQW/MXPBLN>-1	; Max # Pups we allow on BSP input queue
MXBSIB==MXBSIP*<MXPLEN-MNPLEN>	; Max # bytes we allow on BSP input queue
MXBSOP==<MAXOQW/MXPBLN>-1	; Max # Pups we allow on BSP output queue
MXBSOB==MXBSOP*<MXPLEN-MNPLEN>	; Max # bytes we allow on BSP output queue
MXSACK==0		; Max # Pos/NegAck blocks per Ack Pup
			; 0 => Ignore incoming Pos/NegAcks also
MXPTXT==^D75		; Max # bytes of text in Interrupt, Abort

MINBWI==^D100		; Minimum background wakeup interval (ms)
			; Background process waits at least this long
			; when it dismisses before waking up again.
IBWDLY==^D500		; Input background wakeup delay (ms)
			; When an input packet arrives, wakeup of the
			; background process is delayed this long in
			; hopes that the user fork will process the input
RETINT==^D100		; Nominal retransmission interval (ms)
MINRET==^D25		; Minimum retransmission interval
MAXRET==^D10000		; Maximum retransmission interval
HLDINT==^D1000		; Hold interval (expiration forces AData)
PRBINT==^D15000		; Probe interval for idle connection (ms)
DETINT==^D120		; Default error timeout interval (sec)

ALLPCT==^D0		; % of total allocation (Pups or bytes)
			;  below which an AData is sent to request
			;  new allocation.  0 = don't overlap Data/Acks.


; Macro to assemble bits corresponding to up to 8 listed port states
; Call by:	STTBTS(STATE1,STATE2, ...)

DEFINE STTBTS(A,B,C,D,E,F,G,H) <<$S(A)+$S(B)+$S(C)+$S(D)+$S(E)+$S(F)+$S(G)+$S(H)>>

DEFINE $S(STATE) <IFNB <STATE>,<1B<S.'STATE>>>


; Macro to assemble code to skip if current state is among those listed
; Call by:	CHKSTT(<STATE1,STATE2, ...>,AC)
; Assumes UNIT setup, clobbers A unless AC specified

DEFINE CHKSTT(STATES,AC<A>) <
	LDB AC,PBSSTT		; Get current state
	MOVE AC,BITS##(AC)	; Get bit corresponding to state
	TLNN AC,(STTBTS(STATES))  ; Skip if among those listed
>



; Pup NVT data
; Indexed by Pup NVT # (= TTY # - PUPLO)
; ** This is a documented GETAB table **

GS NVTPUP,NPUPLN	; NVT data
TTYPUP=:NVTPUP-PUPLO	; NVTPUP indexable directly by TTY #
 ; B0				; 1 => NVT assigned
 PSYNCT: POINT 3,TTYPUP(B),3	; Sync count (Int's - DM's)
 SYNCNT==7B3			; Mask of bits in sync count
 PSYNTM: POINT 3,TTYPUP(B),6	; Sync timer
 PNVSTT: POINT 2,TTYPUP(B),8	; NVT state for input processing
 PNVMRK: POINT 4,TTYPUP(B),12	; Pending Mark type if any
 HUREQF==1B13			; Hangup request already made
 PTMKCT: POINT 3,TTYPUP(B),16	; Count of incoming timing marks pending
 TMKPNF==1B17			; Outgoing timing mark pending
 ; B18-35			; Pup unit # of attached port


SYNCHI==^D10000		; Sync check interval (ms)
SYNTMO==^D20000/SYNCHI	; Sync timeout interval (20 seconds)

LS NVTLCK		; Lock for NVT assignment and management

; Error handling

; In addition to the usual BUGHLT, BUGCHK, and BUGNTE (for reporting
;  internal errors), there is a collection of BUG types for
;  reporting anomalies associated with a particular Pup and/or
;  discarding that Pup.

; BUG(PUP,<message>,X)
;  Copies the header of the packet pointed to by PB into cells
;  looked at by job 0.  If PUPBGF is nonzero, this data is printed
;  on the logging console by job 0.

; BUG(DIP,<message>,X)
;  Appends the packet pointer to by PB to the discarded input
;  packet queue (DSCIBQ).  The PC of the BUG is stored in the RH
;  of the PBBSPQ word.  If PUPBGF is nonzero, information
;  about this packet is printed on the logging console by job 0.
;  (Later we may provide a mechanism whereby a user process can
;  arrange to receive all discarded Pups).  The buffer is then
;  deallocated.

; BUG(DPR,<message>,X)
;  Same as BUG(DIP,...) except that an extra POPJ is executed
;  so that the routine invoking the BUG is exited.



; JSYS error macros, adapted from JSYS.MAC

DEFINE ERROR(ERRORN,EXTRA,WHERE) <
IFB <ERRORN'EXTRA>,<JRST WHERE>
IFNB <ERRORN'EXTRA>,<
	JRST [	EXTRA
		IFNB <ERRORN>,<MOVEI A,ERRORN>
		JRST WHERE]
>>

; Load error code and do POPJ P,
DEFINE ERPOPJ(ERRORN,EXTRA) <ERROR(ERRORN,<EXTRA>,CPOPJ##)>

; Store error code and give error return from JSYS
DEFINE ERR(ERRORN,EXTRA) <ERROR(ERRORN,<EXTRA>,ERRD##)>

; Store error code, unlock JFN, and give error return from JSYS
DEFINE ERUNLK(ERRORN,EXTRA) <ERROR(ERRORN,<EXTRA>,ERUNLD##)>

; Store error code and generate instruction trap
DEFINE ERABRT(ERRORN,EXTRA) <ERROR(ERRORN,<EXTRA>,ERABRD##)>

; Store error code, unlock JFN, and generate instruction trap
DEFINE FILABT(ERRORN,EXTRA) <ERROR(ERRORN,<EXTRA>,ABTDO##)>

; Store error code, unlock JFN, and give i/o data error psi
DEFINE FILINT(ERRORN,EXTRA) <ERROR(ERRORN,<EXTRA>,DOINT##)>

; Macro to activate Pup background process.
; SIGPBP(XXX) causes bit PBFXXX to be set in PUPFLG.  This causes
;  the Pup background process to wakeup and call the routine
;  implementing the requested background task (see PUPBAK).
; Optional arguments:
;	SIGPBP(FLAG,<INSTRUCTION>,AC)
; If <INSTRUCTION> is specified, the flag is set iff the
; instruction does not skip.  If AC is specified, it (instead of
; A) is the ac clobbered by the generated code.

DEFINE SIGPBP(FLAG,INST,AC<A>) <
	MOVSI AC,(PBF'FLAG)
	INST
	IORM AC,PUPFLG
>

LS PUPFLG		; Records Pup background process requests
LS NXTWAK		; Earliest time at which next wakeup permitted


; Random other data referenced in more than one place.
; (Storage used in only one place is defined at that place)

LS PRTLCK		; Lock for changes to port tables
LS LSKNDL		; # of deleted entries in local socket table
LS FREIBN		; # buffers in FREIBQ
GS PUPFRK		; FORKX of Pup background process

LS SYNTIM		; Time for next sync timeout check


; Notes on handling of locks:
; PRTLCK should be locked while attempting to lock a port, then
;  unlocked once the port is locked.
; NVTLCK should be locked while doing anything to an NVT.
; No lock should be held while waiting for a port lock to become free.
; If both NVTLCK and PRTLCK need be locked simultaneously, NVTLCK
;  must be locked first to prevent deadlocks.
; Lockers of PRTLCK should invoke SPQ (Special Queue), unless it is
;  known that the locker is the Pup background fork, which already
;  runs on HIQ.
; Lockers of NVTLCK should invoke HIQ unless it is known that the
;  locker is the Pup background fork.


; -----------------------------------------------------------------
;	Standard JSYS Routines for Pup
; -----------------------------------------------------------------

USE SWAPPC

; Pup device dispatch table

PUPDTB::PUPSET		; Directory setup
	PUPNAM		; Name lookup
	PUPEXT		; Extension lookup
	GJSRET		; Version lookup
	CPOPJ##		; Insert protection
	CPOPJ##		; Insert account
	CPOPJ##		; Insert status
	PUPOPN		; Open
	PUPSQI		; Sequential input
	PUPSQO		; Sequential output
	PUPCLZ		; Close
	CPOPJ##		; Rename
	CPOPJ##		; Delete
	CPOPJ##		; Dump input
	CPOPJ##		; Dump output
	CPOPJ##		; Mount
	CPOPJ##		; Dismount
	CPOPJ##		; Initialize directory
	PUPMTP		; MTOPR
	PUPGST		; Get status
	PUPSST		; Set status


; Lookup routines called by GTJFN

DEFINE GJERR(ERRORN) <ERROR(ERRORN,,GJERRX)>


; Directory setup routine

PUPSET:	NOINT
	JRST SK2RET##		; Always successful


; Name lookup routine

PUPNAM:	JUMPE A,[GJERR(GJFX31)]	; * not allowed
	HRLI A,(POINT 7,,35)	; Make string pointer
	PUSHJ P,PNMDEC		; Decode name string
	 GJERR(GJFX18)		; Bad, say no such name
	JRST GJ2RET		; Ok, take success return


; Extension lookup routine

PUPEXT:	JUMPE A,[GJERR(GJFX31)]	; * not allowed
	HRLI A,(POINT 7,,35)	; Make string pointer
	PUSHJ P,PEXDEC		; Decode extension string
	 GJERR(GJFX19)		; Bad, say no such extension
	MOVEI B,(A)		; Ok, now just throw the block away
	PUSHJ P,RELPFR
;	JRST GJ2RET		; Take success return


; Version lookup routine (always succeeds, does nothing)


; Returns from GTJFN routines
GJ2RET:	AOS 0(P)		; Double skip
GJSRET:	AOS 0(P)		; Single skip
	TEST(NE,UNLKF)		; Should we unlock?
	 POPJ P,		; No
GJERRX:	OKINT			; Yes
	POPJ P,

; Open Pup network file (OPENF)

DEFINE OPNERR(ERRORN,EXTRA) <ERROR(ERRORN,<EXTRA>,OPNERX)>

; Check mode and byte size
PUPOPN:	TEST(NN,XCTF,RNDF)	; Xct and append are illegal
	TEST(NN,READF,WRTF)	; Must be reading or writing
	 ERPOPJ(OPNX13)		; Illegal access
	TRNE STS,10		; Raw packet mode (16)?
	 JRST PUPOP0		; Yes, skip some checks
	TEST(C,READF,WRTF)	; BSP can do only one or the other
	TEST(CN,READF,WRTF)
	 ERPOPJ(OPNX13)		; Both read and write is illegal
	LDB A,PBYTSZ##		; Get byte size
	CAIE A,7		; Only 7 and 8 allowed
	CAIN A,8
	 CAIA
	 ERPOPJ(SFBSX2)		; Illegal byte size

; Re-parse the name and extension strings to yield addresses
PUPOP0:	HRRZ A,FILNEN(JFN)	; Make byte ptr to extension
	HRLI A,(POINT 7,,35)
	PUSHJ P,PEXDEC		; Decode Pup extension string
	 ERPOPJ(OPNX2)		; Failed (maybe net dir changed?)
	MOVE E,A		; Save address table pointer
	HLRZ A,FILNEN(JFN)	; Make byte ptr to filename
	HRLI A,(POINT 7,,35)
	PUSHJ P,PNMDEC		; Decode Pup name string
	 OPNERR(OPNX2)		; Failed (maybe net dir changed?)

; Now have A/ <net>B7 + <host>B15, B/ socket for local port.
; Check for correct access to the specified socket number
	MOVE C,CAPENB##		; Get privilege bits
	TRNE C,WHEEL!OPR	; Wheel or operator?
	 JRST PUPOP1		; Yes, can have any socket
	MOVE C,B		; No, get high 17 bits
	LSH C,-^D15
	MOVE D,FORKX##		; Get fork number
	SKIPGE D,FKDIR##(D)	; Connected,,login dir if top fork
	 JRST .-1		; Pointer to top of group if not
	CAIN C,(D)		; User-relative for login dir?
	 JRST PUPOP1		; Yes, ok
	HLRZ D,D		; Try connected dir
	CAIL C,^D50000		; Socket in free-for-all range?
	 CAILE C,^D99999
	 CAIN C,(D)		; No, user-relative for this fork?
	 JRST PUPOP1		; Either of those, socket ok
	MOVE D,JOBNO		; No, get job number
	CAIE C,^D100000(D)	; Job-relative for this job?
	 OPNERR(OPNX13)		; No, illegal access to socket

; OPENF (cont'd)

; If mode 0, 1, or 4, ensure foreign port is not multiple or wild
PUPOP1:	TRNE STS,12		; Ok if mode 2, 3, or 16
	 JRST PUPOP3
	CAML E,[-2,,0]		; Multiple?
	 JRST PUPOP2		; No, go check for wildcard

; Multiple foreign address
; Pick the first one on a directly-connected network, or else the
;  first one that is accessible.
	PUSH P,A		; Save local port address
	PUSH P,B
	MOVE D,E		; Copy foreign address table ptr
	SETZ C,			; No choice yet
PUPO1A:	HLRZ A,1(D)		; Get a net from table
	CAIL A,1		; In range?
	 CAILE A,NPNETS
	 JRST PUPO1B		; No
	SKIPGE B,PUPROU-1(A)	; Yes, get entry
	 JRST PUPO1B		; Inaccessible, ignore
	TLNE B,(177777B17)	; Routing directly to network?
	SKIPN C			; No, already have saved index?
	 MOVE C,D		; Local or no index yet, save index
	TLNN B,(177777B17)	; Routing directly to net?
	 JRST PUPO1C		; Yes, use this entry
PUPO1B:	AOBJN D,.+1		; Advance table pointer (2 words)
	AOBJN D,PUPO1A		; Try next if any remain
PUPO1C:	JUMPE C,[POP P,B	; Fail if none found
		POP P,A
		OPNERR(PUPX2)]
	MOVE A,1(C)		; Store selected address at
	MOVEM A,1(E)		;  start of block
	MOVE A,2(C)
	MOVEM A,2(E)
	MOVEI A,0(E)		; Copy pointer to block
	MOVEI B,3		; New size of block
	PUSHJ P,TRMPFR		; Trim the address block
	HRLI E,-2		; Now just 2 words in table
	POP P,B			; Recover local port
	POP P,A

; Give error if foreign port now has any wildcard elements.
; Substitute appropriate values for wildcard local net/host
PUPOP2:	SKIPN 2(E)		; Wild socket?
	 OPNERR(PUPX2)		; Yes, address error
	HLRZ C,1(E)		; Get net
	SKIPE C			; Wildcard?
	 CAILE C,NPNETS		; Out of range?
	 OPNERR(PUPX2)		; Yes, address error
	HRRZ D,1(E)		; Get host
	SKIPE D			; Wildcard?
	 SKIPGE D,PUPROU-1(C)	; Dest net inaccessible?
	 OPNERR(PUPX2)		; Yes, address error
	JUMPN A,PUPOP3		; Local net/host specified?
	TRNN D,-1		; No, are we on dest net?
	 LDB C,[POINT 8,PUPROU-1(C),9]  ; No, use net of gateway
	HRRZ D,PUPROU-1(C)	; Get our address on that net
	ROT D,-8		; Concatenate net/host
	LSHC C,-8		; Left-justify in D
	MOVE A,D		; Put in proper ac

; OPENF (cont'd)

; Now have A/ <net>B7 + <host>B15, B/ socket for local port.
; Attempt to assign the local port
PUPOP3:	PUSHJ P,ASGPRT		; Assign local port
	 OPNERR(OPNX10)		; Failed, tables full
	 JRST PUPOP6		; Duplicate, check for legal cases
	HRLM UNIT,DEV		; Success, remember Pup unit #
	HRLM UNIT,FILDEV(JFN)
	MOVE A,FORKX##		; Record fork owning port
	HRRM A,PUPPSI(UNIT)
	MOVEM E,PUPFPT(UNIT)	; Save address table pointer
	TRNN STS,10		; Raw packet mode?
	 JRST PUPOP4		; No, BSP, more to do

; Successful open in raw packet mode, finish up and return
	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Unlock local socket table
	SKIPN 1(E)		; Is foreign port fully wildcard?
	SKIPE 2(E)
	 JRST SKPRET##		; No, done
	SETZM PUPFPT(UNIT)	; Yes, remember so
	MOVEI B,(E)		; Release the address block
	PUSHJ P,RELPFR
	JRST SKPRET##		; Done, skip return

; Here if BSP mode.  Lock port and setup BSP data block
PUPOP4:	PUSHJ P,BLDBSP		; Allocate and build BSP data block
	 ERPOPJ(OPNX10,<UNLOCK(PRTLCK,RESIDENT,SPQ)
			PUSHJ P,DELPRT>)  ; Failed
	HRRM BSP,PUPLNH(UNIT)	; Store pointer in standard place
	MOVSI IOS,(BSLCKF+BSOPNR)  ; Assume opening for reading
	TEST(NE,WRTF)		; Writing?
	 MOVSI IOS,(BSLCKF+BSOPNW)  ; Yes
	MOVEM IOS,PUPSTS(UNIT)	; Initialize port status word
	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Unlock local socket table
	XCTUU [HLRZ A,2]	; Get lh 2 from user
	TRNE A,377		; Timeout interval specified?
	 DPB A,PBSTMO		; Yes, set it

; Initiate appropriate operations to open a connection
	TRNE STS,2		; Listening?
	 JRST [	TLO IOS,(BSLISF)  ; Yes, remember so
		MOVEI A,E.OPNL	; Generate event OPENF(L)
		JRST PUPOP5]
	TRNE STS,4		; Direct open (no rendezvous)?
	 JRST [	UMOVE A,3	; Yes, get Connection ID from user
		PUSHJ P,SETCID	; Set it in data block
		MOVEI A,E.OPNN	; Generate event OPENF(N)
		JRST PUPOP5]
	MOVEI A,E.OPNC		; Initiating rendezvous, OPENF(C)
PUPOP5:	PUSHJ P,PUPFSM		; Activate the FSM appropriately
	JRST PUPOP7		; Go wait if necessary

; Here if local port already in use, check for legal case
PUPOP6:	HRRZ BSP,PUPLNH(UNIT)
	SKIPE BSP		; Already open in raw packet mode?
	TRNE STS,10		; Opening in raw packet mode?
	 OPNERR(OPNX9,<UNLOCK(PRTLCK,RESIDENT,SPQ)>)  ; Yes, fail
	HRRZ A,PUPPSI(UNIT)	; No, get fork that did first open
	HLRZ A,FKJOB##(A)	; Get job
	CAME A,JOBNO		; Same as me?
	 OPNERR(OPNX9,<UNLOCK(PRTLCK,RESIDENT,SPQ)>)  ; No, fail
	MOVEI B,(E)		; Ok, get rid of address table
	PUSHJ P,RELPFR
	PUSHJ P,LCKBSA		; Attempt to lock the port
	 JRST [	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Can't, unlock the table
		MOVSI A,(UNIT)	; Set scheduler test
		HRRI A,BSLCKT	;  for port unlocked
		JSYS EDISMS##	; Wait until unlocked
		JRST PUPOP0]	; Try again
	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Ok, unlock the table
	PUSHJ P,SETRWB		; Setup read/write bit for this opening
	TDOE IOS,A		; Flag opening, check for conflict
	 ERPOPJ(OPNX9,<PUSHJ P,ULKBSP>)  ; Already open, fail
	HRLM UNIT,DEV		; Remember Pup unit #
	HRLM UNIT,FILDEV(JFN)

; OPENF (cont'd)

; Here to wait for completion if necessary
PUPOP7:	CHKSTT <OPEN,ENDI,ENDO,DALY,ABOR,CLOS>  ; Beyond LIST/RFCO state?
	 TRNE STS,5		; Immediate return OPENF?
	 JRST PUPOP8		; Yes, bypass waiting
	PUSHJ P,ULKBSP		; Unlock port
	TEST(O,OPNF)		; Mark JFN as being open
	MOVSI A,1		; Fix reference count (?)
	IORM A,FILLFW(JFN)
	PUSHJ P,UNLCKF##	; Unlock file, go OKINT
	MOVSI A,(ALLSTT-STTBTS(LIST,RFCO))
	PUSHJ P,WATSTT		; In desired state now?
	 JSYS EDISMS##		; No, wait until get there

; Check whether the connection was opened successfully
; This is somewhat hairy since a PSI or another fork could have
;  released and re-used the JFN in the meantime
	LSH JFN,-SJFN
	PUSHJ P,CHKJFN##	; NOINT, lock JFN again
	 ERR()			; Huh? (released by PSI maybe)
	 ERUNLK(DESX4)
	 ERUNLK(DESX4)
	MOVSI A,(UNIT)		; Make sure JFN still refers to
	HRRI A,PUPDTB		;  the same Pup port
	CAME A,DEV
	 ERPOPJ(DESX5)		; Not, fail
	TEST(NE,OPNF)		; Make sure JFN still open
	 PUSHJ P,LCKBSQ		; Lock the port again
	 ERPOPJ(DESX5)		; Not open or not BSP port
	MOVSI A,1		; Undo reference count diddle
	ANDCAM A,FILLFW(JFN)

; Come directly here in immediate-return modes
PUPOP8:	CHKSTT <CLOS,ABOR>	; Connection closed or aborted?
	 TDZA A,A		; No, assume no error
	 MOVEI A,OPNX21		; Yes, assume rejected by foreign host
	TLNE IOS,(BSTIMF)	; Timed out?
	 MOVEI A,OPNX20		; Yes, assume nobody there
	JUMPN A,PUPOP9		; Jump if failed to open
	PUSHJ P,ULKBSP		; Succeeded, unlock port
	JRST SKPRET##		; Give success return

; Here if rendezvous attempt failed
; Clean up and give error return, A/ error code
PUPOP9:	HRLM A,0(P)		; Save error code
	MOVEI A,E.CLST		; Generate CLOSF(T) event
	HRROI C,0		; Set code for Abort if any
	HRROI D,[ASCIZ /Connection attempt timed out/]
	PUSHJ P,PUPFSM		; Force state to closed
	PUSHJ P,PUPCL3		; Delete port if appropriate
	 BUG(HLT,<PUPOPN: Impossible +1 return from PUPCL3>)
	TEST(Z,OPNF)		; JFN no longer open
	HLRZ A,0(P)		; Recover error code
	POPJ P,			; Fail return from OPENF



; Here to fail return from early parts of the OPENF when we have
;  address table assigned but port not open yet (OPNERR macro)
; A/ error code, E/ address table pointer
OPNERX:	PUSH P,A		; Save error code
	MOVEI B,(E)		; Release address table
	PUSHJ P,RELPFR
	POP P,A
	POPJ P,

; Close Pup network file (CLOSF)

PUPCLZ:	HLRZ UNIT,DEV		; Setup Pup unit #
	PUSHJ P,LCKBSQ		; Lock port if BSP
	 JRST PUPCL8		; Not BSP, jump around BSP logic
	SETZM FILCNT(JFN)	; Allow no further i/o
	TLZE IOS,(BSTIMF)	; Timed out?
	 JRST [	MOVEI A,E.CLST	; Yes, generate CLOSF(T) event
		HRROI C,0	; Abort Code = 0 (need registered code ******)
		HRROI D,[ASCIZ /Connection timed out/]
		PUSHJ P,PUPFSM
		TEST(O,ERRF)	; Set JFN error flag
		ERPOPJ(IOX5,<PUSHJ P,ULKBSP>)]  ; Give error return
	TEST(NN,WRTF)		; Closing output JFN?
	 JRST [	TLNN IOS,(BSOPNW)  ; No, is port also open for writing?
		 JRST PUPCL2	; No, generate close event
		JRST PUPCL3]	; Yes, do nothing for input close
	CHKSTT <OPEN,ENDI>	; State ok for BSP output?
	 JRST PUPCL2		; No, skip this
	MOVE A,FILBYT(JFN)	; Yes, get byte ptr to last byte stored
	PUSHJ P,FRCBSP		; Force out remaining data if any
	PUSHJ P,CHKBOQ		; Any output pending?
	 JRST CLZWAT		; Yes, back out and wait til done
PUPCL2:	MOVEI A,E.CLSN		; Generate CLOSF(N) event
	HRROI C,0		; Need registered code ************
	HRROI D,[ASCIZ /Connection attempt abandoned/]  ; In case RFC Out
	PUSHJ P,PUPFSM
	MOVSI A,(STTBTS(CLOS,ABOR))  ; Specify desired states
	PUSHJ P,WATSTT		; Now closed or aborted?
	 JRST CLZWAT		; No, back out and wait until it is
	LDB A,PBSSTT		; Yes, get current state
	CAIE A,S.CLOS		; Now closed?
	 ERPOPJ(IOX5,<PUSHJ P,ULKBSP>)  ; No, give error return

; Called here from OPENF code to clean up after rendezvous failure
PUPCL3:	PUSHJ P,SETRWB		; Setup status bit for this opening
	ANDCM IOS,A		; Mark no longer open this way
	TLNE IOS,(BSOPNR+BSOPNW)  ; Still open the other way?
	 JRST [	PUSHJ P,ULKBSP	; Yes, don't delete port yet
		JRST SKPRET##]	; Success return
	PUSHJ P,FLSBSQ		; Now closed both ways, flush queues

; Now delete the port (still locked if BSP port)
PUPCL8:	MOVEI A,PUPOBC(UNIT)	; Check output counts
	SKIPE 0(A)		; Output pending for this port?
	 PUSHJ P,DISE##		; Yes, wait until all gone
	PUSHJ P,DELPRT		; Delete the port
	JRST SKPRET##		; Done, skip return

; Must set bit in FILLFW before backing out of CLOSF.
; I don't really understand what the FILLFW bullshit is all about.
CLZWAT:	MOVSI B,1
	IORM B,FILLFW(JFN)
	JRST ULKWAT


; Setup read/write bit appropriately for this opening of port
;	STS/ File status
; Returns +1:  A/ BSOPNR or BSOPNW set

SETRWB:	MOVSI A,(BSOPNR)	; Assume opening for reading
	TEST(NE,WRTF)		; Writing?
	 MOVSI A,(BSOPNW)	; Yes, say so
	POPJ P,


; Pup kill fork
; Called to clean up Pup tables when a fork is killed
; Returns +1
; Clobbers A, UNIT

PUPKFK::MOVSI UNIT,-NPUPUN	; For all ports:
PUPKF1:	HRRE A,PUPPSI(UNIT)	; Get fork to be interrupted
	CAMN A,FORKX##		; Same as fork being killed?
	 SETOM PUPPSI(UNIT)	; Yes, deassign interrupt for port
	AOBJN UNIT,PUPKF1
	POPJ P,

; Pup sequential byte input
;	JFN, DEV, STS setup
; Returns +1 always, A/ the next byte (if no error)
; Clobbers A-D, UNIT, BSP, PB

PUPSI1:	PUSHJ P,PUPSIP		; Here when buffer empty: try for next
	 POPJ P,		; Error or EOF, return with no data
	 JRST BAKWAT		; None now, back out and wait

PUPSQI:	SOSGE FILCNT(JFN)	; Decrement and test byte count
	 JRST PUPSI1		; Pup exhausted, get another
	ILDB A,FILBYT(JFN)	; Bytes remain, load next
	AOS FILBYN(JFN)		; Advance byte number
	POPJ P,			; Return

; Get and set up next Pup for sequential input.
; Returns +1: error or EOF
;	+2: none available now, must wait; A/ EDISMS arg
;	+3: successful

PUPSIP::HLRZ UNIT,DEV		; Get Pup unit #
	PUSHJ P,LCKBSQ		; Lock port, check for BSP
	 FILABT(IOX1)		; Not BSP, sequential i/o illegal
	CHKSTT <OPEN,ENDI,ENDO,DALY>  ; Check for legal state
	 JRST PUPSQE		; Not good, set error bit
	TLNE IOS,(BSMRKF+BSENDF+BSTIMF)  ; Eof or errors?
	 JRST PUPSI2		; Yes, don't try for more Pups
	PUSHJ P,GETBSP		; No, get next Pup from stream
	 JRST [	CHKSTT(<ENDI,DALY>,B)  ; Empty, has End been received?
		 JRST PUPSQW	; No, must wait
		TLO IOS,(BSENDF)  ; Yes, set End encountered flag
		JRST PUPSI2]	; Do eof handling
	LDB A,PUPTYP		; Got one, get Pup Type
	CAIE A,PT.MRK		; Mark?
	CAIN A,PT.AMA		; AMark?
	 JRST [	ILDB A,PBBSID(PB)  ; Yes, get the byte
		DPB A,PBSMRK	; Store in status word
		PUSHJ P,RELPKT	; Release the packet
		HRRZS BSPCUR(BSP)  ; Note no current packet
		TLO IOS,(BSMRKF)  ; Set Mark encountered flag
		JRST PUPSI2]	; Do eof handling
	PUSHJ P,ULKBSP		; Data or AData, unlock port
	MOVE A,PBBSBC(PB)	; Get byte count
	MOVEM A,FILCNT(JFN)	; Store it in standard place
	ADDM A,FILLEN(JFN)	; Extend file length
	MOVE A,PBBSID(PB)	; Get byte pointer
	MOVEM A,FILBYT(JFN)	; Store it in standard place
	JRST SK2RET##		; Success return

; Here if any error flags are set
PUPSI2:	TLNE IOS,(BSMRKF+BSENDF)  ; Mark or End encountered?
	 TEST(O,EOFF)		; Yes, set eof flag for JFN
	TLNE IOS,(BSTIMF)	; Timeout
PUPSQE:	 TEST(O,ERRF)		; Yes, set error flag for JFN
	PUSHJ P,ULKBSP		; Unlock port
	POPJ P,			; Return with no data

; Here if no data; caller must wait.
PUPSQW:	PUSHJ P,ULKBSP		; Unlock port
	JRST SKPRET##		; Return +2

; Pup sequential byte output
;	A/ Byte to be output
;	JFN, DEV, STS setup
; Returns +1 always
; Clobbers A-D, UNIT, BSP, PB

PUPSO1:	PUSHJ P,PUPSOP		; Here when buffer full: try for next
	 POPJ P,		; Error
	 JRST BAKWAT		; None now, back out and wait

PUPSQO:	SOSGE FILCNT(JFN)	; Decrement and test byte count
	 JRST PUPSO1		; Pup full, attempt to send
	IDPB A,FILBYT(JFN)	; Still room, store byte
	AOS FILBYN(JFN)		; Advance byte number
	POPJ P,			; Return

; Get and set up next Pup for sequential output.
; Returns +1: error
;	+2: none available now, must wait; A/ EDISMS arg
;	+3: successful
; Saves and restores RH of A (byte being output)

PUPSOP::HRLM A,0(P)		; Save the byte to be output
	HLRZ UNIT,DEV		; Get Pup unit #
	PUSHJ P,LCKBSQ		; Lock port, check for BSP
	 FILABT(IOX2)		; Not BSP, sequential i/o illegal
	CHKSTT <OPEN,ENDI>	; Check for reasonable state
	 JRST PUPSQE		; Not good, set error bit
	TLNE IOS,(BSTIMF)	; Timeout?
	 JRST PUPSQE		; Yes, set error flag
	MOVE A,FILBYT(JFN)	; Get ptr to last byte stored
	PUSHJ P,DMPBSP		; Force out current Pup if any
	PUSHJ P,CHKBSO		; See if more BSP output possible
	 JRST PUPSQW		; No, must wait
	PUSHJ P,BLDDAT		; Yes, build virgin Data packet
	 JRST PUPSQW		; Failed to allocate space
	MOVEM A,FILCNT(JFN)	; Store byte count
	MOVEM B,FILBYT(JFN)	; Store byte pointer
	PUSHJ P,ULKBSP		; Unlock port
	HLRZ A,0(P)		; Recover the new byte
	JRST SK2RET##		; Succeeded, return +2

; Get status (GDSTS)
;	User 3/ Size ,, address of block to return foreign port
;		address table in (see PUPNM), or 0 to omit table
; Returns +1:
;	A/ BSP status word (to be returned to user ac2)
;	User 3/ size of address table ,, unchanged

PUPGST:	TEST(NN,OPNF)		; Make sure open
	 JRST [	SETZ A,		; Not open, return zero status
		XCTUU [HRRZS 3]	; Zero address count
		POPJ P,]
	HLRZ UNIT,DEV		; Get Pup unit #
	PUSHJ P,LCKBSQ		; Lock port if BSP
	 CAI			; Not BSP
	UMOVE E,3		; Get user block pointer
	JUMPLE E,PUPGS2		; Omit if none
	HLRZ D,E		; Get count
	SKIPN B,PUPFPT(UNIT)	; Have address table?
	 JRST [	SETZ A,		; No, make zero net/host
		HRLI E,A	; Make BLT "from" address
		MOVEI C,2	; Size is 2
		JRST PUPGS1]
	HLRE C,B		; Yes, get -count
	MOVN C,C		; Make positive
	HRLI E,1(B)		; Make BLT "from" address
PUPGS1:	XCTUU [HRLM C,3]	; Return count
	CAILE C,(D)		; Have more than user wants?
	 MOVEI C,(D)		; Yes, take minimum
	ADDI C,(E)		; Make BLT end pointer
	XCTMU [BLT E,-1(C)]	; Copy address table to user
PUPGS2:	MOVE A,PUPSTS(UNIT)	; Get status
	PUSHJ P,ULKBSQ		; Unlock port if BSP
	POPJ P,


; Set status (SDSTS)
;	A/ BSP status word to set (from user ac2)
; Returns +1

PUPSST:	HLRZ UNIT,DEV		; Get Pup unit #
	PUSHJ P,LCKBSQ		; Lock port if BSP
	 CAI			; Not BSP
	MOVE B,A		; Copy new status
	AND A,BSSETB		; Mask bits user may set
	IOR IOS,A		; Set them
	ANDCA B,BSCLRB		; Mask bits user may clear
	ANDCM IOS,B		; Clear them
	TLNN IOS,(BSMRKF!BSENDF) ; Mark and end flags now clear?
	 TEST(Z,EOFF)		; Yes, clear jfn EOF flag
	TLNN IOS,(BSTIMF)	; Timeout flag now clear?
	 TEST(Z,ERRF)		; Yes, clear jfn error flag
	PUSHJ P,ULKBSQ		; Unlock port if BSP
	POPJ P,

BSSETB:	BSNCHK+DSCRNF		; Bits that user may set
BSCLRB:	BSMRKF+BSTIMF+BSNCHK+DSCRNF  ; Bits that user may clear

; Miscellaneous JSYS routines not dispatched through the standard
;  dispatch mechanism (PUPDTB)


; Return local port address (including absolute socket #) (CVSKT)
;	JFN (etc.)/ already setup (see .CVSKT in NETWRK)
;	A/ string ptr to filename string
; Returns +1 to user:  Unsuccessful, 1/ error #
;	+2 to user:  Successful,
;		user 2/ net ,, host
;		user 3/ socket

CVPSKT::TEST(NN,OPNF)		; Open?
	 JRST [	PUSHJ P,PNMDEC	; No, just decode filename
		 ERUNLK(CVSKX2)	; Failed (net dir changed?)
		JRST CVPSK1]
	HLRZ UNIT,DEV		; Yes, get Pup unit #
	MOVE A,PUPLNH(UNIT)	; Pick up local net/host
	MOVE B,PUPLSK(UNIT)	;  and socket
CVPSK1:	UMOVEM B,3		; Return socket in 3
	LSHC A,-^D<36-8>	; Reformat net/host to net,,host
	LSH A,^D<18-8>
	LSHC A,^D8
	UMOVEM A,2		; Return net,,host in 2
	PUSHJ P,UNLCKF
	JRST SKMRTN##		; Skip return to user



; Attach port to Pup NVT (ATPTY)
;	JFN/ Send JFN  (see .ATPTY in NETWRK)
;	DEV/ Send DEV
;	UNIT/ Send UNIT
;	0(P)/ Receive JFN
;	-1(P) Receive DEV
; Both JFN's locked and verified to be open Pup JFN's
; Returns +1 to user:  Error, 1/ error code
;	+2 to user:  Success, 1/ Attached TTY designator, JFN's released

DEFINE ATPERR(ERRORN,EXTRA) <ERROR(ERRORN,<EXTRA>,ATPER4##)>

ATPNVT::CAME DEV,-1(P)		; Both JFN's point to same port?
	 ATPERR(ATPX15)		; No, fail
	PUSHJ P,LCKBSQ		; Yes, attempt to lock it
	 ATPERR(ATPX16)		; Not BSP port, fail
	CHKSTT <OPEN>		; Connection must be open
	 ATPERR(ATPX17,<PUSHJ P,ULKBSP>)  ; Not, fail
	PUSHJ P,ASPNVT		; Assign Pup NVT
	 ATPERR(ATPX13,<PUSHJ P,ULKBSP>)  ; None available, fail
	MOVEI A,400000(B)	; Convert line # to TTY designator
	UMOVEM A,1		; Return it to user
	MOVE A,FILBYT(JFN)	; Get ptr to last byte stored
	PUSHJ P,DMPBSP		; Force out partial Pup if any
	PUSHJ P,ULKBSP		; Unlock port
	PUSHJ P,RELJFN##	; Release send JFN
	POP P,JFN
	PUSHJ P,RELJFN##	; Release receive JFN
	JRST SKMRTN##		; Skip return to user

; Dismiss until input buffer empty (DIBE)
;	JFN (etc.)/ already setup (see .DIBE in JSYS)
; Returns +1

PUDIBE::PUSHJ P,CHKBSP		; Check for good BSP JFN
	 POPJ P,		; Not, ignore
	 FILINT(IOX5)		; Bad state, give i/o data error
	HRRZ A,BSPIQL(BSP)	; Any input bytes queued?
	JUMPE A,ULKBSP		; Return now if none
	MOVEI A,PDIBET		; Yes, set scheduler test
	HRLI A,(UNIT)
	TLO IOS,(BSINPF)	; Flag that input is queued
	JRST ULKWAT		; Back out and wait

USE RESPC

; Scheduler test for input buffer empty (or error)
; Arg is Pup unit index

PDIBET:	MOVE B,PUPSTS(A)	; Get port status word
	TLNE B,(BSINPF)		; Input buffer empty?
	 TLNE B,(BSTIMF+BSERRF)	; No, error?
	 JRST 1(D)		; Yes, wakeup
	JRST 0(D)		; No, wait

USE SWAPPC


; Dismiss until output buffer empty (DOBE)
;	JFN (etc.)/ already setup (see .DOBE in JSYS)
; Returns +1

PUDOBE::PUSHJ P,CHKBSP		; Check for good BSP JFN
	 POPJ P,		; Not, ignore
	 FILINT(IOX5)		; Bad state, give i/o data error
	TEST(NN,WRTF)		; Open for writing?
	 FILABT(IOX2,<PUSHJ P,ULKBSP>)  ; No, generate instruction trap
	CHKSTT <OPEN,ENDI>	; Check for reasonable state
	 JRST [	TEST(O,ERRF)	; Bad, give error
		POPJ P,]
	MOVE A,FILBYT(JFN)	; Get ptr to last byte stored
	PUSHJ P,FRCBSP		; Force out partial Pup if any
	SETZM FILCNT(JFN)	; Zero byte count
	PUSHJ P,CHKBOQ		; Check for empty output queue
	 JRST ULKWAT		; Not empty, back out and wait
	JRST ULKBSP		; Empty, done

; Skip if input buffer empty (SIBE)
;	JFN (etc.)/ already setup (see .SIBE in JSYS)
; Returns +1:  Not empty, A/ # of buffered bytes
;	+2:  Empty

PUSIBE::PUSHJ P,CHKBSP		; Check for good BSP JFN
	 JRST SKPRET##		; Not, give empty return
	 JRST SKPRET##		; Bad state, give empty return
	HRRZ A,BSPIQL(BSP)	; Get # of input bytes available
	SKIPL FILCNT(JFN)	; Any bytes in current buffer?
	 ADD A,FILCNT(JFN)	; Yes, include those too
	SKIPG A			; Any bytes available?
	 AOS 0(P)		; No, preset skip return
	JRST ULKBSP		; Unlock port and return


; Skip if output buffer empty (SOBE)
;	JFN (etc.)/ already setup (see .SOBE in JSYS)
; Returns +1:  Not empty, A/ # of buffered bytes
;	+2:  Empty

PUSOBE::PUSHJ P,CHKBSP		; Check for good BSP JFN
	 JRST SKPRET##		; Not, give empty return
	 JRST SKPRET##		; Bad state, give empty return
	HRRZ A,BSPOQL(BSP)	; Get # of output bytes pending
	SKIPG A			; Are there any?
	 AOS 0(P)		; No, preset skip return
	JRST ULKBSP		; Unlock port and return


; Skip if output buffer full (SOBF)
;	JFN (etc.)/ already setup (see .SOBF in JSYS)
; Returns +1:  Not full (i.e. can output more bytes)
;	+2:  Full (next byte output would block you)
;		A/ # of buffered bytes, on either return

PUSOBF::PUSHJ P,CHKBSP		; Check for good BSP JFN
	 CAI			; Not, give not full return
	 JRST [	SETZ A,		; Bad state, give not full return
		POPJ P,]
	SKIPLE FILCNT(JFN)	; Room in current buffer?
	 JRST .+3		; Yes
	PUSHJ P,CHKBSO		; No, check for BSP output possible
	 AOS 0(P)		; Not possible, preset skip return
	HRRZ A,BSPOQL(BSP)	; Return # of output bytes pending
	JRST ULKBSP		; Unlock port and return


; Set Pup routing table entry (PUPROU function of OPRFN)
;	B/ Net number
;	C/ Mask of bits to change
;	D/ New value of those bits
; Returns +1:  Error (OPRFX2 code in ac1)
;	+2: Successful
;	user ac4/ Value of routing table entry (updated)
; Note: to read the existing contents of an entry, just use a zero mask

SETRTE::CAIL B,1		; Make sure net number in range
	CAILE B,NPNETS
	 ERPOPJ(OPRFX2)
	NOSKED
	AND D,C			; Mask bits to be changed
	ANDCA C,PUPROU-1(B)	; Mask bits to be retained
	IOR D,C			; Combine
	MOVEM D,PUPROU-1(B)	; Put back in routing table
	OKSKED
	UMOVEM D,4		; Give back to caller
	JRST SKPRET##

; Pup device-dependent operations (MTOPR)
;	JFN (etc.)/ already setup
;	B/ operation
; Returns +1 always;  results depend on operation.

PUPMTP:	TEST(NN,OPNF)		; Open?
	 POPJ P,		; No, do nothing
	CAIN B,3		; Write eof?
	 MOVEI B,20		; Yes, use different index
	CAIL B,20		; Defined operation?
	CAIL B,20+PUPMTN
	 POPJ P,		; No, do nothing
	HLRZ UNIT,DEV		; Setup Pup unit #
	MOVE A,PUPMTT-20(B)	; Get dispatch
	JUMPGE A,0(A)		; Dispatch if BSP not required
	PUSHJ P,LCKBSQ		; See if BSP port, lock if so
	 POPJ P,		; Not, do nothing
	TLNN A,(1B1)		; Do errors matter?
	 JRST [	PUSHJ P,0(A)	; No, just dispatch
		JRST ULKBSP]	; Unlock port and return
	TLNN IOS,(BSTIMF)	; Yes, timeout?
	 PUSHJ P,0(A)		; No, do operation
	TLNE IOS,(BSTIMF)	; Timeout?
	 TEST(O,ERRF)		; Yes, set error flag
	PUSHJ P,ULKBSP		; Unlock port
	TEST(NE,ERRF)		; Error flag set?
	 FILINT(IOX5)		; Yes, give i/o data error psi
	POPJ P,

; Pup MTOPR dispatch table
; B0 set => port required to be open in BSP mode
; B1 set => generate error psi on timeout
PUPMTT:	1B0+1B1+MTSMRK		; 20 (really 3) send Mark
	1B0+1B1+MTFORC		; 21 Force transmission of partial Pup
	1B0+1B1+MTSINT		; 22 Send Interrupt
	1B0+MTGMRK		; 23 Return most recent Mark byte
	EXP MTAINT		; 24 Assign interrupt channels
	1B0+MTSABT		; 25 Abort connection
	1B0+MTGABT		; 26 Return Abort data

PUPMTN==.-PUPMTT	; Number of defined functions


; Send Mark (MTOPR function 3)
;	3/ Mark byte

MTSMRK:	TEST(NN,WRTF)		; Open for writing?
	 FILABT(IOX2,<PUSHJ P,ULKBSP>)  ; No, generate instruction trap
	CHKSTT <OPEN,ENDI>	; Check for reasonable state
	 JRST [	TEST(O,ERRF)	; Bad, give error
		POPJ P,]
	MOVE A,FILBYT(JFN)	; Get ptr to last byte stored
	PUSHJ P,DMPBSP		; Dump partial Pup if any
	SETZM FILCNT(JFN)	; Zero byte count
	UMOVE A,3		; Get Mark byte from user
	PUSHJ P,SNDMRK		; Send Mark
	 JRST ULKWAT		; Can't, back out and wait for Ack
	POPJ P,


; Get content byte of most recently received Mark (MTOPR function 23)
; Returns user 3/ Mark byte

MTGMRK:	LDB A,PBSMRK		; Get the byte
	UMOVEM A,3		; Return byte to user
	POPJ P,

; MTOPR routines (cont'd)

; Force out partial Pup (MTOPR function 21)

MTFORC:	TEST(NN,WRTF)		; Open for writing?
	 FILABT(IOX2,<PUSHJ P,ULKBSP>)  ; No, generate instruction trap
	CHKSTT <OPEN,ENDI>	; Check for reasonable state
	 JRST [	TEST(O,ERRF)	; Bad, give error
		POPJ P,]
	MOVE A,FILBYT(JFN)	; Get ptr to last byte stored
	PUSHJ P,DMPBSP		; Force out partial Pup if any
	SETZM FILCNT(JFN)	; Zero byte count
	POPJ P,


; Send Interrupt (MTOPR function 22)
;	3/ Interrupt code
;	4/ If nonzero, string ptr to Interrupt text

MTSINT:	CHKSTT <OPEN,ENDI,ENDO>  ; Check for reasonable state
	 JRST [	TEST(O,ERRF)	; Bad, give error
		POPJ P,]
	UMOVE A,3		; Get code
	UMOVE B,4		; Get string ptr if any
	PUSHJ P,SNDINT		; Send Interrupt
	 JRST ULKWAT		; Can't, back out and wait
	POPJ P,


; Assign interrupt channels (MTOPR function 24)
;	3/ B0-5:   "Interrupt" PSI channel ( >35 => disable)
;	   B6-11:  "Received Pup" PSI channel
;	   B12-17: "State Change" PSI channel

MTAINT:	UMOVE A,3		; Get user arg
	HRR A,FORKX##		; Direct interrupts to this fork
	MOVEM A,PUPPSI(UNIT)	; Store in table
	POPJ P,


; Abort connection
;	3/ Abort code
;	4/ If nonzero, string ptr to Abort text

MTSABT:	MOVEI A,E.CLST		; Generate CLOSF(T) event
	XCTUU [HRRZ C,3]	; Get Abort Code (lh=0 => user call)
	UMOVE D,4		; Get string ptr to text if any
	PUSHJ P,PUPFSM		; Activate the FSM
	SETZM FILCNT(JFN)	; No further i/o
	POPJ P,


; Get Abort data
;	4/ If nonzero, string ptr to store Abort text
; Returns 3/ Abort code, 4/ updated pointer

MTGABT:	HRRZ PB,BSPTIM(BSP)	; Get ptr to saved Abort
	JUMPE PB,CPOPJ##	; Do nothing if none
	LDB A,[POINT 16,PBCONT(PB),15]  ; Get Abort Code
	UMOVEM A,3		; Give to user
	UMOVE D,4		; Get user string ptr
	JUMPE D,CPOPJ##		; Stop here if none
	TLC D,-1		; Fix -1 lh
	TLCN D,-1
	 HRLI D,(POINT 7)
	LDB C,PUPLEN		; Get Pup Length
	SUBI C,MNPLEN+2		; Subtract overhead
	JUMPLE C,MTGAB2		; Jump if none
	MOVE B,[POINT 8,PBCONT(PB),15]  ; Init byte ptr
MTGAB1:	ILDB A,B		; Get byte from packet
	XCTBU [IDPB A,D]	; Give to user
	SOJG C,MTGAB1		; Repeat until exhausted
MTGAB2:	UMOVEM D,4		; Return updated pointer
	XCTBU [IDPB C,D]	; Append null
	POPJ P,

; Decode Pup name string
;	A/ String pointer to name
; Returns +1:  Unsuccessful
;	+2:  Successful:
;		A/ <net>B7 + <host>B15 (0 => wildcard)
;		B/ socket (right-justified)
; Clobbers A-D

	ADRBSZ==^D20	; Size of address block to allocate

PNMDEC:	PUSH P,A
	MOVEI B,ADRBSZ+1	; Allocate space for address table
	PUSHJ P,ASGPFR
	 JRST [	POP P,A		; Failed
		POPJ P,]
	MOVEI B,1(A)		; Address table loc for PUPNM
	EXCH A,0(P)		; Restore string ptr
	EXCH E,0(P)		; Save E, E_ address table ptr
	MOVEI D,"U"		; Default mode is user-relative
	ILDB C,A		; Get first char
	CAIE C,0		; Empty string?
	CAIN C,"!"		; Or just mode specifier?
	 JRST [	SETZM 0(B)	; Yes, default all fields
		SETZM 1(B)
		HRLI B,2	; Say just one address input
		JRST PNMDE1]	; Handle mode if any
	ADD A,[7B5]		; Non-null, back up string ptr
	HRLI B,(1B0+<ADRBSZ>B17)  ; Name to address, set size
	PUPNM			; Translate string to address(es)
	 JRST PNMDE9		; Error
	LDB C,A			; Ok, get terminator
PNMDE1:	CAIE C,"!"		; Mode being given?
	 JRST PNMDE2		; No
	ILDB D,A		; Yes, get mode specifier
	JUMPE D,PNMDE9		; Make sure not null
	ILDB C,A		; Get terminator
PNMDE2:	JUMPN C,PNMDE9		; Error if non-null
	HLRZ C,B		; Ok, get returned adr tbl length
	CAIG C,ADRBSZ		; Make sure block was big enough
	 JRST .+3		; Yes
	BUG(CHK,<PNMDEC: ADRBSZ too small for address table>)
	MOVEI C,ADRBSZ		; Use only what we have
	MOVN C,C		; Negate
	HRLI B,(C)		; Make AOBJN ptr to address table

; Now have B/ -length,,address of address table
; D/ Mode character for local socket defaulting (not yet checked).
; Now compute the absolute local socket on the basis of the first
;  entry in the address table
	SKIPN A,1(B)		; Get local socket from first entry
	 JRST [	MOVEI A,(JFN)	; Zero, default to 8*JFN
		LSH A,3-SJFN
		JRST PNMDE3]	; Make user- or job-relative
	CAIN D,"A"		; Want absolute socket?
	 JRST PNMDE5		; Yes, skip following
PNMDE3:	CAIE D,"J"		; Want job or user-relative?
	CAIN D,"U"
	 CAILE A,77777		; Yes, can only specify these bits
	 JRST PNMDE9		; Bad
	CAIN D,"J"
	 JRST [	MOVE C,JOBNO	; Job-relative, get job number
		ADDI C,^D100000	; Add offset
		JRST PNMDE4]
	MOVE C,FORKX##		; User-relative, get fork number
	SKIPGE C,FKDIR##(C)	; Connected,,login dir if top fork
	 JRST .-1		; Pointer to top of group if not
	HLRZ C,C		; Use connected dir
PNMDE4:	LSH C,^D15		; Use this for high-order bits
	IOR A,C

; PNMDEC (cont'd)

; Now A/ absolute local socket, B/ -length,,adr of address table.
; Scan the address table and (1) make sure that any nonzero
;  net/host entries specify a real Maxc address, (2) make sure
;  all socket specifications are the same, and (3) make net/host
;  wildcard if appropriate.
PNMDE5:	MOVE C,1(B)		; Get socket # of this entry
	CAME C,2(E)		; Consistent with first?
	 JRST PNMDE9		; No, bad
	SKIPN C,0(B)		; Get specified net/host
	 JRST PNMDE7		; Zero means default, always ok
	HLRZ D,C		; Get net
	CAIL D,1		; Check bounds
	CAILE D,NPNETS
	 JRST PNMDE9		; Bad
	HRRZ D,PUPROU-1(D)	; Ok, get Maxc adr on net
	JUMPE D,PNMDE9		; Bad if Maxc not on that net
	TRNN C,-1		; Host specified?
	 JRST [	HRRM D,0(B)	; No, substitute default
		JRST PNMDE7]
	CAIE D,(C)		; Yes, correct?
	 JRST PNMDE9		; No, bad
PNMDE7:	MOVE C,0(B)		; This net/host same as first?
	CAME C,1(E)
	 SETZM 1(E)		; No, make fully wildcard
	AOBJN B,.+1		; Repeat for all adr tbl entries
	AOBJN B,PNMDE5
	MOVE C,1(E)		; Done, get resulting net/host
	SETZ B,			; Convert to <net>B7 + <host>B15
	ROTC B,-8
	LSH C,-^D<18-8>
	ROTC B,-8
	EXCH A,B		; Net/host to A, socket to B
	AOS -1(P)		; Preset skip return

; Here to return from PNMDEC
PNMDE9:	PUSH P,A		; Save result
	EXCH B,E
	PUSHJ P,RELPFR		; Release address table
	MOVE B,E
	POP P,A
	POP P,E
	POPJ P,			; Non-skip return

; Decode Pup extension string
;	A/ String pointer to name
; Returns +1:  Unsuccessful
;	+2:  Successful, A/ -Used length,,address of address block
;		(note the rh points to the header word -- the
;		address table starts at 1(A))
; Clobbers A-D

PEXDEC:	PUSH P,A		; Save string ptr
	MOVEI B,ADRBSZ+1	; Allocate space for address table
	PUSHJ P,ASGPFR
	 JRST [	POP P,A		; No room, fail
		POPJ P,]
	MOVEI B,1(A)		; Set address tbl loc for PUPNM
	EXCH A,0(P)		; Save pointer, get back string
	MOVE D,A		; Copy string ptr
	ILDB C,D		; Get first char
	JUMPE C,[SETZM 0(B)	; If null, default all fields
		SETZM 1(B)
		HRLI B,2	; Say just one address input
		JRST PEXDE1]	; Go exit
	HRLI B,(1B0+<ADRBSZ>B17)  ; Name to address, set size
	PUPNM			; Translate string to address(es)
	 JRST PEXDE9		; Error
	LDB C,A			; Ok, get terminator
	JUMPN C,PEXDE9		; Error if non-null
PEXDE1:	HLRZ B,B		; Ok, get returned adr tbl length
	CAIG B,ADRBSZ		; Make sure block was big enough
	 JRST PEXDE2		; Yes
	BUG(CHK,<PEXDEC: ADRBSZ too small for address table>)
	MOVEI B,ADRBSZ		; Use only what we have
PEXDE2:	MOVN A,B		; Negate
	HRLM A,0(P)		; Make AOBJN ptr to address table
	HRRZ A,0(P)		; Get pointer to block
	MOVEI B,1(B)		; Include overhead in size
	PUSHJ P,TRMPFR		; Trim block to required size
	POP P,A			; Get AOBJN ptr to address table
	JRST SKPRET##		; Done, take skip return

; Here to fail return from PEXDEC
PEXDE9:	POP P,B			; Release address block
	PUSHJ P,RELPFR
	POPJ P,			; Fail return

; Check for open BSP port in good state
;	JFN/ Pup JFN (locked at JSYS level)
; Returns +1:  Not open or not BSP port
;	+2:  BSP port but timed out or in bad state (Closed, Abort)
;	+3:  Ok, port locked

CHKBSP:	HLRZ UNIT,DEV		; Get Pup unit #
	TEST(NE,OPNF)		; File open?
	 PUSHJ P,LCKBSQ		; Yes, check for BSP and lock it
	 POPJ P,		; Not open or not BSP, return +1
	TLNE IOS,(BSTIMF+BSERRF)  ; Open, in good state?
	 JRST [	PUSHJ P,ULKBSP	; No, unlock port
		TEST(O,ERRF)	; Set JFN error flag
		JRST SKPRET##]	; Return +2
	JRST SK2RET##		; Yes, return +3


; Unlock BSP port, unlock file, and wait for some condition
;	A/ EDISMS argument word
; Does not return to caller, but rather backs up the user PC
;  and returns to the caller of the JSYS, hence causing the
;  JSYS to be started over.

ULKWAT:	PUSHJ P,ULKBSP		; Unlock the port


; Unlock file and wait for some condition
;	A/ EDISMS argument word
; Does not return to caller, but rather backs up the user PC
;  and returns to the caller of the JSYS, hence causing the
;  JSYS to be started over.

BAKWAT:	PUSHJ P,UNLCKF##	; Unlock file, go OKINT
	JSYS EDISMS##		; Dismiss until condition satisfied
	MOVE P,MPP		; Flush to top of monitor stack
	MOVE A,0(P)		; Get return PC
	HRRI A,-1(A)		; Back it up, avoiding carries
	MOVEM A,0(P)
	JRST MRETN##		; Return from JSYS, start it over


; -----------------------------------------------------------------
;	JSYSes for Raw Packet I/O
; -----------------------------------------------------------------


; Input Pup in raw packet mode
;	1/	B0: Never dismiss for I/O, give PUPX3 error instead
;		B1: Check Pup Checksum, give PUPX5 error if bad
;		B2: Perform source address check, give PUPX7 error
;		    if incorrect
;		B3: Use timeout specified in 3, give PUPX3 error upon expiration
;		RH: JFN for port open in raw packet mode
;	2/	LH: Length of user block (36-bit words)
;		RH: Address of user block
;	3/	Timeout in milliseconds, 50000 maximum
; Returns +1:  Unsuccessful, 1/ Error #
;	+2:  Successful

.PUPI::	JSYS MENTR##
	PUSHJ P,SETRAW		; Setup and check arguments
	TEST(NN,READF)
	 ERUNLK(IOX1)		; Not open for reading
	PUSHJ P,GETPUP		; Get Pup from input queue
	 JRST PUPI1		; Empty
	LDB A,PUPLEN		; Get Pup Length in bytes
	ADDI A,3		; Convert to words
	LSH A,-2
	CAILE D,(A)		; User want more than we have?
	 MOVEI D,(A)		; Yes, cut him down to size
	MOVSI B,PBHEAD(PB)	; Set up BLT pointer
	HRRI B,(E)
	ADDI E,(D)		; Compute end of BLT
	XCTMU [BLT B,-1(E)]	; Copy Pup to user block
	CAIGE D,(A)		; Was user block big enough?
	 ERUNLK(PUPX1,<PUSHJ P,RELPKT>)  ; No, give error
	TLNN E,(1B1)		; Want checksum checked?
	 JRST .+3		; No
	PUSHJ P,CHKCKS		; Yes, check the checksum
	 ERUNLK(PUPX5,<PUSHJ P,RELPKT>)  ; Checksum incorrect
	TLNN E,(1B2)		; Want source address check?
	 JRST .+3		; No
	PUSHJ P,CHKSRC		; Yes, check for correct source adr
	 ERUNLK(PUPX7,<PUSHJ P,RELPKT>)  ; Source address incorrect
	PUSHJ P,RELPKT		; All ok, release the buffer
	PUSHJ P,UNLCKF##	; Unlock file
	JRST SKMRTN##		; Skip return to user

; PUPI (cont'd)
; Input queue empty

PUPI1:	TLZN E,(1B3)		; Timeout specified?
	 JRST WATRAW		; No, go wait or fail immediately
	TLO E,(1B0)		; Yes, set to fail immediately on next call
	XCTUU [HLLM E,1]
	UMOVE A,3		; Get timeout
	CAILE A,^D50000		; Limit to 50 seconds
	 MOVEI A,^D50000
	ADD A,TODCLK		; Compute ending time
	ADDI A,177		; Round up to next unit of 128 ms
	TRZ A,177
	LSH A,^D20		; B0-8 _ (ending time / 128) mod 512
	TLO A,(UNIT)		; Insert Pup port index
	HRRI A,PUPIWT		; Scheduler test routine
	JRST BAKWAT		; Back out and wait

USE RESPC

; Scheduler test routine for Pup input ready or timeout

PUPIWT:	LDB B,[POINT 9,A,35]	; Get Pup port index
	HRRZ C,PUPIBQ(B)	; Get head of queue
	CAIE C,PUPIBQ(B)
	 JRST 1(D)		; Not empty, awaken
	TRZ A,777
	LSH A,-2		; Shift (ending time / 128) mod 512 into position
	SUB A,TODCLK		; Compute (then - now) mod 512
	ANDI A,177600
	CAIG A,^D50000		; Expired?
	 JRST 0(D)		; No
	JRST 1(D)		; Yes, awaken

USE SWAPPC

; Output Pup in raw packet mode
;	1/	B0: Never dismiss for I/O, give PUPX3 error instead
;		B1: Compute Pup Checksum
;		RH: JFN for port open in raw packet mode
;	2/	LH: Length of user block (36-bit words)
;		RH: Address of user block
; Returns +1:  Unsuccessful, 1/ Error #
;	+2:  Successful

.PUPO::	JSYS MENTR##
	PUSHJ P,SETRAW		; Setup and check arguments
	TEST(NN,WRTF)
	 ERUNLK(IOX2)		; Not open for writing
	MOVEI PB,-PBHEAD(E)	; Offset for looking at Pup header
	XCTMU [LDB A,PUPLEN]	; Fetch Pup Length
	CAIL A,MNPLEN		; Check for legal length
	CAILE A,MXPLEN
	 ERUNLK(PUPX1)		; Size error
	ADDI A,3		; Compute # 36-bit words
	LSH A,-2
	CAILE A,(D)		; Check length consistency
	 ERUNLK(PUPX1)		; User block too short for Pup length
	ADDI A,PBHEAD		; Ok, include overhead in size
	PUSHJ P,CHKOQL		; See if this much can be queued
	 JRST WATRAW		; No, wait until queue less full
	MOVEI B,(A)		; Ok, get size
	PUSHJ P,ASGPKT		; Allocate packet buffer
	 JRST WATRAW		; Can't, back out and wait for space
	MOVSI B,(E)		; Make BLT pointer
	HRRI B,PBHEAD(PB)
	HRRZ C,PBSIZE(PB)	; Compute end of BLT
	ADDI C,(PB)
	XCTUM [BLT B,-1(C)]	; Copy Pup to packet buffer

; Substitute defaults for zero elements in the Pup destination
	SKIPN D,PUPFPT(UNIT)	; Get foreign port descriptor
	 MOVEI D,[EXP 0,0]-1	; None, default all zeroes
	LDB A,PPUPDN		; Destination net
	JUMPN A,PUPO1		; Jump if specified
	HLRZ A,1(D)		; Unspecified, get default
	JUMPN A,.+2		; Jump if have one
	HRRZ A,DEFNET		; None, use default directly-connected net
	DPB A,PPUPDN		; Store replacement value
PUPO1:	CAIL A,1		; Net number in bounds?
	CAILE A,NPNETS
	 ERUNLK(PUPX2,<PUSHJ P,RELPKT>)  ; No, give address error

	LDB B,PPUPDH		; Destination host
	JUMPN B,.+3		; Jump if specified
	HRRZ B,1(D)		; Unspecified, get default
	DPB B,PPUPDH		; Store replacement value

	LDB A,PPUPD0		; Destination socket
	MOVE B,PBHEAD+3(PB)
	LSHC A,^D16
	JUMPN A,PUPO4		; Jump if specified
	MOVE A,2(D)		; Unspecified, get default
	JUMPE A,PUPOAE		; Error if multiple or wildcard
	DPB A,PPUPD1		; Store replacement value
	LSH A,-^D16
	DPB A,PPUPD0

; PUPO (cont'd)

; Check that the Pup source is consistent with the local port
; and Maxc's network address, and default elements where necessary.
PUPO4:	LDB A,PPUPSN		; Get source net from Pup
	LDB B,PPRTLN		; Get local net from port
	JUMPN A,PUPO2		; Net specified in Pup?
	SKIPN A,B		; No, get from port specification
	 JRST [	LDB A,PPUPDN	; None there either.  Get dest net
		MOVE B,PUPROU-1(A)
		TRNN B,-1	; Destination directly connected?
		 LDB A,[POINT 8,B,9] ; No, use immediate gateway net
		SKIPGE B	; Present in routing table?
		 HRRZ A,DEFNET	; No, use default directly-connected net
		DPB A,PPUPSN
		JRST PUPO3]
PUPO2:	DPB A,PPUPSN		; Default source net in Pup
	CAME A,B		; Pup and port agree?
	 JUMPN B,PUPOAE		; No, fail if port not wildcard
PUPO3:	CAIL A,1		; Net in range?
	CAILE A,NPNETS
	 ERUNLK(PUPX2,<PUSHJ P,RELPKT>)  ; No, give address error
	HRRZ C,PUPROU-1(A)	; Yes, get Maxc address on net
	JUMPE C,PUPOAE		; Fail if not on net

	LDB A,PPUPSH		; Get source host from Pup
	LDB B,PPRTLH		; Get local host from port
	JUMPE A,.+3		; Host specified in Pup?
	CAME A,C		; Yes, agree with Maxc address?
	 ERUNLK(PUPX2,<PUSHJ P,RELPKT>)  ; No, give address error
	JUMPE B,.+3		; Host specified in port?
	CAME B,C		; Yes, agree with Maxc address?
	 ERUNLK(PUPX2,<PUSHJ P,RELPKT>)  ; No, give address error
	DPB C,PPUPSH		; Deposit required Maxc host #

	LDB A,PPUPSS		; Get source socket from Pup
	JUMPN A,.+3		; Socket specified in Pup?
	MOVE A,PUPLSK(UNIT)	; No, get local socket from port
	DPB A,PPUPSS		; Default source socket in Pup
	CAME A,PUPLSK(UNIT)	; Pup and port agree?
PUPOAE:	 ERUNLK(PUPX2,<PUSHJ P,RELPKT>)  ; No, give address error

; Done defaulting address fields
; Compute checksum if required and queue the Pup for output
	TLNE E,(1B1)		; Want checksum generated?
	 PUSHJ P,SETCKS		; Yes, do so
	PUSHJ P,PUTPUP		; Queue packet for output
	 JRST [	PUSH P,A	; Can't, release buffer
		PUSHJ P,RELPKT
		POP P,A
		JRST WATRAW]	; Back out and wait
	PUSHJ P,UNLCKF##	; Unlock file
	JRST SKMRTN##		; Skip return to user

; Common setup code for PUPI and PUPO
;	1/ User's ac1
; Returns +1:
;	UNIT/ Pup unit #
;	E/ lh: Flags (from lh of user's ac1)
;	   rh: Block location (from rh of user's ac2)
;	D/ Block size (lh of user's ac2)
; Does not return if error

SETRAW:	HRRZ JFN,1		; Get JFN
	PUSHJ P,CHKJFN##	; Check it
	 ERR()			; Bad JFN
	 ERUNLK(DESX4)		; TTY not legal
	 ERUNLK(DESX4)		; String pointer not legal
	TEST(NN,OPNF)		; Test file status
	 ERUNLK(DESX5)		; Not open
	HRRZ A,DEV		; Check device
	CAIE A,PUPDTB
	 ERUNLK(PUPX8)		; Not device PUP:
	MOVE A,STS		; Check mode
	ANDI A,17
	CAIE A,16
	 ERUNLK(PUPX6)		; Not open in mode 16
	UMOVE E,2		; Get user block length,,adr
	HLRE D,E		; Isolate length
	XCTUU [HLL E,1]		; Put flags in lh of E
	MOVEI A,(E)		; Copy block address
	ADDI A,-1(D)		; Compute last address
	CAIL D,<MNPLEN+3>/4	; Error if smaller than Pup header
	CAILE A,777777		; Error if cross end of memory
	 ERUNLK(PUPX1)		; Size error
	HLRZ UNIT,DEV		; Get Pup unit
	POPJ P,


; Common code to unlock file, go OKINT, dismiss for some condition,
;  then back up the PC and return to the user in such a way that
;  the JSYS will be started over
;	A/ EDISMS argument word (test data,,test routine)

WATRAW:	JUMPGE E,BAKWAT		; Allowed to dismiss?
	ERUNLK(PUPX3)		; No, give error return

; -----------------------------------------------------------------
;	Pup Background Process, Initialization, Bug Reporting
; -----------------------------------------------------------------


; Routine to start Pup background process
; Called only once (from SWPMON during system initialization)
; Returns +1
; Clobbers A, B

PUPBEG::MOVSI A,(1B1)		; Transmit capabilities
	CFORK			; Create fork
	 BUG(HLT,<PUPBEG: Can't create Pup background fork>)
	MOVEI B,PUPBAK		; Start in monitor mode
	MSFRK
	POPJ P,


; Background process starts here

PUPBAK:	MOVSI A,UMODF		; Setup stack, etc.
	MOVEM A,FPC
	JSYS MENTR##
	MOVE A,[ITFPC,,PUPUXI]	; Trap fatal interrupts
	MOVEM A,MONBK
	MOVE A,CHNSON##
	MOVEM A,MONCHN
IFE PIESLC,<
	MOVEI A,202		; Don't fall below Q2
	MOVEM A,JOBBIT
>IFN PIESLC,<
	PUSHJ P,SETSPQ##	; Always run on special queue
>
	PUSHJ P,PUPINI		; Initialize all Pup data

	MOVE A,FORKX##		; Record our fork number
	MOVEM A,PUPFRK
	PUSHJ P,GETIRT		; Get and discard incremental runtime

; Main loop of background process
; Look for something to do
PUPBK1:	MOVE A,PUPFLG		; Get flags
	JFFO A,PUPBK2		; Any requests in?
	JSP D,PUPBKT		; Re-check timers
	 JRST PUPBK3		; Nothing to do, go dismiss
	JRST PUPBK1		; Back to top of loop

; Here when have a request to process
; B/ Flag bit position
PUPBK2:	MOVE A,BITS##(B)	; Clear the bit
	ANDCAM A,PUPFLG
	CAIL B,PUPBKN		; Make sure task number in range
	 BUG(HLT,<PUPBAK: Background task number out of range>)
	PUSH P,B		; Ok, save task number
	PUSHJ P,@PBKTAB(B)	; Perform the task
	PUSHJ P,GETIRT		; Get incremental runtime
	POP P,B			; Restore task number
	ADDM A,PBKTIM(B)	; Accumulate time used by task
	AOS PBKCNT(B)		; Count number of task executions
	JRST PUPBK1		; Loop

; Here on fatal interrupt
PUPUXI:	BUG(CHK,<PUPBAK: Fatal error interrupt, continuing>)
	MOVSI A,UMODF		; Setup stack, etc.
	MOVEM A,FPC
	JSYS MENTR##
	JRST PUPBK1		; Restart at top of loop

; Here when no more work to do
PUPBK3:	MOVE A,TODCLK		; Get now
	ADDI A,MINBWI		; Minimum background wait interval
	MOVEM A,NXTWAK		; Set earliest time of next wakeup
	MOVEI A,PUPBKT		; Scheduler test
	JSYS EDISMS##		; Dismiss until something to do
	JRST PUPBK1		; Back to top of loop

USE RESPC

; Scheduler test for Pup background process wakeup

PUPBKT:	MOVE B,TODCLK		; Get now
	CAMGE B,NXTWAK		; Has minimum wait period elapsed?
	 JRST 0(D)		; No, don't wake up
	HRRZ C,PUPTQH		; Get head of timer queue
	CAML B,PUPTQD(C)	; Time to service request?
	 JRST [	SIGPBP(BSP)	; Yes, set flag
		JRST 1(D)]	; Wakeup
	CAML B,SYNTIM		; Time to check syncs?
	 JRST [	SIGPBP(SYN)	; Yes, set flag
		JRST 1(D)]	; Wakeup
	SKIPN PUPFLG		; Any requests in?
	 JRST 0(D)		; No
	JRST 1(D)		; Yes, wakeup

USE SWAPPC

; Definition of background task requests

DEFINE PBTASK(BIT,ROUTINE) <
	PBF'BIT==1B<.-PBKTAB>	;; Assign bit number
	EXP ROUTINE		;; Assemble dispatch
>

; Dispatch table
PBKTAB:	PBTASK(FRE,RELOPB)	; Release free output buffers
	PBTASK(ASG,GETIPB)	; Assign new input buffers
	PBTASK(GCS,GCPLSK)	; GC local socket table
	PBTASK(BSP,BSPBAK)	; Do BSP background processing
	PBTASK(NVT,BSPNVT)	; Scan for NVT input/output
	PBTASK(SYN,SYNCHK)	; Check for sync timeout errors

PUPBKN==.-PBKTAB	; Number of background tasks in table

; Statistics
GS PUPSTA,0		; GETAB table of Pup statistics
LS PBKCNT,PUPBKN	; Number of executions of each task
LS PBKTIM,PUPBKN	; Time spent executing each task
LS PBKRT		; Total runtime consumed by Pup process

NPUPST==:2*PUPBKN+1	; Length of PUPSTA GETAB table


USE RESPC

; Routine to get incremental runtime (since last call)
; Returns +1, A/ Runtime since last call (ms)

GETIRT:	NOSKED
	MOVE A,FKRT		; Get total runtime charged to fork
	ADD A,JOBRTT##		; Add runtime not yet charged
	SUBM A,PBKRT		; Compute time since last update
	EXCH A,PBKRT		; Save new total, get delta time
	OKSKED
	POPJ P,


USE SWAPPC

; Routines to perform miscellaneous background tasks

; Release output packet buffers that have become unused

RELOPB:	MOVEI A,FREOBQ		; Free output buffer queue header
	PUSHJ P,REMIBQ		; Remove packet from queue
	 POPJ P,		; Queue empty
	PUSHJ P,RELPKT		; Release the buffer
	JRST RELOPB		; Repeat until queue empty


; Allocate and lock new input buffers if necessary

GETIPB:	MOVE A,FREIBN		; Get # of buffers now allocated
	CAIGE A,MAXFIB		; Greater than max # we want?
GETIP1:	PUSHJ P,ASGIPB		; No, assign a buffer for input
	 POPJ P,		; Failed, forget it
	MOVE A,FREIBN		; Less than minimum # we want?
	CAIGE A,MINFIB
	 JRST GETIP1		; Yes, assign more
	POPJ P,			; No, done


; Process requests on timer queue

BSPBAK:	PUSHJ P,REMTQP		; Remove request from head of queue
	 POPJ P,		; No more pending requests
	PUSHJ P,DOBSP		; Got one, do BSP processing for it
	JRST BSPBAK		; Repeat until run out

; Timer queue logic

USE RESPC

; Add port to timer queue, callable from process level
;	A/ Time at which wakeup is desired (377777777777 => never)
;	UNIT/ Pup unit #
; Returns +1
; Clobbers A-C

ADDTQP:	CHNOFF PUPCHN		; No races
	CAME A,[377777777777]	; Do nothing for infinity
	 PUSHJ P,ADDTQI		; Do the work
	CHNON PUPCHN
	POPJ P,

; Same routine, callable from interrupt level
ADDTQI:	SKIPN C,PUPTMQ(UNIT)	; Port already on timer queue?
	 JRST ADDTQ1		; No, just put new request on
	CAML A,PUPTIM(UNIT)	; Yes, new request sooner than old?
	 POPJ P,		; No, done
	MOVS B,C		; Yes, get predecessor ptr in rh
	HRLM B,(C)		; Remove this port from queue
	HRRM C,(B)
ADDTQ1:	MOVEM A,PUPTIM(UNIT)	; Store new time for port

; Scan timer queue from head to find place for new request.
; Note that no end test is needed since the PUPTIM corresponding
;  to the queue header word contains infinity.
; Instructions are repeated to unroll the loop and thereby speed it up.
	SKIPA B,PUPTQH		; Start at header of timer queue
ADDTQ2:	MOVE B,0(B)		; Get successor
	CAMG A,PUPTQD(B)	; Compare new time to one on queue
	 JRST ADDTQ3		; New time earlier, found the place.
	MOVE B,0(B)
	CAMG A,PUPTQD(B)
	 JRST ADDTQ3
	MOVE B,0(B)
	CAMG A,PUPTQD(B)
	 JRST ADDTQ3
	MOVE B,0(B)
	CAMLE A,PUPTQD(B)
	 JRST ADDTQ2

; Found the desired place, B/ new successor
ADDTQ3:	MOVEI A,PUPTMQ(UNIT)	; Compute address of new item
	HLRZ C,0(B)		; Get new predecessor
	HRLZM C,0(A)		; Link item into queue
	HRRM B,0(A)
	HRLM A,0(B)
	HRRM A,0(C)
	POPJ P,			; Done

; Delete port from timer queue, callable from process level
;	UNIT/ Pup unit #
; Returns +1
; Clobbers A-B

DELTQP:	CHNOFF PUPCHN		; No races
	SKIPN A,PUPTMQ(UNIT)	; Port now on timer queue
	 JRST DELTQ1		; No, do nothing
	MOVS B,A		; Yes, get predecessor ptr in rh
	HRLM B,(A)		; Remove this port from queue
	HRRM A,(B)
	SETZM PUPTMQ(UNIT)	; Mark no longer queued
DELTQ1:	CHNON PUPCHN
	POPJ P,


; Remove request from front of timer queue
; Called only from Pup background fork
; Returns +1:  No more
;	+2:  UNIT/ Pup unit # of request
; Clobbers A, UNIT

REMTQP:	CHNOFF PUPCHN		; No races
	HRRZ UNIT,PUPTQH	; Get head of queue
	MOVE A,PUPTQD(UNIT)	; Get time of first request
	CAMLE A,TODCLK		; Now due?
	 JRST [	CHNON PUPCHN	; No (or empty), return +1
		POPJ P,]
	MOVE A,0(UNIT)		; Yes, get predecessor ,, successor
	HRRM A,PUPTQH		; Remove this port from queue
	HLLM A,0(A)
	SETZM 0(UNIT)		; Mark no longer queued
	SUBI UNIT,PUPTMQ	; Convert pointer to index
	CHNON PUPCHN
	JRST SKPRET##		; Return +2

; Initialize Pup queues and data structures
; Returns +1
; Clobbers A-D, UNIT, PB

USE SWAPPC

PUPINI:	SETZM XPUPIB		; Zero NVIO communication cells
	SETZM XPUPOB

	SETZM PRSBEG		; Clear Pup resident storage
	MOVE A,[PRSBEG,,PRSBEG+1]
	BLT A,PRSEND-1
	SETZM PNRBEG		; Clear Pup nonresident storage
	MOVE A,[PNRBEG,,PNRBEG+1]
	BLT A,PNREND-1

	MOVE A,[[PKTBUF,,-1	; Initialize packet buffer free storage
		-1		;  header (see ASGFRE for format)
		NPKTBF*1000
		MXPBLN
		PKTBUF+NPKTBF*1000,,PKTBUF],,PKTFRE]
	BLT A,PKTFRE+4
	MOVEI A,NPKTBF*1000	; Initially all one big block
	MOVEM A,PKTBUF

	MOVE A,[[PUPBUF,,-1	; Initialize Pup free storage
		-1		;  header (see ASGFRE for format)
		NPUPBF*1000
		BSPSIZ
		PUPBUF+NPUPBF*1000,,PUPBUF],,PUPFRE]
	BLT A,PUPFRE+4
	MOVEI A,NPUPBF*1000	; Initially all one big block
	MOVEM A,PUPBUF

	MOVEI A,PBQBEG		; Initialize queues to empty
	HRRM A,(A)
	HRLM A,(A)
	CAIGE A,PBQEND-1	; More?
	 AOJA A,.-3		; Yes, repeat for all

	MOVSI UNIT,-NPUPUN	; Initialize all ports
	PUSHJ P,INIPRT
	AOBJN UNIT,.-1

	MOVSI A,(1B0)		; Initialize routing table to all empty
	MOVEM A,PUPROU
	MOVE A,[PUPROU,,PUPROU+1]
	BLT A,PUPROU+NPNETS-1
	MOVSI A,-LPUPIR		; Setup entries for directly-connected nets
PUPII1:	MOVE B,PUPIRT(A)	; Get table entry
	LDB C,[POINT 16,B,17]	; Get net number
	TLZ B,177777		; Flush from entry
	MOVEM B,PUPROU-1(C)	; Put entry in routing table
	AOBJN A,PUPII1

	MOVE A,[PUPTQH,,PUPTQH]	; Initialize timer queue to empty
	MOVEM A,PUPTQH
	HRLOI A,377777		; Make corresponding time infinite
	MOVEM A,PUPFTM

	SETOM PRTLCK		; Unlock port table lock
	SETOM NVTLCK		; Unlock NVT assignment lock

	PUSHJ P,PUPRST		; Initialize NVIO communication
	POPJ P,

USE RESPC

; Restart Pup I/O
; Called from PUPINI and from SYSRST in PISRV
; Returns +1
; Clobbers A

PUPRST::MOVEI A,PUPISV		; Assign interrupt channels
	API A,<PUPCHN>B29+PUPIDN
	MOVEI A,PUPOSV
	API A,<PUPCHN>B29+PUPODN

	SKIPLE XPUPIB		; Empty input buffer assigned?
	 SIGNAL PUPIBG		; Yes, tell NVIO
	SKIPGE XPUPIB		; Full input buffer?
	 IDEV PUPIDN		; Yes, service it

	SKIPLE XPUPOB		; Full output buffer assigned?
	 SIGNAL PUPOBG		; Yes, tell NVIO
	SKIPGE XPUPOB		; Output already serviced?
	 IDEV PUPODN		; Yes, do next output

	MOVSI A,(PBFFRE!PBFASG!PBFBSP)  ; Run some background tasks
	IORM A,PUPFLG

	POPJ P,

; Code to handle Pup Bugs

; BUG(PUP,<message>,X)
; Copy header of packet PB for later printout by job 0

BGRPUP:	AOS PUPBGC		; Count occurrences
	PUSH P,A
	PUSH P,B
	PUSH P,C
	SKIPE PUPBGP		; Already have unprocessed Pup bug?
	 JRST BGRPU1		; Yes, don't store this one
	MOVSI A,(PB)		; Save data from PB header
	HRRI A,PUPBGH
	BLT A,PUPBGH+PBCONT-1
	HRRZ A,-3(P)		; Get pc of bug
	HRL A,PUPBGC		; Put bug number in lh
	MOVEM A,PUPBGP		; Save in stored header
	SKIPE PUPBGF		; Logging enabled?
	 AOS JB0FLG##		; Yes, awaken job 0
BGRPU1:	HRRZ A,-3(P)		; Get pc of bug
	PUSHJ P,PBGCNT		; Count this bug in hash table
	POP P,C
	POP P,B
	POP P,A
	POPJ P,


; BUG(DIP,<message>,X)
; Discard input packet PB after printout by job 0 if enabled

BGRDIP:	HRRZS 0(P)		; Flag extra return not desired
	JRST BGRDP1		; Enter common bug code

; BUG(DPR,<message>,X)
; Discard input packet PB as above, then execute an extra POPJ
;  so the routine invoking the BUG is exited

BGRDPR:	HRROS 0(P)		; Flag extra return desired
BGRDP1:	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	AOS A,PUPBGC		; Count occurrences, get count
	HRL A,-4(P)		; Get pc of bug
	MOVSM A,PBBSPQ(PB)	; Save count,,pc in packet buffer
	CONSZ PI,1B<20+PUPCHN>	; At interrupt level?
	 JRST BGRDP2		; Yes
	SKIPN PUPBGF		; No, logging enabled?
	 JRST [	PUSHJ P,RELPKT	; No, just release packet
		JRST BGRDP4]
	PUSHJ P,LOCKPB		; Yes, have to lock the buffer
	CHNOFF PUPCHN		; Interlock
BGRDP2:	SKIPN PUPBGF		; Pup bug logging enabled?
	 JRST [	PUSHJ P,RELPBI	; No, just release the buffer
		JRST BGRDP3]
	MOVEI A,DSCIBQ		; Yes, append to discard queue
	PUSHJ P,APPIBQ		;  for processing by job 0
	AOS JB0FLG##		; Awaken job 0
BGRDP3:	CONSO PI,1B<20+PUPCHN>	; At interrupt level?
	 CHNON PUPCHN		; No, uninterlock
BGRDP4:	HRRZ A,-4(P)		; Get pc of bug
	PUSHJ P,PBGCNT		; Count this bug in hash table
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	SKIPGE 0(P)		; Which call?
	 SUB P,BHC##+1		; DPR, pop off another return
	POPJ P,

; Bug-related data

LS PUPBGF		; Nonzero to log Pup bugs
LS PUPBGC		; Count of Pup bugs
LS PUPBGH,PBBSPQ	; PB header and Pup header for last BUG(PUP,...)
LS PUPBGP,PBCONT-PBBSPQ	; PC of last BUG(PUP,...)

USE SWAPPC

; Log Pup bugs;  called from job 0 (see SWPMON)
; Returns +1
; Clobbers A-D, PB, and probably others (see CHKBG1 in SWPMON)

PBGLOG::SKIPN PUPBGP		; Have bug pc?
	 JRST PBGLG1		; No
	MOVEI PB,PUPBGH		; Yes, set pointer to saved header
	PUSHJ P,PBGPRT		; Print Pup bug
	SETZM PUPBGP		; Clear, enable for next
PBGLG1:	HRRZ A,DSCIBQ		; Check discarded input queue
	CAIN A,DSCIBQ		; Empty?
	 POPJ P,		; Yes, done
	MOVE A,TODCLK		; No, set time limit for printing
	ADDI A,^D10000		; 10 seconds from now
	PUSH P,A
PBGLG2:	MOVEI A,DSCIBQ		; Get packet from queue
	PUSHJ P,REMIBQ
	 JRST [	SUB P,BHC##+1	; Empty, fix stack and exit
		POPJ P,]
	MOVE A,TODCLK		; Check time limit
	CAMG A,0(P)		; Skip if exceeded
	 PUSHJ P,PBGPRT		; Print bug
	PUSHJ P,RELPKT		; Release packet buffer
	JRST PBGLG2		; Repeat for all packets in queue


; Internal routine to print Pup bugs
;	PB/ Packet buffer pointer

PBGPRT:	SKIPN PUPBGF		; Want to print Pup bugs?
	 POPJ P,		; No
	HRROI A,[ASCIZ /**PUPBUG /]
	PSOUT
	HLRZ B,PBBSPQ(PB)	; Get bug number
	PUSHJ P,DECCTY##	; Print in decimal
	HRROI A,[ASCIZ / D=/]
	PSOUT
	MOVE B,PBHEAD+2(PB)	; Get high dest socket
	LSH B,-4		; Right-justify
	MOVE C,PBHEAD+3(PB)	; Get low dest socket
	LSHC B,-^D16		; Concatenate
	LSH C,-4		; Right-justify
	LDB A,PPUPDN		; Dest net
	LDB B,PPUPDH		; Dest host
	PUSHJ P,PBGPNM		; Print name string
	HRROI A,[ASCIZ / S=/]
	PSOUT
	LDB A,PPUPSN		; Source net
	LDB B,PPUPSH		; Source host
	MOVE C,PBHEAD+4(PB)	; Source socket
	LSH C,-4		; Right-justify
	PUSHJ P,PBGPNM		; Print name string
	HRROI A,[ASCIZ /
  PS=/]
	PSOUT
	LDB A,PPBPHN		; Phys src net
	LDB B,PPBPHH		; Phys src host
	SETZ C,			; No socket
	PUSHJ P,PBGPNM		; Print name string
	HRROI A,[ASCIZ / T=/]
	PSOUT
	LDB B,PUPTYP		; Print Pup type in octal
	PUSHJ P,OCTCTY##
	HRROI A,[ASCIZ / at /]
	PSOUT
	HRRZ B,PBBSPQ(PB)	; Get pc of bug
	SOJA B,CHKBG1##		; Print PC, date, time, message

; Internal routine to print name string
;	A/ Net
;	B/ Host
;	C/ Socket

PBGPNM:	HRLI B,(A)		; Make net,,host
	PUSH P,B		; Put on stack
	PUSH P,C		; Put socket on stack
	MOVEI A,101		; Output to tty
	MOVEI B,-1(P)		; Location of address block
	HRLI B,(1B2)		; Flag number substitution ok
	PUPNM			; Convert address to name
	 BUG(CHK,<PBGPNM: Impossible failure of PUPNM>)
	SUB P,BHC##+2		; Fix stack
	POPJ P,


USE RESPC

LG2PBT==6		; Log(2) size of Pup bug table
LENPBT==:1_LG2PBT	; Length of Pup bug table
GS PUPBGT,LENPBT	; Hash table of bug count,,pc pairs.

; Count a Pup bug in the hash table
;	A/ pc
; Returns +1
; Clobbers A-C

PBGCNT:	MOVEI B,(A)		; Copy just rh of pc
	IMULI B,^D162013	; Hash - 2^18/golden ratio
	LSH B,-<^D18-LG2PBT>	; Keep topmost  LG2PBT bits
	ANDI B,LENPBT-1
	MOVNI C,(B)		; Keep negative index for wraparound
	HRLI A,(C)
	HRLI B,-LENPBT(B)	; Make AOBJN pointer
PBGCN1:	HRRZ C,PUPBGT(B)	; Get current entry
	CAIN C,(A)		; Same as pc of new bug?
	 JRST PBGCN3		; Yes
	JUMPE C,PBGCN2		; No, found free entry?
	AOBJN B,PBGCN1		; Collision, reprobe linearly
	HLLZ B,A		; Wrap around end of table
	HRLI A,0		; In case get here again
	JUMPN B,PBGCN1
	POPJ P,			; Table is full, forget it

; Here to insert new entry
PBGCN2:	HRRZM A,PUPBGT(B)	; Store pc of bug

; Here to increment count for existing entry
PBGCN3:	MOVSI C,1
	ADDM C,PUPBGT(B)
	POPJ P,

MX(<  ; Maxc1 only
; NVIO bug strings

; General Pup errors
NVBUG(30,<Incorrect Pup length>)
NVBUG(31,<Pup length greater than physical packet length>)
NVBUG(32,<Failed to allocate packet buffer>)

; Ethernet errors
NVBUG(40,<Incorrect Ethernet receiver status>)
NVBUG(41,<Incorrect Ethernet message length>)
NVBUG(42,<Incorrect Ethernet source address>)
NVBUG(43,<Incorrect Ethernet destination address>)
NVBUG(44,<Incorrect Ethernet packet type>)
NVBUG(45,<Ethernet transmitter timed out by software>)
NVBUG(46,<Incorrect Ethernet transmitter status>)
NVBUG(47,<Ethernet load overflow>)

; MCA errors
NVBUG(50,<MCA input timeout>)
NVBUG(51,<MCA message too long>)
NVBUG(52,<MCA input sync error>)
NVBUG(53,<MCA Pup output timeout>)

; Imp errors
NVBUG(60,<Imp message too long>)
NVBUG(61,<Imp state changed>)
NVBUG(62,<Imp input host-host protocol packet discarded>)
>,)

; -----------------------------------------------------------------
;	Byte Stream Protocol
; -----------------------------------------------------------------

; Note:  In the calling sequences, "Assumes port is locked"
; means that UNIT, BSP, and IOS must be setup before the call,
; and the subroutine updates IOS appropriately.

USE SWAPPC

; Get Pup from BSP input queue
; Assumes port is locked
; Returns +1:  Can't, A/ argument word for EDISMS
;	+2:  Ok, PB/ Packet buffer pointer
;		PBBSBC(PB)/ Byte count
;		PBBSID(PB)/ Byte pointer (ILDB gets first byte)
; Note that the returned packet may be a Data, AData, or Mark
; Clobbers A-D, PB

GETBSP:	HLRZ PB,BSPCUR(BSP)	; Is there a current input packet?
	JUMPE PB,.+3
	PUSHJ P,RELPKT		; Yes, release it
	HRRZS BSPCUR(BSP)	; Clear current input packet ptr

; Get next packet if there is one
GETBS1:	HRRZ A,BSPIQL(BSP)	; Get number of bytes available
	JUMPE A,[TLZ IOS,(BSINPF)  ; If none, clear input flag
		PUSHJ P,DOBSPL	; Make sure BSP data up-to-date
		TLNE IOS,(BSINPF)  ; New input available?
		 JRST GETBS1	; Yes, try again
		MOVSI A,(UNIT)	; No, set scheduler test
		HRRI A,BSITST
		POPJ P,]	; Take fail return
	MOVEI A,BSPIBQ(BSP)	; Data available, get queue header
	PUSHJ P,REMITQ		; Remove item from BSP input queue
	 BUG(HLT,<GETBSP: Count nonzero but queue empty>)
	MOVEI PB,-PBBSPQ(B)	; Set pointer to head of PB
	HRLM PB,BSPCUR(BSP)	; Save as current input packet
	MOVSI A,-1		; Decrement count of packets
	ADDB A,BSPIQL(BSP)
	SKIPGE A		; Check for over-decrementing
	 BUG(CHK,<GETBSP: Over-decrementing BSP input count>)

; Compute and update byte sequence numbers and counts
	MOVE A,BSPILW(BSP)	; Get left window edge
	SUB A,PBBSID(PB)	; Compute offset from start of PB
	TLZ A,(-1B3)		;  mod 2^32
	TLNE A,(1B4)		; Make sure positive
	 BUG(HLT,<GETBSP: Byte sequence numbers screwed up>)
	CAML A,PBBSBC(PB)	; Any bytes in window?
	 JRST GETBSP		; No, discard (can this happen?)
	MOVN B,A		; Yes, make negative
	ADDB B,PBBSBC(PB)	; Decrease count by first byte #
	MOVN C,B		; Decrement # bytes available
	ADDB C,BSPIQL(BSP)	; Decrement # bytes available
	TRNE C,400000		; Check for over-decrementing
	 BUG(HLT,<GETBSP: Over-decremented BSP byte count>)
	ADD B,BSPILW(BSP)	; Update left window edge to
	TLZ B,(-1B3)		;  first byte beyond this Pup
	MOVEM B,BSPILW(BSP)

; GETBSP (cont'd)

; Initialize byte pointer to start of byte stream
	MOVEI B,PBCONT(PB)	; Make byte ptr to start of
	HRLI B,(POINT 8)	;  Pup Contents
	ROT A,-2		; Separate word and byte numbers
	ADDI B,(A)		; Advance word index in byte ptr
	HRRI A,0		; Clear word except byte # in B0-1
	LSH A,-1		; Byte # to B1-2, i.e. 8*# in B0-5
	SUB B,A			; Modify byte ptr for starting byte
	MOVEM B,PBBSID(PB)	; Store byte ptr in PB header

; Do any necessary BSP processing before returning
	PUSHJ P,DOBSPQ		; Do BSP processing if needed
	TLNE IOS,(BSZALF)	; Did we send zero allocation?
	 PUSHJ P,SNDACK		; Yes, send another Ack (presumably nonzero now)
	HLRZ PB,BSPCUR(BSP)	; Recover packet buffer pointer
	JRST SKPRET##		; Take skip return

USE RESPC

; Scheduler test for BSP input available
; Arg is Pup unit #

BSITST:	MOVSI B,(BSINPF+BSTIMF+BSERRF+BSWAKF)  ; Anything to do?
	TDNN B,PUPSTS(A)
	 JRST 0(D)		; No
	JRST 1(D)		; Yes, wakeup

USE SWAPPC



; Check for BSP output possible
; Assumes port is locked
; Returns +1:  Output not possible, A/ argument word for EDISMS
;	+2:  Output possible, A/ Max # bytes in next Pup
; Clobbers A-D, PB

CHKBSO:	LDB A,PBSOAP		; Get # additional Pups allowed
	JUMPE A,CHKBO3		; Fail if none
	HRRZ A,BSPOAL(BSP)	; Get # additional bytes allowed
	JUMPE A,CHKBO3		; Fail if none
	LDB B,PBSOBP		; Get max bytes/Pup
	JUMPE B,CHKBO3		; 0 => no Ack received yet
	CAILE A,(B)		; More than one Pups' worth?
	 MOVEI A,(B)		; Yes, cut down to max Pup length
	JRST SKPRET		; Success, skip return

; Here when output not possible
CHKBO3:	TLZ IOS,(BSOUTF)	; Clear output flag
	PUSHJ P,DOBSPL		; Make sure BSP data up-to-date
	TLNE IOS,(BSOUTF)	; Output possible now?
	 JRST CHKBSO		; Maybe, try again
	SKIPN BSPATM(BSP)	; No, is AData outstanding?
	 PUSHJ P,SNDADA		; No, force AData to be sent
	MOVSI A,(UNIT)		; Set scheduler test
	HRRI A,BSOTST
	POPJ P,			; Take fail return

USE RESPC

; Scheduler test for BSP output possible
; Arg is Pup unit #

BSOTST:	MOVSI B,(BSOUTF+BSTIMF+BSERRF+BSWAKF)  ; Anything to do?
	TDNN B,PUPSTS(A)
	 JRST 0(D)		; No
	JRST 1(D)		; Yes, wakeup

USE SWAPPC

; Build BSP Data packet
;	A/ # data bytes to be stored in Pup
; Assumes port is locked
; Returns +1:  Failed, A/ argument word for EDISMS
;	+2:  Succeeded:
;		A/ Byte count (same as call)
;		B/ Byte ptr (IDPB stores first data byte)
;		PB/ Packet buffer pointer
; Clobbers A-D, PB

BLDDAT:	HRLM A,0(P)		; Save byte count
	MOVEI B,4*PBHEAD+MNPLEN+3(A)  ; Include header and overhead
	LSH B,-2		; Convert to words
	PUSHJ P,ASGPKT		; Allocate packet buffer
	 POPJ P,		; Failed
	HRRM PB,BSPCUR(BSP)	; Ok, save current buffer ptr
	MOVEI A,PT.DAT		; Set Type = Data
	DPB A,PUPTYP
	HLRZ A,0(P)		; Recover byte count
	MOVEI B,PBCONT(PB)	; Construct byte pointer
	HRLI B,(POINT 8)
	JRST SKPRET##		; Done, skip return



; Finish up and send current Data Pup, if any
;	A/ Byte ptr to last byte stored (if any)
; Assumes port is locked
; Returns +1 always
; Clobbers A-D, PB

DMPBSP:	HRRZ PB,BSPCUR(BSP)	; Get ptr to current output PB
	JUMPE PB,CPOPJ##	; Do nothing if none
	HLLZS BSPCUR(BSP)	; Zero pointer in data block
	PUSHJ P,ENDPUP		; Compute length, trim excess
	PUSHJ P,SNDBSP		; Send it on its way
	POPJ P,

; "Force" BSP output, i.e. send the current Pup as an AData,
;  or send a null AData
;	A/ Byte ptr to last byte stored in current Pup (if any)
; Assumes port is locked
; Returns +1 always
; Clobbers A-D, PB

FRCBSP:	HRRZ PB,BSPCUR(BSP)	; Get ptr to current output PB
	JUMPE PB,FRCBS1		; Jump if none
	HLLZS BSPCUR(BSP)	; Zero pointer in data block
	PUSHJ P,ENDPUP		; Compute length, trim excess
	MOVEI A,PT.ADA		; Set Type = AData
	DPB A,PUPTYP
	PUSHJ P,SNDBSP		; Send it on its way
	POPJ P,

; Here when there is no current output packet
FRCBS1:	PUSHJ P,DOBSPQ		; Do housekeeping
	HLRZ A,BSPOBQ(BSP)	; Get tail of output queue
	CAIN A,BSPOBQ(BSP)	; Queue empty?
	 POPJ P,		; Yes, nothing to do
	MOVEI PB,-PBBSPQ(A)	; No, point to head of tail packet
	LDB A,PUPTYP		; Get Pup Type
	CAIE A,PT.ADA		; An AData?
	 CAIN A,PT.AMA		; An AMark?
	 POPJ P,		; Yes, nothing more to do
	PUSHJ P,RETADA		; No, retransmit it as AData/AMark
	POPJ P,



; Check for empty BSP output queue
; Assumes port is locked
; Returns +1:  Not empty, A/ Scheduler test, B/ # buffered bytes
;	+2:  Empty

CHKBOQ:	HRRZ A,BSPOBQ(BSP)	; Get queue head
	CAIN A,BSPOBQ(BSP)	; Empty?
	 JRST SKPRET##		; Yes, skip return
	TLO IOS,(BSNOQF)	; No, set nonempty output queue flag
	PUSHJ P,DOBSPL		; Do any necessary processing
	TLNN IOS,(BSNOQF)	; Now empty?
	 JRST CHKBOQ		; Maybe, check again
	MOVSI A,(UNIT)		; No, set scheduler test
	HRRI A,BSEOQT
	HRRZ B,BSPOQL(BSP)	; Return # buffered bytes
	POPJ P,			; Take non-skip return

USE RESPC

; Scheduler test for empty BSP output queue
; Arg is Pup unit #

BSEOQT:	MOVE B,PUPSTS(A)	; Get port status
	TLNE B,(BSNOQF)		; Output queue now empty?
	TLNE B,(BSTIMF+BSERRF+BSWAKF)  ; Error or work to do?
	 JRST 1(D)		; Yes, wakeup
	JRST 0(D)		; No, wait

USE SWAPPC

; Send BSP data packet (including AData, Mark, or AMark)
;	PB/ Packet buffer ptr
; Assumes port is locked
; Returns +1 always
; Caller is expected to have checked for allocation beforehand
;  (by calling CHKBSO)
; Caller should set up Length and Type, we do the rest
; Clobbers A-D, PB

SNDBSP:	MOVEI A,BSPOBQ(BSP)	; Point to output queue header
	MOVEI B,PBBSPQ(PB)	; Point to link word in this PB
	PUSHJ P,APPITQ		; Append new Pup to BSP queue
	HLLZS BSPCUR(BSP)	; Clear current output PB ptr
	MOVE A,TODCLK		; Time stamp the Pup
	MOVEM A,PBTIME(PB)

; Compute and store Pup ID
	HRRZ A,BSPOQL(BSP)	; Get current # bytes queued
	ADD A,BSPOLW(BSP)	; Compute ID for this Pup
	LSH A,4			; Left-justify
	MOVEM A,PBHEAD+1(PB)	; Set Pup ID

; Update Pup and byte counts for this port
	LDB A,PUPLEN		; Get Pup Length
	SUBI A,MNPLEN		; Subtract overhead
	HRLI A,1		; Count 1 Pup
	ADDM A,BSPOQL(BSP)	; Update Pups and bytes queued
	LDB C,PBSOAP		; Get additional Pups allowed
	SOSL C			; Decrement
	 DPB C,PBSOAP		; Store back unless negative
	HRRZ D,BSPOAL(BSP)	; Get additional bytes allowed
	SUBI D,(A)		; Decrement by # bytes in new Pup
	SKIPGE D		; Make sure non-negative
	 SETZ D,
	HRRM D,BSPOAL(BSP)	; Store back

; Check allocation and change Data to AData or Mark to AMark if appropriate
	LDB A,PUPTYP		; Get Pup Type
	CAIE A,PT.ADA		; Already an AData?
	 CAIN A,PT.AMA		; Already an AMark?
	 JRST SNDBS5		; Yes, nothing more needed
	PUSHJ P,CHKADA		; Check hold time and allocation
	 JRST [	MOVE D,BSPDTM(BSP)  ; Still ok, save timer
		PUSHJ P,SETTMH	; Set timer to hold time
		CAMGE D,BSPDTM(BSP)  ; Compare to previous timer
		 MOVEM D,BSPDTM(BSP)  ; Use earlier
		JRST SNDBS6]	; Go finish up
	LDB A,PUPTYP		; Time to send AData, get current type
	CAIN A,PT.DAT		; Data?
	 MOVEI A,PT.ADA		; Yes, change to AData
	CAIN A,PT.MRK		; Mark?
	 MOVEI A,PT.AMA		; Yes, change to AMark
	DPB A,PUPTYP
SNDBS5:	MOVE A,TODCLK		; Record sending AData now
	MOVEM A,BSPATM(BSP)
	PUSHJ P,SETTMR		; Set timer for retransmission

; Finish up and send the Pup
SNDBS6:	SETZ A,			; Clear transport control byte
	DPB A,PUPTCB
	PUSHJ P,SETPRT		; Set up source and dest ports
	PUSHJ P,SETCHK		; Set Pup Checksum appropriately
	PUSHJ P,PUTPUP		; Queue Pup for output
	 BUG(PUP,<SNDBSP: Output queue overflowed>,X)
	PUSHJ P,DOBSPQ		; Do housekeeping if needed
	PUSHJ P,SETPTM		; Put port on timer queue
	AOS BSPOPG(BSP)		; Count packets generated
	POPJ P,			; Done

; Send an Interrupt
;	A/ Interrupt code
;	B/ If nonzero, string ptr to Interrupt text (see BLDIAB)
; Assumes port is locked
; Returns +1:  Can't (interrupt already outstanding)
;		A/ argument word for EDISMS
;	+2:  Successfully sent
; Clobbers A-D, PB

SNDINT:	SKIPGE BSPSII(BSP)	; Interrupt already outstanding?
	 JRST [	TLO IOS,(BSINTF)  ; Yes, ensure flag is set
		PUSH P,A	; Save code and string ptr
		PUSH P,B
		PUSHJ P,DOBSPL	; Ensure BSP data up-to-date
		POP P,B
		POP P,A
		SKIPL BSPSII(BSP)  ; Still outstanding?
		 JRST .+1	; No, continue
		MOVSI A,(UNIT)	; Yes, set scheduler test
		HRRI A,INOTST
		POPJ P,]	; Take fail return
	PUSHJ P,BLDIAB		; Ok, build the Pup
	 POPJ P,		; Failed, take non-skip return
	MOVEI A,PT.INT		; Set Type = Interrupt
	DPB A,PUPTYP
	SETZ A,			; Zero out Transport control byte
	DPB A,PUPTCB
	HRROI A,0(PB)		; Make PB ptr with sign set
	EXCH A,BSPSII(BSP)	; Store it, get Interrupt ID
	LSH A,4			; Left-justify
	MOVEM A,PBHEAD+1(PB)	; Store in Pup
	PUSHJ P,SETPRT		; Set up source and dest ports
	PUSHJ P,SETCHK		; Set Pup Checksum appropriately
	SETOM PBBSPQ(PB)	; Mark PB as owned by BSP process
	MOVE A,TODCLK		; Time stamp
	MOVEM A,PBTIME(PB)
	HLRZ B,BSPTIM(BSP)	; Get round-trip delay
	LSH B,1			; Double to make retransmission timeout
	ADDI A,(B)		; Compute time for next check
	MOVEM A,BSPITM(BSP)	; Store in data block
	PUSHJ P,PUTPUP		; Queue Pup for output
	 BUG(PUP,<SNDINT: Output queue overflowed>,X)
	TLO IOS,(BSINTF)	; Ensure flag is set
	PUSHJ P,DOBSPQ		; Check for work to be done
	PUSHJ P,SETPTM		; Put port on timer queue
	JRST SKPRET##		; Finished, skip return

USE RESPC

; Scheduler test for Interrupt no longer outstanding
; Arg is Pup unit #

INOTST:	MOVE B,PUPSTS(A)	; Get port status
	TLNE B,(BSINTF)		; Interrupt no longer outstanding?
	TLNE B,(BSTIMF+BSERRF+BSWAKF)  ; Error or work to do?
	 JRST 1(D)		; Yes, wakeup
	JRST 0(D)		; No, wait

USE SWAPPC

; Send an Abort
;	A/ Abort code
;	B/ If nonzero, string ptr to Abort text (see BLDIAB)
; Assumes port is locked
; Returns +1 always
; Clobbers A-D, PB

SNDABT:	PUSHJ P,BLDIAB		; Build the Pup
	 POPJ P,		; Failed, forget it
	MOVE A,BSPCID(BSP)	; Get Connection ID
	LSH A,4			; Left-justify
	MOVEM A,PBHEAD+1(PB)	; Store as Pup ID
	MOVEI A,PT.ABT		; Set Type = Abort
	PUSHJ P,SNDPUP		; Finish up and send the Pup
	 CAI			; Ignore failure
	POPJ P,			; Done

; Build Interrupt or Abort (common code)
;	A/ B0 clear if called from user, set if from monitor
;	   rh: Interrupt or Abort Code
;	B/ If nonzero, string ptr to text in appropriate space
; Assumes port is locked
; Returns +1:  Can't (no room), A/ argument word for EDISMS
;	+2:  Successful, PB/ ptr to packet buffer

BLDIAB:	HLLM A,0(P)		; Save address space indicator
	PUSH P,B		; Save string ptr to text
	PUSH P,A		; Save code
	MOVEI B,PBHEAD+<MNPLEN+MXPTXT+2+3>/4
	PUSHJ P,ASGPKT		; Assign packet buffer
	 JRST [	SUB P,BHC##+2	; Can't, flush args
		POPJ P,]	; Fail return
	POP P,B			; Recover code
	DPB B,[POINT 16,PBCONT(PB),15]  ; Store in Pup
	MOVE A,[POINT 8,PBCONT(PB),15]  ; Init ptr for storing text
	POP P,B			; Recover string ptr to text
	JUMPE B,BLDIA2		; Jump if no text
	TLC B,-1		; Left half = -1?
	TLCN B,-1
	 HRLI B,(POINT 7)	; Yes, change to string ptr
	MOVEI C,MXPTXT		; Init byte counter
BLDIA1:	SKIPGE 0(P)		; Check address space indicator
	 ILDB D,B		; Get byte from monitor
	SKIPL 0(P)
	 XCTBU .-2		; Get byte from user
	JUMPE D,BLDIA2		; Jump if end
	IDPB D,A		; Put byte in Pup
	SOJG C,BLDIA1		; Repeat if still room
BLDIA2:	PUSHJ P,ENDPUP		; Compute length, trim excess
	JRST SKPRET##		; Skip return



; Send an AMark
;	A/ Mark byte (right-justified)
; Assumes port is locked
; Returns +1:  Can't, A/ argument word for EDISMS
;	+2:  Successfully sent
; Note caller is expected to have finished any preceding data Pup
; Clobbers A-D, PB, BSP, IOS

SNDAMA:	IORI A,400000		; Flag to send Amark
				; Fall into Mark code


; Send a Mark
;	A/ Mark byte (right-justified)
; Assumes port is locked
; Returns +1:  Can't, A/ argument word for EDISMS
;	+2:  Successfully sent
; Note caller is expected to have finished any preceding data Pup
; Clobbers A-D, PB, BSP, IOS

SNDMRK:	HRLM A,0(P)		; Save Mark byte
	PUSHJ P,CHKBSO		; Check for BSP output possible
	 POPJ P,		; Not now, take fail return
	MOVEI B,PBHEAD+<MNPLEN+1+3>/4
	PUSHJ P,ASGPKT		; Allocate packet buffer
	 POPJ P,		; Couldn't, take fail return
	HLRZ A,0(P)		; Ok, get back the byte
	MOVEI B,PT.MRK		; Assume want to send Mark
	TRZE A,400000		; AMark flag set?
	 MOVEI B,PT.AMA		; Yes
	DPB A,[POINT 8,PBCONT(PB),7]  ; Store Mark byte
	DPB B,PUPTYP		; Set Pup Type
	MOVEI A,MNPLEN+1	; Set Pup Length appropriately
	DPB A,PUPLEN
	PUSHJ P,SNDBSP		; Send it on its way
	JRST SKPRET##		; Done, skip return

; Perform BSP processing for a port, if possible
; Called only from background
;	UNIT/ Pup unit #
; Returns +1
; Clobbers most everything besides UNIT

DOBSP:	LOCK(PRTLCK,,SPQ)	; Lock out changes to port table
	HRRZ BSP,PUPLNH(UNIT)	; Get BSP linkage if any
	JUMPE BSP,[UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Do nothing if not BSP port
		POPJ P,]
	PUSHJ P,LCKBSA		; Attempt to lock BSP port
	 JRST [	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Can't, unlock table
		MOVE A,TODCLK	; Request delayed background processing
		ADDI A,IBWDLY	; Input background wakeup delay interval
		PUSHJ P,ADDTQP	; Add port to timer queue
		POPJ P,]	; Return having done nothing
	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Ok, unlock the table
	PUSHJ P,DOBSPB		; Do the real work
	PUSHJ P,ULKBSP		; Update status, unlock BSP port
	POPJ P,			; Done


; Perform BSP processing for port locked by caller
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
;	IOS/ Port status
; Returns +1 always, does not unlock port
; Clobbers A-D, PB

; Enter here to perform processing only if requested
DOBSPQ:	TLNE IOS,(BSWAKF)	; Specifically woken up?
	 JRST DOBSPL		; Yes, always do it
	MOVE A,TODCLK		; No, get now
	SKIPE PUPTMQ(UNIT)	; Is there a timer request in?
	 CAMGE A,PUPTIM(UNIT)	; Yes, is it due?
	 POPJ P,		; No, do nothing

; Enter here to reset possibly pending requests first
DOBSPL:	PUSHJ P,DELTQP		; Delete timer request if pending

; Enter here from DOBSP (background only)
DOBSPB:	TLZ IOS,(BSWAKF)	; Cancel wakeup request
	MOVEM IOS,PUPSTS(UNIT)	; Update in core too

; Process packets on input queue
DOBSP1:	PUSHJ P,GETPUP		; Get packet from input queue
	 JRST DOBSP2		; Queue empty
	PUSH P,E
	PUSHJ P,DOBSPI		; Process the packet
	POP P,E
	JRST DOBSP1		; Repeat until queue empty

; Send Ack if needed
DOBSP2:	TLZE IOS,(BSSAKF)	; Need to send Ack?
	 PUSHJ P,SNDACK		; Yes, do so

; See if time yet to check for BSP retransmissions
	MOVE A,TODCLK		; Get now
	CAMGE A,BSPDTM(BSP)	; Time for check?
	TLNE IOS,(BSRAKF)	; Received Ack?
	 PUSHJ P,DOBSPO		; Yes, do output processing

; Check outstanding Interrupts
	MOVE A,TODCLK		; Get now
	CAML A,BSPITM(BSP)	; Time for check?
	 PUSHJ P,CKPINT		; Yes, do so

; Check FSM if required
	MOVE A,TODCLK		; Get now
	CAML A,BSPFTM(BSP)	; Time for FSM check?
	 PUSHJ P,[MOVEI A,E.TIMO  ; Yes, generate timeout event
		JRST PUPFSC]

; Compute time for next service
	JRST SETPTM		; Set time and return

; Process input packet for BSP port
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
;	IOS/ Port status
;	PB/ Packet buffer pointer
; Returns +1
; Clobbers A-D, E
; Updates IOS where appropriate

DOBSPI:
; Check Pup Checksum unless inhibited by user
	TLNE IOS,(BSNCHK)	; Checksumming inhibited?
	 JRST .+3		; Yes, bypass
	PUSHJ P,CHKCKS		; No, check checksum
	 BUG(DPR,<DOBSPI: Pup Checksum incorrect>,X)

; Check Pup Type and get dispatch
	LDB E,PUPTYP		; Get Pup Type
	CAIGE E,NBSDSP		; Within bounds?
	 SKIPN E,BSPDSP(E)	; Yes, get flags and dispatch
	 BUG(DPR,<DOBSPI: BSP Pup of unknown type>,X)

; Perform pre-dispatch checking of Pup depending on flags
	TLNN E,(1B16)		; Check Source Port?
	 JRST .+3		; No
	PUSHJ P,CHKSRC		; Yes, perform source port check
	 BUG(DPR,<DOBSPI: BSP Pup from incorrect Source Port>,X)

	TLNN E,(1B17)		; Check Pup ID?
	 JRST DOBSI1		; No
	MOVE A,PBHEAD+1(PB)	; Yes, get word containing Pup ID
	LSH A,-4		; Right-justify
	CAME A,BSPCID(BSP)	; Same as Connection ID?
	 BUG(DPR,<DOBSPI: BSP Pup with incorrect ID>,X)

DOBSI1:	LDB A,PBSSTT		; Get current state
	TDNN E,BITS##(A)	; Reasonable type for this state?
	 BUG(DPR,<DOBSPI: Improper port state for received Pup>,X)

	MOVE A,TODCLK		; Get now
	TLNE E,(1B15)		; Want to reset timeout?
	 MOVEM A,BSPACT(BSP)	; Remember time of last activity
	JRST 0(E)		; Dispatch to processing routine


; BSP dispatch table, indexed by Pup Type
; Flags:
;	B0 - max state #:  Proper port states for this type
;	B15: Update activity timeout before dispatch
;	B16: Check Source Port before dispatch
;	B17: Check for Pup ID = Connection ID before dispatch

BSPDSP:	0			; (0)
	ALLSTT+1B16+RCVECH	; (1) Echo Me
	ALLSTT+1B16+RCVIEC	; (2) I'm An Echo
	ALLSTT+1B16+RCVBEC	; (3) I'm A Bad Echo
	ALLSTT+RCVERR		; (4) Error
	0			; (5)
	0			; (6)
	0			; (7)
	STTBTS(RFCO,LIST,OPEN,ENDO)+1B15+RCVRFC  ; (10) Request for Connection
	ALLSTT+1B16+1B17+RCVABT	; (11) Abort
	ALLSTT+1B15+1B16+1B17+RCVEND  ; (12) End
	ALLSTT+1B15+1B16+1B17+RCVENR  ; (13) End Reply
	0			; (14)
	0			; (15)
	0			; (16)
	0			; (17)
	STTBTS(OPEN,ENDO)+1B15+1B16+RCVDAT  ; (20) Data
	STTBTS(OPEN,ENDO)+1B15+1B16+RCVADA  ; (21) AData
	STTBTS(OPEN,ENDI)+1B15+1B16+RCVACK  ; (22) Acknowledgment
	STTBTS(OPEN,ENDO)+1B15+1B16+RCVMRK  ; (23) Mark
	STTBTS(OPEN,ENDI,ENDO)+1B15+1B16+RCVINT  ; (24) Interrupt
	STTBTS(OPEN,ENDI,ENDO)+1B15+1B16+RCVINR  ; (25) Interrupt Reply
	STTBTS(OPEN,ENDO)+1B15+1B16+RCVAMA  ; (26) AMark

NBSDSP==.-BSPDSP	; Length of the dispatch table

; Individual BSP Pup input processing routines
; All routines have the following calling sequence:
;	PB/ Packet buffer ptr
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
;	IOS/ BSPSTS(BSP)
; Returns +1 always
; Routine is expected to dispose of the packet
; Clobbers A-D
; Routines to handle RFC, Abort, End, and End Reply are located
;  near the FSM routines


; Echo
; ----

RCVECH:	MOVEI A,PT.IEC		; Set type = "I'm an Echo"
	DPB A,PUPTYP
	PUSHJ P,SWPPRT		; Swap source and destination ports
	PUSHJ P,SNDPU1		; Setup and send
	 CAI			; Ignore if failed
	POPJ P,			; Done, packet buffer re-used


; I'm an Echo
; -----------

RCVIEC:				; Discard (we don't send EchoMe's)


; I'm a Bad Echo
; --------------

RCVBEC:	JRST RELPKT		; Discard (we don't send EchoMe's)



; Error
; -----

RCVERR:	BUG(PUP,<RCVERR: Received Error Pup>,X)
	LDB A,[POINT 16,PBCONT+5(PB),15]  ; Get error type
	CAIE A,3		; Port IQ overflow?
	CAIN A,1007		; Gateway OQ overflow?
	 JRST RCVER1		; Yes
	CAIN A,2		; No such port?
	 PUSHJ P,CHKSRC		; Yes, make sure source correct
	  JRST RELPKT		; Not, discard
	JRST RCVABT		; Yes, treat same as Abort

RCVER1:	HLRZ A,BSPTIM(BSP)	; Get retransmission timeout
	IMULI A,9		; Increase by 1/8
	LSH A,-3
	CAIG A,MAXRET		; Within maximum?
	 HRLM A,BSPTIM(BSP)	; Yes, update
	JRST RELPKT		; Discard packet and return

; Input Pup processing routines (cont'd)

; AMark
; -----

RCVAMA:	TLO IOS,(BSSAKF)	; Request that an Ack be sent

; Mark
; ----

RCVMRK:	LDB A,PUPLEN		; Make sure it contains just 1 byte
	CAIE A,MNPLEN+1
	 BUG(DPR,<RCVMRK: Received Mark with incorrect length>,X)
	JRST RCVDAT		; Handle Mark like Data


; AData
; -----

RCVADA:	TLO IOS,(BSSAKF)	; Request that an Ack be sent

; Data
; ----

RCVDAT:	HRLM PB,0(P)		; Save PB pointer
	MOVEI A,17		; Get Pup ID and clear garbage bits
	ANDCAB A,PBHEAD+1(PB)
	LSH A,-4		; Right-justify
	MOVEM A,PBBSID(PB)	; Store in more convenient form
	LDB B,PUPLEN		; Get Pup Length
	SUBI B,MNPLEN		; Compute # data bytes
	JUMPE B,RELPKT		; Flush packet if none
	MOVEM B,PBBSBC(PB)	; Store in more convenient form
	MOVE C,BSPILW(BSP)	; Get left window edge
	HRRZ D,BSPIAL(BSP)	; Get width of window
	PUSHJ P,CMPIVL		; Compare intervals
	 JRST RCVDA1		; Identical (ok but most unlikely)
	 JRST RCVDA1		; Pup subinterval of window
	 BUG(DPR,<RCVDAT: Received Data Pup larger than window>,X)
	 JRST RCVDA1		; Intersect but not contained
	 JRST RELPKT		; Outside window, discard quietly

; Scan the BSP input queue and find where this packet belongs
RCVDA1:	MOVEI C,BSPIBQ(BSP)	; Start at tail of input queue
RCVDA2:	HLRZ C,0(C)		; Get predecessor
	CAIN C,BSPIBQ(BSP)	; Reached head of queue?
	 JRST [	HRRZ A,0(C)	; Yes, must belong here
		JRST RCVDA4]
	MOVE A,PBHEAD+1(PB)	; No, get back ID of new Pup
	SUB A,PBHEAD+1-PBBSPQ(C) ; Compare to ID of queued Pup
	JUMPL A,RCVDA2		; Repeat if existing ID larger

; Now C points to PBBSPQ of last old Pup with ID <= new Pup's ID
; B still contains the new Pup's length
	MOVE A,PBBSID(PB)	; Get back ID of new Pup
	MOVEI PB,-PBBSPQ(C)	; Point to head of existing packet
	MOVE C,PBBSID(PB)	; Get its ID
	MOVE D,PBBSBC(PB)	; Get # data bytes in it
	PUSHJ P,CMPIVL		; Compare intervals
	 CAI			; +1: Identical, discard new packet
	 JRST [	HLRZ PB,0(P)	; +2: New packet is contained by
		JRST RELPKT]	;  existing one, discard new
	 JRST [	MOVEI A,PBBSPQ(PB)  ; +3: Existing contained by
		JRST RCVDA4]	;    new, insert new before it
	 CAI			; +4: Intersect without containment
	HRRZ A,PBBSPQ(PB)	; +5: Disjoint, get successor

; Input Pup processing routines (cont'd)

; Data (cont'd)
; ----

; Now ready to put the new packet on the input queue.
; A points to PBBSPQ word of packet before which the new packet
;  is to be inserted (i.e. to be the new packet's successor).
RCVDA4:	HLRZ PB,0(P)		; Recover new PB pointer
	HLRZ C,BSPIQL(BSP)	; Get # Pups already on queue
	LDB B,PBSIAP		; Get max # Pups allowed
	CAIL C,(B)		; Allocation exhausted?
	 BUG(DPR,<RCVDAT: Received Data exceeding Pup allocation>,X)
	MOVSI C,1		; No, add to count
	ADDM C,BSPIQL(BSP)
	MOVEI B,PBBSPQ(PB)	; Make ptr to queue link word
	PUSHJ P,INSITQ		; Insert into queue

; Scan successor Pups for ones completely swallowed by the new one
RCVDA5:	HRRZ A,PBBSPQ(PB)	; Get new Pup's successor
	CAIN A,BSPIBQ(BSP)	; Make sure there is one
	 JRST RCVDA6		; None, skip this
	MOVE C,PBBSID-PBBSPQ(A)	; Get ID of existing Pup
	MOVE D,PBBSBC-PBBSPQ(A)	; Get # data bytes in it
	MOVE A,PBBSID(PB)	; Get ID of new Pup
	MOVE B,PBBSBC(PB)	; Get # data bytes in it
	PUSHJ P,CMPIVL		; Compare intervals
	 BUG(HLT,<RCVDAT: Impossible +1 return from CMPIVL>)
	 BUG(HLT,<RCVDAT: Impossible +2 return from CMPIVL>)
	 JRST [	HRRZ A,PBBSPQ(PB)  ; +3: Existing contained by
		MOVEI PB,-PBBSPQ(A) ;  new, delete existing
		PUSHJ P,DELBIQ
		HLRZ PB,0(P)	; Recover new PB pointer
		JRST RCVDA5]	; Repeat for new successor
	 CAI			; +4: Intersect without containment
				; +5: Disjoint

; If we filled in a hole, update byte count
RCVDA6:	MOVE A,PBBSID(PB)	; Get ID of new Pup
	SUB A,BSPILW(BSP)	; Compute bytes from left edge
	TLZ A,(-1B3)		;  mod 2^32
	HRRZ B,BSPIQL(BSP)	; Get # bytes to first hole
	CAILE A,(B)		; New Pup starts before or at hole?
	 JRST RCVDA7		; No
	ADD A,PBBSBC(PB)	; Yes, add # bytes in new Pup
	CAILE A,(B)		; Now past start of hole?
	 HRRM A,BSPIQL(BSP)	; Yes, update # bytes available
	HRRZ A,PBBSPQ(PB)	; Advance to successor Pup
	CAIN A,BSPIBQ(BSP)	; Ran off end of queue?
	 JRST RCVDA7		; Yes, stop here
	MOVEI PB,-PBBSPQ(A)
	JRST RCVDA6		; Repeat until hit new hole

RCVDA7:	HRRZ B,BSPIQL(BSP)	; New # bytes to first hole
	SKIPE B			; Bytes now available?
	 PUSHJ P,WAKBSI		; Yes, awaken input
	POPJ P,			; Done

; Input Pup processing routines (cont'd)

; Acknowledgment
; --------------

RCVACK:	LDB A,PUPLEN		; Get Pup Length
	CAIGE A,MNPLEN+6	; Make sure big enough
	 BUG(DPR,<RCVACK: Pup too small>,X)
	MOVE A,PBHEAD+1(PB)	; Get Pup ID
	LSH A,-4		; Right-justify
	MOVE B,A		; Copy it
	SUB B,BSPOLW(BSP)	; Compute distance from left window edge
	TLZ B,(-1B3)		;  modulo 2^32
	HRRZ C,BSPOQL(BSP)	; Get width of window
	CAILE B,(C)		; Pup ID in window?
	 BUG(DPR,<RCVACK: Received Ack with unreasonable ID>,X)
	MOVEM A,BSPOLW(BSP)	; Yes, store new left window edge
	SUBI C,(B)		; Compute updated width
	HRRM C,BSPOQL(BSP)
	HRLM PB,0(P)		; Save pointer to Ack packet
	TLO IOS,(BSRAKF)	; Note that we received an Ack

; Scan BSP output queue and discard packets now lying entirely
;  outside the updated window.  Ignore Pos/NegAcks ****************
RCVAC1:	HRRZ A,BSPOBQ(BSP)	; Get BSP output queue head
	CAIN A,BSPOBQ(BSP)	; Now empty?
	 JRST RCVAC5		; Yes
	MOVEI PB,-PBBSPQ(A)	; No, make ptr to head PB
	MOVE A,PBHEAD+1(PB)	; Get Pup ID
	LSH A,-4		; Right-justify
	LDB B,PUPLEN		; Get Pup Length
	ADDI A,-MNPLEN-1(B)	; Compute ID of last byte in Pup
	SUB A,BSPOLW(BSP)	; Compare to left window edge
	LSH A,4
	JUMPGE A,RCVAC5		; Jump if in window
	PUSHJ P,DELBOQ		; Outside, delete from output queue
	JRST RCVAC1		; Continue with next

; Update the allocations
RCVAC5:	HLRZ PB,0(P)		; Recover ptr to Ack packet
	MOVE D,[POINT 16,PBCONT(PB)]  ; Init byte ptr to data  
	ILDB A,D		; Get "Max bytes/Pup" field
	CAILE A,MXPLEN-MNPLEN	; More than what we allow anyway?
	 MOVEI A,MXPLEN-MNPLEN	; Yes, cut down
	LDB B,PBSOBP		; Get current bytes/Pup
	CAIGE A,(B)		; Decreasing?
	 BUG(PUP,<RCVACK: Allocated decreasing bytes per Pup>,X)
	DPB A,PBSOBP		; Store updated bytes/Pup
	ILDB A,D		; Get "Number of Pups" field
	CAILE A,MXBSOP		; More than maximum we allow?
	 MOVEI A,MXBSOP		; Yes, limit
	HLRZ B,BSPOQL(BSP)	; Get # Pups already queued
	SUBI A,(B)		; Compute additional Pups
	SKIPGE A		; Make sure positive
	 SETZ A,		; Force to zero otherwise
	DPB A,PBSOAP		; Store # additional Pups allowed
	ILDB A,D		; Get "Number of bytes" field
	CAILE A,MXBSOB		; More than maximum we allow?
	 MOVEI A,MXBSOB		; Yes, limit
	HRRZ B,BSPOQL(BSP)	; Get # bytes already queued
	SUBI A,(B)		; Compute additional bytes allowed
	SKIPGE A		; Make sure positive
	 SETZ A,		; Force to zero otherwise
	HRRM A,BSPOAL(BSP)	; Store # additional bytes allowed

; Input Pup processing routines (cont'd)

; Acknowledgment (cont'd)
; --------------

; Revise running estimate of round-trip delay.
; new estimate _ (7 * old estimate + new sample) / 8.
	MOVE A,TODCLK
	SUB A,BSPATM(BSP)	; Actual time since most recent AData sent
	CAIG A,MINRET		; Keep within reasonable bounds
	 MOVEI A,MINRET
	CAIL A,MAXRET
	 MOVEI A,MAXRET
	HLRZ B,BSPTIM(BSP)	; Get old estimate
	IMULI B,7		; Compute new estimate
	ADD B,A
	LSH B,-3
	HRLM B,BSPTIM(BSP)	; Store new estimate

; Update status and return
	HRRZ A,BSPOBQ(BSP)	; Get output queue head
	CAIN A,BSPOBQ(BSP)	; Now empty?
	 TLZ IOS,(BSNOQF)	; Yes, notify anyone watching this
	MOVE A,BSPOAL(BSP)	; Get additional allocation
	TLNE A,(-1B7)		; Can send more Pups?
	TRNN A,-1		; Can send more bytes?
	 CAIA			; No
	 PUSHJ P,WAKBSO		; Yes, awaken BSP output
	JRST RELPKT		; Discard the Ack and return

; Input Pup processing routines (cont'd)

; Interrupt
; ---------

RCVINT:	MOVE A,PBHEAD+1(PB)	; Get Pup ID
	LSH A,-4		; Right-justify
	CAME A,BSPRII(BSP)	; Same as next expected?
	 AOJA A,RCVIN2		; No
	HRRE B,PUPPSI(UNIT)	; Yes, get fork to interrupt
	JUMPGE B,[LDB A,INTPSI	; Get PSI channel to interrupt on
		CAIGE A,^D36	; Armed?
		 PUSHJ P,PSIRQF## ; Yes, initiate PSI on channel
		JRST RCVIN1]
	AOJE B,RCVIN1		; Jump if no assignment
	MOVEI B,-400001(B)	; NVT, get TTY #
	PUSHJ P,NVTINT		; Process the interrupt
RCVIN1:	AOS BSPRII(BSP)		; Advance receive interrupt ID
	MOVSI A,(-1B3)		;  modulo 2^32
	ANDCAM A,BSPRII(BSP)
	JRST RCVIN3		; Go send reply

; Here if Pup ID is not the same as expected
; If it is the expected ID -1, it is a duplicate which we
;  should acknowledge but not generate an interrupt.  Else flush.
; A/ Pup ID +1
RCVIN2:	TLZ A,(-1B3)		; Make +1 modulo 2^32
	CAME A,BSPRII(BSP)	; Was this a duplicate?
	 BUG(DPR,<RCVINT: Received Interrupt with incorrect ID>,X)

; Here to send the acknowledging Interrupt Reply
RCVIN3:	MOVEI A,PT.INR		; Set type = "Interrupt Reply"
	PUSHJ P,SNDPUP		; Setup and send it back
	 CAI			; Ignore if failed
	POPJ P,			; Done, packet buffer re-used


; Interrupt Reply
; ---------------

RCVINR:	SKIPL A,BSPSII(BSP)	; Check for outstanding Interrupt
	 BUG(DPR,<RCVINR: Received unexpected Interrupt Reply>,X)
	MOVE B,PBHEAD+1(PB)	; Get Pup ID
	ANDCMI B,17		; Clear garbage bits
	CAME B,PBHEAD+1(A)	; Same as outstanding Interrupt's ID?
	 BUG(DPR,<RCVINR: Received Interrupt Reply with incorrect ID>,X)
	PUSHJ P,RELPKT		; Yes, release the Interrupt Reply
	HRRZ PB,BSPSII(BSP)	; Get ptr to Interrupt again
	MOVE A,PBHEAD+1(PB)	; Get Pup ID
	ADDI A,20		; Increment and right-justify
	LSH A,-4
	MOVEM A,BSPSII(BSP)	; Store updated send Interrupt ID
	PUSHJ P,DELOBQ		; Unqueue and release saved Interrupt
	HRLOI A,377777		; Set Interrupt timer to infinity
	MOVEM A,BSPITM(BSP)
	TLZ IOS,(BSINTF)	; Clear Interrupt outstanding flag
	POPJ P,			; Done, packet disposed of



; Check for retransmission of Interrupt Pup
; Assumes port locked and ac's setup
; Returns +1
; Clobbers A-D, PB

CKPINT:	SKIPL PB,BSPSII(BSP)	; Have outstanding Interrupt?
	 JRST [	HRLOI A,377777	; No, reset timer to infinity
		JRST CKPIN1]
	PUSHJ P,RETPUP		; Yes, queue for retransmission
	MOVE A,PBTIME(PB)	; Get time of original transmission
	PUSHJ P,NXTTIM		; Compute time of next check
CKPIN1:	MOVEM A,BSPITM(BSP)	; Store in data block
	POPJ P,

; Do BSP output processing -- flow control and retransmission
; Assumes port locked and ac's setup
; Returns +1 always
; Clobbers A-D, PB

DOBSPO:	CHKSTT <OPEN,ENDI>	; Reasonable state for BSP output?
	 JRST [	HRLOI A,377777	; No, set timer to infinity
		MOVEM A,BSPDTM(BSP)
		TLZ IOS,(BSRAKF)  ; Clear rec'd Ack flag
		POPJ P,]	; Return having done nothing
	TLZN IOS,(BSRAKF)	; Received Ack?
	 JRST DOBSO6		; No, just check timers

; Ack was received
; See if we have any packets to retransmit
	HRRZ A,BSPOBQ(BSP)	; Get head of queue
	CAIN A,BSPOBQ(BSP)	; Empty?
	 JRST SETTMI		; Yes, set idle interval and return
	HLRZ D,BSPTIM(BSP)	; No, get round-trip time
	LSH D,-1		; Make cutoff be now minus half that
	ADD D,PBTIME-PBBSPQ(A)	; Check time stamp of first packet
	CAMLE D,TODCLK		; Older than round-trip time?
	 JRST [	PUSHJ P,CHKADA	; No retransmittable packets, want to send AData?
		 JRST SETTMH	; No, set hold interval and return
		PUSHJ P,SETTMR	; Yes, compute time of next probe
		JRST SNDADA]	; Send null AData and return

; Retransmit all unacknowledged packets older than the estimated
;  round-trip delay
DOBSO1:	MOVEI PB,-PBBSPQ(A)	; Make pointer to head of PB
	HLRZ D,BSPTIM(BSP)	; Get round-trip time
	LSH D,-1		; Make cutoff be now minus half that
	MOVN D,D		; Make negative
	ADD D,TODCLK		; Compute cutoff time
	HRRZ A,PBBSPQ(PB)	; Get successor of current packet
	CAIE A,BSPOBQ(BSP)	; Is there one?
	 CAMGE D,PBTIME-PBBSPQ(A)  ; Yes, also retransmittable?
	 JRST DOBSO2		; No, possibly want to send AData
	PUSHJ P,RETDAT		; Yes, retransmit current as Data
	HRRZ A,PBBSPQ(PB)	; Get successor again
	JRST DOBSO1		; Repeat for it

; Here when have last retransmittable packet
DOBSO2:	PUSHJ P,CHKADA		; Timer expired or allocation low?
	 JRST [	PUSHJ P,RETDAT	; No, retransmit as Data
		JRST SETTMH]	; Set hold interval, return
	PUSHJ P,RETADA		; Yes, retransmit as AData
	JRST SETTMR		; Set retransmission interval, exit

; Here if no Ack was received
; If data timer ran out, send an AData if necessary
; Also check error timer
DOBSO6:	MOVE A,TODCLK		; Get now
	CAMGE A,BSPDTM(BSP)	; Timed out?
	 POPJ P,		; No, done
	SUB A,BSPACT(BSP)	; Yes, compute time since last activity
	LDB B,PBSTMO		; Get error timeout interval
	LSH B,^D12		; Convert to ms
	CAML A,B		; Too long?
	 PUSHJ P,BSPTMO		; Yes, signal error timeout

	PUSHJ P,SETTMI		; Compute time for next probe
	PUSHJ P,SNDADA		; Send null AData
	POPJ P,

; Determine whether want to (re)transmit AData, i.e.,
;  compute the predicate:
;	~ ADataOut and (AllocAlmostGone or Time[Oldest]<Now-Hold)
; Assumes port is locked and ac's setup
; Returns +1:  Don't send AData
;	+2:  Send AData
; Clobbers A, B

CHKADA:	HLRZ A,BSPTIM(BSP)	; Get round-trip delay
	LSH A,-1		; Make cutoff be now minus half that
	ADD A,BSPATM(BSP)	; Add to time of last AData
	CAML A,TODCLK		; More recent than round-trip time?
	 POPJ P,		; Yes, don't send another
	HRRZ A,BSPOBQ(BSP)	; No, get head of queue
	CAIN A,BSPOBQ(BSP)	; Empty?
	 JRST CHKALL		; Yes, skip this test
	MOVE A,PBTIME-PBBSPQ(A)	; No, get packet's time stamp
	ADDI A,HLDINT		; Add hold time
	CAMGE A,TODCLK		; Packet older than hold time?
	 JRST SKPRET##		; Yes, return +2: send AData
				; No, fall into CHKALL


; Check for allocation being low
; Assumes port is locked and ac's setup
; Returns +1:  allocation sufficient
;	+2:  allocation exhausted or almost exhausted
; Clobbers A, B

CHKALL:
IFN ALLPCT,<	; If overlapping Data/Acks
	LDB A,PBSOAP		; Get # Pups allocation
	HLRZ B,BSPOQL(BSP)	; Get # Pups already queued
	ADDI B,(A)		; Derive initial allocation
	IMULI A,^D100/ALLPCT	; Below threshold?
	CAMG A,B
	 JRST SKPRET##		; Yes, return +2: almost exhausted
	HRRZ A,BSPOAL(BSP)	; No, now get # bytes allocation
	HRRZ B,BSPOQL(BSP)	; Get # bytes already queued
	ADDI B,(A)		; Derive initial allocation
	IMULI A,^D100/ALLPCT	; Below threshold?
	CAMG A,B
	 JRST SKPRET##		; Yes, return +2: almost exhausted
	POPJ P,			; No, +1:  allocation sufficient
>
IFE ALLPCT,<	; If not overlapping Data/Acks
	LDB A,PBSOAP		; Get # Pups allocation
	JUMPE A,SKPRET##	; Return +2 if exhausted
	HRRZ A,BSPOAL(BSP)	; Get # bytes allocation
	JUMPE A,SKPRET##	; Return +2 if exhausted
	POPJ P,			; Not exhausted, return +1
>

; Routines to compute and store new timeout
; All return +1 and clobber A, B

; Enter here to set timer to Time[Oldest]+HoldTime
; If the queue is empty, the idle probe interval is used
SETTMH:	HRRZ B,BSPOBQ(BSP)	; Get head of queue
	CAIN B,BSPOBQ(BSP)	; Empty?
	 JRST SETTM2		; Yes, use idle interval
	MOVE A,PBTIME-PBBSPQ(B)	; Get age of packet
	ADDI A,HLDINT		; Compute remaining hold time
	SUB A,TODCLK
	HLRZ B,BSPTIM(BSP)	; Get round trip delay
	LSH B,1			; Make retransmission timeout be double that
	CAIGE A,(B)		; Hold at least that long
	 MOVEI A,(B)
	JRST SETTM3		; Go set new time

; Enter here to set timer to Now + Retransmission interval
SETTMR:	HLRZ A,BSPTIM(BSP)	; Get round trip delay
	LSH A,1			; Make retransmission timeout be double that
	JRST SETTM3		; Go set new time

; Enter here to set timer to idle probe interval, i.e.:
;  if AllocExhausted then Now+HLDINT else Now+IDLINT
SETTMI:	MOVE A,BSPOAL(BSP)	; Get allocations
	TLNE A,(-1B7)		; Pups exhausted?
	TRNN A,-1		; Bytes exhausted?
	 SKIPA A,[HLDINT]	; Yes, use hold interval (shorter)
SETTM2:	MOVEI A,PRBINT		; Not exhausted, use idle interval
SETTM3:	ADD A,TODCLK		; Add increment to now
SETTM4:	MOVEM A,BSPDTM(BSP)	; Set time of next check
	POPJ P,

; Retransmit Data/Mark Pup as AData/AMark
;	PB/ Packet buffer ptr
; Assumes port is locked and ac's setup
; Returns +1 always
; Clobbers A-D

RETADA:	LDB A,PUPTYP		; Get existing type
	CAIN A,PT.DAT		; Data?
	 MOVEI A,PT.ADA		; Yes, change to AData
	CAIN A,PT.MRK		; Mark?
	 MOVEI A,PT.AMA		; Yes, change to AMark
	MOVE B,TODCLK		; Save time we sent it
	MOVEM B,BSPATM(BSP)
	JRST RETDA1		; Join common code

; Retransmit Data/Mark Pup as Data/Mark
;	PB/ Packet buffer ptr
; Assumes port is locked and ac's setup
; Returns +1 always
; Clobbers A-D

RETDAT:	LDB A,PUPTYP		; Get existing type
	CAIN A,PT.ADA		; AData?
	 MOVEI A,PT.DAT		; Yes, change to Data
	CAIN A,PT.AMA		; AMark?
	 MOVEI A,PT.MRK		; Yes, change to Mark
RETDA1:	MOVE B,PUPTYP		; Get byte ptr to existing type
	LDB C,B			; Get existing Pup Type
	CAIE A,(C)		; Changing type?
	 PUSHJ P,UPDCKS		; Yes, do so and fix checksum
	AOS BSPOPR(BSP)		; Count retransmitted packets

; Fall into RETPUP
; Note there is a potential race here whose worst effect would
; be sending a Pup with a bad checksum.


; Retransmit a Pup
;	PB/ Packet buffer ptr
; Assumes port is locked and ac's setup
; Returns +1 always
; Clobbers A-D

RETPUP:	SKIPE PBIOBQ(PB)	; Already queued for transmission?
	 JRST RETPU1		; Yes
	PUSHJ P,PUTPUP		; No, put on queue
	 BUG(PUP,<RETPUP: Output queue overflowed>,X)
	POPJ P,

RETPU1:	BUG(PUP,<RETPUP: Pup already on transmission queue>,X)
	POPJ P,

; Compute time of next check (for retransmissions)
; Retransmission intervals start at the nominal interval
;  given by LH BSPTIM and double for each retransmission,
;  with a maximum given by the constant PRBINT (~15 seconds)
;	A/ Time of previous check
; Assumes port is locked and ac's setup
; Returns +1:  A/ Time of next check
; Generates timeout error if appropriate
; Clobbers A, B

NXTTIM:	SUB A,TODCLK		; Get -(now-then)
	MOVNS A			; Make positive
	PUSH P,A		; Save it
	LDB B,PBSTMO		; Get error timeout interval
	LSH B,^D12		; Convert to ms
	CAML A,B		; Too long?
	 PUSHJ P,BSPTMO		; Yes, signal timeout error
	POP P,A			; Recover interval
	ASH A,1			; Double it
	HLRZ B,BSPTIM(BSP)	; Get round trip delay
	LSH B,1			; Make retransmission timeout be double that
	CAIGE A,(B)		; Use whichever is greater
	 MOVEI A,(B)
	CAILE A,PRBINT		; But never greater than
	 MOVEI A,PRBINT		;  probe interval while idle
	ADD A,TODCLK		; Add offset to now
	POPJ P,



; Set timer for port
; Call after changing BSPDTM, BSPITM, or BSPFTM
; Returns +1
; Clobbers A-D

SETPTM:	PUSHJ P,DELTQP		; Delete from timer queue if on it
	MOVE A,BSPDTM(BSP)	; Get time to send next AData
	CAMLE A,BSPITM(BSP)	; Retransmit Interrupt sooner?
	 MOVE A,BSPITM(BSP)	; Yes, use it
	CAMLE A,BSPFTM(BSP)	; Check FSM sooner?
	 MOVE A,BSPFTM(BSP)	; Yes, use that
	PUSHJ P,ADDTQP		; Add port to timer queue
	POPJ P,



; Send a null AData (for probing)
;	BSP/ BSP data block ptr
; Returns +1 always
; Clobbers A-D, PB

SNDADA:	MOVEI B,MNPBLN		; Allocate minimum-length Pup
	PUSHJ P,ASGPKT
	 POPJ P,		; Can't, forget it
	MOVEI A,MNPLEN		; Set Pup Length
	DPB A,PUPLEN
	HRRZ A,BSPOQL(BSP)	; Get # of bytes queued
	ADD A,BSPOLW(BSP)	; Compute ID of first byte not sent
	LSH A,4			; Left-justify
	MOVEM A,PBHEAD+1(PB)	; Store ID in packet
	MOVEI A,PT.ADA		; Pup Type = AData
	PUSHJ P,SNDPUP		; Send it
	 CAI			; Ignore failure
	MOVE A,TODCLK		; Remember time of last AData
	MOVEM A,BSPATM(BSP)
	AOS BSPPPG(BSP)		; Count probe packets generated
	POPJ P,

; Send an Ack
;	UNIT/ Pup unit #
;	BSP/ BSP data block pointer
;	IOS/ BSPSTS(BSP)
; Returns +1 always
; Clobbers A-D, PB

SNDACK:	MOVEI B,PBHEAD+<MNPLEN+6+6*MXSACK+3>/4  ; Max-length Ack
	PUSHJ P,ASGPKT		; Assign packet buffer
	 JRST [	TLO IOS,(BSSAKF)  ; Failed, note ack still needed
		POPJ P,]

; Compute Pup ID for cumulative acknowledgement
	HRRZ A,BSPIQL(BSP)	; Get offset from left edge to hole
	ADD A,BSPILW(BSP)	; Compute ID of first hole
	LSH A,4			; Left-justify
	MOVEM A,PBHEAD+1(PB)	; Set Pup ID

; Setup the allocation block
	PUSH P,[POINT 16,PBCONT(PB)]  ; Init byte ptr into Pup
	LDB A,PBSIBP		; Get maximum bytes/Pup
	IDPB A,0(P)		; Store in Pup
	LDB A,PBSIAP		; Get maximum # Pups allowed
	HLRZ C,BSPIQL(BSP)	; Get # Pups already on queue
	SUBI A,(C)		; Compute remainder
	SKIPGE A		; Make sure positive
	 SETZ A,		; Make zero if negative
	IDPB A,0(P)		; Store # Pups allowed into Pup
	HRRZ B,BSPIAL(BSP)	; Get maximum # bytes allowed
	SUB B,BSPIQL(BSP)	; Subtract # bytes used
	TRNE B,400000		; Make sure positive
	 SETZ B,		; Make zero if negative
	IDPB B,0(P)		; Store # bytes allowed into Pup
	SKIPE A			; Sending zero # Pups allocation?
	 TRNN B,-1		; Sending zero # bytes allocation?
	 TLOA IOS,(BSZALF)	; Yes, remember we did this
	 TLZ IOS,(BSZALF)	; No, clear flag

IFG MXSACK,<		; Only if allowed to send specific Acks
; Specifically acknowledge Pups beyond first hole
; First, scan forward from tail to find first packet past hole
	MOVEI A,BSPIBQ(BSP)	; Get pointer to queue header
SNDAC2:	HLRZ A,0(A)		; Get predecessor
	CAIN A,BSPIBQ(BSP)	; Reached head?
	 JRST SNDAC3		; Yes
	MOVE B,PBHEAD+1-PBBSPQ(A)  ; No, get ID of this packet
	SUB B,PBHEAD+1(PB)	; Compare to ID of Ack
	JUMPGE B,SNDAC2		; Repeat if still beyond hole
SNDAC3:	HRRZ A,0(A)		; Ok, now get successor
	CAIN A,BSPIBQ(BSP)	; Make sure there is one
	 JRST SNDAC7		; No Pups to specifically ack

; Now A/ pointer to PBBSPQ of first Pup past hole.   Build PosAck blocks
	MOVSI D,-MXSACK		; Init max # of specific acks
SNDAC4:	HRRI D,(A)		; Save ptr to start of range
SNDAC5:	MOVE B,PBBSID-PBBSPQ(A)  ; Get ID right-justified
	ADD B,PBBSBC-PBBSPQ(A)	; Add number of bytes in packet
	LSH B,4			; Left-justify
	HRRZ A,0(A)		; Get successor
	CAIN A,BSPIBQ(BSP)	; Make sure there is one
	 JRST SNDAC6		; No, end of queue
	MOVE C,PBHEAD+1-PBBSPQ(A)  ; Yes, get its ID left-justified
	SUB C,B			; See if touch or overlap previous
	JUMPLE C,SNDAC5		; Loop if so, to combine ranges
SNDAC6:	SUB B,PBHEAD+1-PBBSPQ(D)  ; No, compute length of range
	LSH B,-4		; Right-justify
	IORI B,100000		; Set flag to note PosAck
	IDPB B,0(P)		; Store flag and # bytes in Pup
	MOVE B,PBBSID-PBBSPQ(D)	; Get starting ID right-justified
	ROT B,-^D16		; Right-justify high 16 bits
	IDPB B,0(P)		; Store in Pup
	ROT B,^D16		; Right-justify low 16 bits
	IDPB B,0(P)		; Store in Pup
	CAIE A,BSPIBQ(BSP)	; Reached end of queue?
	 AOBJN D,SNDAC4		; No, repeat if not past limit
; Still in IFG MXSACK conditional

; SNDACK (cont'd)

; Now finish up and send the Ack
SNDAC7:	POP P,A			; Restore byte pointer
	PUSHJ P,ENDPUP		; Compute length and trim packet
> ; End IFG MXSACK
IFE MXSACK,<
	SUB P,BHC##+1		; Flush byte ptr from stack
	MOVEI A,MNPLEN+6	; Constant if no specific acks
	DPB A,PUPLEN		; Store Pup Length
>
	MOVEI A,PT.ACK		; Pup type = "Ack"
	PUSHJ P,SNDPUP		; Setup header and send it
	 TLO IOS,(BSSAKF)	; Couldn't, note Ack still needed
	POPJ P,			; Done



; Compute Pup Length given byte pointer, and trim excess
;	A/ Byte ptr to last byte stored
;	PB/ Packet buffer ptr
; Returns +1 always
; Clobbers A-D

ENDPUP:	MOVEI B,@A		; Compute address of last word
	SUBI B,PBHEAD-1(PB)	; Compute # 36-bit words used
	LSH B,2			; Convert to bytes
	LSH A,-^D33		; Get bytes not used in last word
	SUBI B,(A)		; Compute Pup Length
	ADDI B,2		; Include checksum
	DPB B,PUPLEN		; Store it
	PUSHJ P,TRMUPB		; Trim excess from packet buffer
	POPJ P,



; Set up header and send Pup
;	A/ Pup Type to be stored in packet
;	PB/ Packet buffer pointer
;	UNIT/ Pup unit #
;	IOS/ BSPSTS(BSP)
; Caller is expected to setup Pup Length and ID
; A Pup once passed here is gone forever
; Returns +1:  Failed, packet buffer discarded
;	+2:  Succeeded, packet buffer queued for output
; Clobbers A-D

SNDPUP:	DPB A,PUPTYP		; Store Pup Type in packet
	PUSHJ P,SETPRT		; Set up source and dest ports

; Enter here if type and ports are already setup
SNDPU1:	SETZB A,PBBSPQ(PB)	; Clear BSP queue linkages
	DPB A,PUPTCB		; Zero out Transport Control byte
	PUSHJ P,SETCHK		; Set Pup Checksum appropriately
	PUSHJ P,PUTPUP		; Queue Pup for output
	 BUG(DPR,<SNDPUP: Output queue overflowed>,X)
	JRST SKPRET##		; Done, skip return

; Set up Source and Destination Ports in Pup
;	PB/ Packet buffer pointer
;	UNIT/ Pup unit #
; Returns +1 always

SETPRT:	SKIPN C,PUPFPT(UNIT)	; Get foreign port descriptor
	 BUG(HLT,<SETPRT: Attempt to send Pup to wildcard port>)
	MOVE A,1(C)		; Get destination net,,host
	MOVE B,2(C)		; Get destination socket
	LSH B,4			; Left-justify socket
	LSHC A,-8		; Concatenate host and socket
	LSH A,-^D10		; Right-justify net
	LSHC A,-8		; Concatenate net/host/high socket
	MOVEM B,PBHEAD+2(PB)	; Store dest net/host/high socket
	MOVE A,2(C)		; Get dest socket again
	MOVE B,PUPLNH(UNIT)	; Get local net/host left-justified
	LSHC A,-^D16		; Concatenate low dest socket to it
	MOVEM B,PBHEAD+3(PB)	; Store source net/host, high dest socket
	MOVE A,PUPLSK(UNIT)	; Get local socket
	LSH A,4			; Left-justify
	MOVEM A,PBHEAD+4(PB)	; Store source socket in PB
	POPJ P,


; Set Pup Checksum appropriately
;	PB/ Packet buffer pointer
;	IOS/ BSPSTS(BSP)
; Returns +1 always
; Clobbers A-D

SETCHK:	TLNN IOS,(BSNCHK)	; Checksumming inhibited?
	 JRST SETCKS		; No, compute and set checksum
	PUSHJ P,GPTCKS		; Yes, get ptr to checksum field
	SETO A,			; Deposit nil checksum
	DPB A,B
	POPJ P,



; Compare sequence number intervals
;	A/ Left edge of interval 1
;	B/ Length of interval 1
;	C/ Left edge of interval 2
;	D/ Length of interval 2
; Returns +1:  Intervals are identical
;	+2:  Interval 1 is a subinterval of 2
;	+3:  Interval 2 is a subinterval of 1
;	+4:  Intervals intersect but neither contains the other
;	+5:  Intervals are disjoint
; Clobbers A, C

CMPIVL:	SUBM C,A		; A _ (L2 - L1) mod 2^32
	TLZ A,(-1B3)
	MOVN C,A		; C _ (L1 - L2) mod 2^32
	TLZ C,(-1B3)
	CAMN B,D		; Lengths same?
	 JUMPE A,CPOPJ##	; Yes, return +1 if left edges same
	CAMGE A,B		; Check for overlaps
	 JRST CMPIV1		; Overlap, maybe 2 subinterval of 1
	CAMGE C,D
	 JRST CMPIV2		; Overlap, maybe 1 subinterval of 2
	POP P,A			; No overlap, return +5
	JRST 4(A)

; Here on overlap with possibility of 2 being a subinterval of 1
CMPIV1:	ADD A,D			; Add 2's size to its offset from 1
	CAMLE A,B		; 2 completely contained by 1?
	 JRST SK3RET##		; No, return +4
	JRST SK2RET##		; Yes, return +3

; Here on overlap with possibility of 1 being a subinterval of 2
CMPIV2:	ADD C,B			; Add 1's size to its offset from 2
	CAMLE C,D		; 1 completely contained by 2?
	 JRST SK3RET##		; No, return +4
	JRST SKPRET##		; Yes, return +2

; Flush all packets from BSP queues
; Assumes port is locked
; Returns +1 always
; Clobbers A-D, PB

FLSBSQ:	HLRZ PB,BSPCUR(BSP)	; Delete current input PB if any
	SKIPE PB
	 PUSHJ P,RELPKT
	HRRZ PB,BSPCUR(BSP)	; Delete current output PB if any
	SKIPE PB
	 PUSHJ P,RELPKT
	SETZM BSPCUR(BSP)	; Mark no current PB's
FLSBS1:	HRRZ A,BSPIBQ(BSP)	; Get head of BSP input queue
	CAIN A,BSPIBQ(BSP)	; Empty?
	 JRST FLSBS2		; Yes
	MOVEI PB,-PBBSPQ(A)	; No, get ptr to head of PB
	PUSHJ P,DELBIQ		; Delete from queue
	JRST FLSBS1		; Repeat until empty
FLSBS2:	HRRZ A,BSPOBQ(BSP)	; Get head of BSP output queue
	CAIN A,BSPOBQ(BSP)	; Empty?
	 JRST FLSBS3		; Yes
	MOVEI PB,-PBBSPQ(A)	; No, get ptr to head of PB
	PUSHJ P,DELBOQ		; Delete from queue
	JRST FLSBS2		; Repeat until empty
FLSBS3:	SKIPGE PB,BSPSII(BSP)	; Have pending send Interrupt?
	 PUSHJ P,DELOBQ		; Yes, release PB
	SETZM BSPSII(BSP)	; Clear pointer
	HRRZ PB,BSPTIM(BSP)	; Have a saved Abort packet?
	SKIPE PB
	 PUSHJ P,RELPKT		; Yes, release it
	HLLZS BSPTIM(BSP)	; Clear pointer
	POPJ P,


; Delete Pup from BSP input queue
;	PB/ Packet buffer ptr
; Assumes port is locked
; Returns +1, releases packet buffer, updates Pup count
; Clobbers A-D

DELBIQ:	MOVEI A,PBBSPQ(PB)	; Make ptr to link word
	PUSHJ P,DELITQ		; Delete item from queue
	PUSHJ P,RELPKT		; Release packet buffer
	MOVSI A,-1		; Decrement # Pups in BSP queue
	ADDB A,BSPIQL(BSP)
	SKIPGE A		; Check for over-decrementing
	 BUG(CHK,<DELBIQ: Over-decrementing BSP input count>)
	POPJ P,


; Delete Pup from BSP output queue
;	PB/ Packet buffer ptr
; Assumes port is locked
; Returns +1, releases packet buffer, updates Pup count
; Clobbers A-D

DELBOQ:	HLRZ A,PBBSPQ(PB)	; Get predecessor
	HRRZ B,PBBSPQ(PB)	; Get successor
	HRLM A,(B)		; Fix links between predecessor
	HRRM B,(A)		;  and successor
	PUSHJ P,DELOBQ		; Remove from PUPOBQ if on it
	MOVSI A,-1		; Decrement # Pups in BSP queue
	ADDB A,BSPOQL(BSP)
	SKIPGE A		; Check for over-decrementing
	 BUG(CHK,<DELBOQ: Over-decrementing BSP output count>)
	POPJ P,

; Routines to lock/unlock BSP port
; Note:  While a port is locked, the up-to-date flags are
;  carried in IOS, and are stored in PUPSTS(UNIT) when the
;  port is unlocked.  Exception:  the BSWAKF flag is always
;  updated in core (while the port is locked by someone else).


; Lock port iff it is a BSP port
;	UNIT/ Pup unit #
; Returns +1:  Not a BSP port, BSP/ 0
;	+2:  Port locked,
;	BSP/ BSP data block pointer
;	IOS/ PUPSTS(UNIT)
; Clobbers nothing else

LCKBSQ:	HRRZ BSP,PUPLNH(UNIT)	; Get BSP linkage
	JUMPE BSP,CPOPJ##	; Return +1 if not BSP port
	AOS 0(P)		; Ok, preset skip return


; Lock BSP port (wait if already locked)
;	UNIT/ Pup unit #
; Returns +1 always:
;	BSP/ BSP data block pointer
;	IOS/ PUPSTS(UNIT)
; Clobbers nothing else

LCKBSP:	LOCK(PRTLCK,,SPQ)	; Lock out changes to port table
	PUSHJ P,LCKBSA		; Attempt to lock port
	 JRST [	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Can't, unlock table
		PUSH P,A	; Save an ac
		MOVSI A,(UNIT)	; Set scheduler test
		HRRI A,BSLCKT
		JSYS EDISMS##	; Wait until port unlocked
		POP P,A
		JRST LCKBSP]	; Try again to lock
	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Ok, unlock table
	POPJ P,			; Return

USE RESPC

; Scheduler test for BSP port unlocked
; Arg is Pup unit #

BSLCKT:	MOVSI B,(BSLCKF)	; Flag to test
	TDNE B,PUPSTS(A)	; Locked?
	 JRST 0(D)		; Yes, wait
	JRST 1(D)		; Unlocked, wakeup

USE SWAPPC


; Attempt to lock BSP port
; PRTLCK must be locked by caller
;	UNIT/ Pup unit #
; Returns +1: Failed, already locked, IOS clobbered
;	+2: Ok, we have locked it:
;		BSP/ BSP data block pointer
;		IOS/ PUPSTS(UNIT)
; Clobbers nothing else

LCKBSA:	HRRZ BSP,PUPLNH(UNIT)	; Get linkage
	SKIPN BSP		; Make sure have BSP port
	 BUG(HLT,<LCKBSA: Attempt to lock non-BSP port>)
	MOVSI IOS,(BSLCKF)	; Flag to test
	TDNE IOS,PUPSTS(UNIT)	; Already locked?
	 POPJ P,		; Yes, fail
	IORB IOS,PUPSTS(UNIT)	; Lock port, setup IOS
	JRST SKPRET##		; Give success return

; Unlock port iff it is a BSP port
;	UNIT/ Pup unit #
;	BSP/ BSP data block pointer (0 if none, see LCKBSQ)
;	IOS/ Status
; Returns +1, Clobbers nothing

ULKBSQ:	JUMPE BSP,CPOPJ##	; Do nothing if not BSP port


; Unlock BSP port
;	UNIT/ Pup unit #
;	IOS/ Status
; Returns +1, Clobbers nothing

ULKBSP:	TLZN IOS,(BSLCKF)	; Clear BSP lock bit
	 BUG(HLT,<ULKBSP: Attempt to unlock port not locked>)
	EXCH IOS,PUPSTS(UNIT)	; Store updated status word
	AND IOS,[BSWAKF]	; If wakeup pending,
	IORB IOS,PUPSTS(UNIT)	;  be sure bit stays on
	POPJ P,



; Generate BSP error timeout
; Assumes port is locked and ac's setup
; Returns +1
; Clobbers A, B

BSPTMO:	TLON IOS,(BSTIMF)	; Ignore if already timed out
	 PUSHJ P,PUPSTC		; Generate state change interrupt
	POPJ P,



; Awaken BSP input if necessary
; Assumes port is locked and ac's setup
; Returns +1
; Clobbers A, B

WAKBSI:	TLO IOS,(BSINPF)	; Flag input possible now
	HRRE B,PUPPSI(UNIT)	; Get port owner
	AOJGE B,CPOPJ##		; Done if unassigned or assigned to fork
	SIGPBP(NVT)		; Request NVT scan
	POPJ P,


; Awaken BSP output if necessary
; Assumes port is locked and ac's setup
; Returns +1
; Clobbers A, B

WAKBSO:	TLO IOS,(BSOUTF)	; Flag output possible now
	HRRE B,PUPPSI(UNIT)	; Get port owner
	AOJGE B,CPOPJ##		; Done if unassigned or assigned to fork
	MOVEI B,-400001(B)	; Assigned to NVT, get TTY #
	SIGPBP(NVT,<SKIPG TTOCT##(B)  ; Request NVT scan
		SKIPLE TTECT##(B)>)  ;  if output or echo waiting
	POPJ P,

; Build BSP data block
; Returns +1:  Failed (no room)
;	+2:  Ok, BSP/ pointer to block
; Clobbers A-D, BSP

BLDBSP:	MOVEI B,BSPSIZ		; Size of BSP data block
	PUSHJ P,ASGPFR		; Allocate a block
	 POPJ P,		; Can't, fail
	MOVEI BSP,(A)		; Ok, put ptr in standard ac
	AOS 0(P)		; Preset skip, fall into INIBSP


; Initialize BSP data block
;	BSP/ Data block ptr
; Returns +1 always
; Clobbers A, B

INIBSP:	MOVSI A,-BSPSIZ		; Set AOBJN ptr
	HRLI BSP,A		; Set index register for store
INIBS1:	XCT IBSTAB(A)		; Get an initial value
	MOVEM B,@BSP		; Store in block
	AOBJN A,INIBS1		; Repeat for all
	POPJ P,

; Initialization table
; Each entry loads B with the corresponding initial value

DEFINE X(LOC,INST) <
IFL LOC-<.-IBSTAB>,<PRINTX ?IBSTAB entries out of order>
REPEAT LOC-<.-IBSTAB>,<SETZ B,>
	INST
>

IBSTAB:	X BSPHDR,<MOVE B,[<DETINT*^D1000/10000>B15+BSPSIZ]>
	X BSPTIM,<MOVSI B,RETINT>
	X BSPACT,<MOVE B,TODCLK>
	X BSPDTM,<HRLOI B,377777>
	X BSPITM,<HRLOI B,377777>
	X BSPFTM,<HRLOI B,377777>
	X BSPSTM,<MOVE B,TODCLK>
	X BSPIBQ,<PUSHJ P,INIBSQ>
	X BSPOBQ,<PUSHJ P,INIBSQ>
	X BSPCID,<SETO B,>
	X BSPIAL,<MOVE B,[<MXBSIP>B7+<MXPLEN-MNPLEN>B17+MXBSIB]>
	X BSPSIZ,<>

INIBSQ:	MOVEI B,@BSP
	HRLI B,(B)
	POPJ P,

; -----------------------------------------------------------------
;	Pup Finite State Machine (rendezvous, termination)
; -----------------------------------------------------------------

USE SWAPPC


; Port states

S.CLOS==0	; Closed
S.RFCO==1	; RFC Outstanding
S.LIST==2	; Listening
S.OPEN==3	; Open
S.ENDI==4	; End In
S.ENDO==5	; End Outstanding
S.DALY==6	; Dallying
S.ABOR==7	; Abort

NPSTAT==10	; Number of states
ALLSTT==-1B<NPSTAT-1>  ; Bit mask corresponding to all states


; Events

E.OPNC==0	; OPENF mode 0 or 1 (connect)
E.OPNL==1	; OPENF mode 2 or 3 (listen)
E.OPNN==2	; OPENF mode 4 (no rendezvous)
E.CLSN==3	; Normal CLOSF
E.CLST==4	; CLOSF after timeout
E.RRFC==5	; Received RFC
E.RABT==6	; Received Abort
E.REND==7	; Received End
E.RENR==10	; Received End Reply
E.TIMO==11	; Timeout (for retransmissions)


; Actions

A.NOOP==0	; No action
A.SRF1==1	; Send RFC (initiate connection)
A.SRF2==2	; Send RFC (respond to incoming RFC)
A.OPNC==3	; Open connection
A.SEND==4	; Send End
A.SENR==5	; Send End Reply
A.SABT==6	; Send Abort
A.LERR==7	; Local error (improper locally-generated event)
A.FERR==10	; Foreign error (improper Pup type received)


A.==<S.==0>	; For unused fields in action/transition matrices

; Routines to generate events
; All assume the port is locked and ac's UNIT, BSP, IOS setup.
; If the event is generated by an incoming Pup, PB points to the
;  packet buffer.


; Routine called from DOBSPI upon receipt of an RFC
;	PB/ Packet buffer pointer
; Returns +1 always
; Clobbers A-D, releases packet buffer always

RCVRFC:	LDB A,PUPLEN		; Get Pup Length
	CAIGE A,MNPLEN+6	; Make sure big enough
	 BUG(DPR,<RCVRFC: Pup too small>,X)
	PUSHJ P,GTCPRT		; Get Connection Port
	 BUG(DPR,<RCVRFC: RFC with improper Connection port>,X)
	LDB D,PBSSTT		; Get current port state
	CAIN D,S.RFCO		; RFC Out?
	 JRST RCVRF1		; Yes
	CAIN D,S.LIST		; Listening?
	 JRST RCVRF2		; Yes

; Open (or End Out), probably a retransmission
	PUSHJ P,CHKSR1		; See if matches foreign port
	 BUG(DPR,<RCVRFC: RFC with non-matching Connection Port>,X)
	MOVE A,PBHEAD+1(PB)	; Get Pup ID
	LSH A,-4		; Right-justify
	CAME A,BSPCID(BSP)	; Compare to Connection ID
	 BUG(DPR,<RCVRFC: RFC with incorrect ID>,X)
	TLNN IOS,(BSLISF)	; Formerly in listening state?
	 JRST RCVRF4		; No, discard packet and ignore
	JRST RCVRF3		; Yes, go generate event

; RFC Out, ID must match our Connection ID
RCVRF1:	MOVE A,PBHEAD+1(PB)	; Get Pup ID
	LSH A,-4		; Right-justify
	CAME A,BSPCID(BSP)	; Compare to Connection ID
	 BUG(DPR,<RCVRFC: RFC with incorrect ID>,X)

; Listening or RFC Out, Source Port must pass address filter
RCVRF2:	PUSHJ P,CHKSRC		; Check Source Port
	 BUG(DPR,<RCVRFC: RFC from incorrect Source Port>,X)
RCVRF3:	MOVEI A,E.RRFC		; Ok, generate Received RFC event
	PUSHJ P,PUPFSM
RCVRF4:	PUSHJ P,RELPKT		; Release packet buffer
	POPJ P,

; Routine called from DOBSPI upon receipt of an End
;	PB/ Packet buffer pointer
; Returns +1 always
; Clobbers A-D, releases packet buffer always

RCVEND:	MOVEI A,E.REND		; Generate Received End event
	JRST RCVEN1

; Routine called from DOBSPI upon receipt of an End Reply
;	PB/ Packet buffer pointer
; Returns +1 always
; Clobbers A-D, releases packet buffer always

RCVENR:	MOVEI A,E.RENR		; Generate Received End Reply event
RCVEN1:	PUSHJ P,PUPFSM
	PUSHJ P,RELPKT		; Release packet buffer
	POPJ P,


; Routine called from DOBSPI upon receipt of an Abort
;	PB/ Packet buffer pointer
; Returns +1 always
; Clobbers A-D, disposes of packet buffer always

RCVABT:	MOVEI A,E.RABT		; Generate Received Abort event
	PUSHJ P,PUPFSM
	HRRZ A,BSPTIM(BSP)	; See if already have Abort packet
	JUMPN A,RELPKT		; If so, just discard this
	HRRM PB,BSPTIM(BSP)	; Don't have one, store this
	POPJ P,

; Routine to step FSM for port
;	A/ Event number
;	C, D/ Arguments for action routine, if appropriate
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
;	IOS/ Port status word
;	PB/ Pointer to incoming packet, if any
; Returns +1
; Clobbers A-D, updates others where appropriate

PUPFSM:	PUSHJ P,PUPFSC		; Do the work
	PUSHJ P,SETPTM		; Set timer appropriately
	POPJ P,

; Enter here from DOBSP only
PUPFSC:	HRLM A,0(P)		; Save event number
	PUSH P,PB		; Save packet buffer ptr if any
	LDB B,PBSSTT		; Get current port state
	LDB A,PFSACT(B)		; Get action index
	XCT EVNACT(A)		; Do action associated with event
	HLRZ A,-1(P)		; Recover event number
	LDB B,PBSSTT		; Get current port state
	LDB A,PFSTRN(B)		; Get successor from transition tbl
	DPB A,PBSSTT		; Store in port status word
	DPB A,PBSSTM		; Store in memory also
	CAIE A,S.CLOS		; Entering Closed or Abort state?
	 CAIN A,S.ABOR
	 TLO IOS,(BSERRF)	; Yes, signal bad state for BSP
	CAIN A,(B)		; State changed?
	 JRST PUPFS2		; No
	MOVE B,TODCLK		; Yes, record time of state change
	MOVEM B,BSPSTM(BSP)
	CAIE A,S.OPEN		; Entering Open state?
	 JRST PUPFS1		; No
	MOVEM B,BSPDTM(BSP)	; Yes, activate data probing
	MOVEM B,BSPATM(BSP)
PUPFS1:	PUSHJ P,PUPSTC		; Generate state change psi
PUPFS2:	POP P,PB		; Restore packet buffer ptr
	LDB A,PBSSTT		; Get new state
	CAIE A,S.RFCO		; RFC or End Outstanding?
	 CAIN A,S.ENDO
	 JRST [	MOVE A,BSPSTM(BSP)  ; Yes, get time of last state change
		PUSHJ P,NXTTIM	; Compute time for next check
		JRST PUPFS3]	; Go set it
	CAIN A,S.DALY		; No, dallying?
	 JRST [	HLRZ A,BSPTIM(BSP)  ; Yes, get retransmission timeout
		IMULI A,5	; Dally this long
		ADD A,TODCLK	; Compute time of next check
		JRST PUPFS3]	; Go set it
	HRLOI A,377777		; Set timer to infinity for other states
PUPFS3:	MOVEM A,BSPFTM(BSP)	; Store time of next check
	POPJ P,


; Byte pointers for accessing action and transition tables
; Indexed by current state #, expects event # in A

PFSACT:
REPEAT NPSTAT,<
	POINT 4,FSMACT(A),4*<.-PFSACT>+3
>


PFSTRN:
REPEAT NPSTAT,<
	POINT 4,FSMTRN(A),4*<.-PFSTRN>+3
>

; Action table
; Event yields row, current state yields column

DEFINE XX ($1,$2,$3,$4,$5,$6,$7,$8,$9) <
	BYTE(4) A.'$1, A.'$2, A.'$3, A.'$4, A.'$5, A.'$6, A.'$7, A.'$8, A.'$9
>

; Current state						; Event
;	   CLOS RFCO LIST OPEN ENDI ENDO DALY ABOR

FSMACT:	XX SRF1,LERR,LERR,LERR,LERR,LERR,LERR,LERR	; OPNC
	XX NOOP,LERR,LERR,LERR,LERR,LERR,LERR,LERR	; OPNL
	XX NOOP,LERR,LERR,LERR,LERR,LERR,LERR,LERR	; OPNN
	XX NOOP,SABT,NOOP,SEND,SENR,NOOP,NOOP,NOOP	; CLSN
	XX NOOP,SABT,NOOP,SABT,SABT,SABT,NOOP,NOOP	; CLST
	XX FERR,OPNC,SRF2,SRF2,FERR,SRF2,FERR,FERR	; RRFC
	XX FERR,NOOP,FERR,NOOP,NOOP,NOOP,NOOP,NOOP	; RABT
	XX FERR,FERR,FERR,NOOP,NOOP,SENR,SENR,FERR	; REND
	XX FERR,FERR,FERR,FERR,FERR,SENR,NOOP,FERR	; RENR
	XX NOOP,SRF1,NOOP,NOOP,NOOP,SEND,NOOP,NOOP	; TIMO


; Transition table
; Event yields row, current state yields column

DEFINE XX ($1,$2,$3,$4,$5,$6,$7,$8,$9) <
	BYTE(4) S.'$1, S.'$2, S.'$3, S.'$4, S.'$5, S.'$6, S.'$7, S.'$8, S.'$9
>

; Current state						; Event
;	   CLOS RFCO LIST OPEN ENDI ENDO DALY ABOR

FSMTRN:	XX RFCO,RFCO,LIST,OPEN,ENDI,ENDO,DALY,ABOR	; OPNC
	XX LIST,RFCO,LIST,OPEN,ENDI,ENDO,DALY,ABOR	; OPNL
	XX OPEN,RFCO,LIST,OPEN,ENDI,ENDO,DALY,ABOR	; OPNN
	XX CLOS,CLOS,CLOS,ENDO,DALY,ENDO,DALY,CLOS	; CLSN
	XX CLOS,CLOS,CLOS,CLOS,CLOS,CLOS,CLOS,CLOS	; CLST
	XX CLOS,OPEN,OPEN,OPEN,ENDI,ENDO,DALY,ABOR	; RRFC
	XX CLOS,ABOR,LIST,ABOR,ABOR,ABOR,ABOR,ABOR	; RABT
	XX CLOS,RFCO,LIST,ENDI,ENDI,DALY,DALY,ABOR	; REND
	XX CLOS,RFCO,LIST,OPEN,ENDI,CLOS,CLOS,ABOR	; RENR
	XX CLOS,RFCO,LIST,OPEN,ENDI,ENDO,CLOS,ABOR	; TIMO


; Table of actions in event/action matrix

EVNACT:	CAI			; NOOP - No action
	PUSHJ P,SNDIRF		; SRF1 - Send initiating RFC
	PUSHJ P,SNDARF		; SRF2 - Send answering RFC
	PUSHJ P,OPNCON		; OPNC - Open connection
	PUSHJ P,SNDEND		; SEND - Send End
	PUSHJ P,SNDENR		; SENR - Send End Reply
	PUSHJ P,ABORT		; SABT - Send Abort
	PUSHJ P,LCLERR		; LERR - Local error
	PUSHJ P,FORERR		; FERR - Foreign error

; Action routines
; All have the following calling sequence:
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
;	IOS/ BSP status
;	PB/ Pointer to received packet buffer, if appropriate
; Returns +1 always
; May clobber A-D, PB


; Send initiating RFC

SNDIRF:	MOVEI B,PBHEAD+<MNPLEN+6+3>/4
	PUSHJ P,ASGPKT		; Allocate packet buffer for RFC
	 POPJ P,		; Failed, forget it
	MOVEI A,MNPLEN+6	; Set Pup Length
	DPB A,PUPLEN
	SKIPL A,BSPCID(BSP)	; Connection ID already assigned?
	 JRST SNDIR1		; Yes, use it (retransmission)
	MOVE A,TODCLK		; No, get now in milliseconds
	LSH A,7			; Convert to units of ~8 usec
	PUSHJ P,SETCID		; Set Connection ID
SNDIR1:	LSH A,4			; Left-justify
	MOVEM A,PBHEAD+1(PB)	; Set Pup ID
	PUSHJ P,STCPRT		; Set Connection Port = local port
	MOVEI A,PT.RFC		; Type = RFC
	PUSHJ P,SNDPUP		; Finish up and send the Pup
	 CAI			; Ignore failure
	POPJ P,


; Send answering RFC

SNDARF:	SKIPL BSPCID(BSP)	; Connection parameters already set?
	 JRST SNDAR1		; Yes, bypass this
	MOVE A,PBHEAD+1(PB)	; Get Pup ID from incoming RFC
	LSH A,-4		; Right-justify
	PUSHJ P,SETCID		; Set Connection ID
	LDB A,PPUPDN		; Copy Destination net/host to
	DPB A,PPRTLN		;  local net/host in case wildcard
	LDB A,PPUPDH
	DPB A,PPRTLH
	PUSHJ P,OPNCON		; Set foreign port for connection
SNDAR1:	HRLM PB,0(P)		; Save ptr to received RFC
	MOVEI B,PBHEAD+<MNPLEN+6+3>/4
	PUSHJ P,ASGPKT		; Allocate packet buffer for reply
	 POPJ P,		; Failed, forget it
	HLRZ A,0(P)		; Ok, recover ptr to received RFC
	MOVSI A,PBHEAD(A)	; Copy the header
	HRRI A,PBHEAD(PB)	;  into the answering RFC
	BLT A,PBCONT-1(PB)
	PUSHJ P,SWPPRT		; Swap source and dest ports in RFC
	PUSHJ P,STCPRT		; Set Connection Port = local port
	PUSHJ P,SNDPU1		; Finish up and send the Pup
	 CAI			; Ignore failure
	POPJ P,


; Open connection in response to answering RFC

OPNCON:	PUSHJ P,GTCPRT		; Get Connection Port from RFC
	 BUG(HLT,<OPNCON: GTCPRT failed unaccountably>)
	PUSHJ P,STFPRT		; Set foreign port for connection
	POPJ P,

; Action routines (cont'd)

; Send End

SNDEND:	MOVEI A,PT.END		; Type = End
	JRST SNDEN1		; Jump to common code


; Send End Reply

SNDENR:	MOVEI A,PT.ENR		; Type = End Reply
SNDEN1:	HRLM A,0(P)		; Save type
	MOVEI B,MNPBLN		; Minimum length
	PUSHJ P,ASGPKT		; Allocate packet buffer
	 POPJ P,		; Failed, forget it
	MOVEI A,MNPLEN		; Set Pup Length
	DPB A,PUPLEN
	MOVE A,BSPCID(BSP)	; Get Connection ID
	LSH A,4			; Left-justify
	MOVEM A,PBHEAD+1(PB)	; Set Pup ID
	HLRZ A,0(P)		; Recover Pup Type
	PUSHJ P,SNDPUP		; Finish up and send the Pup
	 CAI			; Ignore failure
	POPJ P,


; Send Abort
;	C/ Abort Code (B0 set => call from monitor)
;	D/ If nonzero, string ptr to Abort Text in caller space

ABORT:	MOVE A,C		; Copy args to proper ac's
	MOVE B,D
	PUSHJ P,SNDABT		; Build and send the Abort
	POPJ P,



; Signal local error

LCLERR:	BUG(CHK,<PUPFSM: Improper port state for local event>)
	POPJ P,



; Signal foreign error

FORERR:	BUG(PUP,<PUPFSM: Improper port state for received Pup>,X)
	POPJ P,


; Get Connection Port parameters from RFC Pup
;	PB/ Packet buffer pointer
; Returns +1:  Error, illegal address
;	+2:  Ok,  A/ Net, B/ Host, C/ Socket, right-justified

GTCPRT:	MOVE A,PBCONT(PB)	; Get net/host/high socket
	LSHC A,-^D28		; Right-justify net
	LSH B,-^D12		; Right-justify host/high socket
	MOVE C,PBCONT+1(PB)	; Get low socket
	LSHC B,-^D16		; Right-justify host
	LSH C,-4		; Concatenate, right-justify socket
	SKIPN A			; Net specified?
	 LDB A,PPUPSN		; No, assume same as Rendezvous
	JUMPE B,CPOPJ##		; Error if zero host
	JUMPE C,CPOPJ##		; Error if zero socket
	JRST SKPRET##		; Ok, take success return


; Set Connection Port = local port in outgoing RFC
;	PB/ Packet buffer pointer
;	UNIT/ Pup unit #
; Returns +1 always
; Clobbers A

STCPRT:	HLLZ A,PUPLNH(UNIT)	; Get local net/host
	TLNE A,(377B7)		; Make sure fully specified
	TLNN A,(377B15)
	 BUG(HLT,<STCPRT: Called for wildcard local port>)
	MOVEM A,PBCONT(PB)	; Store in Connection Port field
	MOVE A,PUPLSK(UNIT)	; Get local socket
	ROT A,-^D16		; Right-justify high 16 bits
	DPB A,[POINT 16,PBCONT(PB),31]  ; Store in the RFC
	MOVEM A,PBCONT+1(PB)	; Store low 16 bits
	POPJ P,


; Store foreign connection port
;	A/ Net, B/ Host, C/ Socket, right-justified
; Assumes port is locked
; Returns +1
; Clobbers A-D

STFPRT:	SKIPN D,PUPFPT(UNIT)	; Get address table
	 BUG(HLT,<STFPRT: No address table assigned>)
	HRLM A,1(D)		; Store foreign address in table
	HRRM B,1(D)
	MOVEM C,2(D)
	HRLI D,-2		; Now just one address in table
	MOVEM D,PUPFPT(UNIT)
	MOVEI A,0(D)		; Copy pointer to block
	MOVEI B,3		; New size of block
	PUSHJ P,TRMPFR		; Trim it
	POPJ P,


; Set Connection ID
;	A/ Connection ID, right-justified
; Assumes port is locked
; Returns +1

SETCID:	TLZ A,(-1B3)		; Truncate to 32 bits
	MOVEM A,BSPCID(BSP)	; Set Connection ID
	MOVEM A,BSPILW(BSP)	; Init input Byte ID
	MOVEM A,BSPOLW(BSP)	; Init output Byte ID
	MOVEM A,BSPRII(BSP)	; Init receive Interrupt ID
	MOVEM A,BSPSII(BSP)	; Init send Interrupt ID
	POPJ P,

; Generate Pup state change interrupt
;	A/ New state
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
; Returns +1 always
; Clobbers A, B

PUPSTC:	HRRE B,PUPPSI(UNIT)	; Get port owner
	JUMPL B,PUPST1		; Jump if not fork
	LDB A,STCPSI		; Get state change PSI channel
	CAIGE A,^D36		; Assigned?
	 PUSHJ P,PSIRQF##	; Yes, initiate PSI
PUPST1:	PUSHJ P,WAKBSI		; Awaken fork or NVT processor
	POPJ P,



; Setup to wait for port to enter a specified state (or time out)
;	A/ Bit mask of desired state(s) [STTBTS macro]
; Assumes port is locked
; Returns +1:  Port not yet in specified state, A/ EDISMS argument
;	+2:  Port already in specified state
; Clobbers A, B

WATSTT:	LDB B,PBSSTT		; Get current state
	TDNN A,BITS##(B)	; Already in specified state?
	 TLNE IOS,(BSTIMF)	; Timed out?
	 JRST SKPRET##		; Yes, give skip return
	HRRI A,STTTST		; No, set scheduler test
	TLO A,(UNIT)		; Set Pup unit index
	POPJ P,			; Non-skip return

USE RESPC

; Scheduler test for entering specified state(s)
; Arg is state bit mask in B18-26, Pup unit # in B27-35

STTTST:	MOVSI B,(A)		; Copy bit mask
	ANDI A,777		; Isolate Pup unit #
	MOVE C,PUPSTS(A)	; Get status word
	LDB A,PBSSTA		; Get port state
	TDNN B,BITS##(A)	; Now in specified state(s)?
	 TLNE C,(BSTIMF)	; Timeout?
	 JRST 1(D)		; Yes, wakeup
	JRST 0(D)		; No, wait

USE SWAPPC

; -----------------------------------------------------------------
;	Pup NVT handling
; -----------------------------------------------------------------

USE SWAPPC

; Background routine to scan for Pup NVT input/output

BSPNVT:	LOCK NVTLCK		; No messing with table
	MOVEI B,PUPLO		; Set to first Pup NVT
BSPNV1:	SKIPGE UNIT,TTYPUP(B)	; Assigned?
	 SKIPGE IOS,PUPSTS(UNIT)  ; Yes, port unlocked?
	 JRST BSPNV2		; No
	SKIPN TTOCT##(B)	; Yes, output ready?
	 SKIPE TTECT##(B)	; Or echo ready?
	 TLNN IOS,(BSOUTF)	; Yes, output possible?
	 TLNE IOS,(BSINPF+BSTIMF+BSERRF)  ; Input available or error?
	 PUSHJ P,DONVTP		; One of those, service this NVT
BSPNV2:	CAIGE B,PUPHI		; Last NVT?
	 AOJA B,BSPNV1		; No, on to next
	UNLOCK NVTLCK
	POPJ P,			; Yes, done


; Do Pup NVT processing for one line
;	B/ TTY Line #
;	UNIT/ Pup unit #
; Returns +1 always
; Clobbers A, C, D, BSP, IOS;  preserves B

DONVTP:	LOCK PRTLCK		; Lock out changes to port table
	PUSHJ P,LCKBSA		; Attempt to lock the port
	 JRST [	UNLOCK PRTLCK	; Failed, forget it
		POPJ P,]
	UNLOCK PRTLCK		; Ok, unlock table
	TLNE IOS,(BSERRF+BSTIMF)  ; Errors?
	 JRST DONVTE		; Yes, go handle

; Note that doing input first and then output generally ensures
;  that echos will be transmitted immediately
	TLNE IOS,(BSINPF)	; Input pending?
	 PUSHJ P,DONVTI		; Yes, process it
	SKIPN TTOCT##(B)	; Output pending?
	 SKIPE TTECT##(B)	; Echo pending?
	 PUSHJ P,DONVTO		; Yes, process it

	LDB A,PBSSTT		; Get current port state
	CAIN A,S.OPEN		; Still open?
	 JRST ULKBSP		; Yes, just unlock port and return

; Here if port no longer open or timed out, kill the connection
DONVTE:	PUSHJ P,CLPNVT		; Initiate close of connection
	 PUSHJ P,ULKBSP		; Have to wait, unlock port and quit
	POPJ P,			; Connection gone, no need to unlock

; Process NVT input
;	B/ TTY Line #
;	UNIT/ Pup unit #
; Assumes port is locked
; Returns +1 always
; Clobbers A, C, D, PB;  preserves B

DONVTI:	LDB A,PNVSTT		; Get current NVT input state
	JRST @NVTSTD(A)		; Dispatch on state

; Dispatch table for current NVT state
NVTSTD:	NVTDAT		; (0) Normal data
	NVTMRK		; (1) Mark pending
	NVTSYN		; (2) Sync in progress

; Dispatched-to code should jump to one of these labels when
;  it can't do any more processing
NVTST0:	JSP A,DONVTX		; Set state to 0 (normal data)
NVTST1:	JSP A,DONVTX		; Set state to 1 (Mark pending)
NVTST2:	JSP A,DONVTX		; Set state to 2 (Sync in progress)

DONVTX:	SUBI A,NVTST0+1		; Convert pc to state index
	DPB A,PNVSTT		; Store new state
	POPJ P,			; Return from DONVTI


; Dispatch here to process normal data
NVTDAT:	LDB A,TTIMAX##		; Get capacity of line
	CAMG A,TTICT##(B)	; Full?
	 JRST NVTST0		; Yes, stop (state _ 0)
	PUSHJ P,GNVBYT		; No, get next byte
	 JRST NVTST0		; No more (state _ 0)
	 JRST NVTMR1		; Mark encountered
	HRLI UNIT,(B)		; B clobbered by TTCHI
	PUSH P,UNIT		; =5, clobbered by TTCHI
	PUSH P,IOS		; =6
	SETZ IOS,		; Would you believe this is an arg?
	NOSKED			; TTCHI requires this
	PUSHJ P,TTCHI##		; Stuff character in input buffer
	OKSKED
	POP P,IOS		; Restore ac's
	POP P,UNIT
	HLRZ B,UNIT
	JRST NVTDAT		; Repeat


; Dispatch here when sync in progress
; Also get here after processing Mark
NVTSYN:	LDB A,PSYNCT		; Check sync counter
	JUMPE A,NVTDAT		; Resume processing if now balanced
	CAIE A,SYNCNT/<SYNCNT&-SYNCNT>  ; Skip if -1 (waiting for Int)
NVTSY1:	 PUSHJ P,GNVBYT		; Scanning for DM, get next byte
	 JRST NVTST2		; No more (state _ 2)
	 JRST NVTMR1		; Mark encountered, process it
	JRST NVTSY1		; Normal data, flush it


; Dispatch here to process pending Mark
NVTMRK:	LDB A,PNVMRK		; Recover the Mark byte

; Here when Mark first encountered, A/ Mark byte
NVTMR1:	CAIL A,NNVMRK		; See if in range
	 JRST NVTSYN		; No, ignore
	JRST @MRKDSP(A)		; Yes, perform operation

; Dispatch table for received Mark types
; Code should finish by going to NVTST1 if must defer,
;  NVTSYN normally (to check sync count)
MRKDSP:	NVTSYN		; (0) Unassigned
	NVTDM		; (1) Data Mark
	NVTLW		; (2) Line Width
	NVTPL		; (3) Page Length
	NVTTYP		; (4) Terminal Type
	NVTTMK		; (5) Timing Mark
	NVTTMR		; (6) Timing Mark Reply

NNVMRK==.-MRKDSP	; Number of Mark types recognized

; DONVTI (cont'd)
; Code to process specific Mark types

; Process Data Mark (DM, Mark type 1)
NVTDM:	MOVEI A,SYNTMO		; Reset sync timer
	DPB A,PSYNTM
	LDB A,PSYNCT		; Get sync count
	SUBI A,1		; DM counts as -1
	DPB A,PSYNCT		; Put it back
	PUSHJ P,TTCIBF##	; Clear TTY input buffer
	JRST NVTSYN		; Go reconsider state

; Set Line Width (Mark type 2)
NVTLW:	PUSHJ P,GNVBYT		; Get argument byte
	 JRST NVTST1		; Can't, defer (state _ 1)
	 JRST NVTMR1		; Another Mark, ignore this
	CAIL A,10		; Range check (see .STPAR in TTYSRV)
	 CAIL A,200
	 SETZ A,		; Use default if out of bounds
	DPB A,[POINT 7,TTFLGS##(B),17]  ; Store in TTY status
	JRST NVTSYN		; Done

; Set Page Length (Mark type 3)
NVTPL:	PUSHJ P,GNVBYT		; Get argument byte
	 JRST NVTST1		; Can't, defer (state _ 1)
	 JRST NVTMR1		; Another Mark, ignore this
	CAIL A,10		; Range check (see .STPAR in TTYSRV)
	 CAIL A,200
	 MOVEI A,^D66		; Use default if out of bounds
	DPB A,[POINT 7,TTFLGS##(B),10]  ; Store in TTY status
	JRST NVTSYN		; Done

; Set Terminal Type (Mark type 4)
NVTTYP:	PUSHJ P,GNVBYT		; Get argument byte
	 JRST NVTST1		; Can't, defer (state _ 1)
	 JRST NVTMR1		; Another Mark, ignore this
	CAIL A,NTTYPS##		; Range check (see .STTYP in TTYSRV)
	 JRST NVTSYN		; Out of range, ignore
	HRRM A,TTYPE##(B)	; Set terminal type
	MOVEI C,0(A)		; TTMBIT indexes by C
	LDB A,TTMBIT##		; Get mech bits
	DPB A,[POINT 3,TTFLGS##(2),3]  ; Put where noticed
	JRST NVTSYN		; Done

; Timing Mark (Mark type 5)
NVTTMK:	HRRE A,TTFORK##(B)	; Is there a fork blocked for input?
	JUMPL A,NVTTM1
	HRLM B,0(P)		; Yes, save line #
	MOVEI A,6		; Generate immediate timing mark reply
	PUSHJ P,SNDAMA
	 JRST [	HLRZ B,0(P)	; Can't, defer processing of timing mark
		JRST NVTST1]	; (State _ 1)
	HLRZ B,0(P)		; Ok, recover line #
	JRST NVTSYN		; Done

; Here if no fork waiting.  Increment count so as to cause reply
; to be generated when somebody exhausts the input buffer.
NVTTM1:	LDB A,PTMKCT		; Get current count of timing marks
	ADDI A,1		; Increment it
	DPB A,PTMKCT
	JRST NVTSYN		; Done

; Timing Mark Reply (Mark type 6)
NVTTMR:	MOVSI A,(TMKPNF)	; Clear timing mark pending flag
	ANDCAM A,TTYPUP(B)	; This wakes up anywone waiting
	JRST NVTSYN		; Done

; Get input byte for NVT
;	B/ TTY Line #
; Assumes port is locked and ac's setup
; Returns +1:  Input exhausted
;	+2:  Mark encountered, A/ the byte (also stored via PNVMRK)
;	+3:  Normal, A/ the byte
; Clobbers A, C-D, PB;  does not clobber B

GNVBYT:	HLRZ PB,BSPCUR(BSP)	; Get current buffer ptr if any
	JUMPN PB,GNVBY2		; Jump if already have a buffer
GNVBY1:	HRLM B,0(P)		; Save line #
	PUSHJ P,GETBSP		; Get the next packet
	 JRST [	HLRZ B,0(P)	; No more, recover line #
		POPJ P,]	; Return +1
	HLRZ B,0(P)		; Recover line #
	LDB A,PUPTYP		; Get Pup Type
	CAIE A,PT.MRK		; Mark?
	 CAIN A,PT.AMA		; AMark?
	 JRST [	ILDB A,PBBSID(PB)  ; Yes, get the byte
		DPB A,PNVMRK	; Save away in case need to defer
		SETZM PBBSBC(PB)  ; No more bytes in this packet
		JRST SKPRET##]	; Return +2

GNVBY2:	SOSGE PBBSBC(PB)	; Count down bytes in packet
	 JRST GNVBY1		; Exhausted, try next packet
	ILDB A,PBBSID(PB)	; Get the next byte
	JRST SK2RET##		; Return +3

; Do NVT output processing for one line
;	B/ TTY Line #
; Assumes port is locked
; Returns +1 always
; Clobbers A, C, D, PB;  preserves B

DONVTO:	CHKSTT <OPEN>		; Connection still open?
	 POPJ P,		; No, do nothing
	HRLM B,0(P)		; Preserve line #
	PUSHJ P,CHKBSO		; Check for BSP output possible
	 JRST [	HLRZ B,0(P)	; Not possible, recover line #
		POPJ P,]	; Return having done nothing
	PUSHJ P,BLDDAT		; Build packet of appropriate size
	 JRST [	HLRZ B,0(P)	; Failed to allocate, recover line#
		POPJ P,]	; Return having done nothing
	MOVEM B,PBBSID(PB)	; Store byte pointer
	HLRZ B,0(P)		; Recover line #
	NOSKED			; No races

; Pack bytes from echo buffer
	SKIPN TTECT##(B)	; Any characters in echo buffer?
	 JRST DONVO2		; No
	SKIPN D,TTEOUT##(B)	; Yes, get byte pointer
	 BUG(HLT,<DONVTO: Echo count nonzero but no buffer>)
DONVO1:	TDNN D,WRPMSK##		; Reached end of buffer?
	 HRR D,1-TTSIZ(D)	; Yes, chain or wraparound
	ILDB C,D		; Get next char from echo buffer
	IDPB C,PBBSID(PB)	; Store in packet
	SUBI A,1		; Count down space in packet
	SOSLE TTECT##(B)	; Echo buffer exhausted?
	 JUMPG A,DONVO1		; No, loop unless packet full
	MOVEM D,TTEOUT##(B)	; Yes, store updated byte pointer
	JUMPLE A,DONVO5		; Jump around if packet full

; Pack bytes from output buffer
DONVO2:	SKIPN TTOCT##(B)	; Any characters in output buffer?
	 JRST DONVO4		; No
	SKIPN D,TTOOUT##(B)	; Yes, get byte pointer
	 BUG(HLT,<DONVTO: Output count nonzero but no buffer>)
DONVO3:	TDNN D,WRPMSK##		; Reached end of buffer?
	 HRR D,1-TTSIZ(D)	; Yes, chain or wraparound
	ILDB C,D		; Get next char from output buffer
	IDPB C,PBBSID(PB)	; Store in packet
	SUBI A,1		; Count down space in packet
	SOSLE TTOCT##(B)	; Output buffer exhausted?
	 JUMPG A,DONVO3		; No, loop unless packet full
	MOVEM D,TTOOUT##(B)	; Yes, store updated byte pointer
DONVO4:	SKIPN TTOCT##(B)	; TTY buffers now empty?
	 PUSHJ P,TTRLOB##	; Yes, release them

; Finish up and send the packet
DONVO5:	OKSKED
	MOVE A,PBBSID(PB)	; Get ptr to last byte stored
	PUSHJ P,DMPBSP		; Finish up and send the packet
	HLRZ B,0(P)		; Recover line #
	POPJ P,			; Done

; Routine called upon receipt of an Interrupt for a port
;  attached to an NVT
;	B/ Line #
;	PB/ Packet buffer pointer
; Assumes port is locked
; Returns +1 always
; Clobbers A-D

NVTINT:	LOCK NVTLCK		; No messing with NVT table
	MOVEI A,SYNTMO		; Reset sync timer
	DPB A,PSYNTM
	LDB A,PSYNCT		; Get sync count (Int's - DM's)
	AOS A			; Interrupt counts as +1
	DPB A,PSYNCT		; Put it back
	JUMPE A,[UNLOCK NVTLCK	; Done if Ints and DMs now balance
		JRST WAKBSI]
	LDB A,PNVSTT		; Get current input state
	SKIPN A			; Normal input?
	 MOVEI A,2		; Yes, change to sync in progress
	DPB A,PNVSTT		; Put it back
	UNLOCK NVTLCK
	PUSHJ P,TTCIBF##	; Clear TTY input buffer
	PUSHJ P,WAKBSI		; Make NVT processor notice change
	POPJ P,			; Done



; Background routine to time out syncs
; Called periodically from Pup background process
; Returns +1
; Clobbers A-D, UNIT, BSP, IOS

SYNCHK:	LOCK NVTLCK		; No messing with NVT table
	MOVEI B,PUPLO		; Prepare to scan all NVT's
SYNCH1:	SKIPGE UNIT,TTYPUP(B)	; NVT assigned?
	 TLNN UNIT,(SYNCNT)	; Yes, sync in progress?
	 JRST SYNCH3		; No
	LDB A,PSYNTM		; Yes, get timer
	SOJL A,[SETZ A,		; If timed out, clear sync count
		DPB A,PSYNCT
		UNLOCK NVTLCK	; Prevent deadlocks!
		PUSH P,B	; Preserve line #
		PUSHJ P,LCKBSP	; Lock port
		PUSHJ P,WAKBSI	; Make NVT processor notice change
		PUSHJ P,ULKBSP	; Unlock port
		POP P,B
		LOCK NVTLCK	; Re-lock NVT table
		JRST SYNCH3]
	DPB A,PSYNTM		; Not timed out yet, put it back
SYNCH3:	CAIGE B,PUPHI		; Last NVT?
	 AOJA B,SYNCH1		; No, repeat
	UNLOCK NVTLCK
	SIGPBP(NVT)		; Scan NVT's at least this often
	MOVEI A,SYNCHI		; Get sync check interval
	ADD A,TODCLK		; Compute time of next check
	MOVEM A,SYNTIM
	POPJ P,

; Assign Pup NVT
;	UNIT/ Pup unit #
; Returns +1:  Failed, none free
;	+2:  B/ Line #
; Clobbers A, B

ASPNVT:	MOVE B,[-NPUPLN,,PUPLO]	; Prepare to scan all NVT's
	LOCK(NVTLCK,,HIQ)	; Lock the table
ASPNV1:	SKIPL TTYPUP(B)		; NVT assigned?
	SKIPL TTFORK##(B)	; No, line free?
	 AOBJN B,ASPNV1		; Not available, try next
	JUMPGE B,[UNLOCK(NVTLCK,RESIDENT,HIQ)  ; Fail return if none available
		POPJ P,]
	MOVEI A,(UNIT)		; Found one, copy Pup index
	HRLI A,(1B0)		; Set assignment flag
	MOVEM A,TTYPUP(B)	; Assign NVT
	MOVEI A,400000(B)	; Point port to NVT
	HRROM A,PUPPSI(UNIT)	;  and clear interrupt assignments
	UNLOCK(NVTLCK,RESIDENT,HIQ)  ; Unlock table
	MOVEI B,(B)		; Clear lh of line #
	PUSHJ P,TTCOBI##	; Clear output buffer
	PUSHJ P,TTCIBF##	; Clear input buffer
	PUSHJ P,ITTPAR##	; Initialize terminal parameters
	JRST SKPRET##		; Success return


; Close Pup NVT
;	B/ Line #
; Assumes NVTLCK and port are locked and UNIT, BSP, IOS setup
; Returns +1:  Port not yet closed (try again later)
;	+2:  Now closed, port deleted, NVT released
; Clobbers A, C-D, PB;  preserves B

CLPNVT:	HRLM B,0(P)		; Preserve line #
	PUSHJ P,TTCIBF##	; Clear TTY input buffer
	PUSHJ P,TTCOBI##	; Clear TTY output buffer
	MOVSI A,(HUREQF)	; Hangup requested flag
	TDNN A,TTYPUP(B)	; Already done?
	SKIPGE TTFORK##(B)	; Is there a job attached?
	 JRST CLPNV1		; Already done or no job, bypass
	IORM A,TTYPUP(B)	; Yes, remember we did it
	PUSH P,UNIT		; =5, clobbered by NVTCOF
	PUSHJ P,NVTCOF##	; Initiate carrier-off psi
	POP P,UNIT		;  (NVTCOF also clobbers B)
CLPNV1:	LDB A,PBSSTT		; Get current state
	CAIE A,S.CLOS		; Now closed or aborted?
	 CAIN A,S.ABOR
	 JRST CLPNV5		; Yes, just flush port
	TLNE IOS,(BSTIMF)	; Timed out?
	 JRST [	MOVEI A,E.CLST	; Yes, generate CLOSF(T) event
		HRROI C,0	; Need registered code ************
		HRROI D,[ASCIZ /Connection timed out/]
		JRST CLPNV3]
	CHKSTT <OPEN,ENDI>	; No, state ok for BSP output?
	 JRST CLPNV2		; No
	PUSHJ P,FRCBSP		; Yes, force the byte stream
	PUSHJ P,CHKBOQ		; Any unacknowledged output?
	 JRST [	HLRZ B,0(P)	; Yes, have to wait
		POPJ P,]
CLPNV2:	MOVEI A,E.CLSN		; Generate CLOSF(N) event
CLPNV3:	PUSHJ P,PUPFSM		; Activate the FSM
	CHKSTT <CLOS,ABOR>	; Now closed or aborted?
	 JRST [	HLRZ B,0(P)	; No, have to wait
		POPJ P,]
CLPNV5:	PUSHJ P,FLSBSQ		; Yes, flush all queues
	SKIPE PUPOBC(UNIT)	; Any pending output on port queue?
	 JRST [	HLRZ B,0(P)	; Yes, have to wait
		POPJ P,]
	PUSHJ P,DELPRT		; No, delete the port
	HLRZ B,0(P)		; Recover line #
	SETZM TTYPUP(B)		; Release the NVT
	JRST SKPRET##		; Done

; Pup NVT routines called from TTYSRV

; Clear TTY output buffers for Pup NVT
;	B/ Line #
; Returns +1 always
; Clobbers A, C-D;  preserves B, UNIT, BSP, IOS

PNVCOB::PUSHJ P,CHKNVT		; Check and lock NVT
	 POPJ P,		; No port attached, do nothing
	TLNE IOS,(BSTIMF+BSERRF)  ; Any errors?
	 JRST PNVCO2		; Yes, forget it
	HRROI A,0		; Need registered code ************
	HRROI B,[ASCIZ /Sync/]
	PUSHJ P,SNDINT		; Send Interrupt
	 JRST [	PUSHJ P,ULKNVT	; Can't, undo all locks
		JSYS EDISMS##	; Wait until can send Interrupt
		JRST PNVCOB]	; Try again
PNVCO1:	MOVEI A,1		; Mark type = 1 (DM)
	PUSHJ P,SNDAMA		; Send AMark
	 JRST [	NOINT		; Can't, lock out PSIs while waiting
		PUSHJ P,ULKNVT	; Undo all locks
		JSYS EDISMS##	; Wait until can send Mark
		PUSHJ P,CHKNVT	; Lock everything again
		 JRST [	OKINT	; Port went away, give up
			POPJ P,]
		OKINT
		TLNE IOS,(BSTIMF+BSERRF)  ; Any errors?
		 JRST PNVCO2	; Yes, forget it
		JRST PNVCO1]	; Try again to send Mark
PNVCO2:	PUSHJ P,ULKNVT		; Unlock
	POPJ P,


; Dismiss until output buffer empty, called from TTDOBE
;	B/ Line #
; Returns +1 always
; Clobbers A, C-D;  preserves B, UNIT, BSP, IOS

PNVDOB::PUSHJ P,CHKNVT		; Check and lock NVT
	 POPJ P,		; No port attached, do nothing
	TLNE IOS,(BSTIMF+BSERRF)  ; Any errors?
	 JRST [	PUSHJ P,ULKNVT	; Yes, forget it
		POPJ P,]
	MOVEI A,5		; Mark type = 5 (Timing Mark)
	PUSHJ P,SNDAMA		; Send AMark
	 JRST [	PUSHJ P,ULKNVT	; Can't, undo locks
		JSYS EDISMS##	; Wait until can send Mark
		JRST PNVDOB]	; Try again
	MOVE B,0(P)		; Recover line #
	MOVSI A,(TMKPNF)	; Set timing mark pending flag
	IORM A,TTYPUP(B)
	PUSHJ P,ULKNVT		; Unlock, go OKINT
	MOVEI A,PNVDBT		; Set scheduler test
	HRLI A,(B)		; This line
	JSYS EDISMS##		; Wait until Timing Mark Reply received
	POPJ P,

USE RESPC

; Scheduler test for timing mark not outstanding
; Arg is line #

PNVDBT:	MOVE B,A		; Copy line #
	MOVE A,TTYPUP(B)	; NVT status
	LDB C,TTIMAX##		; Get capacity of line
	TLNE A,(TMKPNF)		; Timing mark still pending?
	CAMG C,TTICT##(B)	; Input buffer full?
	 JRST 1(D)		; No or yes, wakeup
	MOVE A,PUPSTS(A)	; Get port status
	TLNE A,(BSTIMF+BSERRF)	; Still ok?
	 JRST 1(D)		; No, wakeup
	JRST 0(D)		; Yes, wait

USE SWAPPC

; Hang up Pup NVT line, i.e. close connection, release NVT
;	B/ Line #
; Returns +1 always
; Clobbers A, C-D;  preserves B, UNIT, BSP, IOS

PNVCLZ::PUSHJ P,CHKNVT		; Check and lock NVT
	 POPJ P,		; No port attached, do nothing
	PUSHJ P,CLPNVT		; Initiate close
	 JRST [	PUSHJ P,ULKNVT	; Not finished yet, unlock
		POPJ P,]	; Background will handle rest
	PUSHJ P,ULKNV2		; Now closed, port gone
	POPJ P,


USE RESPC

; Awaken Pup NVT processor (called from TCI and TCOUT)
;	B/ Line #
; Returns +1 always
; Clobbers A

PNVWAK::SKIPL TTYPUP(B)		; Is there a port attached?
	 JRST TTCOBI##		; No, flush output and return
	PUSH P,A		; Yes, protect clobbered ac
	SIGPBP(NVT)		; Request NVT scan
	POP P,A
	POPJ P,


; Routine called when TTY input buffer becomes empty (or is cleared)
;	B/ Line #
; Returns +1 always
; Clobbers nothing

PNVIBE::PUSH P,A		; Save an ac
	LDB A,PTMKCT		; Get count of timing marks pending
	JUMPE A,PNVIB3		; Jump if none
PNVIB0:	SKIPN NSKED		; Make sure not NOSKED
	 PUSHJ P,CHKNVT		; Check and lock NVT
	  JRST PNVIB3		; No port attached, do nothing
	CHKSTT <OPEN,ENDI>	; Port in good state for output?
	 JRST PNVIB2		; No, do nothing
	LDB A,PTMKCT		; Yes, get count of marks pending
	JUMPE A,PNVIB2		; Jump if none
PNVIB1:	MOVEI A,6		; Mark type = Timing Mark Reply
	PUSHJ P,SNDAMA		; Try to send AMark
	 JRST [	PUSHJ P,ULKNVT	; Can't, unlock NVT
		JSYS EDISMS##	; Wait until can send Mark
		JRST PNVIB0]	; Try again
	MOVE B,0(P)		; Recover line #
	LDB A,PTMKCT		; Decrement timing mark count
	SOSL A
	 DPB A,PTMKCT
	JUMPG A,PNVIB1		; Repeat if more timing marks pending
PNVIB2:	PUSHJ P,ULKNVT
PNVIB3:	POP P,A
	POPJ P,

USE SWAPPC

; Check and lock Pup NVT and save ac's (for TTY level routines)
;	B/ Line #
; Returns +1:  Not attached to Pup port
;	+2:  Ok, NVT table and port locked and UNIT, BSP, IOS setup
; The +2 return is made at a stack level deeper than the call.
; B is saved at 0(P).  Return must be via ULKNVT
; Clobbers A

CHKNVT:	CAIL B,PUPLO		; Consistency check
	CAILE B,PUPHI
	 BUG(HLT,<CHKNVT: Line # not Pup NVT>)
	EXCH UNIT,0(P)		; Save vulnerable ac's
	PUSH P,BSP
	PUSH P,IOS
	PUSH P,PB
	PUSH P,B
	PUSH P,UNIT		; Put return pc on top
CHKNV1:	NOINT			; Protect locks
	LOCK(NVTLCK,,HIQ)	; Lock the NVT table
	SKIPL UNIT,TTYPUP(B)	; Get and check linkage
	 JRST ULKNV2		; Not attached to Pup port
	LOCK PRTLCK		; Ok, lock port table
	PUSHJ P,LCKBSA		; Attempt to lock port
	 JRST [	UNLOCK PRTLCK	; Can't, unlock port table
		UNLOCK(NVTLCK,RESIDENT,HIQ)  ; Avoid deadlocks
		OKINT
		MOVSI A,(UNIT)	; Set scheduler test
		HRRI A,BSLCKT
		JSYS EDISMS##	; Wait until port unlocked
		JRST CHKNV1]	; Try again
	UNLOCK PRTLCK		; Ok, unlock port table
	JRST SKPRET##		; Skip return, NVT locked


; Unlock Pup NVT and restore AC's
; UNIT, BSP, IOS setup from previous call to CHKNVT
; Returns +1, restores B, UNIT, BSP, IOS

ULKNVT:	PUSHJ P,ULKBSP		; Unlock port

; Enter here if port wasn't locked (or has been deleted)
ULKNV2:	UNLOCK(NVTLCK,RESIDENT,HIQ)  ; Unlock NVT table
	OKINT
	POP P,UNIT		; Pop off return pc
	POP P,B			; Restore saved ac's
	POP P,PB
	POP P,IOS
	POP P,BSP
	EXCH UNIT,0(P)		; Restore UNIT, put back pc
	POPJ P,			; Return


; -----------------------------------------------------------------
;	Pup Interrupt Routines
; -----------------------------------------------------------------


USE RESPC

; Pup input interrupt service

LS CURIPB		; Pointer to current input packet buffer
LS PUPFII		; Count of false input interrupts
LS PUPNFI		; Count of times we had no free input buffers

PUPISV:	JSYS [PUPSVR,,.+1]	; Interrupt entry, Maxc dispatch
	JSYS PUPSAV		; Save ac's, setup stack
	SKIPN A,XPUPIB		; See if packet being input
	 JRST PUPIS1		; No, just start input
	JUMPG A,[AOS PUPFII	; Count false interrupts if
		JRST PUPSVX]	;  input not completed, and ignore
	MOVE PB,CURIPB		; Ok, get packet buffer ptr
	PUSHJ P,PUPINP		; Process input Pup

; Handler returns via POPJ when done with the packet.
; Now setup to start reading next packet
PUPIS1:	MOVEI A,FREIBQ		; Header of free input buffer queue
	PUSHJ P,REMOBQ		; Remove first free input buffer
	 JRST [	AOS PUPNFI	; Queue empty, count occurrences
		SETZM XPUPIB	; Shut off input
		JRST PUPIS2]	; Request assignment, dismiss interrupt
	SOS FREIBN		; Got one, decrement free count
	MOVEM PB,CURIPB		; Save packet buffer ptr
	MOVEI A,(PB)		; Make length,,address
	HRL A,0(A)
	PUSHJ P,MAKNBP##	; Build ptr with real page #'s
	MOVEM A,XPUPIB		; Store for NVIO
	SIGNAL PUPIBG		; Tell NVIO about it
PUPIS2:	SIGPBP(ASG,<MOVE B,FREIBN ; Request buffer assignment
		CAIGE B,MINFIB>)  ;  if below minimum level
	JRST PUPSVX		; Dismiss interrupt

; Routine to process input Pup
;	PB/ Packet Buffer pointer
; Returns +1 always
; Clobbers A-D, disposes of input Pup always

; Check for reasonable Pup Length
PUPINP:	LDB A,PUPLEN		; Get Pup Length field
	CAIL A,MNPLEN		; Check for legal length
	CAILE A,MXPLEN
	 BUG(DPR,<PUPINP: Pup Length out of bounds>,X)
	ADDI A,3		; Ok, compute expected # words
	LSH A,-2
	LDB B,PPBPHS		; Get actual # words NVIO gave us
	CAIE A,(B)		; Same?
	 BUG(DPR,<PUPINP: Packet size inconsistency>,X)

; Check for reasonable physical source network
	LDB C,PPBPHN		; Get phys source network
	CAIL C,1		; Check bounds
	CAILE C,NPNETS
	 BUG(DPR,<PUPINP: Bad physical source network number>,X)

; Reject packet if it claims to be from host zero
	LDB C,PPUPSH		; Get Pup source host
	SKIPN C
	 BUG(DPR,<PUPINP: Bad Pup source host number>,X)

; Default zero network fields to the physical source network
	LDB A,PPUPSN		; Get Pup source network
	JUMPN A,PUPIN1		; Src net = 0?
	LDB A,PPBPHN		; Yes, src net _ phys src net
	MOVE B,PPUPSN
	PUSHJ P,UPDCKS		; Update src net and fix checksum
	JRST PUPI1A

; Pup from specific source net.  See whether we know about it and
; fix up routing table if not.
PUPIN1:	CAILE A,NPNETS		; In range?
	 BUG(DPR,<PUPINP: Pup source net out of range>,X)
	SKIPL PUPROU-1(A)	; Already in routing table?
	 JRST PUPI1A		; Yes
	MOVE B,PBPHYS(PB)	; No, get immediate source net/host (B0-15)
	LSH B,-2		; Position to B2-15 to insert into RT
	TLNE B,(377B17)		; Make sure not host zero
	 HLLZM B,PUPROU-1(A)	; Insert route into table
PUPI1A:	LDB A,PPUPDN		; Get Pup destination network
	JUMPN A,PUPIN2		; Dst net = 0?
	LDB A,PPBPHN		; Yes, dst net _ phys src net
	MOVE B,PPUPDN
	PUSHJ P,UPDCKS		; Update dst net and fix checksum
	LDB A,PPUPDN		; Recover dst net for next check

; Check for destination = Maxc
PUPIN2:	CAIL A,1		; Check for legal destination net
	CAILE A,NPNETS
	 JRST PUPIE1		; Unknown, give error and discard
	HRRZ C,PUPROU-1(A)	; Get Maxc address on dest net
	LDB B,PPUPDH		; Get Pup destination host
	CAIE B,(C)		; Pup destination = Maxc?
	 JUMPN B,GATEWY		; No, pass Pup to gateway processor

; Destination is Maxc (or broadcast), lookup destination port.
; Note that broadcast Pups will match only host-wildcard ports
	MOVE A,PBHEAD+2(PB)	; Get dst net/host and high socket
	LSH A,-4		; Right-justify high socket
	MOVE B,PBHEAD+3(PB)	; Get low dst socket
	LSHC A,-^D16		; Concatenate high and low socket
	LSH B,-4		; Right-justify dst socket
	LSH A,^D20		; Left-justify dst net/host
	PUSHJ P,PRTLUK		; Lookup local port, set UNIT
	 JRST PUPIE2		; Not found, give error and discard

; PUPINP (cont'd)

; Found destination port
; Check for requested random discard
	PUSHJ P,DSCRAN		; Want to discard packet?
	 JRST RELPBI		; Yes, do so

; Check for exceeding maximum port input buffer queue length
	LDB A,PUPLEN		; Get Pup Length (bytes)
	ADDI A,4*PBHEAD+3	; Convert to words, add overhead
	LSH A,-2
	PUSHJ P,CHKIQL		; Check for exceeding maximum
	 JRST PUPIE3		; Overflowed, give error and discard

; Append Pup to port input buffer queue
	PUSHJ P,TRMLPB		; Trim packet buffer to size of Pup
	HRRZ A,PBSIZE(PB)	; Get size of trimmed block
	HRLI A,1		; One new buffer
	ADDM A,PUPIBC(UNIT)	; Add to total for port
	MOVEI A,PUPIBQ(UNIT)	; Get adr of input queue header
	PUSHJ P,APPIBQ		; Append Pup to queue

; Give Pup-Received interrupt to fork, if armed
	HRRE B,PUPPSI(UNIT)	; Get fork to interrupt
	JUMPL B,PUPIN5		; -1 => none
	LDB A,RECPSI		; Get PSI channel to interrupt on
	CAIL A,^D36		; Armed?
	 JRST PUPIN5		; No
	MOVEI A,PRQINT		; Yes, initiate scheduler request
	HRLI A,(UNIT)		; Wakeup for this port
	PUSHJ P,SCDRQ7##	; Queue the request

PUPIN5:	HRRZ A,PUPLNH(UNIT)	; Get BSP linkage if any
	JUMPE A,CPOPJ##		; Done now if not BSP port
	MOVSI A,(BSWAKF)	; Set flag to awaken BSP processor
	IORM A,PUPSTS(UNIT)
	MOVE A,TODCLK		; Queue request for background task
	AOJL B,.+2		; Immediately if NVT
	ADDI A,IBWDLY		; Delayed otherwise
	PUSHJ P,ADDTQI		; Add port to timer queue
	POPJ P,			; Done

; Gateway processor
; Enter with PB/ Packet Buffer pointer
;	A/ Destination network
;	B/ Destination host
; Returns +1 always
; Clobbers A-D, disposes of packet always

GATEWY:	SKIPL PUPPAR+2		; Are we a gateway?
	 JRST NOGATE		; No
	MOVE B,PUPTCB		; Get byte ptr to transport control byte
	LDB A,B			; Get current value of byte
	ADDI A,1B31		; Increment hop count (B0-3 of byte)
	TRNN A,17B31		; Overflow?
	 JRST PUPIE4		; Yes, give error and discard
	PUSHJ P,UPDCKS		; Ok, set new value and fix checksum
	MOVEI UNIT,NPUPUN	; Set fake unit # for gateway
	DPB UNIT,PPUPUN
	HRRZ A,PBSIZE(PB)	; Get length of this packet buffer
	PUSHJ P,CHKGQL		; Check for exceeding maximum
	 BUG(DPR,<GATEWY: Excessive gateway Pups queued>,X)
	ADDM A,PUPOBC(UNIT)	; Ok, update counts
	MOVEI A,PUPOBQ		; Append to output queue
	MOVEI B,PBIOBQ(PB)
	PUSHJ P,APPITQ
	PUSHJ P,PUPOGO		; Wake up output if necessary
	POPJ P,			; Return from gateway handler

; Here if we are not a gateway
NOGATE:	BUG(PUP,<GATEWY: Received Pup not for me and I'm not a gateway>,X)
	MOVEI A,1006		; Registered error code
	HRROI B,[ASCIZ /I'm not a gateway/]
	JRST PUPIE8		; Go send Error Pup

; Here on various Pup input errors detected at interrupt level.
; Generate appropriate "Error" Pup where possible.

; Here if destination network is unknown or unreachable
PUPIE1:	BUG(PUP,<PUPINP: Unknown Pup destination network>,X)
	MOVEI A,1002		; Set Error type
	HRROI B,[ASCIZ /Destination net not in routing table/]
	JRST PUPIE8		; Go make Error and send it

; Here if Pup received for nonexistent local port
PUPIE2:	BUG(PUP,<PUPINP: Received Pup for nonexistent local port>,X)
	MOVEI A,2		; Set Error type
	HRROI B,[ASCIZ /No process at destination port/]
	SKIPN ENTFLG##		; Tenex allowing login?
	 HRROI B,[ASCIZ /Tenex not available/]
	MOVE C,FACTSW##		; Check startup flags
	TLNN C,(CHKDSE)		; Checkdsk errors?
	 SKIPL AUTONX##		; Autojobs not yet started?
	 HRROI B,[ASCIZ /Tenex restarting, wait/]
	JRST PUPIE7		; Go make and send Error

; Here if port input queue overflowed
PUPIE3:	BUG(PUP,<PUPINP: Exceeded maximum input buffer queue length for port>,X)
	MOVEI A,3		; Set Error type
	HRROI B,[ASCIZ /Port input queue overflowed/]
	JRST PUPIE7		; Go make and send Error

; Here if gateway hop count overflowed
PUPIE4:	BUG(PUP,<GATEWY: Discarding Pup at 16th gateway>,X)
	MOVEI A,1004		; Set Error type
	HRROI B,[ASCIZ /Discarded at 16th gateway/]
	JRST PUPIE8		; Go make and send Error


; Here to make and send Error arising from original Pup destination
PUPIE7:	PUSHJ P,MAKERR		; Make Error Pup
	 JRST RELPBI		; Can't, just flush packet
	JRST PUPIEX		; Go send Error

; Here to make and send Error arising from Maxc NCP
PUPIE8:	PUSHJ P,MAKERR		; Make Error Pup
	 JRST RELPBI		; Can't, just flush packet
	LDB A,PPBPHN		; Set source net/host to be
	DPB A,PPUPSN		;  phys net/host at which Pup
	LDB A,PPBPHH		;  was received
	DPB A,PPUPSH
	SETZM PBHEAD+4(PB)	; Set source socket to zero

; Send Error packet via gateway queue
PUPIEX:	MOVEI UNIT,NPUPUN	; Set fake unit # for gateway
	DPB UNIT,PPUPUN
	HRRZ A,PBSIZE(PB)	; Get length of this packet buffer
	PUSHJ P,CHKGQL		; Check for exceeding maximum
	 JRST RELPBI		; Overflowed, just chuck it
	ADDM A,PUPOBC(UNIT)	; Ok, update counts
	MOVEI A,PUPOBQ		; Append to output queue
	MOVEI B,PBIOBQ(PB)
	PUSHJ P,APPITQ
	PUSHJ P,PUPOGO		; Wake up output if necessary
	POPJ P,			; Return from gateway handler

; Pup output interrupt service

LS CUROPB		; Pointer to current output packet buffer
LS PUPFOI		; Count of false output interrupts

PUPOSV:	JSYS [PUPSVR,,.+1]	; Interrupt entry, Maxc dispatch
	JSYS PUPSAV		; Save ac's, setup stack

; Check for packet that NVIO is done with
	SKIPN A,XPUPOB		; Packet being output?
	 JRST PUPOS2		; No
	JUMPG A,[AOS PUPFOI	; Count false interrupts if
		JRST PUPSVX]	;  output not completed, and ignore
	SETZM XPUPOB		; Clear communication cell
	MOVE PB,CUROPB		; Get packet buffer ptr

; Here from code below to discard packet before attempting output
PUPOS1:	LDB UNIT,PPUPUN		; Get index of originating port
	HRRZ A,PBSIZE(PB)	; Get length of packet just output
	PUSHJ P,DECOQL		; Decrement buffer counts for port
	SKIPE PBBSPQ(PB)	; Packet on BSP output queue?
	 JRST [	PUSHJ P,UNLKPB	; Yes, unlock from core
		SETZM PBIOBQ(PB) ; Mark PB no longer being serviced
		JRST PUPOS2]	; But don't deallocate
	PUSHJ P,RELPBI		; No, just release packet buffer

; Now look for a Pup queued for output
PUPOS2:	MOVEI A,PUPOBQ		; Output buffer queue header 
	PUSHJ P,REMOBQ		; Remove packet from queue
	 JRST PUPSVX		; Queue empty
	LDB UNIT,PPUPUN		; Get index of originating port
	PUSHJ P,SETPHD		; Setup physical destination
	 JRST PUPOE2		; Dest net inaccessible
	PUSHJ P,DSCRAN		; See if want random discard
	 JRST PUPOS1		; Yes, do so
	MOVEM PB,CUROPB		; Save ptr to packet being output
	SETOM PBIOBQ(PB)	; Note not done with packet yet
	MOVEI A,(PB)		; Make length,,address
	HRL A,0(A)
	PUSHJ P,MAKNBP##	; Build ptr with real page #'s
	MOVEM A,XPUPOB		; Store for NVIO
	SIGNAL PUPOBG		; Signal NVIO to begin output
	JRST PUPSVX		; Dismiss


; Here if can't transmit packet because dest net is inaccessible
PUPOE2:	BUG(PUP,<PUPOSV: Destination network inaccessible>,X)
	JRST PUPOS1		; Just flush from queue and get next

; Interrupt handler subroutines

; Save AC's A-D, UNIT, PB, and P for interrupt routine,
;  and set up P.
; Enter by JSYS PUPSAV

PUPSVR==PISC5R##	; Pup interrupt routine return
LS PUPSAR		; PUPSAV return

PUPSAV:	PUPSAR,,.+1		; JSYS arg
	MOVEM P,PI5ACP##	; Save P
	MOVE P,[A,,PI5AC##]	; Save A-UNIT
	BLT P,PI5AC##+UNIT-A
	MOVE P,PI5STK##		; Setup stack
	PUSH P,PB		; Save PB as first item
	JRST @PUPSAR		; Return to caller of PUPSAV


; Restore AC's and dismiss interrupt

PUPSVX:	MOVE PB,PI5PDL##	; Restore PB
	MOVS P,[A,,PI5AC##]	; Restore A-UNIT
	BLT P,UNIT
	MOVE P,PI5ACP##		; Restore P
	JEN @PUPSVR		; Dismiss


; Check for requested random discard
;	UNIT/ Pup unit #
; Returns +1:  Discard packet
;	+2:  Don't discard packet
; Clobbers A, B

DSCRAN:	MOVSI A,(DSCRNF)	; Random discard requested?
	CAIE UNIT,NPUPUN	; And not gateway "port"?
	TDNN A,PUPSTS(UNIT)
	 JRST SKPRET##		; No
	SKIPN A,RANNUM		; Yes, get current random number
	 MOVS A,TODCLK		; None, initialize to clock
	MULI A,6065		; Compute next
	DIV A,[377777777741]
	MOVSM B,RANNUM		; Store remainder for next call
	TLNE B,(-1B5)		; Discard 1 packet in 32
	 AOS 0(P)
	POPJ P,

LS RANNUM		; Last random number


; Routine called from scheduler to request Pup received PSI on port
;	A/ Pup unit #
; Returns +1
; Clobbers A, B, UNIT

PRQINT:	MOVEI UNIT,(A)		; Put port index in right ac
	HRRE B,PUPPSI(UNIT)	; Get fork to interrupt
	JUMPL B,CPOPJ##		; Forget it if none
	LDB A,RECPSI		; Get PSI channel to interrupt on
	CAIGE A,^D36		; Armed?
	 PUSHJ P,PSIRQ##	; Yes, initiate interrupt
	POPJ P,

; Set physical destination and message length for Pup
;	PB/ Packet Buffer pointer
; Returns +1:  Destination unreachable
;	+2:  PBPHYS word set up

SETPHD:	LDB B,PPUPDN		; Get destination net
	CAIL B,1		; Check bounds (probably redundant)
	CAILE B,NPNETS
	 POPJ P,		; Error
	SKIPGE A,PUPROU-1(B)	; Ok, get routing table entry
	 POPJ P,		; Net known to be unreachable
	LSH A,2			; Left-justify net/host
	TLNN A,(177777B15)	; Dest net directly connected?
	 MOVE A,PBHEAD+2(PB)	; Yes, use final destination
	MOVEM A,PBPHYS(PB)	; Store phys net/host
	LDB A,PUPLEN		; Get Pup length
	ADDI A,3		; Convert to 36-bit words
	LSH A,-2
	DPB A,PPBPHS		; Set physical size for NVIO
	JRST SKPRET##		; Give skip return



; Start NVIO input going if necessary.
; Call after putting something on FREIBQ
; Returns +1, clobbers nothing

PUPIGO:	SKIPN XPUPIB		; Input already turned on?
	 IDEV PUPIDN		; No, initiate manual interrupt
	POPJ P,


; Start NVIO output going if necessary.
; Call after putting something on PUPOBQ
; Returns +1, clobbers nothing

PUPOGO:	SKIPN XPUPOB		; Output already in progress?
	 IDEV PUPODN		; No, initiate manual interrupt
	POPJ P,


; -----------------------------------------------------------------
;	General Pup Subroutines
; -----------------------------------------------------------------

; Port table management

USE SWAPPC

; Assign local port
;	A/ <net>B7 + <host>B15
;	B/ Socket (right-justified)
; Returns +1:  Error, no slots available
;	+2:  Port already in use, UNIT/ Pup unit #
;	+3:  Successful, UNIT/ Pup unit #
; +1 return with PRTLCK unlocked, +2 and +3 with PRTLCK locked.
; Clobbers C, D, UNIT

ASGPRT:	LOCK(PRTLCK,,SPQ)	; Lock the table
	MOVSI UNIT,(1B0+1B2)	; Set flags for port conflict check
	PUSHJ P,PRTLU0		; Lookup local port
	 CAIA			; Not found
	JRST SKPRET##		; Found, take single skip return
	JUMPL UNIT,[
		UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Unlock and fail if table full
		POPJ P,]
	PUSHJ P,INIPRT		; Initialize port
	SKIPE PUPLSK(UNIT)	; Skip if entry is free
	 SOS LSKNDL		; Deleted, decrement delete count
	HLLZM A,PUPLNH(UNIT)	; Store net/host
	MOVEM B,PUPLSK(UNIT)	; Store socket #, assigning port
	JRST SK2RET##		; Take success return


; Delete local port
;	UNIT/ Pup unit #
; The port itself must be locked if it is a BSP port
; Returns +1 always
; Clobbers A-D, PB

DELPRT:	LOCK(PRTLCK,,SPQ)	; Lock the table
	SETOM PUPLSK(UNIT)	; Mark entry deleted
	PUSHJ P,DELTQP		; Delete port from timer queue
	MOVEI A,PUPIBQ(UNIT)	; Input packet buffer queue header
	PUSHJ P,FSHPBQ		; Flush packet buffer queue
	SKIPE B,PUPFPT(UNIT)	; Have foreign port address table?
	 PUSHJ P,RELPFR		; Yes, deallocate it
	HRRZ B,PUPLNH(UNIT)	; Have BSP data block?
	SKIPE B
	 PUSHJ P,RELPFR		; Yes, deallocate it
	SETZM PUPLNH(UNIT)	; Zero net/host and BSP linkage
	PUSHJ P,INIPRT		; Initialize port for cleanliness
	AOS B,LSKNDL		; Increment # of deleted entries
	SIGPBP(GCS,<CAIL B,NPUPUN/4>) ; Request GC of table if worthwhile
	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Unlock the table
	POPJ P,


; Initialize local port
;	UNIT/ Pup unit #
; Returns +1 always, after setting the port's entry in all port-
;  indexed tables to a virgin state.
; Clobbers C

INIPRT:	SETZM PUPFPT(UNIT)	; Clear foreign port
	MOVEI C,PUPIBQ(UNIT)	; Set input buffer queue to empty
	HRLI C,(C)
	MOVEM C,(C)
	SETZM PUPIBC(UNIT)	; Set queue counts to zero
	SETZM PUPOBC(UNIT)
	SETOM PUPPSI(UNIT)	; Disable PSI stuff
	SETZM PUPSTS(UNIT)	; Clear status word
	POPJ P,

USE RESPC

; Garbage collect Pup local socket table by setting free as many
;  deleted entries as possible.  This is done by first changing
;  all deleted entries to be free, then looking up each in-use
;  entry and marking deleted all free cells encountered.
; Clobbers A-D, UNIT, E

GCPLSK:	LOCK PRTLCK		; Lock the table
	CHNOFF PUPCHN		; Lock out interrupt-level accesses
	MOVSI E,-NPUPUN		; For all entries:
	SKIPGE PUPLSK(E)	; Deleted?
	 SETZM PUPLSK(E)	; Yes, set free
	AOBJN E,.-2
	SETZM LSKNDL		; Init count of deleted entries
	MOVSI E,-NPUPUN		; For all entries:
GCPLS1:	SKIPG B,PUPLSK(E)	; In use?
	 JRST GCPLS2		; No
	MOVE A,PUPLNH(E)	; Yes, fetch net/host
	MOVSI UNIT,(1B1)	; Set special flag
	PUSHJ P,PRTLU0		; Lookup, setting free entries to deleted
	 BUG(HLT,<GCPLSK: Impossible fail return from PRTLU0>
GCPLS2:	AOBJN E,GCPLS1
	CHNON PUPCHN		; Unlock and return
	UNLOCK PRTLCK
	POPJ P,

; Lookup local port
;	A/ <net>B7 + <host>B15
;	B/ Socket (right-justified)
; Returns +1: fail, UNIT/ Index of first free slot (B0 set => full)
;	  +2: found, UNIT/ Index of matching entry
; Non-interrupt-level callers should lock PRTLCK before calling
;  if they intend to use UNIT on either return.
; Clobbers C, D, UNIT

PRTLUK:	MOVSI UNIT,(1B0)	; Note no free entries found yet

; Enter here for various flavors of lookup controlled by lh UNIT:
;  B0	No free entries found yet (should always be set on call)
;  B1	Doing gc marking (setting free entries to deleted)
;  B2	Doing port conflict check (wildcard in either arg or port
;	constitutes a match)

PRTLU0:	MOVE C,[^D2654435769_3]	; Constant relatively prime to 2^32
	MUL C,B			; D _ 32-bit fraction in range [0,1)
	MOVEI C,NPUPUN		; Normalize to range [0,NPUPUN)
	MULM C,D
	MOVNI C,(D)		; Save neg index for wraparound
	HRLM C,0(P)
	HRLI D,-NPUPUN(D)	; Make AOBJN ptr, here to end
PRTLU1:	CAMN B,PUPLSK(D)	; Socket number match this entry?
	 JUMPN B,[MOVE C,PUPLNH(D)  ; Yes, compare net/host
		XOR C,A
		HLR C,PUPLNH(D)	; Wildcard check
		TLNE UNIT,(1B2)	; Port conflict check?
		 TLNE A,(377B7)	; Yes, check arg for wildcard
		TRNN C,377B25
		 TLZ C,(377B7)	; Net wildcard
		TLNE UNIT,(1B2)	; Port conflict check?
		 TLNE A,(377B15)  ; Yes, check arg for wildcard
		TRNN C,377B33
		 TLZ C,(377B15)	; Host wildcard
		TLNE C,(177777B15)
		 JRST PRTLU2	; Mismatch, continue search
		MOVEI UNIT,(D)	; Match, return index
		JRST SKPRET##]
	SKIPG C,PUPLSK(D)	; No match, free or deleted?
	 JRST [	TLNE UNIT,(1B1)	; Yes, doing gc marking?
		 JRST [	JUMPL C,PRTLU2	; Yes, ignore if deleted
			SETOM PUPLSK(D)	; Free, mark deleted
			AOS LSKNDL	; Bump delete count
			JRST PRTLU2]	; Continue search
		TLZE UNIT,(1B0)	; No, already have free/deleted index?
		 HRRI UNIT,(D)	; No, remember this
		JUMPL C,PRTLU2	; Keep searching if deleted entry
		POPJ P,]	; Fail if free entry, i.e. not found	
PRTLU2:	AOBJN D,PRTLU1		; Search linearly thru table
	HLLZ D,0(P)		; At end, wraparound
	HRRZS 0(P)		; Clear count in case get here again
	JUMPL D,PRTLU1		; Do portion before initial probe
	POPJ P,			; Searched whole table, not found

USE SWAPPC

; Check Pup source field
;	PB/ Packet buffer pointer
;	UNIT/ Pup unit #
; Returns +1:  Source incorrect
;	+2:  Source correct, i.e. matches foreign port
; Clobbers A-D

CHKSRC:	LDB A,PPUPSN		; Get source net from Pup
	LDB B,PPUPSH		; Source host
	LDB C,PPUPSS		; Source socket

; Enter here with A/ net, B/ host, C/ socket to be checked
CHKSR1:	SKIPN D,PUPFPT(UNIT)	; Have foreign port address table?
	 JRST SKPRET##		; No, fully wildcard, skip return
	PUSH P,E		; Get another ac
CHKSR2:	HLRZ E,1(D)		; Get net from table
	CAIE A,(E)		; Match?
	 JUMPN E,CHKSR3		; No, fail unless wildcard
	HRRZ E,1(D)		; Yes, get host from table
	CAIE B,(E)		; Match?
	 JUMPN E,CHKSR3		; No, fail unless wildcard
	CAME C,2(D)		; Yes, check socket
	 SKIPN 2(D)		; Mismatch, fail unless wildcard
	AOSA -1(P)		; Matched, take skip return
CHKSR3:	AOBJN D,CHKSR2		; Table entry mismatched, try next
	POP P,E			; Matched (skip preset) or no more
	POPJ P,


; Set Pup checksum
;	PB/ Packet Buffer pointer
; Returns +1:
; Clobbers A-D

SETCKS:	PUSHJ P,PUPCKS		; Compute checksum
	MOVE C,A		; Save it
	PUSHJ P,GPTCKS		; Get byte pointer to checksum
	DPB C,B			; Store checksum in Pup
	POPJ P,


; Check Pup checksum
;	PB/ Packet Buffer pointer
; Returns +1:  Checksum incorrect
;	+2:  Checksum correct
; Clobbers A-D

CHKCKS:	PUSHJ P,GPTCKS		; Get byte pointer to checksum
	LDB C,B			; Get checksum from Pup
	CAIN C,177777		; Real checksum?
	 JRST SKPRET##		; No, unchecksummed Pup always ok
	PUSH P,C		; Yes, save checksum from Pup
	PUSHJ P,PUPCKS		; Recompute checksum
	POP P,C
	CAMN A,C		; Correct?
	 AOS 0(P)		; Yes, skip return
	POPJ P,

USE RESPC

; Update Pup checksum
;	PB/ Packet Buffer pointer
;	A/ New value of field to be updated
;	B/ Byte pointer denoting field to be changed
;	   Must be indexed by PB and cannot cross 16-bit boundary
; Returns +1 after storing new value as specified and updating the
;	   checksum (if appropriate)
; Clobbers A-D

UPDCKS:	MOVE C,A		; Save new value
	MOVEI A,(B)		; Compute Maxc-word offset of field
	LSH A,1			; Convert to 16-bit word offset
	HLRZ D,B		; Which byte?
	CAIGE D,^D20B23
	 ADDI A,1		; Right, add 1 to offset
	PUSH P,B		; Save byte ptr arg
	PUSHJ P,GPTWRD		; Get pointer to 16-bit word
	LDB D,B			; Fetch old contents of word
	DPB C,0(P)		; Store new value into field being changed
	SUB P,BHC##+1		; Fix stack
	LDB C,B			; Fetch new contents of word
	SUBI C,(D)		; Compute 16-bit 1's complement difference
	JUMPGE C,.+2
	 ADDI C,177777
	MOVE D,A		; Save offset
	PUSHJ P,GPTCKS		; Return offset and ptr to checksum
	SUBI A,(D)		; Compute difference in offsets
	ANDI A,17		; Modulo 16
	LSH C,(A)		; Shift checksum correction appropriately
	LDB A,B			; Fetch old checksum
	CAIN A,177777		; Real checksum?
	 POPJ P,		; No, unchecksummed Pup, don't update
	ADD A,C			; Compute new sum
	MOVE D,B		; Save byte ptr
	PUSHJ P,CKFOLD		; Fold computed checksum to 16 bits
	CAIN A,177777		; Check for minus zero
	 SETZ A,		; Convert to plus zero
	DPB A,D			; Store new checksum
	POPJ P,


; Get pointer to Pup checksum
;	PB/ Packet Buffer pointer
; Returns +1:
;	A/ Packet-Buffer-relative offset of 16-bit checksum word
;	B/ Byte pointer to Pup checksum
; No other ac's clobbered

GPTCKS:	LDB A,PUPLEN		; Get Pup length in bytes
	ADDI A,4*PBHEAD-1	; Compute PB-relative 16-bit word offset
	LSH A,-1		;  of Pup checksum
				; Fall into GPTWRD


; Get pointer to 16-bit word in Pup
;	A/ Packet-Buffer-relative offset of word
;	   e.g. 2*PBHEAD denotes offset of Pup Length field
; Returns +1:
;	B/ Byte ptr to selected word (indexed by PB)
; No ac's clobbered (besides B)

GPTWRD:	MOVEI B,(A)		; Copy offset
	ROT B,-1		; Compute Maxc-word offset
	JUMPL B,.+2		; Which byte?
	 TLOA B,(POINT 16,(PB),15)  ; Left
	 HRLI B,(POINT 16,(PB),31)  ; Right
	POPJ P,

USE SWAPPC

; Compute Pup checksum
;	PB/ Packet Buffer pointer
; Returns +1:
;	A/ 16-bit checksum, right-justified
; Clobbers B-D

PUPCKS:	LDB C,PUPLEN		; Pup length in bytes
	SUBI C,1		; Compute # full words to checksum
	LSHC C,-2		; (i.e. exclusive of checksum word)
IFE UCSUMF,<	; If no CSUM16 microcode operation present
	PUSH P,D		; Sign bit set if leftover 16-bits
	ROT C,-3		; Divide # full words by 8
	MOVEI D,1(C)		; # 8-fold cycles +1
	LSH C,-^D<18-3>		; # leftover bytes in lh
	MOVN C,C		; Make AOBJN pointer to Pup
	HRRI C,PBHEAD(PB)
	SETZ A,			; Init checksum to zero
	ADD P,BHC##+LPCHKL	; Get some stack space to save ACs
	JUMPGE P,MSTKOV##
	MOVSI B,D+1
	HRRI B,-LPCHKL+1(P)
	BLT B,0(P)
	MOVE B,[PCHKLP,,D+1]	; Copy the Pup checksum loop into the ACs
	BLT B,D+LPCHKL
	TLNN C,-1		; Use leftover count first
	 JRST PUPCK4		; None, start full 8-fold cycles
	JRST D+1		; Enter main loop

; Break out of main loop to here every 8 words
PUPCK3:	PUSHJ P,CKFOLD		; Fold 36 bits to 16
PUPCK4:	HRLI C,-8		; Set to do next group
	SOJG D,D+1		; Repeat if more to do
	MOVSI B,-LPCHKL+1(P)	; Done, restore ACs
	HRRI B,D+1
	BLT B,D+LPCHKL
	SUB P,BHC##+LPCHKL	; Flush from stack
	POP P,D
>
IFN UCSUMF,<	; If CSUM16 microcode operation is available
	MOVN B,C		; Make AOBJN ptr to Pup
	MOVSI B,0(B)
	HRRI B,PBHEAD(PB)
	SETZ C,			; Init checksum to zero
	CSUM16 B,		; Invoke the microcode operation
	MOVE A,C		; Result checksum
	MOVE C,B		; Ending pointer
>
	JUMPGE D,PUPCK5		; Have a leftover 16 bits?
	MOVE B,0(C)		; Yes, add it in
	LSH B,-^D<36-16>
	ADDI A,(B)
	LSH A,1
	PUSHJ P,CKFOLD		; Fold to 16 bits
PUPCK5:	CAIN A,177777		; Minus zero?
	 SETZ A,		; Yes, make plus zero
	POPJ P,

; PUPCKS (cont'd)

IFE UCSUMF,<
; Main loop of Pup checksum computation.  Runs in ACs starting at D+1.
PCHKLP:	MOVE B,0(C)		; Get a word
	ANDCMI B,17		; Clear garbage bits
	ROT B,^D16		; High 16 bits to B20-35, clear B18-19
	ADDI A,(B)		; Add to checksum
	LSH A,2			; Shift checksum twice
	LSH B,-^D<36-16-1>	; Justify previous low 16 bits to B34
	ADDI A,(B)		; Add to checksum (pre-shifted)
	AOBJN C,D+1		; Repeat for this group
	JRST PUPCK3		; Out to fold in the propagated carries
LPCHKL==.-PCHKLP
>


USE RESPC

; Fold 36-bit add-and-left-shift checksum into 16-bit
;  ones-complement add-and-left-cycle checksum
;	A/ 36-bit checksum
; Returns +1:
;	A/ 16-bit checksum, right-justified
; Clobbers B

CKFOLD:	CAIG A,177777
	 POPJ P,		; No more folding to do
	LSHC A,-^D16		; Overflow bits in A, low 16 in B
	LSH B,-^D<36-16>
	ADDI A,(B)		; Fold
	JRST CKFOLD		; Check again

; Pup free storage management routines

USE SWAPPC

; Assign Pup free storage block from the PUPFRE region
;	B/ Size of block needed (words)
; Returns +1: Failed
;	+2: A/ Pointer to block
; Clobbers A-D

ASGPFR:	MOVEI A,PUPFRE		; Point to free storage header
	JRST ASGFRE##		; Just call standard routine



; Release Pup free storage block
;	B/ Pointer to block
; Returns +1 always
; Clobbers A-D

RELPFR:	MOVEI A,PUPFRE		; Point to free storage header
	JRST RELFRE##		; Just call standard routine



; Trim Pup storage block
;	A/ Pointer to block
;	B/ # words to retain
; Returns +1 always
; Clobbers A-D

TRMPFR:	HRRZ C,0(A)		; Get current size
	SUB C,B			; Compute excess words
	JUMPLE C,CPOPJ##	; Quit if none
	HRRM B,0(A)		; Store new size
	ADDI B,(A)		; Point to start of excess
	HRRM C,0(B)		; Store size at head of block
	PUSHJ P,RELPFR		; Release excess block
	POPJ P,

; Assign packet buffer
;	B/ Size of buffer needed (words)
; Returns +1:  Failed, A/ appropriate arg for EDISMS
;	+2:  PB/ Packet Buffer pointer
; The buffer returned has the size setup (PBSIZE) and all else zeroed.
; Clobbers A-D

ASGPKT:	MOVEI A,PKTFRE		; Free storage header
	PUSHJ P,ASGFRE##	; Assign the block
	 JRST ASGPK1		; Can't
	MOVEI PB,(A)		; Ok, put buffer adr in PB
	PUSHJ P,CLRPBH		; Clear header
	JRST SKPRET##		; Skip return

; Here when fail to allocate
ASGPK1:	BUG(NTE,<ASGPKT: Free storage exhausted>)
	MOVSI A,(B)		; Set scheduler test word
	HRRI A,PKTFRT		; Size,,routine
	SETZM PKTRLF		; Init wakeup condition
	POPJ P,			; Take fail return

USE RESPC

; Scheduler test for process dismissed after ASGPKT failure
; Arg is size of packet buffer needed (words)

LS PKTRLF		; Set nonzero when storage has been released

PKTFRT:	CAMG A,PKTFRE+2		; Don't wakeup if total space insufficient
	SKIPN PKTRLF		; Wakeup if RELPKT has been called
	 JRST 0(D)
	JRST 1(D)


USE SWAPPC

; Release packet buffer
;	PB/ Packet Buffer pointer
; Returns +1
; Clobbers A-D, PB

RELPKT:	MOVSI A,(PBLCKF)	; Make sure not locked
	TDNE A,PBSIZE(PB)
	 BUG(HLT,<RELPKT: Attempt to release locked packet buffer>)
	HRRZ A,PBSIZE(PB)	; Check size
	MOVE B,FREIBN		; Get free input buffer count
	CAIL A,MXPBLN		; Releasing maximum-size buffer?
	CAIL B,MAXFIB		; Yes, want to add more input buffers?
	 JRST [	MOVEI A,PKTFRE	; No, just release the storage
		MOVEI B,(PB)
		PUSHJ P,RELFRE##
		SETOM PKTRLF	; Note space has been released
		POPJ P,]
	PUSHJ P,CLRPBH		; Yes, clear header
	JRST ASGIP1		; Go put on FREIBQ and return

; Assign input packet buffer, add to FREIBQ, and start up input if necessary
; Returns +1: failed
;	+2: succeeded
; Clobbers A-D and PB

ASGIPB:	MOVEI B,MXPBLN		; Get maximum-size packet buffer
	PUSHJ P,ASGPKT
	 POPJ P,		; Failed, forget it
	AOS 0(P)		; Ok, preset skip return

; Here from RELPKT with PB/ ptr to maximum-size packet buffer
ASGIP1:	MOVEI A,FREIBQ		; Free input buffer queue header
	PUSHJ P,APPOBQ		; Lock and append to queue
	AOS FREIBN		; Fix count
	PUSHJ P,PUPIGO		; Start input if necessary
	POPJ P,


USE RESPC

; Release packet buffer at interrupt level
;	PB/ Packet buffer ptr
; Returns +1
; Callable only at interrupt level;  PB must be locked
; Clobbers A-C

RELPBI:	MOVSI A,(PBLCKF)	; Make sure locked
	TDNN A,PBSIZE(PB)
	 BUG(HLT,<RELPBI: Called with unlocked PB>)
	HRRZ A,PBSIZE(PB)	; Get size of PB
	MOVE B,FREIBN		; Get # of buffers already available
	CAIL A,MXPBLN		; This PB too small?
	CAIL B,MAXFIB		; Already enough PBs available?
	 JRST [	MOVEI A,FREOBQ	; Yes, put PB on queue to be freed
		PUSHJ P,APPIBQ
		SIGPBP(FRE)	; Request service by deallocator
		POPJ P,]
	PUSHJ P,CLRPBH		; No, clear header
	MOVSI A,(PBLCKF)	; Set locked flag again
	IORM A,PBSIZE(PB)
	MOVEI A,FREIBQ		; Free input buffer queue header
	MOVEI B,PBIOBQ(PB)	; Make ptr to link word in PB
	PUSHJ P,APPITQ		; Append to queue
	AOS FREIBN		; Fix count
	PUSHJ P,PUPIGO		; Start input if necessary
	POPJ P,


; Clear packet buffer header
;	PB/ Packet buffer ptr
; Returns +1, clobbers nothing

CLRPBH:	HRRZS PBSIZE(PB)	; Clear lh of PBSIZE
	SETZM PBIOBQ(PB)	; Clear I/O queue links
	SETZM PBBSPQ(PB)	; Clear BSP queue links
	SETZM PBTIME(PB)	; Clear time stamp word
	POPJ P,

; Packet buffer queueing and unqueueing routines
USE SWAPPC

; Get Pup from port input queue
;	UNIT/ Pup unit #
; Returns +1:  Queue empty, A/ Appropriate arg for EDISMS
;	+2:  PB/ Packet Buffer pointer, counts updated appropriately
; Clobbers A-C

GETPUP:	MOVEI A,PUPIBQ(UNIT)	; Set adr of port input queue hdr
	PUSHJ P,REMIBQ		; Get packet buffer from queue
	 JRST [	MOVEI A,NEPBQT	; Empty, set scheduler test word
		HRLI A,PUPIBQ(UNIT)
		POPJ P,]	; Fail return
	HRRZ A,PBSIZE(PB)	; Got one, get packet buffer length
	PUSHJ P,DECIQL		; Decrement input queue length counts
	JRST SKPRET##		; Skip return

USE RESPC

; Scheduler test for non-empty packet buffer queue
; Arg is address of queue header

NEPBQT:	HRRZ B,(A)		; Get head item in queue
	CAIN B,(A)		; Self-pointer?
	 JRST 0(D)		; Yes, queue still empty
	JRST 1(D)		; Non-empty, wakeup


USE SWAPPC

; Put Pup on output queue
;	PB/ Packet Buffer pointer
;	UNIT/ Pup unit #
; Returns +1:  Queue too long, A/ Appropriate arg for EDISMS
;	+2:  Ok, queue length updated appropriately
; Clobbers A-C

PUTPUP:	DPB UNIT,PPUPUN		; Store unit # in Pup
	HRRZ A,PBSIZE(PB)	; Get length of new packet buffer
	PUSHJ P,CHKOQL		; Check for exceeding output queue length
	 POPJ P,		; Too much, fail return
	ADDM A,PUPOBC(UNIT)	; Ok, update count
	MOVEI A,PUPOBQ		; Pup output buffer queue header
	PUSHJ P,APPOBQ		; Lock and append Pup to queue
	PUSHJ P,PUPOGO		; Start output going if necessary
	JRST SKPRET##		; Skip return

USE RESPC

; Delete Pup from output queue if still on it
; Pup must be marked as owned by BSP processor (PBBSPQ nonzero)
;	PB/ Packet buffer pointer
;	UNIT/ Pup unit #
; Returns +1, releases or disposes of packet buffer always
; Clobbers A-C

DELOBQ:	SKIPN PBBSPQ(PB)	; Make sure owned by BSP processor
	 BUG(HLT,<DELOBQ: Called for unowned packet buffer>)
	SKIPN PBIOBQ(PB)	; Now on output queue?
	 JRST DELOB2		; No, just release the packet
	NOSKED			; Prevent swapouts
	SKIP PBIOBQ(PB)		; Make sure in core
	CHNOFF PUPCHN		; Lock out interrupts
	SKIPN A,PBIOBQ(PB)	; Still on output queue?
	 JRST DELOB1		; No, just release the packet
	AOJE A,[SETZM PBBSPQ(PB)  ; Now being output by NVIO,
		CHNON PUPCHN	;  mark unowned so output interrupt
		OKSKED		;  deallocates it when done
		POPJ P,]
	MOVEI A,PBIOBQ(PB)	; On output queue, unlink it
	PUSHJ P,DELITQ
	HRRZ A,PBSIZE(PB)	; Get size of packet buffer
	PUSHJ P,DECOQL		; Decrement counts
	PUSHJ P,UNLKPB		; Unlock packet buffer
DELOB1:	CHNON PUPCHN		; Uninterlock
	OKSKED
DELOB2:	PUSHJ P,RELPKT		; Release the packet buffer
	POPJ P,			; Done


; Check input queue length
;	A/ Size of packet about to be added to input queue
;	UNIT/ Pup unit #
; Returns +1:  Error, queue too full
;	+2:  Ok, A/ 1,,size (ready to be added to PUPIBC(UNIT))
; Clobbers B, C

CHKIQL:	HLRZ B,PUPIBC(UNIT)	; Get buffer count
	HRRZ C,PUPIBC(UNIT)	; Get word count
	ADDI C,(A)		; Add new size to it
	CAIGE B,MAXIQB		; Enough buffers already?
	CAILE C,MAXIQW		; Too many words?
	 POPJ P,		; Yes, fail
	HRLI A,1		; No, set to add count
	JRST SKPRET##		; Skip return


; Decrement input queue length
;	A/ Size of packet just removed from input queue
;	UNIT/ Pup unit #
; Returns +1 always
; Clobbers A

DECIQL:	HRLI A,1		; Set to count one buffer
	MOVNS A			; Negate buffer and word counts
	ADDB A,PUPIBC(UNIT)	; Decrement them
	TDNE A,[1B0+1B18]	; Check for over-decrementing
	 BUG(CHK,<DECIQL: Over-decrementing Pup input count>)
	POPJ P,

; Check output queue length
;	A/ Size of packet about to be added to output queue
;	UNIT/ Pup unit #
; Returns +1:  Error, queue too full, A/ EDISMS argument word
;	+2:  Ok, A/ 1,,size (ready to be added to PUPOBC(UNIT))
; Clobbers B, C

CHKOQL:	HLRZ B,PUPOBC(UNIT)	; Get buffer count
	HRRZ C,PUPOBC(UNIT)	; Get word count
	ADDI C,(A)		; Add new size to it
	CAIGE B,MAXOQB		; Enough buffers already?
	CAILE C,MAXOQW		; Too many words?
	 JRST [	LSH A,^D<35-8>	; Yes, position size to B8
		TLO A,(UNIT)	; Unit # at B17
		HRRI A,FOPBQT	; Set scheduler test
		POPJ P,]	; Fail return
	HRLI A,1		; No, set to add count
	JRST SKPRET##		; Skip return

; Scheduler test for full output packet buffer queue
; Arg is in form <size of new packet>B26 + Pup unit #

FOPBQT:	LSHC A,-^D9		; Separate size and unit
	LSH B,-^D<36-9>		; Size to A, unit # to B
	HRRZ C,PUPOBC(B)	; Get word count
	HLRZ B,PUPOBC(B)	; Get buffer count
	ADDI C,(A)		; Add new length to word count
	CAIGE B,MAXOQB		; Within bounds?
	CAILE C,MAXOQW
	 JRST 0(D)		; No
	JRST 1(D)		; Yes, wakeup


; Decrement output queue length
;	A/ Size of packet just removed from output queue
;	UNIT/ Pup unit #
; Returns +1 always
; Clobbers A

DECOQL:	HRLI A,1		; Set to count one buffer
	MOVNS A			; Negate buffer and word counts
	ADDB A,PUPOBC(UNIT)	; Decrement them
	TDNE A,[1B0+1B18]	; Check for over-decrementing
	 BUG(CHK,<DECOQL: Over-decrementing Pup output count>)
	POPJ P,


; Check gateway queue length
;	A/ Size of packet about to be added to gateway queue
;	UNIT/ Pup unit # of gateway queue (NPUPUN)
; Returns +1:  Error, queue too full
;	+2:  Ok, A/ 1,,size (ready to be added to PUPOBC(UNIT))
; Clobbers B, C

CHKGQL:	HLRZ B,PUPOBC(UNIT)	; Get buffer count
	HRRZ C,PUPOBC(UNIT)	; Get word count
	ADDI C,(A)		; Add new size to it
	CAIGE B,MAXGQB		; Enough buffers already?
	CAILE C,MAXGQW		; Too many words?
	 POPJ P,		; Yes, fail
	HRLI A,1		; No, set to add count
	JRST SKPRET##		; Skip return

; Append packet buffer to input queue at interrupt level
;	PB/ Packet Buffer pointer
;	A/ Address of queue header
; Returns +1
; Previous tail (if any) must of course be locked, and is
;  unlocked by this routine.
; Clobbers A-C

APPIBQ:	MOVEI B,PBIOBQ(PB)	; Get adr of new PB's link word
	PUSHJ P,APPITQ		; Append item to queue
	CAIN C,(A)		; Was queue previously empty?
	 POPJ P,		; Yes, done
	PUSH P,PB		; No, save current PB
	MOVEI PB,-PBIOBQ(C)	; Compute real adr of old tail PB
	PUSHJ P,UNLKPB		; Unlock it
	POP P,PB
	POPJ P,


; Remove packet buffer from input queue at non-interrupt level,
;  and unlock it if necessary
;	A/ Address of queue header
; Returns +1:  Queue empty
;	+2:  PB/ Address of packet buffer
; Clobbers A-C

REMIBQ:	MOVE B,(A)		; Get queue header word
	MOVE B,(B)		; Reference head packet
	SKIP (B)		; Reference successor
	NOSKED			; Prevent swapouts
	MOVE B,(A)		; Do references again in case
	MOVE B,(B)		;  pages sneaked away (page fault
	SKIP (B)		;  while CHNOFF is death)
	CHNOFF PUPCHN		; Interlock
	PUSHJ P,REMITQ		; Remove item from queue
	 JRST [	CHNON PUPCHN	; Empty, fail
		OKSKED
		POPJ P,]
	CHNON PUPCHN
	MOVEI PB,-PBIOBQ(B)	; Get real adr of new PB
	CAIN C,(A)		; Was this the only PB in the queue?
	 PUSHJ P,UNLKPB		; Yes, have to unlock it
	OKSKED
	SETZM PBIOBQ(PB)	; Mark PB as not in queue
	JRST SKPRET##		; Skip return


; Lock and append packet to output queue at non-interrupt level
;	A/ Address of queue header
;	PB/ Packet Buffer pointer
; Returns +1
; Clobbers B,C

APPOBQ:	PUSH P,A
	PUSHJ P,LOCKPB		; Lock the packet buffer
	POP P,A
	MOVEI B,PBIOBQ(PB)	; Get adr of new PB's link word
	CHNOFF PUPCHN		; Interlock
	PUSHJ P,APPITQ		; Append to queue
	CHNON PUPCHN
	POPJ P,


; Remove packet buffer from output queue at interrupt level,
;  but do not unlock it
;	A/ Address of queue header
; Returns +1:  Queue empty
;	+2:  PB/ Address of packet buffer
; Clobbers A-C

REMOBQ:	PUSHJ P,REMITQ		; Remove item from head of queue
	 POPJ P,		; Empty, fail
	MOVEI PB,-PBIOBQ(B)	; Get real adr of new PB
	JRST SKPRET##		; Skip return

; Primitive queueing/unqueueing routines.
; The caller is responsible for interlocking queue access for
;  race prevention.


; Insert item into queue
;	A/ Address of item which is to be the new item's successor,
;	    i.e. before which the new item is to be inserted
;	B/ Address of item to insert
; Returns +1:
;	C/ Address of new item's predecessor
; No other ac's affected

INSITQ::			; Same as APPITQ


; Append item to queue
;	A/ Address of queue header
;	B/ Address of item to append
; Returns +1:
;	C/ Address of previous tail item
; No other ac's affected

APPITQ::HLRZ C,(A)		; Get current tail
	HRLM B,(A)		; Queue tail _ new PB
	HRRZM A,(B)		; New PB's successor _ queue header
	HRLM C,(B)		; New PB's predecessor _ old tail
	HRRM B,(C)		; Old tail's successor _ new PB
	POPJ P,


; Remove item from head of queue
;	A/ Address of queue header
; Returns +1:  Queue empty
;	+2:  B/ Address of item removed
;	     C/ Address of new head item
; No other ac's affected

REMITQ::HRRZ B,(A)		; Get current head
	CAIN B,(A)		; Empty?
	 POPJ P,		; Yes, fail
	HRRZ C,(B)		; No, get successor
	HRRM C,(A)		; Queue head _ successor
	HRLM A,(C)		; Successor's predecessor _ queue header
	SETZM (B)		; Clear links in removed item
	JRST SKPRET##		; Skip return


; Delete item from queue, i.e. unlink it, wherever it is in queue
;	A/ Address of item to be deleted
; Returns +1:
;	B/ Address of item that was predecessor to this one
;	C/ Address of item that was successor to this one
; No other ac's affected

DELITQ::HLRZ B,(A)		; Get this item's predecessor
	HRRZ C,(A)		; Get this item's successor
	HRLM B,(C)		; Fix links between predecessor
	HRRM C,(B)		;  and successor
	SETZM (A)		; Clear links in deleted item
	POPJ P,

; Miscellaneous subroutines

USE SWAPPC

; Flush packet buffer queue
;	A/ Address of queue header
; Returns +1 always.
; Caller must do any necessary race prevention
; Clobbers A-D, PB

FSHPBQ:	HRLM A,0(P)		; Save pointer to queue header
FSHPB1:	PUSHJ P,REMITQ		; Remove item from head of queue
	 POPJ P,		; Queue empty, done
	MOVEI PB,-PBIOBQ(B)	; Got one, set pointer
	MOVSI A,(PBLCKF)	; Is packet buffer locked?
	TDNE A,PBSIZE(PB)
	 PUSHJ P,UNLKPB		; Yes, unlock it
	PUSHJ P,RELPKT		; Release packet buffer
	HLRZ A,0(P)		; Restore queue header pointer
	JRST FSHPB1		; Repeat till queue empty


; Trim unlocked packet buffer and liberate excess
; Callable only from process level
;	PB/ Packet buffer ptr
; Returns +1 always
; Clobbers A-D

TRMUPB:	LDB A,PUPLEN		; Get Pup Length (bytes)
	ADDI A,4*PBHEAD+3	; Add overhead and convert to words
	LSH A,-2
	HRRZ B,PBSIZE(PB)	; Get current size of packet buffer
	SUBI B,(A)		; Compute excess
	CAIG B,^D20		; Worth releasing excess?
	 POPJ P,		; No, forget it
	HRRM A,PBSIZE(PB)	; Reduce size of packet
	PUSH P,PB		; Save packet buffer ptr
	ADDI PB,(A)		; Make ptr to excess block
	MOVEM B,PBSIZE(PB)	; Put size at head of excess
	PUSHJ P,RELPKT		; Release excess block
	POP P,PB		; Restore original PB ptr
	POPJ P,


USE RESPC

; Trim locked packet buffer and put excess on FREOBQ to be freed
; Callable only from interrupt level
;	PB/ Packet buffer ptr
; Returns +1 always
; Clobbers A, B

TRMLPB:	LDB A,PUPLEN		; Get Pup Length (bytes)
	ADDI A,4*PBHEAD+3	; Add overhead and convert to words
	LSH A,-2
	HRRZ B,PBSIZE(PB)	; Get current size of packet buffer
	SUBI B,(A)		; Compute excess
	CAIG B,^D20		; Worth releasing excess?
	 POPJ P,		; No, forget it
	HRRM A,PBSIZE(PB)	; Reduce size of packet
	PUSH P,PB		; Save packet buffer ptr
	ADDB PB,A		; Point to first word of excess
	HRLI B,(PBLCKF)		; Set locked flag
	MOVEM B,PBSIZE(PB)	; Put size at head of excess
	TRNE PB,777		; Split other than at page boundary?
	 PUSHJ P,MLKMCA##	; Yes, lock start of excess block
	PUSHJ P,RELPBI		; Release excess block
	POP P,PB		; Restore original PB ptr
	POPJ P,

USE SWAPPC

; Lock packet buffer
;	PB/ Packet Buffer pointer
; Returns +1
; Callable only from process level
; Clobbers A

LOCKPB:	MOVSI A,(PBLCKF)	; Make sure not already locked
	TDNE A,PBSIZE(PB)
	 BUG(HLT,<LOCKPB: Attempt to lock packet buffer already locked>)
	IORM A,PBSIZE(PB)	; Mark locked
	MOVEI A,0(PB)		; Lock page in which PB starts
	PUSHJ P,MLKMA##
	HRRZ A,PBSIZE(PB)	; Get length of PB
	ADDI A,-1(PB)		; Compute adr of last word in PB
	ANDI A,777000		; Find start adr of page
	CAILE A,(PB)		; Does PB cross page boundary?
	 PUSHJ P,MLKMA##	; Yes, lock page in which PB ends
	POPJ P,


USE RESPC

; Unlock packet buffer
;	PB/ Packet Buffer pointer
; Returns +1
; Must be called NOSKED, INSKED, CHNOFF, or at interrupt level
; Clobbers A

UNLKPB:	MOVSI A,(PBLCKF)	; Make sure really locked
	TDNN A,PBSIZE(PB)
	 BUG(HLT,<UNLKPB: Attempt to unlock packet buffer not locked>)
	ANDCAM A,PBSIZE(PB)	; Mark unlocked
	MOVEI A,0(PB)		; Unlock page in which PB starts
	PUSHJ P,MULKMP##
	HRRZ A,PBSIZE(PB)	; Get length of PB
	ADDI A,-1(PB)		; Compute adr of last word in PB
	ANDI A,777000		; Find start adr of page
	CAILE A,(PB)		; Does PB cross page boundary?
	 PUSHJ P,MULKMP##	; Yes, unlock page in which PB ends
	POPJ P,

; Make Error Pup out of Pup about which it is complaining
;	PB/ Packet buffer ptr (packet buffer must be big enough)
;	A/ Error type
;	B/ String ptr to error text
; Returns +1:  Don't send Error
;	+2:  Error ready to be sent
; Clobbers A-D

MAKERR:	LDB C,PUPTYP		; Get existing Pup Type
	CAIN C,PT.ERR		; Already of type Error?
	 POPJ P,		; Yes, don't give Error for Error
	LDB C,PPUPDH		; Check destination host
	JUMPE C,CPOPJ##		; Don't respond to broadcast Pups
	MOVSI C,PBHEAD(PB)	; Make BLT pointer
	HRRI C,PBCONT(PB)	; Copy header into contents
	BLT C,PBCONT+<PBCONT-PBHEAD>-1(PB)
	LSH A,^D20		; Left-justify Error type
	MOVEM A,PBCONT+<PBCONT-PBHEAD>(PB)  ; Store type, zero arg
	MOVE A,[POINT 8,PBCONT+<PBCONT-PBHEAD>+1(PB)]
	TLC B,-1		; String arg lh = -1?
	TLCN B,-1
	 HRLI B,(POINT 7)	; Yes, make standard byte ptr
MAKER1:	ILDB C,B		; Get byte from string
	JUMPE C,MAKER2		; Jump if end
	IDPB C,A		; Store in Pup
	JRST MAKER1

MAKER2:	MOVEI B,@A		; Compute address of last word
	SUBI B,PBHEAD-1(PB)	; Compute # 36-bit words used
	LSH B,2			; Convert to bytes
	LSH A,-^D33		; Get bytes not used in last word
	SUBI B,(A)		; Compute Pup Length
	ADDI B,2		; Include checksum
	DPB B,PUPLEN		; Store it
	MOVEI A,PT.ERR		; Set Pup Type = Error
	DPB A,PUPTYP
	SETZ A,			; Zero Transport Control
	DPB A,PUPTCB
	PUSHJ P,SWPPRT		; Swap source and dest ports
	PUSHJ P,GPTCKS		; Get pointer to Pup Checksum
	SETO A,			; Store -1 to mean unchecksummed
	DPB A,B
	JRST SKPRET##		; Return +2


; Swap Source and Destination Ports in Pup
;	PB/ Packet buffer pointer
; Returns +1 always
; Clobbers A, B

SWPPRT:	MOVE A,PBHEAD+2(PB)	; Get dest net/host/high socket
	MOVE B,PBHEAD+3(PB)	; Get dest low socket
	LSH A,-4		; Concatenate socket
	LSHC A,-^D16		;  and right-justify dest net/host
	EXCH B,PBHEAD+4(PB)	; Exchange source and dest sockets
	LSH A,^D20		; Left-justify dest net/host
	LSH B,-4		; Right-justify source socket
	ROTC A,-^D16		; Concatenate src low skt to dest net/host
	EXCH A,PBHEAD+3(PB)	; Exchange for dst low skt, src net/host
	LSH A,-4		; Right-justify
	LSH B,^D20		; Left-justify source high socket
	LSHC A,-^D16		; Concatenate src net/host/high skt
	MOVEM B,PBHEAD+2(PB)	; Store in header
	POPJ P,


LS PRSEND,0		; End of Pup resident storage
NGS PNREND,0		; End of Pup nonresident storage

	END
