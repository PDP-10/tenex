;<134>DSKPAK.MAC;179    22-APR-77 15:44:50    EDIT BY TAFT
; Repair problems in mount/dismount failure code
;<134>DSKPAK.MAC;178    11-APR-77 16:01:16    EDIT BY TAFT
; Correct hardware-to-linear drum address conversion in CDSKSA
;<134>DSKPAK.MAC;177    30-MAR-77 14:17:10    EDIT BY TAFT
; Repair bugs in utility command flushing for dead unit and in
; pack moving code
;<134>DSKPAK.MAC;176    28-JAN-77 23:00:01    EDIT BY TAFT
; Fix CHKDSK to account for +2 return from XEFACT
;<134>DSKPAK.MAC;175    11-JAN-77 17:30:34    EDIT BY TAFT
; Change command code 1 from read header to write all records.
; Add bit masks characterizing all operations.
;<133>DSKPAK.MAC;174    12-NOV-75 17:21:39    EDIT BY TAFT
; Fix bugs in MONBLT, UDSKIO, UDSKGF
;<133>DSKPAK.MAC;173    10-NOV-75 21:45:35    EDIT BY TAFT
; Fix assembly errors
;<133>DSKPAK.MAC;172    10-NOV-75 19:47:42    EDIT BY TAFT
; Rewrite boot routines for new save area format.
; MONBLT routine also called from GETSWM and DDTRCL
;<133>DSKPAK.MAC;171    15-OCT-75 16:13:41    EDIT BY TAFT
; Additional DSKMNT fix
;<133>DSKPAK.MAC;170    10-OCT-75 11:42:05    EDIT BY TAFT
; Fix DSKMNT glitches
;<133>DSKPAK.MAC;169     7-OCT-75 16:35:41    EDIT BY FIALA
; Tried to fix mysterious problem in which DSKADR contained 0 immediately
;   after MOUNT.  Changed DSKMNT to store correct arm and sector before
;   KSEEK into DSKADR.
;<133>DSKPAK.MAC;168    17-JUN-75 11:13:26    EDIT BY FIALA
; Fixed bug introduced in version 165 which caused bad spots not to get
;   recorded (bug reported by EAT).
;<133>DSKPAK.MAC;167     6-JUN-75 00:15:49    EDIT BY TAFT
; Change KPARAM to increase preamble length and time-before-reading
;  by 1 word time
;<133>DSKPAK.MAC;166    28-MAY-75 22:52:42    EDIT BY FIALA
; Fixed bug in auxiliary disk pack flushing code which caused low priority
;   utility holding queue not to get flushed.  Fixed bug in pack moving
;   code introduced in version 160.  Changed test at UIOUQL+3 for utility
;   command to save several instructions.
;<133>DSKPAK.MAC;165    20-MAY-75 16:10:26    EDIT BY FIALA
; Moved the timeout after DSEEK2 into DSKIDL.  Added BUGHLT at KIDLE1 to
;   catch command arrivals with commands on queues but no timeouts set.
;   Added more bughlt's in KUDEAD code to catch regular commands on
;   auxiliary packs.  Absorbed the RDCKFC subroutine and changed the code
;   at UNERR.
;<133>DSKPAK.MAC;163    15-MAY-75 01:01:02    EDIT BY FIALA
; Replace bughlt in CONVPK for non-existent pack by a RET (edit missed
;   on version 151).  Changed code for deciding when to record bad spots
;   so that this happens only on the 8th error, not on read-only packs.
;<133>DSKPAK.MAC;162     6-MAY-75 21:44:00    EDIT BY TAFT
; Fix assembly errors
;<133>DSKPAK.MAC;161    22-APR-75 11:14:04    EDIT BY FIALA
; Added omitted CHNON DSKCHN in KUDEAD code.  Fixed possible status
;   anomaly in DSKIDL code to insure that timeout gets started whenever
;   any command is on the disk queues.
;<133>DSKPAK.MAC;160    15-APR-75 17:28:02    EDIT BY FIALA
; Inserted code to handle pack movement of system packs without flushing
;   any commands and without going through the soft restart code.
;   Auxiliary packs still have their commands flushed with code 7.
;   Also signal job 0 through KCFLOG to log new disk configuration.
;<133>DSKPAK.MAC;159    11-APR-75 18:36:06    EDIT BY TAFT
; Fix assembly errors
;<133>DSKPAK.MAC;158    11-APR-75 11:33:36    EDIT BY FIALA
; Release virtual unit associated with phyical unit when moving a
;   pack to another physical unit.  CALL DSKRST and SWPRST instead of
;   doing complete SYSRST.  Add NOREP flag to suppress bad spot update
;   by job 0, logging report of errors, and soft error retries.  Shrunk
;   size of microcode command to 4 bits and of attempt count to 4 bits.
;<133>DSKPAK.MAC;156     4-APR-75 15:30:52    EDIT BY TAFT
; Go straight to SYSRST from PCKDWN code
;<133>DSKPAK.MAC;155    24-MAR-75 15:28:19    EDIT BY FIALA
; Prevented KDOINT from issuing manual disk interrupt when unit is
;   recovering from offline condition and detect offline condition and
;   recover at KGOF.
;<133>DSKPAK.MAC;154    21-MAR-75 01:25:18    EDIT BY FIALA
; Fixed bugs in disk unit anomaly counting at DSKCK4 and in utility sector
;   queue flushing at NOCOMM+2
;<133>DSKPAK.MAC;153     6-JAN-75 23:36:55    EDIT BY TAFT
; Fix glitches in handling of read-only condition
;<132>DSKPAK.MAC;152    24-NOV-74 18:27:26    EDIT BY FIALA
; Fixed bug in utility disk I/O error return for wrong pack mounted.
;<132>DSKPAK.MAC;151    18-NOV-74 21:11:21    EDIT BY FIALA
; Fixed read-only error so that it KBUGH's for system packs and gives
;   a code 15 error for utility I/O.  Put in fail return in CONVPK and
;   its calls to handle auxiliary pack going offline before bad spots
;   can be recorded.
;<132>DSKPAK.MAC;150     4-NOV-74 19:39:07    EDIT BY TAFT
; Fix bug in sector queue copying patch
;<132>DSKPAK.MAC;149     4-NOV-74 17:55:54    EDIT BY FIALA
; Fixed bug in failing to check for page reassignment when copying to
;   sector queue and in extraneous POP in RDCKFC code and removed
;   DSKQ and DSKLQ check in DSKIDL.
;<132>DSKPAK.MAC;147    23-OCT-74 05:58:46    EDIT BY FIALA
; Fixed bug at DSKII1-1 failing to fix low pri. statistics counters
;   during DSKRST
;<132>DSKPAK.MAC;146    22-OCT-74 04:15:30    EDIT BY FIALA
; Fixed bugs at DSKDMN+5 and in UDSKGF, changed utility I/O command
;   pickup timeout to 30 seconds, increased # utility I/O buffers, replaced
;   utility I/O error code 1 (checksum error) by error codes 1, 12, 13,
;   and 14 for header, UN, and data checksum and synchronization errors.
;<132>DSKPAK.MAC;144    10-OCT-74 11:22:01    EDIT BY FIALA
; Repairs to new disk driver.
;<132>DSKPAK.MAC;128     3-OCT-74 11:34:43    EDIT BY FIALA
; Rewrote disk driver to incorporate new features including:
; a.  Optional read-and-check after writing DI or directory pages
; b.  Manually initiate interrupt when new operation can start immediately
; c.  Allow full hardware control from utility I/O
; d.  Permit issuer of utility I/O to continue without waiting for
;     completion and to queue an indefinite no. of utility commands.
;     Later, another utility I/O command picks up the results.
; e.  High and low priority for both regular and utility I/O
; f.  Lower cased all the comments.
; g.  Put in additional measurement stuff to determine the time
;     between commands and the distribution of operations.
; h.  Made disk statistics a GETAB table, put more error counters in
;     existing disk errors GETAB table.
; i.  Parameterized DSKBLT to use SWPMA0 as address of swappable monitor.
; j.  Put in shortest-seek-time-first scan.
; k.  Code to handle unique name comparison error.
; l.  Reduce storage and wait less time for KON in DSKINI and DSKRST.
; m.  Made errors which crash-halt Tenex for system packs return error
;     codes for auxiliary packs.
; n.  Made all instances of KBUGH continuable following correction of problem.
; o.  Put in code to permit moving a system disk pack to another drive
;     following an irrecoverable drive failure.
; p.  Replaced most of DSKBLT by a loop using UDSKIO.
; q.  Added # file system tracks/unit and # file system packs to DSKPAR
;<132>DSKPAK.MAC;119    29-JUL-74 01:50:08    EDIT BY TAFT
; Rewrite event logging subroutine.
;<132>DSKPAK.MAC;117    24-JUL-74 16:08:21    EDIT BY TAFT
; TODCLK no longer external
;<132>DSKPAK.MAC;113    22-JUL-74 07:02:52    EDIT BY FIALA
; Moved CHKDSK here from SWPMON, NDSKPR, E_UNIT, F_IOS.
;<131>DSKPAK.MAC;112    29-MAY-74 12:14:25    EDIT BY TAFT
; Add LOGCNF to log current disk configi., date, and time in fact file
; Change CHKDSE to DSKEVF throughout.   Flush some JSR BUGHLTs.
; More :: entries.  Check UDSKIO addresses against NHIPG in PAGEM.
; Put back DWRBIT, fix DSKPAR conflict, add END

IFDEF DSKCHN,<
; Disk pack driver, linear-hardware address conversion, monitor dump/boot
; routines, auxiliary disk pack mount/dismount, and event logging

;Written by E. R. Fiala, 12 March 1974, major revision 8 October 1974

;This disk driver is differently organized from the RPO2 driver by D. Murphy
;and Maxc driver by C. Simonyi.  The driver uses a shortest-seek-time-first
;scan of arm pos. on each unit, doing all commands at an arm pos. before
;going on to the next (earlier drivers used cyclic scan).  Sector
;optimization has been added.  In addition, the sector interrupts for
;each unit are diasabled when no commands are waiting to reduce overhead.
;High and low priority queues are used for both regular and utility
;I/O commands, so commands for which completion time is less important
;(writes) can be put lower priority than those for which considerable
;resources are tied up while waiting (reads).  Under demand paging the
;high priority disk queues seldom are longer than one or two entries
;because there is at most one read/fork in the balance set.  Formerly,
;there were times of heavier traffic when page management put a burst of
;write requests on the queues.  These are now deferred until reads are
;done unless one fortuitously occurs at the same arm pos. as a read.

;The swap area (DRMDMY) is distributed uniformly over the central arm
;positions of all disk drives, allocated as a single drum unit with
;NSECS*NPACKS sectors and NSWPTK*NPGTK bands.  This tends to assign
;swapping pages for each user uniformly over drives and sectors, but
;does not optimize arm position.  Previous allocators put the swap area
;on a single drive, causing nearly all the traffic to be on that drive.
;Use of the central arm positions reduces the average seek time.

;The DSK allocation has also been changed.  Both old and new allocators
;try to keep pages of a file at a single arm pos. of a pack.  When
;storage at that arm pos. is used up, the old allocator advances to the
;next arm pos. of that pack.  This causes newly created files to cluster
;on a single pack, increasing traffic density to that drive.  The new
;allocator cycles through all drives before advancing arm pos.  Also,
;bit table counters have been merged with the bit table to save
;1 word/arm pos.

;Save areas have been divided uniformly among all drives and appear on
;the largest numbered arm positions.  Formerly, save areas were all
;on the last drive.

;Disk bad spots on each pack are kept on record 0 of that pack in 18-bit
;bytes, terminated by a 0 byte.  Formerly, these had to be kept on a
;file (i.e., a tape file) which was cumbersome and made no provision
;for varying disk packs in the system.  Diagnostic programs which
;check out packs are responsible for initializing record 0.  Subsequently,
;Tenex appends pages to the list, when more than 7 read retries are required.

;Error recovery for drive failures such as header mismatch and sector
;timeout has been improved to recover these whenever possible.
;Irrecoverable drive failures result in a pertinent message on the cty.
;The system then stops until the operator asks it to resume or to move
;the disk pack to another drive.  Auxiliary pack drive failures are
;always passed back as command errors, never halting Tenex.

;MOUNT and DSMNT commands for DPK units have been added so that auxiliary
;disk packs may be used for i/o, in addition to system packs.  DSKOP
;is currently the only way to manipulate data on auxiliary packs.

;There are some remaining rough spots in this driver/allocator.
;First, the DRMDMY allocator could be made intelligent about arm positions.
;Secondly, save areas should be precreated files in the <SYSTEM>
;directory.  Save areas are purely a crock to make Microexec simpler,
;so there should not be any special code for them inside Tenex.
;Thirdly, initialization of disk unit status blocks is driven
;by wired-in parameters.  A better way to do this would be to assemble
;the unit blocks directly, possibly differently for different units.
;Then initialization need not depend on global parameters
;such as NSECS, NARMS, NSURFS.  Other dependencies on these parameters
;should also be removed from the code.  Fourthly, the UN and PD fields
;of the disk sector aren't used.  There is a scheme by which DST can be
;replaced by a CST4 plus two bits/disk page (dirty and allocated) by
;using the PD field on each disk record.  Fifthly, a complete file system
;should be added on the auxiliary disk packs.  Sixthly, main memory
;should not be allocated until just before a disk read commences.
;Allocating a page at the time a read is queued ties up that storage
;during the latency time (averaging 30 msec).

; Since the BUGCHK and BUGHLT messages are on a file, the disk hardware
; has to be working to type them out.  Consequently, unit failures
; usually stop the system with KBUGH macro below instead of BUGHLT,
; in order to get the bug message typed out immediately and halt until the
; hardware problem is fixed.  Simply proceed from the halt to resume.
; Arguments are a Sixbit message string ($ = CR-LF) and a resume loc.
DEFINE KBUGH(FOO,RLOC,%TAG,%NAM)
<	JSYS [XWD BUGHLT,%TAG]
DEFINE %NAM
<	JUMPA RLOC
%TAG:	MOVEM A,HLTASV
	JSP A,DSKBUG
	SIXBIT @FOO/@
	IF2,<PURGE %TAG>>
	KBUGR <%NAM>
>

DEFINE KBUGR(..XXX)
<	KBUG2<..XXX>,
>

DEFINE KBUG2(..NEW,..OLD)
<DEFINE KBUGR(..XXX)
<	KBUG2<..XXX>,<..OLD
	..NEW
>>>

;CHKSN==1		; Include sector checking if defined
;DSKEVF==1		; Include calls to event buffer if defined
; EVENT is called for every KSEEK (disk address at DSKADR(UNIT)),
; KGO (command pointer in A), and command completion (error status in A,
; command status in B, command pointer in C).
;CHKDIP==1		; Check directory pages after writing if defined
SEEKST==1		; Assemble seek statistics (big table) if defined
KCHOKE==3		; Limits no. busy units

AA=10
BB=11

; Bit masks characterizing disk operations
; If bit n is set, then command n has the specified attribute.
WRTOPS:	1B0+1B1+1B3+1B6+1B7+1B8  ; Operations that write on the disk
DATOPS:	1B1+1B4+1B5+1B6+1B7+1B8  ; Data operations that touch main memory
RDOPS:	1B4+1B5	; Read operations that touch main memory, thereby dirtying it

; Disk driver storage
LS KERRQ,1		; holding queue for completed utility commands
LS BSTARM,1		; Best arm displacement in seek computation
LS DSKNTR,1		; # of units currently transferring
LS NEWBS,1		; New bad spot
LS DSKBLK,1		; Bit table lock
LS KTIMT,2		; Temporary for computing KTIME as below
LS HLTASV,1		; Temporary for KBUGH expansions
LS KAGTIM,1		; Time at which next anomaly count LSH -1 occurs
	UBUFS==20	; # utility I/O buffers
LS UDSKBK,UBUFS*UBLKSZ	; Command buffers for UDSKIO readin
LS UBADCM,11		; Buffer for bad command pickup by DSKBLT

; Disk statistics GETAB table
LS DIRWRT,1		; # writes of DI and directory pages
LS KNINTS,1		; # disk interrupts
LS KMANRQ,1		; # manually initiated interrupts
LS KTSTRT,1		; # KGO's
LS KSQ,2		; # (high/low pri.) reg. commands to sector queue
LS KHQ,2		; # (high/low pri.) reg. commands to holding queues
LS USQ,2		; # (high/low pri.) util. commands to sector queue
LS UHQ,2		; # (high/low pri.) util. commands to holding queues
LS KTIME,2		; Total wait to finish/remove (high/low pri.) reg. commands
LS UTIME,2		; Total wait for (high/low pri.) util. commands
LS CTIME,1		; - total execution time (-CTIME/sum[<KTFIN+UFIN+KIOREM>] =
			; intercompletion time
LS WTRAN,2		; # interfering/non-interfering writes
			; (interferes with computing when NRUN .G. 0)
LS RTRAN,2		; # interfering/non-interfering reads
LS KTFIN,4		; # (high/low pri., swap/file) reg. completions
LS KIOREM,2		; # (high/low pri.) removals from regular queues
LS UFIN,2		; # (high/low pri.) util. completions
LS NFSEEK,1		; # file area seeks
LS NSSEEK,1		; # swap area seeks
LS SKDISP,1		; Total arm displacement of all seeks
LS SADISP,1		; Total distance from swap area for file area seeks
NDSKW==:41		; # statistics words for GETAB

; Do not reorder error words, used by GETAB
NDSKEW==:21		; No. error words for GETAB
LS DSKRCE,1		; Count of recoverable errors
LS DSKRER,4		; Disk address, header, m.m. address, error bits
			; merged with retry count in bits 24-29
LS DSKNRE,1		; Count of non-recoverable errors
LS DSKLER,4		; Command words and error bits last non-rec. error
LS MISFIN,1		; # missed command completions
LS DSKSEQ,1		; # sector sequence errors (should occur only when
			; man. initiated ints receive service accross
			; a sector transition
LS KREWRT,1		; # rewrites after read-and-check failures
LS SKWRNG,1		; # seek-to-wrong-arm-position recalibrates done
LS DSKTMO,1		; # sector-interrupt-timeout recalibrates
LS MALWTC,1		; # times allocator failed for utility I/O
LS DRPOFF,1		; # times unit has dropped offline

SWAPCD

; Disk parameter table
DSKPAR:: 0		; (0) lowest track used for files
	NTRACK		; (1) highest track + 1 used for files
	NSECS*NSURFS	; (2) # sectors/cylinder
	1000		; (3) # words/sector
	NTRACK/NPACKS	; (4) # file system tracks/unit
	NPACKS		; (5) # file system packs
NDSKPR==:.-DSKPAR

RESCD

; Each disk unit has a status block laid out as follows:
INTDSP:	JSYS 1			;-4  Interrupt instruction (1_.+1)
	XWD PI4R,2		;-3 (2_.+1)
	MOVEM UNIT,PI4AC+5	;-2
	JSP UNIT,DSKSV		;-1  loading unit with DSKBL pointer

DSKSQ==0	; Sector queue 0 in r.h. and command status in l.h.
	CBBUSY==400000	; CBBUSY=1 means the CB has a command in it
	DSKUIO==200000	; Utility I/O request
	NOWAIT==100000	; Don't save command after completion
	NOUNLK==40000	; Don't unlock page after transfer (util. I/O)
	CSAVE==20000	; Save command even if no error (util. I/O)
	HIPRI==10000	; High priority command (util. I/O)
	KFIN==4000	; Disk utility command finished
	UCGET==CBBUSY	; Utility I/O get UN and PD from user bit
	UCRET==DSKUIO	; Utility I/O return command to user bit
	NOREP==2000	; Prevent retries, job 0 report, and bad spot page update
	; Bits 9-12 error count, 13-17 error code
DSKCB==1	; Command buffer 0
; DSKSQ+QDCBL+1 is sector queue 1
; DSKCB+QDCBL+1 is command buffer 1, etc., for NSECS altogether
QDCBL==13+5	; Length of command buffer rounded up to power of 2
	QDSKAD==0	; Disk command (4-8) and disk address
	QHDR==1		; Header word read by hardware
	QUN==2		; First of 4 unique name words
	QPD==6		; First of 2 predata words
	QCORAD==10	; Word count (0-14) and main mem. addr. (15-35)
; Additional stuff for utility commands only
	FSTAMP==11	; Fork no. of command issuer
	UBLKSZ==13	; Size of utility block for allocator
UDSKSQ==12	; Utility sector 0 queue in r.h., command in prog. in l.h.

; Sandwich in these cells after queues and buffer for sector 0.
; Hardware status block filled by microprogrammed disk driver (3 words)
DSKSTS==13	; Command and hardware status at last sector int.
DSKFIN==14	; Command completion pointer
DSKADR==15	; Next available disk address
DSKQ==16	; Holding queue for commands at other arm positions
DSKLQ==17	; Holding queue lower priority than DSKQ

; After queues and buffer for sector 1
UDSKQ==33	; Utility I/O command queue
UDSKLQ==34	; Holding queue lower priority than UDSKQ
DSKLSV==35	; Time of last int. service or recalibrate (0 = ints. off)
DSKKPR==36	; KPARAM for SLOC JMC
DSKLSN==37	; Next sector no. expected, 1B0 set if sector ints. off

; After queues and buffer for sector 2
DSKPAK==53	; MAXKA for online JMC
DSKBSY==54	; # outstanding KGO's
CURARM==55	; Current arm position, B0 = 1 means recalibrate,
		; B0 = 1 with B1 = 1 means recalibrate requested,
		; B0 = 1 with B2 = 1 means unit dead action requested
SQPTR==56	; Pointer to <NSECS-1>*QDCBL+ displacement of unit block
KCLK1==57	; Temporary used in determining time/command
KSSTAT==60	; # seek failures bits 12-23, # seek-to-wrong-arm-pos.
		; bits 24-35, total recalibrates (= timeouts + seek failures +
		; seek-to-wrong-arm-pos.) bits 0-11.

LDSKBL==4+6-5+NSECS*QDCBL; Length of DSKBL
LS DSKBL, NDVMAX*LDSKBL
LS PDSKBL,NDVMAX	; Holds pointers converting unit no. to DSKBL pointer

BDSKBL:	FOO==0		; Pointers to convert unit no. to DSKBL pointer
	REPEAT NDVMAX,<XWD FOO,DSKBL+4+<LDSKBL*FOO>
	FOO==FOO+1>

; Disk driver initialization.  Must not clobber G.
; Microexec passes the disk configuration to Tenex in DRIVTB and KPAKNO.
; Tenex initializes the other half of the DRIVTB table so that
; it can conveniently map between virtual and physical unit numbers.
; However, Tenex does not use KPAKNO after initialization except to
; update it when auxiliary packs are mounted/dismounted for soft restart
DSKINI:: IFNDEF DRMCHN,<CALL DRMINI##>	; Initialize swap bit table
	IFDEF DRMCHN,<SKIPN DISKP##
	RET>
	SETOM UBSPG		; Unlock BSPG (used by DSKOP)
	SETOM DSKBLK		; Unlock disk bit table
	HRLZI C,-NDVMAX
DSKII8:	MOVE D,BDSKBL(C)
	MOVEM D,PDSKBL(C)	; Initialize pointers to disk unit blocks
	MOVEI D,(C)
	CAIGE D,NPACKS		; Flush packs above configuration
	JRST DSKII5		; Make sure enough packs in config.
	SETOM KPAKNO##(C)
	SETOM DRIVTB##(C)
DSKII6:	AOBJN C,DSKII8
DSKRST::HRLZI C,-NPACKS		; Loop over all virtual units
DSKII2:	MOVE A,DRIVTB(C)
	HRLM C,DRIVTB(A)	; Store virt. unit
	HRLZ B,KPAKNO(C)
	HRRI B,KMAX
	MOVE UNIT,PDSKBL(A)
	MOVEM B,DSKPAK(UNIT)
	AOBJN C,DSKII2
; All of the LS and GS storage is zeroed by SYSGO, but SYSRST requires
; initialization of DSKLSV, DSKFIN, DSKQ, DSKSQ's, DSKLSN, and DSKBSY
; but not of the utility disk I/O stuff or of command buffers involved
; in utility I/O.  SWPRST restarts regular disk I/O from CST status bits.
	SKIPL UBSPG
	  BUG(HLT,<BSPG locked at restart>)
	SKIPL DSKBLK
	  BUG(HLT,<Disk bit table locked at restart>)
	SETZM DSKNTR		; 0 # units transferring
	HRLZI C,-2		; High and low pri. counters fixed
; Fix up completion, removal and timing counters for statistics
DSKII1:	MOVE A,KHQ(C)
	ADD A,KSQ(C)		; # requests queued
	SUB A,KIOREM(C)		; - # disposed of
	SUB A,KTFIN(C)		; Swap area completions
	SUB A,KTFIN+2(C)	; File area completions
	ADDM A,KIOREM(C)	; = # flushed by SWPRST
	IMUL A,TODCLK		; Assume flushed this instant
	ADD A,KTIMT(C)		; = Total time on queues
	ADDM A,KTIME(C)		; Adjust total waiting time
	SETZM KTIMT(C)		; Zero temporaries
	AOBJN C,DSKII1		; Do both high and low pri.
	HRLZI C,-NDVMAX		; Now switch to physical unit loop
DSKII4:	MOVE UNIT,PDSKBL(C)
	SETZM DSKSTS(UNIT)	; 0 this for DSKUPT
	SETZM DSKLSV(UNIT)	; 0 prevents timeout of sector ints
	SETZM DSKFIN(UNIT)
	SETZM DSKQ(UNIT)	; No commands on holding queue
	SETZM DSKLQ(UNIT)	; No commands on low priority holding queue
	MOVEI A,QDCBL*<NSECS-1>(UNIT)
	MOVEM A,SQPTR(UNIT)	; Initialize sector queue pointer
	HRLZI B,DSKUIO
DSKII0:	HLLZS DSKSQ(A)		; No commands on sector queues
	TDNN B,DSKSQ(A)		; Utility I/O in progress?
	SETZM DSKSQ(A)		; No.  Clear command buffer
	SUBI A,QDCBL
	CAIL A,(UNIT)
	JRST DSKII0
	SETOM DSKBSY(UNIT)	; Init count of # outstanding KGO's - 1
	SETOM DSKLSN(UNIT)	; Next sector (neg. prevents seq. check)
	MOVEI B,-4(UNIT)	; Address of interrupt instruction
	HRLI B,INTDSP		; "FROM" address for BLT
	BLT B,-1(UNIT)		; Set up four-word interrupt routine entry
	MOVEI B,-4(UNIT)	; Relocate two instrucitons
	ADDM B,-4(UNIT)		; JSYS .+1
	ADDM B,-3(UNIT)		; XWD PI4R,.+1
	CALL DOKON
	AOBJN C,DSKII4

	MOVEI A,^D20000
	SOJG A,.		; Wait awhile
	HRLZI C,-NDVMAX
KIISKL:	MOVE UNIT,PDSKBL(C)
	SKIPN D,DSKPAK(UNIT)	; Check for units up OK
	JRST DSKII7
	MOVE B,DSKSTS(UNIT)	; Sector status written, even though ints. off
	TLNE B,10000		; Read-only condition?
	  CALL RONOTE
	HRRZS A,CURARM(UNIT)
	DPB A,[POINT 9,D,32]
	KSEEK D,
	  KBUGH(<$INITIAL SEEK REJECT>,KIISKL)
	DPB A,[POINT 9,DSKADR(UNIT),32]
DSKII7:	AOBJN C,KIISKL
	RET

; Subroutine to put the disk unit (C) online.
; UNIT and DSKPAK(UNIT) must be setup.  Clobbers A.
DOKON:	PUSH P,B
	MOVEI B,-4(UNIT)	; Address of interrupt instruction
	API B,DSKCHN*100(C)
	MOVEI B,(C)
	LSH B,4
	MOVEI A,DSKSTS(UNIT)
	SLOC A,413(B)		; KBLK (20*unit + 413) = DSKBL pointer
	MOVE A,[64430620700]
	MOVEM A,DSKKPR(UNIT)
	SLOC A,414(B)		; KPARAM (20*unit + 414)
	POP P,B
	SKIPN A,DSKPAK(UNIT)	; Put unit online unless DSKPAK contains 0
	RET
	KON A,(C)
	  JSYS [XWD BUGHLT,DSKFAT] ; Impossible
	RET

; Tell operator that unit is read only
RONOTE:	MOVEI A,[SIXBIT '$READ-ONLY/']
	JSYS [XWD KBUGT,KBUGT0]
	RET

; Check for improper disk configuration
DSKII5:	HRROS A,DRIVTB(C)	; Mark virtual units non-existent
	MOVEI A,(A)
	CAIGE A,NDVMAX		; Phys. unit must be .L. NDVMAX
	JRST DSKII6
	MOVEI A,[SIXBIT '$DISK CONFIGURATION HAS TOO FEW PACKS$/']
	JSYS BUGMSG##
	JSYS [XWD BUGHLT,KHALT]

; Subroutine used by expansions of KBUGH macro
DSKBUG:	JSYS [XWD KBUGT,KBUGT0]
	SUBI A,3		; Point A at the resume instruction
	EXCH A,HLTASV
	HALT @HLTASV

; Very bad errors come here (unsafe, offline, deselected, seek failure)
; Halt so that crash recovery doesn't try to restart from this
DSKFAT:	JSYS [XWD KBUGT,KBUGT1]
KHALT:	HALT BUGHLT+1

; Call with JSYS [XWD KBUGT,KBUGT0] or with JSYS [XWD KBUGT,KBUGT1]
; At KBUGT0 type the SIXBIT message pointed to by A, then at KBUGT1
; type " TROUBLE WITH DISK PACK n" and then return
LS KBUGT,2
KBUGT0:	PIOFF
	JSYS BUGMSG		; Type SIXBIT message pointed to by A
KBUGT1:	MOVEM A,KBUGT+1
	PIOFF
	MOVEI A,[SIXBIT ' TROUBLE WITH DISK PACK /']
	JSYS BUGMSG
	HLRZ A,DSKPAK(UNIT)
	JSYS BUGOPT##
	MOVEI A,[SIXBIT '$/']
	JSYS BUGMSG
	MOVE A,KBUGT+1
	JRSTF @KBUGT

SWPTRK==<NTRKOP-NSWPTK>/2	; Swapping on middle arm positions

; Disk address of <SYSTEM>INDEX file
DIDSC0==<SWPTRK-2>*NPGTK*NPACKS	; Put next to swap area
DIDSCI::XWD 30, DIDSC0
GS DIDSCA,1


; Convert area no. in A to starting disk address.
; Return phys. unit no. in LH, starting disk address in RH.
ARTOAD::CAIL A,NAREAS
	BUG(HLT,<Illegal save area>)
	PUSH P,C
	PUSH P,B
	MOVE C,SYSUN##
	MOVEI B,NAREAS(C)
	IDIVI B,1(C)		; No. areas/pack in B
	IDIVI A,(B)		; Area no. on pack in B, unit in A
	IMULI B,NTRKPA		; Track displacement of area
	MOVN B,B
	MOVEI B,NARMS-NTRKPA(B)	; Save areas are largest numbered tracks
	LSH B,3			; Position track field
	HRL B,DRIVTB##(A)	; Phys. unit to LH for TENEX
	MOVE A,B
	POP P,B
	POP P,C
	RET


; Enter here to increment disk address in A
IDSKA::	MOVEI B,1

; Offset disk address in A by no. pages in B, clobbers B
DSKOFS::PUSH P,C
	PUSH P,D
	IDIVI B,NSECS
	LDB D,[POINT 3,A,35]	; Get sector
	ADDI D,(C)
	CAIGE D,NSECS
	JUMPA DSKOF1
	SUBI D,NSECS
	ADDI B,1
DSKOF1:	DPB D,[POINT 3,A,35]	; Save sector
	IDIVI B,NSURFS
	LDB D,[POINT 6,A,23];	; Get surface
	ADDI D,(C)
	CAIGE D,NSURFS
	JUMPA DSKOF2
	SUBI D,NSURFS
	ADDI B,1
DSKOF2:	DPB D,[POINT 6,A,23]	; Set surface
	IDIVI B,NARMS
	LDB D,[POINT 9,A,32]	; Get arm
	ADDI D,(C)
	CAIGE D,NARMS
	JUMPA DSKOF3
	ADDI B,1
	SUBI D,NARMS
DSKOF3:	DPB D,[POINT 9,A,32]	; Set arm
	HRLZI B,(B)
	ADD A,B			; Offset virtual unit
	POP P,D
	POP P,C
	RET

; Convert linear file address in A to hardware disk address
; order of significance is sector, surface, unit, then arm.
; Clobbers B, C
CVDSK::	TLZ A,DSKMSK
	CAIL A,NTRACK*NPGTK
	  BUG(HLT,<Illegal linear disk address>)
	IDIVI A,NPGTK
	IDIVI B,NSECS		; Surface in B, sector in C
	LSH B,14		; Position surface
	IORI C,(B)
	IDIVI A,NPACKS		; Get unit no. in B, arm pos. in A
	CAIL A,SWPTRK		; Offset above swapping area
	ADDI A,NSWPTK
	LSH A,3			; Position arm pos.
	HRL A,DRIVTB(B)		; Get physical unit no.
	IORI A,(C)
	JRST (D)


; Convert linear address in A to hardware address.  Clobbers B, C.
CDSKH:	TLNE A,10		; File memory or swap memory?
	JUMPA CVDSK		; File memory

; If swapping to disk, disk address disguised as drum address in A.
; Convert to hardware address.  Linear progression in band no.
; increments the surface first, then the arm position; in the sector,
; the sector first, then the unit.
	IFDEF DRMCHN,<SKIPE DRUMP	; Really swapping on disk?
	  BUG(HLT,<DSKIO-bad swap address>)>
	HRRZS B,A
	ANDI B,77		; unit*NSECS + sector
	CAIL B,NSECS*NPACKS
	  BUG(HLT,<Bad sector no. in drum address>)
	IDIVI B,NSECS		; Get unit in B, sector in C
	HRL C,DRIVTB(B)		; Phys. drive no. to C[15,17]
	LSH A,-6		; "Band" = <arm-SWPTRK>*NSURFS + surface
	CAIL A,NSWPTK*NSURFS
	  BUG(HLT,<Bad band no. in drum address>)
	IDIVI A,NSURFS		; Surface in B, arm-SWPTRK in A
	ADDI A,SWPTRK		; Middle arm pos. for swapping
	LSH A,3
	IOR A,C
	LSH B,14
	IOR A,B			; Physical unit in l.h.
	JRST (D)

; Convert the pack or phys. unit no. in l.h. of A to virt. unit no. in C
CONVPK:	TLZ A,777400		; Clear any garbage bits
	HLRZ C,A		; Get pack no. or phys. unit no.
	CAIL C,100		; Pack no.'s are .GE. 100
	JUMPA CVPK0		; Pack no.
	CAIL C,NDVMAX		; Unit no.'s .L. NDVMAX
	BUG(HLT,<Illegal physical unit no. in disk address>)
CVPK2:	HLRZ C,DRIVTB(C)	; Get virtual unit no.
	TRNN C,777770		; Unit on-line?
	AOS (P)			; Ok return
	RET

CVPK0:	HRLZI C,-NDVMAX
CVPK1:	MOVE B,PDSKBL(C)
	MOVE B,DSKPAK(B)
	XOR B,A
	TLNN B,377
	JUMPA CVPK2
	AOBJN C,CVPK1
	RET


SWAPCD

; Convert hardware address in A to linear swapping address (clobbers B, C)
CDSKSA:	CALL CONVPK		; Convert pack no. to virt. unit no.
	  BUG(HLT,<No such virtual disk unit>)
	IMULI C,NSECS
	LDB B,[POINT 3,A,35]
	ADDI B,(C)		; Pseudo-sector = C*NSECS + sector
	LDB C,[POINT 9,A,32]	; Arm pos.
	LDB A,[POINT 6,A,23]	; Surface no.
	SUBI C,SWPTRK		; Arm-SWPTRK
	IMULI C,NSURFS		; <Arm-SWPTRK>*NSURFS
	ADDI A,(C)		; <Arm-SWPTRK>*NSURFS + surface
	LSH A,6
	ADDI A,(B)
	RET

; Convert hardware address in A to linear file address in A (clobbers B, C)
CDSKVA:	CALL CONVPK		; Convert pack no. to virt. unit no. in C
	  BUG(HLT,<No such virtual disk unit>)
	LDB B,[POINT 9,A,32]	; 24-32 is arm pos.
	CAIL B,SWPTRK
	SUBI B,NSWPTK
	IMULI B,NPACKS
	ADDI B,(C)
	IMULI B,NPGTK
	LDB C,[POINT 6,A,23]	; Surface no.
	IMULI C,NSECS
	ADDI B,(C)
	ANDI A,7
	ADD A,B
	RET

; Log current disk configuration in fact file
CNFLEN==3+<NDVMAX+1>/2
NGS CNFBUF,CNFLEN
GS KCFLOG,1		; Job 0 flag

LOGCNF::MOVSI A,(307B8)		; Fact entry type
	MOVEM A,CNFBUF
	SETZM CNFBUF+1		; Clear the block
	MOVE A,[CNFBUF+1,,CNFBUF+2]
	BLT A,CNFBUF+CNFLEN-1
	GTAD			; Current date&time in 3rd word
	MOVEM A,CNFBUF+2
	MOVE A,[POINT 18,CNFBUF+3] ; Set byte ptr for storing pack numbers
	SETZM KCFLOG
	MOVSI B,-NDVMAX		; Loop for all physical units
LOGCN1:	HLRZ C,DRIVTB(B)	; Get logical unit for physical unit
	CAIN C,-1		; Pack mounted on unit?
	TDZA C,C		; No, return zero
	HRRZ C,KPAKNO(C)	; Yes, return pack number
	IDPB C,A		; Store in block
	AOBJN B,LOGCN1		; Loop
	MOVE A,[-CNFLEN,,CNFBUF]
	EFACT			; Write fact entry in file
	  CAI
	RET

; JSP D,MNTCHK returns POPJ P, (=caller's caller + 1) on errors,
; 0(D) if a mount or dismount is legal
MNTCHK:	MOVE A,CAPENB
	TRNN A,WHEEL!OPER
	JRST WHEELX		; Must be wheel or operator
	HLRZ C,13		; 13 = DEV in file system
	CAIL C,NDVMAX
	  RET			; Illegal unit no.
	HLRZ A,DRIVTB(C)	; Get logical unit
	CAMG A,SYSUN##		; Must not be a system pack
	  RET			; Device not available
	MOVE UNIT,PDSKBL(C)
	JRST (D)

; Mount disc pack.  Get here with XWD unit no., dispatch in DEV and
; pack no. in user B, device characteristics word in C
DSKMNT:: JSP D,MNTCHK		; Get DSKBL ptr in UNIT, phys. unit in C
	CAIN A,-1		; Must not be mounted auxiliary pack
	SKIPE DSKPAK(UNIT)
	  RET
	UMOVE A,B		; Get pack #
	CAIL A,100
	CAILE A,377
	  RET			; Illegal pack no.
	HRLZI B,-NDVMAX
	CAMN A,KPAKNO(B)	; Pack no. must be # online pack no.'s
	  RET
	AOBJN B,.-2
	HRLZI B,-NDVMAX
	SKIPL KPAKNO(B)		; Accept first unused virtual unit #
	AOBJN B,.-1
	JUMPGE B,CPOPJ##	; Return if no free units
	HRLZI D,(A)
	HRRI D,KMAX
	MOVEM D,DSKPAK(UNIT)
	SETZM CURARM(UNIT)
	HRLM B,DRIVTB(C)	; Set virtual unit for physical
	HRRM C,DRIVTB(B)	; Set physical unit for virtual
	MOVEM A,KPAKNO(B)	; Record pack number
	CALL DOKON		; Put unit (C) online
	ANDCMI D,7777		; Select arm pos. 0, sector 0
	MOVEM D,DSKADR(UNIT)	; In case of funny interrupt...
	MOVEI A,^D30		; Wait one revolution for sector sync
	DISMS
	KSEEK D,
	 JRST UNMOUN		; Failed, undo mount and return
DSKDM0:	SETOM KCFLOG		; Signal job 0 to log disk configuration
	JRST SKPRET##		; Return +2

; Dismount disc pack
DSKDMN:: JSP D,MNTCHK		; Get DSKBL pointer in UNIT, phys. unit in C
	SKIPN DSKQ(UNIT)	; Holding queue busy?
	SKIPE DSKLQ(UNIT)	; Lower priority holding queue busy?
	  RET			; Cannot dismount (busy)
	SKIPN UDSKQ(UNIT)	; Utility queue busy?
	SKIPE UDSKLQ(UNIT)	; Or lower priority utility queue?
	  RET			; Yes, cannot dismount
	MOVE D,SQPTR(UNIT)
DSKDML:	SKIPN DSKSQ(D)		; Sector queue busy?
	SKIPE UDSKSQ(D)		; Or utility sector queue?
	  RET			; Yes, cannot dismount
	SUBI D,QDCBL
	CAIL D,(UNIT)
	JRST DSKDML		; Loop over all sectors
	PUSHJ P,UNMOUN		; Unmount disk pack
	JRST DSKDM0		; Log configuration and return

; Unmount disk pack -- UNIT/ DSKBL pointer, C/ physical unit #
UNMOUN:	SETZM DSKPAK(UNIT)
	HLRZ D,DRIVTB(C)	; Get virtual unit
	SETOM KPAKNO(D)		; Free up virt. unit
	HLLOS DRIVTB(D)		; Turn-off phys. unit no.
	HRROS DRIVTB(C)		; Turn-off virt. unit
	KOFF (C)
	POPJ P,

RESCD

; DISK I/O DRIVER - Called from PAGEM
; A/ core page no. in 18-35, DWRBIT in 0
; B, C, D, and A[6,17] are clobbered
; Disk commands are put on a sector queue iff they are at the current
; arm position or if all queues and buffers are empty.  When a command
; goes to the sector queue, a seek is issued to change arm positions (if
; necessary) and to enable sector interrupts.  If the command might start
; at the next sector, a disk sector interrupt is manually initiated.

DSKIO::	PUSH P,UNIT
	PUSH P,A		; Save xwd DWRBIT, CST index
	MOVE A,CST1(A)		; Linear address
	JSP D,CDSKH		; Get A/ xwd unit,disk address
	DPB A,[POINT 12,0(P),17] ; Save arm and sector in 0(P)[6,17]
	HLRZ C,A		; Get physical drive no.
; Thread the CST3 entry for this page on the appropriate queue
	MOVE UNIT,PDSKBL(C)	; Convert physical unit to DSKBL pointer
	LDB A,[POINT 9,A,32]	; Arm pos. of this command
	JSP D,DSKIDL		; Check for sector queue or holding queue
	  JRST DSKI4		; Holding queue
; Fall through if unit idle or command to current position
	SKIPL (P)		; Test DWRBIT, writes go to low queue
	AOSA KSQ		; Count high priority sector queue insertions
	AOS KSQ+1		; Count low priority
	HLRZ C,(P)		; Get sector no. and arm pos.
	ANDI C,7
	CALL KDOINT		; Trigger manual interrupt if necessary
	JUMPA DSKIC

DSKI4:	MOVEI C,DSKQ(UNIT)	; Command will go on either DSKQ or DSKLQ
	SKIPGE (P)		; Test DWRBIT, writes go to low queue
	AOSA KHQ+1		; Count insertions on low priority queue
	AOSA KHQ		; Count high queue insertions
	MOVEI C,DSKLQ(UNIT)	; Writes go to lower priority queue

; Insert on chain.  Predecessor pointed to by C.
DSKIC:	POP P,A			; Get DWRBIT, arm, and sector in l.h.
	MOVN B,TODCLK
	SKIPL D,A		; Page no. in r.h.  High pri.?
	ADDM B,KTIMT		; Yes, subtract from temporary.  TODCLK will be
				; added back in at completion or removal
				; to get elapsed time
	JUMPGE D,.+2
	ADDM B,KTIMT+1		; Low pri.
	HRR D,(C)		; Pointer to tail in r.h.
	MOVEM D,CST3(A)
	MOVEI D,CST3(A)
	HRRM D,(C)		; Pointer to new entry in predecessor
	CHNON DSKCHN
	POP P,UNIT
	RET

; Sector no. in C.  Issue a manual interrupt to the disk unit if
; a command for this sector can be setup now.
KDOINT:	LDB D,[POINT 3,DSKADR(UNIT),35]
	CAIE D,(C)		; Current sector?
	JRST KDOI1		; No
; Have to check for command buffer busy because a double sector int.
; will cause multiple KGO and double counting of DSKBSY, screwing up the
; statistics, but don't have to worry about sector transition.
	LSH C,4			; Yes, see if command buffer empty
	ADDI C,DSKSQ(UNIT)
	SKIPL CURARM(UNIT)	; Avoid problems if unit recovering from
				; select lock or other offline condition
	SKIPE (C)		; Give int. iff nothing at sector
	RET
IFDEF CHKSN,<			; Prevent sector sequence error
	SETOM DSKLSN(UNIT)
>
; Unit no. in l.h. of UNIT = device no.
	HLRZ D,UNIT
	AOS KMANRQ		; Count manually initiated interrupts
	IDEV (D)
	RET

KDOI1:	LSH C,4
	ADDI C,DSKSQ(UNIT)
	RET

KIDLE1:	SKIPN DSKLSV(UNIT)	; Timeout set?
	BUG(NTE,<Disk queues not empty but no timeout set>)
	CAMN A,CURARM(UNIT)	; Same as current arm pos.?
	JRST 1(D)		; Yes, use sector queue
	JRST 0(D)		; No, use holding queue

; Called with arm pos. in A by JSP D,DSKIDL.  Clobbers C and A.
; Return .+1 if command should go on holding queue, else .+2
; if it should go on sector queue.  Seek initiated if required.
; Leaves disk interrupts turned off.
DSKIDL:	CHNOFF DSKCHN
	MOVE C,SQPTR(UNIT)
DSKILP:	SKIPN DSKSQ(C)		; Test all sector queues
	SKIPE UDSKSQ(C)		; and utility sector queues
	  JRST KIDLE1		; Not empty, check arm pos.
	SUBI C,QDCBL
	CAIL C,(UNIT)
	JRST DSKILP		; Loop over all sectors
	MOVE C,TODCLK
	MOVEM C,DSKLSV(UNIT)	; Start interrupt timeout
	MOVEM C,KCLK1(UNIT)	; Init. execution timer
	MOVE C,DSKSTS(UNIT)	; Don't seek unless previous seek finished
	TLNE C,40000		; because command unqueuing may remove all
	  IFDEF DSKEVF,<JRST EVENT>
	  IFNDEF DSKEVF,<JRST (D)>
	CAMN A,CURARM(UNIT)
	AOJA D,DSEEK1
	AOJA D,DOSEEK		; Jump to DOSEEK and skip return

; Seek routine.  Call is JSP D,DOSEEK with arm pos. in A
; Return is .+1 always
DOSEEK:	SKIPGE CURARM(UNIT)	; Don't seek if recalibrating
	JRST 0(D)
	CAIL A,NARMS
	  BUG(HLT,<Illegal disk arm pos. for seek>)
	DPB A,[POINT 9,DSKADR(UNIT),32]	; Update arm position
	EXCH A,CURARM(UNIT)
	SUB A,CURARM(UNIT)
	MOVM A,A		; Arm displacement
	ADDM A,SKDISP		; Count total seek displacement
	HRRZ A,CURARM(UNIT)	; Recover arm pos.
	CAIL A,SWPTRK+NSWPTK
	JRST DSEEK3
	CAIL A,SWPTRK		; In swap area?
	JRST DSEEK4		; Yes
	SUBI A,SWPTRK
	MOVN A,A		; Get displacement from swap area
	JRST .+2
DSEEK3:	MOVEI A,-SWPTRK-NSWPTK+1(A)
	ADDM A,SADISP		; Count displacement from swap area
	AOSA NFSEEK		; Count file area seeks
DSEEK4:	AOS NSSEEK		; Count swap area seeks
DSEEK1:	MOVE A,DSKADR(UNIT)
	KSEEK A,
	  JUMPA SEEKF
IFDEF DSKEVF,<JRST EVENT>
IFNDEF DSKEVF,<JRST (D)>

SEEKF:	TLNN A,320100		; Hardware failure? (unsafe, offline,
				; seek failure, or deselected)
	  BUG(HLT,<Software-related seek reject>)
; Have timeout code recover from seek failure
DRPOT1:	MOVEI A,10000
	ADDM A,KSSTAT(UNIT)	; Count drop offline errors in bits 12-23
	AOS DRPOFF		; Count drop offline errors
	HRRI A,500000		; Code for shutdown request
	TLNN A,200000		; Unsafe?
DRPOT2:	HRRI A,600000		; No, try a recalibrate
	HRLM A,CURARM(UNIT)	; Save request for DSKCHK called by scheduler
	MOVE A,DSKPAK(UNIT)
	KIOFF A,		; Turn-off PDP-10 ints to insure timeout
	  CAI 0			; Legitimate rejection if offline
IFDEF CHKSN,<			; Prevent sector sequence errors
	SETOM DSKLSN(UNIT)
>
	SETZM DSKTIM		; Request DSKCHK run
IFDEF DSKEVF,<JRST EVENT>
IFNDEF DSKEVF,<JRST (D)>

; UTILITY DISK I/O--Called from DSKOP in NOINT, DDMP, GETSWM, and DSKBLT
; A/ hardware disk address (phys. unit in LH)
; B/ B0-8 status bits UCGET, UCRET, NOUNLK, HIPRI, CSAVE, NOWAIT, and NOREP
;	as in the parameter block defns.
;    B9-13 Interpreted by DSKOP
;    B14-17 Command no. coded per microcode
;	0  Write header
;	1  Write header, write UN, write data
;	2  Read header, read UN
;	3  Read header, write UN
;	4  Read header, UN, and data
;	5  Read header, compare UN, read data
;	6  Read header, read UN, and write data
;	7  Read header, compare UN, and write data
;	10 Read header, write UN, and write data
;	11 Read header, compare UN, and check data
;	12-17 undefined
;    B18-35 Caller's 9-word command addr. (***CFM bit set for monitor call)
; C/ main memory address (caller must lock page if necessary)
; Returns with error bits in A (0 if no errors), retry count in C,
; clobbers D.  Always transfers 1000 words.
; Errors:  1 = data checksum error, 2 = command reject, 3 = wrong pack mounted,
; 4 = unique name #, 5 = header surface incorrect, 6 = header garbaged,
; 7 = irr. disk unit failure, 10 = attempt to read into ill. part of mon.
; 11 = allocator timeout, probable difficulty, 12 = header checksum error,
; 13 = UN checksum error, 14 = data synchronization error (CDTL or SOVF)
; 15 = read-only error
UDSKIO:: PUSH P,UNIT
	LDB UNIT,[POINT 3,A,35]	; Check sector
	LDB D,[POINT 9,A,32]	; Check arm position
	CAIGE D,NARMS
	CAIL UNIT,NSECS
	  JRST UDSK4
	LDB UNIT,[POINT 6,A,23]	; Check head select
	LDB D,[POINT 12,C,26]	; Check page no.
	CAMG D,NHIPG##
	CAIL UNIT,NSURFS
	  JRST UDSK4
	TLZ A,777400
	HLRZ D,A
	MOVE UNIT,PDSKBL(D)	; Get DSKBL pointer for this unit
	CAIGE D,NDVMAX		; Must be physical unit no.
	SKIPN DSKPAK(UNIT)	; Online?
	  JRST UDSK4		; No
	TLZ C,777770		; Fill it
	HLL A,DSKPAK(UNIT)
	LDB D,[POINT 4,B,17]	; Get command no. per microcode
	CAIL D,12		; Defined?
	  JRST UDSK4		; No, reject command
	DPB D,[POINT 4,A,8]
	MOVE D,BITS##(D)	; Operation reads into main memory?
	TDNN D,RDOPS
	JRST UDSKE		; No, no danger of clobbering monitor
	LDB D,[POINT 12,C,26]	; Get page # again
	CAML D,SWPCOR##		; In res. monitor?
	JRST UDSKE		; No, ok (***better check here?***)
	SKIPE SYSIFG##		; System initialized yet?
	JRST URRMON		; Yes, illegal
	CAIL C,SPT+SSPT		; No, must be call from MONBLT
	CAIL C,KSVEND##		; Allow read into res. monitor and low buffers
	JRST UDSKE
URRMON:	MOVEI A,10		; Give ill. main mem. addr. error
	JRST UDSK7

; Command is ok.  Have disk command in A, main mem. addr. & w.c. in C
UDSKE:	PUSH P,A		; Save disk address & operator
	MOVEI D,^D20		; Get count for allocation failures
UDSK1:	MOVE A,[-UBUFS,,UDSKBK]
	CHNOFF DSKCHN
ALLOOP:	SKIPL (A)		; This buffer allocated (CBBUSY = 1B0)?
	JRST ALLOK		; No, use it
	ADDI A,UBLKSZ-1		; Yes, try next
	AOBJN A,ALLOOP
	CHNON DSKCHN
	AOS MALWTC		; Count allocation failures
	MOVEI A,^D30
	DISMS			; Wait 30 msec, then try again
	SOJGE D,UDSK1
	MOVEI A,11		; Something probably wrong, return error
	SUB P,BHC+1
	JRST UDSK7		; Might be hangup on KERRQ

UDSKA:	MOVEI C,QUN+1+1(A)
	HRLI C,QUN+1(A)
	SETZM QUN+1(A)
	BLT C,QPD+1+1(A)
	JRST UDSKB

ALLOK:	SETOM (A)		; Allocate the block
	CHNON DSKCHN
	POP P,QDSKAD+1(A)	; Place disk address and command no.
	TLO C,770000		; Only word count = 1000 permitted
	MOVEM C,QCORAD+1(A)	; Place main memory addr. and w.c.
	PUSH P,A		; Save command pointer
	TLNN B,UCGET		; Get UN and PD from user?
	JRST UDSKA		; No, use zeroes
	MOVEI C,QUN+1(A)	; "TO" address in command buffer
	HRLI C,QUN(B)		; "FROM" address in user area
	XCTUM [BLT C,QPD+1+1(A)]
UDSKB:	MOVE C,FORKX##		; Get fork no. of user for possible return
	HRL C,TODCLK		; and start time for statistics
	MOVEM C,FSTAMP+1(A)	; Fork no. of originator
	LDB A,[POINT 9,QDSKAD+1(A),32] ; Arm pos. of command
	JSP D,DSKIDL		; At current arm pos. or unit idle?
	  JRST UDSKC		; No, put on UDSKQ or UDSKLQ
	MOVE A,(P)		; Yes, restore command pointer
	LDB C,[POINT 3,QDSKAD+1(A),35] ; Yes, get sector no. of command
	CALL KDOINT		; Initiate manual interrupt if required
	ADDI C,UDSKSQ-DSKSQ	; Get pointer to UDSKSQ
	TLNN B,HIPRI		; High priority command?
	AOSA USQ+1		; No, count low priority sector queue
	AOS USQ			; Yes, count high priority
UDSK0:	HRRZ D,(C)		; Current queue header
	HLL D,B			; Get HIPRI, NOWAIT, NOUNLK, CSAVE
	TLZ D,1777+KFIN		; Clear error count, error code, KFIN
	TLO D,CBBUSY+DSKUIO	; Set CBBUSY and DSKUIO
	MOVEM D,(A)		; Splice command at head of queue
	HRRM A,(C)
	CHNON DSKCHN
	TLNE B,NOWAIT		; Waiting for command completion?
	JRST UDSK5		; No, continuing
	HRLZI A,(A)		; Data for wakeup test = pointer to command
	HRRI A,UDSK3		; Scheduler test routine address
	JSYS SCHEDP##		; Dismiss on page wait
	POP P,A
	TLNN B,UCRET		; User asking to get command back?
	JUMPA UDSK6		; No
UDSKF:	MOVEI C,(B)		; Address of buffer for command return
	HRLI C,QDSKAD+1(A)	; Xwd from,to for blt
	XCTMU [BLT C,QCORAD(B)]	; BLT UN and predata to user
UDSK6:	LDB C,[POINT 4,(A),12]	; Total tries in C
	LDB UNIT,[POINT 5,(A),17]	; Get error bits
	SETZM (A)		; Deallocate buffer
	MOVEI A,(UNIT)		; Error bits returned in A
UDSK7:	POP P,UNIT
	RET

UDSK5:	SUB P,BHC##+1
	MOVEI A,0		; Indicate no error
	JRST UDSK7

UDSK4:	MOVEI A,2		; Command reject
	JUMPA UDSK7

; Unit not idle, put on a holding queue
UDSKC:	MOVEI C,UDSKQ(UNIT)
	TLNN B,HIPRI		; High priority command?
	AOSA UHQ+1		; No, low priority.  Count occurrences
	AOSA UHQ		; Yes, high pri.
	MOVEI C,UDSKLQ(UNIT)	; Low
	MOVE A,(P)
	JRST UDSK0

UDSK3:	MOVE A,(A)		; Test command status
	TLNE A,KFIN		; for finished
	JUMPA 1(D)		; Yes, wakeup
	JUMPA 0(D)		; No.


; UDSKGF--Get utility I/O status and pick up finished command for this fork.
; At call:  address for 9-word disk command in B
; Return first command for this fork on KERRQ to user's block (B).
; Return error status in A, retry count in C, # unfinished commands in D.
; The command buffer is returned in the hardware format.
; The sign of D is 1 if there were no commands on KERRQ
UDSKGF::PUSH P,UNIT
	PUSH P,B
	PUSH P,IOS
	HRLZI D,400000		; Indicate no command and no errors
	HRLZI IOS,-NDVMAX		; Check all units for this fork
	CHNOFF DSKCHN
UCNTLP:	MOVE UNIT,PDSKBL(IOS)	; Pointer to unit block
	HRRZ A,UDSKQ(UNIT)
	CALL CNTUC		; Count commands on UDSKQ
	HRRZ A,UDSKLQ(UNIT)
	CALL CNTUC		; and on UDSKLQ
	MOVE C,SQPTR(UNIT)	; Loop through sector queues
UCLP1:	HRRZ A,UDSKSQ-DSKSQ(C)
	CALL CNTUC		; Count for this fork
	HLRZ A,UDSKSQ-DSKSQ(C)	; Don't forget command in progress
	JUMPE A,UCNT2
	HRRE B,FSTAMP+1(A)
	CAMN B,FORKX
	ADDI D,1
UCNT2:	SUBI C,QDCBL
	CAIL C,(UNIT)
	JRST UCLP1
	AOBJN IOS,UCNTLP	; Go to next unit
; Now check finished commands
	MOVEI C,KERRQ		; Pointer to predecessor
GETFLP:	HRRZ A,(C)
	JUMPE A,ZCOMR
	HRRE B,FSTAMP+1(A)	; Find originator of command
	CAMN B,FORKX		; This fork?
	JRST EBLTR		; Yes, BLT it back to caller
	MOVEI C,(A)
	JRST GETFLP

EBLTR:	TLZ D,400000		; Indicate found command on KERRQ
	MOVE UNIT,(A)		; Get next command on error queue
	HRRM UNIT,(C)		; Fix up predecessor
	CHNON DSKCHN
	POP P,IOS
	POP P,B
	JRST UDSKF		; Return complete command to user

ZCOMR:	CHNON DSKCHN
	POP P,IOS
	POP P,B
	JRST UDSK7

; Accept queue pointer in A, count commands with FSTAMP=FORKX
CNTUC:	JUMPE A,CPOPJ##		; Empty queue?
	HRRE B,FSTAMP+1(A)	; No, get fork stamp
	HRRZ A,(A)
	CAMN B,FORKX		; = Current fork?
	AOJA D,CNTUC		; Yes, count
	JRST CNTUC

DSKALL:	371700000077		; All disk errors

; Sector interrupt routine common to all units.  Have interrupt return
; in PI4R, old UNIT in PI4AC+4, and DSKBL pointer in UNIT
DSKSV:	AOS KNINTS		; Count disk interrupts
	MOVEM D,PI4AC##+4
	MOVEI D,PI4AC
	BLT D,PI4AC+3		; Save AC's 0, A, B, C, D
	MOVEM P,PI4ACP		; and P
	MOVE P,PI4STK##
	SKIPE C,DSKFIN(UNIT)
	CALL KFINSH		; Clean up command just finished
	MOVE C,DSKADR(UNIT)
	ANDI C,7		; Get sector no.

IFDEF CHKSN,<			; Check for sector sequence error
; This only works if DSKLSN is initialized when ints. are turned off
; and before manual ints.
	CAME C,DSKLSN(UNIT)
	CALL SEQERR		; Check out sequence error
	AOS B,DSKLSN(UNIT)	; Compute next sector
	CAIL B,NSECS
	SETZM DSKLSN(UNIT)
	>
	CAIL C,NSECS
	JUMPA DSKSVW
; Determine if any transfer can be started or if a seek can be
; carried out.  Have sector no. in 3
	LSH C,4			; =IMULI C,QDCBL
	ADDI C,DSKCB(UNIT)	; -1(C) points at sector queue and status
				; 0(C) points at command buffer
DSKSVC:	SKIPL B,-1(C)		; Know CBBUSY = sign bit
	JUMPA CKSECQ		; Go check sector queue
KDOCOM:	IFL KCHOKE-NDVMAX,<
	SKIPL DSKBSY(UNIT)
	JUMPA DSKSV9		; OK to transfer if unit already busy
	MOVE B,DSKNTR
	CAIL B,KCHOKE		; Or if no. busy units less than param.
	JUMPA DSKSV3
>
DSKSV9:	MOVE A,C		; Save command pointer in case of error
IFDEF DSKEVF,<JSP D,EVENT>
	KGO C,0			; Initiate transfer
	  JUMPA KGOF		; KGO rejected
IFL KCHOKE-NDVMAX,<
	AOSN DSKBSY(UNIT)
	AOS DSKNTR
>
	AOSA KTSTRT		; Count KGO's
DSKSVW:	  BUG(NTE,<Disk sector no. too big--index pulse missed>)
DSKSV3:	MOVE B,TODCLK
	MOVEM B,DSKLSV(UNIT)	; Save start time for timeout routine
DSKSV7:	HRLZI UNIT,PI4AC
	BLT UNIT,UNIT
	MOVE P,PI4ACP##
	JEN @PI4R##

; KGO failed.  Might happen if another sector int. occurs
; (In which case, DSKADR has changed).  BUGHLT for any other case.
KGOF:	TLNE C,320100		; Unit failures?
	JUMPA DRPOUT		; Yes, recover
	TRNN C,200		; Sec # next sec. or arm # current arm
	  BUG(HLT,<KGO rejected>)	; No, something worse
	LDB D,[POINT 9,DSKADR(UNIT),32]
	LDB B,[POINT 9,QDSKAD(A),32]
	CAIE D,(B)		; Arm position correct?
	  BUG(HLT,<Disk arm pos. & command buffer arm pos. disagree>)
	AOS DSKSEQ		; Sector interrupt service late
	JUMPA DSKSV3

; Sector sequence errors get here.  Next sector in C
IFDEF CHKSN,<
SEQERR:	SKIPL DSKLSN(UNIT)	; DSKLSN initialized to 400000 000000
	  AOS DSKSEQ
	MOVEM C,DSKLSN(UNIT)
	RET
	>

; Command buffer is empty.  Check sector queue.
CKSECQ:	JUMPN B,KSETUP		; Execute command on sector queue?
	HRRZ B,UDSKSQ-DSKCB(C)
	JUMPN B,UDSKCP		; Copy utility command into buffer

; No commands on sector queue, check sector queues and buffers for empty
DSKSVD:	MOVE B,SQPTR(UNIT)	; Get pointer to largest sector no.
DSKSV8:	SKIPN UDSKSQ(B)		; Test utility sector queue
	SKIPE DSKSQ(B)		; and regular sector queue
	JRST DSKSV3		; Some sector not idle, don't seek
	SUBI B,QDCBL
	CAIL B,(UNIT)
	JRST DSKSV8
; In case of missed cleanups
IFL KCHOKE-NDVMAX,<SKIPGE DSKBSY(UNIT)
	JUMPA .+4
	SOS DSKNTR
	SETOM DSKBSY(UNIT)
	AOS MISFIN		; Count missed cleanups
>
	MOVE A,DSKSTS(UNIT)	; Don't seek or turn-off ints. unless
				; previous seek finished because command
	TLNE A,40000		; unqueuing may remove all commands at an
	JRST DSKSV3		; arm pos. before the seek to it finishes

; Find the best arm position by looking at commands on the holding and
; utility high pri. queues and preferring the nearest arm pos. according
; to the SSTF scan.  If both queues are empty, check the low pri. queues.
; Priority of regular and utility commands is the same for seeking.

	HRLZI 0,700000		; For page reassignment test below
	MOVEI P,1000		; Worse than any real value for comp.
	HRLI UNIT,400000	; Flag looking at high pri. queues
	MOVEI C,DSKQ(UNIT)	; Get pointer to high pri. queue
BALOOP:	HRRZ D,UDSKQ-DSKQ(C)	; Cleverly get queue header for either
				; high or low pri. util. queue
	JUMPE D,BSTKNT		; Empty queue?
UBESLP:	LDB A,[POINT 9,QDSKAD+1(D),32] ; No, get arm pos.
	SUB A,CURARM(UNIT)	; Get displacement from current arm
; Code here is for shortest-seek-time first scan of queues.
; For cyclic scan use MOVEI B,(A); CAIGE B,(P).
	MOVM B,A		; Get magnitude of displacement
	CAIL B,(P)		; Compare with best so far
	JRST .+3		; Not as good
	MOVEI P,(B)		; Better, save new best
	MOVEM A,BSTARM		; Save best displacement for seek
	HRRZ D,(D)		; Advance queue pointer
	JUMPN D,UBESLP		; Any more entries?
	JRST BSTKNT		; No, look at regular queues

BESTLP:	TDNE 0,CST0-CST3(A)	; Page reassigned?
	JRST UNQPG		; Yes, unqueue it
	MOVEI C,(A)		; No, advance queue pointer
	LDB A,[POINT 9,(A),14]	; Get arm pos.
	SUB A,CURARM(UNIT)	; Arm displacement
; Scan algorithm as above
	MOVM B,A
	CAIL B,(P)
	JRST .+3
	MOVEI P,(B)
	MOVEM A,BSTARM
BSTKNT:	HRRZ A,(C)		; Advance queue pointer
	JUMPN A,BESTLP		; End of queue?
	CAIGE P,1000		; Yes, found any items?
	JRST SSEEK		; Yes, go seek
	TLZN UNIT,400000	; No, test-and-clear high flag
	JRST OFFINT		; All queues were empty
	MOVEI C,DSKLQ(UNIT)	; Now do low priority
	JRST BALOOP

; Start seek and copy commands at best arm pos. onto sector queues
; Arm pos. - current arm pos. in BSTARM
SSEEK:	MOVE A,BSTARM		; Get arm pos. for seek
	ADD A,CURARM(UNIT)
	JSP D,DOSEEK
; Now copy all commands from holding queues to sector queues
	MOVEI C,DSKLQ(UNIT)
	HRLI UNIT,400000	; Flag low priority queue
CPYLP:	HRRZ A,(C)		; Point at command being considered
	JUMPE A,UCPY		; Done, go do utility I/O
	LDB D,[POINT 9,(A),14]	; Arm pos. of command
	CAMN D,CURARM(UNIT)	; At this arm pos.?
	JRST SECCPY		; Yes
	MOVEI C,(A)		; No, predecessor _ tail and loop
	JRST CPYLP

SECCPY:	MOVE D,(A)		; Tail of DSKQ or DSKLQ
	HRRM D,(C)		; Remove from queue
	TDNE 0,CST0-CST3(A)	; Operation aborted?
	JRST [	MOVEI D,CPYLP
		JRST UNQXPG]	; Yes, remove (must be low queue)
	LDB D,[POINT 3,D,17]	; Get sector no.
	LSH D,4			; = IMULI D,QDCBL
	ADDI D,DSKSQ(UNIT)	; Pointer to sector queue
	MOVE B,(D)		; Current sector queue pointer
	HRRM B,(A)
	HRRM A,(D)		; Fix up queue header
	JRST CPYLP

; Copy utility queues
UCPY:	MOVEI B,UDSKLQ(UNIT)
	TLNN UNIT,400000	; Low priority queue first
	MOVEI B,UDSKQ(UNIT)
UUQLP:	HRRZ C,(B)
	JUMPN C,UUQLP1		; Empty queue?
	TLZN UNIT,400000	; Done yet?
	JRST DSKSV3		; Yes, finished
	MOVEI C,DSKQ(UNIT)	; No, do high pri. queues
	JRST CPYLP

UUQLP1:	LDB D,[POINT 9,QDSKAD+1(C),32]
	CAMN D,CURARM(UNIT)
	JRST USECPY
	MOVEI B,(C)
	JRST UUQLP

USECPY:	MOVE D,(C)		; Tail of queue
	HRRM D,(B)		; Remove from UDSKQ or UDSKLQ
	LDB D,[POINT 3,QDSKAD+1(C),35]
	LSH D,4
	ADDI D,UDSKSQ(UNIT)
	MOVE A,(D)
	HRRM A,(C)
	HRRM C,(D)
	JRST UUQLP

; Cancel I/O at holding queue removal if page has become active
; A/ pointer to CST3 entry, C/ pointer to predecessor
UNQPG:	MOVEI D,BSTKNT		; Set return address
	HRRZ B,(A)		; Get queue tail
	HRRM B,(C)		; Remove from queue
UNQXPG:	MOVEI A,-CST3(A)
UNQSPG:	MOVSI B,(CORMB)
	IORM B,CST0(A)		; Set modified bit
	MOVE B,TODCLK
	EXCH B,KCLK1(UNIT)	; Determine execution time, set start time
	SUB B,KCLK1(UNIT)
	ADDM B,CTIME		; Update total execution time
	MOVE B,TODCLK
	SKIPGE CST3(A)		; Now update wait time on high/low pri.
	JRST UNQPG1		; Low
	AOS KIOREM		; High
	ADDM B,KTIMT
	JRST SWPDON##		; Clobbers B

UNQPG1:	AOS KIOREM+1		; Low pri.
	ADDM B,KTIMT+1
	JRST SWPDON		; Returns to 0(D), clobbers B

; Copy command from sector queue into execution buffer.
; Sector queue pointer in B, sector queue and command status at -1(C)
; Execution buffer at 0(C), 0 in l.h. of C
KSETUP:	HRRZ A,(B)		; Get link from CST3 entry
	MOVEM A,-1(C)		; Take off sector queue, 0 status
	MOVEI A,-CST3(B)	; Get main mem. page no. of command
	MOVEI B,(A)
	LSH B,11		; Main memory address
	TLO B,-1000*10		; One page word count
	MOVEM B,QCORAD(C)
	MOVEI D,DSKSVC		; Return address for UNQSPG below
	MOVE 0,CST0(A)
	TLNE 0,700000		; Page reassigned?
	JUMPA UNQSPG		; Yes, flush
	HLL A,CST3(A)
	MOVSI B,4000
	TLNE A,DWRBIT		; Write bit on?
	MOVSI B,10000
	MOVEM B,QDSKAD(C)
	TLO C,CBBUSY
	HLLM C,-1(C)		; Save command status
	MOVE A,CST1(A)		; Linear disk address
	HRLI UNIT,(C)
	JSP D,CDSKH		; Convert A to hardware address
	HLRZ C,UNIT
	HLL A,DSKPAK(UNIT)	; Set pack no.
	DPB A,[POINT 26,QDSKAD(C),35]
	SETZM QUN(C)
	MOVEI D,QUN+1(C)
	HRLI D,QUN(C)
	BLT D,QPD+1(C)
	JUMPA KDOCOM

; Copy utility command into execution buffer
; Pointer from r.h. of UDSKSQ in B, pointer to DSKCB in C
UDSKCP:	MOVE D,(B)		; Get command status and tail pointer
	HRRM D,UDSKSQ-DSKCB(C)	; Advance UDSKSQ
	HLLM D,-1(C)		; Save in execution buffer status
	MOVEI D,(C)		; "TO"
	HRLI D,1(B)		; "FROM"
	BLT D,10(C)		; Fill execution buffer
	HRLM B,UDSKSQ-DSKCB(C)	; Retain pointer to command in l.h. of UDSKSQ
	JRST KDOCOM

; Clean up command just finished.  Pointer to it in C
KFINSH:	SETZM DSKFIN(UNIT)
	MOVE D,SQPTR(UNIT)
FINLP:	CAIN C,DSKCB(D)		; This execution buffer?
	JRST PHANCK		; Yes
	SUBI D,QDCBL
	CAIL D,(UNIT)
	JRST FINLP
	  BUG(CHK,<Garbage disk command completion pointer>)
	RET			; Ignore and plow on

PHANCK:
IFL KCHOKE-NDVMAX,<SKIPGE DSKBSY(UNIT)
	  BUG(HLT,<Phantom disk completion>)
	SOSGE DSKBSY(UNIT)
	SOS DSKNTR>
	MOVE A,DSKSTS(UNIT)	; Get errors for command
	SKIPL B,-1(C)		; Skip if command buffer full
	  BUG(HLT,<Cleanup for empty command buffer>)
IFDEF DSKEVF,<JSP D,EVENT>
	LDB 0,[POINT 4,QDSKAD(C),8]	; Get disk operation #
	TDNE A,DSKALL		; Any errors?
	  JUMPA DSKERR		; Yes
DSKSV1:	CALL TRCHK		; Count transfer interference
	JSP D,KPGCHK		; Determine utility, regular or directory
	  JRST DSKUT1		; Utility clean up
	  JRST KDIRCK		; Directory page, special checks
DSKSVX:	MOVEI B,0		; Index high priority
	SKIPGE CST3(A)		; Low priority?
	MOVEI B,1		; Yes
	HRRZ D,CURARM(UNIT)
	CAIL D,SWPTRK		; In file area?
	CAIL D,SWPTRK+NSWPTK
	AOSA KTFIN+2(B)		; Yes, count completions
	AOS KTFIN(B)		; No, count swap area completions
	MOVE D,TODCLK
	ADDM D,KTIMT(B)		; Log wait time in temporary
	JSP D,SWPDON		; Regular page, cleanup, clobbers B
	HRRZS -1(C)		; Mark execution buffer empty
DSKSV0:	MOVE D,TODCLK
	EXCH D,KCLK1(UNIT)	; Get execution time
	SUB D,KCLK1(UNIT)
	ADDM D,CTIME		; Log neg. execution time
	RET

; After writing directory pages, check by reading them
KDIRCK:	SKIPGE CST3(A)		; DWRBIT set?
IFDEF CHKDIP,<AOSA DIRWRT	; Yes, count DI and directory writes
>
IFNDEF CHKDIP,<AOS DIRWRT>
	JRST DSKSVX		; No
	LDB B,[POINT 4,QDSKAD(C),8]	; Get command no.
	CAIN B,11		; Already checked it?
	JRST DSKSVX		; Yes, finish
	MOVEI B,11
	DPB B,[POINT 4,QDSKAD(C),8]	; Check results of write on next
	RET			; revolution of disk

; Determine whether command at (C) is utility I/O, regular, or directory.
; Returns page no. in A.
KPGCHK:	TLNE B,DSKUIO		; Utility I/O?
	JRST 0(D)		; Yes
	LDB A,[POINT 12,QCORAD(C),26] ; No, get page no.
	MOVE B,CST2(A)		; Find out what page it is
	TLNN B,-1		; From SPT?
	JRST [	CAIL B,NOFN
		HLRZ B,SPTH(B)	; Get OFN
		JRST .+2]
	HLRZ B,B
	CAIL B,1		; DI or Directory?
	CAILE B,NFDIB+3
	JRST 2(D)		; Regular page
	JRST 1(D)		; DI or directory

; Utility I/O surface # error = code 5
SURFAI:	TLNN B,DSKUIO
	  KBUGH(<$HEADER ERROR--WRONG SURFACE>,TRKFAI)
	TLOA B,5
; UN error.
UIOUN:	TLO B,4			; Return code 4
	JRST DSKUT1

; Pass bad auxiliary pack no. back as error code 3, crash if system pack
PCKFAI:	TLNN B,DSKUIO		; Utility I/O
	  KBUGH(<$HEADER HAS WRONG PACK NO.--DISK CONFIGURATION OK?$>,TRKFAI)
	TLO B,3		; Indicate pack no. mismatch
	JRST DSKUT1

; Utility I/O fatal read error.  Leave error code in B[13,17]
UIOFRE:	MOVE A,DSKRER+3		; Recover error status
	TRNE A,2		; Header checksum?
	JUMPA UIOFRH		; Yes, ignore rest
	TRNE A,10		; UN checksum?
	JUMPA UIOFRU
	TRNE A,20		; Data checksum?
	TLOA B,1		; Data checksum error
	TLO B,14		; Sector overflow (synchronization) error
; Utility I/O cleanup.  B has command status, C has command pointer.
DSKUT1:	HLRZ A,UDSKSQ-DSKCB(C)	; Get pointer to command buffer
	JUMPN A,.+2
	  BUG(HLT,<Utility I-O cleanup with no pointer to its buffer>)
	HRRZS UDSKSQ-DSKCB(C)	; Indicate no command in progress
	HRRZS DSKSQ-DSKCB(C)	; Mark execution buffer free
	HRLI C,1(A)
	MOVS C,C
	BLT C,QPD+1+1(A)	; BLT command back to its buffer
UCLN1:	LDB C,[POINT 4,QDSKAD+1(A),8]; Get command opcode
	CAIL C,4		; Read (= main memory write)?
	CAIGE C,6
	JRST DSKUT6		; No.
	LDB C,[POINT 12,QCORAD+1(A),26]	; Yes, get page no.
	MOVSI D,(CORMB)
	IORM D,CST0(C)		; Set dirty bit
DSKUT6:	HRLO D,TODCLK		; Compute wait time
	SUB D,FSTAMP+1(A)	; In l.h. of D mod 2^18
	HLRZ D,D
	MOVEI C,1
	TLNE B,HIPRI		; High pri.?
	MOVEI C,0		; Yes
	AOS UFIN(C)		; Log # completions
	ADDM D,UTIME(C)		; Log wait time
	TLO B,KFIN		; Mark command finished
	HLLM B,(A)
	TLNE B,NOWAIT		; Some fork waiting for completion?
	JRST DSKUT2		; No, finish and deallocate.
	AOS PSKED##		; Yes, tell scheduler
	JRST DSKUT4

DSKUT2:	TLNE B,CSAVE+37		; Command save or any errors?
	JRST DSKUT3		; Yes, don't unlock--save buffer on KERRQ
	SETZM (A)		; No, flush buffer
	JRST DSKUT4

DSKUT3:	HRRZ D,KERRQ
	HRRM D,(A)		; Put at head of KERRQ
	HRRM A,KERRQ
DSKUT4:	TLNE B,NOUNLK
	JRST DSKSV0		; Don't unlock page
	LDB B,[POINT 12,QCORAD+1(A),26] ; Get main mem. page no.
	CALL MULK1##		; Unlock page
	JRST DSKSV0

UIOFRH:	TLOA B,12		; Header checksum
UIOFRU:	TLO B,13		; UN checksum
	JUMPA DSKUT1

; Sector interrupt missed (probably processor halted after command accept)
SECFAI:	  BUG(NTE,<Header error--wrong sector>)

; Checksum, controller data late, sector overflow, and header sector not
; equal errors get here QDSKAD in D, command status in B, command
; pointer in C
DSKRTY:	ADD B,[XWD 40,0]	; Bump error count
	MOVEM B,-1(C)
	TLNE B,NOREP		; Suppressing retries and reports?
	JRST DSKER2		; Yes, immediate fatal error
	LDB 0,[POINT 4,B,12]
	CAIL 0,17		; Tried 15 times?
	JUMPA DSKER3		; Yes, irrecoverable
	LDB A,[POINT 4,QDSKAD(C),8]
	CAIE A,11		; Read-check after writing?
	JUMPA DKRTY1		; No, check for bad spot
	TLNE B,1600		; Trouble if repeated four times
	  JRST IRRDCK
	MOVEI A,10
	DPB A,[POINT 4,QDSKAD(C),8] ; Retry write
	AOS KREWRT		; Count rewrites
DKRTY1:	MOVE A,DSKSTS(UNIT)	; Get read-only status bit
	TLNE A,10000		; Is unit read-only?
	RET			; Yes, cannot record bad spot
	CAIN 0,10		; No, enough for new bad spot?
	MOVEM D,NEWBS		; Yes
	RET

IRRDCK:	MOVEM D,NEWBS		; Mark bad spot (for eventual recovery)
	  KBUGH(<$DIREC. WRITE FAILURE.  UNABLE TO READ-CHECK FOR 4 REWRITES>,TRKFAI)

; Read-only violation.  Note that turning on the read-only switch does
; not make a unit read-only until a subsequent KON is done.
ROERR:	TLNN B,DSKUIO		; Utility I/O?
	KBUGH(<$READ-ONLY>,TRKFAI)
	TLO B,15		; Yes, set read-only error code
	JRST UIOFRE

; Irrecoverable checksum, sector overflow, or controller data late errors
DSKER3:	AOS DSKNRE
	MOVNI A,20
	ADDM A,DSKRCE
	MOVE A,[XWD DSKRER,DSKLER]
	BLT A,DSKLER+3		; Save non-rec. command and status
DSKER2:	JSP D,KPGCHK		; Determine utility, regular, or directory
	  JRST UIOFRE		; Utility I/O fatal read error
	  KBUGH(<$IRREC. READ ERROR IN DIRECTORY--BEWARE OF DISK WRITE FAILURE>,TRKFAI)
	MOVSI B,SWPERR
	IORM B,CST3(A)		; Notify swapper of error
	JRST DSKSVX

; Unique name comparison error.  Put code 4 in utility command.
; Bughlt for other cases.
UNERR:	TLNE B,DSKUIO		; Utility I/O?
	JRST UIOUN		; Utility
	BUG(HLT,<Impossible unique name error on regular command>)

; Fatal hardware errors get here
DRPOUT:	JSP D,DRPOT1		; Request DSKCHK run
	JRST DSKSV3

; Hardware sought to wrong arm position
TRKFAI:	AOS SKWRNG		; Count seeks to wrong arm pos.
	AOS KSSTAT(UNIT)	; Count seeks to wrong arm pos. in 24-35
	JSP D,DRPOT2		; Request recalibrate
	JRST DSKSV3

OFFINT:	SETZM DSKLSV(UNIT)	; Turn-off timeout errors
	MOVE A,DSKPAK(UNIT)
	KIOFF A,		; Disable sector interrupts
	  CAI 0			; Legitimate reject if offline
IFDEF CHKSN,<
	SETOM DSKLSN(UNIT)	; Ignore sector sequence errors
	>
	JRST DSKSV7

; Command completion error.  Hardware status in A, command status in B,
; command pointer in C, disk operation # in 0
DSKERR:	MOVE D,WRTOPS		; Bits set correspond to write operations
	LSH D,@0		; Shift bit for this op to sign
	JUMPL D,.+2		; Write operation?
	TLZ A,10000		; No, clear read-only error
	AND A,DSKALL
	JUMPE A,DSKSV1		; Jump if not really an error
	CAME A,[XWD 40000,40]	; Command not finished and seeking?
	CAIN A,40
	RET			; Yes.  Retry, this is normal.
	CALL TRCHK		; Count transfer interference
	LDB D,[POINT 6,B,12]	; Retry count
	LSH D,6
	IOR D,A			; Merge error status and retry count
	MOVEM D,DSKRER+3	; Save error status and retry count
	MOVE D,QHDR(C)
	MOVEM D,DSKRER+1	; Save header
	MOVE D,QCORAD(C)	; Main memory address
	TLZ D,777770
	MOVEM D,DSKRER+2
	MOVE D,QDSKAD(C)
	MOVEM D,DSKRER		; Save disk address
	TLNN B,NOREP		; Suppressing job 0 report?
	AOS DSKRCE		; No, update count for job 0
	TLNE A,10000		; Read-only error?
	JRST ROERR		; Yes
	TLNE A,320100		; Fatal errors? (unsafe, offline, seek
	JRST DRPOUT		; failure, deselected)
	TLNE A,1000		; Processor data late?
	RET			; Yes, try indefinitely.
	TDNE A,[XWD 600,32]	; Retry CDTL, SOVF, or CSUM errors
	JUMPA DSKRTY		; Try a few times.  SOVF may be fatal if
				; oscillator can't sync data.
	TRNE A,4		; Unique name not equal?
	JRST UNERR
	TRNN A,1		; Header error?
	  JSYS [XWD BUGHLT,DSKFAT] ; No other errors possible, crash.
; Header error.  Analyze
	MOVE 0,QHDR(C)		; Get header read by hardware
	XOR 0,QDSKAD(C)		; Compare to disk address of command
	TLZ 0,777400		; Clear garbage bits
	JUMPE 0,HGARB		; Really wrong?
	TRNN 0,777777
	JUMPA PCKFAI
	TDNN 0,[XWD 377,770007]
	JUMPA TRKFAI		; Wrong arm position
	TDNN 0,[XWD 377,777770]
	JUMPA SECFAI		; Wrong sector
	TDNN 0,[XWD 377,007777]
	  JRST SURFAI		; Wrong surface
HGARB:	TLNN B,DSKUIO
	  KBUGH(<$HEADER GARBAGED>,TRKFAI) ; Crash-halt if system pack
	TLO B,6
	JRST DSKUT1		; Error return for aux. pack

; Determine whether command has interfered with useful computation
; and Aos the appro. counter for statistics.  Have operation # in 0.
TRCHK:	MOVE D,0		; Set bit corresponding to operation
	MOVE D,BITS##(D)
	TDNN D,DATOPS		; Transferred data record?
	 RET			; No, no interference
	SKIPG NBRUN##		; Any runnable forks?
	HRRI D,1		; No, index for non-interference
	TDNN D,RDOPS		; Read?
	AOSA WTRAN(D)		; No, write or check
	AOS RTRAN(D)		; Yes.
	RET

; Periodic scheduler routine to check for disk units hung
DSKCHK:: MOVEI A,^D2000		; Reset clock for 2 seconds
	MOVEM A,DSKTIM##
	HRLZI BB,-NDVMAX	; Loop through all units
	MOVE D,TODCLK
	HRLZI UNIT,0		; Clear sign bit (= aging flag)
	CAMGE D,KAGTIM		; Past time to age?
	JRST DSKCLP		; No
	ADD D,[^D450000]	; 7.5 minutes between aging
	MOVEM D,KAGTIM		; Next time to age
	HRLZI UNIT,400000	; Set sign bit to indicate doing aging
DSKCLP:	HRR UNIT,PDSKBL(BB)
	SKIPN A,DSKLSV(UNIT)
	JUMPA DSKPC0		; 0 if sector interrupt off
	SUB A,TODCLK
	CAMG A,[-^D30]		; Waited more than 30 msec?
	  CALL KUTMO		; Yes, timeout
DSKPC0:	JUMPGE UNIT,DSKAG1	; Jump if not aging this time
	LDB A,[POINT 12,KSSTAT(UNIT),11]
	LSH A,-1
	DPB A,[POINT 12,KSSTAT(UNIT),11]
DSKAG1:	AOBJN BB,DSKCLP
	HRLZI B,-2		; Loop over high/low pri. statistics
	CHNOFF DSKCHN
DSKCK2:	MOVE A,KTFIN(B)		; Get total completions
	ADD A,KTFIN+2(B)
	ADD A,KIOREM(B)		; + removals
	SUB A,KHQ(B)		; - startups
	SUB A,KSQ(B)
	JUMPN A,DSKCK3		; Not idle, can't log
	MOVE A,KTIMT(B)		; Idle, accumulate temporaries
	ADDM A,KTIME(B)
	SETZM KTIMT(B)		; Init. temporaries
DSKCK3:	AOBJN B,DSKCK2		; Do high/low pri.
	MOVEI B,KERRQ
KEQLP:	HRRZ A,(B)		; Get pointer to unpickedup command
	JUMPE A,KEQE
	HRLO C,TODCLK
	SUB C,FSTAMP+1(A)	; Elapsed time mod 2^18 in l.h.
	HLRZ C,C
	CAIL C,^D30000		; Longer than 30 seconds?
	JRST KEQTMO		; Yes, flush it
	MOVEI B,(A)
	JRST KEQLP
KEQE:	CHNON DSKCHN
	RET

; KERRQ command timed out, flush it
KEQTMO:	HRRZS A,(A)		; Clearing sign bit deallocates
	HRRM A,(B)
	  BUG(NTE,<Flushed command on disk error queue after 30 seconds>)
	JRST KEQLP

; Disk unit (BB) timed out
KUTMO:	MOVEI AA,(BB)
	CHNOFF DSKCHN
	SKIPL D,CURARM(UNIT)	; Recalibrating or recalibrate requested?
	  JRST DSKCK4		; No, hardware dead
	TLZE D,200000		; Requested?
	JRST RECALR		; Yes
	TLZE D,100000		; Unit dead?
	JRST KUDEAD		; Yes, go through shutdown code
	CAML A,[-^D2500]	; Allow 2.5 sec.
	RET			; Not enough time yet
KUTMO1:	MOVEI C,(AA)		; Setup phys. unit #
	CALL DOKON		; Put unit online and back at arm pos.
	DPB D,[POINT 9,DSKADR(UNIT),32]
	HRRZM D,CURARM(UNIT)
	JSP D,DSEEK1
	SKIPGE D,CURARM(UNIT)	; Still offline, unsafe, etc.?
	JRST KUDEAD		; Yes, go through shutdown code
	CHNON DSKCHN
	RET

DSKCK4:	AOS DSKTMO		; Count sector-interrupt timeouts
RECALR:	HRLZI A,100
	ADDB A,KSSTAT(UNIT)	; Count anomalies
	TLNE A,20000		; More than 128 anomalies in 15 min.?
	  JRST KUDEAD		; Too frequent errors
IRECAL:	KOFF (AA)		; Recalibrate and offline
	MOVEI A,400000
	HRLM A,CURARM(UNIT)	; Indicate recalibrating
	MOVE A,TODCLK
	MOVEM A,DSKLSV(UNIT)	; Start timeout
	CHNON DSKCHN
	RET	

; Pause system for system packs.
; Flush all utility I/O commands giving error code 7 for auxiliary packs.
KUDEAD:	HLRZ A,DRIVTB(AA)	; Get logical unit
	CAMG A,SYSUN		; System pack?
	JUMPA PCKDWN		; Yes, stop system.
	SETZM KSSTAT(UNIT)	; No, clear unit counters
	HRRZS CURARM(UNIT)
	MOVE IOS,SQPTR(UNIT)
UIOUQL:	MOVEI C,DSKCB(IOS)	; Loop over all sector queues
	SKIPL B,DSKSQ-DSKCB(C)	; Get command status
	JRST NOCOMM		; No command in buffer
	TLNN B,DSKUIO		; Must be utility command?
	BUG(HLT,<Regular command on auxiliary disk pack>)
	TLO B,7			; Irr. failures code
	CALL DSKUT1		; Finish command with code 7
; Now check utility sector queue for commands
NOCOMM:	MOVEI C,DSKCB(IOS)
	HRRZS A,UDSKSQ-DSKCB(C)
	JUMPN A,[MOVE B,(A)	; Remove from queue, get status
		HRRM B,UDSKSQ-DSKCB(C)
		TLO B,7		; Irr. failures code
		CALL UCLN1
		JUMPA NOCOMM]
	SKIPE DSKSQ-DSKCB(C)
	BUG(HLT,<Regular command on auxiliary disk pack>)
; Done with this sector, advance
	SUBI IOS,20
	CAIL IOS,(UNIT)		; Done all sectors yet?
	JRST UIOUQL		; No, do next
	HRLZI IOS,-2
HQUQLP:	MOVEI D,UDSKQ(UNIT)
	ADDI D,(IOS)		; Select high/low pri. queue
	HRRZ A,(D)		; Get queue pointer
	JUMPE A,HQUQ2		; Jump when done
	MOVE B,(A)		; Get status and queue pointer
	HRRM B,(D)		; Remove from queue
	TLO B,7			; Indicate disk drive error
	CALL UCLN1		; Finish command
	JRST HQUQLP

HQUQ2:	AOBJN IOS,HQUQLP	; Do both queues
	SKIPN DSKQ(UNIT)
	SKIPE DSKLQ(UNIT)
	BUG(HLT,<Regular command on auxiliary disk pack>)
	SETZM DSKLSV(UNIT)	; Indicate ints. off, no commands
IFDEF CHKSN,<
	SETOM DSKLSN(UNIT)
	>
	KIOFF A,
	  CAI 0
	CHNON DSKCHN
	RET			; Return from call to KUTMO

PCKDWN:	MOVEI A,[SIXBIT '$TROUBLE WITH SYSTEM PACK /']
	JSYS BUGMSG		; Type sixbit message pointed to by A
	HLRZ A,DSKPAK(UNIT)
	JSYS BUGOPT		; Type pack #
MRMSG:	MOVEI A,[SIXBIT '$TYPE "M" TO MOVE PACK, "R" TO RESUME:  / ']
	JSYS BUGMSG
	JSYS BUGTYI##
	TRZ A,40
	CAIN A,"R"		; Resume with current pack?
	JRST IRECAL		; Yes, recalibrate and go
	CAIE A,"M"		; Move pack?
	JRST MRMSG		; None of the above, retry
; Move the pack mounted on the failed unit to another unit
	MOVEI A,[SIXBIT '$MOVE PACK /']
	JSYS BUGMSG
	HLRZ A,DSKPAK(UNIT)
	JSYS BUGOPT
	MOVEI A,[SIXBIT ' TO UNIT (A-H):  /']
	JSYS BUGMSG
	JSYS BUGTYI##
	TRZ A,40
	SUBI A,"A"
	JUMPL A,MRMSG
	CAIL A,NDVMAX		; Legal?
	JRST MRMSG		; No, try again
	SKIPL DRIVTB(A)		; Anyone assigned to this phys. unit?
	JRST MRMSG		; Yes, try again
	HLRZ B,DRIVTB(AA)	; Get current virtual unit
	HRRM A,DRIVTB(B)	; Save new phys. unit
	HRROS DRIVTB(AA)	; Release virtual unit for old phys. unit
; Have old physical unit in AA, new in A
	MOVE B,PDSKBL(A)
	MOVE UNIT,PDSKBL(AA)
	HRRM B,PDSKBL(AA)	; Interchange DSKBL pointers for old and
	HRRM UNIT,PDSKBL(A)	; new units
	KOFF (AA)		; Old unit offline
	MOVEI AA,(A)		; Setup new unit number to put on-line
	MOVEI A,[SIXBIT '$/']
	JSYS BUGMSG
	SETOM KCFLOG		; Signal job 0 to log configuration
	JRST KUTMO1		; Put new unit online and go

SWAPCD

; Enter here from CHKR in SWPMON (Job 0) with DSKNRE in A to print error
; info on CTY and FACT file.
CHKDSK::MOVEM A,CHKDNE##	; Save new count
	HRROI A,[ASCIZ /***NON-REC DSKERR: /]
	MOVEI IOS,DSKLER	;4-word block of commands and err bits
CHKDE2:	PSOUT
	MOVEI A,101
	HRLI IOS,-4		; Report 4 words
	MOVE C,[1B0+^D8]	; In magnitude octal
CHKD1:	MOVE B,0(6)
	NOUT
	JFCL
	MOVEI B," "
	BOUT
	AOBJN IOS,CHKD1
	MOVSI B,(302B8)		; Fact entry type for recovered dsk err
	CAIN IOS,DSKLER+4	; Hard error?
	MOVSI B,(303B8)		; Yes
	SETZ C,			; Second word not used at this time
	GTAD			; Date and time in third word
	MOVE D,A
	MOVSI A,-4(6)		; Four words of error data
	HRRI A,5
	BLT A,10
	MOVE A,[-7,,2]		; Put disk error entry in fact file
	EFACT
	  JSP B,XEFACT##
	JRST CHKR1##
	JRST CHKR1##		; XEFACT sometimes returns +2?

CHKDE1::MOVEM A,CHKDRE##	; Save new count
	HRROI A,[ASCIZ /*DSKERR: /]
	MOVEI IOS,DSKRER		;4-word block of commands, etc.
	JRST CHKDE2

RESCD

; Reload resident monitor, called from SYSGO

RLRMON::PIOFF
	MOVEI A,[SIXBIT '$BOOTING TENEX FROM AREA /']
	JSYS BUGMSG
	MOVE A,SVAREA##
	JSYS BUGOPT
	MOVEI A,[SIXBIT ' ... /']
	JSYS BUGMSG
	PION
	MOVEI A,1		; Start at page 1
	MOVE B,SWPCOR		; Stop at top of symbol table
	SUBI B,1
	MOVEI C,SPT+SSPT-2000	; Use top of SPT for scratch
	CALL MONBLT		; Read resident monitor
	MOVEI A,[SIXBIT ' FINISHED!$/']
	PIOFF
	JSYS BUGMSG
	RET


; BLT region of monitor from save area into memory
; Called from RLRMON (above) and from GETSWM and DDTRCL (SWPMON)
;	A/ First virtual page #
;	B/ Last virtual page #
;	C/ Virtual starting address of 2 temp pages.
; All pages (including the temps) are assumed to exist and be
; locked in core.
; Clobbers most everything

MONBLT::MOVE E,A		; Save page numbers
	MOVE F,B
	HRLM C,0(P)		; Save temp page address
	MOVE A,SVAREA##		; Get save area from which booted
	CALL ARTOAD		; Convert to starting disk address
	MOVE IOS,A		; Save it
	HLRZ C,0(P)		; Recover temp page address
	CALL MBREAD		; Read first map page from disk
	MOVE A,IOS		; Recover starting disk address
	CALL IDSKA		; Increment it
	HLRZ C,0(P)		; Recover temp page address
	ADDI C,1000		; Get address of 2nd page
	CALL MBREAD		; Read second map page from disk
	CALL MBWAIT		; Wait for reads to complete
	HLRZ UNIT,0(P)		; Init map entry pointer
	HLRZ A,0(UNIT)		; Check for SSAVE format
	CAIE A,1000
	 BUG(HLT,<Illegal format in save area>)
MONBL1:	HLRZ A,0(UNIT)		; Get format code for block
	CAIE A,1000		; SSAVE format?
	 JRST MBWAIT		; No, end, wait for completion
	MOVN A,0(UNIT)		; Yes, get negative of page count
	HRLI UNIT,0(A)		; Make AOBJN ptr
	ADDI UNIT,1		; Point to first map entry
MONBL2:	LDB A,[POINT 9,0(UNIT),17]  ; Get virtual page #
	CAIL A,(E)		; In desired range?
	 CAILE A,(F)
	 JRST MONBL3		; No, ignore
	MOVE A,IOS		; Yes, get starting disk address
	HRRZ B,0(UNIT)		; Get physical page #
	CALL DSKOFS		; Offset disk address by page #
	LDB C,[POINT 9,0(UNIT),17]  ; Get virtual page # again
	LSH C,9			; Make virtual address
	CALL MBREAD		; Read the page
MONBL3:	AOBJN UNIT,MONBL2	; Repeat for all entries in block
	JRST MONBL1		; On to next block if any

; MONBLT (cont'd)

; Internal routine to read page given
;	A/ Disk address
;	C/ Virtual monitor address

MBREAD:	HRLI C,101240		; Funny bits for microcode
	MVA C,			; Map virtual address
	MOVSI B,NOWAIT!NOUNLK!4	; Command to start disk read
	CALL UDSKIO		; Read page from disk
	JUMPE A,MBREA1		; Jump if no errors
	CAIE A,10		; "Clobbered monitor" error is ok
	 BUG(HLT,<MONBLT: Error reading page from save area>)
MBREA1:	MOVEI B,UBADCM		; Where to return command block
	CALL UDSKGF		; Return completion information
	SKIPL D			; Skip if no errors returned
	 BUG(HLT,<MONBLT: Error reading page from save area>)
	HRRZS D			; Isolate # pending commands
	CAIG D,UBUFS/2		; Used over half the buffers?
	 RET			; No, return now
	MOVEI A,^D10		; Yes, wait a bit
	SKIPL FORKX##		; Just loop if we are not a fork
	 DISMS			; Dismiss if we are a fork
	JRST MBREA1		; Look again

; Internal routine to wait for all outstanding reads to complete

MBWAIT:	MOVEI B,UBADCM		; Where to return command block
	CALL UDSKGF		; Return completion information
	SKIPL D			; Skip if no errors returned
	 BUG(HLT,<MONBLT: Error reading page from save area>)
	TRNN D,-1		; Any commands pending?
	 RET			; No, done
	MOVEI A,^D10		; Yes, wait a bit
	SKIPL FORKX##		; Just loop if we are not a fork
	 DISMS			; Dismiss if we are a fork
	JRST MBWAIT		; Look again

; Event buffer:

EVBUFL==100			; Length of event buffer
LS EVBUF,EVBUFL
LS LEVENT,1			; Points to the last word of the last event
LS EVSV16,1			; AC save location

; Event logging call is JSP D,EVENT
EVENT::	PIOFF
	EXCH D,LEVENT		; Save return, get event buffer pointer
	MOVEM 16,EVSV16		; Save another AC
	MOVSI 16,-EVLSTL	; Init. event list pointer
EVENT1:	TLNN D,377777		; At end or first time through?
	MOVE D,[400000-EVBUFL,,EVBUF-1] ; Yes, reset to start of buffer
	PUSH D,@EVLIST(16)	; Save a word of data in the buffer
	SKIPL EVLIST+1(16)	; End of event list?
	AOBJN 16,EVENT1		; No, loop (unless max. size)
	MOVE 16,EVSV16		; Yes, restore 16
	EXCH D,LEVENT		; Save current buffer ptr., restore return PC
	PION
	JRSTF (D)

; List of addresses of data to save.  -1 or end of list terminates.
EVLIST:	LEVENT			; Return PC
	-1			; Patch in other addresses
	-1
	-1
	-1
EVLSTL==.-EVLIST		; Max. length of event list

; Assemble KBUGH stuff now
DEFINE KBUG2(..NEW,..OLD)
<	..OLD>

	KBUGR()

	SWAPCD
>
	END
