;<PUP>PUPSEQ.MAC.34, 10-Jun-82 12:31:54, Edit by SCHOEN
; Let OS do unmapping of a fork's pages in KILLFK
;<PUP>PUPSEQ.MAC.33, 15-May-82 19:37:13, Edit by SCHOEN
; Zero last locker BEFORE freeing lock in UNLOCK
;<PUP>PUPSEQ.MAC.28, 27-Apr-82 22:35:26, Edit by SCHOEN
; Don't resignal server fork on receipt of duplicate packet
; Make sure LEAFFK is handled as two half-words
; One more time -- filter out non-sequins at RNTSV4
; Rework queues; dispense with PP queue
; SENSEQ sends data immediately, then queues it for retransmission on TX queue
; Clean up RELSEQ (correct some 8-bit arithmetic)
; Don't empty TX queue at BNTSV2
; Replace SNDQ with SNDPUP
; Don't gratuitously send contents of TX queue at BNTSRV
;<PUP>PUPSEQ.MAC.22, 25-Apr-82 15:00:43, Edit by SCHOEN
; Go NOINT in SNDQ
; Lock BNTLCK only while in SNDQ
; Check for non-sequin packets at beginning of HDLSEQ (not HDLSQ3)
;<PUP>PUPSEQ.MAC.21, 23-Apr-82 12:07:02, Edit by SCHOEN
; Unlock queue lock words if dismissed waiting for queue to empty
;<PUP>PUPSEQ.MAC.20, 16-Apr-82 14:02:26, Edit by SCHOEN
; Improve handling of SEQOUT
; Remove routine to wait for lower fork init (doesn't work well on Tops-20)
; Instead, call SGLEAF when dropping duplicate packets
;<PUP>PUPSEQ.MAC.18, 11-Apr-82 22:32:42, Edit by SCHOEN
; Add routine to wait for server fork to initialize
;<PUP>PUPSEQ.MAC.17, 11-Apr-82 21:42:50, Edit by SCHOEN
; Make some tables global
;<PUP>PUPSEQ.MAC.16, 11-Apr-82 21:23:16, Edit by SCHOEN
; Log non-sequin pups being discarded at HDLSQ3
;<PUP-TEMP>PUPSEQ.MAC.15, 11-Apr-82 00:34:05, Edit by SCHOEN
; Remove extraneous POP P,(P) from fail returns in SEQINI
;<PUP>PUPSEQ.MAC.14, 10-Apr-82 23:29:32, Edit by SCHOEN
; Stop treating SEQOUT as halfword -- count user's outstanding packets only
;<PUP>PUPSEQ.MAC.13, 10-Apr-82 20:51:28, Edit by SCHOEN
; PSQVAR, PSQPVR -> TOPVAR, TOPPVR so PUPUUO loads correctly
;<PUP>PUPSEQ.MAC.11,  6-Apr-82 12:39:22, Edit by SCHOEN
; Send SequinBroken on receipt of data Sequin for nonexistent connection
; Send SequinBroken when no free Sequins remain
; No longer timestamp buffers
; When freeing locks, make the last locker impossible.
;<PUP>PUPSEQ.MAC.8,  2-Apr-82 23:23:02, Edit by SCHOEN
; HDLSEQ checks that received packets are Sequins
;<PUP>PUPSEQ.MAC.3,  1-Apr-82 12:31:16, Edit by SCHOEN
; Don't search SYSDEF; LEAFSV.CCL includes SYS10X or SYST20 along
; with PUPDEF in compilation
;<PUP>PUPSEQ.MAC.2, 31-Mar-82 15:56:50, Edit by SCHOEN
; Shared variables via the GS macro defined in PUPDEF, rather than
; by local SHRVAR mechanism's TS macro
;<SCHOEN>PUPSEQ.MAC.71,  5-Mar-82 13:11:05, Edit by SCHOEN
; Log Sequin brokens (not DTYPE), zero CONTAB(CX) after connection has
; been cleaned up, not before!
;<SCHOEN>PUPSEQ.MAC.70, 26-Feb-82 08:49:38, Edit by SCHOEN
; Append log entry when killing connection due to timeout
;<SCHOEN>PUPSEQ.MAC.68,  3-Feb-82 20:31:04, Edit by SCHOEN
; Make MAPDAT map from file to core, rather than vs.
;<SCHOEN>PUPSEQ.MAC.64,  3-Feb-82 14:02:25, Edit by SCHOEN
; Clean stack correctly at SNDQ1 when there's no room to send
;<SCHOEN>PUPSEQ.MAC.63,  1-Feb-82 16:13:08, Edit by SCHOEN
; Make MAPDAT global (for PSVLEF routines), always map to <SYSTEM>
;<SCHOEN>PUPSEQ.MAC.61, 21-Jan-82 13:33:40, Edit by SCHOEN
; Keep track of number of active connections, do nothing when there
; are no active connections.
;<SCHOEN>PUPSEQ.MAC.60,  9-Jan-82 21:58:34, Edit by SCHOEN
; Make sure server is enabled when it starts
;<SCHOEN>PUPSEQ.MAC.59,  3-Jan-82 14:37:33, Edit by SCHOEN
; Do correct test in KILLFK on fork handle
;<SCHOEN>PUPSEQ.MAC.57,  3-Jan-82 13:55:48, Edit by SCHOEN
; Index off the correct AC to get fork handle in KILLFK
;<SCHOEN>PUPSEQ.MAC.55,  3-Jan-82 13:18:30, Edit by SCHOEN
; Kill dead connections from top fork only (fork handles are top fork relative)
;<SCHOEN>PUPSEQ.MAC.54,  2-Jan-82 13:36:48, Edit by SCHOEN
; [Tops-20] Don't call MAPDAT
;<SCHOEN>PUPSEQ.MAC.53, 15-Dec-81 10:48:41, Edit by SCHOEN
; Move responsibility for cleaning up a destroyed Sequin to BNTSV2 from 
; RNTSV2 (race condition)
;<SCHOEN>PUPSEQ.MAC.50, 11-Dec-81 14:59:11, Edit by SCHOEN
; Send packet if no allocation at receiver iff packet contains no data
; Change Sequin state to BROKen after sending a SequinBroken
; Map data pages to LEAFSV.PMAP;1;P770000 
;<SCHOEN>PUPSEQ.MAC.48, 11-Dec-81 11:27:38, Edit by SCHOEN
; make sure server is enabled to OPENF socket 43!A (for restarts)
;<SCHOEN>PUPSEQ.MAC.47,  8-Dec-81 14:02:59, Edit by SCHOEN
; More fixes to 8-bit arithmetic (had 0-377 working, but not 377-0)
;<SCHOEN>PUPSEQ.MAC.45,  7-Dec-81 17:11:09, Edit by SCHOEN
; Timestamp buffers when they're filled (for debugging info)
;<SCHOEN>PUPSEQ.MAC.42,  5-Dec-81 15:45:04, Edit by SYSTEM
; Fix 8-bit arithmetic simulations in sequence filter
;<SCHOEN>PUPSEQ.MAC.33,  4-Dec-81 22:53:10, Edit by SCHOEN
; Make BNTSRV lock shared, create locks for RX, TX, and PP queues
;<SCHOEN>PUPSEQ.MAC.31, 19-Nov-81 23:47:20, Edit by SCHOEN
; Log source of Sequin connections
;<SCHOEN>PUPSEQ.MAC.29,  6-Nov-81 16:53:14, Edit by SCHOEN
; LOG crashes
; Don't enable server forks, disable after opening socket 43!A.
;<SCHOEN>PUPSEQ.MAC.20, 23-Sep-81 10:16:20, Edit by SCHOEN
; Mere mortals get user relative socket 43 if they try to start the...
; ...server

	title	pupseq
	subttl	Sequin protocol implementation for Tenex
	search	pupdef,psqdef
	usevar	topvar,toppvr,pshvar,pshpvr

	extern lfinit

tenex,<	search stenex >
tops20,<search monsym>

;	Eric Schoen
;	SUMEX Computer Project
;	Stanford University Medical Center
;	Stanford, CA.
;	August, 1981

;	Work on Leaf and Sequin implementations in Tenex
;	and Tops-20 was funded by NIH Biotechnology Resouces 
;	Program under grant RR-00785

; format of a packet buffer
pblink==:0			; link word: previous,,next buffer
pbstat==:1			; auxiliary word

; byte pointers into Sequin packet, indexed by PB
pbhead==:2
pupLen::point 16,pbhead(pb),15	; Pup length, bytes
pupTCB::point 8,pbhead(pb),23	; Pup Transport Control Byte
PupTyp::point 8,pbhead(pb),31	; Pup Type

; pbhead+1 (normally the Pup ID field)
SeqAlc::point 8,pbhead+1(pb),7	; Sequin Allocation byte
SeqRec::point 8,pbhead+1(pb),15	; Sequin Receive sequence
SeqCon::point 8,pbhead+1(pb),23	; Sequin control byte
SeqSen::point 8,pbhead+1(pb),31	; Sequin Send sequence

; pbhead+2
ppupdn::point 8,pbhead+2(pb),7	; Pup Destination net
ppupdh::point 8,pbhead+2(pb),15	; Pup Destination host
ppupd0::point 16,pbhead+2(pb),31; Pup Destination socket high

; pbhead+3
ppupd1::point 16,pbhead+3(pb),15; Pup Destination socket low
ppupsn::point 8,pbhead+3(pb),23	; Pup Source net
ppupsh::point 8,pbhead+3(pb),31	; Pup Source host

; pbhead+4
ppupss::point 32,pbhead+4(pb),31; Pup Source socket

; pbhead+5
pbcont==pbhead+5

.noint::push p,a
	tlne f,(debugf)
	 jrst [move a,-1(p)
	       soj a,
	       movem a,.nocal	; save caller
	       movei a,400000
	       skipl intdef
		jrst .+1
	       skpir
		jrst [type <INTDEF = -1 but interrupts OFF!%/>
		      jrst .+1]
	       jrst .+1]
	movei a,400000
	aosg intdef
	 dir
	pop p,a
	popj p,

.okint::push p,a
	tlne f,(debugf)
	 jrst [move a,-1(p)
	       soj a,
	       movem a,.okcal	; save caller address
	       movei a,400000
	       skipge intdef
		jrst [type <Call to .OKINT with INTDEF = -1%/>
		      jrst .+1]
	       skpir
		jrst .+1
	       type <Call to .OKINT with INTDEF .ge. 0 and interrupts ON!%/>
	       jrst .+1]
	movei a,400000
	sosge intdef
	 eir	
	pop p,a
	popj p,

ls intdef,1			; interrupts on flag word
				; -1 means interrupts on
ls .nocal,1			; last caller of .NOINT
ls .okcal,1			; last caller of .OKINT
	subttl	Sequin Initialization

; Initialize Sequin connection management
; This routine should be called by the first user of the
; Sequin package.  Its job to is set up connection tables
; for the Sequin connections which follow.

; call: pushj p,seqini
;	a/ 0 to for sequin user, -1 for sequin server
; returns: +1, always

seqini::movem a,server
	setzm contab
	move a,[contab,,contab+1]
	blt a,contab+nconn-1
	setom bntlck		; make the background process lock free
	setzm bntlkr		; make the last locker be nonexistent
	movei a,pupbuf
	movem a,frepnt		; set up free space management
	movei a,freque		; assign the queues
	movei c,npupbf*3
	skipge server		; are we a server?
	 movei c,npupbf*nconn*3	; yes, assign queues for everyone
	pushj p,mqueue
	skipl server		; are we a server?
	 popj p,		; no, return here
	movei a,400000
	rpcap
	move c,b		; enable what we've got
	epcap
ifn ft10x,<
	hrroi b,[asciz/PUP:43!A./]
>
ifn ft20,<
	hrroi b,[asciz/PUP:43!A./]
>
	trnn c,1b18!1b19	; wheel or operator?
ifn ft10x,<
	 hrroi b,[asciz/PUP:43!U./] ; no, open user relative socket
>
ifn ft20,<
	 hrroi b,[asciz/PUP:43!U./]
>
	movsi a,1		; yes, open server socket
	gtjfn			; get a jfn
	 ercal [elog <Failed to get server socket: %1J%/>
		popj p,]
	move b,[7000,,300000]
	openf
	 ercal [elog <Failed to open server socket: %1J%/>
		popj p,]
	movem a,srvjfn		; save server jfn
	push p,a
	pushj p,psiini		; init the psi's
	pop p,a
ifn ft10x,<			; tenex, run disabled
	movei a,400000
	rpcap
	trz c,1b18!1b19		; not wheel or operator, now
	epcap
>				
	popj p,

ls srvjfn			; JFN of port in server mode
ls server			; server/user flag
ls freque,3			; free pool information block

; Initialize Sequin connection
; This routine resets the Send and Receive sequences, opens the Sequin
; connection, and creates the ring buffer of Sequin
; packets, thereby computing the receiver allocation.

; call:  a/ JFN of raw pup port opened read/write
;	sq/ Pointer to sequin data block (at least sqblen words long)
;	cx/ Connection table index, if being called as server
; returns: +1, failure (no connections open)
; 	   +2, success, cx/ Connection table index for this connection
; clobbers a,b,c

conini::skipge server		; a server?
	 jrst conin2		; yes, have cx, sq already
 	movsi cx,-nconn		; find a free connection
conin1:	skipn contab(cx)	; free connection if contab entry=0
	 jrst conin2		; found one
	aobjn cx,conin1
	popj p,			; fail if we can't find a free connection
	
; now have a connection table index.  Assign buffers for this connection
conin2:	movei cx,(cx)		; clear left half
	movem sq,contab(cx)	; assign this table
	move p1,a		; save Pup jfn
	skipge server
	 move p1,srvjfn

	movsi a,(sq)
	hrri a,1(sq)
	setzm (sq)
	blt a,sqblen-1(sq)	; clear out seqblk
	setom sendsq(sq)	; sendsq starts at -1

	movei a,freque		; from the free queue...
	movei c,npupbf		; make npupbfs on each queue
	movei b,(cx)		; get table address
	imuli b,lqutab		; compute index into table for connection
	movei b,txtab(b)	; get that address
	movem b,sqtxcu(sq)	; save it
	setom qulock(b)		; init the queue lock
	pushj p,aqueue		; make the queue
	 popj p,

	movei b,(cx)
	imuli b,lqutab
	movei b,rxtab(b)
	movem b,sqrxcu(sq)
	setom qulock(b)
	pushj p,aqueue
	 popj p,

	movsi a,npupbf		; init connection allocation
	movem a,seqall(sq)
	
; now fill in sequin data block with local and foreign port info
	move a,p1		; retrieve pup jfn
	cvskt			; get local port params
	 ercal jerr
	movem b,seqlnh(sq)	; save local net,,host
	movem c,seqlsk(sq)	; save local socket
	skipge server		; server?
	 jrst [move a,pupfnh(cx); yes, get foreign stuff from cx tables
	       movem a,seqfnh(sq)
	       move a,pupfsk(cx)
	       movem a,seqfsk(sq)
	       jrst conin6]
	movei c,seqfnh(sq)	; get foreign port params
	hrli c,2
	gdsts
	 ercal jerr
	hrlm a,sqjfnx(sq)	; save jfn and connection index
conin6:	hrrm cx,sqjfnx(sq)
	movei a,leafSk		; default socket if necessary
	skipn seqfsk(sq)	; a socket specified?
	 movem a,seqfsk(sq)	; no
	hlrz a,seqlnh(sq)	; see if local net specified
	jumpn a,conin5
	hlrz c,seqfnh(sq)	; no, check foreign net
	jumpe c,conin5		; jump if not specified either
	move a,[sixbit /puprou/]  ; get routing table entry for net
	sysgt
	hrrz a,b		; table number
	hrli a,-1(c)		; entry
	getab
	 ercal jerr
	trnn a,-1		; are we directly connected?
	 ldb c,[point 8,a,9]	; no, use net of gateway
	hrlm c,seqlnh(sq)	; establish local net

	move a,[connt,,filet]	; set up timeouts
	movem a,ltime(cx)	; local timeout 

	move a,[connt,,filet_-1]; remote timeout
	movem a,ftime(cx)
	
	skipl server		; if not serving...
	 jrst conin5		; ... open the connection...
	pushj p,makfrk		; ... otherwise, make fork for connection
	 error <Failed to create connection fork: %1J>,1
	setzm lfinit(cx)	; say server not yet initialized
	movei a,(cx)		; get real connection index
	log <Connection %1O opened from %2P>
	aos (p)			; and return if successful
	popj p,

; now open the Sequin connection
conin5:	setz a,			; send no data with this pup
	movei b,seqOpn
	pushj p,senSeq		; send a Sequin packet
	aos (p)			; increment return
	popj p,			; return

	subttl	Sequin Send

; routine to send a Sequin packet
; call: a/length*,,address of data to send in packet (0 if none)
;	b/SequinOp (-1 to default to most reasonable choice)
;      sq/pointer to Sequin data block
; return: +1 always
; * length in 16 bit words

senseq::push p,pb		; save packet buffer pointer
	push p,a		; save address
	push p,b		; save SequinOp
	move a,sqtxcu(sq)
	move b,qusize(a)	; get queue size
	camg b,qucnt(a)		; is there room?
	 jrst [push p,a		; no, wait until there is
	       movei a,^d250
	       disms
	       pop p,a
	       jrst .-2]
	movei a,qulock(a)	; there's room, lock the queue
	pushj p,lock
	move a,sqtxcu(sq)	; recover queue pointer
	hlrz pb,(a)		; get pup pointer
	hrrz b,0(pb)		; get address of next buffer
	cain b,0		; get a zero?
	 jrst [dtype <Buffer chain points to nowhere!!%/%/>
	       pushj p,jerr
	       jrst .+1]
	hrlm b,(a)		; store as next available buffer
	aos 2(a)		; increment queue count
	pop p,b			; retrieve sequinOp
	move a,(p)		; retrieve a
	jumpe a,sensq1		; minimum length if no data
	hlrz a,a		; get word length
	lsh a,1			; convert to bytes
sensq1:	addi a,mnplen		; add header length
	dpb a,puplen		; save pup length
	setz a,			; clear transport control byte
	dpb a,puptcb
	movei a,seqtyp		; type is "sequin"
	dpb a,puptyp

; we run with 0 allocation for lockstep handling, since it is very easy for
; our 2020 to be overrun with packets from an IFS, even when Sequin is the
; only active process on the machine!

	setz a,
repeat 0,<
	hlrz a,seqall(sq)	; store allocation byte
>
	dpb a,seqalc
	move a,recvsq(sq)	; store receiver sequence
	dpb a,seqrec
	move a,sendsq(sq)
	ldb c,puplen		; get length
	caie c,MNPLEN		; any contents bytes?
	 jrst [aoj a,		; yes, increment send sequence
	       andi a,377
	       movem a,sendsq(sq)
	       jrst sensq4]
	caige a,0		; is this the first packet out on connection?
	 aoj a,			; yes, go from -1 to 0 in send sequence

sensq4:	dpb a,seqsen
	skipl a,b		; get sequinOp into a
	 jrst sensq2		; caller supplied explicit op
	movei a,seqdat		; control is sequinData
	skipn 0(p)		; send a SequinNop if no data
	 movei a,seqnop
	skipn seqsta(sq)	; unless connection is not open
	 movei a,seqopn		; in which case, send a SequinOpen
sensq2:	dpb a,seqcon		; store control byte

	hlrz a,seqfnh(sq)	; store foreign net
	dpb a,ppupdn
	hrrz a,seqfnh(sq)	; store foreign host
	dpb a,ppupdh
	move a,seqfsk(sq)	; store foreign socket
 	dpb a,ppupd1		; low order
	rot a,-^d16
	dpb a,ppupd0		; high order

	hlrz a,seqlnh(sq)		; store local net
	dpb a,ppupsn
	hrrz a,seqlnh(sq)		; store local host
	dpb a,ppupsh
	move a,seqlsk(sq)		; store local socket
	dpb a,ppupss		

; move any data into Sequin packet
	pop p,a			; recover length,,address
	jumpe a,sensq5		; skip this if no data to send
	hlrz b,a		; get length
	aoj b,
	idivi b,2		; convert to PDP10 words
	hrl a,a			; set up to BLT data
	hrri a,pbcont(pb)
	addi b,pbcont-1(pb)
	blt a,(b)		; transfer data into packet buffer
sensq5:	tro f,tempf1		; Remember that we have the tx queue locked
; skip the stack manipulation following

; send packet
; also here to retransmit packets from retransmit queue
; sq/ points to Sequin data block for this connection
; pb/ points to packet buffer for the Sequin data packet
sensq3:	movei b,(pb)
	pushj p,sndpup		; Send the pup off
	trze f,tempf1
	 jrst  [move a,sqtxcu(sq) ; called from above?
		movei a,qulock(a) ; yes, unlock the queue
		pushj p,unlock		
		pop p,pb	; restore packet buffer pointer
		popj p,]	; return
	popj p,			; return

	subttl	Sequin Resend

; This routine is called to resend any packets in the retransmission
; queue which have not been acknowledged yet (i.e. on receipt of a
; SequinRestart packet).
; Only data containing packets are resent, control packets are ignored.
; sq/ pointer to sequin data block for this connection
; returns +1 always

rsnseq:	push p,pb		; save packet buffer pointer
	move a,sqtxcu(sq)	; lock the queue for consistency
	movei a,qulock(a)
	pushj p,lock
	trz f,tempf1		; make sure we don't look like SENSEQ
	tlo f,(sqrtrn)		; say we're retransmitting
	hrrz pb,@sqtxcu(sq)	; pick up retransmission pointer
	hlrz a,@sqtxcu(sq)	; get transmission pointer?
	push p,a		; save on stack
rsnsq1:	camn pb,(p)		; reached transmission pointer?
	 jrst rsnsq3		; yes, return
	ldb a,puplen
	caile a,MNPLEN		; only resend data packets
	 pushj p,sensq3		; resend this packet
rsnsq2:	hrrz pb,0(pb)		; look at next packet buffer
	jrst rsnsq1		; loop

; here when done
rsnsq3:	pop p,(p)		; remove transmission pointer entry
	pop p,pb
	tlz f,(sqrtrn)		; no longer retransmitting
	move a,sqtxcu(sq)
	movei a,qulock(a)
	pushj p,unlock		; unlock the queue
	popj p,			; return to caller

	subttl	Sequin Release packets on retransmission queue

; This routine frees packets on the retransmission queue which have
; been acknowledged by the other process
; a/ receive sequence number from the acknowledgement
; sq/ pointer to sequin data block for this connection
; Returns +1 always,
; b/ number of freed buffers
relseq:	noint
	push p,c
	push p,d
	setz d,			; d counts number of freed buffers
	push p,pb		; don't kill pb
	setz b,
	push p,b		; (p) counts number of freed packets
	move pb,sqtxcu(sq)
relsq0:	hrrz pb,(pb)		; pick up retransmit queue pointer
	move b,sqtxcu(sq)	; compare with transmit queue pointer
	hlrz b,(b)
	cain b,(pb)		; if equal, we're done, else loop
         jrst relsq1		; equal, leave
	ldb b,seqsen		; look at this packet's send sequence
; do 8-bit arithmetic
	camn a,b		; does recv'd ack = send seq of this packet?
	 jrst relsq1		; yes, we're done
	ldb b,puplen		; any data in this packet?
	caie b,mnplen	
	 aos (p)		; yes, increment released packet count
	aoja d,relsq0

relsq1:	move b,sqtxcu(sq)
	hrrm pb,(b)		; store updated dequeue pointer
	move c,2(b)		; get queue item count
	subi c,(d)		; adjust for freed items
	movem c,2(b)		; save new value
	pop p,b			; get freed buffer count
	pop p,pb		; restore pb
	pop p,d
	pop p,c
	okint
	popj p,			; return
	subttl Sequin Receive 
	
; this routine is called to receive Sequin packets

; Packets which are returned by this routine have already been
; input by an interrupt level routine.  These packets are placed
; in a ring buffer, like the retransmit buffer.  This routine returns
; these packets to the caller if and only if they contain data destined 
; for some higher level process (i.e. Leaf).

; call: a/ location to store received packet in (assumed MXPBLN-MNPBLN long)
;      sq/ pointer to sequin data block for this connection
; return: +1 failure: a/ -1 if timeout, 
;			 other error codes as defined above,
;	  +2: success, packet stored in location pointed to by A
;		      a/ number of bytes stored

; clobbers c,d

inpSeq::push p,a		; save address
	time
	addi a,sqtmin		; add timeout interval
	movem a,sqtime(sq)	; save timeout time

; loop here looking for packets
inpSq1: move a,sqrxcu(sq)	; get pointer to receive queue
	skipn 2(a)		; anything in the queue?
	 jrst inpSq0		; no, wait a bit
	pop p,b			; retrieve storage address
	tlo b,(1b0)		; flag DQUEUE to return only data portion
	pushj p,dqueue		; get from queue
	subi a,mnplen		; remove overhead from packet length
	aos (p)			; return +2
	popj p,

; here when the received packet queue is empty
; waits here for 250 ms, and then tries again (at inpSq1, above)
; if we timeout, return to caller =1 with a/ errTim (timeout)
inpSq0:	time			; get time
	camge a,sqtime(sq)	; timed out, yet?
	 jrst [movei a,^d250	; no, loop
	       disms
	       jrst inpSq1]
	pop p,a			; clean stack
	movei a,errTim
	popj p,			; return +1 with timeout


; Interrupt level code to handle received packet
; call: input PUP in tmprec
; returns: +1 always
; a contains some error code (see PSQDEF.MAC) or zero

; Here when there is a packet in the received Sequin packet queue.
; Here, we dispatch on the packet type and perform any Sequin-level
; tasks which need to be performed.  This code parallels the routine
; HandlePBI in IFSSequinSwap.bcpl (IFS Leaf/Sequin implementation).

hdlSeq:	movei pb,tmprec-2	; point to input packet
	ldb a,seqCon		; get control field
	cain a,seqOpn		; if it's a sequinOpen
	 skipa
	cain a,seqCls		; or a sequinClose
	 movei a,seqDat		; make it look like a sequinData
	movem a,contro		; save control type
	
	tlnn f,(debugf)
	 jrst hdlsq4
	move a,recvsq(sq)
	move b,sendsq(sq)
	hrroi c,temp
	write c,<HDLSEQ: My send #%2O, recv #%1O; >
	ldb a,SeqSen
	ldb b,SeqRec
	write c,<packet send #%1O, recv #%2O>
	hrroi c,temp
	log <%3S>

hdlsq4:	ldb a,SeqSen		; get incoming send sequence
	move b,recvsq(sq)	; and expected send sequence
	pushj p,comSeq		; compare sequence numbers
	 jrst sqFail		; +1: out-of-range, go die
	 jrst sqRqRe		; +2: ahead, request retransmission
	 jrst sqDupl		; +3: duplicate, drop packet
	 jrst sqChng		; +4: previous, change control to restart

; if here, either OK or Sequin control changed to SequinRestart
hdlSq1:	ldb a,SeqAlc		; get other process's allocation
	hrrm a,seqAll(sq)	; save it
	ldb a,SeqRec		; now compare incoming recv sequence...
	move b,sendsq(sq)	; ... against my send sequence
	pushj p,comSeq
	 jrst sqFail		; +1: out-of-range, go to die
	 jrst hdlSq3		; +2: ahead, fall through
	 jrst sqDupl		; +3: duplicate, drop packet 
	 jfcl			; +4: previous, fall through
	skiple seqout(sq)	; +5: equal, adjust outstanding packet count
	 sos seqout(sq)		;
	jrst hdlsq5		; go handle states
; ...
; if here, sequence compare equal, duplicate, or previous
; in any case, release packets from the retransmission queue which
; are acknowledged by this packet, and process the data in the packet,
; if there is any

hdlSq3:	move a,contro
	cain a,SeqRes		; is control a Restart?
	 jrst [skiple seqout(sq)
		sos seqout(sq)	; yes, adjust outstanding packet count
	       jrst hdlsq5]	; and fall through
	ldb a,seqRec		; get receive sequence
	pushj p,relSeq		; release those packets this one acks
	move a,seqout(sq)	; update outstanding packet count
	caile a,0		; don't if a is 0 or less
	 sub a,b
	jumpl a,[push p,a
		 movei a,(cx)
		 elog <HDLSEQ: Overdecremented SEQOUT for connection %1O>
		 pop p,a
		 setzm seqout(sq)
		 jrst .+1]
	movem a,seqout(sq)
	movei a,(cx)
;	dtype <HDLSQ3: Freed %2O packets on connection %1O%/>

; dispatch on state of connection
hdlsq5:	move a,seqSta(sq)	; get connection state
	jrst @stattb(a)		; dispatch

; now dispatch on control field
hdlsq2:	move a,control
	jrst @ctrltb(a)		; dispatch

; dispatch table to handle sequin connection state
stattb:	stCLOS 			; state is closed
	stOPEN 			; state is open
	stDLLY 			; state is dallying
	stBROK 			; state is broken
	stDSTR 			; state is destroyed
	stTIMD 			; state is timed out

; dispatch table to handle different control types in Sequin packets
ctrltb:	hdlDat			; handle Sequin data
	hdlAck			; handle Sequin ack
	hdlNop			; handle Sequin nop
	hdlRes			; handle Sequin restart
	hdlChk			; handle Sequin check
	screwup			; can't get Sequin open in control
	hdlBrk			; handle Sequin break
	screwup			; can't get Sequin close in control
	hdlCld			; handle Sequin closed
	hdlDes			; handle Sequin destroy
	hdlDal			; handle Sequin dally
	hdlQui			; handle Sequin quit
	hdlBro			; handle Sequin broken

	subttl	Sequin Receive utilities

; routine to compare sequence numbers
; call: a/first sequence number
;	b/second sequence number
; Returns +1: (a-b) is out of range
;	  +2: (a-b) is between 1 and mxAhed
;	  +3: (a-b) is between -2 and -mxAhed
;	  +4: (a-b) is -1
;	  +5: a=b
; Clobbers a,b
comSeq:	sub a,b			; compute a-b
	andi a,377
	trne a,200
	 ior a,[-1,,777400]	; simluating 8-bit arithmetic
	movm b,a		; get magnitude of difference
	caile b,mxAhed		; too big a difference?
	 popj p,		; yes, return +1
	aos (p)			; return at least +2
	caile a,0		; a positive?
	 popj p,		; yes, return +2
	aos (p)			; no, return at least +3
	camge a,[-1,,-1]	; a .ge. -1?
	 popj p,		; no, return +3
	aos (p)			; yes, return at least +4
	caie a,0		; a = 0?
	 popj p,		; no, must be -1; return +4
	aos (p)			; else return +5
	popj p,

; here when sequence numbers are out of range
sqFail:	setz a,			; send a sequinBroken Op
	movei b,seqBro		; the world ends!
	pushj p,senSeq

	movei a,(cx)
	log <SQFAIL: Sequin broken on connection %1O%/>
	movei a,DSTR
	movem a,seqSta(sq)	; change state to BROKen
	movei a,errDes		; signal sequin broken
	popj p,			; return +1

; here to request retransmission of all unacknowledged packets
; this routine sends a sequinRestart, and returns
sqRqRe:	setz a,			; send a sequinRestart
	movei b,seqRes
	pushj p,senSeq		; send it out
	movei a,(cx)
	dtype <SQRQRE: Sending sequinRestart for connection %1O%/>

; also here to return from HDLSEQ without queueing anything for Leaf
rethdl:	setz a,
	popj p,

; here when packet received is flagged as "duplicate"
; simply drop the packet
sqDupl:	movei a,(cx)
	dtype <SQDUPL: Dropping duplicate packet for connection %1O%/>
	jrst rethdl

; here when incoming packet is flagged as "previous"
; change control field to restart, and fall through
sqChng:	move a,control		; only make this a restart if control=data
	caie a,SeqDat
	 jrst rethdl
 	movei a,seqRes
	movem a,control		; store control
	movei a,(cx)
	dtype <SQCHNG: Incoming control becomes RESTART on connection %1O%/>
	jrst hdlsq1		; fall back to hdlseq


; dispatch code from control and state dispatches here

; here to handle CLOSed state
stCLOS:	ldb a,seqCon		; get original control byte
	caie a,seqDat		; was it a data byte?
	 cain a,seqOpn		; or an open request?
	  jrst stTIMD		; then fall through
	jrst stOPEN		; else make believe state is open
	   
; fall through

; here if state is timed out
stTIMD:	movei a,OPEN
	movem a,seqSta(sq)	; make state open
; fall through

; here if state is OPEN
stOPEN:	pushj p,strxtm		; set receive timer
	jrst hdlSq2		; return

; here if state is broken
stBROK:	setz a,
	movei b,seqBro
	pushj p,senSeq		; send a sequin broken
	movei a,errBro		; say Sequin is broken
	popj p,			; return bad

; here if in dallying state
stDLLY:	move a,contro		; get control
	cain a,seqQui		; was it a quit?
	 jrst stDLY1		; yes, go die
	setz a,
	movei b,seqDal		; no, send a dally in return
	pushj p,senseq
	setz a,
	popj p,			; and wait for more packets

stDLY1:	movei a,DSTR		; say Sequin is destroyed
	movem a,seqSta(sq)
	movei a,errDes
	popj p,			; received a quit, return +1

; here if in destroyed state
stDSTR:	dtype <STDSTR: Received packet while in DESTROYED state>
	movei a,errDes		; say sequin is destroyed
	popj p,			; return 


; these routine handle the various control fields in the sequin packet

; here when control field is "destroy"
hdlDes:	movei a,DLLY		; make state = dallying
	movem a,seqSta(sq)
	setz a,			; respond with a dallying packet
	movei b,seqDal
	pushj p,senSeq		; send off the packet
	setz a,
	popj p,			; wait for a reply

; here to respond to a SequinDally
hdlDal:	setz a,
	movei b,seqQui		; respond with a SequinQuit
	pushj p,senSeq
	movei a,ErrDes		; say Sequin has been destroyed
	popj p,

; here to respond to a seqChk or seqNop
hdlChk:
hdlNop:	setz a,
	movei b,seqAck		; reply with an ack
	pushj p,senSeq		; send it
	setz a,
	popj p,			; wait for more packets to come in

; here to respond to a SequinRestart
hdlRes:	pushj p,rsnseq		; resend the transmit queue
	setz a,
	popj p,			; wait for more packets

; here to respond to a sequinAck
hdlAck:	setz a,
	popj p,			; just keep waiting

; here to respond to a SequinData
hdlDat:	move a,seqSta(sq)	; get state
	caie a,OPEN		; are we open?
	 jrst sqFail		; no, respond with sequinBroken, ret +1
	movei b,seqAck		; prepare to respond with sequinAck
	ldb a,seqCon		; get real control field
	cain a,seqCls		; is it a sequinClose?
	 jrst [movei a,CLOS	; make state = CLOSed
	       movem a,seqSta(sq)
	       movei b,seqCld	; prepare to respond with sequinClosed
	       jrst .+1]
	ldb a,puplen		; get length of incoming pup
	caig a,MNPLEN		; greater than minimum?
	 jrst [setz a,		; no, send an acknowledgement
	       pushj p,senSeq	; send the reply
	       setz a,
	       popj p,]		; and wait for more input
	aos a,recvsq(sq)	; increment received sequence number
	andi a,377
	movem a,recvsq(sq)	; save masked number
	pushj p,inSequ		; move the packet to the caller's space
	setz a,
	popj p,
	
hdlBrk:
hdlBro:
hdlCld:
hdlQui:	jrst sqFail		; don't like receiving these here


; here to move data into caller's space
; pb/ pointer to packet buffer
; clobbers a,b,c
; returns +1 always
inSequ:	move a,sqrxcu(sq)
	movei b,pbhead(pb)	; yes, queue packet, else drop on floor 
	skipn 2(a)		; is the queue empty?
	 tro f,tempf1		; yes, remember
	move c,1(a)		; get buffer size
	camle c,2(a)		; is there room?
	 pushj p,nqueue		; yes, otherwise drop on floor
	trze f,tempf1		; was the queue empty?
	 pushj p,sgleaf		; yes, signal leaf to run
	popj p,			; return

; here to signal a leaf fork that a previously empty queue now has data in it
; call: pushj p,sgleaf
;	cx/ connection index for this connection
; returns: +1, always
; clobbers a,b
sgleaf:	skipl leaffk(sq)	; only interrupt if B0 of leaffk is on
	 popj p,
	move a,connfk(cx)	; get fork handle
	move b,[sigchn]
	iic
	popj p,

; here if server fork isn't initialized; wait 5 seconds, then kill fork
sglf1:	time
	addi a,5000
	push p,a		; save timeout time
sglf1a:	movei a,100		; wait a little bit
	disms
	skipe lfinit(cx)	; ready yet?
	 jrst [pop p,(p)	; yes, clean stack and return
	       popj p,]
	time			; check the time
	caml a,(p)		; timed out yet?
	 jrst [movei a,DSTR	; yes, destroy this sequin
	       movem a,seqsta(sq)
	       pop p,(p)
	       movei a,(cx)
	       elog <Connection %1O won't init; destroying...>
	       popj p,]
	jrst sglf1a

	subttl General utilities

; routines to manage queues
; a queue is a doubly-linked set of buffers of mamximum pup length, plus
; a couple of words of queue and buffer management overhead (see beginning
; of this file).  Associated with each queue is a queue information block
; containing:
;	enqueue,,dequeue pointers for the queue
;	size of queue
;	count of items in the queue

; routine to create a free buffer pool
; call: pushj p,mqueue
; 	a/ points to queue information word for this queue
; 	c/ number of buffers to assign
; returns: +1 always
; clobbers b,c
mqueue:	push p,p1		; save a permanent location
	move p1,a		; point queue info pointer in a safe place
	movem c,1(p1)		; get queue size
	pushj p,asgfre		; get a buffer
	hrrm a,(p1)		; save dequeue pointer
	hrlm a,(p1)		; save enqueue pointer
	push p,a		; save address of first buffer
	soje c,mquex		; leave if all buffers reserved

mque1:	move b,a		; save address of this buffer
	pushj p,asgfre		; get next buffer
	hrrm a,(b)		; link it to previous buffer
	hrlm b,(a)		; link previous buffer to it
	sojn c,mque1		; loop if more to do

mquex:	hlrz b,(p1)		; get enqueue pointer
	hrlm a,(b)		; make first buffer point back to last 
	hrrm a,quemax		; save highest queue address
	pop p,b			; retrieve first buffer address
	hrrm b,(a)		; make last buffer point forward to first
	move a,p1		; restore a
	setzm 2(a)		; make queue empty
	pop p,p1
	popj p,

ls quemax			; contains address of highest queue entry

; routine to assign buffers from free buffer pool to a process
; call: a/ address of free buffer pool information word
;	b/ address of information word for buffers being assigned
;	c/ number of buffers requested
; returns: +1, not enough available buffers
;	   +2, success, buffers assigned

aqueue:	push p,d		; save d
	push p,a		; save arguments
	push p,b
	push p,c

	hrrz a,(a)		; get address of first buffer in free pool
	movem a,(b)		; save in new info block
	hrlm a,(b)
	movem c,1(b)		; save queue size
	setzm 2(b)		; and make it initially empty

	move b,-2(p)		; get address of free pool info block
	move d,1(b)		; get free pool size
	subi d,(c)		; remove number of requested buffers
	jumpl d,aqueux		; fail if can't assigned requested number
	movem d,1(b)

	push p,a		; save address of first buffer in new queue
	caia			; enter assign loop
aqueu1:	hrrz a,(a)		; get free buffer pool header
	sojn c,aqueu1		; loop until found last desired buffer

	hrrz c,(a)		; get address of new first buffer in free pool
	move b,(p)		; get address of first buffer
	hrrm b,(a)		; place in link word
	hlrz d,(b)		; get last buffer in free pool
	hrlm a,(b)		; place addr of last buffer in first entry
	move a,-3(p)		; get address of free pool info block
	hrrm c,(a)		; store new first buffer
	hrlm d,(c)		; store last free pool buffer in new first buf

	pop p,(p)
	aos -4(p)		; return successfully
aqueux:	pop p,c			; recovers acs
	pop p,b
	pop p,a
	pop p,d
	popj p,

; routine to return a queue of buffers to the free buffer pool
; call: a/ address of free pool information block
;	b/ address of information block for buffer queue being deassigned
; returns: +1, always
rqueue:	push p,c		; save c
	push p,d		; and d
	push p,a		; also save arguments
	push p,b
	move d,1(b)		; get size of buffer queue being returned
	skipn 1(a)		; is free pool currently empty?
	 jrst [movsi c,(b)	; yes, just move queue over
	       hrri c,(a)
	       blt c,2(a)
	       setzm 1(b)
	       jrst rqueux]
	hrrz c,(a)		; get address of first buffer in free pool
	hlrz c,(c)		; get address of last buffer in pool
	hrrz b,(b)		; get address of buffer in returning queue
	hrrm b,(c)		; link it into free pool
	hrlm c,(b)		; and link free pool into it
	caia			; enter loop
rqueu1:	hrrz b,(b)		; get next buffer in queue
	sojn d,rqueu1		; loop until through all buffers

	hrrz a,(a)		; b has last buffer addr, get 1st in free pool
	hrlm b,(a)		; complete linking returned queue into free
	hrrm a,(b)

	move b,(p)
	move a,-1(p)
	exch d,1(b)		; zero queue size for returned queue
	setzm 2(b)		; make it empty, too
	addm d,1(a)		; add returned queue size to free pool size
rqueux:	pop p,b
	pop p,a
	pop p,d			; recover d and c
	pop p,c
	popj p,			; and return


; routine to place an item on queue
; call: a/address of queue information word
;	b/address of pup to place on queue
; returns: +1 always
; if queue if full, then process waits until it can place item on queue

nqueue:	push p,pb		; don't clobber pb
	push p,a
	push p,b
	movei a,qulock(a)	; lock queue
	pushj p,lock
	move a,-1(p)
	movei pb,-pbhead(b)	; set up bytepointers for this packet
	move b,1(a)		; get size of queue
	camg b,2(a)		; is size > count?
	 jrst [push p,a
	       movei a,qulock(a)
	       pushj p,unlock	; unlock while dismissed
	       movei a,^d250	; wait 250 ms
	       disms
	       move a,(p)
	       movei a,qulock(a)
	       pushj p,lock	; relock when done waiting
	       pop p,a
	       jrst .-2]	; and try again
	ldb a,puplen		; compute length of move
	idivi a,4
	caie b,0
	 aoj a,
	move b,-1(p)		; a has length in words, compute last address
	hlrz b,(b)		; set up BLT pointer
	addi b,pbhead-1(a)	; b has last address to BLT to now
	move a,-1(p)
	hlrz a,(a)		; get enqueue pointer
	addi a,pbhead		; point into data region of queue
	hrli a,pbhead(pb)
	blt a,(b)		; transfer onto queue
	hrrz b,-1(p)
	hlrz a,(b)		; update queue pointer
	hrrz a,(a)
	cain a,0		; check for foul link
	 jrst [elog <Buffer chain points nowhere!%/%/>
	       pushj p,jerr
	       jrst .+1]
	hrlm a,(b)
	pop p,b
	pop p,a
	aos 2(a)		; increment item count
	push p,a		; unlock queue
	movei a,qulock(a)
	pushj p,unlock
	pop p,a
	pop p,pb
	popj p,

; routine to dequeue item from queue
; call: a/ address of queue information word
;	b/ address to write into
;	   B0 on means return data part only
; returns: +1 always (waits if queue is empty)
dqueue:	push p,p1
	push p,pb		; save some acs
	push p,a
	push p,b
	movei a,qulock(a)	; lock the queue
	pushj p,lock
	move a,-1(p)
	hrrz pb,(a)		; get dequeue pointer
	hrrz b,2(a)		; get item count
	cain b,0		; wait if it's zero
	 jrst [push p,a
	       movei a,qulock(a)
	       pushj p,unlock	; unlock while dismissed
	       movei a,^d250	; wait 250 ms
	       disms
	       move a,(p)
	       movei a,qulock(a)
	       pushj p,lock	; relock when done waiting
	       pop p,a
	       jrst .-2]	; and try again
	ldb a,puplen		; see how many words to transfer
	skipge 0(p)
	 move p1,a		; if returning data only, save packet len
	idivi a,4
	caie b,0
	 aoj a,
	move b,(p)		; a has len in wds, make BLT pointer
	hrli b,pbhead(pb)	; read following queue link word
	addi a,-1(b)		; b is source,,dest; get addr of last word
	skipge 0(p)		; want data part only?
	 jrst [add b,[mnpbln-1,,0]; yes, adjust BLT stuff
	       subi a,mnpbln-1
	       jrst .+1]
	blt b,(a)
	pop p,b
	pop p,a
	hrrz pb,(pb)		; update queue pointer
	cain pb,0
	 jrst [elog <Buffer chain points nowhere!%/%/>
	       pushj p,jerr
	       jrst .+1]
	hrrm pb,(a)
	sos 2(a)		; decrement queue item count
	push p,a		; save address of queue block
	movei a,qulock(a)	; compute address of lock
	pushj p,unlock		; unlock
	pop p,a			; restore address
	skipge b
	 move a,p1		; return packet length if necessary
	pop p,pb	
	pop p,p1
	popj p,			; return
	

; routine to mark out a buffer (MXPBLN+PBHEAD words)
; returns: +1 always, a/ address of buffer
asgfre:	move a,frepnt
	push p,a
	addi a,mxpbln+pbhead
	movem a,frepnt
	pop p,a
	popj p,

; routines to set timeouts for various connections

; routine to set timeout to keep connection alive
; call: cx/ connection index for this connection
; returns: +1 always, transparent to acs
sttxtm:	push p,a		; get now
	push p,b
	time
	hrrz b,ftime(cx)
	imuli b,^d1000		; convert to ms
	add a,b
	movem a,txtime(cx)	; save time to transmit in table
	pop p,b
	pop p,a
	popj p,

; routine to set timeout on received packets
; call: cx/ connection index for this connection
; returns: +1 always, transparent to acs
strxtm:	push p,a		; get now
	push p,b
	time
	hrrz b,ltime(cx)
	imuli b,^d1000		; convert to ms
	add a,b
	movem a,rxtime(cx)	; save time to receive by
	pop p,b
	pop p,a
	popj p,

; routine to set local timeout params (called by Leaf server)
; call: pushj p,stlctm
;	a/ connection,,file timeout (seconds)
;	cx/ connection table index
; returns: +1, always
stlctm::movem a,ltime(cx)
	popj p,

; routine to set foreign timeout params (called by Leaf user)
; call: pushj p,stfntm
;	a/ connection,,file timeout (seconds)
;	cx/ connection table index
; returns: +1, always
; A SequinNop will be sent every time the file timeout expires.  Thus,
; it is advisable to set the file timeout to be something less than the
; server's file timeout.  The default timeout is 5 minutes, one-half the
; default timeout for the IFS.

stfntm::movem a,ftime(cx)
	popj p,

; routine to create a server fork
; call: pushj p,makfrk
;	cx/ connection index
;	sq/ address of sequin data block
; returns: +1, failure, JSYS error code in 1
;	   +2, success; leaffk(sq) containing fork handle of fork
; clobbers a,b,c,d
makfrk:	movsi a,(1b1)
	cfork			; create empty fork with superior's capenb
	 popj p,
tenex,<
	cfgrp			; in Tenex, do proxy logins for fork groups
	 popj p,
>
	hrrzm a,leaffk(sq)	; save fork index in sequin data block
	movem a,connfk(cx)	; and in table indexed by connection
	move d,[400000,,1000]	; stop PMAP loop when AC1 contains (d)
	movsi c,(1b2!1b4!1b9)	; map read, cw, execute
	hrlz b,a		; map from this fork to inferior
	movsi a,400000
makfk1:	camn a,d		; done yet?
	 jrst makfk3		; yes, leave
	push p,b		; no, check if this page exists
	rpacs
	tlnn b,(1b5)		; page exists?
	 jrst [push p,a		; make the page exist
	       movei a,(a)
	       lsh a,^d9
	       setzm (a)	; touch it
	       pop p,a
	       jrst .+1]
	pop p,b			; yes, map to inferior
	pmap
	caia
makfk2:	pop p,b
	aoj b,			; increment page numbers
	aoja a,makfk1		; and loop

; here when done mapping pages... make certain pages read, write, exec
makfk3: hll a,b
	hrri a,ishloc/1000	; starting at ishloc
	move c,quemax
	lsh c,-^d9
	aoj c,
	subi c,-1(a)		; number of pages to change
makfk4:	rpacs
	tlne b,(1b5)		; page exists?
	 jrst [movsi b,(1b2!1b3); yes, change to read, write
	       spacs
	       jrst .+1]
	aoj a,
	sojn c,makfk4

	hlrz a,a		; get fork handle
	setz b,			; set fork acs
	sfacs
	movei b,leaf##		; start at leaf
	sfork
	aos (p)
	popj p,

; here to kill a server fork
; call: pushj p,killfk
;	sq/ address of sequin data block
;	cx/ connection table index
; returns: +1, always
; clobbers a,b,c
killfk:	hrrz a,connfk(cx)	; check consistency of fork handle
	caig a,400000		; for debugging
	 jrst  [movei b,(cx)
		elog <Connection %2O claims fork handle %1O for server>
		popj p,]
	kfork
	setzm leaffk(sq)
	setzm connfk(cx)	; clear fork pointers
	popj p,			; returns

; lock and unlock utilities to insure contention-free program flow
; routine to lock a data structure
; call: pushj p,lock
;	a/address of lock block (word 0 = lock, word 1 = fx of locker)
; returns: +1, always, when locked
lock:	aose (a)		; try to lock
	 jrst .-1
	movem fx,1(a)
	popj p,

; routine to unlock
; call: pushj p,unlock
;	a/address of lock block
unlock: push p,a
	move a,(a)		; get lock word
	camn a,[-1,,-1]		; is it locked?
	 jrst [move a,(p)
	       elog <Lock at %1O is not locked>
	       jrst .+1]
	pop p,a
	came fx,1(a)		; do we own the lock?
	 jrst [elog <Attempt to unlock lock at %1O by improper process %16O>
	       pushj p,screwup]
	setzm 1(a)		; yes, make the last locker impossible
	setom (a)		; free lock
	popj p,

; routine to map data space into a thawed file so (enabled) others can look at
; what the server is doing
mapdat::movsi a,1		; get the .PMAP file
ifn ft10x,<
	hrroi b,[asciz/<SYSTEM>LEAFSV.PMAP;1;P770000/]
>
ifn ft20,<
	hrroi b,[asciz/SYSTEM:LEAFSV.PMAP.1;P770000/]
>
	gtjfn
	 jrst mapdaf
	move p1,a
	move b,[44b5+1b19+1b20+1b25]	; open read, write, thawed, 36 bits
	openf
	 jrst mapdaf
	move b,[400000,,ilsloc/1000]
	hrlz a,p1
	hrri a,ilsloc/1000
	movsi c,(1b2!1b3)	; map read/write
	move d,[400000,,600]	; stop here
mapda1: move p2,b
	move b,a
	seto a,
	pmap			; delete the file page
	move a,b		; (hope this works on Tops-20)
	move b,p2
	pmap			; map a page to core
	aoj b,			; increment core address
	came b,d		; reached end?
	 aoja a,mapda1		; nope, incr file address, loop
mapda2:	jrst (fx)


; here on failure
mapdaf:	log <Can't create .PMAP file: %1J>
	skipe a,p1		; relase JFN if we've got one
	 rljfn	
	  jfcl			; ignore it if we can't
	jrst (fx)

	subttl	interrupt driven routines and background process

; These routines maintain the state of the server.  RNTSRV is run at
; interrupt level to receive Pups.  On receipt of a PUP, RNTSRV finds
; the connection it belongs to (or creates a new one), then calls the
; sequence number filter to determine where in the packet sequence the
; received Sequin belongs.  Sequins which are indeed in sequence are
; queued in SQRXCU for the server fork (whatever it may be) below to
; handle.  

; BNTSRV is run on  a five second timer, and is responsible for garbage
; collecting dead or destroyed sequins, and also maintaining the state
; of each sequin connection.

; call: pushj p,bntsrv
;	transparent to acs

bntsrv::skipg nactcn			; are there any active connections?
	 popj p,			; no, return
	exch p,bntpdl
	movem 16,bntacs+16		; save acs 0-16
	movei 16,bntacs
	blt 16,bntacs+15
	move 16,bntacs+16		; recover fx (=AC16)

	cail fx,0			; are we the top fork here?
	 jrst [pushj p,bntsv1		; no, service this connection only
	       tlze f,(defntf)		; need to reenter?
		jrst .-2		; yes, do so
	       jrst bntsv5]		; done, leave

bntsv4:	movsi cx,-nconn			; look for active connections
bntsv0:	skipe sq,contab(cx)		; is this connection alive?
	 pushj p,bntsv1			; yes, handle it
	aobjn cx,bntsv0			; loop if more connections to scan

	tlze f,(defntf)			; want to recycle through this?
	 jrst bntsv4			; yes, go again

bntsv5:	movsi 16,bntacs			; done, recovers acs
	blt 16,16			
	exch p,bntpdl
	tlze f,(defntf)			; want BNTSRV again?
	 jrst bntsrv			; loop through again
	popj p,

gs bntlck				; Background service lock
gs bntlkr				; Last locker
	 
; this routine does all the work
bntsv1:
	move a,seqSta(sq)		; get current state
	caie a,BROK			; if broken...
	 cain a,DSTR			; ... or destroyed
	  jrst bntsv2			; clean up
	cain a,TIMD			; timed out?
	 jrst [skipn b,rxtime(cx)	; see if connection timed out
		jrst .+1
	       hrrz a,ltime(cx)		; compute time of connection timeout
	       imuli a,^d1000
	       sub b,a
	       hlrz a,ltime(cx)
	       imuli a,^d1000
	       add b,a
	       push p,b			; get now
	       time
	       pop p,b	
	       caml a,b
		jrst [movei c,(cx)
		      elog <BNTSV1: Connection %3O timed out>
		      jrst bntsv2]	; connection timed out
	       jrst .+1]

; check for time to send
	skipn txtime(cx)		; is there a send timeout?
	 pushj p,sttxtm			; no, set one
	time
	caml a,txtime(cx)		; tx timeout yet?
	 pushj p,sndnop			; yes, send a nop (if not server)

; check if receiver timed out
	skipn rxtime(cx)		; is there a received timeout?
	 pushj p,strxtm			; no, set one
	caml a,rxtime(cx)
	 jrst [movei a,TIMD
	       movem a,seqSta(sq)	; yes, say connection is timed out
	       jrst .+1]
	popj p,				; return

; here to close a BROKen, DeSTRoyed, or TIMeD out connection
; sq, cx set up
bntsv2:	cail fx,0			; Let only the top fork do this
	 popj p,			; If not, then return
	movei a,(cx)
	log <BNTSV2: Closing connection %1O>
	setzm pupfsk(cx)		; clear address for server, also
	setzm pupfnh(cx)
	setzm rxtime(cx)
	setzm txtime(cx)
	skipge server
	 jrst [pushj p,cleanf##		; clean JFNs
	       pushj p,killfk		; kill server fork
	       jrst bnts2a]		; don't close socket if server
	hlrz a,sqjfnx(sq)		; close jfn
	closf
	 elog <BNTSV2: While closing port: %1J>
bnts2a:	movei a,freque			; return queues to free pool
	hrrz b,sqtxcu(sq)
	pushj p,rqueue
	hrrz b,sqrxcu(sq)
	pushj p,rqueue
	setzm contab(cx)		; clear connect index
	sosge nactcn			; decrement count of actives conns
	 jrst  [elog <BNTS2A: NACTCN overdecremented>
		setzm nactcn
		popj p,]
	popj p,

; Routine to send a PUP, updating allocations as it goes, if necessary.
; This routine will dismiss if the allocation does not exist at the
; receiver, hence, do not lock any critical data structures or call with
; interrupts off.
; call: b/ Address of packet buffer to send
; returns: +1 always
;	    Clobbers c,d
sndpup: push p,a
	push p,b
	push p,pb			; save pb
	movei pb,(b)			; point to packet
	ldb a,puplen			; compute PDP10 word count
	addi a,3
	idivi a,4
	hrl b,a
	hrri b,pbhead(pb)		; point to start of packet data
	hlr a,sqjfnx(sq)
	skipge server			; if server
	 hrr a,srvjfn			; use the server jfn
	hrli a,(1b0+1b1)		; don't block, generate checksum
sndpp1:	hrrz c,seqall(sq)		; get allocation for receiver
	cain c,0			; is it 0?	
	 movei c,1			; then make it 1
	move d,seqout(sq)		; get outstanding packet count
	sub c,d				; get difference
	jumple c,[tlne f,(sqrtrn)	; retransmitting?
		   jrst .+1		; ignore allocation limits
		  push p,a		; no allocation, must wait
		  ldb a,puplen		; get length of pup
		  caig a,mnplen		; don't disms if no contents bytes
		    jrst [pop p,a
			  jrst .+1]
		  move a,sqtxcu(sq)
		  movei a,qulock(a)
		  push p,a		; unlock the queue while waiting
		  pushj p,unlock
		  movei a,^d100
		  disms
		  pop p,a
		  pushj p,lock		; relock the queue
		  pop p,a
		  jrst sndpp1]		; try again now
	pupo
	 ercal jerr
	ldb a,puplen			; get length of PUP just sent
	caig a,MNPLEN			; any contents bytes?
	 jrst sndpp2			; no, don't mess with seqout	
	tlnn f,(sqrtrn)			; retransmitting?
	 aos seqout(sq)			; no, incr outstanding packet count
sndpp2:	pushj p,sttxtm			; reset the timeout timer for 5 minutes
	pop p,pb			; restore pb
	pop p,b
	pop p,a
	popj p,

; routine to place a sequinNop on the queue
sndNop:	skipge server			; only if not server
	 popj p,
	push p,a
	push p,b
	setz a,				; send no data
	movei b,seqNop			; send a Nop
	pushj p,senSeq			; queue it
	pop p,b				; restore acs
	pop p,a
	popj p,

; routine called when a pup is received
rntsrv: exch p,rntpdl
	movem 16,rntacs+16		; save acs 0-16
	movei 16,rntacs
	blt 16,rntacs+15
	skipge server
	 jrst [seto fx,			; we're the top fork
	       pushj p,rntsv1		; if server, get packet
	       jrst rntsv5]

	movsi cx,-nconn			; loop through connections
rntsv0:	skipe sq,contab(cx)		; looking for those with pups waiting
	 pushj p,rntsv1			; do the work
	aobjn cx,rntsv0

rntsv5:	movsi 16,rntacs			; done, recovers acs
	blt 16,16			
	exch p,rntpdl
	debrk				; leave interrupt routine
	 ercal jerr			; in case something fails

rntsv1:	hrrz a,srvjfn			; assume we're a server
	skipl server			; are we a server?
	 hlr a,sqjfnx(sq)		; no, get jfn from seqblk
	hrli a,(1b0+1b1)		; don't disms for I/O, gen checksum
	move b,[mxpbln,,tmprec]
	pupi				; attempt to input a pup
	 jrst rntsv3			; empty or error
	skipge server			; are we a server?
	 jrst [pushj p,rntsv4		; yes, get connection for this packet
	        jrst rntsv1		; failed, see if there's another
	       jrst .+1]		; found the connection
	movei c,tmprec
	pushj p,HdlSeq			; Handle this packet
	cain a,errDes			; was the Sequin destroyed?
	 jrst rntsv2			; yes, go wait for send queue to empty
	jrst rntsv1			; no, loop until input port is empty


; here when Sequin is classified as destroyed
; Make state=DSTR, let BNTSV2 clean up this connection
rntsv2:	movei a,DSTR
	movem a,seqsta(sq)		; make state=DeSTRoyed
	popj p,

rntsv3:	cain a,pupx3			; empty?
	 popj p,
	type <RNTSRV: PUPI failure %1J%/>
	popj p,

; routine to find connection index (or make new one) for received packet
; call: pushj p,rntsv4
;	TMPREC: containing received packet
; returns: +1, failed packet (can't open connection or not Sequin, etc)
; 	   +2, packet received ok, with cx, sq set up
rntsv4: push p,pb
	movei pb,tmprec-pbhead
	ldb a,puptyp		; is this a sequin packet?
	caie a,seqtyp
	 jrst [log <RNTSV4: Discarding non-sequin packet>
	       pop p,pb
	       popj p,]
	ldb a,ppupss			; get source socket
	movsi cx,-nconn
rnts4a:	camn a,pupfsk(cx)		; did we find it?
	 jrst rnts4d			; maybe, try net,,host
	aobjn cx,rnts4a			; loop until we find it

; here if not found; look for an empty slot to make a new connection in
rnts4g:	ldb a,seqcon			; get control byte
	caie a,seqOpn			; is it an open request?
	 jrst rnts4x			; no, send a broken in return
	movsi cx,-nconn			; yes, look for a free slot
rnts4b:	skipn contab(cx)
	 jrst rnts4c
	aobjn cx,rnts4b

; here if no room; return +1
rnts4x:	pop p,pb
	jrst breksq			; send a sequin broken, return +1

; here when a free slot found, make new connection
rnts4c:	movei cx,(cx)
	movei sq,(cx)
	imuli sq,sqblen
	movei sq,sqbtab(sq)
	movem sq,contab(cx)
	ldb a,ppupss
	movem a,pupfsk(cx)
	ldb a,ppupsh
	ldb b,ppupsn
	hrl a,b
	movem a,pupfnh(cx)
	move a,srvjfn
	hrlm a,sqjfnx(sq)
	pushj p,conini
	 jrst [pop p,pb
	       popj p,]
	pop p,pb
	aos 0(p)
	dtype <LEAFSV: Sequin connection %6O opened%/>
	aos nactcn			; increment number of active conns
	popj p,

; here when socket matches; look for net,,host
rnts4d:	move c,a		; save pupfsk
	ldb a,ppupsh
	ldb b,ppupsn
	hrl a,b
rnts4e:	camn a,pupfnh(cx)
	 jrst [camn c,pupfsk(cx)
		jrst rnts4f	; got it
	       jrst .+1]
	aobjn cx,rnts4e
	jrst rnts4g	

; here when found a match
rnts4f:	move sq,contab(cx)
	pop p,pb
	aos (p)
	popj p,

ls rntstk,psisiz
ls bntstk,psisiz			; interrupt stacks
ls rntpdl
ls bntpdl				; interrupt stack pointers

; routine to send a SequinBroken back to sender when a Sequin cannot be
; created
; call: pushj p,breksq
;	pb/ pointer to received packet
; returns: +1, always
breksq: movei pb,tmprec-pbhead
	ldb a,ppupsn			; get source port
	ldb b,ppupsh
	ldb c,ppupss
	movei pb,brkpup-pbhead		; point to space to send break pup
	dpb a,ppupdn			; deposit dest port
	dpb b,ppupdh
	dpb c,ppupd1			; low order bits
	rot c,-^d16			; rotate around high order bits
	dpb c,ppupd0			; and deposit into Pup

	movei pb,tmprec-pbhead		; deposit source host bytes
	ldb a,ppupdn
	ldb b,ppupdh
	movei pb,brkpup-pbhead
	dpb a,ppupsn
	dpb b,ppupsh
	move a,srvjfn			; determine local net, host, socket
	cvskt			
	 ercal jerr
	dpb c,ppupss			; save socket

	movei pb,tmprec-pbhead		; set up sequin fields
	ldb a,seqrec			; receive sequence
	ldb b,seqSen			; get send sequence
	ldb c,puplen			; any data in packet?
	caile c,mnplen	
	 aoj b,				; yes, increment for return recv seq
	movei pb,brkpup-pbhead
	dpb a,seqSen
	dpb b,seqRec
	setz a,				; no Alloc
	dpb a,seqAll
	movei a,seqBro			; say sequin broken
	dpb a,seqCon

	movei a,mnplen
	dpb a,puplen
	movei a,seqtyp
	dpb a,puptyp
	hrr a,srvjfn		; use the server jfn
	hrli a,(1b0+1b1)	; don't block, generate checksum
	movei b,brkpup
	hrli b,mnpbln
	pupo
	 elog <BREKSQ: PUPO error: %1J>
	log <BREKSQ: No room or Data Sequin rcvd for nonexistent connection>
	popj p,

ls brkpup,MNPBLN+2		; a little longer for superstitious reasons

	subttl	PSI utilities

; routine to init psi's
; call: (p)/ jfn on port
psiini::setom intdef
	move a,[iowd psisiz,bntstk] ; do this here because BNTSRV used to...
	movem a,bntpdl		    ; ... run at interrupt level
	move a,[iowd psisiz,rntstk]
	movem a,rntpdl
	move b,[levtab,,chntab]
	movei a,400000		; init PSI's for this fork
	sir
	eir
	move b,[actchn]		; activate used channels
	aic
	move a,[^d26,,^d23]	; assign ^Z interrupt to channel 23
	ati
	move a,-1(p)		; set received pup interrupt
	movei b,24
	move c,[36b5+1b11+36b17]; chan 1 is recvd interrupt
	mtopr
	popj p,

; PSI channel definitions
define psi(ch,lev,disp),<
actchn==actchn!1b<ch>
	reloc chntab+^d<ch>
	lev,,disp
>

actchn==0
chntab::psi(1,3,rntsrv)		; receiver service
	psi(9,1,pdlovf)		; Pushdown overflow
	psi(11,1,daterr)	; Data error
	psi(15,1,illins)	; Illegal instruction
	psi(16,1,illred)	; Illegal read
	psi(17,1,illwrt)	; Illegal write
	psi(18,1,illxct)	; Illegal execute
	psi(20,1,illsiz)	; Machine size exceeded
	psi(23,1,kilsrv)	; ^Z interrupt to kill server

	reloc chntab+^d36

levtab::lev1pc
	lev2pc
	lev3pc

; Fatal errors

pdlovf::jsr crashx
	asciz /Pushdown overflow/

daterr::jsr crashx
	asciz /IO data error/

illred::jsr crashx
	asciz /Illegal read/

illwrt::jsr crashx
	asciz /Illegal write/

illxct::jsr crashx
	asciz /Illegal execute/

illsiz::jsr crashx
	asciz /Machine size exceeded/

; Common code for fatal error interrupts
crashx:	0
	push p,lev1pc		; Put trap pc on stack
	push p,b
	hrro b,crashx		; Make call pc into string ptr
	jrst screw1

jerr::	push p,b
	hrroi b,temp##
	write b,<%1J%/>
	hrroi b,temp##
	jrst screw1

screwup::
	push p,b
	hrroi b,[asciz/A fatal error has occurred/]
screw1:	push p,a		; don't clobber any acs
	hrrz a,-2(p)		; get caller
	soj a,			; decrement for true address
	log <%2S at %1O%/%/>
	time			; get now
	subm a,crstim		; compute how long ago we last crashed
	exch a,crstim
	caige a,^d<60*1000>	; longer than a minute?
	 jrst  [elog <Too-frequent crashes, aborting...>
		pushj p,dmplog##
		haltf
		jrst srvstt##]
	elog <Leaf server crashed, restarting...>
	pushj p,dmplog##
	jrst srvstt##

ls crstim

; here to handle illegal instruction
illins::push p,a		; Not sumex, try to do ERCAL
	push p,b
	hrrz a,lev1pc
	hllz b,(a)		; Get instruction after error
	camn b,[ERCAL]		; Is it an ERCAL?
	 jrst [hrrz a,lev1pc	; Yes, simulate ERCAL to error routine
	       hrrz b,(a)	; Get address of error routine
	       movem b,psiret	; store it
	       aoj a,		; Adjust return address from interrupt
	       pop p,b
	       exch a,(p)	; Store new return address
	       jrst @psiret]	; Jump into error routine
	hllz b,-1(a)		; Not ERCAL, did a JSYS get us?
	camn b,[JSYS 0]		; Was it a JSYS?
	 jrst  [movei a,400000
		geter
		movei a,(b)	; isolate error number
		hrroi b,temp
		write b,<Fatal JSYS error %1J>
		pop p,b		; mung stack
		pop p,a
		push p,lev1pc
		push p,b
		hrroi b,temp
		jrst screw1]
	pop p,b
	pop p,a			; Not JSYS, handle as with other errors
	jsr crashx		
	asciz /Illegal instruction/

ls psiret,1			; Location to hold address of error routine

; ^Z interrupt to kill server
kilsrv:	movsi cx,-nconn		; break all connections
	setz a,
	movei b,seqBro		; send sequin brokens
kilsr1:	skipe sq,contab(cx)
	 pushj p,senseq
	aobjn cx,kilsr1
	pushj p,dmplog
	move a,srvjfn		; close the socket
	closf
	 elog <KILSRV: Unable to close server socket: %1J>
	gtad
	type <%/%/Tenex Leaf Server halted at %1T>
	haltf
	jrst srvstt##
	subttl	Storage
ls bntacs,20		; storage for background process acs
ls rntacs,20		; storage for recv interrupt acs

; tables indexed by CX
gs contab,nconn		; connection table
gs rxtime,nconn		; receiver timeout
gs txtime,nconn		; transmitter timeout
gs pupfsk,nconn		; table of foreign sockets, indexed by cx
gs pupfnh,nconn		; table of foreign net,,host, index by cx
gs ltime,nconn		; local timeout (connection,,filelock)
gs ftime,nconn		; foreign timeout (connection,,filelock)
gs connfk,nconn		; fork for leaf server, indexed by cx

gs nactcn,1		; holds number of active connections
ls contro,1		; control word from received packet
ls frepnt,1		; free space pointer for ASGFRE
ls sndtmp,MXPBLN	; temporary send buffer
ls tmprec,MXPBLN	; temporary receive buffer

ls lev1pc,1
ls lev2pc,1
ls lev3pc,1

gs txtab,lqutab*nconn
gs rxtab,lqutab*nconn

gs sqbtab,sqblen*nconn

	end

