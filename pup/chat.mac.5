;<PUP>CHAT.MAC;5  1-Dec-80  01:02:31  Edit by SCHOEN
; Make NO CLEAR.OUTPUT.CHARACTER possible
; Fix initial commands feature: don't overwrite initial open
;   angle bracket, and don't send 37 for CR in remote, xparnt mode
;<PUP>CHAT.MAC;4  8-Sept-80 10:40:05  Edit by SCHOEN
; Tops20: Simulate Tenex hold character
;<PUP>CHAT.MAC;3  11-Jul-80 10:12:10, Edit by SCHOEN
; tenex/tops20: No longer set local terminal type to 0 when in remote 
; mode (why do it?).  Kept lowercase from being sent when not in 
; transparent mode
;<PUP>CHAT.MAC;2 11-Jun-80 Edit by Schoen
;<PUP>CHAT.MAC;1	9-Jun-80 Edit by SCHOEN
; Made runnable on Tops20 (though not complete -- command parser)
; Changed editing defaults to Sumex or Tops20
;<PUP>CHAT.MAC;11     3-JUL-79 10:31:10    EDIT BY TAFT
; Reset P when restarted at RECV0
;<PUP>CHAT.MAC;10    24-APR-78 12:14:50    EDIT BY TAFT
; Add names of all IFSs to host name table.
; Fix crash caused by log.file.for.current.connection when there
; is no connection.
;<PUP>CHAT.MAC;9    17-JUL-77 12:56:59    EDIT BY TAFT
; Add IFS command
;<PUP>CHAT.MAC;8    13-APR-77 12:54:36    EDIT BY TAFT
; Add initial Chat.Commands feature
; Correct implementation of timing mark
;<PUP>CHAT.MAC;7    21-MAR-77 16:50:45    EDIT BY TAFT
; Add simple host name collector
;<TAFT>CHAT.MAC;4    21-MAR-77 02:05:53    EDIT BY TAFT
; Find help file on <Doc>Chat.help
;<TAFT>CHAT.MAC;3    21-MAR-77 01:03:37    EDIT BY TAFT
; Conversion from TELNET to CHAT:
; Rip out all the BCPL call stuff
; Rip out all option negotiation and RCTE code
; Remove Arpanet-related stuff (netstat, socket.map, status.of ...)
; Rewrite DOICP to make Pup connections
; Remove state change stuff
; Insert commands "Maxc1" and "Maxc2" until we can figure out
; a good way of collecting host names.
;<DODDS>TELNET.MAC;135     4-FEB-75 14:55:16    EDIT BY DODDS

	TITLE CHAT -- TENEX PUP USER TELNET
	SUBTTL	E. A. Taft, based on TELNET by R.S.Tomlinson

	SEARCH SYSDEF

DEFINE  TENEX,<IFN FT10X>
DEFINE  TOPS20,<IFN FT20>
tenex,< SEARCH STENEX >
tops20,<SEARCH MONSYM>


; to be compiled with CHAT.10X on TENEX, CHAT.P20 on Tops20
ifndef sumex,<sumex==0>
ifndef sum20,<sum20==0>
ifndef maxc,<maxc==0>
ifn sumex+sum20+maxc-1,<
 tenex,<
	printx	Must compile with CHAT.10X!
 >
 tops20,<
	printx	Must compile with CHAT.P20!
 >
	end
> ;end ife sumex!sum20!maxc


ENTVEC:	JRST START		; entry vector: start adr
	JRST START		; restart adr, changed later

VERNUM:	ASCIZ \1.03 24-Apr-78\
	BLOCK 3

OPDEF	ERROR[1B8]


; Accumulators

A=1
B=2
C=3
D=4
X=5
Y=6
Z=7
PTR=10
TAB=11
NOA=12
CNX=13
NCNX=14
P=17
F=0

; Flags (rh of f)

REMOTF==1		; Operating in remote mode
COMMDF==4		; In command mode
NSTIWF==2		; Don't do stiw's
ICPMOD==10		; ICP in progress
TMPF==400000		; Temporary flags
TMPF2==200000
TMPF3==100000
TMPF4==40000
TMPF5==20000
TMPF6==10000

; Parameters

NPDL==2000		; Size of push list
NCONN==7		; Number of connections to remember
ifn sumxsw&sumex,<
IESC=="Z"-100		; Initial escape character
ICBF=="O"-100		; Initial clear output buffer character
>
ifn sumxsw!sumex,<
IESC=="Y"-100		; Like Sumex Telnet
ICBF=="N"-100
>
tops20,<
IHLD==37		; Initial Tenex hold character
>

ESCCHN==0		; Use channel 0 for escape
ABNCHN==2		; Channel 2 for abnormal connection termination
CBFCHN==4

tops20,<
HLDCHN==1		; Use channel 1 for simulate hold
>

SAVBFS==4000		; Size of string saving buffer

LOC 200000		; fork data area

SPDL:	BLOCK 100
APDL:	BLOCK 50
FKRET1:	BLOCK 1
FKRET2:	BLOCK 1
FKRET3:	BLOCK 1
FSVCNX:	BLOCK 1			; fork's cnx for use by INSRCV
IRSST:	BLOCK 1			; ditto temp for Send status
IACSAV:	BLOCK 20		; ditto AC save area
SAVBUF:	BLOCK SAVBFS

LOC 300000		; Interfork data area
ARRAY 	HOLDF [NCONN+1]

LOC 100000		; Where to store variables

INTEGER	CONTAB
ARRAY	PDL[NPDL]
ARRAY	COMBUF,LINBUF,HLPBUF[200]
ARRAY	BIGBUF[4000]
INTEGER	LODFLG,WATFLG,TCASE,TRMLWC,BPTR,LPTR,SVP
INTEGER	TTCOC0,TTCOC1,TTMOD0,TTMODR,TTMODC,JOBTIW,HDX,NFANCY
INTEGER	ESCAPE,ESCCOD,CBFCHR,CBFCOD,LSTBDI,CONCSF,ABNLCK,ABNCNX
INTEGER	LCASCF,UCASCF,LCASC,LCASL,UCASC,UCASL,UNSFT
INTEGER	SYNC,QUOT,QUOTF,SPECWK
tops20,<
INTEGER HLDCOD,HLDCHR
>
ARRAY	FAC,LGDRST[20]
INTEGER	IJFN,SCRJFN,SCRCNT,SCRTIM,REALTT,CMCALX,CRNLSW,CMDJFN
INTEGER	DIVJFN,DIVSWT,RLACJ,SPCFRK,ACTVSW,ACTVTM
INTEGER	SKTMSK,FSKT,FHST,FHSTN,RETPC1,RETPC2,RETPC3
ARRAY	SNDFRK,RCVFRK,DMTIME,LSKT,ELCLF,LFCRF,LNBFF[NCONN+1]
ARRAY	XPARNT,RCVBSW,CBFCNT,ALTJFN,ALTJCT,SNDATM,RCVATM[NCONN+1]
ARRAY	RAISEF,LOWERF,ECHCOC,CONTB,SAVINP,SAVINC,SAVONP,SAVSWT[NCONN+1]
ARRAY	RHLDCT,RSHLCT,RBUFCT,RBFECT,RBFSCT[NCONN+1]
ARRAY	RHLDBF,RHLDPT,RECHPT,RSNDPT,LGFJFN,LGFCNT,LGFTIM[NCONN+1]
ARRAY	SNDJFN,RECJFN[NCONN+1]	; Send & Receive jfns
ARRAY	SYNCNT[NCONN+1]	; Sync count (interrupts - data marks)
ARRAY	CONNAM[3+3*NCONN]
INTEGER	SWOFLG,CLROBF,TERM,JUNK

RELOC


; Program starts here

START:	MOVEI A,100
	SIBE
	JRST RSTART
	HRROI A,[ASCIZ /
Chat -- Pup User Telnet /]
	PSOUT
	HRROI A,VERNUM
	PSOUT
ifn sumex!sumxsw,<			; tell them how to leave
	HRROI A,[ASCIZ/
Escape character is /]
	PSOUT
	MOVEI A,IESC
	PBOUT
	HRROI A,[ASCIZ/; clear output buffer character is /]
	PSOUT
	MOVEI A,ICBF
	PBOUT
	MOVEI A,"."
	PBOUT
> ; end ifn sumex!sumxsw
RSTART:	RESET			; Reset the world
	MOVE P,[XWD -NPDL,PDL-1]
	MOVE A,[PUSHJ P,UUO]
	MOVEM A,41
	MOVEI A,400000
	RPCAP			; Find out what we can do
	AND B,[1B0!1B2]
	IOR C,B
	EPCAP			; Enable control-c stealing
	TLNE C,(1B0)
	TROA F,NSTIWF
	TRZ F,NSTIWF
	SETZB F,VARS
	MOVE A,[XWD VARS,VARS+1]
	BLT A,EVARS-1		; Zero all variables, set BCPL params
	SETOM ABNLCK		; Unlock abnormal interrupt handler.
	SETOM UCASC
	SETOM UCASL
	SETOM LCASC
	SETOM LCASL
	SETOM UNSFT
	SETOM QUOT
	SETOM SYNC
	MOVSI B,-NCONN

ICNVL:	MOVE A,[BYTE (1)0,0,0,0,0,0,0,1,0,1,1,0,0,1]
	MOVEM A,ECHCOC(B)	; Initial control character local echo
	SETOM LFCRF(B)
	SETOM ELCLF(B)
	AOBJN B,ICNVL
	MOVEI A,CONTB
	MOVEM A,CONTAB		; Contab points at contb
	MOVEI A,IESC		; Setup initial escape character
	MOVEM A,ESCAPE
	PUSHJ P,CVINTC		; Convert character to interrup channel
	 HALT .			; Can't fail
	MOVEM A,ESCCOD
	MOVEI A,ICBF
	MOVEM A,CBFCHR
	PUSHJ P,CVINTC
	 HALT .
	MOVEM A,CBFCOD
tops20,<
	MOVEI A,IHLD
	MOVEM A,HLDCHR
	PUSHJ P,CVINTC
	 HALT .
	MOVEM A,HLDCOD
>
	SETZM FSVCNX
	MOVEI A,400000
	CIS
	MOVE B,[XWD LEVTAB,CHNTAB]
	SIR
	EIR
	MOVEI A,100
	RFMOD			; Find out what kind of line we have
	MOVEM B,TTMOD0		; Remember same
	TRNE B,1B32		; Hdx terminal?
	 SETOM HDX		; Yes, set hdx flag
	TLNE B,(1B3)
	 SETOM TRMLWC		; Remember term has lower case
	ANDCMI B,77B23!3B25!17B29!1B30!1B31
	PUSH P,B
	IORI B,17B23!0B25!1B29
	MOVEM B,TTMODC		; In command mode: break-all, echo-none
	POP P,B
	IORI B,17B23!1B29
tops20,<ANDCMI B,1B34>		; tops20 - turn off page bit
	MOVEM B,TTMODR		; No change for remote mode
	RFCOC			; Get standard control output control
	MOVEM B,TTCOC0
	MOVEM C,TTCOC1
	GJINF
	PUSH P,A		; Save login dir number
	HRROI A,HLPBUF		; Build name <login-dir>Chat.Commands
	MOVEI B,"<"
	BOUT
	POP P,B
	DIRST
	 0
	HRROI B,[ASCIZ/>CHAT.COMMANDS/]
	SETZ C,
	SOUT
	MOVSI A,(1B2+1B17)	; Old file, short form
	HRROI B,HLPBUF
	GTJFN
	 JRST INIT1		; Not there
	MOVEM A,CMDJFN		; Ok, save jfn
	MOVE B,[7B5+1B19]	; Open for reading
	OPENF
	 PUSHJ P,[SETZ A,	; Can't, just release jfn and ignore
		EXCH A,CMDJFN
		JRST CLRJFN]
INIT1:	MOVE A,[JRST PCLP]	; set up restart adr
	MOVEM A,ENTVEC+1
PCLP:	MOVEI A,ESCCHN		; Psi channel
	HRL A,ESCCOD		; Escape terminal code
	ATI
	MOVEI A,CBFCHN
	HRL A,CBFCOD
	ATI			; Assign
tops20,<
	MOVEI A,HLDCHN
	HRL A,HLDCOD
	ATI
>
tops20,<
	MOVE B,[1B<ESCCHN>!1B<HLDCHN>!1B<ABNCHN>!1B<CBFCHN>!1B9!1B11!17B18]
> 
tenex,<
	MOVE B,[1B<ESCCHN>!1B<ABNCHN>!1B<CBFCHN>!1B9!1B11!17B18]
>
	MOVEI A,400000
	AIC			; Activate interrupt channel

; Main command loop

COMLP:	TRO F,COMMDF
	TRZ F,TMPF3!ICPMOD
	MOVEI A,101
	DOBE
	MOVE P,[XWD -NPDL,PDL-1]
	MOVE NCNX,CNX
	SETO B,
	MOVEI A,-5
	TRNN F,NSTIWF
	STIW			; Restore terminal interrupt word
	MOVEI A,100
	MOVE B,TTMODC
	SKIPE NFANCY
	 JRST [	TRZ B,77B23
		TRO B,2B25!16B23
		JRST .+1]
	SFMOD			; Set tty mode for command input
tops20,<
	TRNE B,1B34		; Command mode have page bit on?
	 STPAR			; set for page mode
>
	MOVE B,[BYTE (2)0,0,1,1,1,1,1,2,0,2,2,1,2,2,1,1,1,1]
	MOVE C,[BYTE (2)0,1,1,1,1,1,0,1,1,0,1,1,1,2]
	SFCOC
	HRROI A,[ASCIZ /
#/]
	PUSHJ P,.PSOUT		; Prompt character
	MOVE PTR,[POINT 7,COMBUF-1,34]
	MOVEM PTR,LPTR		; Pointer to beginning of line
	MOVEI A," "
	IDPB A,PTR		; Deposit initial space to line up
	MOVE TAB,COMTAB		; Setup to use comtab
	PUSHJ P,SYMVAL		; Call symbol evaluator
	SKIPE SNDJFN(CNX)	; Was connection created or
	TRNN F,REMOTF		; Remote mode?
	 JRST COMLP		; No. stay in command mode
	TRZ F,COMMDF
	MOVEM CNX,FSVCNX	; save CNX for later restoration
	HRROI A,[ASCIZ /#
/]
	PUSHJ P,.PSOUT
	MOVEI A,-5
	MOVN C,ESCCOD
	MOVSI B,400000
	ROT B,(C)		; Get bit for escape code
	PUSH P,B
	MOVN C,CBFCOD
	MOVSI B,400000
	ROT B,0(C)
	IORM B,0(P)
	POP P,B
	IORI B,1B30		; Include carrier off
	TRNN F,NSTIWF
	STIW			; And set tiw to that

REST0:	MOVEI A,100
	MOVE B,TTMODR
	SKIPE XPARNT(CNX)
	 TRZ B,3B29
	SFMOD			; Set tty mode for remote
tops20,<
	MOVE C,TTMODC
	TRNE C,1B34		; Page mode on?
	 STPAR			; Turn it off
>
	MOVE B,[BYTE (2)0,0,0,0,0,0,0,2,2,2,2,2,2,2,0,0,0,0]
	MOVE C,[BYTE (2)0,0,0,0,0,0,0,0,0,0,0,0,0,2]
	SFCOC			; echo all formatter + bell in remote
	MOVEI A,101
	GTTYP
	SETZ C,
	CAIL B,MINSCP		; is terminal a scope?
ifn sumex&sumxsw,<
	 JRST [ EXCH C,B
		STTYP		; yes, save & set to 33 for remote
		JRST .+1 ]
>
ifn sumex!sumxsw,<
	 EXCH C,B
>
	MOVEM C,REALTT		; save terminal type or 0 if not scope
	MOVE A,RCVFRK(CNX)
	FFORK			; Freeze it
	MOVEI A,400000
	DIR			; Interrupts off to avoid confusion
	SETZM SAVSWT(CNX)	; Resume output
	MOVE A,RCVFRK(CNX)
	RFSTS			; Get pc of receive fork
	MOVE A,RCVFRK(CNX)
	HRRZS B
	CAIG B,RECV0		; If fork will get back to RECVO
	 JRST REST2		;  let it proceed
	CAIG B,RECVB
	 JRST REST1
	CAIL B,RCVBX
	CAILE B,RCVB1+1
	SKIPE RCVBSW(CNX)
	 JRST REST1
	JRST REST2
REST1:	MOVEI B,RECV0		; Else restart it at RECV0
	SFORK
REST2:	MOVE A,SNDFRK(CNX)	; if io wait and input file assigned,
	RFSTS
	MOVE A,SNDFRK(CNX)
	HRRZS B
	CAIN B,PBINX+1
	SKIPN ALTJFN(CNX)
	JRST REST3
	MOVEI B,.PBIN	; restart .PBIN to prevent input hang
	SFORK


REST3:	MOVEI A,400000
	EIR
	MOVE A,RCVFRK(CNX)
	RFORK			; And resume
	MOVE A,SNDFRK(CNX)
	RFORK			; Resume send fork
	SKIPE ACTVSW		; if not auto-switching, wait
	 JRST REST3A
	WFORK			; Should wait forever
	HRROI A,[ASCIZ /
Funny fork termination. Restarted./]
	PUSHJ P,.PSOUT
	JRST RSTART
REST3A:	TIME
	MOVEM A,RCVATM(CNX)	; advance new fork's active time to now
REST4:	MOVEI A,^D15000
	DISMS			; here for auto-switching. wait 1 min..
	TIME
	SUB A,ACTVTM
	MOVE B,A
	CAML A,RCVATM(CNX)	; send and recv forks inactive for
	CAMGE B,SNDATM(CNX)	; more than time constant?
	 JRST REST4		; no, go back to sleep
	MOVSI X,-NCONN
REST5:	MOVE A,SNDJFN(X)	; yes, scan for an active connection
	JUMPE A,REST6
	SKIPLE SAVINC(X)
	 JRST REST7
REST6:	AOBJN X,REST5
	JRST REST4		; if none found keep current one & loop
REST7:	SETOM SAVSWT(CNX)
	MOVEI A,400000
	DIR
	MOVEI A,100		; active cnx found: turn off current cnx
	CFIBF
	MOVE A,SNDFRK(CNX)
	FFORK
	PUSHJ P,TBEL
	HRROI A,[ASCIZ /
Switching to connection /]
	PUSHJ P,.PSOUT
	HRRZ A,X
	IMULI A,3
	HRROI A,CONNAM(A)
	PUSHJ P,.PSOUT
	HRROI A,[ASCIZ /.
/]
	PUSHJ P,.PSOUT
	HRRZ CNX,X
	TRO F,REMOTF
	MOVEM CNX,FSVCNX	; and turn on active one
	JRST REST0


; Abnormal interrupts come here

BADINT:	MOVE CNX,FSVCNX
	MOVEI A,101
	DOBE
	TIME
	SUBI A,^D15000
	CAMGE A,LSTBDI		; Within 5 seconds of last bad int?
	 JRST BADBAD		; Very bad
	HRROI A,[ASCIZ /
Abnormal interrupt from location /]
	PUSHJ P,.PSOUT
	HRRZ B,RETPC1
	MOVEI C,10
	MOVEI A,101
	PUSHJ P,.NOUT
	 JFCL
	HRROI A,[ASCIZ /.
/]
	PUSHJ P,.PSOUT
	TIME
	MOVEM A,LSTBDI
	JRST ESCINZ

BADBAD:	HALTF
	JRST BADINT

; If remote host initiates disconnect, rec'v fork inits int'rpt to here

ABNINT:	MOVE CNX,FSVCNX
	MOVE X,ABNCNX		; Get the correct cnx
	PUSHJ P,DISC1
	JRST ESCINZ

; Clear outbuf int comes here

CBFINT:	MOVE CNX,FSVCNX
	SKIPE A,SNDJFN(CNX)
	AOSE QUOTF
	 JRST CBFINZ
	PUSH P,B
	MOVEI B,SENDO
	JRST SPCSND

tops20,<
; Simulate tenex hold interrupt comes here
HLDINT:	PUSH P,B
	PUSH P,CNX
	MOVE CNX,FSVCNX
	SKIPE HOLDF(CNX)
	 JRST HLDTOG
	SETOM HOLDF(CNX)
	SETOM SAVSWT(CNX)
	MOVEI B,37
	PUSHJ P,SNDCH
	POP P,CNX
	POP P,B
	DEBRK

HLDTOG:	SETZM HOLDF(CNX)
	SETZM SAVSWT
	MOVEI B,37
	PUSHJ P,SNDCH
	POP P,CNX
	POP P,B
	DEBRK
>

CBFINZ:	SETOM CLROBF
	PUSH P,A
	MOVEI A,101
	CFOBF
	POP P,A
	DEBRK
	DEBRK

; Escape interrupt comes to here

ESCINT:	AOSE QUOTF		; if quote prefix typed and
	 JRST ESCINV
	MOVE CNX,FSVCNX
	SKIPN A,SNDJFN(CNX)	; If connection exists,
	 JRST ESCINV
	PUSH P,B
	MOVEI B,SENDE
SPCSND:	PUSH P,A		; Then sent escape character
	MOVE A,SNDFRK(CNX)
	FFORK
	SFORK
	RFORK
	POP P,A
	POP P,B
	DEBRK

ESCINV:	MOVEI A,100
	CFIBF			; do this early for performance
	MOVEI A,101
	TRNE F,COMMDF		; command mode?
	 CFOBF			; yes, flush output
	JRST ESCINY
ESCINZ:	MOVEI A,100
	CFIBF
ESCINY:	SKIPE RLACJ		; Is there likely to be a jfn in ac 1?
	TDNE A,[XWD -1,700000]
	SKIPA			; Apparently not
	 PUSHJ P,CLRJFN		; Apparently yes
	SETZM RLACJ
	SKIPE A,SNDFRK(CNX)	; If there is a send fork
	 FFORK			; Freeze it
	SKIPN A,RECJFN(CNX)	; Connected?
	 JRST ESCINW		; No, skip this
	SETOM SAVSWT(CNX)	; Switch to saving input
	SKIPE A,RCVFRK(CNX)
	RFORK			; Leave running

ESCINW:	SKIPE A,SPCFRK		; If there is a special fork
	 KFORK			; Kill it
	SETZM SPCFRK
	SKIPE A,IJFN
	 PUSHJ P,CLRJFN
	SETZM IJFN		; Release temporary jfn's
	TRNE F,ICPMOD
	 PUSHJ P,RELCON		; release connections if ICP was in prog
	SKIPE B,REALTT		; scope terminal type saved?
	 JRST [ MOVEI A,101
		STTYP		; yes, restore type for command mode
		MOVEI A,100
		SIBE		; any type-ahead since cfibf?
		 JRST .+1	; yes, restored ok
		MOVEI B,40
		STI		; no, simulate char in to break
		PBIN		;  scroll hold, if any
		JRST .+1 ]
ESCI1:	SKIPE A,CMDJFN		; Is there an initial command file?
	 PUSHJ P,CLRJFN		; Yes, close it
	SETZM CMDJFN
	MOVE A,[XWD 10000,COMLP]
	MOVEM A,RETPC1
	DEBRK			; Debrk back to comlp

LEVTAB:	RETPC1
	RETPC2
	RETPC3

CHNTAB:	REPEAT ESCCHN,<XWD 1,BADINT>
	XWD 1,ESCINT
tops20,<
	XWD 1,HLDINT
>
tenex,<
	XWD 1,BADINT
>
	XWD 1,ABNINT
	XWD 1,BADINT
	XWD 2,CBFINT
	REPEAT <^D36-5-ESCCHN>,<XWD 1,BADINT>

FKLVT:	FKRET1
	FKRET2
	FKRET3

FKCHT:	0
	XWD 3,RCVINS
	0
	REPEAT ^D7,<0>
	0
	XWD 1,IOERR
	REPEAT ^D36-^D12,<0>
	DEBRK

; Get a character

GCH:	PUSHJ P,.PBIN
ifn maxc,<
	CAIE A,177		;Standard TENEX delete to kill line
>
ifn sumex,<
	CAIE A,"X"-100		;Sumex uses ^X
>
tops20,<
	CAIE A,"U"-100		;Tops20 (and Tops10) use ^U
>
CPOPJ:	POPJ P,
	HRROI A,[ASCIZ /XXX/]
	PUSHJ P,.PSOUT
	JRST COMLP

; Echo character in a

ECHOIT:	SKIPE HDX
	 PUSHJ P,PBOUT0
	SKIPE HDX
	POPJ P,
	SKIPE NFANCY
	TRNN F,COMMDF
	PUSHJ P,.PBOUT
	POPJ P,

; Primary output with case indicate

.PEOUT:	PUSHJ P,PBOUT0
	CAIL A,100		; Does character have case?
	SKIPE TRMLWC		; Or does terminal have lower case?
	 JRST EOUTX1		; Caseless
	SKIPGE LCASL
	SKIPL LCASC
	SKIPA
	 JRST EOUTX1		; Don't indicate if shift chars absent
	SKIPGE UCASL
	SKIPL UCASC
	SKIPA
	 JRST EOUTX1
	CAIE A,177
	CAIN A,137
	 JRST EOUTX1
	PUSH P,B
	MOVE B,A
	ANDI B,40		; Extract case
	ANDCMI A,40		; Force upper
	CAMN B,TCASE		; Same as current case?
	 JRST EOUTX0		; No need to indicate
	PUSH P,A
	JUMPE B,IUPC		; Upper case
	SKIPG A,LCASL		; Do we have a lower case lock?
	 JRST LCS1		; No, try for lowercase char
	PBOUT			; Yes, print it
	MOVEM B,TCASE		; And remember new case
	JRST EOUTX


LCS1:	SKIPG A,LCASC		; Have we a lower case char prefix?
	 JRST EOUTX		; No, can't indicate
	PBOUT			; Yes, print it
	JRST EOUTX		; But don't change case

IUPC:	SKIPG A,UCASL		; Do we have a upper case lock
	 JRST UCS1
	PBOUT
	MOVEM B,TCASE
	JRST EOUTX

UCS1:	SKIPG A,UCASC
	 JRST EOUTX
	PBOUT
EOUTX:	POP P,A
EOUTX0:	POP P,B
EOUTX1:	CAME A,UCASC
	CAMN A,UCASL
	 JRST ESPCL
	CAME A,LCASC
	CAMN A,LCASL
	 JRST ESPCL
	CAMN A,QUOT
	 JRST ESPCL
	PBOUT
	POPJ P,

ESPCL:	PUSH P,A
	SKIPLE A,QUOT
	PBOUT
	POP P,A
	PBOUT
	POPJ P,


; Primary input

.PBIN:	PUSH P,B
PBIN1:	MOVEI A,100
	TRNE F,COMMDF
	 JRST PBIN0
	SKIPN ALTJFN(CNX)
	 JRST PBIN2
	MOVE A,ALTJFN(CNX)  ; if alt. file exists & in remote mode,
	SOSGE ALTJCT(CNX)   ; take input from file, else tty
	 JRST [ SETZ NOA,
		PUSHJ P,SETALT	; if ct shows eof, close & release
		JRST PBIN1 ]
	BIN
	MOVE A,B
	POP P,B
	POPJ P,
PBIN2:
PBIN0:	SKIPE A,CMDJFN		; Taking input from initial command file?
	 JRST PBIN4		; Yes
	MOVEI A,101
	RFMOD			; will echo be generated?
	TRNE B,3B33!3B25
	 JRST [	MOVEI B,PBOUT0
		EXCH B,0(P)
		JRST .+2]
PBIN3:	POP P,B
PBINX:	PBIN
	POPJ P,

; Get input from initial command file
PBIN4:	BIN
	JUMPE B,[GTSTS		; End of file?
		TLNN B,(1B8)
		 JRST PBIN4	; No, flush null
		PUSHJ P,CLRJFN	; Yes, close file
		SETZM CMDJFN
		JRST PBIN1]	; Get input by other means
	CAIE B,15		; Carriage return?
	 JRST PBIN5		; No
	BIN			; See if line feed follows
	CAIE B,12
	 BKJFN			; No, back up so it will be read
	  CAI
tenex,<
	SKIPE XPARNT(CNX)
	 TRNE F,COMMDF		; if transparent, are we in command?
	  SKIPA B,[37]		; Not transparent or in command
>
	MOVEI B,15		; transparent and not in command

PBIN5:	MOVE A,B
	POP P,B
	TRNE F,COMMDF		; In command mode?
	 PUSHJ P,PBOUT0		; Yes, echo the char
	POPJ P,

; Primary output

.PBOUT:	PBOUT
PBOUT0:	SKIPN SCRJFN
	 POPJ P,
	PUSH P,B
	MOVE B,A
	MOVE A,SCRJFN
tenex,<
	CAIN B,37
	 JRST [ MOVEI B,15	; translate EOL to <CR><LF>
		BOUT
		MOVEI B,12
		BOUT
		MOVEI B,37
		JRST .+2 ]
>
	BOUT
	PUSHJ P,SCRUPD
	MOVE A,B
	POP P,B
	POPJ P,

.PLOUT:	PUSHJ P,.PBOUT
	CAIA
PLOUT0:	PUSHJ P,PBOUT0
PLOUT1:	SKIPN LGFJFN(CNX)
	 POPJ P,
PLOUT2:	PUSH P,A
	MOVE B,A
	MOVE A,LGFJFN(CNX)
tenex,<
	CAIN B,37
	 JRST [ MOVEI B,15
		BOUT
		MOVEI B,12
		BOUT
		MOVEI B,37
		JRST .+2 ]
>
	BOUT
	PUSHJ P,LGFUPD
	MOVE A,B
	POP P,B
	POPJ P,


.GTJFN:	MOVE B,[XWD 100,101]
GTJFN0:	SETOM RLACJ
	GTJFN
	 JRST [	SETZM RLACJ
		POPJ P,]
	MOVEM A,IJFN
	SETZM RLACJ
	PUSH P,C
	SETZ C,
	MOVE B,A
	SKIPE A,SCRJFN
	 JFNS
	POP P,C
	PUSHJ P,SCRUPD
	MOVE A,B
	JRST SKPRET

.NOUT:	NOUT
	 POPJ P,
	SKIPE A,SCRJFN
	NOUT
	 JFCL
	PUSHJ P,SCRUPD
	MOVEI A,101
	AOS (P)
	POPJ P,

.SOUT:	SKIPN A,SCRJFN
	 JRST .SOUT0
	PUSH P,B
	PUSH P,C
	SOUT
	PUSHJ P,SCRUPD
	POP P,C
	POP P,B
.SOUT0:	MOVEI A,101
	SOUT
	POPJ P,

.PSOUT:	SKIPE SCRJFN
	PUSH P,A
	PSOUT
	SKIPN SCRJFN
	 POPJ P,
	EXCH B,0(P)
	PUSH P,C
	MOVE A,SCRJFN
	SETZ C,
	SOUT
	PUSHJ P,SCRUPD
	MOVE A,B
	POP P,C
	POP P,B
	POPJ P,

; Uuo handler

UUO:	HRRO A,40
	PUSHJ P,ERROUT
	MOVEI A,400000
	CIS
	EIR
	JRST COMLP

ERROUT:	PUSH P,A
	MOVEI A,101
	DOBE
	POP P,A
	PUSHJ P,.PSOUT
	MOVEI A,^D1000
	DISMS
	MOVEI A,100
	CFIBF
	POPJ P,

; Convert interrupt character to code

CVINTC:	CAIG A,33
	 JRST SKPRET
	CAIE A,177
	CAIN A,40
	 SKIPA
	POPJ P,
	CAIN A,40
	MOVEI A,^D29
	CAIN A,177
	MOVEI A,^D28
	JRST SKPRET


; type bell

TBEL:	PUSH P,A
	MOVEI A,7
	PBOUT
	POP P,A
	POPJ P,


; Map fork one to one with this fork through page 177
; Call:	A	; Fork handle
;	PUSHJ P,MAPFRK
; Returns
;	+1	; Always. transparent

MAPFRK:	PUSH P,C
	PUSH P,D
	PUSH P,B
	MOVSI D,-177
	MOVSI B,(A)
	MOVSI A,400000
	MOVSI C,160000
MAPFKL:	HRR A,D
	HRR B,D
ifn sumex!sumxsw,<
	PUSH P,B
	RPACS
	TLNN B,(1B5)		;TEST FOR PAGE EXISTS
	 JRST  [POP P,B
		JRST MAPFK1]
	POP P,B
> ;end ifn sumex!sumxsw
	PMAP
ifn sumex!sumxsw,<
MAPFK1:
>
	AOBJN D,MAPFKL
	HLRZ A,B
	POP P,B
	POP P,D
	POP P,C
ifn sumxsw!sumex,<
	PUSHJ P,MAPDDT			; MAP DDT TO LOWER FORK
>
	POPJ P,

ifn sumex!sumxsw,<   ;map DDT down
MAPDDT:	PUSH P,C
	PUSH P,D
	PUSH P,B
	MOVSI D,750-777-1
	HRRI D,750
	MOVSI B,(A)
	HRRI B,750
	MOVSI A,400000
	MOVSI C,160000
MAPDDL:	HRR A,D
	HRR B,D
	PUSH P,B
	RPACS
	TLNN B,(1B5)		;TEST FOR PAGE EXISTS
	 JRST  [POP P,B
		JRST MAPDD1]
	POP P,B
	PMAP
MAPDD1: AOBJN D,MAPDDL
	HLRZ A,B
	POP P,B
	POP P,D
	POP P,C
	POPJ P,

> ;end ifn sumex!sumxsw    ; map DDT to lower fork

INIFRK:	MOVEM NCNX,CNX+FAC
	MOVEI B,FAC
	SFACS
	MOVE B,[XWD FKLVT,FKCHT]
	CIS
	SIR
	EIR
	MOVSI B,(1B1!1B2!1B11)
	AIC
	POPJ P,

; Close and release jfn

CLRJFN:	PUSH P,A
	CLOSF
	 JFCL
	POP P,A
	RLJFN
	 JFCL
	POPJ P,

; Macro for generating commands

DEFINE	CC(STR,VAL)<
	POINT 7,[ASCIZ \STR\
		VAL]
>

; Top level commands

TOPC:	XWD -1,NULTAB
	CC(<;*%x>,<JRST DOCOMT>)
	CC(<describe>,<PUSHJ P,.DSCRB>)
	CC(<list.connections>,<PUSHJ P,LSTCON>)
	CC(<where.am.I>,<PUSHJ P,.WHERE>)
	CC(<wait.for.any.active.connection>,<PUSHJ P,WATRET>)
	CC(<retrieve.connection.under.name>,<PUSHJ P,RETCON>)
	CC(<name.current.connection.to.be>,<PUSHJ P,.STNAM>)
	CC(<!synch!>,<PUSHJ P,SNDSNC>)
	CC(<control>,<PUSHJ P,SNDCTL>)
	XWD -1,CODTB
	CC(<code>,<JRST [	MOVE TAB,CODTB
				JRST SYMVAL]>)
	CC(<exec>,<PUSHJ P,.EXEC>)
	CC(<ddt>,<JRST 770000>)
	CC(<reset>,<PUSHJ P,.RESET>)
	CC(<logout>,<PUSHJ P,.LGOUT>)
	CC(<quit>,<PUSHJ P,.QUIT>)
	CC(<run>,<PUSHJ P,.RUN>)
	CC(<help>,<PUSHJ P,.HELP>)
	CC(<escape.character=>,<PUSHJ P,SETESC>)
	XWD -1,YNTB
tops20,<
	CC(<simulate.tenex.hold.with.hold.key=>,<PUSHJ P,SETSCH>)
>
	CC(<current.modes.are>,<PUSHJ P,PRCMD>)
	CC(<no>,<JRST [SETCA NOA,
			MOVE TAB,YNTB
			JRST SYMVAN]>)
	CC(<remote.mode>,<PUSHJ P,SETREM>)
	CC(<local.mode>,<TRZ F,REMOTF>)
	CC(<terminal.type.is>,<PUSHJ P,SETTRM>)
	CC(<echo.mode.is>,<PUSHJ P,.ECHO>)
	CC(<disconnect>,<PUSHJ P,.DISC>)
	CC(<connection.to>,<PUSHJ P,.CONN>)
	XWD -1,HOSTAB
COMTAB:	XWD TOPC-.,TOPC

YNT:	CC(<log.file.for.current.connection>,<PUSHJ P,SETLGF>)
	CC(<auto.switch.to.active.connection>,<PUSHJ P,ACTVST>)
	CC(<signal.waiting.output>,<MOVEM NOA,SWOFLG>)
	CC(<typescript.to.file>,<PUSHJ P,SETSCR>)
	CC(<take.input.stream.from.file>,<PUSHJ P,SETALT>)
	CC(<divert.output.stream.to.file>,<PUSHJ P,SETDIV>)
	CC(<fancy.command.interpret>,<SETCAM NOA,NFANCY>)
	CC(<verbose>,<SETCAM NOA,CONCSF>)
	CC(<concise>,<MOVEM NOA,CONCSF>)
	CC(<clear.output.character:>,<PUSHJ P,SETCBF>)
	CC(<synch.character:>,<PUSHJ P,SETSNC>)
	CC(<quote.prefix:>,<PUSHJ P,SETQOT>)
	CC(<unshift.prefix:>,<PUSHJ P,SETUNS>)
	CC(<case.shift.prefix.for>,<PUSHJ P,SETSHF>)
	CC(<transparent.mode>,<MOVEM NOA,XPARNT(CNX)>)
	CC(<lower>,<MOVEM NOA,LOWERF(CNX)>)
	CC(<raise>,<MOVEM NOA,RAISEF(CNX)>)
	CC(<line.buffer>,<MOVEM NOA,LNBFF(CNX)>)
	CC(<character.mode>,<SETCAM NOA,LNBFF(CNX)>)
YNTB:	XWD YNT-.,YNT

; Null table
NTP:	CC(<>,<JFCL>)
NULTAB:	XWD NTP-.,NTP

; Table of character code specifiers

CDTB:	CC(<d%d*%d>,<PUSHJ P,SNDDCD>)
	CC(<h%h*%h>,<PUSHJ P,SNDHCD>)
	CC(<o%o*%o>,<PUSHJ P,SNDOCD>)
	CC(<%o*%o>,<PUSHJ P,SNDOCT>)
CODTB:	XWD CDTB-.,CDTB

; Command table for terminal modes

TRMT:	CC(<lowercase>,<PUSHJ P,SETLWR>)
	CC(<halfduplex>,<MOVEM NOA,HDX>)
	CC(<fullduplex>,<SETCAM NOA,HDX>)
	CC(<no>,<JRST [	SETCA NOA,
			JRST SYMVAN]>)
TRMTAB:	XWD TRMT-.,TRMT

; Command table for echo modes

ETP:	CC(<local>,<JRST [	MOVEM NOA,ELCLF(CNX)
				JRST CHGECH]>)
	CC(<remote>,<JRST [	SETCAM NOA,ELCLF(CNX)
				JRST CHGECH]>)
	CC(<linefeed.for.carriage.return>,<MOVEM NOA,LFCRF(CNX)>)
	CC(<control.character.echo.for>,<PUSHJ P,SETCOC>)
	CC(<no>,<JRST [SETCA NOA,
			JRST SYMVAN]>)
ECTAB:	XWD ETP-.,ETP

; Command table for socket lookup

STP:	CC(<name.for.connection.is>,<PUSHJ P,.STNAM>)
	XWD -1,SETTAB
	XWD -1,NULTAB
SKTTAB:	XWD STP-.,STP

STB:	CC(<no>,<JRST [	SETCA NOA,
			MOVE TAB,SETTAB
			JRST SYMVAN]>)
	CC(<wait>,<MOVEM NOA,WATFLG>)
SETTAB:	XWD STB-.,STB

HTP:	
ifn maxc,<
; Maxc host table
; Maxc1 and Maxc2 are the only names built into the command table.
; I would do something better if I really understood how this
; all worked!

	CC(<XEOS>,<PUSHJ P,CONMAX>)
	CC(<WRC>,<PUSHJ P,CONMAX>)
	CC(<Sun>,<PUSHJ P,CONMAX>)
	CC(<Oly>,<PUSHJ P,CONMAX>)
	CC(<Juniper>,<PUSHJ P,CONMAX>)
	CC(<Ivy>,<PUSHJ P,CONMAX>)
	CC(<Isis>,<PUSHJ P,CONMAX>)
	CC(<Iris>,<PUSHJ P,CONMAX>)
	CC(<Ibis>,<PUSHJ P,CONMAX>)
	CC(<ADL>,<PUSHJ P,CONMAX>)
	CC(<Maxc2>,<PUSHJ P,CONMAX>)
	CC(<Maxc1>,<PUSHJ P,CONMAX>)
>
IFN SUMEX!SUMXSW,<
;Sumex-AIM and Sumex-2020 host table
	CC(<Dual>,<PUSHJ P,CONMAX>)
	CC(<Palo>,<PUSHJ P,CONMAX>)
	CC(<Tiny>,<PUSHJ P,CONMAX>)
>
HOSTAB:	XWD HTP-.,HTP

; "Any character" table - used to collect arbitrary strings
; (like host names)

ANYT:	CC(<%x*%x>,<JFCL>)
ANYTAB:	XWD ANYT-.,ANYT

; Octal number table

OCT:	CC(<%o*%o>,<PUSHJ P,CVOCT>)
OCTB:	XWD OCT-.,OCT

; Decimal number table

DCM:	CC(<%d*%d>,<PUSHJ P,CVDEC>)
DCMTB:	XWD DCM-.,DCM

; Letter table

LTR:	CC(<%a>,<ILDB A,BPTR>)
LTRTB:	XWD LTR-.,LTR

; Connection name table

NAMT:	CC(<%n*%n>,<SETO A,>)
NAMTB:	XWD -2,[XWD NAMT-.,NAMT
		XWD -1,CONTAB]

; Case shift command table

SFTAB:	CC(<lock.upper.case>,<MOVEI A,UCASL>)
	CC(<char.upper.case>,<MOVEI A,UCASC>)
	CC(<lock.lower.case>,<MOVEI A,LCASL>)
	CC(<char.lower.case>,<MOVEI A,LCASC>)
SFTB:	XWD SFTAB-.,SFTAB


; table of identifiers for describe command

DSCRT:	CC(<comments>,<JFCL>)
	CC(<list.connections>,<JFCL>)
	CC(<signal.waiting.output>,<JFCL>)
	CC(<where.am.i>,<JFCL>)
	CC(<auto.switch.to.active.connection>,<JFCL>)
	CC(<wait.for.any.active.connection>,<JFCL>)
	CC(<retrieve.connection.under.name>,<JFCL>)
	CC(<!synch!>,<JFCL>)
	CC(<code>,<JFCL>)
	CC(<exec>,<JFCL>)
	CC(<ddt>,<JFCL>)
	CC(<reset>,<JFCL>)
	CC(<logout>,<JFCL>)
	CC(<quit>,<JFCL>)
	CC(<run>,<JFCL>)
	CC(<describe>,<JFCL>)
	CC(<help>,<JFCL>)
	CC(<clear.output.character=>,<JFCL>)
	CC(<escape.character=>,<JFCL>)
	CC(<log.file.for.current.connection>,<JFCL>)
	CC(<typescript.to.file>,<JFCL>)
	CC(<take.input.stream.from.file>,<JFCL>)
	CC(<divert.output.stream.to.file>,<JFCL>)
	CC(<fancy.command.interpret>,<JFCL>)
	CC(<verbose>,<JFCL>)
	CC(<concise>,<JFCL>)
	CC(<synch.character>,<JFCL>)
	CC(<quote.prefix>,<JFCL>)
	CC(<unshift.prefix>,<JFCL>)
	CC(<case.shift.prefix.for>,<JFCL>)
	CC(<transparent.mode>,<JFCL>)
	CC(<lower>,<JFCL>)
	CC(<raise>,<JFCL>)
	CC(<line.buffer>,<JFCL>)
	CC(<character.mode>,<JFCL>)
	CC(<current.modes.are>,<JFCL>)
	CC(<no>,<JFCL>)
	CC(<remote.mode>,<JFCL>)
	CC(<local.mode>,<JFCL>)
	CC(<terminal.type.is>,<JFCL>)
	CC(<echo.mode.is>,<JFCL>)


	CC(<disconnect>,<JFCL>)
	CC(<connection.to>,<JFCL>)
	CC(<log-file>,<JFCL>)
	CC(<initial-command-file>,<JFCL>)
	CC(<input-from-a-file>,<JFCL>)
	CC(<diverting-output>,<JFCL>)
	CC(<typescript-file>,<JFCL>)
	CC(<multiple-connections>,<JFCL>)
	CC(<leaving-chat>,<JFCL>)
	CC(<special-characters>,<JFCL>)
	CC(<status-commands>,<JFCL>)
	CC(<line-buffering>,<JFCL>)
	CC(<echo-control>,<JFCL>)
	CC(<disconnecting>,<JFCL>)
	CC(<making-a-connection>,<JFCL>)
	CC(<escaping>,<JFCL>)
	CC(<command/remote-mode>,<JFCL>)
	CC(<command-interpreter>,<JFCL>)
	CC(<chat>,<JFCL>)
DSCRTB:	XWD DSCRT-.,DSCRT


; Symbol evaluator
; This is temporary until Sumex-AIM gets PA2040 added, and tops20 gets
; COMND JSYS front-end

SYMVAL:	SETO NOA,
SYMVAN:	MOVEM PTR,BPTR		; Save beginning of symbol
SYMLUP:	PUSHJ P,GCH		; Get a character
	CAIE A,"A"-100		; Control-a
	CAIN A,"H"-100		; Or control-h
	 JRST DELCH		; Delete character
ifn sumex!ft20,<
	CAIN A,177		; Sumex and tops20 like delete
	 JRST DELCH
>
	CAIN A,"R"-100
	 JRST RETYPE		; Control-r, retype line
	CAIN A,"W"-100		; Control-w
	 JRST DELWRD		; Delete word
	CAIN A,"?"		; Question mark
	 JRST PRQUES		; Print options
	CAIE A,33		; Altmode or
tenex,<
	CAIN A,37		; Eol
>
tops20,<
	CAIN A,15
>
	 JRST SYMEND		; Lookup
	CAIE A,","		; Comma
	CAIN A," "		; Or space same thing
	 JRST SYMEND
	IDPB A,PTR		; Else deposit into string
	PUSHJ P,TRMST
	SKIPE NFANCY
	 JRST SYMLPE
	SETZ X,			; Clear x
	MOVEM P,SVP		; Save p
	MOVE Y,TAB		; Init y
	PUSHJ P,SYMLUK		; Lookup the current symbol
	MOVE P,SVP		; Restore p
	JUMPE X,[DPB X,PTR	; Smash null onto last character
		MOVE A,PTR
		BKJFN		; Back up pointer
		 0
		MOVEM A,PTR
		JRST DING]	; And echo bell
SYMLPE:	LDB A,PTR		; Symbol still ok, get char
	PUSHJ P,ECHOIT
	JRST SYMLUP		; And loop

DELCH:	CAMN PTR,BPTR		; Delete character, any to delete?
	 JRST DING		; No, echo bell
	MOVEI A,"\"
	PUSHJ P,.PBOUT
	LDB A,PTR
	PUSHJ P,.PBOUT
	MOVE A,PTR
	BKJFN
	 0
	MOVEM A,PTR
	JRST SYMLUP

TRMST:	PUSH P,A
	PUSH P,PTR
	SETZ A,
	IDPB A,PTR
	POP P,PTR
	POP P,A
	POPJ P,

DING:	MOVEI A,7
	PUSHJ P,.PBOUT
	JRST SYMLUP

DELWRD:	CAMN PTR,BPTR		; Delete word
	 JRST DING		; Nothing
	MOVEI A,"#"
	PUSHJ P,.PBOUT
	PUSHJ P,.PBOUT
DELW0:	MOVE PTR,BPTR
	JRST SYMLUP

RETYPE:	MOVE A,PTR
	MOVEI B,0
	IDPB B,A
	MOVEI A,15
	PUSHJ P,.PBOUT
	MOVEI A,12
	PUSHJ P,.PBOUT
	MOVE A,LPTR
	PUSHJ P,.PSOUT
	JRST SYMLUP

; End of symbol, try lookup

SYMEND:	MOVEM A,TERM		; Save terminator
tops20,<
	CAIE A,15
	 JRST SYMND1
	PUSH P,A
	PBIN			; Eat the line feed
	POP P,A
SYMND1:
>
	PUSHJ P,TRMST
	SETZ X,
	MOVE Y,TAB
	PUSHJ P,SYMLUK
	JUMPE X,[HRROI A,[ASCIZ / ? /]
		PUSHJ P,ERROUT
		MOVE A,TERM
tenex,<
		CAIE A,37
>
tops20,<
		CAIE A,15
>
		 JRST DELW0
		JRST COMLP]
	CAIE X,1		; Exactly one symbol
	 JRST SYMAMB		; No. ambiguous
	POP P,C			; Leave pointer to head in c
	POP P,B			; Get pointer to tail of command
SYMCLP:	ILDB A,B		; Copy to terminal
	JUMPE A,SYMECL
	MOVE D,TERM
	SKIPE HDX
	 JRST NCOMP
	SKIPN NFANCY
	SKIPE CONCSF
NCOMP:	CAIN D,33
	 PUSHJ P,.PBOUT
	IDPB A,PTR
	JRST SYMCLP

SYMECL:	MOVEI A,40
	MOVE D,TERM
	CAIN D,33
	 JRST [	PUSHJ P,.PBOUT
		JRST .+4]
tenex,<
	CAIE D,37
>
tops20,<
	CAIE D,15
>
	MOVE A,D
	PUSHJ P,ECHOIT
	IDPB A,PTR
	PUSHJ P,TRMST
	TRZ F,TMPF3!TMPF4!TMPF5
	XCT 1(B)		; Execute "value"
	POPJ P,			; And return
	XCT 2(B)		; If first value skips, execute 2nd
	POPJ P,

SYMAMB:	JUMPE X,DING		; Nothing left, go ding
	POP P,C			; Leave pointer to head in c
	POP P,B			; Get pointer to tail
	ILDB A,B		; Get first ch of tail
	JUMPN A,[SOJA X,SYMAMB]	; If not null, then loop
SYMAML:	SOJLE X,SYMECL		; Else unique
	SUB P,[XWD 2,2]		; Flush the junk
	JRST SYMAML


PRQUES:	PUSHJ P,ECHOIT
	PUSHJ P,TRMST
	SETZ X,
	MOVE Y,TAB
	TRZ F,TMPF5
	TRO F,TMPF6
	PUSHJ P,SYMLUK		; Get all the possibilities
PRQUEL:	JUMPE X,RETYPE		; All done, retype the line
tenex,<
	MOVEI A,37
>
tops20,<
	MOVEI A,15
	PUSHJ P,.PBOUT
	MOVEI A,12
>
	PUSHJ P,.PBOUT		; Eol
	TRZ F,TMPF!TMPF2!TMPF4
PRQUEN:	ILDB A,0(P)
	JUMPE A,PRQUEE
PRQUEB:	CAIN A,"*"
	 JRST [	TRNE F,TMPF3	; reassurance if in "not" mode
		TRNE F,TMPF5!TMPF6
		CAIA
		 JRST [	PUSH P,A
			HRROI A,[ASCIZ /[but otherwise] /]
			PUSHJ P,.PSOUT
			TRO F,TMPF5
			POP P,A
			JRST PRQUEB]
		HRROI A,[ASCIZ /<any number of /]
		PUSHJ P,.PSOUT
		TRO F,TMPF!TMPF4
		JRST PRQUEN]
	CAIN A,"%"
	 JRST [ TRNE F,TMPF3
		TRNE F,TMPF5!TMPF6
		CAIA
		 JRST [	PUSH P,A
			HRROI A,[ASCIZ /[but otherwise] /]
			PUSHJ P,.PSOUT
			TRO F,TMPF5
			POP P,A
			JRST PRQUEB]
		ILDB A,0(P)
		MOVE C,0(P)		; look ahead to detect possible
		PUSHJ P,[ ILDB B,C	;  "any number of same"
			CAIE B,"*"
			 POPJ P,
			ILDB B,C	; consisting of *%<char in A>..
			CAIE B,"%"
			 POPJ P,
			ILDB B,C
			CAMN B,A
			 AOS 0(P)	; skip if we have one
			POPJ P, ]


		CAIA		; do we have one?
		 JRST [ HRROI A,[ASCIZ /<string of /]
			PUSHJ P,.PSOUT	; yes, eliminate redundant
			IBP 0(P)	;  description of char class
			TRO F,TMPF!TMPF4
			JRST PRQUEN ]
		SETZ B,
		CAIN A,"D"+40
		 HRROI B,[ASCIZ /decimal digit/]
		CAIN A,"O"+40
		 HRROI B,[ASCIZ /octal digit/]
		CAIN A,"H"+40
		 HRROI B,[ASCIZ /hexadecimal digit/]
		CAIN A,"A"+40
		 HRROI B,[ASCIZ /alphabetic character/]
		CAIN A,"N"+40
		 HRROI B,[ASCIZ /alphameric character/]
		CAIN A,"S"+40
		 HRROI B,[ASCIZ /separator/]
		CAIN A,"P"+40
		 HRROI B,[ASCIZ /punctuation mark/]
		CAIN A,"X"+40
		 HRROI B,[ASCIZ /any character/]
		MOVEI A,"<"
		TRNN F,TMPF
		 PUSHJ P,.PBOUT
		MOVE A,B
		PUSHJ P,.PSOUT
		TRO F,TMPF2!TMPF4
		JRST PRQUEQ ]
	TRNN F,TMPF4
	TRNN F,TMPF3
	CAIA
	 JRST [	PUSH P,A
		HRROI A,[ASCIZ /[not] /]
		PUSHJ P,.PSOUT
		TRO F,TMPF4
		TRZ F,TMPF6
		POP P,A
		JRST .+1]
	PUSHJ P,.PBOUT
PRQUEQ:	TRNN F,TMPF!TMPF2
	 JRST PRQUEN
	HRROI A,[ASCIZ /'s>/]
	TRZE F,TMPF2
	 HRROI A,[ASCIZ /s>/]
	TRZN F,TMPF
	 HRROI A,[ASCIZ />/]
	PUSHJ P,.PSOUT
	JRST PRQUEN

PRQUEE:	SUB P,[XWD 2,2]		; Flush pointer to end
	SOJA X,PRQUEL		; And loop

; Lookup symbol
; Operates recursively and accumulates a list of things on the stack

SYMLUK:	PUSH P,SVP		; Save old bottom
	MOVEM P,SVP		; Svp points to chain of svp
	TLNE Y,7000		; Byte pointer in y?
	 JRST SYMLK1		; No aobjn word
	PUSH P,Y		; Yes, sve y
	MOVE D,BPTR		; Get pointer to symbol
SYMLKL:	ILDB A,D		; Get character from input
	ILDB B,Y		; And from table entry
	PUSHJ P,SYMCMP		; Compare the characters
	 JRST SYMNEQ		; Not equal
	JUMPN A,SYMLKL		; Continue until null
SYMEQL:	MOVE A,Y
	BKJFN			; Back up pointer to tail
	 JRST [ CAIE A,600150	; dont bomb out if empty list--
		0		; (non-neg. AOBJN ptr)
		JRST SYMNEX ]
	MOVEM A,Y
	EXCH Y,-2(P)		; Pointer to tail to stack, get ret
	POP P,A			; Pointer to head
	POP P,SVP		; Restore svp
	PUSH P,A		; Pointer to head back to stack
	AOJA X,0(Y)		; Return and count items

SYMNEQ:	JUMPE A,SYMEQL		; If input ends first, then substring
SYMNEX:	SUB P,[XWD 1,1]		; Else flush saved y
	POP P,SVP		; Restore svp
	POPJ P,			; And return

SYMLK1:	PUSH P,Z		; Save z
	MOVE Z,Y		; Use as place to count y
SYMLK3:	MOVE Y,0(Z)		; Loop to here for each item
	PUSHJ P,SYMLUK		; Do this item
	AOBJN Z,SYMLK3		; Loop over all things
	MOVE A,P		; Get p
	SUB A,[XWD 1,1]
	CAMN A,SVP		; Any items saved on stack?
	 JRST SYMLK4		; No, shuffle not needed
	MOVE A,SVP		; Get base of stack
	MOVE Z,1(A)		; Restore z
	POP A,SVP		; Restore svp
	MOVE Y,0(A)		; Get return
	MOVEI B,0(A)		; Where to blt to
	HRLI B,3(A)		; And where from
	BLT B,-3(P)		; Copy stack down
	SUB P,[XWD 3,3]
	JRST 0(Y)		; Return

SYMLK4:	POP P,Z
	POP P,SVP
	POPJ P,

SYMCMP:	CAIN B,"*"		; Asterisk
	 JRST SYMMNY		; Means any number of
	CAIN B,"%"		; Percent
	 JRST SYMCLS		; Means character class
	CAIN B,"#"		; Pound sign
	 JRST SYMNCL		; Means not character class
SYMCM2:	PUSH P,B
	PUSH P,A
	XOR A,B
	TRZ B,40		; Ignore case of b
	CAIL B,"A"		; Then if b has
	CAILE B,"Z"		;  a letter
	SKIPA
	 TRZ A,40		; Then ignore case of difference
	SKIPN A
	AOS -2(P)
	POP P,A
	POP P,B
	POPJ P,

SYMMNY:	PUSH P,Y		; Save where we are in table entry
	ILDB B,Y		; Get what we are doing many of
	PUSHJ P,SYMCMP		; Check match
	 JRST SYMMNN		; Not equal
	ILDB B,Y		; See if next is also equal
	PUSHJ P,SYMCMP
	 JRST [	EXCH A,0(P)	; Not equal, get back y, save a
		BKJFN
		 0
		MOVEM A,Y
		POP P,A
		JRST SKPRET]
	SUB P,[XWD 1,1]		; Matches next thing, use it instead
SKPRET:	AOS(P)
	POPJ P,

SYMMNN:	SUB P,[XWD 1,1]		; Go to next thiing
	ILDB B,Y
	JRST SYMCMP

SYMCLS:ILDB B,Y		; Get class indicator
	CAIN B,"%"		; %% means %
	 JRST SYMCM2
	CAIN B,"d"		; d means decimal digit
	 JRST SYMDEC
	CAIN B,"o"		; o means octal digit
	 JRST SYMOCT
	CAIN B,"h"
	 JRST SYMHEX
	CAIN B,"a"		; a means alphabetic
	 JRST SYMALP
	CAIN B,"n"		; n means alphameric
	 JRST SYMALM
	CAIN B,"s"		; s means separator
	 JRST SYMSEP
	CAIN B,"p"		; p for punctuation
	 JRST SYMPNC
	CAIN B,"x"
	 JRST SYMANY
	POPJ P,			; Else fail

SYMNCL:	PUSHJ P,SYMCLS
	 AOS (P)
	POPJ P,

SYMANY:	AOS (P)
	POPJ P,

SYMDEC:	CAIG A,"9"
	CAIGE A,"0"
	 POPJ P,
	JRST SKPRET

SYMOCT:	CAIG A,"7"
	CAIGE A,"0"
	 POPJ P,
	JRST SKPRET

SYMHEX:	CAIG A,"9"
	CAIGE A,"0"
	 JRST SYMHE1
	JRST SKPRET

SYMHE1:	TRZ A,40
	CAIG A,"F"
	CAIGE A,"A"
	 POPJ P,
	JRST SKPRET

SYMALM:	PUSHJ P,SYMDEC
	 JRST SYMALP
	JRST SKPRET

SYMALP:	TRZ A,40
	CAIG A,"Z"
	CAIGE A,"A"
	 POPJ P,
	JRST SKPRET

SYMSEP:SYMPNC:POPJ P,

; Host-name command

CONMAX:	MOVEM C,FHST		; Save pointer to host name
	SETZM FSKT
	JRST CONNX		; Enter "Connect"


; Connect.to

.CONN:	MOVE TAB,ANYTAB		; Collect arbitrary string
	PUSHJ P,SYMVAL
	MOVE A,BPTR		; Save pointer to it
	MOVEM A,FHST
	MOVE B,[1B0+2B17+C]	; See if legal name expression
	PUPNM
	 JRST [	HRROI A,[ASCIZ / ? /]
		PUSHJ P,ERROUT
		MOVE A,TERM
tenex,<
		CAIE A,37
>
tops20,<
		CAIE A,15
>
		 JRST .CONN
		JRST COMLP]
	TLNE C,-1		; Net and host specified?
	TRNN C,-1
	 JRST [	HRROI A,[ASCIZ / Insufficient address expression./]
		PUSHJ P,ERROUT
		JRST COMLP]
	MOVEM D,FSKT
CONNX:	MOVSI X,-NCONN
CONNX2:	SKIPE A,SNDJFN(X)	; Find an empty connection
	 AOBJN X,CONNX2
	JUMPGE X,[ERROR [ASCIZ /too many connections./]]
	HRRZS NCNX,X
	MOVE A,NCNX
	IMULI A,3
	ADDI A,CONNAM
	HRLI A,440700
	MOVEI B,1(X)
	MOVEI C,010
	NOUT
	 JFCL
	IBP A
	HRLI X,(<MOVEI A,0>)
	MOVEM X,1(A)
	PUSHJ P,DEFSKT

CONN2:	HRROI A,[ASCIZ /is /]
	PUSHJ P,.PSOUT
	TRO F,ICPMOD		; set "ICP in progress"
	PUSHJ P,ASNSKT
	PUSHJ P,DOICP		; Do icp
	 JRST [	SKIPN WATFLG	; Failed. wait?
		 JRST [ TRZ F,ICPMOD  ; No
			POPJ P, ]
		HRROI A,[ASCIZ /  First attempt failed,
trying again ... /]
		SKIPG WATFLG
		PUSHJ P,.PSOUT
		SKIPLE WATFLG
		 PUSHJ P,TBEL
		MOVMS WATFLG
		MOVEI A,^D10000
		DISMS
		JRST .-2]
	MOVEI A,7
	MOVEI B,20
	SKIPLE WATFLG
	PUSHJ P,.PBOUT
	SOJG B,.-2
	MOVEI A,400000
	DIR
	HRROI A,[ASCIZ /complete/]
	PUSHJ P,.PSOUT
	TRZ F,ICPMOD
	SKIPE A,SNDFRK(NCNX)
	 JRST CONN3
	MOVSI A,(1B1)
	CFORK
	 JRST [	JSP X,CONFL0
		ASCIZ /can't create send fork./]
	MOVEM A,SNDFRK(NCNX)
	PUSHJ P,MAPFRK

CONN3:	PUSHJ P,INIFRK
	SKIPE A,RCVFRK(NCNX)
	 JRST CONN4
	MOVSI A,(1B1)
	CFORK
	 JRST [	JSP X,CONFL1
		ASCIZ /can't create receive fork./]
	MOVEM A,RCVFRK(NCNX)
	PUSHJ P,MAPFRK
CONN4:	
ifn sumex!sumxsw,<
	PUSH P,A
	HRLZ A,SNDFRK(NCNX)	; make send and receive share a page
	HRRI A,300
	HRLZ B,RCVFRK(NCNX)
	HRRI B,300
	MOVSI C,140000		; access is read/write
	PMAP
	POP P,A
>
	PUSHJ P,INIFRK
	MOVE CNX,NCNX
	HLRE A,CONTAB
	MOVNS A
	ADD A,CONTAB
	HRRZ B,CNX
	IMULI B,3
	ADDI B,CONNAM
	HRLI B,440700
	MOVEM B,(A)
	MOVSI B,-1
	ADDM B,CONTAB
	MOVN A,LSKT(CNX)
	ASH A,-1
	MOVSI B,(1B0)
	ROT B,(A)
	IORM B,SKTMSK
	SETZM SAVSWT(CNX)
	MOVEI B,SEND
	MOVE A,SNDFRK(CNX)
	FFORK
	SFORK
	MOVE A,RCVFRK(CNX)
	MOVEI B,RECV
	FFORK
	SFORK
	TRO F,REMOTF
	MOVEM CNX,FSVCNX	; change save loc to reflect new CNX
	MOVEI A,"."
	PUSHJ P,.PBOUT
	MOVEI A,400000
	EIR
	POPJ P,

CONFL1:CONFL0:	HRROI A,[ASCIZ /,
 but /]
	PUSHJ P,.PSOUT
	PUSHJ P,RELCON
CONFLX:	PUSHJ P,.PSOUT
	POPJ P,

; Assign local socket for connection

ASNSKT:	SETCM A,SKTMSK
	PUSH P,B
	JFFO A,ASNSK1
	MOVEI B,177
ASNSK1:	MOVE A,B
	POP P,B
	LSH A,1
	POPJ P,

; Get foreign socket number or return default socket

DEFSKT:	SETZM WATFLG
	SETOM LODFLG
DEFSK0:	MOVE A,TERM
tenex,<
	CAIN A,37
>
tops20,<CAIN A,15>
	 POPJ P,
	MOVE TAB,SKTTAB
	PUSHJ P,SYMVAL		; Look for qualifiers
	JRST DEFSK0


; Perform icp

DOICP:	MOVEM A,LSKT(NCNX)	; Remember local socket
	HRROI A,HLPBUF		; Build complete name here
	HRROI B,[ASCIZ /PUP:/]
	SETZ C,
	SOUT
	MOVE B,LSKT(NCNX)
	MOVEI C,10
	NOUT
	 0
	HRROI B,[ASCIZ /!J./]
	SETZ C,
	SOUT
	MOVE B,FHST		; Foreign host name
	SOUT
	LDB B,A			; See if command scanner put space on end
	CAIN B,40
	 BKJFN			; Yes, back up over it
	  CAI
	HRROI B,[ASCIZ /+Telnet/]
	SKIPG FSKT		; Foreign socket specified?
	 SOUT			; No, default
	MOVSI A,(1B2+1B17)	; Short form, name from string
	HRROI B,HLPBUF
	GTJFN			; Get a JFN for the port
	 JRST OPNCO7
	MOVEM A,SNDJFN(NCNX)	; Ok, save output JFN
	MOVE B,[8B5+8B17+1B20]	; Bytesize 8, 30-second timeout
	OPENF			; Initiate rendezvous
	 JRST OPNCO4		; Failed

; Now make name string and open same port for input
	MOVE C,[2,,C]		; Get foreign port address
	GDSTS
	PUSH P,D		; Save it
	PUSH P,C
	CVSKT			; Get local port address
	 0
	PUSH P,C
	HRROI A,HLPBUF		; Where to build name
	HRROI B,[ASCIZ /PUP:/]
	SETZ C,
	SOUT
	POP P,B
	MOVEI C,10
	NOUT
	 0
	HRROI B,[ASCIZ /!A./]
	SETZ C,
	SOUT
	HLRZ B,0(P)		; Recover net
	MOVEI C,10
	NOUT
	 0
	MOVEI B,"#"
	BOUT
	POP P,B			; Host
	HRRZS B
	NOUT
	 0
	MOVEI B,"#"
	BOUT
	POP P,B			; Socket
	NOUT
	 0
	MOVSI A,(1B2+1B17)	; Short form, name from string
	HRROI B,HLPBUF
	GTJFN			; Get a JFN for the port
	 JRST OPNCO6		; Failed (unlikely)
	MOVEM A,RECJFN(NCNX)	; Ok, save input JFN
	MOVE B,[8B5+1B19]	; Bytesize 8, open for input
	OPENF
	 JRST OPNCO5		; Failed (unlikely)
	JRST SKPRET		; Return +2

; Failure from first OPENF
OPNCO4:	HRLM A,0(P)		; Save error code
	MOVE A,SNDJFN(NCNX)	; Recover JFN
	RLJFN			; Release it
	 0
	HLRZ A,0(P)		; Recover error code
	JRST OPNCO7

; Failure from second OPENF
OPNCO5:	HRLM A,0(P)		; Save error code
	HRRZ A,RECJFN(NCNX)	; Release the input JFN
	RLJFN
	 0
	HLRZ A,0(P)		; Recover error code

; Failure from second GTJFN
OPNCO6:	HRLM A,0(P)
	HRRZ A,SNDJFN(NCNX)	; Get output JFN
	MOVEI B,25		; Abort function
	SETZ C,			; No code assigned
	HRROI D,[ASCIZ /Connection attempt aborted/]  ; Abort text
	MTOPR			; Abort the connection
	CLOSF			; Close the port
	 0			; Can't fail after abort done
	HLRZ A,0(P)
OPNCO7:	SETZM RECJFN(NCNX)
	SETZM SNDJFN(NCNX)
	SKIPLE WATFLG
	 POPJ P,		; No message on repeat failures
	HRROI B,[ASCIZ /of unknown problem./]
	CAIN A,OPNX20		; Check for special cases
	 HRROI B,[ASCIZ /connection attempt timed out./]
	CAIN A,OPNX21
	 HRROI B,[ASCIZ /connection attempt rejected by remote host./]
	HRROI A,[ASCIZ /incomplete,
because /]
	PSOUT
	MOVE A,B
	PSOUT
	POPJ P,			; Take fail return


RELCON:	MOVEI A,400000
	DIR
	MOVE X,NCNX
	PUSHJ P,DSCNCT
	MOVEI A,400000
	EIR
	POPJ P,

DSCNCT:	MOVE A,SNDJFN(X)	; Disconnect current conx
	CLOSF
	 JRST [	MOVE A,SNDJFN(X)
		CLOSF
		 CAI
		JRST .+1]
	MOVE A,RECJFN(X)
	CLOSF
	 CAI
	MOVE A,SNDJFN(X)
	RLJFN
	 CAI
	MOVE A,RECJFN(X)
	RLJFN
	 CAI
	SETZM SNDJFN(X)
	SETZM RECJFN(X)
	POPJ P,

; Disconnect

.DISC:	MOVE A,TERM
	MOVE X,CNX
tenex,<
	CAIN A,37
>
tops20,<
	CAIN A,15
>
	 JRST DISC1
	SKIPL TAB,CONTAB
	 POPJ P,
	PUSHJ P,SYMVAL
	MOVE X,A
DISC1:	MOVEI A,400000
	DIR
	CAMN X,CNX
	 TRZ F,REMOTF
	MOVE A,ABNCNX		; Might be abncnx
	SETOM ABNCNX		; Clear it
	CAMN X,A		; And if it was
	 SETOM ABNLCK		; Unlock abnlck
	MOVEI A,0
	EXCH A,ALTJFN(X)	; flush file input if any
	SKIPLE A
	 PUSHJ P,CLRJFN
	SKIPN A,RECJFN(X)
	 POPJ P,		; No connection
	MOVE A,RCVFRK(X)
	FFORK
	SETZ NOA,
	EXCH X,CNX
	PUSHJ P,SETLGF
	EXCH X,CNX
	PUSHJ P,DSCNCT		; break connection
	MOVN A,LSKT(X)
	ASH A,-1
	MOVSI B,(1B0)
	ROT B,(A)
	ANDCAM B,SKTMSK
	IMULI X,3		; Compute pointer to this name
	ADDI X,CONNAM
	HRLI X,440700
	MOVE Y,CONTAB
	CAME X,0(Y)		; Search for entry in contb
	 AOBJN Y,.-1
	MOVE A,1(Y)		; Move entries above here, down to
	MOVEM A,0(Y)		;  fill in the gap
	AOBJN Y,.-2
	MOVSI X,1
	ADDM X,CONTAB		; One less entry in contb
	MOVEI A,400000
	EIR
	POPJ P,


; Set name for connection

.STNAM:	MOVE TAB,NAMTB
	TRO F,TMPF3
	PUSHJ P,SYMVAL
	JUMPGE A,NAMINU
	HRRZ A,NCNX
	IMULI A,3
	ADDI A,CONNAM
	HRLI A,440700
	MOVE B,BPTR
	MOVEI C,^D8
	LDB D,PTR		; Get terminator
	SOUT			; Copy through it
	SETZ B,
	DPB B,A			; Replace terminator with null
	MOVE B,NCNX
	HRLI B,(<MOVEI A,>)
	MOVEM B,1(A)
	POPJ P,

NAMINU:	ERROR [ASCIZ /name already in use/]

; Set auto switching to active connection feature

ACTVST:	JUMPE NOA,[ SETZM ACTVSW
		    POPJ P, ]
	HRROI A,[ASCIZ /after /]
	PUSHJ P,.PSOUT
	MOVEI B,2
	MOVE A,TERM
tenex,<
	CAIN A,37
>
tops20,<
	CAIN A,15
>
	 JRST [ MOVEI A,101	; if crlf, use default value
		MOVEI C,12
		PUSHJ P,.NOUT
		 JFCL
		MOVEI A,40
		PUSHJ P,.PBOUT
		MOVE A,B
		JRST ACTVS2 ]
ACTVS1:	MOVE TAB,DCMTB
	PUSHJ P,SYMVAL		; else get time limit in min.
	SKIPG A			; only positive times...
	 JRST [ HRROI A,[ASCIZ / ? /]
		PUSHJ P,.PSOUT
		JRST ACTVS1 ]
ACTVS2:	IMULI A,^D60000
	MOVEM A,ACTVTM
	SETOM ACTVSW
	MOVE B,A
	HRROI A,[ASCIZ /minutes./]
	CAIN B,^D60000
	 HRROI A,[ASCIZ /minute./]
	PUSHJ P,.PSOUT
	POPJ P,


; Wait for a connection wanting to print

WATRET:	MOVSI X,-NCONN
WATREL:	SKIPN A,SNDJFN(X)
	 JRST WATREX
	SKIPG SAVINC(X)
	 JRST WATREX
	HRROI A,[ASCIZ /
connection /]
	PUSHJ P,.PSOUT
	HRRZ A,X
	IMULI A,3
	HRROI A,CONNAM(A)
	PUSHJ P,.PSOUT
	HRROI A,[ASCIZ / ready. /]
	PUSHJ P,.PSOUT
	HRRZ A,X
	JRST RETCO1

WATREX:	AOBJN X,WATREL
	MOVEI A,^D10000
	DISMS
	JRST WATRET

; Retrieve connection

RETCON:	SKIPL TAB,CONTAB
	 JRST [	HRROI A,[ASCIZ /
No connections.
/]
		PUSHJ P,.PSOUT
		POPJ P,]
	PUSHJ P,SYMVAL
RETCO1:	MOVEM A,CNX
	TRO F,REMOTF
	POPJ P,

; List connections

LSTCON:	TRZ F,TMPF
	MOVE X,CONTAB
	JUMPGE X,LSTCOX
LSTCOL:	HRROI A,[ASCIZ /
-Name-  -From-  --To--

/]
	TRON F,TMPF
	PUSHJ P,.PSOUT
	SETZ C,
	MOVE A,(X)
	PUSHJ P,.PSOUT
	MOVE B,1(A)
	MOVEI A,11
	PUSHJ P,.PBOUT
	HRRZ B,SNDJFN(B)
	MOVEI A,101
	MOVE C,[BYTE (3)0,0,1,1,0,0,0(5)0,0,2]
	JFNS
	SKIPE A,SCRJFN
	 JFNS
	PUSHJ P,SCRUPD
tenex,< MOVEI A,37 >
tops20,<MOVEI A,15>
	PUSHJ P,.PBOUT
LSTCOX:	AOBJN X,LSTCOL
	HRROI A,[ASCIZ /
No saved connections./]
	TRZN F,TMPF
	PUSHJ P,.PSOUT
	POPJ P,

; Exec

.EXEC:	
tenex,<
	HRROI B,[ASCIZ /<SYSTEM>EXEC.SAV/]
>
tops20,<
	HRROI B,[ASCIZ/SYSTEM:EXEC.EXE/]
>
	MOVSI C,(1B0)		; cause interrupts to go off
	MOVSI A,100001
	JRST SBGET

; Run

.RUN:	MOVSI A,100003
	MOVE B,[XWD 100,101]
	SETZ C,

SBGET:	PUSH P,B
	PUSHJ P,GTJFN0
	 JRST [	POP P,A
		TLNN A,-1
		PUSHJ P,.PSOUT
		ERROR [ASCIZ / not available./]]
	SUB P,[XWD 1,1]
	MOVEI A,400000
	DIR
	MOVSI A,(1B1!1B3)
	MOVEI B,FAC
	CFORK
	 JRST [	HRROI A,[ASCIZ /No forks available./]
		JRST GETF]
	MOVEM A,SPCFRK
	HRLZ A,SPCFRK
	HRR A,IJFN
	GET
	SETZM IJFN
	MOVEI A,400000
	EIR
	JUMPGE C,SBGET4
	DIR
	MOVE A,ESCCOD
	DTI
	MOVE A,CBFCOD
	DTI

SBGET4:	PUSH P,C
	MOVEI A,100
	MOVE B,TTCOC0
	MOVE C,TTCOC1
	SFCOC
	MOVE B,TTMOD0
	SFMOD
	HRRZ B,0(P)
	MOVE A,SPCFRK
	SFRKV
	WFORK
	MOVEI A,400000
	DIR
	MOVE A,SPCFRK
	KFORK
	SETZM SPCFRK
	POP P,C
	JUMPGE C,SBGET5
	MOVEI A,ESCCHN
	HRL A,ESCCOD
	ATI
	MOVEI A,CBFCHN
	HRL A,CBFCOD
	ATI
SBGET5:	MOVEI A,400000
	EIR
	POPJ P,

GETF:	PUSH P,A
	MOVEI A,400000
	EIR
	SKIPE A,IJFN
	 PUSHJ P,CLRJFN
	SETZM IJFN
	POP P,A
	PUSHJ P,.PSOUT
	POPJ P,

; Set escape character

tops20,<
SETSCH:	PUSHJ P,SETICH
	 HLDCHR
	 HLDCOD
	 HLDCHN
	POPJ P,
>

SETESC:	PUSHJ P,SETICH
	 ESCAPE
	 ESCCOD
	 ESCCHN
	POPJ P,

SETCBF:	PUSHJ P,SETICH
	 CBFCHR
	 CBFCOD
	 CBFCHN
	POPJ P,

SETICH:	MOVE X,0(P)
	ADDI X,3
	EXCH X,0(P)
	SETZ A,
	JUMPGE NOA,SETIC2
SETIC1:	PUSHJ P,.PBIN
	CAIN A,"?"
	 JRST PRESC
	PUSH P,A
	PUSHJ P,CVINTC
	 JRST SETED
SETIC2:	PUSH P,A
	MOVEI A,400000
	DIR
	POP P,A
	MOVE B,0(P)
	MOVEM B,@0(X)
	EXCH A,@1(X)
	DTI
	JUMPGE NOA,SETIC3
	HRLZ A,@1(X)
	HRRI A,@2(X)
	ATI
	MOVE A,0(P)
	CAIL A,40
	 JRST SETE1
	MOVEI A,"^"
	PUSHJ P,ECHOIT
	MOVEI A,100
	ADDM A,0(P)
SETE1:	POP P,A
	PUSHJ P,ECHOIT
SETIC3:	MOVEI A,400000
	EIR
	POPJ P,


SETED:	POP P,A
	MOVEI A,7
	PUSHJ P,.PBOUT
	JRST SETIC1

PRESC:	PUSHJ P,ECHOIT		; echo the "?"
	HRROI A,[ASCIZ /
control-@ through control-z
altmode
rubout
space
/]
	PUSHJ P,.PSOUT
	MOVE A,LPTR
	PUSHJ P,.PSOUT
	JRST SETIC1

; Set terminal modes

SETTRM:	MOVE TAB,TRMTAB
	JRST SYMVAL


; Set synch character

SETSNC:	SETOM SYNC
	JUMPGE NOA,SETIWK
	PUSHJ P,.PBIN
	PUSHJ P,ECHOIT
	MOVEM A,SYNC
	JRST SETIWK


; Set single charcter quote prefix

SETQOT:	SETOM QUOT
	JUMPGE NOA,SETIWK
	PUSHJ P,.PBIN
	PUSHJ P,ECHOIT
	MOVEM A,QUOT
	JRST SETIWK

; Set unshift prefix

SETUNS:	SETOM UNSFT
	JUMPGE NOA,SETIWK
	PUSHJ P,.PBIN
	PUSHJ P,ECHOIT
	MOVEM A,UNSFT
	JRST SETIWK

; Set case shift prefixes

SETSHF:	PUSH P,NOA		; Save noa
	MOVE TAB,SFTB
	PUSHJ P,SYMVAL
	POP P,NOA
	SETOM (A)		; Turn off prefix
	JUMPGE NOA,SETIWK	; Done if "no"
	PUSH P,A
	PUSHJ P,.PBIN
	PUSHJ P,ECHOIT
	MOVEM A,@(P)
	SUB P,[XWD 1,1]
SETIWK:	PUSH P,C		; create new special char.
	PUSH P,B		;  wakeup mask
	SETZ A,
	MOVSI C,-NSPECH
	ADD C,[XWD 1,1]		; omitting escape & clrobf
SETIW1:	HLRZ B,CSTAB(C)
	SKIPGE B,(B)		; lookup each spec. char.
	 JRST SETIW2
	HLRZ B,RCTGTB(B)	; OR in wakeup memshp if it exists
	IOR A,B
SETIW2:	AOBJN C,SETIW1
	MOVEM A,SPECWK		; store in specwk
	POP P,B
	POP P,C
	POPJ P,

; Echo.mode.is

.ECHO:	MOVE TAB,ECTAB
	JRST SYMVAL

CHGECH:	HRROI A,[ASCIZ /A half-duplex terminal (which I believe you have) will not work well
with remote echoing./]
	SKIPE HDX
	SKIPE ELCLF(CNX)
	CAIA
	 PUSHJ P,.PSOUT
	POPJ P,			;  DONT ECHO

; Terminal has lower case

SETLWR:	MOVEM NOA,TRMLWC
	MOVSI B,(1B3)
	JUMPGE NOA,SETLW1
	IORM B,TTMODR
	IORB B,TTMODC
	JRST SETLW2

SETLW1:	ANDCAM B,TTMODR
	ANDCAB B,TTMODC
SETLW2:	MOVEI A,101
	STPAR
	POPJ P,

SNDSNC:	SKIPN A,SNDJFN(CNX)	; Send "sync"
	 POPJ P,		; Connection not ok
	MOVEI B,22		; First send interrupt
	SETZB C,D
	MTOPR
	MOVEI B,3		; Then send mark type DM
	MOVEI C,1
	MTOPR
	POPJ P,

; Set control character echoing

SETCOC:	PUSHJ P,GCH
	CAIN A,"?"
	 JRST SETCOQ
	PUSHJ P,ECHOIT
SETCO2:	CAIN A,37
	MOVEI A,15
	MOVEM A,TERM
	PUSHJ P,.PBIN
	PUSHJ P,ECHOIT
	EXCH A,TERM
	ANDI A,37
	MOVSI B,400000
	MOVNS A
	ROT B,(A)
	SKIPN NOA
	ANDCAM B,ECHCOC(CNX)
	SKIPE NOA
	IORM B,ECHCOC(CNX)
	MOVE A,TERM
tenex,< CAIE A,37 >
tops20,<CAIE A,15>
	 JRST [	CAIE A,40
		CAIN A,","
		 JRST SETCOC
		JRST SETCO2]
	POPJ P,

SETCOQ:	HRROI A,[ASCIZ /
control characters or letter equivalents
/]
	PUSHJ P,.PSOUT
	MOVE A,LPTR
	PUSHJ P,.PSOUT
	JRST SETCOC

SETCOE:	MOVEI A,7
	PUSHJ P,.PBOUT
	JRST SETCOC

; Print current modes

PRCMD:	MOVSI X,-NPMDTB
PRCMD1:	
tenex,<	MOVEI A,37 >
tops20,<MOVEI A,15>
	PUSHJ P,.PBOUT
	MOVSI C,CNX
	HLR C,PCMDTB(X)
	HRROI A,[ASCIZ /no /]
	SKIPN @C
	PUSHJ P,.PSOUT
	HRRO A,PCMDTB(X)
	PUSHJ P,.PSOUT
	AOBJN X,PRCMD1
	HRROI A,[ASCIZ /
Special characters:
/]
	PUSHJ P,.PSOUT
	MOVSI X,-NSPECH
PCSLP:	HLRZ B,CSTAB(X)
	SKIPG (B)
	 JRST PCSLPN
	HRRO A,CSTAB(X)
	PUSHJ P,.PSOUT
	MOVEI A,11
	PUSHJ P,.PBOUT
	MOVE A,(B)
	PUSHJ P,.PBOUT
PCSLPE:	
tenex,<	MOVEI A,37 >
tops20,<MOVEI A,15>
	PUSHJ P,.PBOUT
PCSLPN:	AOBJN X,PCSLP
	SKIPE D,ECHCOC(CNX)
	SKIPN ELCLF(CNX)
	 POPJ P,		; Done if not local echo or no coc
	HRROI A,[ASCIZ /
Local echo for control /]
	PUSHJ P,.PSOUT
PRCM2:	JFFO D,.+1
	MOVSI B,400000
	MOVN C,D+1
	ROT B,(C)
	ANDCAM B,D
	JUMPN D,PRCM1
	HRROI A,[ASCIZ /and /]
	CAME B,ECHCOC(CNX)
	PUSHJ P,.PSOUT
PRCM1:	MOVEI A,100(D+1)
	PUSHJ P,.PBOUT
	JUMPE D,CPOPJ
	HRROI A,[ASCIZ /, /]
	PUSHJ P,.PSOUT
	JRST PRCM2

PCMDTB:	XWD RAISEF,[ASCIZ /Raise/]
	XWD LOWERF,[ASCIZ /Lower/]
	XWD ELCLF,[ASCIZ /Local echo/]
	XWD LFCRF,[ASCIZ /Echo linefeed for carriage return/]
	XWD LNBFF,[ASCIZ /Line buffer/]
NPMDTB==.-PCMDTB

CSTAB:	XWD CBFCHR,[ASCIZ /Clrobf: /]
	XWD ESCAPE,[ASCIZ /Escape: /]
	XWD QUOT,[ASCIZ /Quote:  /]
	XWD UNSFT,[ASCIZ /Unshift:/]
	XWD LCASC,[ASCIZ /Char.lower:/]
	XWD LCASL,[ASCIZ /Lock.lower:/]
	XWD UCASC,[ASCIZ /Char.upper:/]
	XWD UCASL,[ASCIZ /Lock.upper:/]
	XWD SYNC,[ASCIZ /Synch:  /]

NSPECH==.-CSTAB




; Help

.HELP:	HRROI A,[ASCIZ /
The describe command is the efficient way to get specific questions
answered; type "describe describe" to see how./]
	PUSHJ P,.PSOUT
	HRROI A,[ASCIZ /
You may also wish to list the file <DOC>CHAT.HELP on
the LPT: for future reference./]
	PUSHJ P,.PSOUT
	HRROI A,[ASCIZ /
Or you may continue with "help" to get the help file typed out in
pieces.  Continue?  /]
	PUSHJ P,.PSOUT
	PUSHJ P,OPNHLP		; open help file
	 POPJ P,		;   can't
	JRST TYPAL


TYPLP:	MOVEI X,^D20
TYPLP1:	MOVE A,IJFN
	MOVE B,[POINT 7,COMBUF]
	MOVEI C,200*5-3
	MOVEI D,12
	SIN
	GTSTS
	TLNE B,1000
	 JRST ETYPL
	MOVEI A,101
	MOVE B,[POINT 7,COMBUF]
	MOVEI C,200*5-3
	MOVEI D,12
	PUSHJ P,.SOUT
	SOJG X,TYPLP1
	CAIGE C,200*5-3-2
	 JRST TYPLP1
	HRROI A,[ASCIZ /
More help? /]
	PUSHJ P,.PSOUT
TYPAL:	PUSHJ P,.PBIN
	CAIE A,"Y"
	CAIN A,"Y"+40
	 JRST TYPMO
	CAIE A,"N"
	CAIN A,"N"+40
	 JRST TYPNO
	MOVEI A,7
	PUSHJ P,.PBOUT
	JRST TYPAL

TYPMO:	HRROI A,[ASCIZ /Yes
/]
	PUSHJ P,.PSOUT
	JRST TYPLP

TYPNO:	HRROI A,[ASCIZ /No
/]
	PUSHJ P,.PSOUT
	JRST ETYPX

ETYPL:	SUBI C,200*5-3
	SOUT
ETYPX:	MOVE A,IJFN
	PUSHJ P,CLRJFN
	SETZM IJFN
	POPJ P,


; describe
.DSCRB:	MOVE TAB,DSCRTB
	PUSHJ P,SYMVAL		; get identifier, str ptr in bptr
	PUSHJ P,OPNHLP		; now open help file
	 POPJ P,
	SETZB B,X		; overlay null to separator in input
	DPB B,PTR
DSCRB1:	PUSHJ P,RDHLRB		; read help file up to next rubout
	PUSHJ P,RDHLP		; read following string
	MOVE D,BPTR
	MOVE Y,[POINT 7,HLPBUF]	; now compare string from file
	MOVE A,HLPBUF		; to "[no] ", scan off if present,
	CAMN A,[ASCII /[no] /]
	 ADDI Y,1		; then compare input identifier string
DSCRB2:	ILDB A,D		; to present string from file
	ILDB B,Y
	PUSHJ P,SYMCMP
	 JRST [ JUMPE A,DSCRB3	; unequal: substring match if input
		JRST DSCRB1 ]	; ends first; else get next record
	JUMPN A,DSCRB2		; exact match if null, else keep cmprng
DSCRB3:	
tenex,<	MOVEI A,37 >		; file rec matches input identifier
tops20,<MOVEI A,15>
	PUSHJ P,.PBOUT		; type initial <cr>
	PUSHJ P,.PBOUT
DSCRB4:	MOVEI A,101
	MOVE B,[POINT 7,HLPBUF]
	MOVEI C,200*5-3
	MOVEI D,177		; type out text
	PUSHJ P,.SOUT
	LDB A,B
	CAIN A,177		; did output end on a rubout marker?
	 JRST ETYPX		;  yes, done, close file & exit
	PUSHJ P,RDHLP		; no, read another buffer load
	JRST DSCRB4

RDHLRB:	JUMPE X,RDHLRR		; read file up to rubout marker
RDHLRC:	LDB A,X			; if str ptr in b, check if already
	CAIN A,177		;  at a rubout
	 POPJ P,		;   yes, exit
RDHLRR:	PUSHJ P,RDHLP		; no rubout, read another record
	JRST RDHLRC

RDHLP:	MOVE A,IJFN		; read help file into buffer
	GTSTS
	TLNE B,1000		; failure if file already at eof
	 ERROR [ASCIZ /help item not found./]
	MOVE B,[POINT 7,HLPBUF]	; (should never happen)
	MOVEI C,200*5-3
	MOVEI D,177		; read full buffer or up to rubout
	SIN
	MOVE X,B		; save updated pointer
	GTSTS
	TLNN B,1000
	 POPJ P,
	MOVEI A,177
	IDPB A,X		; if eof, smash rubout into buf
	POPJ P,


OPNHLP:	MOVEI A,400000		; get and open help file
	DIR
tenex,<
	HRROI B,[ASCIZ /<DOC>CHAT.HELP/]
>
tops20,<
	HRROI B,[ASCIZ/DOC:CHAT.HELP/]
>
	MOVSI A,100001
	GTJFN
	 JRST [	MOVEI A,400000
		EIR
		HRROI A,[ASCIZ /Help file not found./]
		PUSHJ P,.PSOUT
		POPJ P,]
	MOVEM A,IJFN
	MOVEI A,400000
	EIR
	MOVE A,IJFN
	MOVE B,[XWD 70000,200000]
	OPENF
	 JRST [	MOVE A,IJFN
		PUSHJ P,CLRJFN
		SETZM IJFN
		HRROI A,[ASCIZ /Help file can't be opened./]
		PUSHJ P,.PSOUT
		POPJ P,]
	JRST SKPRET		; 2nd return if success


; Typescript to a file

SETSCR:	PUSHJ P,UGTAD
	MOVEM B,SCRTIM		; Time of last typescript entry
	SETZM SCRCNT		; Characters output since last openf
	MOVEI A,400000
	DIR
	SETZ A,
	EXCH A,SCRJFN
	SKIPLE A
	 PUSHJ P,CLRJFN
	MOVEI A,400000
	EIR
	SKIPL NOA		; file flushed, done if "no"
	 POPJ P,
	PUSHJ P,.PBIN		; wait for input
	CAIE A,33
tenex,<
	CAIN A,37		; get default typscr file if CR or ESC
>
tops20,<CAIN A,15>
	 JRST [ MOVEI A,400000
		DIR
		GJINF
		MOVE B,A
		HRROI A,LGDRST	; always open file in login directory
		DIRST
		 JFCL		; (can't fail)
		MOVEI A,[ 1B0
			XWD 377777,377777
			0
			POINT 7,LGDRST
			REPEAT 5,<0> ]
		HRROI B,[ASCIZ /CHAT.TYPESCRIPT;T;P770000/]
		GTJFN
		 JRST [	MOVEI A,400000
			EIR
			POPJ P,]
		PUSH P,A
		MOVE B,[XWD 70000,20000]
		OPENF
		 JRST [	POP P,A
			RLJFN
			 JFCL
			MOVEI A,400000
			EIR
			POPJ P,]


		HRROI B,[ASCIZ /
CHAT typescript file started at /]
		SETZ C,
		SOUT
		SETO B,
		MOVE C,[1B1+1B7+1B12+1B17]
		ODTIM
		MOVEI B,15
		BOUT
		MOVEI B,12
		BOUT
		POP P,SCRJFN
		MOVEI A,400000
		EIR
		POPJ P,]
	SKIPN HDX
	 PBOUT			; echo first char typed...
	MOVEI A,100		; if non-terminator typed, back up
	BKJFN			;  and get user-named file
	 0
	MOVEI A,[XWD 460000,0
		XWD 100,101
		REPEAT 4,<0>
		XWD 500000,770000
		REPEAT 2,<0>]
	SETZ B,
	PUSHJ P,GTJFN0		; get any file name, but with self-only
	 ERROR [ASCIZ /File not available./]
	MOVE B,[XWD 70000,100000]
	OPENF
	 JRST [	MOVE A,IJFN
		PUSHJ P,CLRJFN
		SETZM IJFN
		ERROR [ASCIZ /Cannot open file./]]
	MOVEI A,400000
	DIR
	MOVEI B,0
	EXCH B,IJFN
	MOVEM B,SCRJFN
	EIR
	POPJ P,

; Get uniform time in secs

UGTAD:	GTAD
	HRRZS B,A
	HLRZS A
	IMULI A,^D24*^D60*^D60
	ADDB A,B
	POPJ P,


; Update script file

SCRUPD:	SKIPN SCRJFN
	 POPJ P,
	PUSH P,A
	PUSH P,B
	SKIPGE SCRTIM
	 JRST SCRUP0		; Forced update
	PUSHJ P,UGTAD
	SUB B,SCRTIM		; Ho long since last update?
	CAIG B,^D30
	 JRST SCRUPX		; Never less than 30 secs
	CAIL B,^D300
	 JRST SCRUP0		; Always every 5 min
	MOVE A,SCRJFN
	RFPTR
	 SETZ B,
	SUB B,SCRCNT
	CAIG B,^D1000
	 JRST SCRUPX		; Then not fewer thant 1000 chars
SCRUP0:	PUSHJ P,UGTAD
	MOVEM B,SCRTIM
	MOVE A,SCRJFN
	RFPTR
	 SETZ B,
	MOVEM B,SCRCNT
	HRLI A,400000
	CLOSF
	 JFCL
	HRRZS A
	MOVE B,[XWD 70000,20000]
	OPENF
	 0
SCRUPX:	POP P,B
	POP P,A
	POPJ P,


; Connection's output to a file as it arrives

SETLGF:	PUSHJ P,UGTAD
	MOVEM B,LGFTIM(CNX)	; Time of last logging entry
	SETZM LGFCNT(CNX)	; Characters output since last openf
	MOVEI A,400000
	DIR
	SETZ A,
	EXCH A,LGFJFN(CNX)
	SKIPLE A
	 PUSHJ P,CLRJFN
	MOVEI A,400000
	EIR
	SKIPL NOA		; file flushed, done if "no"
	 POPJ P,
	MOVEI A,[XWD 460000,0
		XWD 100,101
		REPEAT 4,<0>
		XWD 500000,770000
		REPEAT 2,<0>]
	SETZ B,
	PUSHJ P,GTJFN0		; get any file name, but with self-only
	 ERROR [ASCIZ /File not available./]
	MOVE B,[XWD 70000,100000]
	OPENF
	 JRST [	MOVE A,IJFN
		PUSHJ P,CLRJFN
		SETZM IJFN
		ERROR [ASCIZ /Cannot open file./]]
	MOVEI A,400000
	DIR
	MOVEI B,0
	EXCH B,IJFN
	MOVEM B,LGFJFN(CNX)
	MOVE A,LGFJFN(CNX)
	HRROI B,[ASCIZ /
CHAT logging file started at /]
	SETZ C,
	SOUT
	SETO B,
	MOVE C,[1B1+1B7+1B12+1B17]
	ODTIM
	SKIPN SNDJFN(CNX)	; Is there a connection?
	 JRST LGNJFN		; No, don't try to print its name
	HRROI B,[ASCIZ /
   on connection /]
	SETZ C,
	SOUT
	MOVE B,CNX
	IMULI B,3
	ADDI B,CONNAM
	HRROS B
	SOUT
	HRROI B,[ASCIZ / from /]
	SOUT
	HRRZ B,SNDJFN(CNX)
	MOVE D,B


	MOVSI C,(<BYTE (3)0,0,1>)
	JFNS
	HRROI B,[ASCIZ / to /]
	SETZ C,
	SOUT
	MOVE B,D
	MOVSI C,(<BYTE(3)0,0,0,1>)
	JFNS
LGNJFN:	MOVEI B,15
	BOUT
	MOVEI B,12
	BOUT
	MOVEI A,400000
	EIR
	POPJ P,

; Update logging file

LGFUPD:	SKIPN LGFJFN(CNX)
	 POPJ P,
	PUSH P,A
	PUSH P,B
	SKIPGE LGFTIM(CNX)
	 JRST LGFUP0		; Forced update
	PUSHJ P,UGTAD
	SUB B,LGFTIM(CNX)	; How long since last update?
	CAIG B,^D60
	 JRST LGFUPX		; Never less than 60 secs
	CAIL B,^D300
	 JRST LGFUP0		; Always every 5 min
	MOVE A,LGFJFN(CNX)
	RFPTR
	 SETZ B,
	SUB B,LGFCNT(CNX)
	CAIG B,^D10
	 JRST LGFUPX		; Then not fewer thant 10 chars
LGFUP0:	PUSHJ P,UGTAD
	MOVEM B,LGFTIM(CNX)
	MOVE A,LGFJFN(CNX)
	RFPTR
	 SETZ B,
	MOVEM B,LGFCNT(CNX)
	HRLI A,400000
	CLOSF
	 JFCL
	HRRZS A
	MOVE B,[XWD 70000,20000]
	OPENF
	 0
LGFUPX:	POP P,B
	POP P,A
	POPJ P,


; Divert output  to a file

SETDIV:	MOVEI A,400000
	DIR
	MOVEI A,0
	EXCH A,DIVJFN
	SKIPLE A
	 PUSHJ P,CLRJFN
	MOVEI A,400000
	EIR
	JUMPGE NOA,CPOPJ
	MOVSI A,460003
	PUSHJ P,.GTJFN
	 ERROR [ASCIZ /File not found./]
	MOVE B,[XWD 70000,100000]
	OPENF
	 JRST [	MOVE A,IJFN
		PUSHJ P,CLRJFN
		SETZM IJFN
		ERROR [ASCIZ /Cannot open./]]
	MOVEI A,400000
	DIR
	MOVEI B,0
	EXCH B,IJFN
	MOVEM B,DIVJFN
	EIR
	POPJ P,


; Take input from a file (remote mode)

SETALT:	MOVEI A,400000
	DIR
	MOVEI A,0
	EXCH A,ALTJFN(CNX)
	SKIPLE A
	 PUSHJ P,CLRJFN
	MOVEI A,400000
	EIR
	JUMPGE NOA,CPOPJ
	MOVSI A,160003
	PUSHJ P,.GTJFN
	 ERROR [ASCIZ /File not found./]
	MOVE B,[XWD 1,11]
	MOVEI C,C
	GTFDB
	LDB B,[POINT 6,C,11]
	CAIE B,7
	 ERROR [ASCIZ /Not an ASCII file./]
	SIZEF
	 ERROR [ASCIZ /File not found./]
	MOVEM B,ALTJCT(CNX)
	MOVE B,[XWD 70000,200000]
	OPENF
	 JRST [ MOVE A,IJFN
		PUSHJ P,CLRJFN
		SETZM IJFN
		ERROR [ASCIZ /Cannot open./]]
	MOVEI A,400000
	DIR
	MOVEI B,0
	EXCH B,IJFN
	MOVEM B,ALTJFN(CNX)
	EIR
	POPJ P,

; Print where we are

.WHERE:	
tenex,<	MOVEI A,37 >
tops20,<MOVEI A,15>
	PUSHJ P,.PBOUT
	SKIPN A,SNDJFN(CNX)
	 JRST NOCC
	HRROI A,[ASCIZ /Connection /]
	PUSHJ P,.PSOUT
	MOVE A,CNX
	IMULI A,3
	ADDI A,CONNAM
	HRROS A
	PUSHJ P,.PSOUT
	HRROI A,[ASCIZ / from /]
	PUSHJ P,.PSOUT
	HRRZ B,SNDJFN(CNX)
	MOVEI A,101
	MOVSI C,(<BYTE (3)0,0,1>)
	JFNS
	SKIPE A,SCRJFN
	JFNS
	HRROI A,[ASCIZ / to /]
	PUSHJ P,.PSOUT
	HRRZ B,SNDJFN(CNX)
	MOVEI A,101
	MOVSI 3,(<BYTE (3)0,0,0,1>)
	JFNS
	SKIPE A,SCRJFN
	JFNS
tenex,<	MOVEI A,37 >
tops20,<MOVEI A,15>
	PUSHJ P,.PBOUT
NOCC:	MOVE A,[SIXBIT /SYSVER/]
	SYSGT
	MOVE D,P
	HRRZ C,B
	HLLZS B

.WHRL:	MOVE A,C
	HRL A,B
	GETAB
	 JFCL
	PUSH P,A
	AOBJN B,.WHRL
	PUSH P,[0]
	HRROI A,1(D)
	PUSHJ P,.PSOUT
	MOVE P,D
	HRROI A,[ASCIZ /
Job /]
	PUSHJ P,.PSOUT
	GJINF
	PUSH P,1
	MOVEI A,101
	MOVE B,C
	MOVEI C,12
	PUSHJ P,.NOUT
	 JFCL
	HRROI A,[ASCIZ /, terminal /]
	PUSHJ P,.PSOUT
	MOVE B,D
	MOVEI C,10
	MOVEI A,101
	PUSHJ P,.NOUT
	 JFCL
	HRROI A,[ASCIZ /, user /]
	PUSHJ P,.PSOUT
	POP P,B
	MOVEI A,101
	DIRST
	 JFCL
	SKIPLE A,SCRJFN
	 DIRST
	 JFCL
	HRROI A,[ASCIZ /
CHAT version /]
	PUSHJ P,.PSOUT
	HRROI A,VERNUM
	PUSHJ P,.PSOUT
	POPJ P,


; Reset

.RESET:	JRST RSTART

; Logout

.LGOUT:	HRROI A,[ASCIZ / [Confirm] /]
	PUSHJ P,.PSOUT
	PUSHJ P,.PBIN
tenex,<
	CAIE A,37
>
tops20,<
	CAIE A,15
>
	POPJ P,
	PUSHJ P,.PBOUT
	MOVNI 1,1
	LGOUT
	HALTF

; Quit, exit back to exec

.QUIT:	SETOM SCRTIM
	PUSHJ P,SCRUPD		; Update script before leaving
	MOVSI CNX,-NCONN
QUITA:	SETOM LGFTIM(CNX)
	PUSHJ P,LGFUPD
	AOBJN CNX,QUITA
	MOVEI A,400000
	DIR
	HALTF
	MOVEI A,-4
	FFORK
	MOVE CNX,FSVCNX
	MOVEI A,400000
	EIR
	POPJ P,


; Send code and control

SNDDCD:	IBP BPTR		; Send decimal # as code
	PUSHJ P,CVDEC
	JRST SNDC

SNDOCD:	IBP BPTR		; Send octal # as code
SNDOCT:	PUSHJ P,CVOCT
	JRST SNDC

SNDHCD:	IBP BPTR		; Send hex # as code
	SETZ A,
SNDHCL:	ILDB B,BPTR
	JUMPE B,SNDC
	CAIL B,"A"
	ADDI B,11
	ANDI B,17
	ASH A,4
	ADD A,B
	JRST SNDHCL

SNDCTL:	MOVE TAB,LTRTB		; Send control char.
	PUSHJ P,SYMVAL
	ANDI A,37
	JRST SNDC

SNDCD1:	PUSHJ P,CVOCT
SNDC:	MOVE B,A
	SKIPN SNDJFN(CNX)
	 POPJ P,
	PUSHJ P,SNDCH		; Send and push out byte
	PUSHJ P,TRNSMT
	POPJ P,

; Set remote mode

SETREM:	SKIPE A,SNDJFN(CNX)
	TRO F,REMOTF
	POPJ P,


DOCOMT:	PUSHJ P,GCH
	PUSHJ P,ECHOIT
tenex,<
	CAIE A,37
>
tops20,<
	CAIE A,15
>	
	JRST DOCOMT
	POPJ P,

CVOCT:	SKIPA C,[10]
CVDEC:	MOVEI C,^D10
	MOVE A,BPTR
	NIN
	 SETZ B,
	MOVE A,B
	POPJ P,

SEND:	CIS
	MOVEM CNX,FSVCNX	; save CNX for later restoration
	MOVE P,[XWD -100,SPDL-1]
	MOVE PTR,[POINT 7,LINBUF-1,34]

; Send terminal parameters first
	MOVEI A,101
	SKIPN B,REALTT		; Really a scope?
	 GTTYP			; No, get actual type
	MOVEI A,4		; Send terminal type
	PUSHJ P,SNTPAR
	MOVEI A,101
	RFMOD
	LDB C,[POINT 7,B,10]	; Save length
	PUSH P,C
	LDB B,[POINT 7,B,17]	; Get width
	MOVEI A,2		; Send line width
	PUSHJ P,SNTPAR
	POP P,B
	MOVEI A,3		; Send line length
	PUSHJ P,SNTPAR


SEND0:	PUSHJ P,.PBIN
tops20,<
	SKIPE HOLDF(CNX)
	 SETZM SAVSWT(CNX)
>
	SKIPE ACTVSW		; account time
	 PUSHJ P,SNDTIM
ifn ft10x&ft20,<
	ANDI A,177
>
	SKIPE XPARNT(CNX)	; Completely transparent?
	 JRST [	MOVE B,A	; Yes
		PUSHJ P,SNDCH
		PUSHJ P,TRNSMT
		JRST SEND0]
ifn ft10x!ft20,<
	ANDI A,177		; 7-bits only when not xparent (sumex)
>
	AOSN QUOTF
	 JRST SEND02		; Not special (may be shifted though)
	CAMN A,QUOT		; Quote character
	 JRST [	SETOM QUOTF	; Yes, remember
		JRST SEND0]
	CAMN A,SYNC		; Synch substitute
	 JRST [	PUSHJ P,SNDSNC	; Yes, send sync seq
		JRST SEND0]
	CAMN A,UNSFT		; Now for the shifts...unshift?
	 JRST [	SETZM RAISEF(CNX)
		SETZM LOWERF(CNX)
		SETZM UCASCF
		SETZM LCASCF	; clear all shift flags
		JRST SEND0]
	CAME A,LCASC
	CAMN A,UCASC
	 JRST SETCAS
	CAME A,LCASL
	CAMN A,UCASL
	 JRST SETCAS
SEND02:	CAIG A,136		; Regular character...needs shift?
	CAIGE A,100
	 JRST SEND1		; Not upper case
	AOSE UCASCF		; Upper case.  if no upper case shift
	 PUSHJ P,SFTDWN		; Then see if down shift wanted
	JRST SEND3


SEND1:	CAIG A,176
	CAIGE A,140
	 JRST SEND3		; Not lower case either
	AOSE LCASCF		; Lower case.  if no down shift
	 PUSHJ P,SFTUP		; Then shift up if wanted
	JRST SEND3

SETCAS:	SETZM LCASCF		; Clear character shifts
	SETZM UCASCF
	CAMN A,LCASC		; If lower case char prefix
	 JRST [	SETOM LCASCF	; Remember
		JRST SEND0]
	CAMN A,UCASC		; If upper case char prefix
	 JRST [	SETOM UCASCF	; Remember
		JRST SEND0]
	SETZM LOWERF(CNX)	; Clear shift locks
	SETZM RAISEF(CNX)
	CAMN A,LCASL
	 JRST [	SETOM LOWERF(CNX)
		JRST SEND0]
	CAMN A,UCASL
	 JRST [	SETOM RAISEF(CNX)
		JRST SEND0]

SEND3:	SKIPN LNBFF(CNX)	; If not line buffering
	 PUSHJ P,SNDBUF		; Send any stuff already buffered
tenex,<
	CAIN A,37
	 MOVEI A,15
>
REPEAT 0,<
	 JRST [	HRROI A,15
		PUSHJ P,SNDDO
		SETCM A,LFCRF(CNX)	; Get complement of switch
		HRRI A,12	; Line feed
		JRST .+1]
>
	PUSHJ P,SNDDO
	HRRZS A
	CAIE A,12
	CAIN A,33
	 PUSHJ P,SNDBUF
	JRST SEND0

SFTDWN:	AOSE LCASCF
	SKIPE LOWERF(CNX)
	 TRO A,140
	POPJ P,

SFTUP:	AOSE UCASCF
	SKIPE RAISEF(CNX)
	 TRZ A,40
	POPJ P,

SENDO:	SKIPA A,CBFCHR
SENDE:	MOVE A,ESCAPE
	JRST SEND3

SNDBUF:	CAMN PTR,[POINT 7,LINBUF-1,34]
	 POPJ P,
	PUSHJ P,TRMST
	MOVE PTR,[POINT 7,LINBUF-1,34]
	MOVE C,PTR
SNDBF1:	ILDB B,C		; YES, it's true, replace a SOUT with
	SKIPN B			; a tight loop including SNDCH!
	 JRST [ PUSHJ P,TRNSMT	; This make me soffer so...
		POPJ P, ]
	PUSHJ P,SNDCH
	JRST SNDBF1

SNDDO:	SKIPE LNBFF(CNX)
	 JRST SNDLBF
	MOVE B,A
	PUSHJ P,SNDCH		; Unbuffered: send char & push it out
	PUSHJ P,TRNSMT
	MOVE A,B
	JRST SNDECH


; Send character in B on send connection CNX
SNDCH:	HRRZ A,SNDJFN(CNX)
	BOUT
	POPJ P,

; Force transmission of buffered characters
TRNSMT:	HRRZ A,SNDJFN(CNX)
	MOVEI B,21
	MTOPR
	POPJ P,

; Send terminal parameter
; A/ mark type, B/ parameter value

SNTPAR:	PUSH P,B
	MOVE C,A
	MOVE A,SNDJFN(CNX)
	MOVEI B,3
	MTOPR
	POP P,B
	BOUT
	MOVEI B,21
	MTOPR
	POPJ P,

SNDECH:	JUMPL A,CPOPJ		; Never echo ch with -1 lh
	SKIPN HDX		; If hdx terminal
	SKIPN ELCLF(CNX)		; If not local echo
	 POPJ P,		; Then done
SNDEC1:	MOVE B,ECHCOC(CNX)
	ROT B,(A)		; Prepare to test coc
	CAIGE A,40		; If not control
	 JUMPGE B,CPOPJ
	PUSHJ P,PLOUT1
	PUSHJ P,.PEOUT		; Echo
	POPJ P,

SNDLBF:	CAIE A,"A"-100
	CAIN A,"H"-100
SNDLBD:	 JRST [	CAMN PTR,[POINT 7,LINBUF-1,34]
		 JRST [	MOVEI A,7
			PUSHJ P,.PBOUT
			POPJ P,]
		MOVEI A,"\"
		PUSHJ P,.PBOUT
		LDB A,PTR
		PUSHJ P,.PBOUT
		MOVE A,PTR
		BKJFN
		 0
		MOVEM A,PTR
		POPJ P,]
ifn sumex!ft20,<
	CAIN A,177
	 JRST SNDLBD
>
tenex,<
	CAIN A,"X"-100
>
tops20,<
	CAIN A,"U"-100
>
	 JRST [	MOVEI A,"#"
		PUSHJ P,.PBOUT
		PUSHJ P,.PBOUT
tenex,	      < MOVEI A,37 >
tops20,	       <MOVEI A,15>
		PUSHJ P,.PBOUT
		MOVE PTR,[POINT 7,LINBUF-1,34]
		POPJ P,]
	CAIN A,"R"-100
	 JRST [	
tenex,	      <	MOVEI A,37 >
tops20,	       <MOVEI A,15>
		PUSHJ P,.PBOUT
		PUSHJ P,TRMST
		MOVE A,[POINT 7,LINBUF-1,34]
		PUSHJ P,.PSOUT
		POPJ P,]
	IDPB A,PTR
	SKIPE ELCLF(CNX)
	 PUSHJ P,SNDECH
	POPJ P,

; input character class membership table
;  TENEX wakeup class in lh (10,4,2,1=>F,C,P,A)
;  RCTE break class in rh *** not used by CHAT ***

RCTGTB:	REPEAT 10,<XWD 4,20>	; ^@-^G (C,5)
	REPEAT 6,<XWD 10,10>	; ^H-^M (F,4)
	REPEAT 22,<XWD 4,20>	; ^N-^_ (C,5)
	XWD 2,400		; SPACE (P,9)
	XWD 2,40		; !	(P,6)
	REPEAT 6,<XWD 2,200>	; "#$%&' (P,8)
	REPEAT 2,<XWD 2,100>	; ()	(P,7)
	REPEAT 2,<XWD 2,200>	; *+	(P,8)
	XWD 2,40		; ,	(P,6)
	XWD 2,200		; -	(P,8)
	XWD 2,40		; .	(P,6)
	XWD 2,200		; /	(P,8)
	REPEAT 12,<XWD 1,4>	; 0-9	(A,3)
	REPEAT 2,<XWD 2,40>	; :;	(P,6)
	XWD 2,100		; <	(P,7)
	XWD 2,200		; =	(P,8)
	XWD 2,100		; >	(P,7)
	XWD 2,40		; ?	(P,6)
	XWD 2,200		; @	(P,8)
	REPEAT 32,<XWD 1,1>	; A-Z	(A,1)
	XWD 2,100		; [	(P,7)
	XWD 2,200		; \	(P,8)
	XWD 2,100		; ]	(P,7)
	REPEAT 3,<XWD 2,200>	; ^_`	(P,8)
	REPEAT 32,<XWD 1,2>	; a-z	(A,2)
	XWD 2,100		; {	(P,7)
	XWD 2,200		; |	(P,8)
	XWD 2,100		; }	(P,7)
	XWD 2,200		; ~	(P,8)
	XWD 4,20		; DEL	(C,5)

; routines to store time of last net i/o

SNDTIM:	PUSH P,A
	PUSH P,B		; send fork time accounting
	TIME
	MOVEM A,SNDATM(CNX)
	POP P,B
	POP P,A
	POPJ P,

RCVTIM:	PUSH P,A
	PUSH P,B		; receive fork time accounting
	TIME
	MOVEM A,RCVATM(CNX)
	POP P,B
	POP P,A
	POPJ P,


RECV:	CIS
	MOVEM CNX,FSVCNX
	HRRZ A,RECJFN(CNX)
	MOVEI B,24
	MOVSI C,017777
	MTOPR			; Ins interrupts on channel 1
	SETZM SYNCNT(CNX)	; clean INS count
	SETZM CBFCNT(CNX)
RECVY:	SETZM SAVINC(CNX)	; Loop to here to reset buffer
	MOVE A,[POINT 7,SAVBUF]
	MOVEM A,SAVINP(CNX)
	MOVEM A,SAVONP(CNX)
RECV0:	MOVE CNX,FSVCNX		; restore CNX in case fork restarted
	MOVE P,[XWD -100,SPDL-1]
	SKIPE SAVSWT(CNX)	; Saving output up?
	 JRST RECVR		; Yes, check if full and do it
	SKIPE SAVINC(CNX)	; No, any saved characters?
	 JRST RECVU		; Yes, unsave them
	JRST RECVB0		; No, get next input

RECVR:	MOVEI A,SAVBFS*5-5
	CAMG A,SAVINC(CNX)
RECVH:	 HALTF
RECVB0:	SETOM RCVBSW(CNX)	; Sw stays set until BIN for rstrtng
RECVB:	PUSHJ P,RCVCH
	SKIPE LGFJFN(CNX)
	 PUSHJ P,PLOUT2
	MOVE B,A
	SKIPE ACTVSW
	 PUSHJ P,RCVTIM		; account time
	SKIPE CBFCNT(CNX)
	 JRST RECVFT		; Flushing output or DM timing
RECVBA:	SKIPE SAVSWT(CNX)	; Saving up the output?
	 JRST RECVS		; Yes, go put it in buffer
RECV1:	AOSN CRNLSW		; was last char a <cr>?
	 JUMPE B,RECV0		;  yes, if this char is a null, flush it
	CAIN B,15		; is this char a <cr>?
	 SETOM CRNLSW		;  yes, set switch to screen <cr><nul>
RECV2:	SKIPE CLROBF
	 JRST RECVFL
	SKIPLE A,DIVJFN
	 JRST RECVX
	MOVE A,B
	PUSHJ P,.PEOUT
	JRST RECV0

RECVS:	PUSHJ P,RECVSV
	JRST RECV0


RECVU:	SKIPE CLROBF		; Clear output buffer?
	 JRST [	MOVE A,SAVINP(CNX)
		MOVEM A,SAVONP(CNX)
		SETZM SAVINC(CNX)
		LDB B,SAVONP(CNX)
		JRST RECVFL]
	MOVNI A,SAVBFS		; No
	ADD A,SAVONP(CNX)	; Wrapped pointer if needed
	CAMN A,[POINT 7,SAVBUF-1,34]
	 MOVEM A,SAVONP(CNX)	; Wrap pointer
	ILDB B,SAVONP(CNX)	; Get byte
	SOS SAVINC(CNX)		; Account
	JRST RECV1		; Go put it out

RECVSV:	MOVNI A,SAVBFS		; Prepare wrapped pointer
	ADD A,SAVINP(CNX)
	CAMN A,[POINT 7,SAVBUF-1,34]
	 MOVEM A,SAVINP(CNX)	; And use it if needed
	IDPB B,SAVINP(CNX)	; Store character
	AOS A,SAVINC(CNX)	; Account
	SKIPE SWOFLG		; Swo and
	CAIE A,1		; First character?
	 POPJ P,		; No
	MOVEI A,101
	DOBE
	HRROI A,[ASCIZ /
Output waiting from connection /]
	PUSHJ P,.PSOUT
	MOVE A,CNX
	IMULI A,3
	HRROI A,CONNAM(A)
	PUSHJ P,.PSOUT
tenex,<	MOVEI A,37 >
tops20,<MOVEI A,15>
	PUSHJ P,.PBOUT
	POPJ P,

RECVX:	BOUT
	SKIPE DIVSWT
	 JRST RECVN
	SKIPLE A,SCRJFN
	 BOUT
	MOVE A,B
	PUSHJ P,.PEOUT
RECVN:	CAIE B,12
	 JRST RECV0
	MOVEI A,101
	SOBE
	 JRST [	HRROI A,[ASCIZ /...
/]
		SKIPN DIVSWT
		 PUSHJ P,.PSOUT
		SETOM DIVSWT
		JRST RECV0]
	SETZM DIVSWT
	JRST RECV0

RECVFL:	MOVEM B,D
	HRRZ A,RECJFN(CNX)
	SKIPN SAVINC(CNX)
	SIBE
	 JRST RECV0
	MOVEI C,2
RECVF1:	MOVEI A,^D500
	DISMS
	HRRZ A,RECJFN(CNX)
	SIBE
	 JRST RECV0
	SOJG C,RECVF1
	SETZM CLROBF
tenex,<
	MOVEI A,37
>
tops20,<
	MOVEI A,15
>
	PUSHJ P,.PBOUT
	MOVE B,D
	JRST RECV2

; Receive character, return it in A.
; Handles Marks and Ends internally

RCVCH:	MOVE A,RECJFN(CNX)
	PUSHJ P,RCVBIN
	JUMPE B,RCVCH2		; Maybe EOF
RCVCH1:	MOVE A,B
	POPJ P,

RCVCH2:	SETZ C,
	GDSTS			; Check state of connection
	TLNE B,(1B5)
	 JRST RCVEOF		; End encountered
	TLZN B,(1B4)
	 JRST [	SETZ B,		; Just a null data byte
		JRST RCVCH1]
	SDSTS			; A Mark, clear it
	MOVEI B,23		; Read mark type
	MTOPR
	CAIN C,1		; Data mark?
	 JRST [	SOS SYNCNT(CNX)	; Decrement sync count
		PUSHJ P,ZCFOBF	; Consider whether to flush
		JRST RCVCH]
	CAIN C,5		; Timing mark?
	 JRST [	MOVEI A,101	; Yes, wait for tty buffer to empty
		DOBE
		MOVE A,SNDJFN(CNX)  ; Send timing mark reply
		MOVEI B,3
		MOVEI C,6
		MTOPR
		JRST RCVCH]
; We should never receive a timing mark reply since we never
; send a timing mark.  The other mark types should not be
; received by a Telnet user.
	JRST RCVCH		; Just ignore

IOERR:	HRROI A,[ASCIZ /
IO error for connection /]
	MOVE CNX,FSVCNX		; restore cnx to be sure
	JRST GENABN

RCVEOF:	MOVE CNX,FSVCNX
	SKIPN SAVSWT(CNX)
	SKIPE SAVINC(CNX)
	 JRST RECVH		; Delay eof response until buffer gone
	HRROI A,[ASCIZ /Remote disconnect of /]
GENABN:	PUSH P,A
	AOSE ABNLCK		; Wait for abnormal interpt handler
	 JRST [	MOVEI A,^D1000
		DISMS
		JRST .-1]
	POP P,A
	PUSHJ P,.PSOUT
	MOVE A,CNX
	IMULI A,3
	HRROI A,CONNAM(A)
	PUSHJ P,.PSOUT
	MOVEM CNX,ABNCNX
	MOVEI A,-1
	MOVSI B,(1B<ABNCHN>)
	IIC			; Initiate abnormal interpt in superior
	MOVEI A,^D100000
	DISMS			; And hang
	JRST .-2

RECVFT:	SKIPG CBFCNT(CNX)	; go to flush output if neg.
	JRST RECV0
	PUSH P,B
	TIME			; If pos., there is an excess of DM's,
	POP P,B
	SUB A,DMTIME(CNX)	;  check elapsed time since last DM
	JUMPL A,RECVBA		;  go on if less than limit
	MOVEI A,400000
	DIR			;  else disable interrups to avoid 
	SETZM SYNCNT(CNX)	;  confusion, then clear INS counts
	SETZM CBFCNT(CNX)
	MOVEI A,400000
	EIR
	JRST RECVBA


ZCFOBF:	AOS CBFCNT(CNX)		; if ct -> 0, output flushing stops
	SKIPL SYNCNT(CNX)	; if INS ct pos, more DM's to come,
	 POPJ P,		;  clearing continues
	MOVEI A,101		; if INS ct neg, DM came first, 
	SKIPN SAVSWT(CNX)	;  initiate clearing of buf
	CFOBF
	SETZM SAVINC(CNX)
	MOVE A,[POINT 7,SAVBUF]
	MOVEM A,SAVINP(CNX)
	MOVEM A,SAVONP(CNX)
	TIME			; start timing interval from receipt of
	ADDI A,^D5000		;  last excess DM: if no balancing INS
	MOVEM A,DMTIME(CNX)	;  in 5 sec., counts will be cleared
	POPJ P,			;  (lost INS, presumably)


RCVBIN:				; Called from RCVCH rtn:
				; BIN done here so restart routine can
				; tell if BIN has been completed yet
RCVBX:	SETZM RCVBSW(CNX)	; --switch set from entry to RCVCH
RCVB1:	BIN			; until this point-- this to prevent a
				; restarted conx from hanging on BIN,
	POPJ P,			; and other undesirable effects


RCVINS:	MOVEM 17,IACSAV+17	; INS interrupts come here
	MOVEI 17,IACSAV
	BLT 17,IACSAV+16
	MOVE CNX,FSVCNX
	AOS A,SYNCNT(CNX)
	SOS CBFCNT(CNX)		; If ct -> 0, flushing stops
	SKIPG A			;  if ct neg, more INS's to come
	 JRST RCVINX
	MOVEI A,101		; if ct pos, INS arrived first,
	SKIPN SAVSWT(CNX)	;  start clearing output
	CFOBF
	SETZM SAVINC(CNX)
	MOVE A,[POINT 7,SAVBUF]
	MOVEM A,SAVINP(CNX)
	MOVEM A,SAVONP(CNX)
	HRRZ A,FKRET2
	CAIE A,RECVH
	CAIN A,RECVH+1
	 JRST [	MOVEI A,RECV0
		HRRM A,FKRET2
		JRST RCVINX]
RCVINX:	HRLZI 17,IACSAV
	BLT 17,17
	DEBRK


LOC
VARS:	BLOCK 1
NCONN1==NCONN+1
	VAR
HSFSTR:	BLOCK 20
FMODSW:	BLOCK 7
SPARE:	BLOCK 3
NMODSW==.-FMODSW
EVARS:
RELOC

END START
