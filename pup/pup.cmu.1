SUMXSW==1
;<WOHL.MONITOR>PUP.MAC.7, 26-Aug-81 11:24:56, Edit by WOHL
;CS36
; Convert to run on in a version 4 2060 monitor also covert to
;  tops-20 coding style.
; Removed get time from ethernet code for now at least
;Things left to do:
; a) Make up names for all the bits (at least bits the user can see).
; b) Change the data structures to use DEFSTRs.
;<3A-MONITOR>PUP.MAC.20	   12-Mar-81 12:30:36	 Edit by SCHOEN
; Add ETHTIM to get time from Ethernet
;<3A-MONITOR>PUP.MAC.19     9-Dec-80 15:39:59	 TECO'd by GILMURRAY
; Get connected directory from RH of JSBSDN, not LH of JOBDIR
; Add GTNVLK/RLNVLK routines to get/release NVTLCK
; Fix BGRPRT to type date/time followed by asciz bug msg
; Don't do any output at DONVTO if line is XOFFed (^S)
; Convert Pup data (to UBA format) at non-interrupt level
;  (note...Pup headers must be converted at interrupt level)
; Save/restore critical ACs around sequential byte I/O routines
; Add NOINT/OKINT around ASGFRE calls
; Remove contents of PUPPAR for FT20 (filled in by TTINIT)
; Move SIGNAL and IDEV macros to PROLOG
; Move TTYPUP definition for FT20 to TTPNDV.MAC
; Incorporate 2020 changes into Tenex version
; Search SYSDEF for FT20 and FT10X definitions
; Control Pup NVT logins via SF%PNV (not SF%NVT)
;<MON>PUP.MAC;18     7-Apr-80 15:52:56	  EDIT BY SWEER
; Added hold key and output flow control check in DONVTO
;<MON>PUP.MAC;17     2-Apr-80 09:25:26	  EDIT BY SWEER
; Removed SCPU0 from PNVWAK
;<MON>PUP.MAC;15    14-Mar-80 10:02:53	  EDIT BY SWEER
; Go back to not logging Pup bugs (PUPBGF = 0)
;<MON>PUP.MAC;14     7-Mar-80 12:30:33	  EDIT BY SWEER
; Save 5,6,7 around MKLMA calls
;<MON>PUP.MAC;13     5-Mar-80 11:59:59	  EDIT BY SWEER
; Fix SNDINT to save args around call to DOBSPL
; KIisized 1st EXEC XCT instruction in .PUPO
;<MON>PUP.MAC;12     5-Mar-80 10:50:36	  EDIT BY SWEER
; Preserve UNIT over calls to PUPISV and PUPOSV
;<MON>PUP.MAC;10     4-Mar-80 14:42:52	  EDIT BY SWEER
; Sprayed SCPU0s around for dual processor
;<MON>PUP.MAC;8     4-Mar-80 13:55:41	 EDIT BY SWEER
; Defined CHNOFF and CHNON as macros for dual processor
;<MON>PUP.MAC;5    27-Feb-80 11:53:41	 EDIT BY SWEER
; Initialize PUPBGF to -1 to log pup bugs on logging tty
; Exchanged displacements of PBPHYS and PBTIME for D11 BLKI/O
; Fixed dual processor edit after CONSO at BGRDP3
; Begin dual-processorization
; Modified interrupt routines for D11SRV linkage
; Removed calls to MAKNBP
;<MON>PUP.MAC;3     8-Feb-80 11:00:33	 EDIT BY SWEER
; Redefined NVIO communication words
; Defined SIGNAL and IDEV as macros, removed API code
; Changed angle brackets in comments to parens
; Inserted ifdef pupchn around entire assembly
;<134>PUP.MAC;93    17-MAY-79 13:06:41	  EDIT BY TAFT
; Increase size of hop count field to 4 bits.
; Assemble both gateway and non-gateway code and switch to correct version
; at runtime.
;<134>PUP.MAC;92    18-NOV-78 17:41:42	  EDIT BY TAFT
; Fix editing error
;<134>PUP.MAC;91    21-OCT-78 13:10:13	  EDIT BY TAFT
; If a Pup arrives from an inaccessible net, change the routing table
; to route to net via the immediate source net/host.
;<134>PUP.MAC;90    26-SEP-78 12:36:23	  EDIT BY TAFT
; Insert missing end test in RCVDA6 loop!
;<134>PUP.MAC;89     8-SEP-78 10:22:42	  EDIT BY TAFT
; Fix PNVDBT to wake up on errors also
;<134>PUP.MAC;88     4-JUL-78 18:24:51	  EDIT BY TAFT
; Fix bug at PUPOP4 causing loss of local port if BLDBSP fails
;<134>PUP.MAC;87    12-NOV-77 19:36:57	  EDIT BY TAFT
; Fix PUPCLZ to turn FILLFW bit back on before waiting
;<134>PUP.MAC;86    18-JUL-77 15:24:14	  EDIT BY TAFT
; Raise IBWDLY to 500 ms
;<134>PUP.MAC;85     6-JUL-77 10:19:34	  EDIT BY TAFT
; Change BSP dispatch to update activity timeout only for certain types
;<134>PUP.MAC;84     6-JUL-77 09:56:08	  EDIT BY TAFT
; Fix error introduced into RCVERR in last edit
;<134>PUP.MAC;83     3-JUL-77 15:06:09	  EDIT BY TAFT
; Increase retransmission timeout when port IQ or gateway OQ error occurs
; Run background fork on SPQ
; Try to direct more freed PBs onto FREIBQ to reduce overhead
; Remove state saving code in previous edit
;<134>PUP.MAC;82     7-MAY-77 21:18:19	  EDIT BY TAFT
; Add code to record state of Pup background fork when a port IQ overflows
;<134>PUP.MAC;81    28-APR-77 21:45:23	  EDIT BY TAFT
; Make PBGCNT resident, dummy
;<134>PUP.MAC;80    22-APR-77 10:36:47	  EDIT BY TAFT
; Add logic to detect potential deadlocks arising from timing marks
;<134>PUP.MAC;79    21-APR-77 16:59:02	  EDIT BY TAFT
; Add PUPBGT -- hash table for counting PUPBUGs
;<134>PUP.MAC;78    15-APR-77 12:13:29	  EDIT BY TAFT
; Make TTYPUP internal
;<134>PUP.MAC;77     6-APR-77 10:08:59	  EDIT BY TAFT
; Lock out PSIs in PNVCOB so interrupt and DM will both be sent
;<134>PUP.MAC;76    25-JAN-77 21:18:40	  EDIT BY TAFT
; Parameterize initial routing table
; Put gateway-dependent stuff in GATEWF conditional
; Other changes for Maxc2
;<134>PUP.MAC;74    21-SEP-76 01:43:21	  EDIT BY TAFT
; Update routing table
;<134>PUP.MAC;73    17-JUL-76 18:33:51	  EDIT BY TAFT
; Add net 6 to routing table
;<134>PUP.MAC;72    13-MAY-76 16:59:15	  EDIT BY TAFT
; Repair bad call to RELPKT at FLSBS3+1
;<134>PUP.MAC;71    20-APR-76 22:53:22	  EDIT BY TAFT
; Bug fixes
; Generate timing mark reply immediately if a fork is blocked for input
;<134>PUP.MAC;70    20-APR-76 17:42:56	  EDIT BY TAFT
; Fix glitch at NVTSYN
;<134>PUP.MAC;69    19-APR-76 00:51:07	  EDIT BY TAFT
; Add PUPROU function for OPRFN
;<134>PUP.MAC;67    18-APR-76 21:20:21	  EDIT BY TAFT
; Add Telnet timing mark logic
;<134>PUP.MAC;66    18-APR-76 18:39:17	  EDIT BY TAFT
; Add code to handle Error Pups
;<134>PUP.MAC;65    17-APR-76 15:33:03	  EDIT BY TAFT
; Redo background wakeup strategy -- protective delay without
; added latency in most cases.
;<134>PUP.MAC;64    14-APR-76 20:21:41	  EDIT BY TAFT
; Improve hashing algorithm, remove restriction that NPUPUN be prime
;<134>PUP.MAC;63    29-MAR-76 17:35:58	  EDIT BY TAFT
; At PUPIN5, force immediate rather than delayed wakeup of background
;  process for NVT ports
;<134>PUP.MAC;62    27-MAR-76 20:08:33	  EDIT BY TAFT
; Increase some of the BSP retransmission timeouts
; Change probing strategy on zero allocation
;<134>PUP.MAC;61     7-MAR-76 00:53:56	  EDIT BY TAFT
; Reject Pups claiming to be from host zero
;<134>PUP.MAC;60    23-FEB-76 17:24:03	  EDIT BY TAFT
; Fix glitch in setting of NVT terminal type
;<134>PUP.MAC;59    25-JAN-76 17:32:23	  EDIT BY TAFT
; Take out code to force AData in ATPNVT -- first data will do it anyway
;<134>PUP.MAC;58    22-JAN-76 16:12:41	  EDIT BY TAFT
; Background fork back on HIQ -- SETHIQ bug was found
;<134>PUP.MAC;57    20-JAN-76 17:15:26	  EDIT BY TAFT
; Run background fork in SPQ (SETHIQ seems not to work)
;<134>PUP.MAC;56    20-JAN-76 03:07:54	  EDIT BY TAFT
; Pup received PSI now generated via scheduler request rather
;  than by direct call to PSIRQ from interrupt level.
;<134>PUP.MAC;55    11-JAN-76 21:34:42	  EDIT BY TAFT
; Fix assembly glitch -- need () around LOCK/UNLOCK macro args
; Add some ##
;<134>PUP.MAC;54    10-JAN-76 23:48:50	  EDIT BY TAFT
; Revise LOCK/UNLOCK calls for 1.34 scheduler handling
; Background fork always runs in HIQ

	SEARCH PROLOG,PROKL
	TTITLE PUP

	SUBTTL PUP I/O driver for PUP  /  E. A. Taft	March 1975


; -----------------------------------------------------------------
;	Pup Parameter Definitions
; -----------------------------------------------------------------


; Parameters defined in PARAMS.MAC
;  NPUPUN	# Pup "Units".
;  NTTPNV	# Pup NVT's.
;  PUPLO	TTY # of lowest Pup NVT
;  PUPHI	TTY # of highest Pup NVT
;  NPNETS	Maximum # of networks in routing table
;  NPKTBF	# pages of storage for packet buffer allocator
;  NPUPBF	# pages for other Pup storage

;  PUPCHN	PI assignment for Pup I/O interrupts

;  PUPIBG	Begin Pup input device # (Maxc -) NVIO)
;  PUPOBG	Begin Pup output device # (Maxc -) NVIO)
;  PUPIDN	Pup input done device # (NVIO -) Maxc)
;  PUPODN	Pup output done device # (NVIO -) Maxc)

;  XPUPIB	Pup input packet address
;  XPUPOB	Pup output packet address

; Accumulator assignments
; T1-T4		; Temps
; UNIT		; Pup "Unit" number -- for port-indexed tables

DEFAC(UNIT,Q1)
DEFAC(IOS,Q2)
DEFAC(E,Q3)
DEFAC(STS,P1)
DEFAC(JFN,P2)
DEFAC(BSP,P3)
DEFAC(PB,P4)
DEFAC(F1,P5)

IFNDEF PIESLC,<PIESLC==0>

;Local data defined in STG
	EXTERN CURIPB,CUROPB,DSCIBQ,FREIBN,FREIBQ,FREOBQ
	EXTERN LG2PBT
	EXTERN LSKNDL,NVTLCK,NXTWAK,PBKCNT,PBKRT,PBKTIM
	EXTERN PBQBEG,PBQEND,PKTBUF,PKTFRE,PKTRLF,PNRBEG
	EXTERN PNREND,PRSBEG,PRSEND,PRTLCK,PUPBGC,PUPBGF
	EXTERN PUPBGH,PUPBGT,PUPFII,PUPFLG,PUPFOI
	EXTERN PUPFRE,PUPFRK,PUPFTM,PUPIBC,PUPIBQ,PUPIDN
	EXTERN PUPLNH,PUPLSK,PUPNFI,PUPOBC,PUPOBQ,PUPODN
	EXTERN PUPPSI,PUPSTS,PUPTIM,PUPTMQ,PUPTQH,RANNUM
	EXTERN SYNTIM

;RS PRSBEG,0	; Start of Pup resident storage
;NR PNRBEG,0	; Start of Pup nonresident storage

;RS pupidn	; Pup input done
;RS pupodn	; Pup output done
;RS xpupib	; Pup input buffer communication word
;RS xpupob	; Pup output buffer communication word

; Parameters and byte pointers defining the structure of a Packet Buffer (PB)

; NOTE - At SUMEX displacement of PBPHYS and PBTIME exchanged so that
;	 PBPHYS immediately precedes Pup header. This is to facilitate
;	 BLKI/O communication with the D11 I/O bus interface.

INTERN PPBPHS,PBHEAD,PBCONT,PUPLEN	; Symbols used by ETHSRV

PBSIZE==0
 PBLCKF==1B0			; PB is locked in core
 PPUPUN: POINT 9,PBSIZE(PB),17	; Unit # of owning port
 ; B18-35			; Size of PB in words
IFE FT10X!FT20,<PBPHYS==1>  ; Physical packet parameters, passed to/from NVIO
IFN FT10X!FT20,<PBPHYS==:4> ; Physical packet parameters, passed to/from NVIO
 PPBPHN: POINT 8,PBPHYS(PB),7	; Physical network number
 PPBPHH: POINT 8,PBPHYS(PB),15	; Physical host number
 PPBPHS: POINT 16,PBPHYS(PB),31	; Packet size (Maxc words)

PBBSID==PBPHYS	; Byte ID, right-justified (used by BSP input)

PBIOBQ==2	; I/O buffer queue link word
		; 0 =) not on any queue, -1 =) being output by NVIO

PBBSPQ==3	; BSP buffer queue link word
		; 0 =) not owned by BSP processor
		; -1 =) owned by BSP but not on any queue

IFE FT10X!FT20,<PBTIME==4>  ; Time stamp (TODCLK format), used for BSP output
IFN FT10X!FT20,<PBTIME==1>  ; Time stamp (TODCLK format), used for BSP output

PBBSBC==PBTIME	; Byte count for data (used by BSP input)

PBHEAD==5	; Start of Pup Header
 PUPLEN: POINT 16,PBHEAD(PB),15	; Pup Length
 PUPTCB: POINT 8,PBHEAD(PB),23	; Transport Control Byte
 PUPTYP: POINT 8,PBHEAD(PB),31	; Pup Type

; PBHEAD+1
 ; B0-31			; Pup ID

; PBHEAD+2
 PPUPDN: POINT 8,PBHEAD+2(PB),7	; Destination Network
 PPUPDH: POINT 8,PBHEAD+2(PB),15  ; Destination Host
 PPUPD0: POINT 16,PBHEAD+2(PB),31  ; High 16 bits of Destination Socket

; PBHEAD+3
 PPUPD1: POINT 16,PBHEAD+3(PB),15  ; Low 16 bits of Destination Socket
 PPUPSN: POINT 8,PBHEAD+3(PB),23  ; Source Network
 PPUPSH: POINT 8,PBHEAD+3(PB),31  ; Source Host

; PBHEAD+4
 PPUPSS: POINT 32,PBHEAD+4(PB),31  ; Source Socket

PBCONT==PBHEAD+5		;Start of Pup Contents
PUPBGL==:PBCONT			;Number of words recorded in a pupbug

MNPLEN==^D22	; Minimum Pup Length (bytes), incl header and checksum
MXPLEN==^D554	; Maximum Pup Length (=) 532 data bytes)
MNPBLN==PBHEAD+<MNPLEN+3>/4  ; Minimum size of PB, in words
MXPBLN==PBHEAD+<MXPLEN+3>/4  ; Maximum size of PB, in words


; Pup Type assignments

PT.ECH==1	; Echo Me
PT.IEC==2	; I'm An Echo
PT.BEC==3	; I'm A Bad Echo
PT.ERR==4	; Error
PT.RFC==10	; Request for Connection
PT.ABT==11	; Abort
PT.END==12	; End
PT.ENR==13	; End Reply
PT.DAT==20	; Data
PT.ADA==21	; AData
PT.ACK==22	; Acknowledgment
PT.MRK==23	; Mark
PT.INT==24	; Interrupt
PT.INR==25	; Interrupt Reply
PT.AMA==26	; AMark

; Network-dependent stuff


; Network tables, indexed by net # -1

				; The following is a documented GETAB table
;RS PUPROU,NPNETS		; Network routing table
 ; B0				; Network inaccessible
 BROADF==1B1			; Broadcast packets allowed on net
 ; B2-17			; Net/host to which packets should
				;  be routed (0 =) route directly)
 ; B18-35			; Address of Maxc on this net (0 =) not on net)


; Table for initializing routing table

	SWAPCD

DEFINE HSTMAC(NET,HOST,BROADCAST) <
	<IFNB <BROADCAST>,<BROADF>>+<NET>B17+<HOST>B35>

INTERN PUPIRT			; So ETHSRV can get our net number
PUPIRT:	PUPHST(HSTMAC)		; Expand def from PARAMS.MAC
LPUPIR==.-PUPIRT

	RESCD


; Pup storage parameters and assignments

;RS PKTFRE,7	; Packet buffer free storage header (standard ASGFRE form)
;NRP PKTBUF,<NPKTBF*PGSIZ>  ; Packet buffer free storage region
;RS PUPFRE,7	; Pup free storage header
;NRP PUPBUF,<NPUPBF*PGSIZ>  ; Pup free storage region

NPKTBW==NPKTBF*1000  ; # words of packet buffer storage
MAXIQW==NPKTBW/^D15  ; Max # words on one port's input queue
MAXIQB==^D15	; Max # buffers on one port's input queue
MAXOQW==NPKTBW/^D15  ; Max # words on one port's output queue
MAXOQB==^D15	; Max # buffers on one port's output queue
MAXGQW==NPKTBW/^D10  ; Max # words allowed on gateway queue
MAXGQB==^D20	; Max # buffers allowed on gateway queue
MINFIB==^D12	; Min # free input buffers to maintain
MAXFIB==^D20	; Max # free input buffers to maintain


; Pup parameter GETAB table
; Must be resident because it is referenced by the GATEWY code
PUPPAR::0		; (0) -# of Pup NVT's, TTY# of first NVT
	PUPBUF		; (1) Start of Pup free storage
	<GATEWF>B0	; (2) B0 set if we are a gateway

NPUPPR==:.-PUPPAR	; Length of this table

; Pup queues

; All queues are doubly-linked through 36-bit link words.
; A queue header is in the form
;	Pointer to queue tail ,, Pointer to queue head
;  where self-pointers denote an empty queue.
; A queue item (e.g. a packet link word) is in the form
;	Pointer to predecessor ,, Pointer to successor
; All pointers point to other queue items or to header words.
; This permits uniform queue management without special cases.

; All Packet Buffers are linked through PBIOBQ except as noted

;RS PBQBEG,0		; Start of queue header block

; Queues referenced by input interrupt:

;RS FREIBQ		; Free input buffer queue.
			; Consists of max-length buffers, locked
			;  into core, for use by input interrupt

;RS PUPIBQ,NPUPUN	; Input buffer queue, one per port.
			; Packets received for that port

;RS DSCIBQ		; Discarded input buffer queue.
			; Packets waiting to be logged and discarded
			;  by job 0 or error process


; Queues referenced by output interrupt:

;RS PUPOBQ		; Pup output buffer queue.
			; Packets awaiting service by output interrupt

;RS FREOBQ		; Free (discarded) output buffer queue.
			; Waiting to be returned to free storage

;RS PBQEND,0		; End of queue header block

; Port-indexed tables

; ** The following are documented GETAB tables **

;RS PUPLSK,NPUPUN		; Local socket number hash table
				; 0 =) free, -1 =) deleted

;RS PUPLNH,NPUPUN		; Local Net/Host and BSP linkage
 PPRTLN: POINT 8,PUPLNH(UNIT),7	; Local net # (0 =) wildcard)
 PPRTLH: POINT 8,PUPLNH(UNIT),15 ; Local host # (0 =) wildcard)
 ; B16-17			; Unused
 ; B18-35			; Pointer to BSP data block
				; 0 =) not a BSP port

;NR  PUPFPT,NPUPUN		; Foreign port:  -length,,adr-1 of address table
				; 0 =) foreign port is fully wildcard

;RS PUPSTS,NPUPUN		; Port status word (mostly for BSP)
 BSLCKF==1B0			; Port is locked (must be sign)
 BSWAKF==1B1			; BSP wakeup request pending
 BSINPF==1B2			; Input available
 BSOUTF==1B3			; Output possible
 BSMRKF==1B4			; Mark encountered in stream
 BSENDF==1B5			; End encountered in stream
 BSTIMF==1B6			; Timeout
 BSNCHK==1B7			; Supress checksumming
 BSOPNR==1B8			; Port open for reading
 BSOPNW==1B9			; Port open for writing
 DSCRNF==1B10			; Random discard enabled
 BSSAKF==1B11			; Need to send Ack
 BSRAKF==1B12			; Received Ack
 BSZALF==1B13			; Sent Ack with zero allocation
 BSINTF==1B14			; Interrupt outstanding
 BSLISF==1B15			; Port is or has been listening
 BSNOQF==1B16			; BSP output queue is non-empty
 BSERRF==1B17			; Set if port gets in bad state
 ; B18-31 unused
 PBSSTM: POINT 4,PUPSTS(UNIT),35  ; State # in memory
 PBSSTA: POINT 4,PUPSTS(T1),35	; State # in memory, indexed by A
 PBSSTT: POINT 4,IOS,35		; State # in usual ac

; ** End of documented GETAB tables **

;RS PUPIBC,NPUPUN		; Input buffer counts
 ; B0-17			; Number of buffers allocated
 ; B18-35			; Number of words allocated

;RS PUPOBC,NPUPUN+1		; Output buffer counts
 ; B0-17			; Number of buffers allocated
 ; B18-35			; Number of words allocated
				; Extra entry is for gateway output

;RS PUPPSI,NPUPUN		; Port PSI assignments and other stuff
 INTPSI: POINT 6,PUPPSI(UNIT),5	; BSP Interrupt PSI channel
 RECPSI: POINT 6,PUPPSI(UNIT),11  ; Received Packet PSI channel
 STCPSI: POINT 6,PUPPSI(UNIT),17  ; BSP State Change PSI channel
 ; 18-35			; Fork to interrupt (-1 =) none)
				;  or 400000 + attached TTY #

; ***** Do not change the order of the following *****

;RS PUPTQH			; Timer queue head
;RS PUPTMQ,NPUPUN		; Timer queue linkage

;RS PUPFTM			; Time word corresponding to PUPTQH
;RS PUPTIM,NPUPUN		; BSP timer
				; TODCLK at which BSP processing next
				;  required for timing retransmissions

PUPTQD==NPUPUN+1		;PUPTIM-PUPTMQ displacement

; ***** End of do not change *****

; Definition of BSP data block

DEFINE BSWRD(LABEL) <
	LABEL==BSPSIZ
	BSPSIZ==BSPSIZ+1
>

BSPSIZ==0

BSWRD(BSPHDR)		; Header word
 PBSMRK: POINT 8,BSPHDR(BSP),7	; Value of most recent Mark
 PBSTMO: POINT 8,BSPHDR(BSP),15	; Error timeout interval / 2^12 ms
 ; B16-17			; Unused
 ; B18-35			; Size of BSP data block (words)

BSWRD(BSPTIM)		; BSP timing parameters
 ; B0-17			; Estimated round-trip delay (ms)
 ; B18-35			; Pointer to received Abort if any

; Timer words (TODCLK format) - for flow control and retransmission
BSWRD(BSPACT)		; Time of most recent activity
BSWRD(BSPDTM)		; Time at which to do BSP retransmissions
BSWRD(BSPATM)		; Time last AData was sent
			; 0 =) No AData outstanding
BSWRD(BSPITM)		; Time at which to retransmit Interrupt
BSWRD(BSPFTM)		; Time at which to check FSM
BSWRD(BSPSTM)		; Time of most recent FSM state change

; Packet buffer pointers and queues
BSWRD(BSPCUR)		; Current buffers being packeT4/unpacked
 ; B0-17			; Current input buffer (0 =) none)
 ; B18-35			; Current output buffer (0 =) none)
BSWRD(BSPIBQ)		; BSP Input queue (linked thru PBBSPQ)
BSWRD(BSPOBQ)		; BSP Output queue (linked thru PBBSPQ)

; Sequence numbers, allocations, counters, etc.
BSWRD(BSPCID)		; BSP Connection ID
			; -1 =) no ID assigned yet (listening)
BSWRD(BSPRII)		; BSP Receive Interrupt ID
BSWRD(BSPSII)		; BSP Send Interrupt ID
 ; B0 set =) B18-35 point to unacknowledged send Interrupt PB

BSWRD(BSPILW)		; BSP Input left window edge
			; ID of next byte to be removed by
			;  inputting process
BSWRD(BSPIQL)		; BSP Input queue length
 ; B0-17			; # Pups in BSP input queue
 ; B18-35			; # bytes from BSPILW to first hole
BSWRD(BSPIAL)		; BSP Input allocation
 PBSIAP: POINT 8,BSPIAL(BSP),7	; Total input Pups allowed
 PBSIBP: POINT 10,BSPIAL(BSP),17 ; Maximum data bytes/Pup
 ; B18-35			; Maximum # bytes allowed

BSWRD(BSPOLW)		; BSP Output left window edge
			; Pup ID of last received Ack
BSWRD(BSPOQL)		; BSP Output queue length
 ; B0-17			; # Pups in BSP output queue
 ; B18-35			; # bytes spanned by BSP output queue
BSWRD(BSPOAL)		; BSP Output allocation
 PBSOAP: POINT 8,BSPOAL(BSP),7	; Additional Pups allowed
 PBSOBP: POINT 10,BSPOAL(BSP),17 ; Maximum data bytes/Pup
 ; B18-35			; Additional bytes allowed


; Statistics
BSWRD(BSPOPG)		; BSP Output packets generated
BSWRD(BSPOPR)		; BSP Output packets retransmitted
BSWRD(BSPPPG)		; BSP Probe packets generated

; BSP-related parameters

MXBSIP==3*MAXIQB/4	; Max # Pups we allow on BSP input queue
MXBSIB==3*<4*MAXIQW>/4	; Max # bytes we allow on BSP input queue
MXBSOP==3*MAXOQB/4	; Max # Pups we allow on BSP output queue
MXBSOB==3*<4*MAXOQW>/4	; Max # bytes we allow on BSP output queue
MXSACK==0		; Max # Pos/NegAck blocks per Ack Pup
			; 0 =) Ignore incoming Pos/NegAcks also
MXPTXT==^D75		; Max # bytes of text in Interrupt, Abort

MINBWI==^D100		; Minimum background wakeup interval (ms)
			; Background process waits at least this long
			; when it dismisses before waking up again.
IBWDLY==^D500		; Input background wakeup delay (ms)
			; When an input packet arrives, wakeup of the
			; background process is delayed this long in
			; hopes that the user fork will process the input
RETINT==^D250		; Nominal retransmission interval (ms)
MAXRET==^D2500		; Maximum retransmission interval
HLDINT==^D1000		; Hold interval (expiration forces AData)
PRBINT==^D15000		; Probe interval for idle connection (ms)
DETINT==^D120		; Default error timeout interval (sec)

ALLPCT==^D25		; % of total allocation (Pups or bytes)
			;  below which an AData is sent to request
			;  new allocation


; Macro to assemble bits corresponding to up to 8 listed port states
; Call by:	STTBTS(STATE1,STATE2, ...)

DEFINE STTBTS(A,B,C,D,E,F,G,H) <<$S(A)+$S(B)+$S(C)+$S(D)+$S(E)+$S(F)+$S(G)+$S(H)>>

DEFINE $S(STATE) <IFNB <STATE>,<1B<S.'STATE>>>


; Macro to assemble code to skip if current state is among those listed
; Call by:	CHKSTT(<STATE1,STATE2, ...>,AC)
; Assumes UNIT setup, clobbers A unless AC specified

DEFINE CHKSTT(STATES,AC<A>) <
	LDB AC,PBSSTT		; Get current state
	MOVE AC,BITS(AC)	; Get bit corresponding to state
	TXNN AC,STTBTS(STATES)  ; Skip if among those listed
>

; Pup NVT data
; Indexed by Pup NVT # (= TTY # - PUPLO)
; ** This is a documented GETAB table **

;The TTYPUP word is stored in TTDEV in the dynamic data
 ; B0				; 1 =) NVT assigned
 PSYNCT: POINT 3,TTYPUP(T2),3	; Sync count (Int's - DM's)
 SYNCNT==7B3			; Mask of bits in sync count
 PSYNTM: POINT 3,TTYPUP(T2),6	; Sync timer
 PNVSTT: POINT 2,TTYPUP(T2),8	; NVT state for input processing
 PNVMRK: POINT 4,TTYPUP(T2),12	; Pending Mark type if any
 HUREQF==1B13			; Hangup request already made
INTERN HUREQF			; Ignore TTMSG if hanging up (TTYSRV)
 PTMKCT: POINT 3,TTYPUP(T2),16	; Count of incoming timing marks pending
 TMKPNF==1B17			; Outgoing timing mark pending
 ; B18-35			; Pup unit # of attached port


SYNCHI==^D10000			; Sync check interval (ms)
SYNTMO==^D20000/SYNCHI		; Sync timeout interval (20 seconds)

;RS NVTLCK,2			;??? Actual lock count and FORKX of locker

; Error handling

; In addition to the usual BUGHLT, BUGCHK, and BUGNTE (for reporting
;  internal errors), there is a collection of PBUG types for
;  reporting anomalies associated with a particular Pup anT4/or
;  discarding that Pup.

; PBUG(PUP,<message>)
;  Copies the header of the packet pointed to by PB into cells
;  looked at by job 0.  If PUPBGF is nonzero, this data is printed
;  on the logging console by job 0.

; PBUG(DIP,<message>)
;  Appends the packet pointer to by PB to the discarded input
;  packet queue (DSCIBQ).  The PC of the BUG is stored in the RH
;  of the PBBSPQ word.  If PUPBGF is nonzero, information
;  about this packet is printed on the logging console by job 0.
;  (Later we may provide a mechanism whereby a user process can
;  arrange to receive all discarded Pups).  The buffer is then
;  deallocated.

; PBUG(DPR,<message>)
;  Same as BUG(DIP,...) except that an extra RET is executed
;  so that the routine invoking the BUG is exited.


DEFINE PBUG (.TYP,.STR)<
	JRST [  CALL BGR'.TYP	;;CS36 Assemble into one word
		JFCL [ASCIZ \
  .STR
\]
	JRST .+1]
>

; JSYS error macros, adapted from JSYS.MAC

DEFINE ERROR(ERRORN,EXTRA,WHERE) <
IFB <ERRORN'EXTRA>,<JRST WHERE>
IFNB <ERRORN'EXTRA>,<
	JRST [	EXTRA
		IFNB <ERRORN>,<MOVEI A,ERRORN>
		JRST WHERE]
>>

; Load error code and do RET
DEFINE ERPOPJ(ERRORN,EXTRA) <ERROR(ERRORN,<EXTRA>,R)>

; Store error code, unlock JFN, and give error return from JSYS
DEFINE ERUNLK(ERRORN,EXTRA) <RETERR(ERRORN,<EXTRA
			<CALL UNLCKF>>)>

; Store error code, unlock JFN, and generate instruction trap
DEFINE FILABT(ERRORN,EXTRA) <ITERR(ERRORN,<EXTRA
		<CALL UNLCKF>>)>

; Store error code, unlock JFN, and give i/o data error psi
DEFINE FILINT(ERRORN,EXTRA) <ERROR(ERRORN,<EXTRA>,DOINT)>

; Macro to activate Pup background process.
; SIGPBP(XXX) causes bit PBFXXX to be set in PUPFLG.  This causes
;  the Pup background process to wakeup and call the routine
;  implementing the requested background task (see PUPBAK).
; Optional arguments:
;	SIGPBP(FLAG,<INSTRUCTION>,AC)
; If <INSTRUCTION> is specified, the flag is set iff the
; instruction does not skip.  If AC is specified, it (instead of
; A) is the ac clobbered by the generated code.

DEFINE SIGPBP(FLAG,INST,AC<A>) <
	MOVX AC,PBF'FLAG
	INST
	IORM AC,PUPFLG
>

;RS PUPFLG		; Records Pup background process requests
;RS NXTWAK		; Earliest time at which next wakeup permitted


; Random other data referenced in more than one place.
; (Storage used in only one place is defined at that place)

;RS PRTLCK		; Lock for changes to port tables
;RS LSKNDL		; # of deleted entries in local socket table
;RS FREIBN		; # buffers in FREIBQ
;RS PUPFRK		; FORKX of Pup background process

;RS SYNTIM		; Time for next sync timeout check

DEFINE PLOCK(LCK,FAIL)<
IFIDN <LCK><NVTLCK>,<	CALL GTNVLK>
IFDIF <LCK><NVTLCK>,<PRINTX Incorrect PUP LK arguments>

  IFB <FAIL>,<CBLK1>
  IFNB <FAIL>,<FAIL>
>

; Notes on handling of locks:
; PRTLCK should be locked while attempting to lock a port, then
;  unlocked once the port is locked.
; NVTLCK should be locked while doing anything to an NVT.
; No lock should be held while waiting for a port lock to become free.
; If both NVTLCK and PRTLCK need be locked simultaneously, NVTLCK
;  must be locked first to prevent deadlocks.
; Lockers of PRTLCK should invoke SPQ (Special Queue), unless it is
;  known that the locker is the Pup background fork, which already
;  runs on HIQ.
; Lockers of NVTLCK should invoke HIQ unless it is known that the
;  locker is the Pup background fork.


; -----------------------------------------------------------------
;	Standard JSYS Routines for Pup
; -----------------------------------------------------------------

	SWAPCD

; Pup device dispatch table

PUPDTB::DTBDSP (PUPSET)		; Directory setup
	DTBDSP (PUPNAM)		; Name lookup
	DTBDSP (PUPEXT)		; Extension lookup
	DTBDSP (GJSRET)		; Version lookup
	DTBBAD (DESX9)		; Insert protection
	DTBBAD (DESX9)		; Insert account
	DTBBAD (DESX9)		; Insert status
	DTBDSP (PUPOPN)		; Open
	DTBDSP (PUSQIX)		; Sequential input
	DTBDSP (PUSQOX)		; Sequential output
	DTBDSP (PUPCLZ)		; Close
	DTBBAD (DESX9)		; Rename
	DTBBAD (DESX9)		; Delete
	DTBBAD (DESX9)		; Dump input
	DTBBAD (DESX9)		; Dump output
	DTBBAD (DESX9)		; Mount
	DTBBAD (DESX9)		; Dismount
	DTBBAD (DESX9)		; Initialize directory
	DTBDSP (PUPMTP)		; MTOPR
	DTBDSP (PUPGST)		; Get status
	DTBDSP (PUPSST)		; Set status
	DTBSKP			; RECORD OUT
	DTBDSP (RFTADN)		; READ TAD
	DTBDSP (SFTADN)		; SET TAD
	DTBDSP (BIOINP)		; SET JFN FOR INPUT
	DTBDSP (BIOOUT)		; SET JFN FOR OUTPUT
	DTBBAD (GJFX49)		; CHECK ATTRIBUTE
DTBLEN==:.-PUPDTB


; Lookup routines called by GTJFN

DEFINE GJERR(ERRORN) <ERROR(ERRORN,,GJERRX)>


; Directory setup routine

PUPSET:	TQNE <STEPF>		;CS36 Want to step?
	RETBAD (GJFX17)		;CS26 Yes. can't do it
	NOINT
	JRST SK2RET		;Always successful


; Name lookup routine

PUPNAM:	JUMPE T1,[GJERR(GJFX31)] ;* not allowed
	HRLI T1,(POINT 7,,35)	;Make string pointer
	CALL PNMDEC		;Decode name string
	 GJERR(GJFX18)		;Bad, say no such name
	JRST GJ2RET		;Ok, take success return


; Extension lookup routine

PUPEXT:	JUMPE T1,[GJERR(GJFX31)] ; * not allowed
	HRLI T1,(POINT 7,,35)	;Make string pointer
	CALL PEXDEC		;Decode extension string
	 GJERR(GJFX19)		;Bad, say no such extension
	MOVEI T2,(T1)		;Ok, now just throw the block away
	CALL RELPFR
;	JRST GJ2RET		;Take success return


; Version lookup routine (always succeeds, does nothing)


; Returns from GTJFN routines
GJ2RET:	AOS 0(P)		;Double skip
GJSRET:	AOS 0(P)		;Single skip
	TQNE <UNLKF>		;Should we unlock?
	 RET			;No
GJERRX:	OKINT			;Yes
	RET    

; Open Pup network file (OPENF)

DEFINE OPNERR(ERRORN,EXTRA) <ERROR(ERRORN,<EXTRA>,OPNERX)>

; Check mode and byte size
PUPOPN:	TQNN <XCTF,RNDF>	;Xct and append are illegal
	TQNN <READF,WRTF>	;Must be reading or writing
	 ERPOPJ(OPNX13)		;Illegal access
	TXNE STS,10		;Raw packet mode (16)?
	 JRST PUPOP0		;Yes, skip some checks
	TQC <READF,WRTF>	;BSP can do only one or the other
	TQCN <READF,WRTF>
	 ERPOPJ(OPNX13)		;Both read and write is illegal
	LDB T1,PBYTSZ		;Get byte size
	CAIE T1,7		;Only 7 and 8 allowed
	CAIN T1,8
	 CAIA
	 ERPOPJ(SFBSX2)		;Illegal byte size

; Re-parse the name and extension strings to yield addresses
PUPOP0:	HRRZ T1,FILNEN(JFN)	;Make byte ptr to extension
	HRLI T1,(POINT 7,,35)
	CALL PEXDEC		;Decode Pup extension string
	 ERPOPJ(OPNX2)		;Failed (maybe net dir changed?)
	MOVE E,T1		;Save address table pointer
	HLRZ T1,FILNEN(JFN)	;Make byte ptr to filename
	HRLI T1,(POINT 7,,35)
	CALL PNMDEC		;Decode Pup name string
	 OPNERR(OPNX2)		;Failed (maybe net dir changed?)

; Now have T1/ <net>B7 + <host>B15, T2/ socket for local port.
; Check for correct access to the specified socket number
	MOVE T3,CAPENB		;Get privilege bits
	TXNE T3,SC%WHL!SC%OPR	;Wheel or operator?
	 JRST PUPOP1		;Yes, can have any socket
	MOVE T3,T2		;No, get high 17 bits
	LSH T3,-^D15
	MOVE T4,JOBNO		;Get job number
	MOVE T4,JOBDIR(T4)	;Connected,,login dir if top fork
	CAIN T3,(T4)		;User-relative for login dir?
	 JRST PUPOP1		;Yes, ok
   IFE SUMXSW,<HLRZ T4,D>	;Try connected dir
   IFN SUMXSW,<HRRZ T4,JSBSDN>	;Get connected directory from JSB
	CAIL T3,^D50000		;Socket in free-for-all range?
	 CAILE T3,^D99999
	 CAIN T3,(T4)		;No, user-relative for this fork?
	 JRST PUPOP1		;Either of those, socket ok
	MOVE T4,JOBNO		;No, get job number
	CAIE T3,^D100000(T4)	;Job-relative for this job?
	 OPNERR(OPNX13)		;No, illegal access to socket

; OPENF (cont'd)

; If mode 0, 1, or 4, ensure foreign port is not multiple or wild
PUPOP1:	TXNE STS,12		;Ok if mode 2, 3, or 16
	 JRST PUPOP3
	CAML E,[-2,,0]		;Multiple?
	 JRST PUPOP2		;No, go check for wildcard

; Multiple foreign address
; Pick the first one on a directly-connected network, or else the
;  first one that is accessible.
	PUSH P,T1		;Save local port address
	PUSH P,T2
	MOVE T4,E		;Copy foreign address table ptr
	SETZ T3,		;No choice yet
PUPO1A:	HLRZ T1,1(T4)		;Get a net from table
	CAIL T1,1		;In range?
	 CAILE T1,NPNETS
	 JRST PUPO1B		;No
	SKIPGE T2,PUPROU-1(T1)	;Yes, get entry
	 JRST PUPO1B		;Inaccessible, ignore
	SKIPN T3		;Ok, already have saved index?
	 MOVE T3,T4		;No, save index
	TXNN T2,177777B17	;Routing directly to net?
	 JRST PUPO1C		;Yes, use this entry
PUPO1B:	AOBJN T4,.+1		;Advance table pointer (2 words)
	AOBJN T4,PUPO1A		;Try next if any remain
PUPO1C:	JUMPE T3,[POP P,T2	;Fail if none found
		POP P,T1
		OPNERR(PUPX2)]
	MOVE T1,1(T3)		;Store selected address at
	MOVEM T1,1(E)		; start of block
	MOVE T1,2(T3)
	MOVEM T1,2(E)
	MOVEI T1,0(E)		;Copy pointer to block
	MOVEI T2,3		;New size of block
	CALL TRMPFR		;Trim the address block
	HRLI E,-2		;Now just 2 words in table
	POP P,T2		;Recover local port
	POP P,T1

; Give error if foreign port now has any wildcard elements.
; Substitute appropriate values for wildcard local net/host
PUPOP2:	SKIPN 2(E)		;Wild socket?
	 OPNERR(PUPX2)		;Yes, address error
	HLRZ T3,1(E)		;Get net
	SKIPE T3		;Wildcard?
	 CAILE T3,NPNETS	;Out of range?
	 OPNERR(PUPX2)		;Yes, address error
	HRRZ T4,1(E)		;Get host
	SKIPE T4		;Wildcard?
	 SKIPGE T4,PUPROU-1(T3)	;Dest net inaccessible?
	 OPNERR(PUPX2)		;Yes, address error
	JUMPN T1,PUPOP3		;Local net/host specified?
	TXNN T4,-1		;No, are we on dest net?
	 LDB T3,[POINT 8,PUPROU-1(T3),9]  ; No, use net of gateway
	HRRZ T4,PUPROU-1(T3)	;Get our address on that net
	ROT T4,-8		;Concatenate net/host
	LSHC T3,-8		;Left-justify in D
	MOVE T1,T4		;Put in proper ac

; OPENF (cont'd)

; Now have T1/ <net>B7 + <host>B15, T2/ socket for local port.
; Attempt to assign the local port
PUPOP3:	CALL ASGPRT		;Assign local port
	 OPNERR(OPNX10)		;Failed, tables full
	 JRST PUPOP6		;Duplicate, check for legal cases
	HRLM UNIT,FILSKT(JFN)
	MOVE T1,FORKX		;Record fork owning port
	HRRM T1,PUPPSI(UNIT)
	MOVEM E,PUPFPT(UNIT)	;Save address table pointer
	TXNN STS,10		;Raw packet mode?
	 JRST PUPOP4		;No, BSP, more to do

; Successful open in raw packet mode, finish up and return
	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Unlock local socket table
	SKIPN 1(E)		;Is foreign port fully wildcard?
	SKIPE 2(E)
	 RETSKP			;No, done
	SETZM PUPFPT(UNIT)	;Yes, remember so
	MOVEI T2,(E)		;Release the address block
	CALL RELPFR
	RETSKP			;Done, skip return

; Here if BSP mode.  Lock port and setup BSP data block
PUPOP4:	CALL BLDBSP		;Allocate and build BSP data block
	OPNERR(OPNX10,<UNLOCK(PRTLCK,RESIDENT,SPQ)>) ; Failed
	HRRM BSP,PUPLNH(UNIT)	;Store pointer in standard place
	MOVX IOS,BSLCKF!BSOPNR  ; Assume opening for reading
	TQNE <WRTF>		;Writing?
	 MOVX IOS,BSLCKF!BSOPNW	; Yes
	MOVEM IOS,PUPSTS(UNIT)	;Initialize port status word
	UNLOCK(PRTLCK,RESIDENT,SPQ) ;Unlock local socket table
	XCTU [HLRZ T1,2]	;Get lh 2 from user
	TXNE T1,377		;Timeout interval specified?
	 DPB T1,PBSTMO		;Yes, set it

; Initiate appropriate operations to open a connection
	TXNE STS,2		;Listening?
	 JRST [	TXO IOS,BSLISF  ; Yes, remember so
		MOVEI T1,E.OPNL	;Generate event OPENF(L)
		JRST PUPOP5]
	TXNE STS,4		;Direct open (no rendezvous)?
	 JRST [	UMOVE T1,3	;Yes, get Connection ID from user
		CALL SETCID	;Set it in data block
		MOVEI T1,E.OPNN	;Generate event OPENF(N)
		JRST PUPOP5]
	MOVEI T1,E.OPNC		;Initiating rendezvous, OPENF(T3)
PUPOP5:	CALL PUPFSM		;Activate the FSM appropriately
	JRST PUPOP7		;Go wait if necessary

; Here if local port already in use, check for legal case
PUPOP6:	HRRZ BSP,PUPLNH(UNIT)
	SKIPE BSP		;Already open in raw packet mode?
	TXNE STS,10		;Opening in raw packet mode?
	 OPNERR(OPNX9,<UNLOCK(PRTLCK,RESIDENT,SPQ)>)  ; Yes, fail
	HRRZ T1,PUPPSI(UNIT)	;No, get fork that did first open
	HLRZ T1,FKJOB(T1)	;Get job
	CAME T1,JOBNO		;Same as me?
	 OPNERR(OPNX9,<UNLOCK(PRTLCK,RESIDENT,SPQ)>)  ; No, fail
	MOVEI T2,(E)		;Ok, get rid of address table
	CALL RELPFR
	CALL LCKBSA		;Attempt to lock the port
	 JRST [	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Can't, unlock the table
		MOVSI T1,(UNIT)	;Set scheduler test
		HRRI T1,BSLCKT	; for port unlocked
		MDISMS		;Wait until unlocked
		JRST PUPOP0]	;Try again
	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Ok, unlock the table
	CALL SETRWB		;Setup read/write bit for this opening
	TDOE IOS,T1		;Flag opening, check for conflict
	 ERPOPJ(OPNX9,<CALL ULKBSP>)  ; Already open, fail
	HRLM UNIT,FILSKT(JFN)

; OPENF (cont'd)

; Here to wait for completion if necessary
PUPOP7:	CHKSTT <OPEN,ENDI,ENDO,DALY,ABOR,CLOS>  ; Beyond LIST/RFCO state?
	 TXNE STS,5		;Immediate return OPENF?
	 JRST PUPOP8		;Yes, bypass waiting
	CALL ULKBSP		;Unlock port
	TQO <OPNF>		;Mark JFN as being open
	MOVSI T1,1		;Fix reference count (???)
	IORM T1,FILLFW(JFN)
	CALL UNLCKF		;Unlock file, go OKINT
	MOVX T1,<ALLSTT-STTBTS(LIST,RFCO)>
	CALL WATSTT		;In desired state now?
	MDISMS			;No, wait until get there

; Check whether the connection was opened successfully
; This is somewhat hairy since a PSI or another fork could have
;  released and re-used the JFN in the meantime
	PUSH P,JFN+1
	IDIVI JFN,MLJFN		;CONVERT FROM INTERNAL FORMAT
	POP P,JFN+1
	CALL CHKJFN		;NOINT, lock JFN again
	 RETERR()		;Huh? (released by PSI maybe)
	 ERUNLK(DESX4)
	 ERUNLK(DESX4)
	HRRZ T1,FILDEV(JFN)	;Get DTB
	CAIE T1,PUPDTB		;Is it a PUP
	 ERPOPJ(DESX5)
	HLRZ T1,FILSKT(JFN)	;Make sure JFN still refers to
	CAIE T1,(UNIT)
	 ERPOPJ(DESX5)		;Not, fail
	TQNE <OPNF>		;Make sure JFN still open
	 CALL LCKBSQ		;Lock the port again
	 ERPOPJ(DESX5)		;Not open or not BSP port
	MOVSI T1,1		;Undo reference count diddle ???
	ANDCAM T1,FILLFW(JFN)

; Come directly here in immediate-return modes
PUPOP8:	CHKSTT <CLOS,ABOR>	;Connection closed or aborted?
	 TDZA T1,T1		;No, assume no error
	 MOVEI T1,OPNX21	;Yes, assume rejected by foreign host
	TXNE IOS,BSTIMF  	;Timed out?
	 MOVEI T1,OPNX20	;Yes, assume nobody there
	JUMPN T1,PUPOP9		;Jump if failed to open
	CALL ULKBSP		;Succeeded, unlock port
	RETSKP			;Give success return

; Here if rendezvous attempt failed
; Clean up and give error return, T1/ error code
PUPOP9:	PUSH P,T1		;Save error code
	MOVEI T1,E.CLST		;Generate CLOSF(T) event
	HRROI T3,0		;Set code for Abort if any
	HRROI T4,[ASCIZ /Connection attempt timed out/]
	CALL PUPFSM		;Force state to closed
	CALL PUPCL3		;Delete port if appropriate
	 BUG(PUPOPA)
	TQZ <OPNF>		;JFN no longer open
	POP P,T1		;Recover error code
	RET    			;Fail return from OPENF



; Here to fail return from early parts of the OPENF when we have
;  address table assigned but port not open yet (OPNERR macro)
; T1/ error code, E/ address table pointer
OPNERX:	PUSH P,T1		;Save error code
	MOVEI T2,(E)		;Release address table
	CALL RELPFR
	POP P,T1
	RET    

; Close Pup network file (CLOSF)

PUPCLZ:	HLRZ UNIT,FILSKT(JFN)	;Setup Pup unit #
	CALL LCKBSQ		;Lock port if BSP
	 JRST PUPCL8		;Not BSP, jump around BSP logic
	SETZM FILCNT(JFN)	;Allow no further i/o
	TXZE IOS,BSTIMF  	;Timed out?
	 JRST [	MOVEI T1,E.CLST	;Yes, generate CLOSF(T) event
		HRROI T3,0	;Abort Code = 0 (need registered code ******)
		HRROI T4,[ASCIZ /Connection timed out/]
		CALL PUPFSM
		TQO <ERRF>	;Set JFN error flag
		ERPOPJ(IOX5,<CALL ULKBSP>)]  ; Give error return
		TQNN <WRTF>		;Closing output JFN?
	 JRST [	TXNN IOS,BSOPNW    ; No, is port also open for writing?
		 JRST PUPCL2	;No, generate close event
		JRST PUPCL3]	;Yes, do nothing for input close
	UMOVE T1,1		;Get flags from call
	TXNE T1,CZ%ABT  	;Was this an abort?
	 JRST [ MOVEI T1,E.CLST	;Yes, then send an abort
		JRST PUPCL4 ]	;Skip actions that might block
	CHKSTT <OPEN,ENDI>	;State ok for BSP output?
	 JRST PUPCL2		;No, skip this
	MOVE T1,FILBYT(JFN)	;Yes, get byte ptr to last byte stored
	CALL FRCBSP		;Force out remaining data if any
	CALL CHKBOQ		;Any output pending?
	 JRST CLZWAT		;Yes, back out and wait til done
PUPCL2:	MOVEI T1,E.CLSN		;Generate CLOSF(N) event
PUPCL4:	HRROI T3,0		;Need registered code ************
	HRROI T4,[ASCIZ /Connection attempt abandoned/]  ; In case RFC Out
	CALL PUPFSM
	MOVX T1,<STTBTS(CLOS,ABOR)> ;Specify desired states
	CALL WATSTT		;Now closed or aborted?
	 JRST CLZWAT		;No, back out and wait until it is
	LDB T1,PBSSTT		;Yes, get current state
	CAIE T1,S.CLOS		;Now closed?
	 ERPOPJ(IOX5,<CALL ULKBSP>)  ; No, give error return

; Called here from OPENF code to clean up after rendezvous failure
PUPCL3:	CALL SETRWB		;Setup status bit for this opening
	ANDCM IOS,T1		;Mark no longer open this way
	TXNE IOS,BSOPNR!BSOPNW    ; Still open the other way?
	 JRST [	CALL ULKBSP	;Yes, don't delete port yet
		RETSKP]		;Success return
	CALL FLSBSQ		;Now closed both ways, flush queues

; Now delete the port (still locked if BSP port)
PUPCL8:	MOVEI T1,PUPOBC(UNIT)	;Check output counts
	SKIPE 0(T1)		;Output pending for this port?
	 CALL DISE		;Yes, wait until all gone
	CALL DELPRT		;Delete the port
	RETSKP			;Done, skip return

; Must set bit in FILLFW before backing out of CLOSF.
; I don't really understand what the FILLFW bullshit is all about.
CLZWAT:	MOVSI T2,1		;???
	IORM T2,FILLFW(JFN)
	JRST ULKWAT



; Setup read/write bit appropriately for this opening of port
;	STS/ File status
; Returns +1:  T1/ BSOPNR or BSOPNW set

SETRWB:	MOVX T1,BSOPNR		;Assume opening for reading
	TQNE <WRTF>		;Writing?
	 MOVSI T1,(BSOPNW)	;Yes, say so
	RET    


; Pup kill fork
; Called to clean up Pup tables when a fork is killed
; Returns +1
; Clobbers T1, UNIT

PUPKFK::MOVSI UNIT,-NPUPUN	;For all ports:
PUPKF1:	HRRE T1,PUPPSI(UNIT)	;Get fork to be interrupted
	CAMN T1,FORKX		;Same as fork being killed?
	 SETOM PUPPSI(UNIT)	;Yes, deassign interrupt for port
	AOBJN UNIT,PUPKF1
	RET    

; Pup sequential byte input
;	JFN, DEV, STS setup
; Returns +1 always, T1/ the next byte (if no error)
; Clobbers T1-T4, UNIT, BSP, PB

PUSQIX:	PUSH P,BSP		;Save ACs needed by device independent routines
	PUSH P,PB
	CALL PUPSQI		;Call regular sequential byte input routine
	POP P,PB		;Restore ACs
	POP P,BSP
	RET			;Back to device independent routine

PUPSQI:	SOSGE FILCNT(JFN)	;Decrement and test byte count
	 JRST PUPSI1		;Pup exhausted, get another
	ILDB T1,FILBYT(JFN)	;Bytes remain, load next
	AOS FILBYN(JFN)		;Advance byte number
	RET    			;Return

; Here when input Pup used up, attempt to get next
PUPSI1:	HLRZ UNIT,FILSKT(JFN)	;Get Pup unit #
	CALL LCKBSQ		;Lock port, check for BSP
	 FILABT(IOX1)		;Not BSP, sequential i/o illegal
	CHKSTT <OPEN,ENDI,ENDO,DALY>  ; Check for legal state
	 JRST PUPSQE		;Not good, set error bit
	TXNE IOS,BSMRKF!BSENDF!BSTIMF    ; Eof or errors?
	 JRST PUPSI2		;Yes, don't try for more Pups
	CALL GETBSP		;No, get next Pup from stream
	 JRST [	CHKSTT(<ENDI,DALY>,B)  ; Empty, has End been received?
		 JRST ULKWAT	;No, back out and wait for data
		TXO IOS,BSENDF    ; Yes, set End encountered flag
		JRST PUPSI2]	;Do eof handling
	LDB T1,PUPTYP		;Got one, get Pup Type
	CAIE T1,PT.MRK		;Mark?
	 CAIN T1,PT.AMA		;AMark?
	 JRST [	ILDB T1,PBBSID(PB)  ; Yes, get the byte
		DPB T1,PBSMRK	;Store in status word
		CALL RELPKT	;Release the packet
		HRRZS BSPCUR(BSP)  ; Note no current packet
		TXO IOS,BSMRKF    ; Set Mark encountered flag
		JRST PUPSI2]	;Do eof handling
	CALL ULKBSP		;Data or AData, unlock port
	MOVE T1,PBBSBC(PB)	;Get byte count
	MOVEM T1,FILCNT(JFN)	;Store it in standard place
	ADDM T1,FILLEN(JFN)	;Extend file length
	MOVE T1,PBBSID(PB)	;Get byte pointer
	MOVEM T1,FILBYT(JFN)	;Store it in standard place
	JRST PUPSQI		;Back to get first byte

; Here if any error flags are set
PUPSI2:	TXNE IOS,BSMRKF!BSENDF    ; Mark or End encountered?
	 TQO <EOFF>		;Yes, set eof flag for JFN
	TXNE IOS,BSTIMF  	;Timeout
PUPSQE:	TQO <ERRF>		;Yes, set error flag for JFN
	CALL ULKBSP		;Unlock port
	RET    			;Return with no data

; Pup sequential byte output
;	T1/ Byte to be output
;	JFN, DEV, STS setup
; Returns +1 always
; Clobbers T1-T4, UNIT, BSP, PB

PUSQOX:	PUSH P,BSP		;Save ACs needed by device independent routines
	PUSH P,PB
	CALL PUPSQO		;Call regular sequential byte output routine
	POP P,PB		;Restore ACs
	POP P,BSP
	RET			;Back to device independent routine

PUPSQO:	STKVAR <PUPSOB>		;Byte to output
PUPSQL:	SOSGE FILCNT(JFN)	;Decrement and test byte count
	 JRST PUPSO1		;Pup full, attempt to send
	IDPB T1,FILBYT(JFN)	;Still room, store byte
	AOS FILBYN(JFN)		;Advance byte number
	RET    			;Return

; Here when output Pup full, attempt to send it and start another
PUPSO1:	HRRZM T1,PUPSOB		;Save the byte to be output
	HLRZ UNIT,FILSKT(JFN)	;Get Pup unit #
	CALL LCKBSQ		;Lock port, check for BSP
	 FILABT(IOX2)		;Not BSP, sequential i/o illegal
	CHKSTT <OPEN,ENDI>	;Check for reasonable state
	 JRST PUPSQE		;Not good, set error bit
	TXNE IOS,BSTIMF  	;Timeout?
	 JRST PUPSQE		;Yes, set error flag
	MOVE T1,FILBYT(JFN)	;Get ptr to last byte stored
	CALL DMPBSP		;Force out current Pup if any
	CALL CHKBSO		;See if more BSP output possible
	 JRST ULKWAT		;No, back out and wait for Ack
	CALL BLDDAT		;Yes, build virgin Data packet
	 JRST ULKWAT		;Failed to allocate space
	MOVEM T1,FILCNT(JFN)	;Store byte count
	MOVEM T2,FILBYT(JFN)	;Store byte pointer
	CALL ULKBSP		;Unlock port
	HRRZ T1,PUPSOB		;Recover the new byte
	JRST PUPSQL		;Back to store it

; Get status (GDSTS)
;	User 3/ Size ,, address of block to return foreign port
;		address table in (see PUPNM), or 0 to omit table
; Returns +1:
;	T1/ BSP status word (to be returned to user ac2)
;	User 3/ size of address table ,, unchanged

PUPGST:	TQNN <OPNF>		;Make sure open
	 JRST [	SETZ T1,	;Not open, return zero status
		XCTU [HRRZS 3]	;Zero address count
		RET]
	HLRZ UNIT,FILSKT(JFN)	;Get Pup unit #
	CALL LCKBSQ		;Lock port if BSP
	 CAI			;Not BSP
	UMOVE E,3		;Get user block pointer
	JUMPLE E,PUPGS2		;Omit if none
	HLRZ T4,E		;Get count
	SKIPN T2,PUPFPT(UNIT)	;Have address table?
	 JRST [	SETZ T1,	;No, make zero net/host
		HRLI E,T1	;Make BLT "from" address
		MOVEI T3,2	;Size is 2
		JRST PUPGS1]
	HLRE T3,T2		;Yes, get -count
	MOVN T3,T3		;Make positive
	HRLI E,1(T2)		;Make BLT "from" address
PUPGS1:	XCTU [HRLM T3,3]	;Return count
	CAILE T3,(T4)		;Have more than user wants?
	 MOVEI T3,(T4)		;Yes, take minimum
	MOVE T1,T3		;Length
	HLRZ T2,E		;Source
	HRRZ T3,E		;Destination
	CALL BLTMU1		;Copy to user
;???	XBLTMU [BLT E,-1(T3)]	;Copy address table to user
PUPGS2:	MOVE T1,PUPSTS(UNIT)	;Get status
	CALL ULKBSQ		;Unlock port if BSP
	RET    


; Set status (SDSTS)
;	T1/ BSP status word to set (from user ac2)
; Returns +1

PUPSST:	HLRZ UNIT,FILSKT(JFN)	;Get Pup unit #
	CALL LCKBSQ		;Lock port if BSP
	 CAI			;Not BSP
	MOVE T2,T1		;Copy new status
	AND T1,BSSETB		;Mask bits user may set
	IOR IOS,T1		;Set them
	ANDCA T2,BSCLRB		;Mask bits user may clear
	ANDCM IOS,T2		;Clear them
	TXNN IOS,BSMRKF!BSENDF   ; Mark and end flags now clear?
	 TQZ <EOFF>		;Yes, clear jfn EOF flag
	TXNN IOS,BSTIMF  	;Timeout flag now clear?
	 TQZ <ERRF>		;Yes, clear jfn error flag
	CALL ULKBSQ		;Unlock port if BSP
	RET    

BSSETB:	BSNCHK+DSCRNF		;Bits that user may set
BSCLRB:	BSMRKF!BSTIMF!BSNCHK+DSCRNF  ; Bits that user may clear

; Miscellaneous JSYS routines not dispatched through the standard
;  dispatch mechanism (PUPDTB)

; Convert jfn to absolute network socket number
; Call:	1	;Jfn
;	CVSKT
; Returns
;	+1	;Error
;	+2	;Ok, in 2 the absolute socket number

CVSKTP::MCENT
	UMOVE JFN,1
	CALL CHKJFN
	 JRST CVSER0
	 JRST CVSER0
	 JRST CVSER0
	HLRZ T1,FILNEN(JFN)
	HRLI T1,(<POINT 7,0,35>)
	HRRZ T2,FILDEV(JFN)	;Get device
	CAIN T2,PUPDTB		;Is it a PUP JFN?
	 JRST CVPSKT		;Yes, convert it

CVSER1:	CALL UNLCKF
	SKIPA T1,[CVSKX2]
CVSER0:	MOVEI T1,CVSKX1
	JRST MRETNE

; Return local port address (including absolute socket #) (CVSKT)
;	JFN (etc.)/ already setup (see .CVSKT in NETWRK)
;	T1/ string ptr to filename string
; Returns +1 to user:  Unsuccessful, 1/ error #
;	+2 to user:  Successful,
;		user 2/ net ,, host
;		user 3/ socket

CVPSKT::TQNN <OPNF>		;Open?
	 JRST [	CALL PNMDEC	;No, just decode filename
		 ERUNLK(CVSKX2)	;Failed (net dir changed?)
		JRST CVPSK1]
	HLRZ UNIT,FILSKT(JFN)	;Yes, get Pup unit #
	MOVE T1,PUPLNH(UNIT)	;Pick up local net/host
	MOVE T2,PUPLSK(UNIT)	; and socket
CVPSK1:	UMOVEM T2,3		;Return socket in 3
	LSHC T1,-^D<36-8>	;Reformat net/host to net,,host
	LSH T1,^D<18-8>
	LSHC T1,^D8
	UMOVEM T1,2		;Return net,,host in 2
	CALL UNLCKF
	JRST SKMRTN		;Skip return to user

DEFINE ATPERR(ERRORN,EXTRA) <ERROR(ERRORN,<EXTRA>,ATPER4)>

; Attach sockets to pty
; Call:	1	;Receive jfn of opened network connection
;	2	;Send jfn of opened network connection
;	ATNVT
; Returns
;	+1	;Cannot attach
;	+2	;Ok.  the jfns are released, ac 1 has line number of
;		;Attached pty.

ATNVTP::MCENT
	UMOVE JFN,1
	HRRZS JFN
	CALL CHKJFN		;Check jfn of receive connection
	 JRST ATPER0		;Only real jfns are legal
	 JRST ATPER0
	 JRST ATPER0
	MOVEI T1,ATNX2		;Error code if test skips
	TQNE <READF>		;MUST BE OPENED FOR READING
	CALL CHKATP		;Check for dev=net, open, no buffer
	 JRST ATPER1		;Failed one of the above
	HLRZ UNIT,FILSKT(JFN)
	PUSH P,UNIT		;SAVE DEV AND JFN
	PUSH P,JFN
ATNVT1:	UMOVE JFN,2		;Get send jfn
	CALL CHKJFN		;Check it
	JRST ATPER2		;Must also be a real jfn
	JRST ATPER2
	JRST ATPER2
	MOVEI T1,ATNX2		;Becomes atNx8 at atper3
	TQNE <WRTF>		;THIS ONE MUST BE FOR WRITING
	CALL CHKATP		;And dev=net, open, no buffer
	 JRST ATPER3		;Failed above tests
	HLRZ UNIT,FILSKT(JFN)

; Attach port to Pup NVT (ATPTY)
;	JFN/ Send JFN  (see .ATPTY in NETWRK)
;	DEV/ Send DEV
;	UNIT/ Send UNIT
;	0(P)/ Receive JFN
;	-1(P) Receive DEV
; Both JFN's locked and verified to be open Pup JFN's
; Returns +1 to user:  Error, 1/ error code
;	+2 to user:  Success, 1/ Attached TTY designator, JFN's released

	MOVE T1,0(P)		;Get send JFN
	HLRZ T1,FILSKT(T1)	;Get send unit nbr
	HLRZ T2,FILSKT(JFN)	;Get rcv unit nbr
	CAME T1,T2		;Both JFNs point to same port?
	 ATPERR(ATNX15)		;No, fail
	CALL LCKBSQ		;Yes, attempt to lock it
	 ATPERR(ATNX16)		;Not BSP port, fail
	CHKSTT <OPEN>		;Connection must be open
	 ATPERR(ATNX17,<CALL ULKBSP>)  ; Not, fail
	CALL ASPNVT		;Assign Pup NVT
	 ATPERR(ATNX13,<CALL ULKBSP>)  ; None available, fail
	MOVEI T1,400000(T2)	;Convert line # to TTY designator
	UMOVEM T1,1		;Return it to user
	MOVE T1,FILBYT(JFN)	;Get ptr to last byte stored
	CALL DMPBSP		;Force out partial Pup if any
	CALL ULKBSP		;Unlock port
	CALL RELJFN		;Release send JFN
	POP P,JFN
	CALL RELJFN		;Release receive JFN
	JRST SKMRTN		;Skip return to user

; Check validity of jfn for atpty

CHKATP:	MOVEI T1,ATNX3		;Receive not open
	TQNN <OPNF>		;IS IT OPEN?
	RET    			;NO
	HRRZ T2,FILDEV(JFN)
	MOVEI T1,ATNX4
	CAIN T2,PUPDTB
	AOS 0(P)
	RET    

ATPER2:	MOVEI T1,ATNX7		;Bad send jfn
	JRST ATPER5

ATPER3:	ADDI T1,ATNX7-ATNX1	;Convert receive errors to send errors
ATPER4:	CALL UNLCKF
ATPER5:	MOVE JFN,0(P)		;GET RECIEV JFN
	MOVE STS,FILSTS(JFN)
ATPER1:	CALL UNLCKF
	JRST MRETNE		;Save error return in ac1

ATPER0:	MOVEI T1,ATNX1		;Bad receive jfn
	JRST MRETNE
; Dismiss until input buffer empty (DIBE)
;	JFN (etc.)/ already setup (see .DIBE in JSYS)
; Returns +1

PUDIBE::CALL CHKPUP		;Make sure this is a PUP jfn
	 RET			;No, return
	AOS (P)			;At least a 1 skip return
	CALL CHKBSP		;Check for good BSP JFN
	 JRST UNLCKF		;Not, ignore
	 JRST [ MOVEI T1,IOX5
		CALL DOINT
		CALL UNLCKF
		RET ]		;Bad state, give i/o data error
	HRRZ T1,BSPIQL(BSP)	;Any input bytes queued?
	JUMPE T1,ULKBSP		;Return now if none
	MOVEI T1,PDIBET		;Yes, set scheduler test
	HRLI T1,(UNIT)
	TXO IOS,BSINPF  	;Flag that input is queued
	CALL ULKWAT		;Back out and wait
;??? *** Warning: The next statememt is never reached as ULKWAT never returns
	JRST UNLCKF		;Unlock jfn

	RESCD

; Scheduler test for input buffer empty (or error)
; Arg is Pup unit index

PDIBET:	MOVE T2,PUPSTS(T1)	;Get port status word
	TXNE T2,BSINPF  	;Input buffer empty?
	 TXNE T2,BSTIMF!BSERRF	;No, error?
	 JRST 1(T4)		;Yes, wakeup
	JRST 0(T4)		;No, wait

	SWAPCD

; Dismiss until output buffer empty (DOBE)
;	JFN (etc.)/ already setup (see .DOBE in JSYS)
; Returns +1

PUDOBE::CALL CHKPUP		;Make sure this is a PUP jfn
	 RET			;No, return
	AOS (P)			;At least a 1 skip return
	CALL CHKBSP		;Check for good BSP JFN
	 JRST UNLCKF		;Not, ignore
	 FILINT(IOX5)		;Bad state, give i/o data error
	TQNN <WRTF>		;Open for writing?
	 FILABT(IOX2,<CALL ULKBSP>)  ; No, generate instruction trap
	CHKSTT <OPEN,ENDI>	;Check for reasonable state
	 JRST [	TQO <ERRF>	;Bad, give error
		RET]
	MOVE T1,FILBYT(JFN)	;Get ptr to last byte stored
	CALL FRCBSP		;Force out partial Pup if any
	SETZM FILCNT(JFN)	;Zero byte count
	CALL CHKBOQ		;Check for empty output queue
	 JRST ULKWAT		;Not empty, back out and wait
	CALL ULKBSP		;Empty, done
	JRST UNLCKF		;Unlock file

; Skip if input buffer empty (SIBE)
;	JFN (etc.)/ already setup (see .SIBE in JSYS)
; Returns +1:  Not empty, T1/ # of buffered bytes
;	+2:  Empty

PUSIBE::CALL CHKPUP		;Make sure this is a PUP jfn
	 RET			;No, return
	AOS (P)			;At least a 1 skip return
	CALL CHKBSP		;Check for good BSP JFN
	 JRST [ CALL UNLCKF	;Unlock JFN
		RETSKP ]	;Not, give empty return
	 JRST [ CALL UNLCKF
		RETSKP ]	;Bad state, give empty return
	HRRZ T1,BSPIQL(BSP)	;Get # of input bytes available
	SKIPL FILCNT(JFN)	;Any bytes in current buffer?
	 ADD T1,FILCNT(JFN)	;Yes, include those too
	SKIPG T1		;Any bytes available?
	 AOS 0(P)		;No, preset skip return
	CALL ULKBSP		;Unlock port and return
	JRST UNLCKF


; Skip if output buffer empty (SOBE)
;	JFN (etc.)/ already setup (see .SOBE in JSYS)
; Returns +1: Not a pup jfn
;	  +2:  Not empty, T1/ # of buffered bytes
;	  +3:  Empty

PUSOBE::CALL CHKPUP		;Make sure this is a PUP jfn
	 RET			;No, return
	AOS (P)			;At least a 1 skip return
	CALL CHKBSP		;Check for good BSP JFN
	 JRST [	CALL UNLCKF
		RETSKP ]	;Not, give empty return
	 JRST [	CALL UNLCKF
		RETSKP ]	;Bad state, give empty return
	HRRZ T1,BSPOQL(BSP)	;Get # of output bytes pending
	SKIPG T1		;Are there any?
	 AOS 0(P)		;No, preset skip return
	CALL ULKBSP		;Unlock port and return
	JRST UNLCKF


; Skip if output buffer full (SOBF)
;	JFN (etc.)/ already setup (see .SOBF in JSYS)
; Returns +1:  Not full (i.e. can output more bytes)
;	+2:  Full (next byte output would block you)
;		T1/ # of buffered bytes, on either return

PUSOBF::CALL CHKPUP		;Make sure this is a PUP jfn
	 RET			;No, return
	AOS (P)			;At least a 1 skip return
	CALL CHKBSP		;Check for good BSP JFN
	 CAI			;Not, give not full return
	 JRST [	CALL UNLCKF
		SETZ T1,	;Bad state, give not full return
		RET]
	SKIPLE FILCNT(JFN)	;Room in current buffer?
	 JRST .+3		;Yes
	CALL CHKBSO		;No, check for BSP output possible
	 AOS 0(P)		;Not possible, preset skip return
	HRRZ T1,BSPOQL(BSP)	;Return # of output bytes pending
	CALL ULKBSP		;Unlock port and return
	JRST UNLCKF


CHKPUP:	PUSH P,T1		;Save A
	CALL CHKJFN		;See if valid pupjfn
	 JRST CHKPU1		;no
	 JRST CHKPU1		;no
	 JRST CHKPU1		;no
	HRRZ T1,FILDEV(JFN)	;Get DTB
	CAIN T1,PUPDTB		;Is it a PUP
	 AOS -1(P)		;yes
CHKPU1:	POP P,T1
	RET


; Set Pup routing table entry (PUPROU function of OPRFN)
;	T2/ Net number
;	T3/ Mask of bits to change
;	T4/ New value of those bits
; Returns +1:  Error (OPRFX2 code in ac1)
;	+2: Successful
;	user ac4/ Value of routing table entry (updated)
; Note: to read the existing contents of an entry, just use a zero mask
;(On 2020, OPRFN jsys simulated via SMON jsys which has no skip return)

SETRTE::UMOVE T2,2
	UMOVE T3,3
	UMOVE T4,4
	CAIL T2,1		;Make sure net number in range
	CAILE T2,NPNETS
	 ITERR(SMONX2)
	NOSKED
	AND T4,T3		;Mask bits to be changed
	ANDCA T3,PUPROU-1(T2)	;Mask bits to be retained
	IOR T4,T3		;Combine
	MOVEM T4,PUPROU-1(T2)	;Put back in routing table
	OKSKED
	UMOVEM T4,4		;Give back to caller
	JRST MRETN		;Succede

; Pup device-dependent operations (MTOPR)
;	JFN (etc.)/ already setup
;	T2/ operation
; Returns +1 always;  results depend on operation.

PUPMTP:	TQNN <OPNF>		;Open?
	 RETSKP			;No, do nothing
	CAIN T2,3		;Write eof?
	 MOVEI T2,20		;Yes, use different index
	CAIL T2,20		;Defined operation?
	CAIL T2,20+PUPMTN
	 RETSKP			;No, do nothing
	HLRZ UNIT,FILSKT(JFN)	;Setup Pup unit #
	MOVE T1,PUPMTT-20(T2)	;Get dispatch
	JUMPGE T1,[CALL 0(T1)	;Dispatch if BSP not required
		RETSKP ]
	CALL LCKBSQ		;See if BSP port, lock if so
	 RETSKP			;Not, do nothing
	TXNN T1,1B1  		;Do errors matter?
	 JRST [	CALL 0(T1)	;No, just dispatch
		CALL ULKBSP
		RETSKP ]	;Unlock port and return
	TXNN IOS,BSTIMF  	;Yes, timeout?
	 CALL 0(T1)		;No, do operation
	TXNE IOS,BSTIMF  	;Timeout?
	 TQO <ERRF>		;Yes, set error flag
	CALL ULKBSP		;Unlock port
	TQNE <ERRF>		;Error flag set?
	 FILINT(IOX5)		;Yes, give i/o data error psi
	RETSKP

; Pup MTOPR dispatch table
; B0 set =) port required to be open in BSP mode
; B1 set =) generate error psi on timeout
PUPMTT:	1B0+1B1+MTSMRK		;20 (really 3) send Mark
	1B0+1B1+MTFORC		;21 Force transmission of partial Pup
	1B0+1B1+MTSINT		;22 Send Interrupt
	1B0+MTGMRK		;23 Return most recent Mark byte
	EXP MTAINT		;24 Assign interrupt channels
	1B0+MTSABT		;25 Abort connection
	1B0+MTGABT		;26 Return Abort data

PUPMTN==.-PUPMTT	;Number of defined functions


; Send Mark (MTOPR function 3)
;	3/ Mark byte

MTSMRK:	TQNN <WRTF>		;Open for writing?
	 FILABT(IOX2,<CALL ULKBSP>)  ; No, generate instruction trap
	CHKSTT <OPEN,ENDI>	;Check for reasonable state
	 JRST [ TQO <ERRF>	;Bad, give error
		RET]
	MOVE T1,FILBYT(JFN)	;Get ptr to last byte stored
	CALL DMPBSP		;Dump partial Pup if any
	SETZM FILCNT(JFN)	;Zero byte count
	UMOVE T1,3		;Get Mark byte from user
	CALL SNDMRK		;Send Mark
	 JRST ULKWAT		;Can't, back out and wait for Ack
	RET


; Get content byte of most recently received Mark (MTOPR function 23)
; Returns user 3/ Mark byte

MTGMRK:	LDB T1,PBSMRK		;Get the byte
	UMOVEM T1,3		;Return byte to user
	RET

; MTOPR routines (cont'd)

; Force out partial Pup (MTOPR function 21)

MTFORC:	TQNN <WRTF>		;Open for writing?
	 FILABT(IOX2,<CALL ULKBSP>)  ; No, generate instruction trap
	CHKSTT <OPEN,ENDI>	;Check for reasonable state
	 JRST [ TQO <ERRF>	;Bad, give error
		RET]
	MOVE T1,FILBYT(JFN)	;Get ptr to last byte stored
	CALL DMPBSP		;Force out partial Pup if any
	SETZM FILCNT(JFN)	;Zero byte count
	RET


; Send Interrupt (MTOPR function 22)
;	3/ Interrupt code
;	4/ If nonzero, string ptr to Interrupt text

MTSINT:	CHKSTT <OPEN,ENDI,ENDO>  ; Check for reasonable state
	 JRST [ TQO <ERRF>	;Bad, give error
		RET]
	UMOVE T1,3		;Get code
	UMOVE T2,4		;Get string ptr if any
	CALL SNDINT		;Send Interrupt
	 JRST ULKWAT		;Can't, back out and wait
	RET


; Assign interrupt channels (MTOPR function 24)
;	3/ B0-5:   "Interrupt" PSI channel ( )35 =) disable)
;	   B6-11:  "Received Pup" PSI channel
;	   B12-17: "State Change" PSI channel

MTAINT:	UMOVE T1,3		;Get user arg
	HRR T1,FORKX		;Direct interrupts to this fork
	MOVEM T1,PUPPSI(UNIT)	;Store in table
	RET


; Abort connection
;	3/ Abort code
;	4/ If nonzero, string ptr to Abort text

MTSABT:	MOVEI T1,E.CLST		;Generate CLOSF(T) event
	XCTU [HRRZ T3,3]	;Get Abort Code (lh=0 =) user call)
	UMOVE T4,4		;Get string ptr to text if any
	CALL PUPFSM		;Activate the FSM
	SETZM FILCNT(JFN)	;No further i/o
	RET


; Get Abort data
;	4/ If nonzero, string ptr to store Abort text
; Returns 3/ Abort code, 4/ updated pointer

MTGABT:	HRRZ PB,BSPTIM(BSP)	;Get ptr to saved Abort
	JUMPE PB,CPOPJ		;Do nothing if none
	LDB T1,[POINT 16,PBCONT(PB),15]  ; Get Abort Code
	UMOVEM T1,3		;Give to user
	UMOVE T4,4		;Get user string ptr
	JUMPE T4,CPOPJ		;Stop here if none
	TLC T4,-1		;Fix -1 lh
	TLCN T4,-1
	 HRLI T4,(POINT 7)
	LDB T3,PUPLEN		;Get Pup Length
	SUBI T3,MNPLEN+2	;Subtract overhead
	JUMPLE T3,MTGAB2	;Jump if none
	MOVE T2,[POINT 8,PBCONT(PB),15]	;Init byte ptr
MTGAB1:	ILDB T1,T2		;Get byte from packet
	XCTBU [IDPB T1,D]	;Give to user
	SOJG T3,MTGAB1		;Repeat until exhausted
MTGAB2:	UMOVEM T4,4		;Return updated pointer
	XCTBU [IDPB T3,D]	;Append null
	RET

; Decode Pup name string
;	T1/ String pointer to name
; Returns +1:  Unsuccessful
;	+2:  Successful:
;		T1/ <net>B7 + <host>B15 (0 =) wildcard)
;		T2/ socket (right-justified)
; Clobbers T1-T4

	ADRBSZ==^D20	;Size of address block to allocate

PNMDEC:	MOVEI T2,1(P)		;Set address tbl loc for PUPNM
	ADJSP P,ADRBSZ		;Allocate space on stack
	JUMPGE P,MSTKOV		;Check for overflow
	MOVEM T1,0(P)		;Save string ptr
	MOVEI T4,"U"		;Default mode is user-relative
	ILDB T3,T1		;Get first char
	CAIE T3,0		;Empty string?
	CAIN T3,"!"		;Or just mode specifier?
	 JRST [	SETZM 0(T2)	;Yes, default all fields
		SETZM 1(T2)
		HRLI T2,2	;Say just one address input
		JRST PNMDE1]	;Handle mode if any
	MOVE T1,0(P)		;Non-null, recover string ptr
	HRLI T2,(1B0+<ADRBSZ>B17)  ; Name to address, set size
	PUPNM%			;Translate string to address(es)
	 JRST PNMDE9		;Error
	LDB T3,T1		;Ok, get terminator
PNMDE1:	CAIE T3,"!"		;Mode being given?
	 JRST PNMDE2		;No
	ILDB T4,T1		;Yes, get mode specifier
	JUMPE T4,PNMDE9		;Make sure not null
	ILDB T3,T1		;Get terminator
PNMDE2:	JUMPN T3,PNMDE9		;Error if non-null
	HLRZ T3,T2		;Ok, get returned adr tbl length
	CAIG T3,ADRBSZ		;Make sure block was big enough
	 JRST .+3		;Yes
	 BUG(PNMDEA)
	MOVEI T3,ADRBSZ		;Use only what we have
	MOVN T3,T3		;Negate
	HRLI T2,(T3)		;Make AOBJN ptr to address table

; Now have T2/ -length,,address of address table
; T4/ Mode character for local socket defaulting (not yet checked).
; Now compute the absolute local socket on the basis of the first
;  entry in the address table
	SKIPN T1,1(T2)		;Get local socket from first entry
	 JRST [	MOVEI T1,(JFN)	;Zero, default to 8*JFN
		PUSH P,A+1	;SAVE FROM EFFECT OF DIVIDE
		IDIVI T1,MLJFN	;CONVERT FROM INTERNAL FORMAT
		LSH T1,3	;GET 8*JFN
		POP P,A+1	;RESTORE CLOBBERED AC
		JRST PNMDE3]	;Make user- or job-relative
	CAIN T4,"A"		;Want absolute socket?
	 JRST PNMDE5		;Yes, skip following
PNMDE3:	CAIE T4,"J"		;Want job or user-relative?
	CAIN T4,"U"
	 CAILE T1,77777		;Yes, can only specify these bits
	 JRST PNMDE9		;Bad
	CAIN T4,"J"
	 JRST [	MOVE T3,JOBNO	;Job-relative, get job number
		ADDI T3,^D100000 ;Add offset
		JRST PNMDE4]
   IFE SUMXSW,<
	MOVE T3,JOBNO		;User-relative, get fork number
	HLRZ T3,JOBDIR(T3)	;Connected,,login dir
   > ;IFE SUMXSW
   IFN SUMXSW,<HRRZ T3,JSBSDN>	;Get connected directory from JSB
PNMDE4:	LSH T3,^D15		;Use this for high-order bits
	IOR T1,T3

; PNMDEC (cont'd)

; Now T1/ absolute local socket, T2/ -length,,adr of address table.
; Scan the address table and (1) make sure that any nonzero
;  net/host entries specify a real Maxc address, (2) make sure
;  all socket specifications are the same, and (3) make net/host
;  wildcard if appropriate.
PNMDE5:	MOVE T3,1(T2)		;Get socket # of this entry
	CAME T3,-ADRBSZ+2(P)	;Consistent with first?
	 JRST PNMDE9		;No, bad
	SKIPN T3,0(T2)		;Get specified net/host
	 JRST PNMDE7		;Zero means default, always ok
	HLRZ T4,T3		;Get net
	CAIL T4,1		;Check bounds
	CAILE T4,NPNETS
	 JRST PNMDE9		;Bad
	HRRZ T4,PUPROU-1(T4)	;Ok, get Maxc adr on net
	JUMPE T4,PNMDE9		;Bad if Maxc not on that net
	TXNN T3,-1		;Host specified?
	 JRST [	HRRM T4,0(T2)	;No, substitute default
		JRST PNMDE7]
	CAIE T4,(T3)		;Yes, correct?
	 JRST PNMDE9		;No, bad
PNMDE7:	MOVE T3,0(T2)		;This net/host same as first?
	CAME T3,-ADRBSZ+1(P)
	 SETZM -ADRBSZ+1(P)	;No, make fully wildcard
	AOBJN T2,.+1		;Repeat for all adr tbl entries
	AOBJN T2,PNMDE5
	MOVE T3,-ADRBSZ+1(P)	;Done, get resulting net/host
	SETZ T2,		;Convert to <net>B7 + <host>B15
	ROTC T2,-8
	LSH T3,-^D<18-8>
	ROTC T2,-8
	EXCH T1,T2		;Net/host to T1, socket to B
	AOS -ADRBSZ(P)		;Preset skip return

; Here to fail return from PNMDEC
PNMDE9:	ADJSP P,-ADRBSZ		;Flush address table
	RET    			;Non-skip return

; Decode Pup extension string
;	T1/ String pointer to name
; Returns +1:  Unsuccessful
;	+2:  Successful, T1/ -Used length,,address of address block
;		(note the rh points to the header word -- the
;		address table starts at 1(T1))
; Clobbers T1-T4

PEXDEC:	PUSH P,T1		;Save string ptr
	MOVEI T2,ADRBSZ+1	;Allocate space for address table
	CALL ASGPFR
	 JRST [	POP P,T1	;No room, fail
		RET]
	MOVEI T2,1(T1)		;Set address tbl loc for PUPNM
	EXCH T1,0(P)		;Save pointer, get back string
	MOVE T4,T1		;Copy string ptr
	ILDB T3,T4		;Get first char
	JUMPE T3,[SETZM 0(T2)	;If null, default all fields
		SETZM 1(T2)
		HRLI T2,2	;Say just one address input
		JRST PEXDE1]	;Go exit
	HRLI T2,(1B0+<ADRBSZ>B17)  ; Name to address, set size
	PUPNM%			;Translate string to address(es)
	 JRST PEXDE9		;Error
	LDB T3,T1		;Ok, get terminator
	JUMPN T3,PEXDE9		;Error if non-null
PEXDE1:	HLRZ T2,T2		;Ok, get returned adr tbl length
	CAIG T2,ADRBSZ		;Make sure block was big enough
	 JRST PEXDE2		;Yes
	 BUG(PEXDEA)
	MOVEI T2,ADRBSZ		;Use only what we have
PEXDE2:	MOVN T1,T2		;Negate
	HRLM T1,0(P)		;Make AOBJN ptr to address table
	HRRZ T1,0(P)		;Get pointer to block
	MOVEI T2,1(T2)		;Include overhead in size
	CALL TRMPFR		;Trim block to required size
	POP P,T1		;Get AOBJN ptr to address table
	RETSKP			;Done, take skip return

; Here to fail return from PEXDEC
PEXDE9:	POP P,T2		;Release address block
	CALL RELPFR
	RET    			;Fail return

; Check for open BSP port in good state
;	JFN/ Pup JFN (locked at JSYS level)
; Returns +1:  Not open or not BSP port
;	+2:  BSP port but timed out or in bad state (Closed, Abort)
;	+3:  Ok, port locked

CHKBSP:	HLRZ UNIT,FILSKT(JFN)	;Get Pup unit #
	TQNE <OPNF>		;File open?
	 CALL LCKBSQ		;Yes, check for BSP and lock it
	 RET			;Not open or not BSP, return +1
	TXNE IOS,BSTIMF!BSERRF    ; Open, in good state?
	 JRST [	CALL ULKBSP	;No, unlock port
		TQO <ERRF>	;CS36?? Report error
		RETSKP	]	;Return +2
	JRST SK2RET		;Yes, return +3


; Unlock BSP port, unlock file, and wait for some condition
;	T1/ EDISMS argument word
; Does not return to caller, but rather backs up the user PC
;  and returns to the caller of the JSYS, hence causing the
;  JSYS to be started over.

ULKWAT:	CALL ULKBSP		;Unlock the port


; Unlock file and wait for some condition
;	T1/ EDISMS argument word
; Does not return to caller, but rather backs up the user PC
;  and returns to the caller of the JSYS, hence causing the
;  JSYS to be started over.

BAKWAT:	CALL UNLCKF		;Unlock file, go OKINT
	MDISMS			;Dismiss until condition satisfied
	MOVE P,MPP		;Flush to top of monitor stack
	MOVE T1,-1(P)		;Get return PC
	HRRI T1,-1(T1)		;Back it up, avoiding carries
	MOVEM T1,-1(P)
	JRST MRETN		;Return from JSYS, start it over


; -----------------------------------------------------------------
;	JSYSes for Raw Packet I/O
; -----------------------------------------------------------------


; Input Pup in raw packet mode
;	1/	B0: Never dismiss for I/O, give PUPX3 error instead
;		B1: Check Pup Checksum, give PUPX5 error if bad
;		B2: Perform source address check, give PUPX7 error
;		    if incorrect
;		RH: JFN for port open in raw packet mode
;	2/	LH: Length of user block (36-bit words)
;		RH: Address of user block
; Returns +1:  Unsuccessful, 1/ Error #
;	+2:  Successful

.PUPI::	MCENT			;Enter jsys context
	CALL SETRAW		;Setup and check arguments
	 TQNN <READF>
	 ERUNLK(IOX1)		;Not open for reading
	CALL GETPUP		;Get Pup from input queue
	 JRST WATRAW		;Empty, back out and wait for input
	LDB T1,PUPLEN		;Get Pup Length in bytes
	ADDI T1,3		;Convert to words
	LSH T1,-2
	CAILE T4,(T1)		;User want more than we have?
	 MOVEI T4,(T1)		;Yes, cut him down to size
	PUSH P,T1		;Save pup size
	MOVE T1,T4		;Length
	MOVEI T2,PBHEAD(PB)	;Source
	HRRZ T3,E		;Dest (user)
	CALL BLTMU1		;CS36 Transfer to user
	POP P,T1		;Restore for check
	CAIGE T4,(T1)		;Was user block big enough?
	 ERUNLK(PUPX1,<CALL RELPKT>)  ; No, give error
	TXNN E,1B1  		;Want checksum checked?
	 JRST .+3		;No
	CALL CHKCKS		;Yes, check the checksum
	 ERUNLK(PUPX5,<CALL RELPKT>)  ; Checksum incorrect
	TXNN E,1B2  		;Want source address check?
	 JRST .+3		;No
	CALL CHKSRC		;Yes, check for correct source adr
	 ERUNLK(PUPX7,<CALL RELPKT>)  ; Source address incorrect
	CALL RELPKT		;All ok, release the buffer
	CALL UNLCKF		;Unlock file
	JRST SKMRTN		;Skip return to user

; Output Pup in raw packet mode
;	T1/	B0: Never dismiss for I/O, give PUPX3 error instead
;		B1: Compute Pup Checksum
;		RH: JFN for port open in raw packet mode
;	T2/	LH: Length of user block (36-bit words)
;		RH: Address of user block
; Returns +1:  Unsuccessful, 1/ Error #
;	+2:  Successful

.PUPO::	MCENT
	CALL SETRAW		;Setup and check arguments
	 TQNN <WRTF>
	 ERUNLK(IOX2)		;Not open for writing
	MOVEI PB,-PBHEAD(E)	;Offset for looking at Pup header
	XCTBMU [LDB T1,PUPLEN]	;Fetch Pup Length
	CAIL T1,MNPLEN		;Check for legal length
	CAILE T1,MXPLEN
	 ERUNLK(PUPX1)		;Size error
	ADDI T1,3		;Compute # 36-bit words
	LSH T1,-2
	CAILE T1,(T4)		;Check length consistency
	 ERUNLK(PUPX1)		;User block too short for Pup length
	ADDI T1,PBHEAD		;Ok, include overhead in size
	CALL CHKOQL		;See if this much can be queued
	 JRST WATRAW		;No, wait until queue less full
	MOVEI T2,(T1)		;Ok, get size
	CALL ASGPKT		;Allocate packet buffer
	 JRST WATRAW		;Can't, back out and wait for space
	HRRZ T1,PBSIZE(PB)	;Number of words
	SUBI T1,PBHEAD		;Minus header
	HRRZ T2,E		;Source (user)
	MOVEI T3,PBHEAD(PB)	;Destination PUP buffer
	CALL BLTUM1		;Copy it

; Check that the Pup source is consistent with the local port
; and Maxc's network address, and default elements where necessary.
	LDB T1,PPUPSN		;Get source net from Pup
	LDB T2,PPRTLN		;Get local net from port
	JUMPN T1,.+3		;Net specified in Pup?
	MOVE T1,T2		;No, get from port specification
	DPB T1,PPUPSN		;Default source net in Pup
	CAME T1,T2		;Pup and port agree?
	 JUMPN T2,PUPOAE	;No, fail if port not wildcard
	CAIL T1,1		;Net in range?
	 CAILE T1,NPNETS
	 ERUNLK(PUPX2,<CALL RELPKT>)  ; No, give address error
	HRRZ T3,PUPROU-1(T1)	;Yes, get Maxc address on net
	JUMPE T3,PUPOAE		;Fail if not on net

	LDB T1,PPUPSH		;Get source host from Pup
	LDB T2,PPRTLH		;Get local host from port
	JUMPE T1,.+3		;Host specified in Pup?
	CAME T1,T3		;Yes, agree with Maxc address?
	 ERUNLK(PUPX2,<CALL RELPKT>)  ; No, give address error
	JUMPE T2,.+3		;Host specified in port?
	CAME T2,T3		;Yes, agree with Maxc address?
	 ERUNLK(PUPX2,<CALL RELPKT>)  ; No, give address error
	DPB T3,PPUPSH		;Deposit required Maxc host #

	LDB T1,PPUPSS		;Get source socket from Pup
	JUMPN T1,.+3		;Socket specified in Pup?
	MOVE T1,PUPLSK(UNIT)	;No, get local socket from port
	DPB T1,PPUPSS		;Default source socket in Pup
	CAME T1,PUPLSK(UNIT)	;Pup and port agree?
PUPOAE:	 ERUNLK(PUPX2,<CALL RELPKT>)  ; No, give address error

; PUPO (cont'd)

; Substitute defaults for zero elements in the Pup destination
	SKIPE T4,PUPFPT(UNIT)	;Get foreign port descriptor
	CAMGE T4,[-2,,0]	;Multiple?
	 MOVEI T4,[EXP 0,0]-1	;Yes, can't default
	LDB T1,PPUPDN		;Destination net
	JUMPN T1,PUPO1		;Jump if specified
	HLRZ T1,1(T4)		;Unspecified, get default
	JUMPE T1,PUPOAE		;Error if multiple or wildcard
	DPB T1,PPUPDN		;Store replacement value
PUPO1:	CAIL T1,1		;Net number in bounds?
	CAILE T1,NPNETS
	 ERUNLK(PUPX2,<CALL RELPKT>)  ; No, give address error

	LDB T2,PPUPDH		;Destination host
	JUMPN T2,PUPO2		;Jump if specified
	HRRZ T2,1(T4)		;Unspecified, get default
	JUMPE T2,[MOVE T2,PUPROU-1(T1)  ; None, check net table
		TXNN T2,BROADF  	;Broadcast allowed?
		 ERUNLK(PUPX2,<CALL RELPKT>) ; No, give error
		JRST PUPO2]	;Yes, allow zero for dest host
	DPB T2,PPUPDH		;Store replacement value

PUPO2:	LDB T1,PPUPD0		;Destination socket
	MOVE T2,PBHEAD+3(PB)
	LSHC T1,^D16
	JUMPN T1,PUPO3		;Jump if specified
	MOVE T1,2(T4)		;Unspecified, get default
	JUMPE T1,PUPOAE		;Error if multiple or wildcard
	DPB T1,PPUPD1		;Store replacement value
	LSH T1,-^D16
	DPB T1,PPUPD0

; Done defaulting address fields
; Compute checksum if required and queue the Pup for output
PUPO3:	TXNE E,1B1  		;Want checksum generated?
	 CALL SETCKS		;Yes, do so
	CALL PUOCNV		;Convert packet data (but not checksum)
	CALL PUTPUP		;Queue packet for output
	 JRST [	PUSH P,T1	;Can't, release buffer
		CALL RELPKT
		POP P,T1
		JRST WATRAW]	;Back out and wait
	CALL UNLCKF		;Unlock file
	JRST SKMRTN		;Skip return to user

; Common setup code for PUPI and PUPO
;	1/ User's ac1
; Returns +1:
;	UNIT/ Pup unit #
;	E/ lh: Flags (from lh of user's ac1)
;	   rh: Block location (from rh of user's ac2)
;	T4/ Block size (lh of user's ac2)
; Does not return if error

SETRAW:	HRRZ JFN,1		;Get JFN
	CALL CHKJFN		;Check it
	 RETERR()		;Bad JFN
	 ERUNLK(DESX4)		;TTY not legal
	 ERUNLK(DESX4)		;String pointer not legal
	TQNN <OPNF>		;Test file status
	 ERUNLK(DESX5)		;Not open
	HRRZ T1,FILDEV(JFN)	;Check device
	CAIE T1,PUPDTB
	 ERUNLK(PUPX8)		;Not device PUP:
	MOVE T1,STS		;Check mode
	ANDI T1,17
	CAIE T1,16
	 ERUNLK(PUPX6)		;Not open in mode 16
	UMOVE E,2		;Get user block length,,adr
	HLRE T4,E		;Isolate length
	XCTU [HLL E,1]		;Put flags in lh of E
	MOVEI T1,(E)		;Copy block address
	ADDI T1,-1(T4)		;Compute last address
	CAIL T4,<MNPLEN+3>/4	;Error if smaller than Pup header
	CAILE T1,777777		;Error if cross end of memory
	 ERUNLK(PUPX1)		;Size error
	HLRZ UNIT,FILSKT(JFN)	;Get Pup unit
	RET    


; Common code to unlock file, go OKINT, dismiss for some condition,
;  then back up the PC and return to the user in such a way that
;  the JSYS will be started over
;	T1/ EDISMS argument word (test data,,test routine)

WATRAW:	JUMPGE E,BAKWAT		;Allowed to dismiss?
	ERUNLK(PUPX3)		;No, give error return

; -----------------------------------------------------------------
;	Pup Background Process, Initialization, Bug Reporting
; -----------------------------------------------------------------


; Routine to start Pup background process
; Called only once (from SWPMON during system initialization)
; Returns +1
; Clobbers T1, B

PUPBEG::MOVX T1,CR%CAP		;Transmit capabilities
	CFORK			;Create fork
	 BUG(PUPBEA)
	MOVEI T2,PUPBAK		;Start in monitor mode
	MSFRK
	RET    


; Background process starts here

PUPBAK:	MCENTR			;Setup context
	SE1ENT			;Run in section one
	MOVE T1,[ITFPC,,PUPUXI]	;Trap fatal interrupts
	MOVEM T1,MONBK
	MOVE T1,CHNSON
	MOVEM T1,MONCHN
IFE PIESLC,<
	MOVEI T1,202		;Don't fall below Q2
	MOVEM T1,JOBBIT
>
IFN PIESLC,<
	CALL SETSPQ		;Always run on special queue
>
	CALL PUPINI		;Initialize all Pup data

	MOVE T1,FORKX		;Record our fork number
	MOVEM T1,PUPFRK
	CALL GETIRT		;Get and discard incremental runtime

; Main loop of background process
; Look for something to do
PUPBK1:	MOVE T1,PUPFLG		;Get flags
	JFFO T1,PUPBK2		;Any requests in?
	JSP T4,PUPBKT		;Re-check timers
	 JRST PUPBK3		;Nothing to do, go dismiss
	JRST PUPBK1		;Back to top of loop

; Here when have a request to process
; T2/ Flag bit position
PUPBK2:	MOVE T1,BITS(T2)	;Clear the bit
	ANDCAM T1,PUPFLG
	CAIL T2,PUPBKN		;Make sure task number in range
	 BUG(PUPBKA)
	PUSH P,T2		;Ok, save task number
	NOINT			;CS36??? So RELFRE works...
	CALL @PBKTAB(T2)	;Perform the task
	OKINT			;CS36 
	CALL GETIRT		;Get incremental runtime
	POP P,T2		;Restore task number
	ADDM T1,PBKTIM(T2)	;Accumulate time used by task
	AOS PBKCNT(T2)		;Count number of task executions
	JRST PUPBK1		;Loop

; Here on fatal interrupt
PUPUXI:	BUG(PUPBKB)
	SE1ENT
	MCENTR
	JRST PUPBK1		;Restart at top of loop

; Here when no more work to do
PUPBK3:	MOVE T1,TODCLK		;Get now
	ADDI T1,MINBWI		;Minimum background wait interval
	MOVEM T1,NXTWAK		;Set earliest time of next wakeup
	MOVEI T1,PUPBKT		;Scheduler test
	MDISMS			;Dismiss until something to do
	JRST PUPBK1		;Back to top of loop

	RESCD

; Scheduler test for Pup background process wakeup

PUPBKT:	MOVE T2,TODCLK		;Get now
	CAMGE T2,NXTWAK		;Has minimum wait period elapsed?
	 JRST 0(T4)		;No, don't wake up
	HRRZ T3,PUPTQH		;Get head of timer queue
	CAML T2,PUPTQD(T3)	;Time to service request?
	 JRST [	SIGPBP(BSP)	;Yes, set flag
		JRST 1(T4)]	;Wakeup
	CAML T2,SYNTIM		;Time to check syncs?
	 JRST [	SIGPBP(SYN)	;Yes, set flag
		JRST 1(T4)]	;Wakeup
	SKIPN PUPFLG		;Any requests in?
	 JRST 0(T4)		;No
	JRST 1(T4)		;Yes, wakeup

	SWAPCD

; Definition of background task requests

DEFINE PBTASK(BIT,ROUTINE) <
	PBF'BIT==1B<.-PBKTAB>	;; Assign bit number
	EXP ROUTINE		;; Assemble dispatch
>

; Dispatch table
PBKTAB:	PBTASK(FRE,RELOPB)	;Release free output buffers
	PBTASK(ASG,GETIPB)	;Assign new input buffers
	PBTASK(GCS,GCPLSK)	;GC local socket table
	PBTASK(BSP,BSPBAK)	;Do BSP background processing
	PBTASK(NVT,BSPNVT)	;Scan for NVT input/output
	PBTASK(SYN,SYNCHK)	;Check for sync timeout errors

PUPBKN==:.-PBKTAB	;Number of background tasks in table

; Statistics
;RS PUPSTA,0		;GETAB table of Pup statistics
;RS PBKCNT,PUPBKN	;Number of executions of each task
;RS PBKTIM,PUPBKN	;Time spent executing each task
;RS PBKRT		;Total runtime consumed by Pup process

NPUPST==:2*PUPBKN+1	;Length of PUPSTA GETAB table


	RESCD

; Routine to get incremental runtime (since last call)
; Returns +1, T1/ Runtime since last call (ms)

GETIRT:	NOSKED
	MOVE T1,FKRT		;Get total runtime charged to fork
	SUBM T1,PBKRT		;Compute time since last update
	EXCH T1,PBKRT		;Save new total, get delta time
	OKSKED
	RET    


	SWAPCD

; Routines to perform miscellaneous background tasks

; Release output packet buffers that have become unused

RELOPB:	MOVEI T1,FREOBQ		;Free output buffer queue header
	CALL REMIBQ		;Remove packet from queue
	 RET			;Queue empty
	CALL RELPKT		;Release the buffer
	JRST RELOPB		;Repeat until queue empty


; Allocate and lock new input buffers if necessary

GETIPB:	MOVE T1,FREIBN		;Get # of buffers now allocated
	CAIGE T1,MAXFIB		;Greater than max # we want?
GETIP1:	CALL ASGIPB		;No, assign a buffer for input
	 RET			;Failed, forget it
	MOVE T1,FREIBN		;Less than minimum # we want?
	CAIGE T1,MINFIB
	 JRST GETIP1		;Yes, assign more
	RET    			;No, done


; Process requests on timer queue

BSPBAK:	CALL REMTQP		;Remove request from head of queue
	 RET			;No more pending requests
	CALL DOBSP		;Got one, do BSP processing for it
	JRST BSPBAK		;Repeat until run out

; Timer queue logic

	RESCD

; Add port to timer queue, callable from process level
;	T1/ Time at which wakeup is desired (377777777777 =) never)
;	UNIT/ Pup unit #
; Returns +1
; Clobbers: temps
ADDTQP:	NOSKD1
	CHNOFF PUPCHN		;No races
	CAME T1,[377777777777]	;Do nothing for infinity
	 CALL ADDTQI		;Do the work
	CHNON PUPCHN
	OKSKD1
	RET    

; Same routine, callable from interrupt level
ADDTQI:	SKIPN T3,PUPTMQ(UNIT)	;Port already on timer queue?
	 JRST ADDTQ1		;No, just put new request on
	CAML T1,PUPTIM(UNIT)	;Yes, new request sooner than old?
	 RET			;No, done
	HRRZ T2,T3		;Remove this port from queue
	HLLM T3,(T2)
	HLRZ T2,T3		;Yes, get predecessor ptr in rh
	HRRM T3,(T2)
ADDTQ1:	MOVEM T1,PUPTIM(UNIT)	;Store new time for port

; Scan timer queue from head to find place for new request.
; Note that no end test is needed since the PUPTIM corresponding
;  to the queue header word contains infinity.
	MOVEI T2,PUPTQH		;Start at header of timer queue
ADDTQ2:	HRRZ T2,0(T2)		;Get successor
	CAMLE T1,PUPTQD(T2)	;Compare new time to one on queue
	 JRST ADDTQ2		;Still later, keep searching

; Found the desired place, T2/ new successor
	MOVEI T1,PUPTMQ(UNIT)	;Compute address of new item
	HLRZ T3,0(T2)		;Get new predecessor
	HRLZM T3,0(T1)		;Link item into queue
	HRRM T2,0(T1)
	HRLM T1,0(T2)
	HRRM T1,0(T3)
	RET    			;Done


; Delete port from timer queue, callable from process level
;	UNIT/ Pup unit #
; Returns +1
; Clobbers T1-T2

DELTQP:	NOSKD1
	CHNOFF PUPCHN		;No races
	SKIPN T1,PUPTMQ(UNIT)	;Port now on timer queue
	 JRST DELTQ1		;No, do nothing
	HLRZ T2,T1		;Yes, get predecessor ptr in rh	
	HRRM T1,(T2)		;Make it point to successor

	HRRZ T2,T1		;Get successor
	HLLM T1,(T2)		;Make it point to predecessor
	SETZM PUPTMQ(UNIT)	;Mark no longer queued
DELTQ1:	CHNON PUPCHN
	OKSKD1
	RET    


; Remove request from front of timer queue
; Called only from Pup background fork
; Returns +1:  No more
;	+2:  UNIT/ Pup unit # of request
; Clobbers T1, UNIT

REMTQP:	NOSKD1
	CHNOFF PUPCHN		;No races
	HRRZ UNIT,PUPTQH	;Get head of queue
	MOVE T1,PUPTQD(UNIT)	;Get time of first request
	CAMLE T1,TODCLK		;Now due?
	 JRST [	CHNON PUPCHN	;No (or empty), return +1
		OKSKD1
		RET]
	MOVE T1,0(UNIT)		;Yes, get predecessor ,, successor
	HRRM T1,PUPTQH		;Remove this port from queue
	PUSH P,T2		;Save T2
	HRRZ T2,T1		;CS36 In section address
	HLLM T1,0(T2)
	POP P,T2
	SETZM 0(UNIT)		;Mark no longer queued
	SUBI UNIT,PUPTMQ	;Convert pointer to index
	CHNON PUPCHN
	OKSKD1
	RETSKP			;Return +2

; Initialize Pup queues and data structures
; Returns +1
; Clobbers T1-T4, UNIT, PB

	SWAPCD

PUPINI:	SETZM XPUPIB		;Zero NVIO communication cells
	SETZM XPUPOB

	SETZM PRSBEG		;Clear Pup resident storage
	MOVE T1,[PRSBEG,,PRSBEG+1]
	BLT T1,PRSEND-1
	SETZM PNRBEG		;Clear Pup nonresident storage
	MOVE T1,[PNRBEG,,PNRBEG+1]
	BLT T1,PNREND-1

	MOVE T1,[[PKTBUF,,-1	;Initialize packet buffer free storage
		-1		; header (see ASGFRE for format)
		NPKTBF*1000
		MXPBLN
		PKTBUF+NPKTBF*1000,,PKTBUF],,PKTFRE]
	BLT T1,PKTFRE+4
	MOVEI T1,NPKTBF*1000	;Initially all one big block
	MOVEM T1,PKTBUF

	MOVE T1,[[PUPBUF,,-1	;Initialize Pup free storage
		-1		; header (see ASGFRE for format)
		NPUPBF*1000
		BSPSIZ
		PUPBUF+NPUPBF*1000,,PUPBUF],,PUPFRE]
	BLT T1,PUPFRE+4
	MOVEI T1,NPUPBF*1000	;Initially all one big block
	MOVEM T1,PUPBUF

	MOVEI T1,PBQBEG		;Initialize queues to empty
	HRRM T1,(T1)
	HRLM T1,(T1)
	CAIGE T1,PBQEND-1	;More?
	 AOJA T1,.-3		;Yes, repeat for all

	MOVSI UNIT,-NPUPUN	;Initialize all ports
	CALL INIPRT
	AOBJN UNIT,.-1

	MOVX T1,1B0		;Initialize routing table to all empty
	MOVEM T1,PUPROU
	MOVE T1,[PUPROU,,PUPROU+1]
	BLT T1,PUPROU+NPNETS-1
	MOVSI T1,-LPUPIR		;Setup entries for directly-connected nets
PUPII1:	MOVE T2,PUPIRT(T1)	;Get table entry
	LDB T3,[POINT 16,B,17]	;Get net number
	TXZ T2,<177777,,0>	;Flush from entry
	MOVEM T2,PUPROU-1(T3)	;Put entry in routing table
	AOBJN T1,PUPII1

	MOVE T1,[PUPTQH,,PUPTQH] ;Initialize timer queue to empty
	MOVEM T1,PUPTQH
	HRLOI T1,377777		;Make corresponding time infinite
	MOVEM T1,PUPFTM

	SETOM PRTLCK		;Unlock port table lock
	SETOM NVTLCK		;Unlock NVT assignment lock
	SETOM PUPBGF		;Set to log Pup bugs
	SETOM NTDLCK
	MOVX T1,.SFDIR		;Initialize PUPNM dir
	SMON%
	 ERCAL [BUG(NTDINO)	;Report error
		RET]
	CALL PUPRST		;Initialize NVIO communication
	SETOM PUPRDY		;SAY PUP IS READY
	RET    

	RESCD

; Restart Pup I/O
; Called from PUPINI and from SYSRST
; Returns +1
; Clobbers A

PUPRST::CALL ETHRST		;Restart Ethernet hardware

	SKIPLE XPUPIB		;Empty input buffer assigned?
	 SIGNAL PUPIBG		;Yes, tell NVIO
	SKIPGE XPUPIB		;Full input buffer?
	 IDEV PUPIDN		;Yes, service it

	SKIPLE XPUPOB		;Full output buffer assigned?
	 SIGNAL PUPOBG		;Yes, tell NVIO
	SKIPGE XPUPOB		;Output already serviced?
	 IDEV PUPODN		;Yes, do next output

	MOVX T1,PBFFRE!PBFASG!PBFBSP ;Run some background tasks
	IORM T1,PUPFLG

	RET    

; Code to handle Pup Bugs

; BUG(PUP,<message>,X)
; Copy header of packet PB for later printout by job 0

BGRPUP:	AOS PUPBGC		;Count occurrences
	PUSH P,T1
	PUSH P,T2
	PUSH P,T3
	SKIPE PUPBGP		;Already have unprocessed Pup bug?
	 JRST BGRPU1		;Yes, don't store this one
	MOVSI T1,(PB)		;Save data from PB header
	HRRI T1,PUPBGH
	BLT T1,PUPBGH+PBCONT-1
	HRRZ T1,-3(P)		;Get pc of bug
	HRL T1,PUPBGC		;Put bug number in lh
	MOVEM T1,PUPBGH+PBBSPQ	;CS36 Save in stored header
	SKIPE PUPBGF		;Logging enabled?
	 AOS JB0FLG		;Yes, awaken job 0
BGRPU1:	HRRZ T1,-3(P)		;Get pc of bug
	CALL PBGCNT		;Count this bug in hash table
	POP P,T3
	POP P,T2
	POP P,T1
	RET    


; BUG(DIP,<message>,X)
; Discard input packet PB after printout by job 0 if enabled

BGRDIP:	PUSH P,[0]		;CS36 Flag extra return not desired
	JRST BGRDP1		;Enter common bug code


; BUG(DPR,<message>,X)
; Discard input packet PB as above, then execute an extra POPJ
;  so the routine invoking the BUG is exited

BGRDPR:	PUSH P,[-1]		;CS36 Flag extra return desired
BGRDP1:	PUSH P,T1
	PUSH P,T2
	PUSH P,T3
	PUSH P,T4
	AOS T1,PUPBGC		;Count occurrences, get count
	HRL T1,-5(P)		;Get pc of bug
	MOVSM T1,PBBSPQ(PB)	;Save count,,pc in packet buffer
	CONSZ PI,1B<20+PUPCHN>	;At interrupt level?
	 JRST BGRDP2		;Yes
	SKIPN PUPBGF		;No, logging enabled?
	 JRST [	CALL RELPKT	;No, just release packet
		JRST BGRDP4]
	CALL LOCKPB		;Yes, have to lock the buffer
	NOSKD1
	CHNOFF PUPCHN		;Interlock
BGRDP2:	SKIPN PUPBGF		;Pup bug logging enabled?
	 JRST [	CALL RELPBI	;No, just release the buffer
		JRST BGRDP3]
	MOVEI T1,DSCIBQ		;Yes, append to discard queue
	CALL APPIBQ		; for processing by job 0
	AOS JB0FLG		;Awaken job 0
BGRDP3:	CONSZ PI,1B<20+PUPCHN>	;At interrupt level?
	JRST BGRDP4		;(used to be JRST .+3 -- FSG)
	 CHNON PUPCHN		;No, uninterlock
	OKSKD1
BGRDP4:	HRRZ T1,-5(P)		;CS36 Get pc of bug
	CALL PBGCNT		;Count this bug in hash table
	POP P,T4
	POP P,T3
	POP P,T2
	POP P,T1
	SKIPGE 0(P)		;Which call?
	 ADJSP P,-1		;CS36 DPR, pop off another return
	ADJSP P,-1		;CS36 Pop off DPR flag
	RET    


; Bug-related data

;RS PUPBGF		;Nonzero to log Pup bugs
;RS PUPBGC		;Count of Pup bugs
;RS PUPBGH,PBBSPQ	;PB header and Pup header for last BUG(PUP,...)
PUPBGP=PUPBGH+PBBSPQ	;PC of last BUG(PUP,...)
;RS PUPBGP		;PC of last BUG(PUP,...)

	SWAPCD

; Log Pup bugs;  called from job 0 (see SWPMON)
; Returns +1
; Clobbers T1-T4, PB, and probably others (see CHKBG1 in SWPMON)

PBGLOG::SKIPN PUPBGP		;Have bug pc?
	 JRST PBGLG1		;No
	MOVEI PB,PUPBGH		;Yes, set pointer to saved header
	CALL PBGPRT		;Print Pup bug
	SETZM PUPBGP		;Clear, enable for next
PBGLG1:	HRRZ T1,DSCIBQ		;Check discarded input queue
	CAIN T1,DSCIBQ		;Empty?
	 RET			;Yes, done
	MOVE T1,TODCLK		;No, set time limit for printing
	ADDI T1,^D10000		;10 seconds from now
	PUSH P,T1
	NOINT			;CS36 Protect free list
PBGLG2:	MOVEI T1,DSCIBQ		;Get packet from queue
	CALL REMIBQ
	 JRST [	OKINT		;CS36 Protect free list
		ADJSP P,-1	;Empty, fix stack and exit
		RET]
	MOVE T1,TODCLK		;Check time limit
	CAMG T1,0(P)		;Skip if exceeded
	 CALL PBGPRT		;Print bug
	CALL RELPKT		;Release packet buffer
	JRST PBGLG2		;Repeat for all packets in queue


; Internal routine to print Pup bugs
;	PB/ Packet buffer pointer

PBGPRT:	SKIPN PUPBGF		;Want to print Pup bugs?
	 RET			;No
	TMSG <
**PUPBUG >
	HLRZ T2,PBBSPQ(PB)	;Get bug number
	MOVEI	A,101
	MOVEI	C,^D10
	NOUT			;Print in decimal
	 JFCL
	HRROI T1,[ASCIZ / D=/]
	PSOUT
	MOVE T2,PBHEAD+2(PB)	;Get high dest socket
	LSH T2,-4		;Right-justify
	MOVE T3,PBHEAD+3(PB)	;Get low dest socket
	LSHC T2,-^D16		;Concatenate
	LSH T3,-4		;Right-justify
	LDB T1,PPUPDN		;Dest net
	LDB T2,PPUPDH		;Dest host
	CALL PBGPNM		;Print name string
	HRROI T1,[ASCIZ / S=/]
	PSOUT
	LDB T1,PPUPSN		;Source net
	LDB T2,PPUPSH		;Source host
	MOVE T3,PBHEAD+4(PB)	;Source socket
	LSH T3,-4		;Right-justify
	CALL PBGPNM		;Print name string
	HRROI T1,[ASCIZ /
  PS=/]
	PSOUT
	LDB T1,PPBPHN		;Phys src net
	LDB T2,PPBPHH		;Phys src host
	SETZ T3,			;No socket
	CALL PBGPNM		;Print name string
	HRROI T1,[ASCIZ / T=/]
	PSOUT
	LDB T2,PUPTYP		;Print Pup type in octal
	MOVEI T1,101		;Primary output
	MOVEI T3,10		;in octal
	NOUT
	 JFCL
	HRROI T1,[ASCIZ / at /]
	PSOUT
	HRRZ T2,PBBSPQ(PB)	;Get pc of bug
	SOJA T2,CHKBG1		;Print PC, date, time, message
;*** This routine should be augmented to type the bug string
;*** It now prints the date and bug string (see below) - FSG
CHKBG1:	MOVX T1,.PRIOU
	MOVEI T3,10
	NOUT
	 JFCL
	MOVEI T2," "		;2 blanks between PC and date/time
	BOUT
	BOUT
	SETO T2,		;Current date and time
	SETZ T3,		;In standard format
	ODTIM
	HRRZ T1,PBBSPQ(PB)	;Addr of JFCL [msg]
	HRRO T1,(T1)		;Byte ptr to asciz msg
	PSOUT			;Note that msg starts/ends with CR-LF
	RET

; Internal routine to print name string
;	T1/ Net
;	T2/ Host
;	T3/ Socket

PBGPNM:	HRLI T2,(T1)		;Make net,,host
	PUSH P,T2		;Put on stack
	PUSH P,T3		;Put socket on stack
	MOVEI T1,101		;Output to tty
	MOVEI T2,-1(P)		;Location of address block
	HRLI T2,(1B2)		;Flag number substitution ok
	PUPNM%			;Convert address to name
	 BUG(PBGPNA)
	ADJSP P,-2		;Fix stack
	RET    


	RESCD

;LG2PBT==6		;Log(2) size of Pup bug table
;LENPBT==:1_LG2PBT	;Length of Pup bug table
;RS PUPBGT,LENPBT	;Hash table of bug count,,pc pairs.

; Count a Pup bug in the hash table
;	T1/ pc
; Returns +1
; Clobbers T1-T3

PBGCNT:	MOVEI T2,(T1)		;Copy just rh of pc
	IMULI T2,^D162013	;Hash - 2^18/golden ratio
	LSH T2,-<^D18-LG2PBT>	;Keep topmost  LG2PBT bits
	ANDI T2,LENPBT-1
	MOVNI T3,(T2)		;Keep negative index for wraparound
	HRLI T1,(T3)
	HRLI T2,-LENPBT(T2)	;Make AOBJN pointer
PBGCN1:	HRRZ T3,PUPBGT(T2)	;Get current entry
	CAIN T3,(T1)		;Same as pc of new bug?
	 JRST PBGCN3		;Yes
	JUMPE T3,PBGCN2		;No, found free entry?
	AOBJN T2,PBGCN1		;Collision, reprobe linearly
	HLLZ T2,T1		;Wrap around end of table
	HRLI T1,0		;In case get here again
	JUMPN T2,PBGCN1
	RET    			;Table is full, forget it

; Here to insert new entry
PBGCN2:	HRRZM T1,PUPBGT(T2)	;Store pc of bug

; Here to increment count for existing entry
PBGCN3:	MOVSI T3,1
	ADDM T3,PUPBGT(T2)
	RET    

REPEAT 0,<
; NVIO bug strings

; General Pup errors
NVBUG(30,<Incorrect Pup length>)
NVBUG(31,<Pup length greater than physical packet length>)
NVBUG(32,<Failed to allocate packet buffer>)

; Ethernet errors
NVBUG(40,<Incorrect Ethernet receiver status>)
NVBUG(41,<Incorrect Ethernet message length>)
NVBUG(42,<Incorrect Ethernet source address>)
NVBUG(43,<Incorrect Ethernet destination address>)
NVBUG(44,<Incorrect Ethernet packet type>)
NVBUG(45,<Ethernet transmitter timed out by software>)
NVBUG(46,<Incorrect Ethernet transmitter status>)
NVBUG(47,<Ethernet load overflow>)

; MCA errors
NVBUG(50,<MCA input timeout>)
NVBUG(51,<MCA message too long>)
NVBUG(52,<MCA input sync error>)
NVBUG(53,<MCA Pup output timeout>)

; Imp errors
NVBUG(60,<Imp message too long>)
NVBUG(61,<Imp state changed>)
NVBUG(62,<Imp input host-host protocol packet discarded>)
> ;REPEAT 0

; -----------------------------------------------------------------
;	Byte Stream Protocol
; -----------------------------------------------------------------

; Note:  In the calling sequences, "Assumes port is locked"
; means that UNIT, BSP, and IOS must be setup before the call,
; and the subroutine updates IOS appropriately.

	SWAPCD

; Get Pup from BSP input queue
; Assumes port is locked
; Returns +1:  Can't, T1/ argument word for EDISMS
;	+2:  Ok, PB/ Packet buffer pointer
;		PBBSBC(PB)/ Byte count
;		PBBSID(PB)/ Byte pointer (ILDB gets first byte)
; Note that the returned packet may be a Data, AData, or Mark
; Clobbers T1-T4, PB

GETBSP:	HLRZ PB,BSPCUR(BSP)	;Is there a current input packet?
	JUMPE PB,.+3
	CALL RELPKT		;Yes, release it
	HRRZS BSPCUR(BSP)	;Clear current input packet ptr

; Get next packet if there is one
GETBS1:	HRRZ T1,BSPIQL(BSP)	;Get number of bytes available
	JUMPE T1,[TLZ IOS,(BSINPF) ;If none, clear input flag
		CALL DOBSPL	;Make sure BSP data up-to-date
		TXNE IOS,BSINPF   ;New input available?
		 JRST GETBS1	;Yes, try again
		MOVSI T1,(UNIT)	;No, set scheduler test
		HRRI T1,BSITST
		RET]		;Take fail return
	MOVEI T1,BSPIBQ(BSP)	;Data available, get queue header
	CALL REMITQ		;Remove item from BSP input queue
	 BUG(GETBSA)
	MOVEI PB,-PBBSPQ(T2)	;Set pointer to head of PB
	HRLM PB,BSPCUR(BSP)	;Save as current input packet
	MOVSI T1,-1		;Decrement count of packets
	ADDB T1,BSPIQL(BSP)
	SKIPGE T1		;Check for over-decrementing
	 BUG(GETBSB)

; Compute and update byte sequence numbers and counts
	MOVE T1,BSPILW(BSP)	;Get left window edge
	SUB T1,PBBSID(PB)	;Compute offset from start of PB
	TXZ T1,-1B3  		; mod 2^32
	TXNE T1,1B4  		;Make sure positive
	 BUG(GETBSC)
	CAML T1,PBBSBC(PB)	;Any bytes in window?
	 JRST GETBSP		;No, discard (can this happen?)
	MOVN T2,T1		;Yes, make negative
	ADDB T2,PBBSBC(PB)	;Decrease count by first byte #
	MOVN T3,T2		;Decrement # bytes available
	ADDB T3,BSPIQL(BSP)	;Decrement # bytes available
	TXNE T3,400000		;Check for over-decrementing
	 BUG(GETBSD)
	ADD T2,BSPILW(BSP)	;Update left window edge to
	TXZ T2,-1B3  		; first byte beyond this Pup
	MOVEM T2,BSPILW(BSP)

; GETBSP (cont'd)

; Initialize byte pointer to start of byte stream
	MOVEI T2,PBCONT(PB)	;Make byte ptr to start of
	HRLI T2,(POINT 8)	; Pup Contents
	ROT T1,-2		;Separate word and byte numbers
	ADDI T2,(T1)		;Advance word index in byte ptr
	HRRI T1,0		;Clear word except byte # in B0-1
	LSH T1,-1		;Byte # to B1-2, i.e. 8*# in B0-5
	SUB T2,T1		;Modify byte ptr for starting byte
	MOVEM T2,PBBSID(PB)	;Store byte ptr in PB header

; Do any necessary BSP processing before returning
	CALL DOBSPQ		;Do BSP processing if needed
	TXNE IOS,BSZALF  	;Did we send zero allocation?
	 CALL SNDACK		;Yes, send another Ack (presumably nonzero now)
	HLRZ PB,BSPCUR(BSP)	;Recover packet buffer pointer
	RETSKP			;Take skip return

	RESCD

; Scheduler test for BSP input available
; Arg is Pup unit #

BSITST:	MOVX T2,BSINPF!BSTIMF!BSERRF!BSWAKF ;Anything to do?
	TDNN T2,PUPSTS(T1)
	 JRST 0(T4)		;No
	JRST 1(T4)		;Yes, wakeup

	SWAPCD


; Check for BSP output possible
; Assumes port is locked
; Returns +1:  Output not possible, T1/ argument word for EDISMS
;	+2:  Output possible, T1/ Max # bytes in next Pup
; Clobbers T1-T4, PB

CHKBSO:	LDB T1,PBSOAP		;Get # additional Pups allowed
	JUMPE T1,CHKBO3		;Fail if none
	HRRZ T1,BSPOAL(BSP)	;Get # additional bytes allowed
	JUMPE T1,CHKBO3		;Fail if none
	LDB T2,PBSOBP		;Get max bytes/Pup
	JUMPE T2,CHKBO3		;0 =) no Ack received yet
	CAILE T1,(T2)		;More than one Pups' worth?
	 MOVEI T1,(T2)		;Yes, cut down to max Pup length
	RETSKP		;Success, skip return

; Here when output not possible
CHKBO3:	TXZ IOS,BSOUTF  	;Clear output flag
	CALL DOBSPL		;Make sure BSP data up-to-date
	TXNE IOS,BSOUTF  	;Output possible now?
	 JRST CHKBSO		;Maybe, try again
	SKIPN BSPATM(BSP)	;No, is AData outstanding?
	 CALL SNDADA		;No, force AData to be sent
	MOVSI T1,(UNIT)		;Set scheduler test
	HRRI T1,BSOTST
	RET    			;Take fail return

	RESCD

; Scheduler test for BSP output possible
; Arg is Pup unit #

BSOTST:	MOVX T2,BSOUTF!BSTIMF!BSERRF!BSWAKF ;Anything to do?
	TDNN T2,PUPSTS(T1)
	 JRST 0(T4)		;No
	JRST 1(T4)		;Yes, wakeup

	SWAPCD

; Build BSP Data packet
;	T1/ # data bytes to be stored in Pup
; Assumes port is locked
; Returns +1:  Failed, T1/ argument word for EDISMS
;	+2:  Succeeded:
;		T1/ Byte count (same as call)
;		T2/ Byte ptr (IDPB stores first data byte)
;		PB/ Packet buffer pointer
; Clobbers T1-T4, PB

BLDDAT:	STKVAR <BLDBYT>		;Byte count
	HRRM T1,BLDBYT		;Save byte count
	MOVEI T2,4*PBHEAD+MNPLEN+3(T1)  ; Include header and overhead
	LSH T2,-2		;Convert to words
	CALL ASGPKT		;Allocate packet buffer
	 RET			;Failed
	HRRM PB,BSPCUR(BSP)	;Ok, save current buffer ptr
	MOVEI T1,PT.DAT		;Set Type = Data
	DPB T1,PUPTYP
	HRRZ T1,BLDBYT		;Recover byte count
	MOVEI T2,PBCONT(PB)	;Construct byte pointer
	HRLI T2,(POINT 8)
	RETSKP			;Done, skip return



; Finish up and send current Data Pup, if any
;	T1/ Byte ptr to last byte stored (if any)
; Assumes port is locked
; Returns +1 always
; Clobbers T1-T4, PB

DMPBSP:	HRRZ PB,BSPCUR(BSP)	;Get ptr to current output PB
	JUMPE PB,CPOPJ		;Do nothing if none
	HLLZS BSPCUR(BSP)	;Zero pointer in data block
	CALL ENDPUP		;Compute length, trim excess
	CALL SNDBSP		;Send it on its way
	RET    

; "Force" BSP output, i.e. send the current Pup as an AData,
;  or send a null AData
;	T1/ Byte ptr to last byte stored in current Pup (if any)
; Assumes port is locked
; Returns +1 always
; Clobbers T1-T4, PB

FRCBSP:	HRRZ PB,BSPCUR(BSP)	;Get ptr to current output PB
	JUMPE PB,FRCBS1		;Jump if none
	HLLZS BSPCUR(BSP)	;Zero pointer in data block
	CALL ENDPUP		;Compute length, trim excess
	MOVEI T1,PT.ADA		;Set Type = AData
	DPB T1,PUPTYP
	CALL SNDBSP		;Send it on its way
	RET    

; Here when there is no current output packet
FRCBS1:	CALL DOBSPQ		;Do housekeeping
	HLRZ T1,BSPOBQ(BSP)	;Get tail of output queue
	CAIN T1,BSPOBQ(BSP)	;Queue empty?
	 RET			;Yes, nothing to do
	MOVEI PB,-PBBSPQ(T1)	;No, point to head of tail packet
	LDB T1,PUPTYP		;Get Pup Type
	CAIE T1,PT.ADA		;An AData?
	 CAIN T1,PT.AMA		;An AMark?
	 RET			;Yes, nothing more to do
	CALL RETADA		;No, retransmit it as ADatT1/AMark
	RET    



; Check for empty BSP output queue
; Assumes port is locked
; Returns +1:  Not empty, T1/ Scheduler test, T2/ # buffered bytes
;	+2:  Empty

CHKBOQ:	HRRZ T1,BSPOBQ(BSP)	;Get queue head
	CAIN T1,BSPOBQ(BSP)	;Empty?
	 RETSKP			;Yes, skip return
	TXO IOS,BSNOQF  	;No, set nonempty output queue flag
	CALL DOBSPL		;Do any necessary processing
	TXNN IOS,BSNOQF  	;Now empty?
	 JRST CHKBOQ		;Maybe, check again
	MOVSI T1,(UNIT)		;No, set scheduler test
	HRRI T1,BSEOQT
	HRRZ T2,BSPOQL(BSP)	;Return # buffered bytes
	RET    			;Take non-skip return

	RESCD

; Scheduler test for empty BSP output queue
; Arg is Pup unit #

BSEOQT:	MOVE T2,PUPSTS(T1)	;Get port status
	TXNE T2,BSNOQF  	;Output queue now empty?
	TXNE T2,BSTIMF!BSERRF!BSWAKF   ;Error or work to do?
	 JRST 1(T4)		;Yes, wakeup
	JRST 0(T4)		;No, wait

	SWAPCD

; Send BSP data packet (including AData, Mark, or AMark)
;	PB/ Packet buffer ptr
; Assumes port is locked
; Returns +1 always
; Caller is expected to have checked for allocation beforehand
;  (by calling CHKBSO)
; Caller should set up Length and Type, we do the rest
; Clobbers T1-T4, PB

SNDBSP:	MOVEI T1,BSPOBQ(BSP)	;Point to output queue header
	MOVEI T2,PBBSPQ(PB)	;Point to link word in this PB
	CALL APPITQ		;Append new Pup to BSP queue
	HLLZS BSPCUR(BSP)	;Clear current output PB ptr

; Compute and store Pup ID
	HRRZ T1,BSPOQL(BSP)	;Get current # bytes queued
	ADD T1,BSPOLW(BSP)	;Compute ID for this Pup
	LSH T1,4		;Left-justify
	MOVEM T1,PBHEAD+1(PB)	;Set Pup ID

; Update Pup and byte counts for this port
	LDB T1,PUPLEN		;Get Pup Length
	SUBI T1,MNPLEN		;Subtract overhead
	HRLI T1,1		;Count 1 Pup
	ADDM T1,BSPOQL(BSP)	;Update Pups and bytes queued
	LDB T3,PBSOAP		;Get additional Pups allowed
	SOSL T3			;Decrement
	 DPB T3,PBSOAP		;Store back unless negative
	HRRZ T4,BSPOAL(BSP)	;Get additional bytes allowed
	SUBI T4,(T1)		;Decrement by # bytes in new Pup
	SKIPGE T4		;Make sure non-negative
	 SETZ T4,
	HRRM T4,BSPOAL(BSP)	;Store back

; Check allocation and change Data to AData or Mark to AMark if appropriate
	LDB T1,PUPTYP		;Get Pup Type
	CAIE T1,PT.ADA		;Already an AData?
	 CAIN T1,PT.AMA		;Already an AMark?
	 JRST SNDBS5		;Yes, nothing more needed
	CALL CHKADA		;Check hold time and allocation
	 JRST [	MOVE T4,BSPDTM(BSP) ;Still ok, save timer
		CALL SETTMH	;Set timer to hold time
		CAMGE T4,BSPDTM(BSP) ;Compare to previous timer
		 MOVEM T4,BSPDTM(BSP) ;Use earlier
		JRST SNDBS6]	;Go finish up
	LDB T1,PUPTYP		;Time to send AData, get current type
	CAIN T1,PT.DAT		;Data?
	 MOVEI T1,PT.ADA	;Yes, change to AData
	CAIN T1,PT.MRK		;Mark?
	 MOVEI T1,PT.AMA	;Yes, change to AMark
	DPB T1,PUPTYP
SNDBS5:	MOVE T1,TODCLK		;Record sending AData now
	MOVEM T1,BSPATM(BSP)
	CALL SETTMR		;Set timer for retransmission

; Finish up and send the Pup
SNDBS6:	SETZ T1,		;Clear transport control byte
	DPB T1,PUPTCB
	CALL SETPRT		;Set up source and dest ports
	CALL SETCHK		;Set Pup Checksum appropriately
	MOVE T1,TODCLK		;Time stamp the Pup
	MOVEM T1,PBTIME(PB)
	CALL PUOCNV		;Convert packet data (but not checksum)
	CALL PUTPUP		;Queue Pup for output
	 PBUG(PUP,<SNDBSP: Output queue overflowed>)
	CALL DOBSPQ		;Do housekeeping if needed
	CALL SETPTM		;Put port on timer queue
	AOS BSPOPG(BSP)		;Count packets generated
	RET    			;Done

; Send an Interrupt
;	T1/ Interrupt code
;	T2/ If nonzero, string ptr to Interrupt text (see BLDIAB)
; Assumes port is locked
; Returns +1:  Can't (interrupt already outstanding)
;		T1/ argument word for EDISMS
;	+2:  Successfully sent
; Clobbers T1-T4, PB

SNDINT:	SKIPGE BSPSII(BSP)	;Interrupt already outstanding?
	 JRST [	TXO IOS,BSINTF   ;Yes, ensure flag is set
		PUSH P,T1	;Save code and string ptr
		PUSH P,T2
		CALL DOBSPL	;Ensure BSP data up-to-date
		POP P,T2
		POP P,T1
		SKIPL BSPSII(BSP) ;Still outstanding?
		 JRST .+1	;No, continue
		MOVSI T1,(UNIT)	;Yes, set scheduler test
		HRRI T1,INOTST
		RET]		;Take fail return
	CALL BLDIAB		;Ok, build the Pup
	 RET			;Failed, take non-skip return
	MOVEI T1,PT.INT		;Set Type = Interrupt
	DPB T1,PUPTYP
	SETZ T1,		;Zero out Transport control byte
	DPB T1,PUPTCB
	HRROI T1,0(PB)		;Make PB ptr with sign set
	EXCH T1,BSPSII(BSP)	;Store it, get Interrupt ID
	LSH T1,4		;Left-justify
	MOVEM T1,PBHEAD+1(PB)	;Store in Pup
	CALL SETPRT		;Set up source and dest ports
	CALL SETCHK		;Set Pup Checksum appropriately
	SETOM PBBSPQ(PB)	;Mark PB as owned by BSP process
	MOVE T1,TODCLK		;Time stamp
	MOVEM T1,PBTIME(PB)
	HLRZ T2,BSPTIM(BSP)	;Get retransmission timeout
	ADDI T1,(T2)		;Compute time for next check
	MOVEM T1,BSPITM(BSP)	;Store in data block
	CALL PUOCNV		;Convert packet data (but not checksum)
	CALL PUTPUP		;Queue Pup for output
	 PBUG(PUP,<SNDINT: Output queue overflowed>)
	TXO IOS,BSINTF  	;Ensure flag is set
	CALL DOBSPQ		;Check for work to be done
	CALL SETPTM		;Put port on timer queue
	RETSKP		;Finished, skip return

	RESCD

; Scheduler test for Interrupt no longer outstanding
; Arg is Pup unit #

INOTST:	MOVE T2,PUPSTS(T1)	;Get port status
	TXNE T2,BSINTF  	;Interrupt no longer outstanding?
	TXNE T2,BSTIMF!BSERRF!BSWAKF   ;Error or work to do?
	 JRST 1(T4)		;Yes, wakeup
	JRST 0(T4)		;No, wait

	SWAPCD


; Send an Abort
;	T1/ Abort code
;	T2/ If nonzero, string ptr to Abort text (see BLDIAB)
; Assumes port is locked
; Returns +1 always
; Clobbers T1-T4, PB

SNDABT:	CALL BLDIAB		;Build the Pup
	 RET			;Failed, forget it
	MOVE T1,BSPCID(BSP)	;Get Connection ID
	LSH T1,4		;Left-justify
	MOVEM T1,PBHEAD+1(PB)	;Store as Pup ID
	MOVEI T1,PT.ABT		;Set Type = Abort
	CALL SNDPUP		;Finish up and send the Pup
	 CAI			;Ignore failure
	RET    			;Done

; Build Interrupt or Abort (common code)
;	T1/ B0 clear if called from user, set if from monitor
;	   rh: Interrupt or Abort Code
;	T2/ If nonzero, string ptr to text in appropriate space
; Assumes port is locked
; Returns +1:  Can't (no room), T1/ argument word for EDISMS
;	+2:  Successful, PB/ ptr to packet buffer

BLDIAB:	STKVAR <BLDIAS>		;Space indicator
	MOVEM T1,BLDIAS		;Save address space indicator
	PUSH P,T2		;Save string ptr to text
	PUSH P,T1		;Save code
	MOVEI T2,PBHEAD+<MNPLEN+MXPTXT+2+3>/4
	CALL ASGPKT		;Assign packet buffer
	 JRST [	ADJSP P,-2	;Can't, flush args
		RET]		;Fail return
	POP P,T2		;Recover code
	DPB T2,[POINT 16,PBCONT(PB),15]	;Store in Pup
	MOVE T1,[POINT 8,PBCONT(PB),15]	;Init ptr for storing text
	POP P,T2		;Recover string ptr to text
	JUMPE T2,BLDIA2		;Jump if no text
	TLC T2,-1		;Left half = -1?
	TLCN T2,-1
	 HRLI T2,(POINT 7)	;Yes, change to string ptr
	MOVEI T3,MXPTXT		;Init byte counter
BLDIA1:	SKIPGE BLDIAS		;Check address space indicator
	 ILDB T4,T2		;Get byte from monitor
	SKIPL BLDIAS
	 XCTBU .-2		;Get byte from user
	JUMPE T4,BLDIA2		;Jump if end
	IDPB T4,T1		;Put byte in Pup
	SOJG T3,BLDIA1		;Repeat if still room
BLDIA2:	CALL ENDPUP		;Compute length, trim excess
	RETSKP			;Skip return


; Send an AMark
;	T1/ Mark byte (right-justified)
; Assumes port is locked
; Returns +1:  Can't, T1/ argument word for EDISMS
;	+2:  Successfully sent
; Note caller is expected to have finished any preceding data Pup
; Clobbers T1-T4, PB, BSP, IOS

SNDAMA:	IORI T1,400000		;Flag to send Amark
				;Fall into Mark code


; Send a Mark
;	T1/ Mark byte (right-justified)
; Assumes port is locked
; Returns +1:  Can't, T1/ argument word for EDISMS
;	+2:  Successfully sent
; Note caller is expected to have finished any preceding data Pup
; Clobbers T1-T4, PB, BSP, IOS

SNDMRK:	STKVAR <SNDMSV>		;Mark byte
	HRLM T1,SNDMSV		;Save Mark byte
	CALL CHKBSO		;Check for BSP output possible
	 RET			;Not now, take fail return
	MOVEI T2,PBHEAD+<MNPLEN+1+3>/4
	CALL ASGPKT		;Allocate packet buffer
	 RET			;Couldn't, take fail return
	HLRZ T1,SNDMSV		;Ok, get back the byte
	MOVEI T2,PT.MRK		;Assume want to send Mark
	TXZE T1,400000		;AMark flag set?
	 MOVEI T2,PT.AMA	;Yes
	DPB T1,[POINT 8,PBCONT(PB),7]  ; Store Mark byte
	DPB T2,PUPTYP		;Set Pup Type
	MOVEI T1,MNPLEN+1	;Set Pup Length appropriately
	DPB T1,PUPLEN
	CALL SNDBSP		;Send it on its way
	RETSKP			;Done, skip return

; Perform BSP processing for a port, if possible
; Called only from background
;	UNIT/ Pup unit #
; Returns +1
; Clobbers most everything besides UNIT

DOBSP:	LOCK(PRTLCK,,SPQ)	;Lock out changes to port table
	HRRZ BSP,PUPLNH(UNIT)	;Get BSP linkage if any
	JUMPE BSP,[UNLOCK(PRTLCK,RESIDENT,SPQ) ;Do nothing if not BSP port
		RET]
	CALL LCKBSA		;Attempt to lock BSP port
	 JRST [	UNLOCK(PRTLCK,RESIDENT,SPQ) ;Can't, unlock table
		MOVE T1,TODCLK	;Request delayed background processing
		ADDI T1,IBWDLY	;Input background wakeup delay interval
		CALL ADDTQP	;Add port to timer queue
		RET]		;Return having done nothing
	UNLOCK(PRTLCK,RESIDENT,SPQ) ;Ok, unlock the table
	CALL DOBSPB		;Do the real work
	CALL ULKBSP		;Update status, unlock BSP port
	RET    			;Done


; Perform BSP processing for port locked by caller
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
;	IOS/ Port status
; Returns +1 always, does not unlock port
; Clobbers T1-T4, PB

; Enter here to perform processing only if requested
DOBSPQ:	TXNE IOS,BSWAKF  	;Specifically woken up?
	 JRST DOBSPL		;Yes, always do it
	MOVE T1,TODCLK		;No, get now
	SKIPE PUPTMQ(UNIT)	;Is there a timer request in?
	 CAMGE T1,PUPTIM(UNIT)	;Yes, is it due?
	 RET			;No, do nothing

; Enter here to reset possibly pending requests first
DOBSPL:	CALL DELTQP		;Delete timer request if pending

; Enter here from DOBSP (background only)
DOBSPB:	TXZ IOS,BSWAKF  	;Cancel wakeup request
	MOVEM IOS,PUPSTS(UNIT)	;Update in core too

; Process packets on input queue
DOBSP1:	CALL GETPUP		;Get packet from input queue
	 JRST DOBSP2		;Queue empty
	PUSH P,E
	CALL DOBSPI		;Process the packet
	POP P,E
	JRST DOBSP1		;Repeat until queue empty

; Send Ack if needed
DOBSP2:	TXZE IOS,BSSAKF  	;Need to send Ack?
	 CALL SNDACK		;Yes, do so

; See if time yet to check for BSP retransmissions
	MOVE T1,TODCLK		;Get now
	CAMGE T1,BSPDTM(BSP)	;Time for check?
	TXNE IOS,BSRAKF  	;Received Ack?
	 CALL DOBSPO		;Yes, do output processing

; Check outstanding Interrupts
	MOVE T1,TODCLK		;Get now
	CAML T1,BSPITM(BSP)	;Time for check?
	 CALL CKPINT		;Yes, do so

; Check FSM if required
	MOVE T1,TODCLK		;Get now
	CAML T1,BSPFTM(BSP)	;Time for FSM check?
	 CALL [MOVEI T1,E.TIMO  ;Yes, generate timeout event
		JRST PUPFSC]

; Compute time for next service
	JRST SETPTM		;Set time and return

; Process input packet for BSP port
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
;	IOS/ Port status
;	PB/ Packet buffer pointer
; Returns +1
; Clobbers T1-T4, E
; Updates IOS where appropriate

DOBSPI:
; Check Pup Checksum unless inhibited by user
	TXNE IOS,BSNCHK  	;Checksumming inhibited?
	 JRST .+3		;Yes, bypass
	CALL CHKCKS		;No, check checksum
	 PBUG(DPR,<DOBSPI: Pup Checksum incorrect>)

; Check Pup Type and get dispatch
	LDB E,PUPTYP		;Get Pup Type
	CAIGE E,NBSDSP		;Within bounds?
	 SKIPN E,BSPDSP(E)	;Yes, get flags and dispatch
	 PBUG(DPR,<DOBSPI: BSP Pup of unknown type>)

; Perform pre-dispatch checking of Pup depending on flags
	TXNN E,1B16  		;Check Source Port?
	 JRST .+3		;No
	CALL CHKSRC		;Yes, perform source port check
	 PBUG(DPR,<DOBSPI: BSP Pup from incorrect Source Port>)

	TXNN E,1B17  		;Check Pup ID?
	 JRST DOBSI1		;No
	MOVE T1,PBHEAD+1(PB)	;Yes, get word containing Pup ID
	LSH T1,-4		;Right-justify
	CAME T1,BSPCID(BSP)	;Same as Connection ID?
	 PBUG(DPR,<DOBSPI: BSP Pup with incorrect ID>)

DOBSI1:	LDB T1,PBSSTT		;Get current state
	TDNN E,BITS(T1)		;Reasonable type for this state?
	 PBUG(DPR,<DOBSPI: Improper port state for received Pup>)

	MOVE T1,TODCLK		;Get now
	TXNE E,1B15  		;Want to reset timeout?
	 MOVEM T1,BSPACT(BSP)	;Remember time of last activity
	HRRZ T1,E		;CS36 In section address
	JRST 0(T1)		;Dispatch to processing routine


; BSP dispatch table, indexed by Pup Type
; Flags:
;	B0 - max state #:  Proper port states for this type
;	B15: Update activity timeout before dispatch
;	B16: Check Source Port before dispatch
;	B17: Check for Pup ID = Connection ID before dispatch

BSPDSP:	0			;(0)
	ALLSTT+1B16+RCVECH	;(1) Echo Me
	ALLSTT+1B16+RCVIEC	;(2) I'm An Echo
	ALLSTT+1B16+RCVBEC	;(3) I'm A Bad Echo
	ALLSTT+RCVERR		;(4) Error
	0			;(5)
	0			;(6)
	0			;(7)
	STTBTS(RFCO,LIST,OPEN,ENDO)+1B15+RCVRFC	;(10) Request for Connection
	ALLSTT+1B16+1B17+RCVABT	;(11) Abort
	ALLSTT+1B15+1B16+1B17+RCVEND ;(12) End
	ALLSTT+1B15+1B16+1B17+RCVENR ;(13) End Reply
	0			;(14)
	0			;(15)
	0			;(16)
	0			;(17)
	STTBTS(OPEN,ENDO)+1B15+1B16+RCVDAT ;(20) Data
	STTBTS(OPEN,ENDO)+1B15+1B16+RCVADA ;(21) AData
	STTBTS(OPEN,ENDI)+1B15+1B16+RCVACK ;(22) Acknowledgment
	STTBTS(OPEN,ENDO)+1B15+1B16+RCVMRK ;(23) Mark
	STTBTS(OPEN,ENDI,ENDO)+1B15+1B16+RCVINT	;(24) Interrupt
	STTBTS(OPEN,ENDI,ENDO)+1B15+1B16+RCVINR	;(25) Interrupt Reply
	STTBTS(OPEN,ENDO)+1B15+1B16+RCVAMA ;(26) AMark

NBSDSP==.-BSPDSP		;Length of the dispatch table

; Individual BSP Pup input processing routines
; All routines have the following calling sequence:
;	PB/ Packet buffer ptr
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
;	IOS/ BSPSTS(BSP)
; Returns +1 always
; Routine is expected to dispose of the packet
; Clobbers T1-T4
; Routines to handle RFC, Abort, End, and End Reply are located
;  near the FSM routines


; Echo
; ----

RCVECH:	MOVEI T1,PT.IEC		;Set type = "I'm an Echo"
	DPB T1,PUPTYP
	CALL SWPPRT		;Swap source and destination ports
	CALL SNDPU1		;Setup and send
	 CAI			;Ignore if failed
	RET    			;Done, packet buffer re-used


; I'm an Echo
; -----------

RCVIEC:				;Discard (we don't send EchoMe's)


; I'm a Bad Echo
; --------------

RCVBEC:	JRST RELPKT		;Discard (we don't send EchoMe's)



; Error
; -----

RCVERR:	PBUG(PUP,<RCVERR: Received Error Pup>)
	LDB T1,[POINT 16,PBCONT+5(PB),15]  ;Get error type
	CAIE T1,3		;Port IQ overflow?
	CAIN T1,1007		;Gateway OQ overflow?
	 JRST RCVER1		;Yes
	CAIN T1,2		;No such port?
	 CALL CHKSRC		;Yes, make sure source correct
	  JRST RELPKT		;Not, discard
	JRST RCVABT		;Yes, treat same as Abort

RCVER1:	HLRZ T1,BSPTIM(BSP)	;Get retransmission timeout
	IMULI T1,9		;Increase by 1/8
	LSH T1,-3
	CAIG T1,MAXRET		;Within maximum?
	 HRLM T1,BSPTIM(BSP)	;Yes, update
	JRST RELPKT		;Discard packet and return

; Input Pup processing routines (cont'd)

; AMark
; -----

RCVAMA:	TXO IOS,BSSAKF  	;Request that an Ack be sent

; Mark
; ----

RCVMRK:	LDB T1,PUPLEN		;Make sure it contains just 1 byte
	CAIE T1,MNPLEN+1
	 PBUG(DPR,<RCVMRK: Received Mark with incorrect length>)
	JRST RCVDAT		;Handle Mark like Data


; AData
; -----

RCVADA:	TXO IOS,BSSAKF  	;Request that an Ack be sent

; Data
; ----

RCVDAT:	STKVAR <RCVDPB>		;PB Pointer
	HRLM PB,RCVDPB		;Save PB pointer
	MOVEI T1,17		;Get Pup ID and clear garbage bits
	ANDCAB T1,PBHEAD+1(PB)
	LSH T1,-4		;Right-justify
	MOVEM T1,PBBSID(PB)	;Store in more convenient form
	LDB T2,PUPLEN		;Get Pup Length
	SUBI T2,MNPLEN		;Compute # data bytes
	JUMPE T2,RELPKT		;Flush packet if none
	MOVEM T2,PBBSBC(PB)	;Store in more convenient form
	MOVE T3,BSPILW(BSP)	;Get left window edge
	HRRZ T4,BSPIAL(BSP)	;Get width of window
	CALL CMPIVL		;Compare intervals
	 JRST RCVDA1		;Identical (ok but most unlikely)
	 JRST RCVDA1		;Pup subinterval of window
	 PBUG(DPR,<RCVDAT: Received Data Pup larger than window>)
	 JRST RCVDA1		;Intersect but not contained
	 JRST RELPKT		;Outside window, discard quietly

; Scan the BSP input queue and find where this packet belongs
RCVDA1:	MOVEI T3,BSPIBQ(BSP)	;Start at tail of input queue
RCVDA2:	HLRZ T3,0(T3)		;Get predecessor
	CAIN T3,BSPIBQ(BSP)	;Reached head of queue?
	 JRST [	HRRZ T1,0(T3)	;Yes, must belong here
		JRST RCVDA4]
	MOVE T1,PBHEAD+1(PB)	;No, get back ID of new Pup
	SUB T1,PBHEAD+1-PBBSPQ(T3) ;Compare to ID of queued Pup
	JUMPL T1,RCVDA2		;Repeat if existing ID larger

; Now C points to PBBSPQ of last old Pup with ID (= new Pup's ID
; B still contains the new Pup's length
	MOVE T1,PBBSID(PB)	;Get back ID of new Pup
	MOVEI PB,-PBBSPQ(T3)	;Point to head of existing packet
	MOVE T3,PBBSID(PB)	;Get its ID
	MOVE T4,PBBSBC(PB)	;Get # data bytes in it
	CALL CMPIVL		;Compare intervals
	 CAI			;+1: Identical, discard new packet
	 JRST [	HLRZ PB,RCVDPB	;+2: New packet is contained by
		JRST RELPKT]	; existing one, discard new
	 JRST [	MOVEI T1,PBBSPQ(PB) ;+3: Existing contained by
		JRST RCVDA4]	;   new, insert new before it
	 CAI			;+4: Intersect without containment
	HRRZ T1,PBBSPQ(PB)	;+5: Disjoint, get successor

; Input Pup processing routines (cont'd)

; Data (cont'd)
; ----

; Now ready to put the new packet on the input queue.
; A points to PBBSPQ word of packet before which the new packet
;  is to be inserted (i.e. to be the new packet's successor).
RCVDA4:	HLRZ PB,RCVDPB		;Recover new PB pointer
	HLRZ T3,BSPIQL(BSP)	;Get # Pups already on queue
	LDB T2,PBSIAP		;Get max # Pups allowed
	CAIL T3,(T2)		;Allocation exhausted?
	 PBUG(DPR,<RCVDAT: Received Data exceeding Pup allocation>)
	MOVSI T3,1		;No, add to count
	ADDM T3,BSPIQL(BSP)
	MOVEI T2,PBBSPQ(PB)	;Make ptr to queue link word
	CALL INSITQ		;Insert into queue

; Scan successor Pups for ones completely swallowed by the new one
RCVDA5:	HRRZ T1,PBBSPQ(PB)	;Get new Pup's successor
	CAIN T1,BSPIBQ(BSP)	;Make sure there is one
	 JRST RCVDA6		;None, skip this
	MOVE T3,PBBSID-PBBSPQ(T1) ;Get ID of existing Pup
	MOVE T4,PBBSBC-PBBSPQ(T1) ;Get # data bytes in it
	MOVE T1,PBBSID(PB)	;Get ID of new Pup
	MOVE T2,PBBSBC(PB)	;Get # data bytes in it
	CALL CMPIVL		;Compare intervals
	 BUG(RCVDAA)
	 BUG(RCVDAB)
	 JRST [	HRRZ T1,PBBSPQ(PB)  ; +3: Existing contained by
		MOVEI PB,-PBBSPQ(T1) ;  new, delete existing
		CALL DELBIQ
		HLRZ PB,RCVDPB	;Recover new PB pointer
		JRST RCVDA5]	;Repeat for new successor
	 CAI			;+4: Intersect without containment
				;+5: Disjoint

; If we filled in a hole, update byte count
RCVDA6:	MOVE T1,PBBSID(PB)	;Get ID of new Pup
	SUB T1,BSPILW(BSP)	;Compute bytes from left edge
	TXZ T1,-1B3  		; mod 2^32
	HRRZ T2,BSPIQL(BSP)	;Get # bytes to first hole
	CAILE T1,(T2)		;New Pup starts before or at hole?
	 JRST RCVDA7		;No
	ADD T1,PBBSBC(PB)	;Yes, add # bytes in new Pup
	CAILE T1,(T2)		;Now past start of hole?
	 HRRM T1,BSPIQL(BSP)	;Yes, update # bytes available
	HRRZ T1,PBBSPQ(PB)	;Advance to successor Pup
	CAIN T1,BSPIBQ(BSP)	;Ran off end of queue?
	 JRST RCVDA7		;Yes, stop here
	MOVEI PB,-PBBSPQ(T1)
	JRST RCVDA6		;Repeat until hit new hole

RCVDA7:	HRRZ T2,BSPIQL(BSP)	;New # bytes to first hole
	SKIPE T2		;Bytes now available?
	 CALL WAKBSI		;Yes, awaken input
	RET    			;Done

; Input Pup processing routines (cont'd)

; Acknowledgment
; --------------

RCVACK:	STKVAR <RCVACV>		;Old PB
	LDB T1,PUPLEN		;Get Pup Length
	CAIGE T1,MNPLEN+6	;Make sure big enough
	 PBUG(DPR,<RCVACK: Pup too small>)
	MOVE T1,PBHEAD+1(PB)	;Get Pup ID
	LSH T1,-4		;Right-justify
	MOVE T2,T1		;Copy it
	SUB T2,BSPOLW(BSP)	;Compute distance from left window edge
	TXZ T2,-1B3  		; modulo 2^32
	HRRZ T3,BSPOQL(BSP)	;Get width of window
	CAILE T2,(T3)		;Pup ID in window?
	 PBUG(DPR,<RCVACK: Received Ack with unreasonable ID>)
	MOVEM T1,BSPOLW(BSP)	;Yes, store new left window edge
	SUBI T3,(T2)		;Compute updated width
	HRRM T3,BSPOQL(BSP)
	HRLM PB,RCVACV		;Save pointer to Ack packet
	TXO IOS,BSRAKF  	;Note that we received an Ack

; Scan BSP output queue and discard packets now lying entirely
;  outside the updated window.  Ignore Pos/NegAcks ****************
RCVAC1:	HRRZ T1,BSPOBQ(BSP)	;Get BSP output queue head
	CAIN T1,BSPOBQ(BSP)	;Now empty?
	 JRST RCVAC5		;Yes
	MOVEI PB,-PBBSPQ(T1)	;No, make ptr to head PB
	MOVE T1,PBHEAD+1(PB)	;Get Pup ID
	LSH T1,-4		;Right-justify
	LDB T2,PUPLEN		;Get Pup Length
	ADDI T1,-MNPLEN-1(T2)	;Compute ID of last byte in Pup
	SUB T1,BSPOLW(BSP)	;Compare to left window edge
	LSH T1,4
	JUMPGE T1,RCVAC5	;Jump if in window
	CALL DELBOQ		;Outside, delete from output queue
	JRST RCVAC1		;Continue with next

; Update the allocations
RCVAC5:	HLRZ PB,RCVACV		;Recover ptr to Ack packet
	MOVE T4,[POINT 16,PBCONT(PB)]  ; Init byte ptr to data  
	ILDB T1,T4		;Get "Max bytes/Pup" field
	CAILE T1,MXPLEN-MNPLEN	;More than what we allow anyway?
	 MOVEI T1,MXPLEN-MNPLEN	;Yes, cut down
	LDB T2,PBSOBP		;Get current bytes/Pup
	CAIGE T1,(T2)		;Decreasing?
	 PBUG(PUP,<RCVACK: Allocated decreasing bytes per Pup>)
	DPB T1,PBSOBP		;Store updated bytes/Pup
	ILDB T1,T4		;Get "Number of Pups" field
	CAILE T1,MXBSOP		;More than maximum we allow?
	 MOVEI T1,MXBSOP	;Yes, limit
	HLRZ T2,BSPOQL(BSP)	;Get # Pups already queued
	SUBI T1,(T2)		;Compute additional Pups
	SKIPGE T1		;Make sure positive
	 SETZ T1,		;Force to zero otherwise
	DPB T1,PBSOAP		;Store # additional Pups allowed
	ILDB T1,T4		;Get "Number of bytes" field
	CAILE T1,MXBSOB		;More than maximum we allow?
	 MOVEI T1,MXBSOB	;Yes, limit
	HRRZ T2,BSPOQL(BSP)	;Get # bytes already queued
	SUBI T1,(T2)		;Compute additional bytes allowed
	SKIPGE T1		;Make sure positive
	 SETZ T1,		;Force to zero otherwise
	HRRM T1,BSPOAL(BSP)	;Store # additional bytes allowed

; Update status and return
	HRRZ T1,BSPOBQ(BSP)	;Get output queue head
	CAIN T1,BSPOBQ(BSP)	;Now empty?
	 TXZ IOS,BSNOQF  	;Yes, notify anyone watching this
	MOVE T1,BSPOAL(BSP)	;Get additional allocation
	TXNE T1,-1B7  		;Can send more Pups?
	TXNN T1,-1		;Can send more bytes?
	 CAIA			;No
	 CALL WAKBSO		;Yes, awaken BSP output
	JRST RELPKT		;Discard the Ack and return

; Input Pup processing routines (cont'd)

; Interrupt
; ---------

RCVINT:	MOVE T1,PBHEAD+1(PB)	;Get Pup ID
	LSH T1,-4		;Right-justify
	CAME T1,BSPRII(BSP)	;Same as next expected?
	 AOJA T1,RCVIN2		;No
	HRRE T2,PUPPSI(UNIT)	;Yes, get fork to interrupt
	JUMPGE T2,[LDB T1,INTPSI ;Get PSI channel to interrupt on
		CAIGE T1,^D36	;Armed?
		 CALL PSIRQF	;Yes, initiate PSI on channel
		JRST RCVIN1]
	AOJE T2,RCVIN1		;Jump if no assignment
	MOVEI T2,-400001(T2)	;NVT, get TTY #
	CALL LCKTTY		;Lock tty , get dynamic data
	 JRST RCVI1		;No tty, shouldnt happen
	PUSH P,T2		;Save data
	CALL NVTINT		;Process the interrupt
	POP P,T2
RCVI1:	CALL ULKTTY		;Unlock tty
RCVIN1:	AOS BSPRII(BSP)		;Advance receive interrupt ID
	MOVX T1,-1B3		; modulo 2^32
	ANDCAM T1,BSPRII(BSP)
	JRST RCVIN3		;Go send reply

; Here if Pup ID is not the same as expected
; If it is the expected ID -1, it is a duplicate which we
;  should acknowledge but not generate an interrupt.  Else flush.
; T1/ Pup ID +1
RCVIN2:	TXZ T1,-1B3  		;Make +1 modulo 2^32
	CAME T1,BSPRII(BSP)	;Was this a duplicate?
	 PBUG(DPR,<RCVINT: Received Interrupt with incorrect ID>)

; Here to send the acknowledging Interrupt Reply
RCVIN3:	MOVEI T1,PT.INR		;Set type = "Interrupt Reply"
	CALL SNDPUP		;Setup and send it back
	 CAI			;Ignore if failed
	RET    			;Done, packet buffer re-used


; Interrupt Reply
; ---------------

RCVINR:	SKIPL T1,BSPSII(BSP)	;Check for outstanding Interrupt
	 PBUG(DPR,<RCVINR: Received unexpected Interrupt Reply>)
	MOVE T2,PBHEAD+1(PB)	;Get Pup ID
	ANDCMI T2,17		;Clear garbage bits
	CAME T2,PBHEAD+1(T1)	;Same as outstanding Interrupt's ID?
	 PBUG(DPR,<RCVINR: Received Interrupt Reply with incorrect ID>)
	CALL RELPKT		;Yes, release the Interrupt Reply
	HRRZ PB,BSPSII(BSP)	;Get ptr to Interrupt again
	MOVE T1,PBHEAD+1(PB)	;Get Pup ID
	ADDI T1,20		;Increment and right-justify
	LSH T1,-4
	MOVEM T1,BSPSII(BSP)	;Store updated send Interrupt ID
	CALL DELOBQ		;Unqueue and release saved Interrupt
	HRLOI T1,377777		;Set Interrupt timer to infinity
	MOVEM T1,BSPITM(BSP)
	TXZ IOS,BSINTF  	;Clear Interrupt outstanding flag
	RET    			;Done, packet disposed of



; Check for retransmission of Interrupt Pup
; Assumes port locked and ac's setup
; Returns +1
; Clobbers T1-T4, PB

CKPINT:	SKIPL PB,BSPSII(BSP)	;Have outstanding Interrupt?
	 JRST [	HRLOI T1,377777	;No, reset timer to infinity
		JRST CKPIN1]
	CALL RETPUP		;Yes, queue for retransmission
	MOVE T1,PBTIME(PB)	;Get time of original transmission
	CALL NXTTIM		;Compute time of next check
CKPIN1:	MOVEM T1,BSPITM(BSP)	;Store in data block
	RET    

; Do BSP output processing -- flow control and retransmission
; Assumes port locked and ac's setup
; Returns +1 always
; Clobbers T1-T4, PB

DOBSPO:	CHKSTT <OPEN,ENDI>	;Reasonable state for BSP output?
	 JRST [	HRLOI T1,377777	;No, set timer to infinity
		MOVEM T1,BSPDTM(BSP)
		TXZ IOS,BSRAKF    ; Clear rec'd Ack flag
		RET]		;Return having done nothing
	TXZN IOS,BSRAKF  	;Received Ack?
	 JRST DOBSO6		;No, just check timers

; Ack was received
; See if we have any packets to retransmit
	HRRZ T1,BSPOBQ(BSP)	;Get head of queue
	CAIN T1,BSPOBQ(BSP)	;Empty?
	 JRST SETTMI		;Yes, set idle interval and return
	HLRZ T4,BSPTIM(BSP)	;No, get round-trip time
	ADD T4,PBTIME-PBBSPQ(T1) ;Check time stamp of first packet
	CAMLE T4,TODCLK		;Older than round-trip time?
	 JRST [	CALL CHKADA	;No retransmittable packets, want to send AData?
		 JRST SETTMH	;No, set hold interval and return
		CALL SETTMR	;Yes, compute time of next probe
		JRST SNDADA]	;Send null AData and return

; Retransmit all unacknowledged packets older than the estimated
;  round-trip delay
DOBSO1:	MOVEI PB,-PBBSPQ(T1)	;Make pointer to head of PB
	HLRZ T4,BSPTIM(BSP)	;Get round-trip time
	MOVN T4,T4		;Make negative
	ADD T4,TODCLK		;Compute cutoff time
	HRRZ T1,PBBSPQ(PB)	;Get successor of current packet
	CAIE T1,BSPOBQ(BSP)	;Is there one?
	 CAMGE T4,PBTIME-PBBSPQ(T1)  ; Yes, also retransmittable?
	 JRST DOBSO2		;No, possibly want to send AData
	CALL RETDAT		;Yes, retransmit current as Data
	HRRZ T1,PBBSPQ(PB)	;Get successor again
	JRST DOBSO1		;Repeat for it

; Here when have last retransmittable packet
DOBSO2:	CALL CHKADA		;Timer expired or allocation low?
	 JRST [	CALL RETDAT	;No, retransmit as Data
		JRST SETTMH]	;Set hold interval, return
	CALL RETADA		;Yes, retransmit as AData
	JRST SETTMR		;Set retransmission interval, exit

; Here if no Ack was received
; If data timer ran out, send an AData if necessary
; Also check error timer
DOBSO6:	MOVE T1,TODCLK		;Get now
	CAMGE T1,BSPDTM(BSP)	;Timed out?
	 RET			;No, done
	SUB T1,BSPACT(BSP)	;Yes, compute time since last activity
	LDB T2,PBSTMO		;Get error timeout interval
	LSH T2,^D12		;Convert to ms
	CAML T1,T2		;Too long?
	 CALL BSPTMO		;Yes, signal error timeout

	CALL SETTMI		;Compute time for next probe
	CALL SNDADA		;Send null AData
	RET    

; Determine whether want to (re)transmit AData, i.e.,
;  compute the predicate:
;	~ ADataOut and (AllocAlmostGone or Time[Oldest](Now-Hold)
; Assumes port is locked and ac's setup
; Returns +1:  Don't send AData
;	+2:  Send AData
; Clobbers T1, B

CHKADA:	HLRZ T1,BSPTIM(BSP)	;Get round-trip delay
	ADD T1,BSPATM(BSP)	;Add to time of last AData
	CAML T1,TODCLK		;More recent than round-trip time?
	 RET			;Yes, don't send another
	HRRZ T1,BSPOBQ(BSP)	;No, get head of queue
	CAIN T1,BSPOBQ(BSP)	;Empty?
	 JRST CHKALL		;Yes, skip this test
	MOVE T1,PBTIME-PBBSPQ(T1) ;No, get packet's time stamp
	ADDI T1,HLDINT		;Add hold time
	CAMGE T1,TODCLK		;Packet older than hold time?
	 RETSKP			;Yes, return +2: send AData
				;No, fall into CHKALL


; Check for allocation being low
; Assumes port is locked and ac's setup
; Returns +1:  allocation sufficient
;	+2:  allocation exhausted or almost exhausted
; Clobbers T1, B

CHKALL:	LDB T1,PBSOAP		;Get # Pups allocation
	HLRZ T2,BSPOQL(BSP)	;Get # Pups already queued
	ADDI T2,(T1)		;Derive initial allocation
	IMULI T1,^D100/ALLPCT	;Below threshold?
	CAMG T1,T2
	 RETSKP			;Yes, return +2: almost exhausted
	HRRZ T1,BSPOAL(BSP)	;No, now get # bytes allocation
	HRRZ T2,BSPOQL(BSP)	;Get # bytes already queued
	ADDI T2,(T1)		;Derive initial allocation
	IMULI T1,^D100/ALLPCT	;Below threshold?
	CAMG T1,T2
	 RETSKP			;Yes, return +2: almost exhausted
	RET    			;No, +1:  allocation sufficient



; Routines to compute and store new timeout
; All return +1 and clobber T1, B

; Enter here to set timer to Time[Oldest]+HoldTime
; If the queue is empty, the idle probe interval is used
SETTMH:	HRRZ T2,BSPOBQ(BSP)	;Get head of queue
	CAIN T2,BSPOBQ(BSP)	;Empty?
	 JRST SETTM2		;Yes, use idle interval
	MOVE T1,PBTIME-PBBSPQ(T2) ;Get age of packet
	ADDI T1,HLDINT		;Compute remaining hold time
	SUB T1,TODCLK
	HLRZ T2,BSPTIM(BSP)	;Get retransmission timeout
	CAIGE T1,(T2)		;Hold at least that long
	 MOVEI T1,(T2)
	JRST SETTM3		;Go set new time

; Enter here to set timer to Now + Retransmission interval
SETTMR:	HLRZ T1,BSPTIM(BSP)	;Get retransmission timeout
	JRST SETTM3		;Go set new time

; Enter here to set timer to idle probe interval, i.e.:
;  if AllocExhausted then Now+HLDINT else Now+IDLINT
SETTMI:	MOVE T1,BSPOAL(BSP)	;Get allocations
	TXNE T1,-1B7  		;Pups exhausted?
	TXNN T1,-1		;Bytes exhausted?
	 SKIPA T1,[HLDINT]	;Yes, use hold interval (shorter)
SETTM2:	MOVEI T1,PRBINT		;Not exhausted, use idle interval
SETTM3:	ADD T1,TODCLK		;Add increment to now
SETTM4:	MOVEM T1,BSPDTM(BSP)	;Set time of next check
	RET    

; Retransmit DatT1/Mark Pup as ADatT1/AMark
;	PB/ Packet buffer ptr
; Assumes port is locked and ac's setup
; Returns +1 always
; Clobbers T1-T4

RETADA:	LDB T1,PUPTYP		;Get existing type
	CAIN T1,PT.DAT		;Data?
	 MOVEI T1,PT.ADA	;Yes, change to AData
	CAIN T1,PT.MRK		;Mark?
	 MOVEI T1,PT.AMA	;Yes, change to AMark
	MOVE T2,TODCLK		;Save time we sent it
	MOVEM T2,BSPATM(BSP)
	JRST RETDA1		;Join common code

; Retransmit DatT1/Mark Pup as DatT1/Mark
;	PB/ Packet buffer ptr
; Assumes port is locked and ac's setup
; Returns +1 always
; Clobbers T1-T4

RETDAT:	LDB T1,PUPTYP		;Get existing type
	CAIN T1,PT.ADA		;AData?
	 MOVEI T1,PT.DAT	;Yes, change to Data
	CAIN T1,PT.AMA		;AMark?
	 MOVEI T1,PT.MRK	;Yes, change to Mark
RETDA1:	MOVE T2,PUPTYP		;Get byte ptr to existing type
	LDB T3,T2		;Get existing Pup Type
	CAIE T1,(T3)		;Changing type?
	 CALL UPDCKS		;Yes, do so and fix checksum
	AOS BSPOPR(BSP)		;Count retransmitted packets

; Fall into RETPUP
; Note there is a potential race here whose worst effect would
; be sending a Pup with a bad checksum.


; Retransmit a Pup
;	PB/ Packet buffer ptr
; Assumes port is locked and ac's setup
; Returns +1 always
; Clobbers T1-T4

RETPUP:	SKIPE PBIOBQ(PB)	;Already queued for transmission?
	 JRST RETPU1		;Yes
; Note that packet data already converted
	CALL PUTPUP		;No, put on queue
	 PBUG(PUP,<RETPUP: Output queue overflowed>)
	RET    

RETPU1:	PBUG(PUP,<RETPUP: Pup already on transmission queue>)
	RET    

; Compute time of next check (for retransmissions)
; Retransmission intervals start at the nominal interval
;  given by LH BSPTIM and double for each retransmission,
;  with a maximum given by the constant PRBINT (~15 seconds)
;	T1/ Time of previous check
; Assumes port is locked and ac's setup
; Returns +1:  T1/ Time of next check
; Generates timeout error if appropriate
; Clobbers T1, T2

NXTTIM:	SUB T1,TODCLK		;Get -(now-then)
	MOVNS T1		;Make positive
	PUSH P,T1		;Save it
	LDB T2,PBSTMO		;Get error timeout interval
	LSH T2,^D12		;Convert to ms
	CAML T1,T2		;Too long?
	 CALL BSPTMO		;Yes, signal timeout error
	POP P,T1		;Recover interval
	ASH T1,1		;Double it
	HLRZ T2,BSPTIM(BSP)	;Get retransmission timeout
	CAIGE T1,(T2)		;Use whichever is greater
	 MOVEI T1,(T2)
	CAILE T1,PRBINT		;But never greater than
	 MOVEI T1,PRBINT	; probe interval while idle
	ADD T1,TODCLK		;Add offset to now
	RET    



; Set timer for port
; Call after changing BSPDTM, BSPITM, or BSPFTM
; Returns +1
; Clobbers T1-T4

SETPTM:	CALL DELTQP		;Delete from timer queue if on it
	MOVE T1,BSPDTM(BSP)	;Get time to send next AData
	CAMLE T1,BSPITM(BSP)	;Retransmit Interrupt sooner?
	 MOVE T1,BSPITM(BSP)	;Yes, use it
	CAMLE T1,BSPFTM(BSP)	;Check FSM sooner?
	 MOVE T1,BSPFTM(BSP)	;Yes, use that
	CALL ADDTQP		;Add port to timer queue
	RET    



; Send a null AData (for probing)
;	BSP/ BSP data block ptr
; Returns +1 always
; Clobbers T1-T4, PB

SNDADA:	MOVEI T2,MNPBLN		;Allocate minimum-length Pup
	CALL ASGPKT
	 RET			;Can't, forget it
	MOVEI T1,MNPLEN		;Set Pup Length
	DPB T1,PUPLEN
	HRRZ T1,BSPOQL(BSP)	;Get # of bytes queued
	ADD T1,BSPOLW(BSP)	;Compute ID of first byte not sent
	LSH T1,4		;Left-justify
	MOVEM T1,PBHEAD+1(PB)	;Store ID in packet
	MOVEI T1,PT.ADA		;Pup Type = AData
	CALL SNDPUP		;Send it
	 CAI			;Ignore failure
	MOVE T1,TODCLK		;Remember time of last AData
	MOVEM T1,BSPATM(BSP)
	AOS BSPPPG(BSP)		;Count probe packets generated
	RET    

; Send an Ack
;	UNIT/ Pup unit #
;	BSP/ BSP data block pointer
;	IOS/ BSPSTS(BSP)
; Returns +1 always
; Clobbers T1-T4, PB

SNDACK:	MOVEI T2,PBHEAD+<MNPLEN+6+6*MXSACK+3>/4  ; Max-length Ack
	CALL ASGPKT		;Assign packet buffer
	 JRST [	TXO IOS,BSSAKF    ; Failed, note ack still needed
		RET]

; Compute Pup ID for cumulative acknowledgement
	HRRZ T1,BSPIQL(BSP)	;Get offset from left edge to hole
	ADD T1,BSPILW(BSP)	;Compute ID of first hole
	LSH T1,4			;Left-justify
	MOVEM T1,PBHEAD+1(PB)	;Set Pup ID

; Setup the allocation block
	PUSH P,[POINT 16,PBCONT(PB)]  ; Init byte ptr into Pup
	LDB T1,PBSIBP		;Get maximum bytes/Pup
	IDPB T1,0(P)		;Store in Pup
	LDB T1,PBSIAP		;Get maximum # Pups allowed
	HLRZ T3,BSPIQL(BSP)	;Get # Pups already on queue
	SUBI T1,(T3)		;Compute remainder
	SKIPGE T1		;Make sure positive
	 SETZ T1,		;Make zero if negative
	IDPB T1,0(P)		;Store # Pups allowed into Pup
	HRRZ T2,BSPIAL(BSP)	;Get maximum # bytes allowed
	SUB T2,BSPIQL(BSP)	;Subtract # bytes used
	TXNE T2,400000		;Make sure positive
	 SETZ T2,		;Make zero if negative
	IDPB T2,0(P)		;Store # bytes allowed into Pup
	SKIPE T1		;Sending zero # Pups allocation?
	 TXNN T2,-1		;Sending zero # bytes allocation?
	 TXOA IOS,BSZALF  	;Yes, remember we did this
	 TXZ IOS,BSZALF  	;No, clear flag

IFG MXSACK,<		;Only if allowed to send specific Acks
; Specifically acknowledge Pups beyond first hole
; First, scan forward from tail to find first packet past hole
	MOVEI T1,BSPIBQ(BSP)	;Get pointer to queue header
SNDAC2:	HLRZ T1,0(T1)		;Get predecessor
	CAIN T1,BSPIBQ(BSP)	;Reached head?
	 JRST SNDAC3		;Yes
	MOVE T2,PBHEAD+1-PBBSPQ(T1) ;No, get ID of this packet
	SUB T2,PBHEAD+1(PB)	;Compare to ID of Ack
	JUMPGE T2,SNDAC2	;Repeat if still beyond hole
SNDAC3:	HRRZ T1,0(T1)		;Ok, now get successor
	CAIN T1,BSPIBQ(BSP)	;Make sure there is one
	 JRST SNDAC7		;No Pups to specifically ack

; Now T1/ pointer to PBBSPQ of first Pup past hole
; Build PosAck blocks
	MOVSI T4,-MXSACK	;Init max # of specific acks
SNDAC4:	HRRI T4,(T1)		;Save ptr to start of range
SNDAC5:	MOVE T2,PBBSID-PBBSPQ(T1) ;Get ID right-justified
	ADD T2,PBBSBC-PBBSPQ(T1) ;Add number of bytes in packet
	LSH T2,4		;Left-justify
	HRRZ T1,0(T1)		;Get successor
	CAIN T1,BSPIBQ(BSP)	;Make sure there is one
	 JRST SNDAC6		;No, end of queue
	MOVE T3,PBHEAD+1-PBBSPQ(T1)  ; Yes, get its ID left-justified
	SUB T3,T2		;See if touch or overlap previous
	JUMPLE T3,SNDAC5	;Loop if so, to combine ranges
SNDAC6:	SUB T2,PBHEAD+1-PBBSPQ(T4)  ; No, compute length of range
	LSH T2,-4		;Right-justify
	IORI T2,100000		;Set flag to note PosAck
	IDPB T2,0(P)		;Store flag and # bytes in Pup
	MOVE T2,PBBSID-PBBSPQ(T4) ;Get starting ID right-justified
	ROT T2,-^D16		;Right-justify high 16 bits
	IDPB T2,0(P)		;Store in Pup
	ROT T2,^D16		;Right-justify low 16 bits
	IDPB T2,0(P)		;Store in Pup
	CAIE T1,BSPIBQ(BSP)	;Reached end of queue?
	 AOBJN T4,SNDAC4	;No, repeat if not past limit

; Still in IFG MXSACK conditional

; SNDACK (cont'd)

; Now finish up and send the Ack
SNDAC7:	POP P,T1		;Restore byte pointer
	CALL ENDPUP		;Compute length and trim packet
> ; End IFG MXSACK
IFE MXSACK,<
	ADJSP P,-1		;Flush byte ptr from stack
	MOVEI T1,MNPLEN+6	;Constant if no specific acks
	DPB T1,PUPLEN		;Store Pup Length
>
	MOVEI T1,PT.ACK		;Pup type = "Ack"
	CALL SNDPUP		;Setup header and send it
	 TXO IOS,BSSAKF  	;Couldn't, note Ack still needed
	RET    			;Done



; Compute Pup Length given byte pointer, and trim excess
;	T1/ Byte ptr to last byte stored
;	PB/ Packet buffer ptr
; Returns +1 always
; Clobbers T1-T4

ENDPUP:	MOVE T2,T1		;Word address
	TXO T2,IFIW		;Force refrence to be local
	TXZ T2,<377700,,0>	;Mask out P and S fields
	MOVEI T2,@T2		;Compute address of last word
	SUBI T2,PBHEAD-1(PB)	;Compute # 36-bit words used
	LSH T2,2		;Convert to bytes
	LSH T1,-^D33		;Get bytes not used in last word
	SUBI T2,(T1)		;Compute Pup Length
	ADDI T2,2		;Include checksum
	DPB T2,PUPLEN		;Store it
	CALL TRMUPB		;Trim excess from packet buffer
	RET    



; Set up header and send Pup
;	T1/ Pup Type to be stored in packet
;	PB/ Packet buffer pointer
;	UNIT/ Pup unit #
;	IOS/ BSPSTS(BSP)
; Caller is expected to setup Pup Length and ID
; A Pup once passed here is gone forever
; Returns +1:  Failed, packet buffer discarded
;	+2:  Succeeded, packet buffer queued for output
; Clobbers T1-T4

SNDPUP:	DPB T1,PUPTYP		;Store Pup Type in packet
	CALL SETPRT		;Set up source and dest ports

; Enter here if type and ports are already setup
SNDPU1:	SETZB T1,PBBSPQ(PB)	;Clear BSP queue linkages
	DPB T1,PUPTCB		;Zero out Transport Control byte
	CALL SETCHK		;Set Pup Checksum appropriately
	CALL PUOCNV		;Convert packet data (but not checksum)
	CALL PUTPUP		;Queue Pup for output
	 PBUG(DPR,<SNDPUP: Output queue overflowed>)
	RETSKP			;Done, skip return

; Set up Source and Destination Ports in Pup
;	PB/ Packet buffer pointer
;	UNIT/ Pup unit #
; Returns +1 always

SETPRT:	SKIPN T3,PUPFPT(UNIT)	;Get foreign port descriptor
	 BUG(SETPRA)
	MOVE T1,1(T3)		;Get destination net,,host
	MOVE T2,2(T3)		;Get destination socket
	LSH T2,4		;Left-justify socket
	LSHC T1,-8		;Concatenate host and socket
	LSH T1,-^D10		;Right-justify net
	LSHC T1,-8		;Concatenate net/host/high socket
	MOVEM T2,PBHEAD+2(PB)	;Store dest net/host/high socket
	MOVE T1,2(T3)		;Get dest socket again
	MOVE T2,PUPLNH(UNIT)	;Get local net/host left-justified
	LSHC T1,-^D16		;Concatenate low dest socket to it
	MOVEM T2,PBHEAD+3(PB)	;Store source net/host, high dest socket
	MOVE T1,PUPLSK(UNIT)	;Get local socket
	LSH T1,4		;Left-justify
	MOVEM T1,PBHEAD+4(PB)	;Store source socket in PB
	RET    


; Set Pup Checksum appropriately
;	PB/ Packet buffer pointer
;	IOS/ BSPSTS(BSP)
; Returns +1 always
; Clobbers T1-T4

SETCHK:	TXNN IOS,BSNCHK  	;Checksumming inhibited?
	 JRST SETCKS		;No, compute and set checksum
	CALL GPTCKS		;Yes, get ptr to checksum field
	SETO T1,		;Deposit nil checksum
	DPB T1,T2
	RET    



; Compare sequence number intervals
;	T1/ Left edge of interval 1
;	T2/ Length of interval 1
;	T3/ Left edge of interval 2
;	T4/ Length of interval 2
; Returns +1:  Intervals are identical
;	+2:  Interval 1 is a subinterval of 2
;	+3:  Interval 2 is a subinterval of 1
;	+4:  Intervals intersect but neither contains the other
;	+5:  Intervals are disjoint
; Clobbers T1, C

CMPIVL:	SUBM T3,T1		;A _ (L2 - L1) mod 2^32
	TXZ T1,-1B3  
	MOVN T3,T1		;C _ (L1 - L2) mod 2^32
	TXZ T3,-1B3  
	CAMN T2,T4		;Lengths same?
	 JUMPE T1,CPOPJ		;Yes, return +1 if left edges same
	CAMGE T1,T2		;Check for overlaps
	 JRST CMPIV1		;Overlap, maybe 2 subinterval of 1
	CAMGE T3,T4
	 JRST CMPIV2		;Overlap, maybe 1 subinterval of 2
	POP P,T1		;No overlap, return +5
	JRST 4(T1)

; Here on overlap with possibility of 2 being a subinterval of 1
CMPIV1:	ADD T1,T4		;Add 2's size to its offset from 1
	CAMLE T1,T2		;2 completely contained by 1?
	 JRST SK3RET		;No, return +4
	JRST SK2RET		;Yes, return +3

; Here on overlap with possibility of 1 being a subinterval of 2
CMPIV2:	ADD T3,T2		;Add 1's size to its offset from 2
	CAMLE T3,T4		;1 completely contained by 2?
	 JRST SK3RET		;No, return +4
	RETSKP			;Yes, return +2

; Flush all packets from BSP queues
; Assumes port is locked
; Returns +1 always
; Clobbers T1-T4, PB

FLSBSQ:	HLRZ PB,BSPCUR(BSP)	;Delete current input PB if any
	SKIPE PB
	 CALL RELPKT
	HRRZ PB,BSPCUR(BSP)	;Delete current output PB if any
	SKIPE PB
	 CALL RELPKT
	SETZM BSPCUR(BSP)	;Mark no current PB's
FLSBS1:	HRRZ T1,BSPIBQ(BSP)	;Get head of BSP input queue
	CAIN T1,BSPIBQ(BSP)	;Empty?
	 JRST FLSBS2		;Yes
	MOVEI PB,-PBBSPQ(T1)	;No, get ptr to head of PB
	CALL DELBIQ		;Delete from queue
	JRST FLSBS1		;Repeat until empty
FLSBS2:	HRRZ T1,BSPOBQ(BSP)	;Get head of BSP output queue
	CAIN T1,BSPOBQ(BSP)	;Empty?
	 JRST FLSBS3		;Yes
	MOVEI PB,-PBBSPQ(T1)	;No, get ptr to head of PB
	CALL DELBOQ		;Delete from queue
	JRST FLSBS2		;Repeat until empty
FLSBS3:	SKIPGE PB,BSPSII(BSP)	;Have pending send Interrupt?
	 CALL DELOBQ		;Yes, release PB
	SETZM BSPSII(BSP)	;Clear pointer
	HRRZ PB,BSPTIM(BSP)	;Have a saved Abort packet?
	SKIPE PB
	 CALL RELPKT		;Yes, release it
	HLLZS BSPTIM(BSP)	;Clear pointer
	RET    


; Delete Pup from BSP input queue
;	PB/ Packet buffer ptr
; Assumes port is locked
; Returns +1, releases packet buffer, updates Pup count
; Clobbers T1-T4

DELBIQ:	MOVEI T1,PBBSPQ(PB)	;Make ptr to link word
	CALL DELITQ		;Delete item from queue
	CALL RELPKT		;Release packet buffer
	MOVSI T1,-1		;Decrement # Pups in BSP queue
	ADDB T1,BSPIQL(BSP)
	SKIPGE T1		;Check for over-decrementing
	 BUG(DELBIZ)
	RET    


; Delete Pup from BSP output queue
;	PB/ Packet buffer ptr
; Assumes port is locked
; Returns +1, releases packet buffer, updates Pup count
; Clobbers T1-T4

DELBOQ:	HLRZ T1,PBBSPQ(PB)	;Get predecessor
	HRRZ T2,PBBSPQ(PB)	;Get successor
	HRLM T1,(T2)		;Fix links between predecessor
	HRRM T2,(T1)		; and successor
	CALL DELOBQ		;Remove from PUPOBQ if on it
	MOVSI T1,-1		;Decrement # Pups in BSP queue
	ADDB T1,BSPOQL(BSP)
	SKIPGE T1		;Check for over-decrementing
	 BUG(DELBOZ)
	RET    

; Routines to lock/unlock BSP port
; Note:  While a port is locked, the up-to-date flags are
;  carried in IOS, and are stored in PUPSTS(UNIT) when the
;  port is unlocked.  Exception:  the BSWAKF flag is always
;  updated in core (while the port is locked by someone else).


; Lock port iff it is a BSP port
;	UNIT/ Pup unit #
; Returns +1:  Not a BSP port, BSP/ 0
;	+2:  Port locked,
;	BSP/ BSP data block pointer
;	IOS/ PUPSTS(UNIT)
; Clobbers nothing else

LCKBSQ:	HRRZ BSP,PUPLNH(UNIT)	;Get BSP linkage
	JUMPE BSP,CPOPJ		;Return +1 if not BSP port
	AOS 0(P)		;Ok, preset skip return


; Lock BSP port (wait if already locked)
;	UNIT/ Pup unit #
; Returns +1 always:
;	BSP/ BSP data block pointer
;	IOS/ PUPSTS(UNIT)
; Clobbers nothing else

LCKBSP:	LOCK(PRTLCK,,SPQ)	;Lock out changes to port table
	CALL LCKBSA		;Attempt to lock port
	 JRST [	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Can't, unlock table
		PUSH P,T1	;Save an ac
		MOVSI T1,(UNIT)	;Set scheduler test
		HRRI T1,BSLCKT
		MDISMS		;Wait until port unlocked
		POP P,T1
		JRST LCKBSP]	;Try again to lock
	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Ok, unlock table
	RET    			;Return

	RESCD

; Scheduler test for BSP port unlocked
; Arg is Pup unit #

BSLCKT:	MOVX T2,BSLCKF		;Flag to test
	TDNE T2,PUPSTS(T1)	;Locked?
	 JRST 0(T4)		;Yes, wait
	JRST 1(T4)		;Unlocked, wakeup

	SWAPCD


; Attempt to lock BSP port
; PRTLCK must be locked by caller
;	UNIT/ Pup unit #
; Returns +1: Failed, already locked, IOS clobbered
;	+2: Ok, we have locked it:
;		BSP/ BSP data block pointer
;		IOS/ PUPSTS(UNIT)
; Clobbers nothing else

LCKBSA:	HRRZ BSP,PUPLNH(UNIT)	;Get linkage
	SKIPN BSP		;Make sure have BSP port
	 BUG(LCKBSZ)
	MOVX IOS,BSLCKF		;Flag to test
	TDNE IOS,PUPSTS(UNIT)	;Already locked?
	 RET			;Yes, fail
	IORB IOS,PUPSTS(UNIT)	;Lock port, setup IOS
	RETSKP			;Give success return

; Unlock port iff it is a BSP port
;	UNIT/ Pup unit #
;	BSP/ BSP data block pointer (0 if none, see LCKBSQ)
;	IOS/ Status
; Returns +1, Clobbers nothing

ULKBSQ:	JUMPE BSP,CPOPJ		;Do nothing if not BSP port


; Unlock BSP port
;	UNIT/ Pup unit #
;	IOS/ Status
; Returns +1, Clobbers nothing

ULKBSP:	TXZN IOS,BSLCKF  	;Clear BSP lock bit
	 BUG(ULKBSZ)
	EXCH IOS,PUPSTS(UNIT)	;Store updated status word
	AND IOS,[BSWAKF]	;If wakeup pending,
	IORB IOS,PUPSTS(UNIT)	; be sure bit stays on
	RET    



; Generate BSP error timeout
; Assumes port is locked and ac's setup
; Returns +1
; Clobbers T1, B

BSPTMO:	TXON IOS,BSTIMF  	;Ignore if already timed out
	 CALL PUPSTC		;Generate state change interrupt
	RET    



; Awaken BSP input if necessary
; Assumes port is locked and ac's setup
; Returns +1
; Clobbers T1, B

WAKBSI:	TXO IOS,BSINPF  	;Flag input possible now
	HRRE T2,PUPPSI(UNIT)	;Get port owner
	AOJGE T2,CPOPJ		;Done if unassigned or assigned to fork
	SIGPBP(NVT)		;Request NVT scan
	RET    


; Awaken BSP output if necessary
; Assumes port is locked and ac's setup
; Returns +1
; Clobbers T1, B

WAKBSO:	TXO IOS,BSOUTF  	;Flag output possible now
	HRRE T2,PUPPSI(UNIT)	;Get port owner
	AOJGE T2,CPOPJ		;Done if unassigned or assigned to fork
	MOVEI T2,-400001(T2)	;Assigned to NVT, get TTY #
	NOSKED			;Dont let dynamic data change
	CALL STADYN		;Get dynamic data
	 JRST WAKBS1
	CALL PPSOBE		;Any chars to be processed?
	 JRST [	SIGPBP(NVT)	;Request NVT scan
		JRST WAKBS1 ]
WAKBS1:	OKSKED
	RET    

; Build BSP data block
; Returns +1:  Failed (no room)
;	+2:  Ok, BSP/ pointer to block
; Clobbers T1-T4, BSP

BLDBSP:	MOVEI T2,BSPSIZ		;Size of BSP data block
	CALL ASGPFR		;Allocate a block
	 RET			;Can't, fail
	MOVEI BSP,(T1)		;Ok, put ptr in standard ac
	AOS 0(P)		;Preset skip, fall into INIBSP


; Initialize BSP data block
;	BSP/ Data block ptr
; Returns +1 always
; Clobbers T1, B

INIBSP:	MOVSI T1,-BSPSIZ	;Set AOBJN ptr
	HRLI BSP,1		;Set index register for store
	TXO BSP,IFIW		;CS36 Force local section refernce
INIBS1:	XCT IBSTAB(T1)		;Get an initial value
	MOVEM T2,@BSP		;Store in block
	AOBJN T1,INIBS1		;Repeat for all
	RET    

; Initialization table
; Each entry loads B with the corresponding initial value

DEFINE X(LOC,INST) <
IFL LOC-<.-IBSTAB>,<PRINTX ?IBSTAB entries out of order>
REPEAT LOC-<.-IBSTAB>,<SETZ T2,>
	INST
>

IBSTAB:	X BSPHDR,<MOVE T2,[<DETINT*^D1000/10000>B15+BSPSIZ]>
	X BSPTIM,<MOVSI T2,RETINT>
	X BSPACT,<MOVE T2,TODCLK>
	X BSPDTM,<HRLOI T2,377777>
	X BSPITM,<HRLOI T2,377777>
	X BSPFTM,<HRLOI T2,377777>
	X BSPSTM,<MOVE T2,TODCLK>
	X BSPIBQ,<CALL INIBSQ>
	X BSPOBQ,<CALL INIBSQ>
	X BSPCID,<SETO T2,>
	X BSPIAL,<MOVE T2,[<MXBSIP>B7+<MXPLEN-MNPLEN>B17+MXBSIB]>
	X BSPSIZ,<>

INIBSQ:	MOVEI T2,@BSP
	HRLI T2,(T2)
	RET    

; -----------------------------------------------------------------
;	Pup Finite State Machine (rendezvous, termination)
; -----------------------------------------------------------------

	SWAPCD


; Port states

S.CLOS==0	;Closed
S.RFCO==1	;RFC Outstanding
S.LIST==2	;Listening
S.OPEN==3	;Open
S.ENDI==4	;End In
S.ENDO==5	;End Outstanding
S.DALY==6	;Dallying
S.ABOR==7	;Abort

NPSTAT==10	;Number of states
ALLSTT==-1B<NPSTAT-1>  ; Bit mask corresponding to all states


; Events

E.OPNC==0	;OPENF mode 0 or 1 (connect)
E.OPNL==1	;OPENF mode 2 or 3 (listen)
E.OPNN==2	;OPENF mode 4 (no rendezvous)
E.CLSN==3	;Normal CLOSF
E.CLST==4	;CLOSF after timeout
E.RRFC==5	;Received RFC
E.RABT==6	;Received Abort
E.REND==7	;Received End
E.RENR==10	;Received End Reply
E.TIMO==11	;Timeout (for retransmissions)


; Actions

A.NOOP==0	;No action
A.SRF1==1	;Send RFC (initiate connection)
A.SRF2==2	;Send RFC (respond to incoming RFC)
A.OPNC==3	;Open connection
A.SEND==4	;Send End
A.SENR==5	;Send End Reply
A.SABT==6	;Send Abort
A.LERR==7	;Local error (improper locally-generated event)
A.FERR==10	;Foreign error (improper Pup type received)


A.==<S.==0>	;For unused fields in action/transition matrices

; Routines to generate events
; All assume the port is locked and ac's UNIT, BSP, IOS setup.
; If the event is generated by an incoming Pup, PB points to the
;  packet buffer.


; Routine called from DOBSPI upon receipt of an RFC
;	PB/ Packet buffer pointer
; Returns +1 always
; Clobbers T1-T4, releases packet buffer always

RCVRFC:	LDB T1,PUPLEN		;Get Pup Length
	CAIGE T1,MNPLEN+6	;Make sure big enough
	 PBUG(DPR,<RCVRFC: Pup too small>)
	CALL GTCPRT		;Get Connection Port
	 PBUG(DPR,<RCVRFC: RFC with improper Connection port>)
	LDB T4,PBSSTT		;Get current port state
	CAIN T4,S.RFCO		;RFC Out?
	 JRST RCVRF1		;Yes
	CAIN T4,S.LIST		;Listening?
	 JRST RCVRF2		;Yes

; Open (or End Out), probably a retransmission
	CALL CHKSR1		;See if matches foreign port
	 PBUG(DPR,<RCVRFC: RFC with non-matching Connection Port>)
	MOVE T1,PBHEAD+1(PB)	;Get Pup ID
	LSH T1,-4		;Right-justify
	CAME T1,BSPCID(BSP)	;Compare to Connection ID
	 PBUG(DPR,<RCVRFC: RFC with incorrect ID>)
	TXNN IOS,BSLISF  	;Formerly in listening state?
	 JRST RCVRF4		;No, discard packet and ignore
	JRST RCVRF3		;Yes, go generate event

; RFC Out, ID must match our Connection ID
RCVRF1:	MOVE T1,PBHEAD+1(PB)	;Get Pup ID
	LSH T1,-4		;Right-justify
	CAME T1,BSPCID(BSP)	;Compare to Connection ID
	 PBUG(DPR,<RCVRFC: RFC with incorrect ID>)

; Listening or RFC Out, Source Port must pass address filter
RCVRF2:	CALL CHKSRC		;Check Source Port
	 PBUG(DPR,<RCVRFC: RFC from incorrect Source Port>)
RCVRF3:	MOVEI T1,E.RRFC		;Ok, generate Received RFC event
	CALL PUPFSM
RCVRF4:	CALL RELPKT		;Release packet buffer
	RET    

; Routine called from DOBSPI upon receipt of an End
;	PB/ Packet buffer pointer
; Returns +1 always
; Clobbers T1-T4, releases packet buffer always

RCVEND:	MOVEI T1,E.REND		;Generate Received End event
	JRST RCVEN1

; Routine called from DOBSPI upon receipt of an End Reply
;	PB/ Packet buffer pointer
; Returns +1 always
; Clobbers T1-T4, releases packet buffer always

RCVENR:	MOVEI T1,E.RENR		;Generate Received End Reply event
RCVEN1:	CALL PUPFSM
	CALL RELPKT		;Release packet buffer
	RET    


; Routine called from DOBSPI upon receipt of an Abort
;	PB/ Packet buffer pointer
; Returns +1 always
; Clobbers T1-T4, disposes of packet buffer always

RCVABT:	MOVEI T1,E.RABT		;Generate Received Abort event
	CALL PUPFSM
	HRRZ T1,BSPTIM(BSP)	;See if already have Abort packet
	JUMPN T1,RELPKT		;If so, just discard this
	HRRM PB,BSPTIM(BSP)	;Don't have one, store this
	RET    

; Routine to step FSM for port
;	T1/ Event number
;	C, T4/ Arguments for action routine, if appropriate
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
;	IOS/ Port status word
;	PB/ Pointer to incoming packet, if any
; Returns +1
; Clobbers T1-T4, updates others where appropriate

PUPFSM:	CALL PUPFSC		;Do the work
	CALL SETPTM		;Set timer appropriately
	RET    

; Enter here from DOBSP only
PUPFSC:	PUSH P,PB		;Save packet buffer ptr if any
	PUSH P,T1		;Save event number
	LDB T2,PBSSTT		;Get current port state
	LDB T1,PFSACT(T2)	;Get action index
	XCT EVNACT(T1)		;Do action associated with event
	POP P,T1		;Recover event number
	LDB T2,PBSSTT		;Get current port state
	LDB T1,PFSTRN(T2)	;Get successor from transition tbl
	DPB T1,PBSSTT		;Store in port status word
	DPB T1,PBSSTM		;Store in memory also
	CAIE T1,S.CLOS		;Entering Closed or Abort state?
	 CAIN T1,S.ABOR
	 TXO IOS,BSERRF  	;Yes, signal bad state for BSP
	CAIN T1,(T2)		;State changed?
	 JRST PUPFS2		;No
	MOVE T2,TODCLK		;Yes, record time of state change
	MOVEM T2,BSPSTM(BSP)
	CAIE T1,S.OPEN		;Entering Open state?
	 JRST PUPFS1		;No
	MOVEM T2,BSPDTM(BSP)	;Yes, activate data probing
	MOVEM T2,BSPATM(BSP)
PUPFS1:	CALL PUPSTC		;Generate state change psi
PUPFS2:	POP P,PB		;Restore packet buffer ptr
	LDB T1,PBSSTT		;Get new state
	CAIE T1,S.RFCO		;RFC or End Outstanding?
	 CAIN T1,S.ENDO
	 JRST [	MOVE T1,BSPSTM(BSP) ;Yes, get time of last state change
		CALL NXTTIM	;Compute time for next check
		JRST PUPFS3]	;Go set it
	CAIN T1,S.DALY		;No, dallying?
	 JRST [	HLRZ T1,BSPTIM(BSP)  ; Yes, get retransmission timeout
		IMULI T1,5	;Dally this long
		ADD T1,TODCLK	;Compute time of next check
		JRST PUPFS3]	;Go set it
	HRLOI T1,377777		;Set timer to infinity for other states
PUPFS3:	MOVEM T1,BSPFTM(BSP)	;Store time of next check
	RET    


; Byte pointers for accessing action and transition tables
; Indexed by current state #, expects event # in A

PFSACT:
REPEAT NPSTAT,<
	POINT 4,FSMACT(T1),4*<.-PFSACT>+3
>


PFSTRN:
REPEAT NPSTAT,<
	POINT 4,FSMTRN(T1),4*<.-PFSTRN>+3
>

; Action table
; Event yields row, current state yields column

DEFINE XX ($1,$2,$3,$4,$5,$6,$7,$8,$9) <
	BYTE(4) A.'$1, A.'$2, A.'$3, A.'$4, A.'$5, A.'$6, A.'$7, A.'$8, A.'$9
>

; Current state						;Event
;	   CLOS RFCO LIST OPEN ENDI ENDO DALY ABOR

FSMACT:	XX SRF1,LERR,LERR,LERR,LERR,LERR,LERR,LERR	;OPNC
	XX NOOP,LERR,LERR,LERR,LERR,LERR,LERR,LERR	;OPNL
	XX NOOP,LERR,LERR,LERR,LERR,LERR,LERR,LERR	;OPNN
	XX NOOP,SABT,NOOP,SEND,SENR,NOOP,NOOP,NOOP	;CLSN
	XX NOOP,SABT,NOOP,SABT,SABT,SABT,NOOP,NOOP	;CLST
	XX FERR,OPNC,SRF2,SRF2,FERR,SRF2,FERR,FERR	;RRFC
	XX FERR,NOOP,FERR,NOOP,NOOP,NOOP,NOOP,NOOP	;RABT
	XX FERR,FERR,FERR,NOOP,NOOP,SENR,SENR,FERR	;REND
	XX FERR,FERR,FERR,FERR,FERR,SENR,NOOP,FERR	;RENR
	XX NOOP,SRF1,NOOP,NOOP,NOOP,SEND,NOOP,NOOP	;TIMO


; Transition table
; Event yields row, current state yields column

DEFINE XX ($1,$2,$3,$4,$5,$6,$7,$8,$9) <
	BYTE(4) S.'$1, S.'$2, S.'$3, S.'$4, S.'$5, S.'$6, S.'$7, S.'$8, S.'$9
>

; Current state						;Event
;	   CLOS RFCO LIST OPEN ENDI ENDO DALY ABOR

FSMTRN:	XX RFCO,RFCO,LIST,OPEN,ENDI,ENDO,DALY,ABOR	;OPNC
	XX LIST,RFCO,LIST,OPEN,ENDI,ENDO,DALY,ABOR	;OPNL
	XX OPEN,RFCO,LIST,OPEN,ENDI,ENDO,DALY,ABOR	;OPNN
	XX CLOS,CLOS,CLOS,ENDO,DALY,ENDO,DALY,CLOS	;CLSN
	XX CLOS,CLOS,CLOS,CLOS,CLOS,CLOS,CLOS,CLOS	;CLST
	XX CLOS,OPEN,OPEN,OPEN,ENDI,ENDO,DALY,ABOR	;RRFC
	XX CLOS,ABOR,LIST,ABOR,ABOR,ABOR,ABOR,ABOR	;RABT
	XX CLOS,RFCO,LIST,ENDI,ENDI,DALY,DALY,ABOR	;REND
	XX CLOS,RFCO,LIST,OPEN,ENDI,CLOS,CLOS,ABOR	;RENR
	XX CLOS,RFCO,LIST,OPEN,ENDI,ENDO,CLOS,ABOR	;TIMO


; Table of actions in event/action matrix

EVNACT:	CAI			;NOOP - No action
	CALL SNDIRF		;SRF1 - Send initiating RFC
	CALL SNDARF		;SRF2 - Send answering RFC
	CALL OPNCON		;OPNC - Open connection
	CALL SNDEND		;SEND - Send End
	CALL SNDENR		;SENR - Send End Reply
	CALL ABORT		;SABT - Send Abort
	CALL LCLERR		;LERR - Local error
	CALL FORERR		;FERR - Foreign error

; Action routines
; All have the following calling sequence:
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
;	IOS/ BSP status
;	PB/ Pointer to received packet buffer, if appropriate
; Returns +1 always
; May clobber T1-T4, PB


; Send initiating RFC

SNDIRF:	MOVEI T2,PBHEAD+<MNPLEN+6+3>/4
	CALL ASGPKT		;Allocate packet buffer for RFC
	 RET			;Failed, forget it
	MOVEI T1,MNPLEN+6	;Set Pup Length
	DPB T1,PUPLEN
	SKIPL T1,BSPCID(BSP)	;Connection ID already assigned?
	 JRST SNDIR1		;Yes, use it (retransmission)
	MOVE T1,TODCLK		;No, get now in milliseconds
	LSH T1,7		;Convert to units of ~8 usec
	CALL SETCID		;Set Connection ID
SNDIR1:	LSH T1,4		;Left-justify
	MOVEM T1,PBHEAD+1(PB)	;Set Pup ID
	CALL STCPRT		;Set Connection Port = local port
	MOVEI T1,PT.RFC		;Type = RFC
	CALL SNDPUP		;Finish up and send the Pup
	 CAI			;Ignore failure
	RET    


; Send answering RFC

SNDARF:	SKIPL BSPCID(BSP)	;Connection parameters already set?
	 JRST SNDAR1		;Yes, bypass this
	MOVE T1,PBHEAD+1(PB)	;Get Pup ID from incoming RFC
	LSH T1,-4		;Right-justify
	CALL SETCID		;Set Connection ID
	LDB T1,PPUPDN		;Copy Destination net/host to
	DPB T1,PPRTLN		; local net/host in case wildcard
	LDB T1,PPUPDH
	DPB T1,PPRTLH
	CALL OPNCON		;Set foreign port for connection
SNDAR1:	STKVAR <SNDPBO>
	HRLM PB,SNDPBO		;Save ptr to received RFC
	MOVEI T2,PBHEAD+<MNPLEN+6+3>/4
	CALL ASGPKT		;Allocate packet buffer for reply
	 RET			;Failed, forget it
	HLRZ T1,SNDPBO		;Ok, recover ptr to received RFC
	MOVSI T1,PBHEAD(T1)	;Copy the header
	HRRI T1,PBHEAD(PB)	; into the answering RFC
	BLT T1,PBCONT-1(PB)
	CALL SWPPRT		;Swap source and dest ports in RFC
	CALL STCPRT		;Set Connection Port = local port
	CALL SNDPU1		;Finish up and send the Pup
	 CAI			;Ignore failure
	RET    


; Open connection in response to answering RFC

OPNCON:	CALL GTCPRT		;Get Connection Port from RFC
	 BUG(OPNCOZ)
	CALL STFPRT		;Set foreign port for connection
	RET    

; Action routines (cont'd)

; Send End

SNDEND:	MOVEI T1,PT.END		;Type = End
	JRST SNDEN1		;Jump to common code


; Send End Reply

SNDENR:	MOVEI T1,PT.ENR		;Type = End Reply
SNDEN1:	STKVAR <SNDENT>		;Type
	HRLM T1,SNDENT		;Save type
	MOVEI T2,MNPBLN		;Minimum length
	CALL ASGPKT		;Allocate packet buffer
	 RET			;Failed, forget it
	MOVEI T1,MNPLEN		;Set Pup Length
	DPB T1,PUPLEN
	MOVE T1,BSPCID(BSP)	;Get Connection ID
	LSH T1,4		;Left-justify
	MOVEM T1,PBHEAD+1(PB)	;Set Pup ID
	HLRZ T1,SNDENT		;Recover Pup Type
	CALL SNDPUP		;Finish up and send the Pup
	 CAI			;Ignore failure
	RET    


; Send Abort
;	T3/ Abort Code (B0 set =) call from monitor)
;	T4/ If nonzero, string ptr to Abort Text in caller space

ABORT:	MOVE T1,T3		;Copy args to proper ac's
	MOVE T2,T4
	CALL SNDABT		;Build and send the Abort
	RET    



; Signal local error

LCLERR: BUG(PUPSFZ)
	RET    



; Signal foreign error

FORERR:	PBUG(PUP,<PUPFSM: Improper port state for received Pup>)
	RET    


; Get Connection Port parameters from RFC Pup
;	PB/ Packet buffer pointer
; Returns +1:  Error, illegal address
;	+2:  Ok,  T1/ Net, T2/ Host, T3/ Socket, right-justified

GTCPRT:	MOVE T1,PBCONT(PB)	;Get net/host/high socket
	LSHC T1,-^D28		;Right-justify net
	LSH T2,-^D12		;Right-justify host/high socket
	MOVE T3,PBCONT+1(PB)	;Get low socket
	LSHC T2,-^D16		;Right-justify host
	LSH T3,-4		;Concatenate, right-justify socket
	SKIPN T1		;Net specified?
	 LDB T1,PPUPSN		;No, assume same as Rendezvous
	JUMPE T2,CPOPJ		;Error if zero host
	JUMPE T3,CPOPJ		;Error if zero socket
	RETSKP			;Ok, take success return


; Set Connection Port = local port in outgoing RFC
;	PB/ Packet buffer pointer
;	UNIT/ Pup unit #
; Returns +1 always
; Clobbers A

STCPRT:	HLLZ T1,PUPLNH(UNIT)	;Get local net/host
	TXNE T1,377B7  		;Make sure fully specified
	TXNN T1,377B15  
	 BUG(STCPRZ)
	MOVEM T1,PBCONT(PB)	;Store in Connection Port field
	MOVE T1,PUPLSK(UNIT)	;Get local socket
	ROT T1,-^D16		;Right-justify high 16 bits
	DPB T1,[POINT 16,PBCONT(PB),31]  ; Store in the RFC
	MOVEM T1,PBCONT+1(PB)	;Store low 16 bits
	RET    


; Store foreign connection port
;	T1/ Net, T2/ Host, T3/ Socket, right-justified
; Assumes port is locked
; Returns +1
; Clobbers T1-T4

STFPRT:	SKIPN T4,PUPFPT(UNIT)	;Get address table
	 BUG(STFPRZ)
	HRLM T1,1(T4)		;Store foreign address in table
	HRRM T2,1(T4)
	MOVEM T3,2(T4)
	HRLI T4,-2		;Now just one address in table
	MOVEM T4,PUPFPT(UNIT)
	MOVEI T1,0(T4)		;Copy pointer to block
	MOVEI T2,3		;New size of block
	CALL TRMPFR		;Trim it
	RET    


; Set Connection ID
;	T1/ Connection ID, right-justified
; Assumes port is locked
; Returns +1

SETCID:	TXZ T1,-1B3  		;Truncate to 32 bits
	MOVEM T1,BSPCID(BSP)	;Set Connection ID
	MOVEM T1,BSPILW(BSP)	;Init input Byte ID
	MOVEM T1,BSPOLW(BSP)	;Init output Byte ID
	MOVEM T1,BSPRII(BSP)	;Init receive Interrupt ID
	MOVEM T1,BSPSII(BSP)	;Init send Interrupt ID
	RET    

; Generate Pup state change interrupt
;	T1/ New state
;	UNIT/ Pup unit #
;	BSP/ BSP data block ptr
; Returns +1 always
; Clobbers T1, B

PUPSTC:	HRRE T2,PUPPSI(UNIT)	;Get port owner
	JUMPL T2,PUPST1		;Jump if not fork
	LDB T1,STCPSI		;Get state change PSI channel
	CAIGE T1,^D36		;Assigned?
	 CALL PSIRQF		;Yes, initiate PSI
PUPST1:	CALL WAKBSI		;Awaken fork or NVT processor
	RET    



; Setup to wait for port to enter a specified state (or time out)
;	T1/ Bit mask of desired state(s) [STTBTS macro]
; Assumes port is locked
; Returns +1:  Port not yet in specified state, T1/ EDISMS argument
;	+2:  Port already in specified state
; Clobbers T1, B

WATSTT:	LDB T2,PBSSTT		;Get current state
	TDNN T1,BITS(T2)	;Already in specified state?
	 TXNE IOS,BSTIMF  	;Timed out?
	 RETSKP			;Yes, give skip return
	HRRI T1,STTTST		;No, set scheduler test
	TXO T1,UNIT  		;Set Pup unit index
	RET    			;Non-skip return

	RESCD

; Scheduler test for entering specified state(s)
; Arg is state bit mask in B18-26, Pup unit # in B27-35

STTTST:	MOVSI T2,(T1)		;Copy bit mask
	ANDI T1,777		;Isolate Pup unit #
	MOVE T3,PUPSTS(T1)	;Get status word
	LDB T1,PBSSTA		;Get port state
	TDNN T2,BITS(T1)	;Now in specified state(s)?
	 TXNE T3,BSTIMF  	;Timeout?
	 JRST 1(T4)		;Yes, wakeup
	JRST 0(T4)		;No, wait

	SWAPCD

; -----------------------------------------------------------------
;	Pup NVT handling
; -----------------------------------------------------------------

	SWAPCD

; Background routine to scan for Pup NVT input/output

BSPNVT:	PLOCK(NVTLCK)		;No messing with table
	MOVE T2,PUPPAR		;Set to first Pup NVT
BSPNV1:	PUSH P,T2		;Save line
	CALL LCKTTY		;Lock tty
	 JRST BSPNV2		;not full tty
	SKIPL UNIT,TTYPUP(T2)	;Assigned?
	 JRST BSPNV2		;No
	HRRZ UNIT,UNIT		;Clean up UNIT
	SKIPGE IOS,PUPSTS(UNIT)  ; Yes, port unlocked?
	 JRST BSPNV2		;No
	TXNE IOS,BSINPF!BSTIMF!BSERRF    ; Input available or error?
	 JRST BSPNV3
	TXNN IOS,BSOUTF  	;Output possible?
	 JRST BSPNV2		;Cant do output
	CALL PPSOBE		;Any output chars to proceess?
BSPNV3:	 CALL DONVTP		;One of those, service this NVT
BSPNV2:	CALL ULKTTY		;Unlock tty
	POP P,T2		;Restore static line
	AOBJN T2,BSPNV1		;Any more lines ?
	CALL RLNVLK
	RET    			;Yes, done


; Do Pup NVT processing for one line
;	T2/ Dynamic data pointer
;	UNIT/ Pup unit #
; Returns +1 always
; Clobbers T1, T3, T4, BSP, IOS;  preserves T2

DONVTP:	LOCK(PRTLCK)		;Lock out changes to port table
	CALL LCKBSA		;Attempt to lock the port
	 JRST [	UNLOCK(PRTLCK)	;Failed, forget it
		RET]
	UNLOCK(PRTLCK)		;Ok, unlock table
	MOVX T1,HUREQF		;Is a hangup occuring?
	TDNN T1,TTYPUP(T2)
	TXNE IOS,BSERRF!BSTIMF	;Errors?
	 JRST DONVTE		;Yes, go handle

; Note that doing input first and then output generally ensures
;  that echos will be transmitted immediately
	TXNE IOS,BSINPF  	;Input pending?
	 CALL DONVTI		;Yes, process it
	CALL PPSOBE		;Output pending?
	 CALL DONVTO		;Yes, process it

	LDB T1,PBSSTT		;Get current port state
	CAIN T1,S.OPEN		;Still open?
	 JRST ULKBSP		;Yes, just unlock port and return

; Here if port no longer open or timed out, kill the connection
DONVTE:	CALL CLPNVT		;Initiate close of connection
	 CALL ULKBSP		;Have to wait, unlock port and quit
	RET    			;Connection gone, no need to unlock

; Process NVT input
;	T2/ TTY Line #
;	UNIT/ Pup unit #
; Assumes port is locked
; Returns +1 always
; Clobbers T1, T3, T4, PB;  preserves B

DONVTI:	LDB T1,PNVSTT		;Get current NVT input state
	JRST @NVTSTD(T1)		;Dispatch on state

; Dispatch table for current NVT state
NVTSTD:	NVTDAT		;(0) Normal data
	NVTMRK		;(1) Mark pending
	NVTSYN		;(2) Sync in progress

; Dispatched-to code should jump to one of these labels when
;  it can't do any more processing
NVTST0:	JSP T1,DONVTX		;Set state to 0 (normal data)
NVTST1:	JSP T1,DONVTX		;Set state to 1 (Mark pending)
NVTST2:	JSP T1,DONVTX		;Set state to 2 (Sync in progress)

DONVTX:	SUBI T1,NVTST0+1	;Convert pc to state index
	DPB T1,PNVSTT		;Store new state
	RET    			;Return from DONVTI


; Dispatch here to process normal data
NVTDAT:	CALL PUPIFL		;Is input full?
	 JRST NVTST0		;Yes, stop (state _ 0)
	CALL GNVBYT		;No, get next byte
	 JRST NVTST0		;No more (state _ 0)
	 JRST NVTMR1		;Mark encountered
	PUSH P,T2		;T2 clobbered by TTCHI
	PUSH P,UNIT		;=5, clobbered by TTCHI
	PUSH P,IOS		;=6
	SETZ IOS,		;Would you believe this is an arg?
	NOSKED			;TTCHI requires this
	HRRZ T2,1(T2)		;Get static line number
	CALL TTCHI		;Stuff character in input buffer
	 JFCL			;CS36 Let user get ?Logging in is disallowed
	OKSKED
	POP P,IOS		;Restore ac's
	POP P,UNIT
	POP P,T2
	JRST NVTDAT		;Repeat


; Dispatch here when sync in progress
; Also get here after processing Mark
NVTSYN:	LDB T1,PSYNCT		;Check sync counter
	JUMPE T1,NVTDAT		;Resume processing if now balanced
	CAIE T1,SYNCNT/<SYNCNT&-SYNCNT>  ; Skip if -1 (waiting for Int)
NVTSY1:	 CALL GNVBYT		;Scanning for DM, get next byte
	 JRST NVTST2		;No more (state _ 2)
	 JRST NVTMR1		;Mark encountered, process it
	JRST NVTSY1		;Normal data, flush it


; Dispatch here to process pending Mark
NVTMRK:	LDB T1,PNVMRK		;Recover the Mark byte

; Here when Mark first encountered, T1/ Mark byte
NVTMR1:	CAIL T1,NNVMRK		;See if in range
	 JRST NVTSYN		;No, ignore
	JRST @MRKDSP(T1)	;Yes, perform operation

; Dispatch table for received Mark types
; Code should finish by going to NVTST1 if must defer,
;  NVTSYN normally (to check sync count)
MRKDSP:	NVTSYN		;(0) Unassigned
	NVTDM		;(1) Data Mark
	NVTLW		;(2) Line Width
	NVTPL		;(3) Page Length
	NVTTYP		;(4) Terminal Type
	NVTTMK		;(5) Timing Mark
	NVTTMR		;(6) Timing Mark Reply

NNVMRK==.-MRKDSP	;Number of Mark types recognized

; DONVTI (cont'd)
; Code to process specific Mark types

; Process Data Mark (DM, Mark type 1)
NVTDM:	MOVEI T1,SYNTMO		;Reset sync timer
	DPB T1,PSYNTM
	LDB T1,PSYNCT		;Get sync count
	SUBI T1,1		;DM counts as -1
	DPB T1,PSYNCT		;Put it back
	CALL TTCIBF		;Clear TTY input buffer
	JRST NVTSYN		;Go reconsider state

; Set Line Width (Mark type 2)
NVTLW:	CALL GNVBYT		;Get argument byte
	 JRST NVTST1		;Can't, defer (state _ 1)
	 JRST NVTMR1		;Another Mark, ignore this
	CALL TTSWID		;Store in TTY status
	 JFCL			;Not a legal width, leave as is
	JRST NVTSYN		;Done

; Set Page Length (Mark type 3)
NVTPL:	CALL GNVBYT		;Get argument byte
	 JRST NVTST1		;Can't, defer (state _ 1)
	 JRST NVTMR1		;Another Mark, ignore this
	CALL TTSLEN		;Store in TTY status
	 JFCL			;Length is illegal leave as is
	JRST NVTSYN		;Done

; Set Terminal Type (Mark type 4)
NVTTYP:	CALL GNVBYT		;Get argument byte
	 JRST NVTST1		;Can't, defer (state _ 1)
	 JRST NVTMR1		;Another Mark, ignore this
	CALL PUPSTP		;Set terminal type
	JRST NVTSYN		;Done

; Timing Mark (Mark type 5)
NVTTMK:	HRRE T1,TTFORK(T2)	;Is there a fork blocked for input?
	JUMPL T1,NVTTM1
	PUSH P,T2		;Yes, save line #
	MOVEI T1,6		;Generate immediate timing mark reply
	CALL SNDAMA
	 JRST [	POP P,T2	;Can't, defer processing of timing mark
		JRST NVTST1]	;(State _ 1)
	POP P,T2		;Ok, recover line #
	JRST NVTSYN		;Done

; Here if no fork waiting.  Increment count so as to cause reply
; to be generated when somebody exhausts the input buffer.
NVTTM1:	LDB T1,PTMKCT		;Get current count of timing marks
	ADDI T1,1		;Increment it
	DPB T1,PTMKCT
	JRST NVTSYN		;Done

; Timing Mark Reply (Mark type 6)
NVTTMR:	MOVX T1,TMKPNF		;Clear timing mark pending flag
	ANDCAM T1,TTYPUP(T2)	;This wakes up anywone waiting
	JRST NVTSYN		;Done

; Get input byte for NVT
;	T2/ TTY Line #
; Assumes port is locked and ac's setup
; Returns +1:  Input exhausted
;	+2:  Mark encountered, T1/ the byte (also stored via PNVMRK)
;	+3:  Normal, T1/ the byte
; Clobbers T1, C-D, PB;  does not clobber B

GNVBYT:	HLRZ PB,BSPCUR(BSP)	;Get current buffer ptr if any
	JUMPN PB,GNVBY2		;Jump if already have a buffer
GNVBY1:	PUSH P,T2		;Save line #
	CALL GETBSP		;Get the next packet
	 JRST [	POP P,T2	;No more, recover line #
		RET]		;Return +1
	POP P,T2		;Recover line #
	LDB T1,PUPTYP		;Get Pup Type
	CAIE T1,PT.MRK		;Mark?
	 CAIN T1,PT.AMA		;AMark?
	 JRST [	ILDB T1,PBBSID(PB) ;Yes, get the byte
		DPB T1,PNVMRK	;Save away in case need to defer
		SETZM PBBSBC(PB) ;No more bytes in this packet
		RETSKP]		;Return +2

GNVBY2:	SOSGE PBBSBC(PB)	;Count down bytes in packet
	 JRST GNVBY1		;Exhausted, try next packet
	ILDB T1,PBBSID(PB)	;Get the next byte
	JRST SK2RET		;Return +3

; Do NVT output processing for one line
;	T2/ TTY Line #
; Assumes port is locked
; Returns +1 always
; Clobbers T1, T3, T4, PB;  preserves B

DONVTO:	SAVEAC <T2>		;Preserve line #
	STKVAR <DONVTT>		;Save line number
	HRLZM T2,DONVTT		; for us
	CHKSTT <OPEN>		;Connection still open?
	 RET			;No, do nothing
	CALL CHKBSO		;Check for BSP output possible
	 RET			;Return having done nothing
	HLRZ T2,DONVTT		;Get dynamic line nbr
	CALL PNVCXF		;Is line XOFFed (^S)?
	 RET			;Yes, no output till XON (^Q) received
	CALL BLDDAT		;Build packet of appropriate size
	 RET			;Return having done nothing
	MOVEM T2,PBBSID(PB)	;Store byte pointer
	HLRZ T2,DONVTT		;Recover line #
	NOSKED			;No races
; Pack bytes from output buffer
	CALL PUPACT		;Set line to active
	PUSH P,T1		;Save remaining count
DONOV3:	PUSH P,T2		;Save dynamic data
	CHNOFF DLSCHN		;CS36
	CALL TTSND		;Get the char
	CHNON DLSCHN		;CS36
	POP P,T2		;Restore data
	CALL PUPTAC		;Line still active?
	 JRST DONOV5		;No
	IDPB T3,PBBSID(PB)	;Store in packet
	SOSLE 0(P)		;Any space left in packet?
	 JRST DONOV3		;Yes
	CALL PUPIAC		;Set line to inactive

; Finish up and send the packet

DONOV5:	POP P,T1			;Pop stack
	OKSKED
	MOVE T1,PBBSID(PB)	;Get ptr to last byte stored
	CALL DMPBSP		;Finish up and send the packet
	RET    			;Done

; Routine called upon receipt of an Interrupt for a port
;  attached to an NVT
;	T2/ Line #
;	PB/ Packet buffer pointer
; Assumes port is locked
; Returns +1 always
; Clobbers T1-T4

NVTINT:	PLOCK(NVTLCK)		;No messing with NVT table
	MOVEI T1,SYNTMO		;Reset sync timer
	DPB T1,PSYNTM
	LDB T1,PSYNCT		;Get sync count (Int's - DM's)
	AOS T1			;Interrupt counts as +1
	DPB T1,PSYNCT		;Put it back
	JUMPE T1,[CALL RLNVLK	;Done if Ints and DMs now balance
		JRST WAKBSI]
	LDB T1,PNVSTT		;Get current input state
	SKIPN T1		;Normal input?
	 MOVEI T1,2		;Yes, change to sync in progress
	DPB T1,PNVSTT		;Put it back
	CALL RLNVLK
	CALL TTCIBF		;Clear TTY input buffer
	CALL WAKBSI		;Make NVT processor notice change
	RET    			;Done



; Background routine to time out syncs
; Called periodically from Pup background process
; Returns +1
; Clobbers T1-T4, UNIT, BSP, IOS

SYNCHK:	PLOCK(NVTLCK)		;No messing with NVT table
	MOVE T2,PUPPAR		;Prepare to scan all NVT's
SYNCH1:	PUSH P,T2		;Save static line number
	CALL LCKTTY		;Lock tty, get dynamic data
	 JRST SYNCH3		;Not really there
	SKIPGE UNIT,TTYPUP(T2)	;NVT assigned?
	 TXNN UNIT,SYNCNT  	;Yes, sync in progress?
	 JRST SYNCH3		;No
	HRRZ UNIT,UNIT		;CS36 Get a clean unit
	LDB T1,PSYNTM		;Yes, get timer
	SOJL T1,[SETZ T1,	;If timed out, clear sync count
		DPB T1,PSYNCT
		CALL RLNVLK	;Prevent deadlocks!
		PUSH P,T2 	;Preserve line #
		CALL LCKBSP	;Lock port
		CALL WAKBSI	;Make NVT processor notice change
		CALL ULKBSP	;Unlock port
		POP P,T2
		PLOCK(NVTLCK)	;Re-lock NVT table
		JRST SYNCH3]
	DPB T1,PSYNTM		;Not timed out yet, put it back
SYNCH3:	CALL ULKTTY		;Unlock tty
	POP P,T2 		;Restore static line
	AOBJN T2,SYNCH1		;Any more NVTs?
	CALL RLNVLK
	SIGPBP(NVT)		;Scan NVT's at least this often
	MOVEI T1,SYNCHI		;Get sync check interval
	ADD T1,TODCLK		;Compute time of next check
	MOVEM T1,SYNTIM
	RET    

; Assign Pup NVT
;	UNIT/ Pup unit #
; Returns +1:  Failed, none free
;	+2:  T2/ Line #
; Clobbers T1, B

ASPNVT:	MOVE T2,PUPPAR		;Prepare to scan all NVT's
	PLOCK(NVTLCK,,HIQ)	;Lock the table
	NOSKED
ASPNV1:	PUSH P,T2		;Keep static line number
	CALL STADYN		;See if active line
	 JUMPE T2,ASPNV4	;Line totally inactive
ASPNV2:	POP P,T2		;Restore line
	AOBJN T2,ASPNV1		;Keep trying
	OKSKED
	CALL RLNVLK		;Fail return if none available
	RET    
ASPNV4:	HRRZ T2,0(P)		;Get static line number
	CALL TTYASC		;Assign the line
	 JRST ASPNV2		;Couldnt, try another line
	CALL LCKTTY		;Lock the tty
	 BUG(ASPNVZ)
	OKSKED
	CALL PUPTIN		;Set perminant flag
	MOVEI T1,(UNIT)		;Found one, copy Pup index
	HRLI T1,(1B0)		;Set assignment flag
	MOVEM T1,TTYPUP(T2)	;Assign NVT
	HRRZ T1,0(P)		;Get static line number
	MOVEI T1,400000(T1)	;Point port to NVT
	HRROM T1,PUPPSI(UNIT)	; and clear interrupt assignments
	CALL RLNVLK		;Unlock table
	MOVEI T2,(T2)		;Clear lh of line #
	CALL TTCOBI		;Clear output buffer
	CALL TTCIBF		;Clear input buffer
	CALL ULKTTY		;Unlock tty
	POP P,T2		;Get back static line number
	RETSKP			;Success return


; Close Pup NVT
;	T2/ Pointer to dynamic data
; Assumes NVTLCK and port are locked and UNIT, BSP, IOS setup
; Returns +1:  Port not yet closed (try again later)
;	+2:  Now closed, port deleted, NVT released
; Clobbers T1, C-D, PB;  preserves T2

CLPNVT:	SKIPN TTYPUP(T2)	;Currently assigned?
	 RETSKP			;Yes, succeed
	STKVAR <CLPNT2>		;Line number
	HRLM T2,CLPNT2		;Preserve line #
	CALL TTCIBF		;Clear TTY input buffer
	MOVX T1,HUREQF		;Hangup requested flag
	TDNN T1,TTYPUP(T2)	;Already done?
	SKIPGE TTFORK(T2)	;Is there a job attached?
	 JRST CLPNV1		;Already done or no job, bypass
	IORM T1,TTYPUP(T2)	;Yes, remember we did it
	PUSH P,UNIT		;=5, clobbered by NVTCOF
	HRRZ T2,1(T2)		;Get static line number
	CALL NTYCOF		;Initiate carrier-off psi
	POP P,UNIT		; (NVTCOF also clobbers T2)
CLPNV1:	LDB T1,PBSSTT		;Get current state
	CAIE T1,S.CLOS		;Now closed or aborted?
	 CAIN T1,S.ABOR
	 JRST CLPNV5		;Yes, just flush port
	TXNE IOS,BSTIMF  	;Timed out?
	 JRST [	MOVEI T1,E.CLST	;Yes, generate CLOSF(T) event
		HRROI T3,0	;Need registered code ************
		HRROI T4,[ASCIZ /Connection timed out/]
		JRST CLPNV3]
	CHKSTT <OPEN,ENDI>	;No, state ok for BSP output?
	 JRST CLPNV2		;No
	CALL FRCBSP		;Yes, force the byte stream
	CALL CHKBOQ		;Any unacknowledged output?
	 JRST CLPNV6		;Yes, have to wait
CLPNV2:	MOVEI T1,E.CLSN		;Generate CLOSF(N) event
CLPNV3:	CALL PUPFSM		;Activate the FSM
	CHKSTT <CLOS,ABOR>	;Now closed or aborted?
	 JRST CLPNV6		;No, have to wait
CLPNV5:	CALL FLSBSQ		;Yes, flush all queues
	SKIPE PUPOBC(UNIT)	;Any pending output on port queue?
	 JRST CLPNV6		;Yes, have to wait
	CALL DELPRT		;No, delete the port
	HLRZ T2,CLPNT2		;Recover line #
	CALL PUPTUN		;Turn off perminant bit
	SETZM TTYPUP(T2)	;Release the NVT
	RETSKP

CLPNV6:	HLRZ T2,CLPNT2		;Have to wait
	MOVE T1,[1B0!TTPPWT]	;Get wait test
	RET

	RESCD
; Wait test for Pup being closed so block can be deassigned

TTPPWT:	MOVE T2,T1		;Get static line number
	CALL STADYN		;Get dynamic block
	 JRST 1(T4)		;No longer there, succeed
	SKIPN TTYPUP(T2)	;pup nvt not closed
	 JRST 1(T4)		;=0 -) closed
	JRST 0(T4)

	SWAPCD

; Pup NVT routines called from TTYSRV

; Clear TTY output buffers for Pup NVT
;	T2/ Line #
; Returns +1 always
; Clobbers T1, C-D;  preserves T2, UNIT, BSP, IOS

PNVCOB::CALL CHKPNV		;Check and lock NVT
	 RET			;No port attached, do nothing
	TXNE IOS,BSTIMF!BSERRF    ; Any errors?
	 JRST PNVCO2		;Yes, forget it
	HRROI T1,0		;Need registered code ************
	HRROI T2,[ASCIZ /Sync/]
	CALL SNDINT		;Send Interrupt
	 JRST [	CALL ULKNVT	;Can't, undo all locks
		CALL TTYDIS	;Unlock tty if it doesnt come back
		MDISMS		;Wait until can send Interrupt
		CALL TTYAWK	;Remove entry
		JRST PNVCOB]	;Try again
PNVCO1:	MOVEI T1,1		;Mark type = 1 (DM)
	CALL SNDAMA		;Send AMark
	 JRST [	NOINT		;Can't, lock out PSIs while waiting
		MDISMS		;Wait until can send Mark
		CALL CHKPNV	;Lock everything again
		 JRST [	OKINT	;Port went away, give up
			RET]
		OKINT
		TXNE IOS,BSTIMF!BSERRF    ; Any errors?
		 JRST PNVCO2	;Yes, forget it
		JRST PNVCO1]	;Try again to send Mark
PNVCO2:	CALL ULKNVT		;Unlock
	RET    


; Dismiss until output buffer empty, called from TTDOBE
;	T2/ Line #
; Returns +1 always
; Clobbers T1, C-D;  preserves T2, UNIT, BSP, IOS

PNVDOB::CALL CHKPNV		;Check and lock NVT
	 RET			;No port attached, do nothing
	TXNE IOS,BSTIMF!BSERRF    ; Any errors?
	 JRST [	CALL ULKNVT	;Yes, forget it
		RET]
	MOVEI T1,5		;Mark type = 5 (Timing Mark)
	CALL SNDAMA		;Send AMark
	 JRST [	CALL ULKNVT	;Can't, undo locks
		CALL TTYDIS	;Unlock tty if this doesnt return
		MDISMS		;Wait until can send Mark
		CALL TTYAWK	;Remove entry to unlock tty
		JRST PNVDOB]	;Try again
	MOVE T2,0(P)		;Recover line #
	MOVX T1,TMKPNF		;Set timing mark pending flag
	IORM T1,TTYPUP(T2)
	CALL ULKNVT		;Unlock, go OKINT
	MOVEI T1,PNVDBT		;Set scheduler test
	HRLI T1,(T2)		;This line
	CALL TTYDIS		;Become interruptable
	MDISMS			;Wait until Timing Mark Reply received
	CALL TTYAWK		;Relock TTY
	RET    

	RESCD

; Scheduler test for timing mark not outstanding
; Arg is line #

PNVDBT:	MOVX T2,TMKPNF		;Timing mark pending?
	TDNN T2,TTYPUP(T1)
	 JRST 1(T4)		;No, wakeup
	MOVE T2,T1		;Yes, see if input buffer is full
	JRST PUPDFL		;Wakeup if input buffer full

	SWAPCD

; Hang up Pup NVT line, i.e. close connection, release NVT
;	T2/ Line #
; Returns +1 with wait test in ac1 if not completed
;	    +2- succeded
; Clobbers T1, C-D;  preserves T2, UNIT, BSP, IOS

PNVCLZ::PUSH P,T2
	CALL LCKTTY		;Lock tty
	 JRST PNVCL9
	CALL CHKPNV		;Check and lock NVT
	 JRST PNVCL9		;No port attached, do nothing
	CALL CLPNVT		;Initiate close
	 JRST PNVCL8		;Must wait return
	CALL ULKNV2		;Now closed, port gone
PNVCL9:	CALL ULKTTY		;Unlock TTy
	POP P,T2		;Restore line nbr
	RETSKP

PNVCL8:	CALL ULKNVT		;Not finished yet, unlock
	CALL ULKTTY		;Unlock tty
	POP P,T2
	RET			 ; Try again later

	RESCD

; Awaken Pup NVT processor (called from TCI and TCOUT)
;	T2/ Line #
; Returns +1 always
; Clobbers A

PNVWK1::SKIPL TTYPUP(T2)	;Is there a port attached?
	 RET			;No, do nothing
PNVWAK::SKIPL TTYPUP(T2)	;Is there a port attached?
	 JRST TTCOBI		;No, flush output and return
	PUSH P,T1		;Yes, protect clobbered ac
	SIGPBP(NVT)		;Request NVT scan
	POP P,T1
	RET    


; Routine called when TTY input buffer becomes empty (or is cleared)
;	T2/ Pointer to dynamic data
; Returns +1 always
; Clobbers nothing

PNVIBE::CALL PNVWAK		;Wakeup background
	PUSH P,T1		;Save an ac
	LDB T1,PTMKCT		;Get count of timing marks pending
	JUMPE T1,PNVIB3		;Jump if none
PNVIB0:	SKIPN NSKED		;Make sure not NOSKED
	 CALL CHKPNV		;Check and lock NVT
	  JRST PNVIB3		;No port attached, do nothing
	CHKSTT <OPEN,ENDI>	;Port in good state for output?
	 JRST PNVIB2		;No, do nothing
	LDB T1,PTMKCT		;Yes, get count of marks pending
	JUMPE T1,PNVIB2		;Jump if none
PNVIB1:	MOVEI T1,6		;Mark type = Timing Mark Reply
	CALL SNDAMA		;Try to send AMark
	 JRST [	CALL ULKNVT	;Can't, unlock NVT
		CALL TTYDIS	;Become interruptable
		MDISMS		;Wait until can send Mark
		CALL TTYAWK	;Lock tty again
		JRST PNVIB0]	;Try again
	MOVE T2,0(P)		;Recover line #
	LDB T1,PTMKCT		;Decrement timing mark count
	SOSL A
	 DPB T1,PTMKCT
	JUMPG T1,PNVIB1		;Repeat if more timing marks pending
PNVIB2:	CALL ULKNVT
PNVIB3:	POP P,T1
	RET    

	SWAPCD

; Check and lock Pup NVT and save ac's (for TTY level routines)
;	T2/ Line #
; Returns +1:  Not attached to Pup port
;	+2:  Ok, NVT table and port locked and UNIT, BSP, IOS setup
; The +2 return is made at a stack level deeper than the call.
; B is saved at 0(P).  Return must be via ULKNVT
; Clobbers A

CHKPNV:	CALL PUPCTY		;Consistency check
	 BUG(CHKNVZ)
	EXCH UNIT,0(P)		;Save vulnerable ac's
	PUSH P,BSP
	PUSH P,IOS
	PUSH P,PB
	PUSH P,T2
	PUSH P,UNIT		;Put return pc on top
CHKNV1:	NOINT			;Protect locks
	PLOCK(NVTLCK,,HIQ)	;Lock the NVT table
	SKIPL UNIT,TTYPUP(T2)	;Get and check linkage
	 JRST ULKNV2		;Not attached to Pup port
	HRRZ UNIT,UNIT		;CS36 Get a clean UNIT
	LOCK(PRTLCK)		;Ok, lock port table
	CALL LCKBSA		;Attempt to lock port
	 JRST [	UNLOCK(PRTLCK)	;Can't, unlock port table
		CALL RLNVLK	;Avoid deadlocks
		OKINT
		MOVSI T1,(UNIT)	;Set scheduler test
		HRRI T1,BSLCKT
		CALL TTYDIS	;Become interruptable
		MDISMS		;Wait until port unlocked
		CALL TTYAWK	;Lock tty again
		JRST CHKNV1]	;Try again
	UNLOCK(PRTLCK)		;Ok, unlock port table
	RETSKP			;Skip return, NVT locked


; Unlock Pup NVT and restore AC's
; UNIT, BSP, IOS setup from previous call to CHKNVT
; Returns +1, restores T2, UNIT, BSP, IOS

ULKNVT:	CALL ULKBSP		;Unlock port

; Enter here if port wasn't locked (or has been deleted)
ULKNV2:	CALL RLNVLK		;Unlock NVT table
	OKINT
	POP P,UNIT		;Pop off return pc
	POP P,T2		;Restore saved ac's
	POP P,PB
	POP P,IOS
	POP P,BSP
	EXCH UNIT,0(P)		;Restore UNIT, put back pc
	RET    			;Return


; -----------------------------------------------------------------
;	Pup Interrupt Routines
; -----------------------------------------------------------------


	RESCD

;PUP input interrupt service (called via PUSHJ from ETHSRV)

;RS CURIPB		;Pointer to current input packet buffer
;RS PUPFII		;Count of false input interrupts
;RS PUPNFI		;Count of times we had no free input buffers

PUPISV::SKIPN T1,XPUPIB		;See if packet being input
	 JRST PUPIS1		;No, just start input
	JUMPG T1,[AOS PUPFII	;Count false interrupts if
		JRST PUPSVX]	; input not completed, and ignore
	MOVE PB,CURIPB		;Ok, get packet buffer ptr
	CALL PUPINP		;Process input Pup

; Handler returns via POPJ when done with the packet.
; Now setup to start reading next packet
PUPIS1:	MOVEI T1,FREIBQ		;Header of free input buffer queue
	CALL REMOBQ		;Remove first free input buffer
	 JRST [	AOS PUPNFI	;Queue empty, count occurrences
		SETZM XPUPIB	;Shut off input
		JRST PUPIS2]	;Request assignment, dismiss interrupt
	SOS FREIBN		;Got one, decrement free count
	MOVEM PB,CURIPB		;Save packet buffer ptr
	MOVEI T1,(PB)		;Make length,,address
	HRL T1,0(T1)
	MOVEM T1,XPUPIB		;Store for NVIO
	SIGNAL PUPIBG		;Tell NVIO about it
PUPIS2:	SIGPBP(ASG,<MOVE T2,FREIBN ; Request buffer assignment
		CAIGE T2,MINFIB>)  ;  if below minimum level
	JRST PUPSVX		;Dismiss interrupt

; Routine to process input Pup
;	PB/ Packet Buffer pointer
; Returns +1 always
; Clobbers T1-T4, disposes of input Pup always

; Check for reasonable Pup Length
PUPINP:	LDB T1,PUPLEN		;Get Pup Length field
	CAIL T1,MNPLEN		;Check for legal length
	CAILE T1,MXPLEN
	 PBUG(DPR,<PUPINP: Pup Length out of bounds>)
	ADDI T1,3		;Ok, compute expected # words
	LSH T1,-2
	LDB T2,PPBPHS		;Get actual # words NVIO gave us
	CAIE T1,(T2)		;Same?
	 PBUG(DPR,<PUPINP: Packet size inconsistency>)

; Check for reasonable physical source network
	LDB T3,PPBPHN		;Get phys source network
	CAIL T3,1		;Check bounds
	CAILE T3,NPNETS
	 PBUG(DPR,<PUPINP: Bad physical source network number>)

; Reject packet if it claims to be from host zero
	LDB T3,PPUPSH		;Get Pup source host
	SKIPN C
	 PBUG(DPR,<PUPINP: Bad Pup source host number>)

; Default zero network fields to the physical source network
	LDB T1,PPUPSN		;Get Pup source network
	JUMPN T1,PUPIN1		;Src net = 0?
	LDB T1,PPBPHN		;Yes, src net _ phys src net
	MOVE T2,PPUPSN
	CALL UPDCKS		;Update src net and fix checksum
	JRST PUPI1A

; Pup from specific source net.  See whether we know about it and
; fix up routing table if not.
PUPIN1:	CAILE T1,NPNETS		;In range?
	 PBUG(DPR,<PUPINP: Pup source net out of range>)
	SKIPL PUPROU-1(T1)	;Already in routing table?
	 JRST PUPI1A		;Yes
	MOVE T2,PBPHYS(PB)	;No, get immediate source net/host (B0-15)
	LSH T2,-2		;Position to B2-15 to insert into RT
	TXNE T2,377B17  	;Make sure not host zero
	 HLLZM T2,PUPROU-1(T1)	;Insert route into table
PUPI1A:	LDB T1,PPUPDN		;Get Pup destination network
	JUMPN T1,PUPIN2		;Dst net = 0?
	LDB T1,PPBPHN		;Yes, dst net _ phys src net
	MOVE T2,PPUPDN
	CALL UPDCKS		;Update dst net and fix checksum
	LDB T1,PPUPDN		;Recover dst net for next check

; Check for destination = Maxc
PUPIN2:	CAIL T1,1		;Check for legal destination net
	CAILE T1,NPNETS
	 JRST PUPIE1		;Unknown, give error and discard
	HRRZ T3,PUPROU-1(T1)	;Get Maxc address on dest net
	LDB T2,PPUPDH		;Get Pup destination host
	CAIE T2,(T3)		;Pup destination = Maxc?
	 JUMPN T2,GATEWY	;No, pass Pup to gateway processor

; Destination is Maxc (or broadcast), lookup destination port.
; Note that broadcast Pups will match only host-wildcard ports
	MOVE T1,PBHEAD+2(PB)	;Get dst net/host and high socket
	LSH T1,-4		;Right-justify high socket
	MOVE T2,PBHEAD+3(PB)	;Get low dst socket
	LSHC T1,-^D16		;Concatenate high and low socket
	LSH T2,-4		;Right-justify dst socket
	LSH T1,^D20		;Left-justify dst net/host
	CALL PRTLUK		;Lookup local port, set UNIT
	 JRST PUPIE2		;Not found, give error and discard

; PUPINP (cont'd)

; Found destination port
; Check for requested random discard
	CALL DSCRAN		;Want to discard packet?
	 JRST RELPBI		;Yes, do so

; Check for exceeding maximum port input buffer queue length
	LDB T1,PUPLEN		;Get Pup Length (bytes)
	ADDI T1,4*PBHEAD+3	;Convert to words, add overhead
	LSH T1,-2
	CALL CHKIQL		;Check for exceeding maximum
	 JRST PUPIE3		;Overflowed, give error and discard

; Append Pup to port input buffer queue
	CALL TRMLPB		;Trim packet buffer to size of Pup
	HRRZ T1,PBSIZE(PB)	;Get size of trimmed block
	HRLI T1,1		;One new buffer
	ADDM T1,PUPIBC(UNIT)	;Add to total for port
	MOVEI T1,PUPIBQ(UNIT)	;Get adr of input queue header
	CALL APPIBQ		;Append Pup to queue

; Give Pup-Received interrupt to fork, if armed
	HRRE T2,PUPPSI(UNIT)	;Get fork to interrupt
	JUMPL T2,PUPIN5		;-1 =) none
	LDB T1,RECPSI		;Get PSI channel to interrupt on
	CAIL T1,^D36		;Armed?
	 JRST PUPIN5		;No
	MOVEI T1,PRQINT		;Yes, initiate scheduler request
	HRLI T1,(UNIT)		;Wakeup for this port
	CALL SCDRQ7		;Queue the request

PUPIN5:	HRRZ T1,PUPLNH(UNIT)	;Get BSP linkage if any
	JUMPE T1,CPOPJ		;Done now if not BSP port
	MOVX T1,BSWAKF		;Set flag to awaken BSP processor
	IORM T1,PUPSTS(UNIT)
	MOVE T1,TODCLK		;Queue request for background task
	AOJL T2,.+2		;Immediately if NVT
	ADDI T1,IBWDLY		;Delayed otherwise
	CALL ADDTQI		;Add port to timer queue
	RET    			;Done

; Gateway processor
; Enter with PB/ Packet Buffer pointer
;	T1/ Destination network
;	T2/ Destination host
; Returns +1 always
; Clobbers T1-T4, disposes of packet always

GATEWY:	SKIPL PUPPAR+2		;Are we a gateway?
	 JRST NOGATE		;No
	MOVE T2,PUPTCB		;Get byte ptr to transport control byte
	LDB T1,T2		;Get current value of byte
	ADDI T1,1B31		;Increment hop count (B0-3 of byte)
	TXNN T1,17B31		;Overflow?
	 JRST PUPIE4		;Yes, give error and discard
	CALL UPDCKS		;Ok, set new value and fix checksum
	MOVEI UNIT,NPUPUN	;Set fake unit # for gateway
	DPB UNIT,PPUPUN
	HRRZ T1,PBSIZE(PB)	;Get length of this packet buffer
	CALL CHKGQL		;Check for exceeding maximum
	 PBUG(DPR,<GATEWY: Excessive gateway Pups queued>)
	ADDM T1,PUPOBC(UNIT)	;Ok, update counts
	MOVEI T1,PUPOBQ		;Append to output queue
	MOVEI T2,PBIOBQ(PB)
	CALL APPITQ
	CALL PUPOGO		;Wake up output if necessary
	RET    			;Return from gateway handler

; Here if we are not a gateway
NOGATE:	PBUG(PUP,<GATEWY: Received Pup not for me and I'm not a gateway>)
	MOVEI T1,1006		;Registered error code
	HRROI T2,[ASCIZ /I'm not a gateway/]
	JRST PUPIE8		;Go send Error Pup

; Here on various Pup input errors detected at interrupt level.
; Generate appropriate "Error" Pup where possible.

; Here if destination network is unknown or unreachable
PUPIE1:	PBUG(PUP,<PUPINP: Unknown Pup destination network>)
	MOVEI T1,1002		;Set Error type
	HRROI T2,[ASCIZ /Destination net not in routing table/]
	JRST PUPIE8		;Go make Error and send it

; Here if Pup received for nonexistent local port
PUPIE2:	PBUG(PUP,<PUPINP: Received Pup for nonexistent local port>)
	MOVEI T1,2		;Set Error type
	HRROI T2,[ASCIZ /No process at destination port/]
	MOVE T3,FACTSW		;Check startup flags
	TXNN T3,SF%PNV		;Logins allowed?
	 HRROI T2,[ASCIZ /Tops-20 not available/]
	JRST PUPIE7		;Go make and send Error

; Here if port input queue overflowed
PUPIE3:	PBUG(PUP,<PUPINP: Exceeded maximum input buffer queue length for port>)
	MOVEI T1,3		;Set Error type
	HRROI T2,[ASCIZ /Port input queue overflowed/]
	JRST PUPIE7		;Go make and send Error

; Here if gateway hop count overflowed
PUPIE4:	PBUG(PUP,<GATEWY: Discarding Pup at 16th gateway>)
	MOVEI T1,1004		;Set Error type
	HRROI T2,[ASCIZ /Discarded at 16th gateway/]
	JRST PUPIE8		;Go make and send Error


; Here to make and send Error arising from original Pup destination
PUPIE7:	CALL MAKERR		;Make Error Pup
	 JRST RELPBI		;Can't, just flush packet
	JRST PUPIEX		;Go send Error

; Here to make and send Error arising from Maxc NCP
PUPIE8:	CALL MAKERR		;Make Error Pup
	 JRST RELPBI		;Can't, just flush packet
	LDB T1,PPBPHN		;Set source net/host to be
	DPB T1,PPUPSN		; phys net/host at which Pup
	LDB T1,PPBPHH		; was received
	DPB T1,PPUPSH
	SETZM PBHEAD+4(PB)	;Set source socket to zero

; Send Error packet via gateway queue
PUPIEX:	MOVEI UNIT,NPUPUN	;Set fake unit # for gateway
	DPB UNIT,PPUPUN
	HRRZ T1,PBSIZE(PB)	;Get length of this packet buffer
	CALL CHKGQL		;Check for exceeding maximum
	 JRST RELPBI		;Overflowed, just chuck it
	ADDM T1,PUPOBC(UNIT)	;Ok, update counts
	CALL PUOCNV		;Convert packet data (but not checksum)
	MOVEI T1,PUPOBQ		;Append to output queue
	MOVEI T2,PBIOBQ(PB)
	CALL APPITQ
	CALL PUPOGO		;Wake up output if necessary
	RET    			;Return from gateway handler

; Pup output interrupt service (called via PUSHJ from ETHSRV)

;RS CUROPB			;Pointer to current output packet buffer
;RS PUPFOI			;Count of false output interrupts

; Check for packet that NVIO is done with
PUPOSV::SKIPN T1,XPUPOB		;Packet being output?
	 JRST PUPOS2		;No
	JUMPG T1,[AOS PUPFOI	;Count false interrupts if
		JRST PUPSVX]	; output not completed, and ignore
	SETZM XPUPOB		;Clear communication cell
	MOVE PB,CUROPB		;Get packet buffer ptr

; Here from code below to discard packet before attempting output
PUPOS1:	LDB UNIT,PPUPUN		;Get index of originating port
	HRRZ T1,PBSIZE(PB)	;Get length of packet just output
	CALL DECOQL		;Decrement buffer counts for port
	SKIPE PBBSPQ(PB)	;Packet on BSP output queue?
	 JRST [	MOVEI T1,HSTNBR		;Reconstruct PBPHYS
		IORI T1,<NETNBR>B27
		MOVSM T1,PBPHYS(PB)	;Net nbr & host nbr
		HLRZ T1,PBHEAD(PB)	;Get nbr of 8-bit bytes (PUPLEN)
		ADDI T1,3		;Convert to nbr of -20 words
		LSH T1,-2
		HRRM T1,PBPHYS(PB)	;Complete PBPHYS
		MOVEI T1,PBPHYS(PB)	;Addr of 1st word to convert
		HRLI T1,-<PBHEAD+1>	;Create AOBJN ptr
		CALL PICNV1		;Convert PBPHYS and header
		LDB T1,PPBPHS		;Get nbr of -20 words in packet
		ADDI T1,PBHEAD-1(PB)	;Addr of checksum word
		CALL PICNV1		;Convert the checksum
		CALL UNLKPB		;Unlock packet from core
		SETZM PBIOBQ(PB) ; Mark PB no longer being serviced
		JRST PUPOS2]	;But don't deallocate
	CALL RELPBI		;No, just release packet buffer

; Now look for a Pup queued for output
PUPOS2:	MOVEI T1,PUPOBQ		;Output buffer queue header 
	CALL REMOBQ		;Remove packet from queue
	 JRST PUPSVX		;Queue empty
	LDB UNIT,PPUPUN		;Get index of originating port
	CALL SETPHD		;Setup physical destination
	 JRST PUPOE2		;Dest net inaccessible
	CALL DSCRAN		;See if want random discard
	 JRST PUPOS1		;Yes, do so
	MOVEM PB,CUROPB		;Save ptr to packet being output
	SETOM PBIOBQ(PB)	;Note not done with packet yet
	MOVEI T1,(PB)		;Make length,,address
	HRL T1,0(T1)
	MOVEM T1,XPUPOB		;Store for NVIO
	SIGNAL PUPOBG		;Signal NVIO to begin output
	JRST PUPSVX		;Dismiss


; Here if can't transmit packet because dest net is inaccessible
PUPOE2:	PBUG(PUP,<PUPOSV: Destination network inaccessible>)
	JRST PUPOS1		;Just flush from queue and get next

; Interrupt handler subroutines

; Save AC's T1-T4, UNIT, PB, and P for interrupt routine,
;  and set up P.
; Enter by JSYS PUPSAV


; Restore AC's and dismiss interrupt

PUPSVX:	RET			;Return to ETHSRV to dismiss interrupt

; Check for requested random discard
;	UNIT/ Pup unit #
; Returns +1:  Discard packet
;	+2:  Don't discard packet
; Clobbers T1, B

DSCRAN:	MOVX T1,DSCRNF		;Random discard requested?
	CAIE UNIT,NPUPUN	;And not gateway "port"?
	TDNN T1,PUPSTS(UNIT)
	 RETSKP			;No
	SKIPN T1,RANNUM		;Yes, get current random number
	 MOVS T1,TODCLK		;None, initialize to clock
	MULI T1,6065		;Compute next
	DIV T1,[377777777741]
	MOVSM T2,RANNUM		;Store remainder for next call
	TXNE T2,-1B5  		;Discard 1 packet in 32
	 AOS 0(P)
	RET    

;RS RANNUM			;Last random number


; Routine called from scheduler to request Pup received PSI on port
;	T1/ Pup unit #
; Returns +1
; Clobbers T1, T2, UNIT

PRQINT:	MOVEI UNIT,(T1)		;Put port index in right ac
	HRRE T2,PUPPSI(UNIT)	;Get fork to interrupt
	JUMPL T2,CPOPJ		;Forget it if none
	LDB T1,RECPSI		;Get PSI channel to interrupt on
	CAIGE T1,^D36		;Armed?
	 CALL PSIRQ		;Yes, initiate interrupt
	RET    

; Set physical destination and message length for Pup
;	PB/ Packet Buffer pointer
; Returns +1:  Destination unreachable
;	+2:  PBPHYS word set up

SETPHD:	LDB T2,PPUPDN		;Get destination net
	CAIL T2,1		;Check bounds (probably redundant)
	CAILE T2,NPNETS
	 RET			;Error
	SKIPGE T1,PUPROU-1(T2)	;Ok, get routing table entry
	 RET			;Net known to be unreachable
	LSH T1,2		;Left-justify net/host
	TXNN T1,177777B15  	;Dest net directly connected?
	 MOVE T1,PBHEAD+2(PB)	;Yes, use final destination
	MOVEM T1,PBPHYS(PB)	;Store phys net/host
	LDB T1,PUPLEN		;Get Pup length
	ADDI T1,3		;Convert to 36-bit words
	LSH T1,-2
	DPB T1,PPBPHS		;Set physical size for NVIO
	RETSKP			;Give skip return



; Start NVIO input going if necessary.
; Call after putting something on FREIBQ
; Returns +1, clobbers nothing

PUPIGO:	SKIPN XPUPIB		;Input already turned on?
	 IDEV PUPIDN		;No, initiate manual interrupt
	RET    


; Start NVIO output going if necessary.
; Call after putting something on PUPOBQ
; Returns +1, clobbers nothing

PUPOGO:	SKIPN XPUPOB		;Output already in progress?
	 IDEV PUPODN		;No, initiate manual interrupt
	RET    


; -----------------------------------------------------------------
;	General Pup Subroutines
; -----------------------------------------------------------------

; Port table management

	SWAPCD

; Assign local port
;	T1/ <net>B7 + <host>B15
;	T2/ Socket (right-justified)
; Returns +1:  Error, no slots available
;	+2:  Port already in use, UNIT/ Pup unit #
;	+3:  Successful, UNIT/ Pup unit #
; +1 return with PRTLCK unlocked, +2 and +3 with PRTLCK locked.
; Clobbers T3, T4, UNIT

ASGPRT:	LOCK(PRTLCK,,SPQ)	;Lock the table
	MOVX UNIT,1B0!1B2	;Set flags for port conflict check
	CALL PRTLU0		;Lookup local port
	 CAIA			;Not found
	RETSKP			;Found, take single skip return
	JUMPL UNIT,[
		UNLOCK(PRTLCK,RESIDENT,SPQ) ;Unlock and fail if table full
		RET]
	CALL INIPRT		;Initialize port
	SKIPE PUPLSK(UNIT)	;Skip if entry is free
	 SOS LSKNDL		;Deleted, decrement delete count
	HLLZM T1,PUPLNH(UNIT)	;Store net/host
	MOVEM T2,PUPLSK(UNIT)	;Store socket #, assigning port
	JRST SK2RET		;Take success return


; Delete local port
;	UNIT/ Pup unit #
; The port itself must be locked if it is a BSP port
; Returns +1 always
; Clobbers T1-T4, PB

DELPRT:	LOCK(PRTLCK,,SPQ)	;Lock the table
	SETOM PUPLSK(UNIT)	;Mark entry deleted
	CALL DELTQP		;Delete port from timer queue
	MOVEI T1,PUPIBQ(UNIT)	;Input packet buffer queue header
	CALL FSHPBQ		;Flush packet buffer queue
	SKIPE T2,PUPFPT(UNIT)	;Have foreign port address table?
	 CALL RELPFR		;Yes, deallocate it
	HRRZ T2,PUPLNH(UNIT)	;Have BSP data block?
	SKIPE B
	 CALL RELPFR		;Yes, deallocate it
	SETZM PUPLNH(UNIT)	;Zero net/host and BSP linkage
	CALL INIPRT		;Initialize port for cleanliness
	AOS T2,LSKNDL		;Increment # of deleted entries
	SIGPBP(GCS,<CAIL T2,NPUPUN/4>) ;Request GC of table if worthwhile
	UNLOCK(PRTLCK,RESIDENT,SPQ)  ; Unlock the table
	RET    


; Initialize local port
;	UNIT/ Pup unit #
; Returns +1 always, after setting the port's entry in all port-
;  indexed tables to a virgin state.
; Clobbers C

INIPRT:	SETZM PUPFPT(UNIT)	;Clear foreign port
	MOVEI T3,PUPIBQ(UNIT)	;Set input buffer queue to empty
	HRLM T3,(T3)
	HRRM T3,(T3)
	SETZM PUPIBC(UNIT)	;Set queue counts to zero
	SETZM PUPOBC(UNIT)
	SETOM PUPPSI(UNIT)	;Disable PSI stuff
	SETZM PUPSTS(UNIT)	;Clear status word
	RET    

	RESCD

; Garbage collect Pup local socket table by setting free as many
;  deleted entries as possible.  This is done by first changing
;  all deleted entries to be free, then looking up each in-use
;  entry and marking deleted all free cells encountered.
; Clobbers T1-T4, UNIT, E

GCPLSK:	LOCK(PRTLCK)		;Lock the table
	NOSKD1
	CHNOFF PUPCHN		;Lock out interrupt-level accesses
	MOVSI E,-NPUPUN		;For all entries:
	SKIPGE PUPLSK(E)	;Deleted?
	 SETZM PUPLSK(E)	;Yes, set free
	AOBJN E,.-2
	SETZM LSKNDL		;Init count of deleted entries
	MOVSI E,-NPUPUN		;For all entries:
GCPLS1:	SKIPG T2,PUPLSK(E)	;In use?
	 JRST GCPLS2		;No
	MOVE T1,PUPLNH(E)	;Yes, fetch net/host
	MOVX UNIT,1B1		;Set special flag
	CALL PRTLU0		;Lookup, setting free entries to deleted
	 BUG(GCPLSZ)
GCPLS2:	AOBJN E,GCPLS1
	CHNON PUPCHN		;Unlock and return
	OKSKD1
	UNLOCK(PRTLCK)
	RET    

; Lookup local port
;	T1/ <net>B7 + <host>B15
;	T2/ Socket (right-justified)
; Returns +1: fail, UNIT/ Index of first free slot (B0 set =) full)
;	  +2: found, UNIT/ Index of matching entry
; Non-interrupt-level callers should lock PRTLCK before calling
;  if they intend to use UNIT on either return.
; Clobbers T3, T4, UNIT

PRTLUK:	MOVX UNIT,1B0		;Note no free entries found yet

; Enter here for various flavors of lookup controlled by lh UNIT:
;  B0	No free entries found yet (should always be set on call)
;  B1	Doing gc marking (setting free entries to deleted)
;  B2	Doing port conflict check (wildcard in either arg or port
;	constitutes a match)

PRTLU0:	STKVAR <CURPTC>		;Current port to check
	MOVE T3,[^D2654435769_3] ;Constant relatively prime to 2^32
	MUL T3,T2		;D _ 32-bit fraction in range [0,1)
	MOVEI T3,NPUPUN		;Normalize to range [0,NPUPUN)
	MULM T3,T4
	MOVNI T3,(T4)		;Save neg index for wraparound
	HRLM T3,CURPTC		;Save
	HRLI T4,-NPUPUN(T4)	;Make AOBJN ptr, here to end
PRTLU1:	CAMN T2,PUPLSK(T4)	;Socket number match this entry?
	 JUMPN T2,[MOVE T3,PUPLNH(T4) ;Yes, compare net/host
		XOR T3,T1
		HLR T3,PUPLNH(T4) ;Wildcard check
		TXNE UNIT,1B2  	;Port conflict check?
		 TXNE T1,377B7   ;Yes, check arg for wildcard
		TXNN T3,377B25
		 TXZ T3,377B7  	;Net wildcard
		TXNE UNIT,1B2  	;Port conflict check?
		 TXNE T1,377B15   ;Yes, check arg for wildcard
		TXNN T3,377B33
		 TXZ T3,377B15   ;Host wildcard
		TXNE T3,177777B15  
		 JRST PRTLU2	;Mismatch, continue search
		MOVEI UNIT,(T4)	;Match, return index
		RETSKP]
	SKIPG T3,PUPLSK(T4)	;No match, free or deleted?
	 JRST [	TXNE UNIT,1B1  	;Yes, doing gc marking?
		 JRST [	JUMPL T3,PRTLU2	;Yes, ignore if deleted
			SETOM PUPLSK(T4) ;Free, mark deleted
			AOS LSKNDL	;Bump delete count
			JRST PRTLU2]	;Continue search
		TXZE UNIT,1B0  	;No, already have free/deleted index?
		 HRRI UNIT,(T4)	;No, remember this
		JUMPL T3,PRTLU2	;Keep searching if deleted entry
		TXZ UNIT,<377777,,0> ;CS36 Mask out search bits
		RET]		;Fail if free entry, i.e. not found	
PRTLU2:	AOBJN T4,PRTLU1		;Search linearly thru table
	HLLZ T4,CURPTC		;At end, wraparound
	HRRZS CURPTC		;Clear count in case get here again
	JUMPL T4,PRTLU1		;Do portion before initial probe
	TXZ UNIT,<377777,,0> ;CS36 Mask out search bits
	RET    			;Searched whole table, not found

	SWAPCD

; Check Pup source field
;	PB/ Packet buffer pointer
;	UNIT/ Pup unit #
; Returns +1:  Source incorrect
;	+2:  Source correct, i.e. matches foreign port
; Clobbers T1-T4

CHKSRC:	LDB T1,PPUPSN		;Get source net from Pup
	LDB T2,PPUPSH		;Source host
	LDB T3,PPUPSS		;Source socket

; Enter here with T1/ net, T2/ host, T3/ socket to be checked
CHKSR1:	SKIPN T4,PUPFPT(UNIT)	;Have foreign port address table?
	 RETSKP			;No, fully wildcard, skip return
	PUSH P,E		;Get another ac
CHKSR2:	HLRZ E,1(T4)		;Get net from table
	CAIE T1,(E)		;Match?
	 JUMPN E,CHKSR3		;No, fail unless wildcard
	HRRZ E,1(T4)		;Yes, get host from table
	CAIE T2,(E)		;Match?
	 JUMPN E,CHKSR3		;No, fail unless wildcard
	CAME T3,2(T4)		;Yes, check socket
	 SKIPN 2(T4)		;Mismatch, fail unless wildcard
	AOSA -1(P)		;Matched, take skip return
CHKSR3:	AOBJN T4,CHKSR2		;Table entry mismatched, try next
	POP P,E			;Matched (skip preset) or no more
	RET    


; Set Pup checksum
;	PB/ Packet Buffer pointer
; Returns +1:
; Clobbers T1-T4

SETCKS:	CALL PUPCKS		;Compute checksum
	MOVE T3,T1		;Save it
	CALL GPTCKS		;Get byte pointer to checksum
	DPB T3,T2		;Store checksum in Pup
	RET    


; Check Pup checksum
;	PB/ Packet Buffer pointer
; Returns +1:  Checksum incorrect
;	+2:  Checksum correct
; Clobbers T1-T4

CHKCKS:	CALL GPTCKS		;Get byte pointer to checksum
	LDB T3,T2		;Get checksum from Pup
	CAIN T3,177777		;Real checksum?
	 RETSKP			;No, unchecksummed Pup always ok
	PUSH P,T3		;Yes, save checksum from Pup
	CALL PUPCKS		;Recompute checksum
	POP P,T3
	CAMN T1,T3		;Correct?
	 AOS 0(P)		;Yes, skip return
	RET    

	RESCD

; Update Pup checksum
;	PB/ Packet Buffer pointer
;	T1/ New value of field to be updated
;	T2/ Byte pointer denoting field to be changed
;	   Must be indexed by PB and cannot cross 16-bit boundary
; Returns +1 after storing new value as specified and updating the
;	   checksum (if appropriate)
; Clobbers T1-T4

UPDCKS:	MOVE T3,T1		;Save new value
	MOVEI T1,(T2)		;Compute Maxc-word offset of field
	LSH T1,1		;Convert to 16-bit word offset
	HLRZ T4,T2		;Which byte?
	CAIGE T4,^D20B23
	 ADDI T1,1		;Right, add 1 to offset
	PUSH P,T2		;Save byte ptr arg
	CALL GPTWRD		;Get pointer to 16-bit word
	LDB T4,T2		;Fetch old contents of word
	DPB T3,0(P)		;Store new value into field being changed
	ADJSP P,-1		;Fix stack
	LDB T3,T2		;Fetch new contents of word
	SUBI T3,(T4)		;Compute 16-bit 1's complement difference
	JUMPGE T3,.+2
	 ADDI T3,177777
	MOVE T4,T1		;Save offset
	CALL GPTCKS		;Return offset and ptr to checksum
	SUBI T1,(T4)		;Compute difference in offsets
	ANDI T1,17		;Modulo 16
	LSH T3,(T1)		;Shift checksum correction appropriately
	LDB T1,T2		;Fetch old checksum
	CAIN T1,177777		;Real checksum?
	 RET			;No, unchecksummed Pup, don't update
	ADD T1,T3		;Compute new sum
	MOVE T4,T2		;Save byte ptr
	CALL CKFOLD		;Fold computed checksum to 16 bits
	CAIN T1,177777		;Check for minus zero
	 SETZ T1,		;Convert to plus zero
	DPB T1,T4		;Store new checksum
	RET    


; Get pointer to Pup checksum
;	PB/ Packet Buffer pointer
; Returns +1:
;	T1/ Packet-Buffer-relative offset of 16-bit checksum word
;	T2/ Byte pointer to Pup checksum
; No other ac's clobbered

GPTCKS:	LDB T1,PUPLEN		;Get Pup length in bytes
	ADDI T1,4*PBHEAD-1	;Compute PB-relative 16-bit word offset
	LSH T1,-1		; of Pup checksum
				;Fall into GPTWRD


; Get pointer to 16-bit word in Pup
;	T1/ Packet-Buffer-relative offset of word
;	   e.g. 2*PBHEAD denotes offset of Pup Length field
; Returns +1:
;	T2/ Byte ptr to selected word (indexed by PB)
; No ac's clobbered (besides B)

GPTWRD:	MOVEI T2,(T1)		;Copy offset
	ROT T2,-1		;Compute Maxc-word offset
	JUMPL T2,.+2		;Which byte?
	 TLOA T2,(POINT 16,(PB),15)  ; Left
	 HRLI T2,(POINT 16,(PB),31)  ; Right
	RET    

	SWAPCD

; Compute Pup checksum
;	PB/ Packet Buffer pointer
; Returns +1:
;	T1/ 16-bit checksum, right-justified
; Clobbers B-D

PUPCKS:	LDB T3,PUPLEN		;Pup length in bytes
	SUBI T3,1		;Compute # full words to checksum
	LSHC T3,-2		;(i.e. exclusive of checksum word)
	PUSH P,T4		;Sign bit set if leftover 16-bits
	ROT T3,-3		;Divide # full words by 8
	MOVEI T4,1(T3)		;# 8-fold cycles +1
	LSH T3,-^D<18-3>	;# leftover bytes in lh
	MOVN T3,T3		;Make AOBJN pointer to Pup
	HRRI T3,PBHEAD(PB)
	SETZ T1,		;Init checksum to zero
	TXNN T3,<-1,,0>		;Use leftover count first
	 JRST PUPCK4		;None, start full 8-fold cycles
PUPCK2:	MOVE T2,0(T3)  		;Get a word
	ANDCMI T2,17		;Clear garbage bits
	ROT T2,^D16		;High 16 bits to B20-35, clear B18-19
	ADDI T1,(T2)		;Add to checksum
	LSH T1,2		;Shift checksum twice
	LSH T2,-^D<36-16-1>	;Justify previous low 16 bits to B34
	ADDI T1,(T2)		;Add to checksum (pre-shifted)
	AOBJN T3,PUPCK2		;Repeat for this group
	CALL CKFOLD		;Fold 36 bits to 16
PUPCK4:	HRLI T3,-8		;Set to do next group
	SOJG T4,PUPCK2		;Repeat if more to do
	POP P,T4		;Done, have a leftover 16 bits?
	JUMPGE T4,PUPCK5
	MOVE T2,0(T3)		;Yes, add it in
	LSH T2,-^D<36-16>
	ADDI T1,(T2)
	LSH T1,1
	CALL CKFOLD		;Fold to 16 bits
PUPCK5:	CAIN T1,177777		;Minus zero?
	 SETZ T1,		;Yes, make plus zero
	RET    


	RESCD

; Fold 36-bit add-and-left-shift checksum into 16-bit
;  ones-complement add-and-left-cycle checksum
;	T1/ 36-bit checksum
; Returns +1:
;	T1/ 16-bit checksum, right-justified
; Clobbers B

CKFOLD:	CAIG T1,177777
	 RET			;No more folding to do
	LSHC T1,-^D16		;Overflow bits in T1, low 16 in B
	LSH T2,-^D<36-16>
	ADDI T1,(T2)		;Fold
	JRST CKFOLD		;Check again

; Pup free storage management routines

	SWAPCD

; Assign Pup free storage block from the PUPFRE region
;	T2/ Size of block needed (words)
; Returns +1: Failed
;	+2: T1/ Pointer to block
; Clobbers T1-T4

ASGPFR:	MOVEI T1,PUPFRE		;Point to free storage header
	NOINT			;Defer interrupts
	CALL ASGFRE		;Assign the block
	JRST .+2		;+1 return if no room
	AOS (P)			;+2 return if ok
	OKINT			;Allow interrupts
	RET    			;Return (+1 or +2)

; Release Pup free storage block
;	T2/ Pointer to block
; Returns +1 always
; Clobbers T1-T4

RELPFR:	MOVEI T1,PUPFRE		;Point to free storage header
	JRST RELFRE		;Just call standard routine



; Trim Pup storage block
;	T1/ Pointer to block
;	T2/ # words to retain
; Returns +1 always
; Clobbers T1-T4

TRMPFR:	HRRZ T3,0(T1)		;Get current size
	SUB T3,T2		;Compute excess words
	JUMPLE T3,CPOPJ		;Quit if none
	HRRM T2,0(T1)		;Store new size
	ADDI T2,(T1)		;Point to start of excess
	HRRM T3,0(T2)		;Store size at head of block
	CALL RELPFR		;Release excess block
	RET    

; Assign packet buffer
;	T2/ Size of buffer needed (words)
; Returns +1:  Failed, T1/ appropriate arg for EDISMS
;	+2:  PB/ Packet Buffer pointer
; The buffer returned has the size setup (PBSIZE) and all else zeroed.
; Clobbers T1-T4

ASGPKT:	MOVEI T1,PKTFRE		;Free storage header
	NOINT			;Defer interrupts
	CALL ASGFRE		;Assign the block
	 JRST ASGPK1		;Can't
	OKINT			;Allow interrupts
	MOVEI PB,(T1)		;Ok, put buffer adr in PB
	CALL CLRPBH		;Clear header
	RETSKP			;Skip return

; Here when fail to allocate
ASGPK1:	OKINT			;Allow interrupts
	 BUG(ASGPKZ)
	MOVSI T1,(T2)		;Set scheduler test word
	HRRI T1,PKTFRT		;Size,,routine
	SETZM PKTRLF		;Init wakeup condition
	RET    			;Take fail return

	RESCD

; Scheduler test for process dismissed after ASGPKT failure
; Arg is size of packet buffer needed (words)

;RS PKTRLF	;Set nonzero when storage has been released

PKTFRT:	CAMG T1,PKTFRE+2	;Don't wakeup if total space insufficient
	SKIPN PKTRLF		;Wakeup if RELPKT has been called
	 JRST 0(T4)
	JRST 1(T4)


	SWAPCD

; Release packet buffer
;	PB/ Packet Buffer pointer
; Returns +1
; Clobbers T1-T4, PB

RELPKT:	MOVX T1,PBLCKF		;Make sure not locked
	TDNE T1,PBSIZE(PB)
	 BUG(RELPKZ)
	HRRZ T1,PBSIZE(PB)	;Check size
	MOVE T2,FREIBN		;Get free input buffer count
	CAIL T1,MXPBLN		;Releasing maximum-size buffer?
	CAIL T2,MAXFIB		;Yes, want to add more input buffers?
	 JRST [	MOVEI T1,PKTFRE	;No, just release the storage
		MOVEI T2,(PB)
		CALL RELFRE
		SETOM PKTRLF	;Note space has been released
		RET]
	CALL CLRPBH		;Yes, clear header
	JRST ASGIP1		;Go put on FREIBQ and return

; Assign input packet buffer, add to FREIBQ, and start up input if necessary
; Returns +1: failed
;	+2: succeeded
; Clobbers T1-T4 and PB

ASGIPB:	MOVEI T2,MXPBLN		;Get maximum-size packet buffer
	CALL ASGPKT
	 RET			;Failed, forget it
	AOS 0(P)		;Ok, preset skip return

; Here from RELPKT with PB/ ptr to maximum-size packet buffer
ASGIP1:	MOVEI T1,FREIBQ		;Free input buffer queue header
	CALL APPOBQ		;Lock and append to queue
	AOS FREIBN		;Fix count
	CALL PUPIGO		;Start input if necessary
	RET    


	RESCD

; Release packet buffer at interrupt level
;	PB/ Packet buffer ptr
; Returns +1
; Callable only at interrupt level;  PB must be locked
; Clobbers T1-T4

RELPBI:	MOVX T1,PBLCKF		;Make sure locked
	TDNN T1,PBSIZE(PB)
	 BUG(RELPBZ)
	HRRZ T1,PBSIZE(PB)	;Get size of PB
	MOVE T2,FREIBN		;Get # of buffers already available
	CAIL T1,MXPBLN		;This PB too small?
	CAIL T2,MAXFIB		;Already enough PBs available?
	 JRST [	MOVEI T1,FREOBQ	;Yes, put PB on queue to be freed
		CALL APPIBQ
		SIGPBP(FRE)	;Request service by deallocator
		RET]
	CALL CLRPBH		;No, clear header
	MOVX T1,PBLCKF		;Set locked flag again
	IORM T1,PBSIZE(PB)
	MOVEI T1,FREIBQ		;Free input buffer queue header
	MOVEI T2,PBIOBQ(PB)	;Make ptr to link word in PB
	CALL APPITQ		;Append to queue
	AOS FREIBN		;Fix count
	CALL PUPIGO		;Start input if necessary
	RET    


; Clear packet buffer header
;	PB/ Packet buffer ptr
; Returns +1, clobbers nothing

CLRPBH:	HRRZS PBSIZE(PB)	;Clear lh of PBSIZE
	SETZM PBIOBQ(PB)	;Clear I/O queue links
	SETZM PBBSPQ(PB)	;Clear BSP queue links
	SETZM PBTIME(PB)	;Clear time stamp word
	RET    

; Packet buffer queueing and unqueueing routines
	SWAPCD

; Get Pup from port input queue
;	UNIT/ Pup unit #
; Returns +1:  Queue empty, T1/ Appropriate arg for EDISMS
;	+2:  PB/ Packet Buffer pointer, counts updated appropriately
; Clobbers T1-T3

GETPUP:	MOVEI T1,PUPIBQ(UNIT)	;Set adr of port input queue hdr
	CALL REMIBQ		;Get packet buffer from queue
	 JRST [	MOVEI T1,NEPBQT	;Empty, set scheduler test word
		HRLI T1,PUPIBQ(UNIT)
		RET]		;Fail return
	CALL PUICNV		;Convert data portion of packet
	HRRZ T1,PBSIZE(PB)	;Got one, get packet buffer length
	CALL DECIQL		;Decrement input queue length counts
	RETSKP			;Skip return

	RESCD

; Scheduler test for non-empty packet buffer queue
; Arg is address of queue header

NEPBQT:	HRRZ T2,(T1)		;Get head item in queue
	CAIN T2,(T1)		;Self-pointer?
	 JRST 0(T4)		;Yes, queue still empty
	JRST 1(T4)		;Non-empty, wakeup

	SWAPCD

; Put Pup on output queue
;	PB/ Packet Buffer pointer
;	UNIT/ Pup unit #
; Returns +1:  Queue too long, T1/ Appropriate arg for EDISMS
;	+2:  Ok, queue length updated appropriately
; Clobbers T1-T3

PUTPUP:	DPB UNIT,PPUPUN		;Store unit # in Pup
	HRRZ T1,PBSIZE(PB)	;Get length of new packet buffer
	CALL CHKOQL		;Check for exceeding output queue length
	 RET			;Too much, fail return
	ADDM T1,PUPOBC(UNIT)	;Ok, update count
	MOVEI T1,PUPOBQ		;Pup output buffer queue header
	CALL APPOBQ		;Lock and append Pup to queue
	CALL PUPOGO		;Start output going if necessary
	RETSKP			;Skip return

	RESCD

; Delete Pup from output queue if still on it
; Pup must be marked as owned by BSP processor (PBBSPQ nonzero)
;	PB/ Packet buffer pointer
;	UNIT/ Pup unit #
; Returns +1, releases or disposes of packet buffer always
; Clobbers T1-T3

DELOBQ:	SKIPN PBBSPQ(PB)	;Make sure owned by BSP processor
	 BUG(DELOBZ)
	SKIPN PBIOBQ(PB)	;Now on output queue?
	 JRST DELOB2		;No, just release the packet
	NOSKED			;Prevent swapouts
	SKIP PBIOBQ(PB)		;Make sure in core
	CHNOFF PUPCHN		;Lock out interrupts
	SKIPN T1,PBIOBQ(PB)	;Still on output queue?
	 JRST DELOB1		;No, just release the packet
	AOJE T1,[SETZM PBBSPQ(PB)  ; Now being output by NVIO,
		CHNON PUPCHN	; mark unowned so output interrupt
		OKSKED		; deallocates it when done
		RET]
	MOVEI T1,PBIOBQ(PB)	;On output queue, unlink it
	CALL DELITQ
	HRRZ T1,PBSIZE(PB)	;Get size of packet buffer
	CALL DECOQL		;Decrement counts
	CALL UNLKPB		;Unlock packet buffer
DELOB1:	CHNON PUPCHN		;Uninterlock
	OKSKED
DELOB2:	CALL RELPKT		;Release the packet buffer
	RET    			;Done

; Check input queue length
;	T1/ Size of packet about to be added to input queue
;	UNIT/ Pup unit #
; Returns +1:  Error, queue too full
;	+2:  Ok, T1/ 1,,size (ready to be added to PUPIBC(UNIT))
; Clobbers T2, C

CHKIQL:	HLRZ T2,PUPIBC(UNIT)	;Get buffer count
	HRRZ T3,PUPIBC(UNIT)	;Get word count
	ADDI T3,(T1)		;Add new size to it
	CAIGE T2,MAXIQB		;Enough buffers already?
	CAILE T3,MAXIQW		;Too many words?
	 RET			;Yes, fail
	HRLI T1,1		;No, set to add count
	RETSKP			;Skip return


; Decrement input queue length
;	T1/ Size of packet just removed from input queue
;	UNIT/ Pup unit #
; Returns +1 always
; Clobbers A

DECIQL:	HRLI T1,1		;Set to count one buffer
	MOVNS T1		;Negate buffer and word counts
	ADDB T1,PUPIBC(UNIT)	;Decrement them
	TDNE T1,[1B0+1B18]	;Check for over-decrementing
	 BUG(DECIQZ)
	RET    

; Check output queue length
;	T1/ Size of packet about to be added to output queue
;	UNIT/ Pup unit #
; Returns +1:  Error, queue too full, T1/ EDISMS argument word
;	+2:  Ok, T1/ 1,,size (ready to be added to PUPOBC(UNIT))
; Clobbers T2, C

CHKOQL:	HLRZ T2,PUPOBC(UNIT)	;Get buffer count
	HRRZ T3,PUPOBC(UNIT)	;Get word count
	ADDI T3,(T1)		;Add new size to it
	CAIGE T2,MAXOQB		;Enough buffers already?
	CAILE T3,MAXOQW		;Too many words?
	 JRST [	LSH T1,^D<35-8>	;Yes, position size to B8
		TXO T1,UNIT  	;Unit # at B17
		HRRI T1,FOPBQT	;Set scheduler test
		RET]		;Fail return
	HRLI T1,1		;No, set to add count
	RETSKP			;Skip return

; Scheduler test for full output packet buffer queue
; Arg is in form <size of new packet>B26 + Pup unit #

FOPBQT:	LSHC T1,-^D9		;Separate size and unit
	LSH T2,-^D<36-9>	;Size to T1, unit # to B
	HRRZ T3,PUPOBC(T2)	;Get word count
	HLRZ T2,PUPOBC(T2)	;Get buffer count
	ADDI T3,(T1)		;Add new length to word count
	CAIGE T2,MAXOQB		;Within bounds?
	CAILE T3,MAXOQW
	 JRST 0(T4)		;No
	JRST 1(T4)		;Yes, wakeup


; Decrement output queue length
;	T1/ Size of packet just removed from output queue
;	UNIT/ Pup unit #
; Returns +1 always
; Clobbers A

DECOQL:	HRLI T1,1		;Set to count one buffer
	MOVNS T1		;Negate buffer and word counts
	ADDB T1,PUPOBC(UNIT)	;Decrement them
	TDNE T1,[1B0+1B18]	;Check for over-decrementing
	 BUG(DECOQZ)
	RET    


; Check gateway queue length
;	T1/ Size of packet about to be added to gateway queue
;	UNIT/ Pup unit # of gateway queue (NPUPUN)
; Returns +1:  Error, queue too full
;	+2:  Ok, T1/ 1,,size (ready to be added to PUPOBC(UNIT))
; Clobbers T2, C

CHKGQL:	HLRZ T2,PUPOBC(UNIT)	;Get buffer count
	HRRZ T3,PUPOBC(UNIT)	;Get word count
	ADDI T3,(T1)		;Add new size to it
	CAIGE T2,MAXGQB		;Enough buffers already?
	CAILE T3,MAXGQW		;Too many words?
	 RET			;Yes, fail
	HRLI T1,1		;No, set to add count
	RETSKP			;Skip return

; Append packet buffer to input queue at interrupt level
;	PB/ Packet Buffer pointer
;	T1/ Address of queue header
; Returns +1
; Previous tail (if any) must of course be locked, and is
;  unlocked by this routine.
; Clobbers T1-T3

APPIBQ:	MOVEI T2,PBIOBQ(PB)	;Get adr of new PB's link word
	CALL APPITQ		;Append item to queue
	CAIN T3,(T1)		;Was queue previously empty?
	 RET			;Yes, done
	PUSH P,PB		;No, save current PB
	MOVEI PB,-PBIOBQ(T3)	;Compute real adr of old tail PB
	CALL UNLKPB		;Unlock it
	POP P,PB
	RET    


; Remove packet buffer from input queue at non-interrupt level,
;  and unlock it if necessary
;	T1/ Address of queue header
; Returns +1:  Queue empty
;	+2:  PB/ Address of packet buffer
; Clobbers T1-T3

REMIBQ:	HRRZ T2,(T1)		;Get queue header word
	HRRZ T2,(T2)		;Reference head packet
	SKIP (T2)		;Reference successor
	NOSKED			;Prevent swapouts
	HRRZ T2,(T1)		;Do references again in case
	HRRZ T2,(T2)		; pages sneaked away (page fault
	SKIP (T2)		; while CHNOFF is death)
	CHNOFF PUPCHN		;Interlock
	CALL REMITQ		;Remove item from queue
	 JRST [	CHNON PUPCHN	;Empty, fail
		OKSKED
		RET]
	CHNON PUPCHN
	MOVEI PB,-PBIOBQ(T2)	;Get real adr of new PB
	CAIN T3,(T1)		;Was this the only PB in the queue?
	 CALL UNLKPB		;Yes, have to unlock it
	OKSKED
	SETZM PBIOBQ(PB)	;Mark PB as not in queue
	RETSKP			;Skip return


; Lock and append packet to output queue at non-interrupt level
;	T1/ Address of queue header
;	PB/ Packet Buffer pointer
; Returns +1
; Clobbers T2,T3

APPOBQ:	PUSH P,T1
	CALL LOCKPB		;Lock the packet buffer
	POP P,T1
	MOVEI T2,PBIOBQ(PB)	;Get adr of new PB's link word
	NOSKD1
	CHNOFF PUPCHN		;Interlock
	CALL APPITQ		;Append to queue
	CHNON PUPCHN
	OKSKD1
	RET    


; Remove packet buffer from output queue at interrupt level,
;  but do not unlock it
;	T1/ Address of queue header
; Returns +1:  Queue empty
;	+2:  PB/ Address of packet buffer
; Clobbers T1-T3

REMOBQ:	CALL REMITQ		;Remove item from head of queue
	 RET			;Empty, fail
	MOVEI PB,-PBIOBQ(T2)	;Get real adr of new PB
	RETSKP			;Skip return

; Primitive queueing/unqueueing routines.
; The caller is responsible for interlocking queue access for
;  race prevention.


; Insert item into queue
;	T1/ Address of item which is to be the new item's successor,
;	    i.e. before which the new item is to be inserted
;	T2/ Address of item to insert
; Returns +1:
;	T3/ Address of new item's predecessor
; No other ac's affected

INSITQ:				;Same as APPITQ


; Append item to queue
;	T1/ Address of queue header
;	T2/ Address of item to append
; Returns +1:
;	T3/ Address of previous tail item
; No other ac's affected

APPITQ:	PUSH P,T4		;Save callers T4
	HRRZ T4,T1		;CS36 In section pointer
	HLRZ T3,(T4)		;Get current tail
	HRLM T2,(T4)		;Queue tail _ new PB
	HRRZ T4,T2		;CS36 In section pointer
	HRRZM T1,(T4)		;New PB's successor _ queue header
	HRLM T3,(T4)		;New PB's predecessor _ old tail
	HRRM T2,(T3)		;Old tail's successor _ new PB
	POP P,T4
	RET    

; Remove item from head of queue
;	T1/ Address of queue header
; Returns +1:  Queue empty
;	+2:  T2/ Address of item removed
;	     T3/ Address of new head item
; No other ac's affected

REMITQ:	HRRZ T2,(T1)		;Get current head
	CAIN T2,(T1)		;Empty?
	 RET			;Yes, fail
	HRRZ T3,(T2)		;No, get successor
	HRRM T3,(T1)		;Queue head _ successor
	HRLM T1,(T3)		;Successor's predecessor _ queue header
	SETZM (T2)		;Clear links in removed item
	RETSKP			;Skip return


; Delete item from queue, i.e. unlink it, wherever it is in queue
;	T1/ Address of item to be deleted
; Returns +1:
;	T2/ Address of item that was predecessor to this one
;	T3/ Address of item that was successor to this one
; No other ac's affected

DELITQ:	HLRZ T2,(T1)		;Get this item's predecessor
	HRRZ T3,(T1)		;Get this item's successor
	HRLM T2,(T3)		;Fix links between predecessor
	HRRM T3,(T2)		; and successor
	SETZM (T1)		;Clear links in deleted item
	RET    

; Miscellaneous subroutines

	SWAPCD

; Flush packet buffer queue
;	T1/ Address of queue header
; Returns +1 always.
; Caller must do any necessary race prevention
; Clobbers T1-T4, PB

FSHPBQ:	STKVAR <FSHPBS>		;Queue head
	HRLM T1,FSHPBS		;Save pointer to queue header
FSHPB1:	CALL REMITQ		;Remove item from head of queue
	 RET			;Queue empty, done
	MOVEI PB,-PBIOBQ(T2)	;Got one, set pointer
	MOVX T1,PBLCKF		;Is packet buffer locked?
	TDNE T1,PBSIZE(PB)
	 CALL UNLKPB		;Yes, unlock it
	CALL RELPKT		;Release packet buffer
	HLRZ T1,FSHPBS		;Restore queue header pointer
	JRST FSHPB1		;Repeat till queue empty


; Trim unlocked packet buffer and liberate excess
; Callable only from process level
;	PB/ Packet buffer ptr
; Returns +1 always
; Clobbers T1-T4

TRMUPB:	LDB T1,PUPLEN		;Get Pup Length (bytes)
	ADDI T1,4*PBHEAD+3	;Add overhead and convert to words
	LSH T1,-2
	HRRZ T2,PBSIZE(PB)	;Get current size of packet buffer
	SUBI T2,(T1)		;Compute excess
	CAIG T2,^D20		;Worth releasing excess?
	 RET			;No, forget it
	HRRM T1,PBSIZE(PB)	;Reduce size of packet
	PUSH P,PB		;Save packet buffer ptr
	ADDI PB,(T1)		;Make ptr to excess block
	MOVEM T2,PBSIZE(PB)	;Put size at head of excess
	CALL RELPKT		;Release excess block
	POP P,PB		;Restore original PB ptr
	RET    


	RESCD


; Trim locked packet buffer and put excess on FREOBQ to be freed
; Callable only from interrupt level
;	PB/ Packet buffer ptr
; Returns +1 always
; Clobbers T1, B

TRMLPB:	LDB T1,PUPLEN		;Get Pup Length (bytes)
	ADDI T1,4*PBHEAD+3	;Add overhead and convert to words
	LSH T1,-2
	HRRZ T2,PBSIZE(PB)	;Get current size of packet buffer
	SUBI T2,(T1)		;Compute excess
	CAIG T2,^D20		;Worth releasing excess?
	 RET			;No, forget it
	HRRM T1,PBSIZE(PB)	;Reduce size of packet
	PUSH P,PB		;Save packet buffer ptr
	ADDB PB,T1		;Point to first word of excess
	HRLI T2,(PBLCKF)	;Set locked flag
	MOVEM T2,PBSIZE(PB)	;Put size at head of excess
	TXNE PB,777		;Split other than at page boundary?
	 CALL MLKMCA		;Yes, lock start of excess block
	CALL RELPBI		;Release excess block
	POP P,PB		;Restore original PB ptr
	RET    

; Lock monitor page known to be in core and assigned
; Page must be private to the monitor map.
; Call with monitor virtual address in 1

;This is here instead of in pagem to minimize changed modules
;???? !!!! ????

MLKMCA:	HRRZ T1,T1		;CS36 A section 0 address
	LSH T1,-9		;Convert address to page #
	SKIPE T1,MMAP(T1)	;Get monitor entry for page
	TXNE T1,NCORTM		;Error if not in core
	 BUG(MLKMC2)
	MOVX T2,PLKV		;Ok, increment lock count
	ADDB T2,CST1(T1)	
	TXNE T2,-PLKV_1  	;Was page previously locked?
	 JRST MLKMC3
	AOS LOKPGS		;No, increment # of locked pages
	AOS BALSHC
	AOS GNPBAS
	AOS SUMNR
	AOS SUMBNR		;CS36
MLKMC3:	AOS LOKSUM		;Increment total # of locks
	RET

	SWAPCD

; Lock packet buffer
;	PB/ Packet Buffer pointer
; Returns +1
; Callable only from process level
; Clobbers A

LOCKPB:	MOVX T1,PBLCKF		;Make sure not already locked
	TDNE T1,PBSIZE(PB)
	 BUG(LOCKPZ)
	IORM T1,PBSIZE(PB)	;Mark locked
	MOVEI T1,0(PB)		;Lock page in which PB starts
	CALL MLKMA
	HRRZ T1,PBSIZE(PB)	;Get length of PB
	ADDI T1,-1(PB)		;Compute adr of last word in PB
	ANDI T1,777000		;Find start adr of page
	CAILE T1,(PB)		;Does PB cross page boundary?
	 CALL MLKMA		;Yes, lock page in which PB ends
	RET    

	RESCD

; Unlock packet buffer
;	PB/ Packet Buffer pointer
; Returns +1
; Must be called NOSKED, INSKED, CHNOFF, or at interrupt level
; Clobbers A

UNLKPB:	MOVX T1,PBLCKF		;Make sure really locked
	TDNN T1,PBSIZE(PB)
	 BUG(UNLKPZ)
	ANDCAM T1,PBSIZE(PB)	;Mark unlocked
	MOVEI T1,0(PB)		;Unlock page in which PB starts
	CALL MULKMP
	HRRZ T1,PBSIZE(PB)	;Get length of PB
	ADDI T1,-1(PB)		;Compute adr of last word in PB
	ANDI T1,777000		;Find start adr of page
	CAILE T1,(PB)		;Does PB cross page boundary?
	 CALL MULKMP		;Yes, unlock page in which PB ends
	RET    


;Routine to lock NVTLCK -- succeeds if already locked by same FORKX
GTNVLK:	PIOFF			;No interrupts please
	MOVE CX,FORKX		;Get current fork
	AOSE NVTLCK		;Try to get lock
	CAMN CX,NVTLCK+1	;Can't, locked by same fork?
	AOSA (P)		;Either got lock or locked by same fork
	 SOSA NVTLCK		;Can't get lock, correct lock count
	MOVEM CX,NVTLCK+1	;Remember who has the lock
	PION			;Enable interrupts
	RET			;Return +1 to wait, +2 if got lock

;Routine to unlock NVTLCK
RLNVLK:	SKIPL NVTLCK		;Prevent over-decrementing
	 SOS NVTLCK		;Unlock 1 level
	RET
; Make Error Pup out of Pup about which it is complaining
;	PB/ Packet buffer ptr (packet buffer must be big enough)
;	T1/ Error type
;	T2/ String ptr to error text
; Returns +1:  Don't send Error
;	+2:  Error ready to be sent
; Clobbers T1-T4

MAKERR:	LDB T3,PUPTYP		;Get existing Pup Type
	CAIN T3,PT.ERR		;Already of type Error?
	 RET			;Yes, don't give Error for Error
	LDB T3,PPUPDH		;Check destination host
	JUMPE T3,CPOPJ		;Don't respond to broadcast Pups
	MOVSI T3,PBHEAD(PB)	;Make BLT pointer
	HRRI T3,PBCONT(PB)	;Copy header into contents
	BLT T3,PBCONT+<PBCONT-PBHEAD>-1(PB)
	LSH T1,^D20		;Left-justify Error type
	MOVEM T1,PBCONT+<PBCONT-PBHEAD>(PB)  ; Store type, zero arg
	MOVE T1,[POINT 8,PBCONT+<PBCONT-PBHEAD>+1(PB)]
	TLC T2,-1		;String arg lh = -1?
	TLCN T2,-1
	 HRLI T2,(POINT 7)	;Yes, make standard byte ptr
MAKER1:	ILDB T3,T2		;Get byte from string
	JUMPE T3,MAKER2		;Jump if end
	IDPB T3,T1		;Store in Pup
	JRST MAKER1

MAKER2:	MOVE T2,T1		;Word address
	TXO T2,IFIW		;Force refrence to be local
	TXZ T2,<377700,,0>	;Mask out P and S fields
	MOVEI T2,@T2		;Compute address of last word
	SUBI T2,PBHEAD-1(PB)	;Compute # 36-bit words used
	LSH T2,2		;Convert to bytes
	LSH T1,-^D33		;Get bytes not used in last word
	SUBI T2,(T1)		;Compute Pup Length
	ADDI T2,2		;Include checksum
	DPB T2,PUPLEN		;Store it
	MOVEI T1,PT.ERR		;Set Pup Type = Error
	DPB T1,PUPTYP
	SETZ T1,		;Zero Transport Control
	DPB T1,PUPTCB
	CALL SWPPRT		;Swap source and dest ports
	CALL GPTCKS		;Get pointer to Pup Checksum
	SETO T1,		;Store -1 to mean unchecksummed
	DPB T1,T2
	RETSKP			;Return +2


; Swap Source and Destination Ports in Pup
;	PB/ Packet buffer pointer
; Returns +1 always
; Clobbers T1, B

SWPPRT:	MOVE T1,PBHEAD+2(PB)	;Get dest net/host/high socket
	MOVE T2,PBHEAD+3(PB)	;Get dest low socket
	LSH T1,-4		;Concatenate socket
	LSHC T1,-^D16		; and right-justify dest net/host
	EXCH T2,PBHEAD+4(PB)	;Exchange source and dest sockets
	LSH T1,^D20		;Left-justify dest net/host
	LSH T2,-4		;Right-justify source socket
	ROTC T1,-^D16		;Concatenate src low skt to dest net/host
	EXCH T1,PBHEAD+3(PB)	;Exchange for dst low skt, src net/host
	LSH T1,-4		;Right-justify
	LSH T2,^D20		;Left-justify source high socket
	LSHC T1,-^D16		;Concatenate src net/host/high skt
	MOVEM T2,PBHEAD+2(PB)	;Store in header
	RET    

PSIRQF:	NOSKED
	CALL PSIRQ
	OKSKED
	RET

;RS PRSEND,0		;End of Pup resident storage
;NR PNREND,0		;End of Pup nonresident storage

	TNXEND 
	END
