;<134>MONJS.MAC;1208     5-JUN-78 12:03:02    EDIT BY TAFT
; Add OPRFN 'INIFNT' for reinitializing LPT fonts
;<134>MONJS.MAC;1207    21-APR-77 17:02:02    EDIT BY TAFT
; Add PUPBGT
;<134>MONJS.MAC;1206     6-APR-77 10:00:52    EDIT BY TAFT
; Remove test of "GETAB capability"
;<134>MONJS.MAC;1205    10-FEB-77 20:04:17    EDIT BY TAFT
; Add kludge in GETPAT to interpret GETTAB for system type without
; dragging in PA1050.
;<134>MONJS.MAC;1204    18-APR-76 23:12:52    EDIT BY TAFT
; Add "PUPROU" function to OPRFN -- set Pup routing table entry
;<134>MONJS.MAC;1203    18-JAN-76 20:02:08    EDIT BY TAFT
; Restore SYSUN table -- lost during conversion
;<134>MONJS.MAC;1202    11-JAN-76 21:20:18    EDIT BY TAFT
; Put back CAPXR (lost when USRIO deleted)
; Remove ## from error mnemonics
;<134>MONJS.MAC;1201    10-JAN-76 22:41:43    EDIT BY TAFT
; Transplant patches from 1.33 SWPMON.MAC:
; Add BADMM GETAB
; Add PUPBGF OPRFN to turn on/off printing of Pup bugs
; Make GETAB fast
; Add GETABs for Pup
; Add CPUTL jsys
; Add Pup stuff -- NTDINI OPRFN
;   Put in KSTAT GETAB table
; Put in ICTRS GETAB table
; Put in OLGBUF Getab table for opcode logging. (ERF)
; Add GETAB entries for MCA:  MCALSK,MCAFSK,MCASTS,MCATTY,MHOSTN
; Take patch space out of GETAB tables since Micro-exec depends on
;  GTTAB and SYMTAB being contiguous.
; Removed USRIO JSYS (user i/o mode n.i. on Maxc).  (ERF)
; SYMTAB defs for Micro-exec.
; Add SYSUN and NSAREA to GETAB tables for the benefit of Micro-exec.  (ERF)
;<135-TENEX>MONJS.MAC;12    12-DEC-75 11:10:25    EDIT BY PLUMMER
; MAKE EXTERN OF CPUSED BE UNDER IFN PIESLC
; ADD EXTERN ON MSTKOV AFTER SNMJFN
;<135-TENEX>MONJS.MAC;11    10-DEC-75 12:55:58    EDIT BY ROSENBERG
; FIX THE MKPGSA OPRFN TO PERMIT THE PAGE WHOSE PAGE NUMBER IS EQUAL
; TO THE VALUE OF SWPCOR, TO BE MADE AVAILABLE.
;<134-TENEX>MONJS.MAC;9    17-OCT-75 14:40:02    EDIT BY ROSENBERG
; IMPROVE COMMENTS IN GETAB JSYS (AND ADD COMMENTED OUT CODE)
;<134-TENEX>MONJS.MAC;8    17-OCT-75 11:32:18    EDIT BY CLEMENTS
; Remove check of SUBSYS/SYSTEM/HACKS from SETNM. If insist type,
;  it gets set, else it doesn't, regardless of directory.
;<134-TENEX>MONJS.MAC;7    17-SEP-75 13:35:48    EDIT BY PLUMMER
; LH(3) TO HSYS CONTAINS USER NUMBER
;<134-TENEX>MONJS.MAC;6    15-AUG-75 18:48:04    EDIT BY CLEMENTS
; Fix typo in .hsys mod
;<134-TENEX>MONJS.MAC;5    11-AUG-75 17:52:26    EDIT BY CLEMENTS
; HSYS writes 3 words into <system>hsys.times file
;<134-TENEX>MONJS.MAC;4    15-JUL-75 15:55:32    EDIT BY CLEMENTS
; ADD IMPDRQ AND HSTINI TO OPRFN JSYS
; ADD "INSIST" FLAG TO SETNM JSYS. IF LH(1) IS 1, THEN ARG IS IN 2
;  AND IT GOES INTO TABLE IF POSSIBLE. ELSE, IT'S .OTHER .
;<134-TENEX>MONJS.MAC;3    28-APR-75 12:10:57    EDIT BY CLEMENTS
;<134-TENEX>MONJS.MAC;2    24-APR-75 12:39:57    EDIT BY CLEMENTS
;<134-TENEX>MONJS.MAC;2    24-APR-75 12:27:48    EDIT BY CLEMENTS
;<134-TENEX>MONJS.MAC;1    23-APR-75 14:51:32    EDIT BY CLEMENTS
;SPLITTING SWPMON INTO FINITE SIZE PIECES. THIS IS MONJS.MAC

	SEARCH PROLOG
	TITLE MONJS

	SWAPCD

;THIS MODULE CONTAINS JSYS CODE FROM SWPMON FOR MISC
; JSYSES, INFO-OBTAINING JSYSES... ALSO ROUTINES CALLED AT JSYS LEVEL.

INTERNAL	.HSYS,GETPAT,.GJINF,.TIME,.JOBTM,.RUNTM
INTERNAL	.GTRPI,.GTDAL,.SYSGT,.GETAB,.SETNM,.GETNM
INTERNAL	.SWTCH,.LITES,.PEEK,CAPX,WHEELX
INTERNAL	.GET,.SAVE,.SSAVE,.OPRFN

EXTERNAL	BHC,BLOCK1,BUGCHK,BUGHLT,CAPENB,CAPMSK
EXTERNAL	CLFRET,CLRLFK,CVTAD,DBUGSW,DCHKSW
EXTERNAL	DDTFSH,DDTRCL,DRMCFE,DRMFRE,DSKRCE
EXTERNAL	FKDIR,FKHPTN,FORKX,FPTA,HSYST2,HSYST3
EXTERNAL	ITRAP1,JB0FLG,JFNOFN,JOBNAM,JOBONT,JOBPT,JOBRT
EXTERNAL	JOBRTT,LOGDES,MAPDIR,MKPGSA,MKPGSU,MONDSC,MRPACS
EXTERNAL	NDRMEW,NDSKEW,NLGDES,NMNDSC,NNAMES,R,RSKP
EXTERNAL	SBLKTM,SBSNMS,SETJFK,SETLF1,SETLFK,SETMPG
EXTERNAL	SETPT,SKMRTN,SNAMES,SPC1,SPFLTS,SPTC,STIMES
EXTERNAL	SVN,SVNN,SVNUM,SWAKES,SWPCOR,TTFORK
IFN PIESLC,<
EXTERNAL	GRPLOK,NJBGRP,SSHARE,TOTSHR
>
IFDEF IMPCHN,<
EXTERNAL	HSTSTS,IMPHRT,IMPLBT,IMPLT1,IMPLT2,IMPLT3,IMPLT4
EXTERNAL	IMPNLK,IMPRDY,NLHOST
>

EXTERNAL	MENTR,MRETN

;HALT SYSTEM - REQUIRES MAINT (OR WHEEL ETC.) CAPABILITY
; ACCEPTS A GTAD-STYLE DATE AND TIME IN 1, AT WHICH TIME TENEX
;WILL BE SHUT DOWN. JOB 0 NOTIFIES USERS AND DOES THE SHUTDOWN.
; AND ACCEPTS A GTAD TIME IN 2 WHEN SYSTEM IS EXPECTED UP AGAIN
; ACCEPTS 4-BIT CODE FOR REASON FOR DOWNAGE IN 3.
; REQUIRES WHEEL, MAINT, OR OPER CAPABILITY.

.HSYS:	JSYS MENTR		;SET UP AC BLOCK
	MOVE 2,CAPENB		;SEE IF USER ALLOWED TO HALT TENEX.
	HLL 2,0(P)		;OR IF PC SAYS CALLED FROM MONITOR
	TLNE 2,UMODF		;CALL FROM MON SPACE?
	TRNE 2,WHEEL+OPER+MAINT	; OR PRIVILEGED?
	SKIPA			; YES. OK TO DO IT.
	RETERR CAPX1		;NO. RETURN CAPX ERROR
	JUMPG 1,HSYS1		;JUMP UNLESS ABORTING THE SHUTDOWN
	SETZM HSYST1		;ABORTING. KILL FLAGS.
	SETZM HSYST2		; ..
	SETZM HSYST3		; ..
	JRST SKMRTN		;SKIP RETURN TO USER

HSYS1:	PUSH P,1		;HOLD THE DESIRED SHUTDOWN.
	CALL CVTAD		; LINEARIZE
	PUSH P,1
	GTAD			;GET CURRENT TIME AND DATE
	CALL CVTAD		; LINEARIZE
	SUB 1,0(P)		;DIFFERENCE IN TIMES
	SKIPGE 1		; NOW MUST BE BEFORE SHUTDOWN
	SKIPGE 1,[^D<7*24*60*60>]
	RETERR TIMEX1		;YES. GIVE BAD TIME FAILURE
	POP P,HSYST2		; LINEAR TAD OF SHUTDOWN
	POP P,HSYST1		; GTAD OF SHUTDOWN
	UMOVE 1,2		; TIME BACK UP, GTAD FORMAT
	CAMG 1,HSYST1		; LATER THAN SHUTDOWN? (IGNORING SIGN)
	MOVEI 1,0		; NO. ASSUME JUNK - UNKNOWN RETURN
	MOVEM 1,HSYST4		; STORE FOR GETAB, IMPHLT.
	SETZM HSYST3		; NO MSG TYPED YET
	UMOVE 2,3		; GET REASON FOR DOWN TIME
	MOVEM 2,HSYST5		;STORE WHO,,WHY
	AOS JB0FLG		;WAKE JOB 0 TO SEE THIS
HSYS2:	SKIPN JOBNO		;CALLED FROM BACKGROUND?
	JRST HSYS2A		;YES. DON'T NEED TO WRITE FILE.
	PUSH P,CAPENB		;GIVE US WHEEL PRIVILEGES SO CAN
	NOINT			; WRITE ON SYSTEM
	MOVEI A,WHEEL		; ..
	IORM A,CAPENB		; ..
	MOVSI A,400001		;CREATE FILE TO HOLD SHUTDOWN TIME
	HRROI B,[ASCIZ /<SYSTEM>HSYS.TIMES;1/]
	GTJFN			; ..
	  JRST HSYS2F		;FAILED?
	MOVE C,A		;COPY JFN IN CASE FAILS
	MOVE 2,[440000,,100000]	;WRITE AT BEGINNING
	OPENF
	  JRST [MOVE A,C	;GET JFN BACK. FAILED.
		RLJFN
		 JFCL
		JRST HSYS2F]
	MOVE B,HSYST1		;NOW PUT OUT TIME GOING DOWN
	BOUT
	MOVE B,HSYST4		;AND TIME BACK UP
	BOUT			; ..
	MOVE B,HSYST5		;AND REASON
	BOUT
	CLOSF			;CLOSE THE FILE
HSYS2F:	  BUG(CHK,<HSYS - TROUBLE WITH <SYSTEM>HSYS.TIMES FILE>)
	POP P,CAPENB		;RESTORE CORRECT CAPABILITIES
	OKINT
HSYS2A:	JRST SKMRTN		;AND GIVE SUCCESS RETURN TO USER.

EXTERN HSYST1,HSYST4		;GTAD FORMAT, IN SYSTAT GETAB TABLE

;POINTS (IN MINUTES BEFORE SHUTDOWN) AT WHICH TO DO NOTIFICATION

CTIMS::	^D<BYTE (9) 60,30,15,10>
	^D<BYTE (9) 5,1,0>

;GET 10/50 COMPATIBILITY FILE ON FIRST USE OF UUO IN A GIVEN FORK

GETPAT:	JSYS MENTR		;GETS HERE FROM UUO HANDLER
	MOVE 1,40		; Pick up user's call
	TLZ 1,777
	CAME 1,[47000,,41]	; CALLI 41?
	 JRST GETPA1
	LDB 2,[POINT 4,40,12]	; Pick up AC
	UMOVE 1,0(2)
	CAME 1,[112,,11]	; Want system type?
	 JRST GETPA1		; No
	MOVEI 1,30000		; Say a TENEX
	UMOVEM 1,0(2)		; Return to user
	JRST SKMRTN
GETPA1:	PUSH P,ENTVEC		;SAVE CURRENT ENTRY VECTOR
	MOVSI 1,(1B2+1B17)
	HRROI 2,[ASCIZ /<SUBSYS>PA1050.SAV/]
	GTJFN
	ITERR ILINS3		;NO FILE
	HRLI 1,400000		;LOAD IT INTO THIS FORK
	GET
	MOVE 1,ENTVEC		;COMPATIBILITY ENTRY VECTOR
	MOVEM 1,PATADR		;PUT IT IN RESERVED PLACE
	POP P,ENTVEC		;RESTORE REGULAR VECTOR
	UMOVE 2,3(1)		;VIRTUAL 40 FOR PAT
	HRRM 2,PATU40
	UMOVE 2,4(1)		;PC WORD FOR PAT
	HRRM 2,PATUPC
	AOJ 1,			;INITIAL ENTRY IS 1, REGULAR 0
	HRLI 1,UMODF
	EXCH 1,0(P)		;SET NEW PAC, GET OLD ONE
	XCTUU PATUPC
	MOVE 1,40
	XCTUU PATU40
	JRST MRETN		;GO TO COMPATIBILITY

IFN PIESLC,<

;ROUTINE TO ASSIGN DSHARE VALUES. WINDFALL GOES TO LEAST COST-EFFECTIVE GROUP
ASGDSH:: ADD P,BHC+12		;MAKE ROOM FOR 0-12 ON STACK
	JUMPGE P,MSTKOV##			;ERROR IF NO ROOM
	MOVEM 12,0(P)			;SAVE LAST AC
	HRRZI 12,-11(P)			;MAKE UP POINTER FOR BLT
	BLT 12,-1(P)

	NOINT
	LOCK GRPLOK

	MOVSI 6,(1.0)			;INITIALIZE 6 TO ACCUMULATE WINDFALL
	SETZ 12,			;12 USED TO MAINTAIN ACTUAL INDEX
					;TO PIE-SLICE-GROUP.DATA ENTRIES

	HRRZI 7,^D<24*60*60>		;NUMBER OF SECONDS IN A DAY

	MOVSI 5,-NGRPS			;LOOP OVER ALL GROUPS
	SETZ 10,		;INITIALIZE COST-EFFECTIVENESS

ASGDS1:	SKIPN NJBGRP(5)			;ANYBODY USING THIS GROUP?
	 JRST ASGDS2			;NO, GO ON TO NEXT ONE

	MOVE 2,SSHARE(12)		;YES, GET NUMBER OF SHARES
	FDVR 2,TOTSHR			;COMPUTE FRACTION
	MOVEM 2,DSHARE(5)		;AND STASH IN DSHARE

	FSBR 6,2			;MAINTAIN WINDFALL

	SKIPN 3,CPUSED##(12)		;GET CPU TIME FOR THIS GROUP
	 JRST [HRLOI 10,377777		;FAKE SMALL COST EFFECTIVENESS
		JRST ASGDS4]
	ASH 3,-^D8			;MAKE SURE WE DON'T LOSE SIGNIFICANT
					;BITS WHEN WE FSC
	FSC 3,233			;CONVERT TO FLOATING
	GTAD				;GET DATE AND TIME
;	CAMN 1,[-1]			;SHOULD REALLY DO THIS
;	JRST ASGDS3
	JUMPL 1,ASGDS3			;RETURN IF NO DATE
;FALL THRU

;FALLS THRU
	SUB 1,BEGDAT##(12)		;LESS START DATE OF THIS GROUP
	CAIL 7,0(1)			;OVERFLOW IN RH?
	SUB 1,[-1,,^D<24*60*60>]	;YES, ADJUST
	LSH 1,-^D9			;MAKE SURE IT FITS IN 27 BITS
	FSC 1,233			;FLOAT IT
	FMPR 2,1			;COMPUTE 1/COST EFFECTIVENESS
	FDVR 2,3			;WHICH IS =(DSHARE*(NOW-BEGDATE))/CPUSED
	CAML 2,10			;LARGEST YET?
	SKIPA 10,2			;YES, REMEMBER IT
	CAIA
ASGDS4:	MOVEI 11,0(5)			;AND REMEMBER GROUP

ASGDS2:	ADDI 12,NWDGRP			;MAINTAIN ACTUAL INDEX
	AOBJN 5,ASGDS1			;ON TO NEXT GROUP

	FMPR 6,KFACT			;MULTIPLICATIVE FACTOR FOR WINDFALL
	FADRM 6,DSHARE(11)		;GIVE WINDFALL TO NEEDIEST GROUP

ASGDS3:	UNLOCK GRPLOK
	OKINT
	HRLZI 12,-11(P)
	BLT 12,12
	SUB P,BHC+12
	RET

;PIE-SLICE GROUP FILE PARAMETER GETAB TABLE (DO NOT SEPARATE ENTRIES)

GRPDES:	NGRPPG
	NWDGRP
	NGRPS
NGRPD=.-GRPDES

>;END PIE-SLICE SCHEDULER CONDITIONAL

;INFO JSYS'S

.GJINF:	MOVE 3,JOBNO
	HRRZ 1,JOBDIR(3)
	HLRZ 2,JOBDIR(3)
	MOVE 4,CTRLTT
	XCT MJRSTF

.TIME:	MOVE 1,TODCLK		;TIME SINCE SYSTEM STARTED
RTIM:	MOVEI 2,^D1000		;DIVISOR FOR SECONDS
	XCT MJRSTF

.JOBTM:
	MOVE 1,JOBNO
	MOVE 1,JOBRT(1)
	ADD 1,JOBRTT
	XCT MJRSTF

.RUNTM:	JSYS MENTR
	XCTUU [HRRZ 1,1]	;FORK HANDLE
	CAIN 1,-5		;WHOLE JOB?
	JRST RUNTM1		;YES
	CALL SETJFK
	CALL SETLF1
	MOVE 1,FKRT(1)		;FORK RUN TIME FROM PSB
	ADD 1,JOBRTT
	JRST RUNTM2

RUNTM1:	NOINT
	MOVE 1,JOBNO
	MOVE 1,JOBRT(1)
RUNTM2:	MOVE 3,TODCLK		;CURRENT TIME
	SUB 3,CONSTO		;LESS TIME ON, FOR CONSOLE TIME USED
	MOVEI 2,^D1000		;MILLISECONDS
RETA3:	UMOVEM 1,1		;RETURN VALUES IN 1,2,3
	UMOVEM 2,2
	UMOVEM 3,3
	JRST CLFRET

.GTRPI:	JSYS MENTR
	CALL SETLFK
	MOVE 1,UTRPCT
	MOVE 2,USWPCT
	MOVE 3,PTTIM
	JRST RETA3

;GET DIRECTORY ALLOCATION
; TAKES A DIRECTORY NUMBER IN 1. 0 MEANS CURRENT CONNECTED DIR
; RETURNS ALLOCATION IN 1, USED IN 2. IF NO SUCH DIRECTORY,
; RETURNS 0 IN 1 AND 2
;
.GTDAL:	JSYS MENTR
	JUMPLE 1,GTDAL1
	PUSHJ P,HSHLUK##	; DIR SUPPLIED. SEE IF IT EXISTS
	  JRST GTDAL3		; NOPE.
	PUSHJ P,USTDIR##	; YES. UNLOCK IT.
	JRST GTDAL2		; AND USE THAT DIRECTORY NUMBER

GTDAL1:	MOVE 1,FORKX
	SKIPGE 1,FKDIR(1)
	MOVE 1,FKDIR(1)		;1=CONN DIR,,USER DIR
	HLRZS 1
GTDAL2:	SETO 2,
	CALL MAPDIR
	HLRZ 1,DIRDSK		; GET MAXIMUM ALLOCATION
	UMOVEM 1,1
	HRRZ 1,DIRDSK		;CURRENT IN-USE COUNT
				;(DOESN'T INCLUDE PAGES CREATED FOR
				; FILES WHICH ARE STILL OPEN)
	UMOVEM 1,2
	JRST MRETN

GTDAL3:	PUSHJ P,USTDIR##	; UNLOCK DIRECTORY
	MOVEI 1,0		; RETURN 0 AS ANSWER FOR USED AND ALLOC
	UMOVEM 1,2
	UMOVEM 1,1
	JRST MRETN

IFN PIESLC,<

; Get CPU utilization (2.5 minute exponentially decaying fraction)
; Accepts in 1:  Fork handle or job number
; Returns +1 always
;	2: Sum of cpu utilization for all referenced forks
;	   (floating point fraction in range 0 to 1)
;	3, 4:  Reserved for future use in returning other information

.CPUTL::JSYS MENTR
	XCTUU [HRRZ 1,1]	; Get arg
	SETZ 4,			; Init answer to zero
	CAIL 1,0		; Given job number?
	CAIL 1,NJOBS
	 JRST CPUTL2		; No, fork handle
	SKIPGE JOBRT##(1)	; Yes, job exist?
	 JRST CPUTL3		; No, return zero
	MOVSI 2,-NFKS		; Yes, search fork tables for that job
CPUTL1:	SKIPL 3,FKPT##(2)	; Fork deleted?
	TLNN 3,-1		; Never assigned?
	 JRST CPUTL4		; Yes, ignore
	HLRZ 3,FKJOB##(2)	; Get job number
	CAIN 3,(1)		; The requested one?
	 FADR 4,FKUTIL##(2)	; Yes, accumulate utilization fraction
CPUTL4:	AOBJN 2,CPUTL1		; Loop for all forks
	JRST CPUTL3		; Return result

; Here if not a job number -- assume fork handle
CPUTL2:	PUSHJ P,MAPFKH##	; Map handle over all referenced forks
	 PUSHJ P,[MOVE 2,SYSFK(1)  ; Translate job to system fork handle
		FADR 4,FKUTIL##(2)  ; Accumulate utilization fraction
		POPJ P,]

; Here to return answer in 4 to user ac2
CPUTL3:	UMOVEM 4,2
	JRST MRETN
> ; End IFN PIESLC


;GET NUMBER OF TABLE AND FIRST WORD GIVEN SIXBIT SYMBOL

.SYSGT:	JSYS MENTR
	MOVSI 4,-GTBSIZ
	CAMN 1,SYMTAB(4)
	JRST SYSGT1
	AOBJN 4,.-2
	XCTUU [SETZM 2]		;NOT FOUND RETURN 0
	JRST MRETN

SYSGT1:	HLRZ 2,GTTAB(4)		;SIZE
	MOVN 2,2		;NEGATE IT
	HRLI 4,0(2)		;COMBINE WITH TABLE NUMBER
	UMOVEM 4,2		;GIVE TO USER
	HRRZ 1,GTTAB(4)		;ADDRESS OF FIRST WORD

;TEMPORARILY PROVIDE AN EXTRA LEVEL OF ADDRESSING FOR SYSSTAT
;TABLE WHICH WILL GO AWAY SOON.
	MOVEI 4,0(4)		;CLEAR LEFT HALF
	CAIN 4,SYSSTN		;IS THIS THE SYSSTAT TABLE?
	MOVE 1,0(1)		;YES

	MOVE 1,0(1)
	UMOVEM 1,1		;GIVE FIRST WORD TO USER
	JRST MRETN


; Get word from table given table number in rh 1 and index in lh 1.
; Return negative of table length in 1 if index is negative.
; Return +1 if error, +2 if success

.GETAB:	MOVEM 2,XMENTR		; Save an ac in protected temp
REPEAT 0,<  ; This doesn't seem very useful
	MOVSI 2,(1B1)		; GETAB capability exist for fork?
	TDNN 2,CAPMSK
	 JRST [	MOVEI 1,GTABX3	; No, return error
		JRST GETAB3]
>
	HRRZ 2,1		; Yes, copy table number
	CAIL 2,GTBSIZ		; Within bounds?
	 JRST [	MOVEI 1,GTABX1	; No, return error
		JRST GETAB3]
	JUMPL 1,[HLRZ 1,GTTAB(1)  ; If negative index, get table length
		MOVNS 1		; Negate it
		JRST GETAB1]	; Return it
	HLLO 1,1		; Set rh to max so compare works
	CAML 1,GTTAB(2)		; Index in bounds?
	 JRST [	MOVEI 1,GTABX2	; No, return error
		JRST GETAB3]
	HLRZ 1,1		; Yes, put index in rh
	ADD 1,GTTAB(2)		; Compute address of word
	CAIN 2,SYSSTN		; Is this the "SYSTAT" table?
	 MOVE 1,0(1)		; Yes, indirect another level
	MOVE 1,0(1)		; Get the data word
GETAB1:	MOVE 2,FPC		; Get return pc
	HRRI 2,1(2)		; Increment it without carry into lh
	MOVEM 2,FPC		; Put it back
GETAB2:	MOVE 2,XMENTR		; Restore saved ac
	XCT MJRSTF		; Return to user

; Here if error
GETAB3:	MOVEM 1,LSTERR##	; Save last error
	JRST GETAB2		; Take non-skip return

;TABLE OF TABLES

	EXTERN NDEV,DEVNAM,DEVCHR,DEVUNT,JOBDIR
	EXTERN TOTRC,MAXQ,QSUM,NTASKT,SOLD,NLOADT,RJTSUM,NEVENT,DRMRD

GTTAB:	XWD NJOBS,JOBPT		;CONTROL TTY,,TOP FORK
	XWD NJOBS,JOBRT		;JOB RUN TIME
	XWD 1,[^D1000]		;DIVISOR FOR SECONDS
	XWD NJOBS,JOBDIR	;DIRECTORY BEING USED
	XWD NLINES,TTFORK
	XWD 1,TOTRC
	XWD NDEV,DEVNAM
	XWD NDEV,DEVCHR
	XWD NDEV,DEVUNT
	XWD NDSKEW,DSKRCE
	XWD NDRMEW,DRMCFE
	XWD SVNN,SVN
	XWD 1,SVNUM
	XWD 3,UTRPCT
SYSSTN==.-GTTAB
	XWD NSTAT,SYSST
	XWD MAXQ+1,QSUM
	XWD NJOBS,JOBNAM
	XWD NNAMES,SNAMES
	XWD NNAMES,STIMES
	XWD NNAMES,SPFLTS
	XWD NNAMES,SWAKES
	XWD NNAMES,SBLKTM
	XWD 2,DBUGSW		;DBUGSW AND DCHKSW
	XWD NLGDES,LOGDES
	XWD GTBSIZ,SYMTAB	;THE 6BIT SYMBOLS
	XWD GTBSIZ,GTTAB	;AND THE POINTERS
	XWD 1,ENTFLG		;ENTRY ALLOWED IF NON-ZERO
	XWD 1,DRMFRE		;TEMP TILL MOUNTABLE PACKS/NEW SWAPPER
	XWD NTASKT,SOLD
	XWD NLOADT,RJTSUM
	XWD NEVENT,DRMRD
	XWD 2,LGNPAR##		;LOGIN FAILURE CODE IF SYSTEM FULL
				; AND LAST LOGIN DATE.
	XWD 23,SYSUN##		; Disk configuration stuff (for Micro-exec)
	XWD 1,NSAREA##		; Number of save areas
	XWD NDSKPR##,DSKPAR##	; DSK PARAMETERS
	XWD 1,FDFMTF##		; DIRECTORY FORMAT FLAG
	XWD NJOBS,JOBONT	;JOB OWNERSHIP TABLE
	XWD NJOBS,JOBNM2	;REAL JOB NAME EVEN IF ".OTHER"
;MORE

;MORE OF ABOVE
IFDEF IMPCHN,<		;NETWORK RELATED TABLES
	EXTERN NHOSTS,HOSTN,LSKT,FSKT,NETAWD,NETBAL,NETSTS,NETBUF
	EXTERN NHSTN,HSTNAM,NETBTC,IMPGTN
	XWD IMPGTN,IMPRDY
	XWD IMPLBT,IMPHRT
	XWD 200,HSTSTS
GTBNHN::XWD NHSTN,HSTNAM
GTBHST::XWD NHOSTS,HOSTN
	XWD NSKT,LSKT
	XWD NSKT,FSKT
	XWD NSKT,NETAWD
	XWD NSKT,NETBAL
	XWD NSKT,NETSTS
	XWD NSKT,NETBUF
	XWD NSKT,NETBTC
	XWD IMPNLK,IMPLT1
	XWD IMPNLK,IMPLT2
	XWD IMPNLK,IMPLT3
	XWD IMPNLK,IMPLT4
	XWD 2,NLHOST		;HOST NUMBER, NVT COUNTER
>

IFN PIESLC,<
	XWD NGRPS,NAPROC##
	XWD NGRPS,DSHARE##
	XWD NJOBS,PIEGRP##
	XWD NGRPS,NJBGRP
	XWD NGRPD,GRPDES
> ; END PIE-SLICE SCHEDULER CONDITIONAL

	XWD NMNDSC,MONDSC

IFDEF MCACHN,<	; MCA related tables
	XWD NMSKT,MLSKT##
	XWD NMSKT,MFSKT##
	XWD NMSKT,MCASTS##
	XWD NXNVT,MCATTY##
	XWD NXNN##,XNETN##
	XWD NXNNM##,XNETNM##
	XWD 2,MLHST##
>
IFDEF PUPCHN,<	; Pup-related tables
	XWD NPUPPR##,PUPPAR##	; Pup parameter table
	XWD NPNETS,PUPROU##	; Host number and routing table
	XWD NPUPUN,PUPLSK##	; Local socket numbers,
	XWD NPUPUN,PUPLNH##	; Local net/host numbers, BSP linkage
	XWD NPUPUN,PUPFPT##	; Foreign ports
	XWD NPUPUN,PUPSTS##	; Pup status word
	XWD NPUPBF*1000,PUPBUF## ; Storage region for Pup data
	XWD NPUPST##,PUPSTA##	; Statistcs
	XWD LENPBT##,PUPBGT##	; Pup bug count hash table
IFN NPUPLN,<
	XWD NPUPLN,NVTPUP##	; Pup NVT data
>> ; End IFDEF PUPCHN
	XWD 1000,LGBUF
	XWD NICTRS##,JBICTR##
	XWD NDSKW##,DIRWRT##
	XWD ^D<<MAXCOR+35>/36>,BADMM##  ; Bad memory bit map
GTBSIZ==.-GTTAB
MGTBSZ==:-GTBSIZ
; Micro-exec depends on GTTAB and SYMTAB being contiguous and in this order.

;SYMBOL TABLE PARALLEL TO ABOVE

SYMTAB::SIXBIT /JOBTTY/
	SIXBIT /JOBRT/
	SIXBIT /TICKPS/
	SIXBIT /JOBDIR/
	SIXBIT /TTYJOB/
	SIXBIT /NCPGS/
	SIXBIT /DEVNAM/
	SIXBIT /DEVCHR/
	SIXBIT /DEVUNT/
	SIXBIT /DSKERR/
	SIXBIT /DRMERR/
	SIXBIT /SYSVER/
	SIXBIT /VERNUM/
	SIXBIT /PGSTAT/
	SIXBIT /SYSTAT/
	SIXBIT /QTIMES/
	SIXBIT /JOBNAM/
	SIXBIT /SNAMES/
	SIXBIT /STIMES/
	SIXBIT /SPFLTS/
	SIXBIT /SWAKES/
	SIXBIT /SBLKTM/
	SIXBIT /DBUGSW/
	SIXBIT /LOGDES/
	SIXBIT /SYMTAB/
	SIXBIT /GETTAB/
	SIXBIT /ENTFLG/
	SIXBIT /DRMFRE/
	SIXBIT /TASKTB/
	SIXBIT /LOADTB/
	SIXBIT /EVENTS/
	SIXBIT /LGNPAR/
	SIXBIT /SYSUN/
	SIXBIT /NAREAS/
	SIXBIT /DSKPAR/
	SIXBIT /FDFMTF/
	SIXBIT /JOBONT/
	SIXBIT /JOBNM2/
;MORE

;MORE OF ABOVE
IFDEF IMPCHN,<
	SIXBIT /NETRDY/
	SIXBIT /IMPHRT/
	SIXBIT /HSTSTS/
	SIXBIT /HSTNAM/
	SIXBIT /HOSTN/
	SIXBIT /NETLSK/
	SIXBIT /NETFSK/
	SIXBIT /NETAWD/
	SIXBIT /NETBAL/
	SIXBIT /NETSTS/
	SIXBIT /NETBUF/
	SIXBIT /NETBTC/
	SIXBIT /IMPLT1/
	SIXBIT /IMPLT2/
	SIXBIT /IMPLT3/
	SIXBIT /IMPLT4/
	SIXBIT /LHOSTN/
>

IFN PIESLC,<
	SIXBIT /NAPROC/
	SIXBIT /DSHARE/
	SIXBIT /PIEGRP/
	SIXBIT /NJBGRP/
	SIXBIT /GRPDES/

> ; END PIE-SLICE SCHEDULER CONDITIONAL

	SIXBIT /MONDSC/


IFDEF MCACHN,<
	SIXBIT /MCALSK/
	SIXBIT /MCAFSK/
	SIXBIT /MCASTS/
	SIXBIT /MCATTY/
	SIXBIT /MHSTN/
	SIXBIT /MHSTNM/
	SIXBIT /MHOSTN/
>
IFDEF PUPCHN,<
	SIXBIT /PUPPAR/
	SIXBIT /PUPROU/
	SIXBIT /PUPLSK/
	SIXBIT /PUPLNH/
	SIXBIT /PUPFPT/
	SIXBIT /PUPSTS/
	SIXBIT /PUPBUF/
	SIXBIT /PUPSTA/
	SIXBIT /PUPBGT/
IFN NPUPLN,<
	SIXBIT /NVTPUP/
>>
	SIXBIT /OLGBUF/
	SIXBIT /ICTRS/
	SIXBIT /KSTAT/
	SIXBIT /BADMM/
IFN GTBSIZ-<.-SYMTAB>,<	PRINTX  GETAB SYMBOL TABLE INCORRECT
>


;TEMPORARY SYSTAT TABLE CONTAINING ADDRESSES OF DATA WHICH
;USED TO BE FOUND IN PREVIOUS SYSTAT TABLE
SYSST:	IDLE##
	SWAPWT##
	GCCR##
	PTRAP##
	DRMRD
	DRMWR##
	DSKRD##
	DSKWR##
	WAKEUP##
	TTINTS##
	BSTSUM##
	RJTSUM##
	RJAV##
	RJAV+1
	RJAV+2
	[0]
	[0]
	NTTYIN##
	NTTYOT##
	GCCR+1
	PPG##
	NREMJ##
	[0]
	HSYST1##
	HSYST4##
	HSYST5##
NSTAT==.-SYSST


;SUBSYSTEM STATISTICS LOGIC

GS SNMPT,1			;NEG COUNT OF ENTRIES IN SNAMES
GS SNMLCK,1			;LOCK FOR SNAMES TABLE

.SETNM:	JSYS MENTR
	PUSH P,ZERO##		;ASSUME NOT THE "INSIST" CASE
	TLNE A,-2		;WHICH CASE IS IT?
	JRST SNM2		;ORDINARY SIXBIT
	TLZN A,(1B17)		;INSIST FLAG ON?
	JRST SNMJFN		;NO, JFN BUT NOT INSIST.
	UMOVE A,2		;INSIST. AC2 HAS SIXBIT OR JFN
	SETOM 0(P)		;SET THE "INSIST" FLAG ON STACK
	TLNN A,-2		;SIXBIT OR JFN?
	JRST SNMJFN		;JFN IN AC A
SNM2:	NOINT			;SIXBIT IN A, INSIST FLAG AT 0(P)
	AOSE SNMLCK		;LOCK TABLE
	JSYS BLOCK1		;OR WAIT TILL LOCKABLE
	HRLZ 3,SNMPT		;NEG COUNT OF ENTRIES
	CAMN 1,SNAMES(3)	;DESIRED NAME?
	JRST SNM1		;YES
	AOBJN 3,.-2		;NO, LOOKED AT ALL?
	MOVEI 3,0(3)
	MOVE 2,1		;COPY SUPPLIED NAME. WILL IT FIT?
	SKIPE 0(P)		;INSIST FLAG OFF, OR FULL TABLE?
	CAIL 3,NNAMES-1		; ..
	SKIPA 2,[SIXBIT /.OTHER/] ;YES, USE CATCH-ALL NAME
	SOSA SNMPT		;UPDATE POINTER
	MOVEI 3,NNAMES-1	;PUT .OTHER AT THE END
	MOVEM 2,SNAMES(3)	;ADD NAME TO TABLE
SNM1:	MOVE 2,JOBNO
	MOVEM 1,JOBNM2##(2)	;SAVE REAL NAME EVEN IF .OTHER
	HRRM 3,JOBNAM(2)	;PUT INDEX IN JOB TABLE
	SETOM SNMLCK		;UNLOCK TABLE
	OKINT
	POP P,(P)		;DISCARD THE "INSIST" FLAG
	JRST MRETN

SNMJFN:	HRRZ D,A		;SAVE THE JFN IN D
	GTSTS			;IS IT GOOD?
	TLNN B,(1B10)		; ..
	JRST SNMPRV		;NO, JUNK. SET TO PRIV.
	HRROI A,1(P)		;SPACE FOR DIRECTORY NAME
	ADD P,BHC+10		; ..
	JUMPGE P,MSTKOV##
SNMJF1:	HRROI 1,-7(P)		;NOW GET THE NAME FIELD
	HRRZ B,D		;GET THE JFN AGAIN
	MOVSI C,001000		;NAME FIELD
	JFNS
	MOVEI A,-10(P)		;WORD BEFORE NAME
	HRLOI B,003777		;TRUNCATE TO 6 CHARS
	ANDCAM B,2(A)		; ..
	PUSHJ P,ASCSIX##
	  JRST SNMPR1		;FAILED?
	SUB P,BHC+10		;RESTORE STACK
	JRST SNM2		;STORE SIXBIT NOW IN A
SNMPR1:	SUB P,BHC+10		;RESTORE STACK
SNMPRV:	MOVE A,SBSNMS+1		;GET SIXBIT FOR (PRIV)
	JRST SNM2		;AND GO SET IT.

.GETNM:	MOVE 1,JOBNO
	MOVE 1,JOBNM2(1)
	XCT MJRSTF

.SWTCH:
	DATAI APR,1
	XCT MJRSTF

.LITES:	JSYS MENTR
	MOVE 2,CAPENB
	TRNN 2,WHEEL+OPER+MAINT	;REQUIRES STATUS
	JRST WHEELX
	DATAO PI,1		;DISPLAY
	JRST MRETN

;PEEK - AC1:  N,,MONLOC
;       AC2:     USRLOC

.PEEK:	JSYS MENTR
	MOVEI 3,WHEEL+OPER+MAINT
	TDNN 3,CAPMSK		;HAS NECESSARY CAPS?
CAPX:	ITERR CAPX1		;NO.
	MOVSI 5,0(1)		;SETUP BLT ARGS - FROM
	HRRI 5,0(2)		; .. TO
	MOVEI 6,0(2)
	HLRZ 3,1		;COUNT
	ADDI 6,-1(3)		; .. TO LIMIT
	ADDI 3,-1(1)		;FROM LIMIT
	XORI 3,0(1)		;SEE IF BLOCK CROSSES PAGE BOUNDARY
	TRNE 3,777000
	RETERR PEEKX1		;CAN'T CROSS PAGE BOUNDARY
	MOVEI 1,0(1)
	MRPAC			;GET ACCESS OF PAGE
	TLNN 2,READB		;READ ALLOWED?
	RETERR PEEKX2		;NO
	XCTMU [BLT 5,0(6)]	;TRANSFER WORD(S)
	AOS 0(P)
	JRST MRETN

;ERROR - WHEEL OR OPER REQUIRED BUT NOT ENABLED

WHEELX:	ITERR WHELX1

;GET AND SAVE ROUTINES

;AC USAGE IN GET ROUTINE:
; 4 - PAGE NUMBER IN USER SPACE CURRENTLY MAPPED TO FTPG1
; 5 - POINTER TO ADDRESS IN FTPG1 CORRESPONDING TO AC 6
; 6 - AOBJN (NOT IOWD) POINTER TO USER SPACE WHERE CURRENTLY READING
;14 - SETPT ARGUMENT FOR FTPG1
;15 - FORK HANDLE BEING GET'ED INTO
;16 - JFN BEING READ FROM

.GET:	JSYS MENTR
	CALL GTSVI		;CHECK PARAMETERS, ETC.
	HRRI 2,1B19		;READ BIT
	TLNN 3,777		;DISK?
	HRRI 2,5B21+1B25	;YES, REQUEST RD,XCT ACCESS AND THAWED
	PUSH P,2		;SAVE THE DESIRED OPENING BITS
	GTSTS			;SEE IF THE FILE IS OPEN ALREADY
	TLNN 2,(1B0)		; ..
	JRST GET2A		;NO. GO OPEN IT.
	TLNE 3,777		;IT'S OPEN. IS IT A DISK?
	JRST GET2B		;NO. ASSUME HE OPENED IT RIGHT
	TLC 2,(1B0+1B1+1B3)	;SEE IF RD & XCT BOTH ON
	TLNE 2,(1B0+1B1+1B3)	; ..
	JRST GETE2		;NO.
GET2B:	RFBSZ			;AND CORRECT BYTE SIZE?
	CAIE 2,44		; ..
	JRST GETE2		;NO
	POP P,2			;OK. CLEAR STACK
	JRST GET2C		;AND GO READ THE OPEN FILE.

GET2A:	POP P,2			;RETRIEVE OPENING MODE BITS
	OPENF			;OPEN FILE FOR INPUT
	JRST ITRAP1		;WON'T OPEN
GET2C:	MOVEI 1,FTPG1A
	CALL FPTA		;GET HANDLE OF TEMP PAGE FOR LATER
	MOVE 14,1
;FALL THRU

;FALLS THRU
GET2:	TSTINT			;INTERRUPT PENDING?
	CALL GETINT		;YES, GO ALLOW IT
	MOVEI 1,0(16)		;JFN
	BIN			;GET IOWD COUNT,ADR
	JUMPE 2,[GTSTS		;ZERO. PROBABLY EOF.
		TLNE 2,(1B8)	;IS IT?
		JRST GETE1	;YES. TRUNCATED FILE.
		MOVEI 2,0	;NO, A ZERO ENTRY VECTOR.
		JRST .+1]	;HANDLE IT
	MOVE 6,2
	HLRZ 2,2
	CAIL 2,1000		;LEFT HALF IMPLYING SSAVE?
	CAIL 2,10000
	JRST .+2		; NO
	JRST SGET		; YES.
	JUMPGE 6,GET1		;POSITIVE MEANS END
	ADDI 6,1		; CHANGE IOWD TO AOBJN POINTER
GET5:	CALL GET3		;SET MAP FOR THIS PAGE, SET AC 5
	MOVEI 2,0(6)		;ADDRESS IN USER SPACE
	ORCMI 2,777		;MINUS NUMBER OF WORDS IN THAT PAGE
	HLRE 3,6		;LENGTH OF THE IOWD
	CAMLE 2,3		;WILL IT FIT IN THE WINDOW PAGE?
	MOVE 3,2		;NO. JUST READ WHAT WILL FIT
	MOVM 2,3		;POSITIVE FOR UPDATING POINTERS
	HRL 2,2			;IN BOTH HALVES. THIS IS +N,,+N
	ADD 6,2			;UPDATE THE AOBJN WORD. MAY OR MAY NOT GO +
	MOVE 2,5		;ADDRESS IN WINDOW PAGE
	HRLI 2,444400		;BYTE POINTER TO IT.
	SUB 5,3			;3 IS ALREADY -N FOR SIN. COUNT WINDOW ADDR.
	SIN			;NOW READ INTO THE WINDOW
	JUMPL 6,GET5		;JUMP IF POINTER CROSSED PAGE BOUNDARY
	JRST GET2		;DONE THIS POINTER. READ NEXT ONE.

GET1:	MOVEI 1,0(15)		;FORK HANDLE
	CALL SETLFK		;MAP PSB
	MOVEM 6,ENTVEC(1)	;STORE ENTRY VECTOR DATA
	MOVEI 1,0(16)		;JFN
	JRST SAVER

SGET:	CAIE 2,1000		;CORRECT TYPE NUMBER?
	JRST GETE1		;NO, STRANGE FILE
	MOVEI 13,0(6)		;SAVE COUNT
	MOVE 1,16
	DVCHR
	TLNE 2,777		;DISK FILE?
SSAVE1:	ITERR SSAVX1		;NO, CAN'T DO IT
SGET1:	MOVE 1,SPTC		;SPT USE COUNT
	CAML 1,SPC1		;RUNNING LOW?
	ITERR GETX2		;YES, BOMB OUT
	MOVE 1,16
	BIN
	MOVEI 1,0(2)		;FILE PAGE NUMBER
	LDB 3,[POINT 9,2,8]	;ACCESS
	LDB 2,[POINT 9,2,17]	;MEMORY PAGE
	ROT 3,-^D9
	TLZE 3,(1B0)		;WRITE COPY REQUEST?
	TLO 3,COPYB		;YES, SET APPROPRIATE BITS
	HRLI 1,0(16)
	HRLI 2,0(15)
	PMAP			;MAP FILE PAGE INTO FORK
	SOJG 13,SGET1
	JRST GET2

GETINT:	SETZ 1,
	MOVEI 2,FTPG1A		;UNMAP STUFF
	CALL SETMPG
	CALL CLRLFK		;THIS DOES OKINT, INTERRUPT HAPPENS HERE
	MOVEI 1,0(15)
	CALL SETLFK		;REESTABLISH STATE
	SETO 4,
	RET

GTSVI:	MOVEI 16,0(1)		;JFN
	HLRZ 15,1		;FORK HANDLE
	MOVEI 1,0(16)		;JFN
	DVCHR			;GET DEVICE CHARACTERISTICS
				;DO THIS FIRST IN CASE OF ITRAP
	HLRZ 3,2		;SEE WHAT KIND OF DEVICE. PREVENT
	ANDI 3,777		; TTY'S, CAUSE FORK HANDLES ARE OFTEN
	CAIN 3,12		; MISPLACED INTO JFN AND LOOK LIKE TTY.
	ITERR (DESX4)		; THEN JOB HANGS NOINT ON TTY BIN
	PUSH P,2
	MOVEI 1,0(15)
	CALL SETLFK		;MAKE SURE FORK IS LEGAL
	MOVEI 1,0(16)		;JFN
	POP P,3			;DEVICE BITS
	MOVSI 2,^D36B23		;BYTE SIZE FOR BIN/BOUT XFER
	SETO 4,
	RET

;CHECK AND REMAP PAGE - 4/ CURRENT PAGE (-1 FIRST TIME)
; SET FTPG1 TO POINT INDIRECT TO USER PAGE ADDRESSED BY AC6

GET3:	TSTINT
	CALL GETINT
	LDB 2,[POINT 9,6,26]	;PAGE NUMBER NEXT REFERENCE
	CAIN 2,0(4)		;SAME AS CURRENT
	JRST GET3A		;YES
	MOVEI 4,0(2)		;REMEMBER IS CURRENT
	HRLI 2,0(15)		;FORK HANDLE
	MOVE 1,2
	CALL FKHPTN		;CONVERT TO INTERNAL FORM
	MOVE 2,14
	MOVSI 3,RWX
	CALL SETPT		;SETUP INDIRECT POINTER TO PAGE
GET3A:	MOVEI 5,0(6)		;SETUP ADDRESS FOR MON REFERENCES
	ANDI 5,777
	ADDI 5,FTPG1A
	MOVEI 1,0(16)		;RESTORE JFN TO 1
	RET

GETE2:	MOVEI 1,GETX3		;FILE NOT PROPERLY OPENED
	JRST GETE0		;RETURN THIS ERROR CODE
GETE1:	MOVEI 1,GETX1		;RETURN ERROR CODE
GETE0:	PUSH P,1		;SAVE THE ERROR CODE
	MOVEI 1,0(16)
	CLOSF
	JFCL
	SETZ 1,
	MOVEI 2,FTPG1A
	CALL SETMPG
	CALL CLRLFK
	POP P,1
	JRST ITRAP1		;RETURN ERROR CODE WITH ITRAP

;SAVE, GIVEN LIST OF BLOCK DESCRIPTORS OR ONE BLOCK DESCRIPTOR
;
; AC USAGE IN THIS ROUTINE --
; 16/ JFN BEING SAVED ONTO
; 15/ FORK HANDLE BEING SAVED FROM
; 10/ USER'S AC2 -- A SINGLE +N,,ADDR OR A
;     POINTER TO A LIST OF THEM, COUNTED AS THEY ARE PROCESSED.
;  7/ CURRENT +N,,ADDR FROM USER TABLE. MADE -N,,ADDR AT SAVEB
;  6/ -N,,ADDR FOR A GROUP OF NON-ZERO WORDS, OR WORDS UP TO PAGE END
;  5/ POINTER TO WINDOW PAGE (FTPG1), OFFSET VERSION OF RH OF 6

.SAVE:	JSYS MENTR
	MOVE 10,2		;SAVE DESCRIPTOR
	CALL GTSVI
	HRRI 2,1B20		;WRITE FILE
	OPENF
	JRST ITRAP1
	MOVEI 2,31
	MOVEI 3,2
	MTOPR			; SET BLOCK SPACING TO 2 IF DTA
	TLNE 10,-1		;SOMETHING IN LH?
	JRST SAVE3		;YES, IT'S ONE DESCRIPTOR
SAVE2:	UMOVE 7,0(10)		;GET NEXT DESCRIPTOR
	JUMPE 7,SAVE1		;CHECK FOR END OF LIST OF DESCRIPTORS
	CALL SAVEB		;WRITE BLOCK
	AOJA 10,SAVE2

SAVE3:	MOVE 7,10
	CALL SAVEB
SAVE1:	MOVEI 1,0(15)		;FORK HANDLE
	CALL SETLFK
	MOVE 2,ENTVEC(1)	;GET ENTRY VECTOR POINTER
	MOVEI 1,0(16)		;JFN
	BOUT			;WRITE ENTRY VECTOR POINTER
SAVER:	CLOSF
	JFCL
	SETZ 1,
	MOVEI 2,FTPG1A		;CLEAR TEMP MAPPINGS
	CALL SETMPG
	JRST CLFRET

;SAVE, PROCESS ONE BLOCK
; ARGUMENT IS +N,,ADDR IN 7 . SEE AC USAGE COMMENT ABOVE

SAVEB:	HLRZ 6,7		;MAKE LH COUNT NEGATIVE
	TRZE 6,400000		;LARGER THAN 377777?
	PUSH P,[SAVEBL]		;YES, DO IN TWO PARTS
	MOVNI 6,0(6)
	HRLI 7,0(6)
SAVEB1:	TSTINT
	CALL GETINT
	JUMPGE 7,R		;DONE?
	MOVE 6,7		;SETUP TO SCAN FOR NON-0'S
	LDB 1,[POINT 9,6,26]	;GET PAGE NUMBER
	CAIN 1,0(4)		;DIFFERENT FOR CURRENT MAPPING?
	JRST SAVE3A		;NO, SAME
	MOVEI 4,0(1)
	HRLI 1,0(15)		;FORK HANDLE
	CALL FKHPTN
	PUSH P,1
	CALL MRPACS		;SEE IF PAGE EXISTS
	POP P,2
	TLNN 1,READB		;CAN IT BE READ?
	JRST SAVE3B		;NO, FORGET IT
	MOVE 1,2
	MOVE 2,[XWD RWX,FTPG1A]
	CALL SETMPG		;MAP PAGE
SAVE3A:	CALL GET3A		;SETUP REFERENCE ADDRESS
	JRST SAVE8

SAVE3B:	ANDI 6,777000
	ADDI 6,1000		;TO NEXT PAGE
	SUBI 6,0(7)
	HRLI 6,0(6)		;COUNT OF WORDS SKIPPED IN BOTH HALVES
	ADD 7,6			;UPDATE COUNT AND ADDRESS
	JRST SAVEB1

SAVEBL:	HRLI 7,400000		;DID N-400000 BEFORE, DO LAST 400000 NOW
	JRST SAVEB1

SAVE12:	TRNN 6,777		;NEW PAGE?
	JRST SAVE5		;YES
SAVE8:	SKIPN 0(5)		;NON-0 WORD?
	JRST SAVE6		;NO, GO CHECK FOR MORE
SAVE7:	ADDI 5,1
	AOBJN 6,SAVE12
	MOVE 6,7		;END OF BLOCK. 6/ -N,,ADDR

;WRITE ALL OR PART OF ONE PAGE. ARGS ARE -N,,ADDR IN 6 AND
; OFFSET ADDR IN 5. ALSO -N',,ADDR IN 7.
;VALUES ARE UPDATED 5 AND 7


SAVED:	HLRE 2,6		;COUNT OF WORDS JUST SCANNED
	ADD 5,2			;RESET WINDOW POINTER
	MOVEI 1,0(16)		;JFN
	MOVE 2,6
	SUBI 2,1		;OUTPUT IOWD CNT,ADR
	BOUT
	MOVEI 2,(5)		;FORM BYTE POINTER TO WINDOW
	HRLI 2,444400		; FOR 36 BIT SOUT
	HLRO 3,6		;NEGATIVE COUNT
	SOUT			;OUTPUT THIS BLOCK OF DATA
	HLRO 6,6		;NOW UPDATE THE POINTERS. - NUM WDS SENT
	MOVM 6,6		;POSITIVE NUMBER OF WORDS SENT
	ADDI 5,(6)		;UPDATE POINTER TO WINDOW
	HRLI 6,(6)		;PLUS N IN BOTH HALVES
	ADD 7,6			;UPDATE MAJOR AOBJN CTR. MAY BE SOME LEFT
	RET

;FOUND 0 WORD, CHECK FOR MORE

SAVE6:	MOVEI 2,0(6)
	CAIN 2,0(7)		;FIRST WORD OF BLOCK OR PAGE?
	JRST SAVE9		;YES
	HLRZ 2,6
	SETCMI 3,0(6)
	CAIE 2,-1		;END OF BLOCK, OR
	TRNN 3,777		;END OF PAGE?
	JRST SAVE5		;YES, FINISH BLOCK
	SKIPE 1(5)		;SUCCESSIVE 0?
	JRST SAVE7		;NO, CONTINUE SCAN
SAVE5:	MOVNI 6,0(6)		;COMPUTE NUMBER OF WORD TO DUMP
	ADDI 6,0(7)		;(-CURRENT)+OLD = -DIFFERENCE
	MOVSI 6,0(6)
	HRRI 6,0(7)		;FIRST ADDRESS
	CALL SAVED		;WRITE BLOCK
	JRST SAVEB1

;SCAN OVER BLOCK OF 0'S

SAVE10:	TRNE 6,777		;END OF PAGE?
	SKIPE 0(5)		;OR NON-0 WORD?
	JRST SAVE11		;YES
SAVE9:	ADDI 5,1
	AOBJN 6,SAVE10
SAVE11:	MOVE 7,6		;UPDATE POINTER
	JRST SAVEB1		;RECHECK PAGE, ETC.

;SHARED SAVE

.SSAVE:	JSYS MENTR
	MOVE 10,2		;OUTPUT DESCRIPTOR
	CALL GTSVI
	TLNE 3,777		;DISK?
	JRST SSAVE1		;GOTTA BE
	HRRI 2,1B20		;WRITE
	OPENF
	JRST ITRAP1
	MOVSI 13,2		;START MAPPING INTO FILE PAGE 2
	JUMPL 10,SSAV3		;SINGLE DESCRIPTOR
SSAV2:	UMOVE 7,0(10)		;GET NEXT DESCRIPTOR
	JUMPE 7,SSAV1		;DONE
	CALL SSAVB		;OUTPUT THE STUFF
	AOJA 10,SSAV2

SSAV3:	MOVE 7,10
	CALL SSAVB
SSAV1:	MOVEI 1,0(15)		;FORK HANDLE
	CALL SETLFK
	MOVE 2,ENTVEC(1)	;PUT ENTRY VECTOR IN FILE
	MOVEI 1,0(16)		;JFN
	BOUT
	HLRZ 2,13		;NEXT FREE PAGE IN FILE
	ASH 2,^D9		;FIRST WORD OF THAT PAGE
	SFPTR			;SET EOF AFTER ALL EXISTING PAGES
	BUG(CHK,<SSAVE - UNEXPECTED BAD RETURN FROM SFPTR>)
	JRST SAVER		;REGULAR FINISH UP

;SAVE PAGES ACCORDING TO AC7, XWD -NPAGES,,ACCESS,FIRST PAGE

SSAVB:	PUSH P,10
	TLC 7,777000		;MAKE SURE COUNT .L. 1000 PAGES
	TLCE 7,777000		;I.E. BITS 0-8 SHOULD BE 0
	ITERR SSAVX2		;LOSE
	HLLZ 13,13		;CLEAR COUNT FOR PAGES IN THIS BLOCK
	SETZ 1,
	MOVEI 2,FTPG1A
	CALL SETMPG		;CLEAR TEMP PAGE
SSAVB2:	MOVSI 1,0(15)
	HRRI 1,0(7)
	ANDCMI 1,777000		;FLUSH ACCESS BITS FROM HERE
	RPACS			;GET STATE OF THIS MEM PAGE
	JUMPE 2,SSAVB1		;DOESN'T EXIST
	TLNN 2,(1B2)		;READABLE?
	JRST SSAVB1		;NO, SKIP IT
	TRNE 7,1B19		;ACCESS FROM SOURCE PAGE REQUESTED?
	JRST [	TSC 7,2		;YES
		TRZ 7,1B18+RWX+TRAPUB ;MOVE THESE BITS INTO ACCESS WD
		TSC 7,2		;FROM RPACS OF SOURCE PAGE
		TLNE 2,WRITEB+COPYB ;SOURCE HAS SOME KIND OF WRITE?
		TRO 7,1B18	;YES, GIVE WRITE-COPY
		JRST .+1]
	CALL FKHPTN
	MOVE 2,[XWD RWX,FPG2A]
	CALL SETMPG		;SETUPT INDIRECT PTR TO USER PAGE
	MOVSI 1,0(16)		;JFN
	HLR 1,13		;FILE PAGE NUMBER
	PUSH P,13
	CALL JFNOFN
	BUG(HLT,<SSAVE - JFNOFN FAILED>)
	POP P,13
	MOVE 2,[XWD RWX,FPG3A]
	CALL SETMPG		;MAP THE FILE PAGE
	HRLI 2,FPG2A
	BLT 2,FPG3A+777		;COPY USER'S PAGE TO FILE
	HLRZ 2,13		;PAGE IN FILE TO USE
	HRLI 2,0(7)		;MEM PAGE IN LH, FILE PAGE IN RH
	TLZ 2,(1B1+7B7)		;FLUSH UNSPECIFIED BITS
	MOVEM 2,FTPG1A(13)	;SAVE FOR LATER OUTPUT
	AOBJP 13,.+1		;INCREMENT FILE PAGE NUMBER AND COUNT
SSAVB1:	AOBJN 7,SSAVB2		;COUNT MEM PAGES
	MOVEI 2,0(13)		;NUMBER OF FILE PAGES DONE
	JUMPE 2,SSAVB3
	HRLI 2,1000		;TYPE NUMBER
	MOVEI 1,0(16)
	BOUT
	MOVNI 7,0(13)		;GET NEG COUNT FOR THIS BLOCK
	MOVSI 7,0(7)		;SETUP AOBJN WORD
	MOVE 2,FTPG1A(7)	;GET WORD FOR ONE PAGE
	BOUT
	AOBJN 7,.-2
SSAVB3:	SETZ 1,			;CLEAR TEMP PAGE
	MOVEI 2,FTPG1A
	CALL SETMPG
	MOVEI 2,FPG2A
	CALL SETMPG
	MOVEI 2,FPG3A
	CALL SETMPG
	POP P,10
	RET

;OPERATOR FUNCTION CALL JSYS "OPRFN". THIS JSYS EXISTS TO BE
;USED BY THE EXEC OR EPHEMERONS TO DO OPERATOR TASKS, SO THE OP
;DOES NOT NEED TO GET INTO MDDT MOST OF THE TIME.
;
;THE FUNCTIONS ARE CALLED BY SIXBIT NAME, WHICH REQUIRES A TABLE
;SEARCH BUT IS OK BECAUSE THESE FUNCTIONS SHOULD ONLY BE CALLED
;ONCE A DAY OR SO. 
;
;FIELD SITES NOTE -- BBN WILL NEVER ADD ANY SIXBIT NAMES STARTING WITH
;THE LETTER "X". FIELD SITES CAN USE THAT CLASS OF NAMES WITHOUT 
;NEEDING TO WORRY ABOUT CONFLICT WITH FUTURE BBN FUNCTIONS.

;CALL - MOVE 1,[SIXBIT .FUNCTION-NAME.]
;	MOVE 2,ARGUMENT DEPENDENT ON FUNCTION. (MORE IN 3 &4...)
;	OPRFN
;	  FAIL RETURN, ERROR CODE IN 1
;	GOOD RETURN

INTERN .OPRFN

.OPRFN:	JSYS MENTR		;ESTABLISH MONITOR CONTEXT
	MOVSI F,-NOPRFS		;COUNT THRU NAME TABLE
	CAMN A,OPRFTB(F)	;SEARCH. THIS ONE?
	JRST OPRFN1		;YES.
	AOBJN F,.-2		;NO, SEARCH ONWARDS.
	MOVEI A,OPRFX1		;NOT IN TABLE.
	JRST MRETNE##		;FAIL, NONSKIP, CODE TO LSTERR AND 1

OPRFN1:	HLRZ E,OPRFT2(F)	;SEE WHAT CAPABILITIES ARE NEEDED
	TDNN E,CAPENB		;ARE THEY ON IN THIS FORK?
	JRST CAPX		;NO. FAIL.
	HRRZ E,OPRFT2(F)	;YES. GO DO THE FUNCTION
	PUSHJ P,0(E)		; ..
	  JRST MRETNE		;FAILED. ERROR CODE IN 1
	JRST SKMRTN		;SUCCESS RETURN.

;HERE ARE THE FUNCTIONS DEFINED SO FAR. ARGS TO THE "X" MACRO
; ARE SIXBIT NAME, CAPABILITIES NEEDED, TAG TO CALL.

DEFINE OPRFNS <
IFN PIESLC,<
	X(KFACT,WHEEL+OPER,OPRKFC)>
IFDEF IMPCHN,<
	X(IMPDRQ,WHEEL+OPER+MAINT,OPRICY)
	X(HSTINI,WHEEL+OPER,OPRHIN)
	X(NETON,WHEEL+OPER+MAINT,OPRNTN)>
IFN JTRPSW,<
	X(JTRPON,WHEEL+OPER,OPRJTN)>
	X(ENTFLG,WHEEL+OPER+MAINT,OPRENT)
	X(MKPGSA,WHEEL+OPER+MAINT,OPRMPA)
	X(MKPGSU,WHEEL+OPER+MAINT,OPRMPU)
	X(DDTRCL,WHEEL+OPER,OPRRCD)
	X(DDTFSH,WHEEL+OPER,OPRFSD)
	X(DBUGSW,WHEEL+OPER,OPRBSW)
	X(DCHKSW,WHEEL+OPER,OPRCSW)
	X(USRSPC,WHEEL+OPER,OPRUSP)
	X(SYSSPC,WHEEL+OPER,OPRSSP)
	X(ACTINI,WHEEL+OPER,OPRACT)
;ADD MORE HERE
IFDEF PUPCHN,<
	X(PUPDIR,WHEEL+OPER,NTDINI##)
	X(PUPROU,WHEEL+OPER,SETRTE##)
	X(PUPBGF,WHEEL+OPER,OPRPBG)>
IFDEF LPTSPL,<
	X(INIFNT,WHEEL+OPER,INIFNT##)>
>

DEFINE X(NAME,CAPS,ROUTIN)<	<SIXBIT \NAME\>>
OPRFTB:	OPRFNS
NOPRFS==.-OPRFTB

DEFINE X(NAME,CAPS,ROUTIN)<	XWD CAPS,ROUTIN>
OPRFT2:	OPRFNS

IFN PIESLC,<

OPRKFC:	FMPRI B,(1.0)		;MAKE SURE IT'S A NORMALIZED FP NUMBER
	CAIL B,0		;AND IN RANGE 0 THRU 1
	CAMLE B,[1.0]
	JRST OPRFXX		;NO GOOD.
	MOVEM B,KFACT##		;OK, SET IT.
	JRST RSKP		;GOOD RETURN.
>
IFDEF IMPCHN,<
OPRNTN:	SKIPE C,B		;SET NETON TO 0 OR -1
	AOJN C,OPRFXX		;JUMP IF NOT LEGAL VALUE
	MOVEM B,NETON##		;OK, SET IT.
	JRST RSKP
>

OPRENT:	SKIPE C,B		;SET ENTFLG TO 0 OR -1
	AOJN C,OPRFXX		;JUMP IF NOT 0 OR -1
	MOVEM B,ENTFLG##	;OK, SET IT.
	JRST RSKP
IFN JTRPSW,<
OPRJTN:	SKIPE C,B		;SET JTRPON TO 0 OR -1
	AOJN C,OPRFXX		;JUMP IF NOT LEGAL VALUE
	MOVEM B,JTRPON##	;OK, SET IT.
	JRST RSKP
>
OPRRCD:	PUSHJ P,DDTRCL		;RECLAIM DDT
	JRST RSKP

OPRFSD:	PUSHJ P,DDTFSH		;FLUSH DDT
	JRST RSKP

OPRBSW:	CAIL B,0		;SET DEBUGSWITCH TO 0 THRU 2
	CAILE B,2		; ..
	JRST OPRFXX		;BAD VALUE
	MOVEM B,DBUGSW		;OK. SET IT
	JRST RSKP

OPRCSW:	CAIE B,0		;0 OR 1 TO DCHKSW
	CAIN B,1
	JRST OPRCS1		;OK
OPRFXX:	MOVEI A,OPRFX2		;BAD ARG ERROR CODE
	POPJ P,0		;NON-SKIP RETURN
OPRCS1:	MOVEM B,DCHKSW		;STORE GOOD DCHKSW
	JRST RSKP

OPRMPA:	MOVE A,B		;MOVE ARGUMENTS OVER TO 1 AND 2
	MOVE B,C
	CAMLE A,B		;PAGES IN RIGHT ORDER?
	JRST OPRFXX
	CAML A,SWPCOR		;AND IN REASONABLE AREA?
	CAIL B,MAXCOR		; ..
	JRST OPRFXX		;NO
	PUSHJ P,MKPGSA		;PUT PAGES ON LINE
	JRST RSKP

OPRMPU:	MOVE A,B		;TAKE PAGES OFF LINE
	MOVE B,C
	CAMLE A,B
	JRST OPRFXX
	CAML A,SWPCOR
	CAIL B,MAXCOR
	JRST OPRFXX
	PUSHJ P,MKPGSU
	JRST RSKP

OPRUSP:	JUMPL B,OPRFXX		;LEGAL FOR .GE. 0
	MOVEM B,USRSPC##	;SET USER DISK LIMIT
	JRST RSKP

OPRSSP:	JUMPL B,OPRFXX		;LEGAL FOR .GE. 0
	MOVEM B,SYSSPC##	;SET SYSTEM DISK LIMIT
	JRST RSKP

OPRACT:	CALL ACTIN1##		; PUT NEW UACHK.FILE OUT
	 RET				; FAILED
	JRST RSKP			; OK

IFDEF IMPCHN,<
OPRHIN:	CALL HSTINI##		;LOAD NEW HOST NAME FILE
	  POPJ P,0		;FAILED
	JRST RSKP		;OK.

OPRICY:	MOVEI B,1		;SET IMPDRQ TO CYCLE THE NET
	MOVEM B,IMPDRQ##	; ..
	JRST RSKP		;RETURN.
>

IFDEF PUPCHN,<
OPRPBG:	MOVEM B,PUPBGF##
	JRST RSKP
>

	END ; OF MONJS.MAC

