;<134>PISRV.MAC;10806    25-JAN-77 21:33:11    EDIT BY TAFT
; Make MTACHN initialization conditional
;<134>PISRV.MAC;10804    17-JUL-76 18:07:29    EDIT BY TAFT
; Add code to save MAR, MDR, etc., at time of parity error
;<134>PISRV.MAC;10803    19-APR-76 00:33:51    EDIT BY TAFT
; Mark 8 pages bad when parity error found
; Remove typeout of bad page list
;<134>PISRV.MAC;10802    11-JAN-76 00:13:51    EDIT BY TAFT
; Add check in MRETN against returning to user while on special queue
;<134>PISRV.MAC;10801     9-JAN-76 19:57:56    EDIT BY TAFT
; No changes required for 1.34
;<133>PISRV.MAC;9710     3-DEC-75 22:28:36    EDIT BY TAFT
; Remove instance of RPI instruction in P1FOV since it's
; de-implemented in the new microcode.
;<133>PISRV.MAC;9709    26-NOV-75 00:38:25    EDIT BY TAFT
; Make UUO dispatcher know about Byte Lisp mode
;<133>PISRV.MAC;9708    13-NOV-75 14:58:52    EDIT BY TAFT
; Correct page count in parity error logic, and print 21-bit addresses
;<133>PISRV.MAC;9707    20-JUN-75 12:18:12    EDIT BY TAFT
; Increase size of PI5PDL for PUP
;<133>PISRV.MAC;9706    13-JUN-75 16:38:57    EDIT BY TAFT
; Take out most of the NVIO bug strings
;<133>PISRV.MAC;9705     4-JUN-75 17:50:09    EDIT BY TAFT
; Restore ac's before entering EDDT in BUGHLT code
;<133>PISRV.MAC;9704    24-MAY-75 15:42:00    EDIT BY TAFT
; Modify parity error code to work for >256k memory
; Add DEVRST PUP
;<133>PISRV.MAC;9703    26-MAR-75 19:44:32    EDIT BY TAFT
; Add 30-second wait in BUGHLT code so operator can get control
;  before auto-restart.
;<133>PISRV.MAC;9702     5-JAN-75 16:54:49    EDIT BY TAFT
;<133>PISRV.MAC;9701     4-JAN-75 19:00:51    EDIT BY TAFT
; Turn levels off at start, on in PIINIT so random PION's don't cause trouble
; Reset CHKTM1 in SYSRST
;<132>PISRV.MAC;9420     4-OCT-74 13:37:39    EDIT BY FIALA
; Changed SYSGO procedure for booting from disk
;<132>PISRV.MAC;9419     1-OCT-74 03:41:00    EDIT BY FIALA
; Put in MPCLRC extern
;<132>PISRV.MAC;9418    25-SEP-74 17:11:54    EDIT BY TAFT
; Reset NVCHKA in initialization
;<132>PISRV.MAC;9417    24-SEP-74 15:40:39    EDIT BY TAFT
; BBN patch at MSTKOV+
;<132>PISRV.MAC;9416    10-SEP-74 15:33:57    EDIT BY TAFT
; Fix clock race in startup code by separating clock code into
;  separate routine CLKINI.
; Put back setting of RSTFLG in SYSRST code.
; Save NVIO bits for original parity error as well as sweep.
;<132>PISRV.MAC;9415     5-AUG-74 10:28:42    EDIT BY FIALA
; Expanded PI4AC to 6 regs. for DSKPAK change. (ERF)
; Reduced INTERN-EXTERN stuff by improving DEVRST macro, ##, and ::
;   removed 10 second clock correction in BUGH0 code (not needed),
;   saved instructions in BUGH0, replaced pager stuff in MEMPAR by PGRON. (ERF)
;<132>PISRV.MAC;9411    26-JUL-74 01:11:52    EDIT BY TAFT
; Eliminate APCLK1. (EAT)
; Use ch7 dispatch for clock and scheduler. (ERF)
; Put in missing MONCLR in MENTR. (EAT)
; Defined DLSLOC. (ERF)
; Take out MCAINI call (move to FILINI). (EAT)
; Put in Maxc-specific initialization for CST0, MMAP, SPT, TRAPS0-PSB,
;   LGBUF, JDV.  Removed MAXLOC definitions to PROLOG. (ERF)
; Put in 1.32 edits into 1.31 sources.  Also split out Maxc-specific
;   stuff in SYSGO, SYSLOD, and SYSRST as MICINI program. (ERF)
;<TENEX-132>PISRV.MAC;92    16-MAY-74 14:19:31    EDIT BY ALLEN
;ADD CHECK FOR UNEXPECTED NXM IN PARITY ERROR MEMORY SCAN.
;<TENEX-132>PISRV.MAC;89     9-MAR-74 15:03:12	EDIT BY CLEMENTS
; CLEAR IDX FIELD OF FPC AT MRETN
;<TENEX-132>PISRV.MAC;78    29-AUG-73 13:23:56	EDIT BY ALLEN
; REPLACE APPROPRIATE RESKED'S WITH RESKD1'S TO AVOID UNNECESSARY
; WAITLIST SCANS
;<TENEX-132>PISRV.MAC;75    26-JUN-73 16:13:40	EDIT BY CLEMENTS
; SEPARATING ASSEMBLY OF PISRV FROM MON
; Change PSWIT to MAPCLR in parity code. (EAT & ERF)
; Limit error count stored in MPECNT to NMPERR. (EAT)
; Add code to save par error data for Job 0 to print.
;  Also save error bits passed by NVIO. (EAT)
; Changes in SYSGO1, SYSRST, PIINIT to allow NVIO update of TODCLK
;  and set clock interrupt interval to 17ms. (EAT)
; Fix 3 bugs in memory parity error recovery. (EAT)
; Set flag and run job 0 immediately on SYSRST. (EAT)
; Reset CHKTIM in SYSRST. (EAT)
; NVLOG not BUGLOG in NVCHK. (EAT)
; Update NVIO bugstrings. (EAT)
; Remove redundant MTBS and DLSBL defn's (in PROLOG), changed NVCHK to
; have its own location NVLOG, so that NVIOCHKs on top of BUGCHK's won't
; clobber the return address. (ERF)
; Make SYSRST internal, remove BGHERE. (EAT)
;30 June 73:	Check microcode at all system restarts; changed
;		BUGHLT restart to try soft restart if crashes
;		aren't too frequent; removed address break and
;		memory protection; gave clock, FOVF, and OVF separate
;		interrupt locations using INCOMPATIBLE.	E.R.Fiala
;9 July 73:	Speeded up MTA, DLS interrupts, put in traps for
;		unused PI locations, ripped out unused level 6 code,
;		moved DBUGSW, BUGHLT, BUGCHK, CRSTAD to a dirty
;		block preserved across system reload; eliminated
;		BUGHAD, CRSTD1, DBUGS1; wrote parity error finding
;		code.					E.R.F.

;PI DISPATCH MODULE - D. MURPHY

SEARCH PROLOG

TITLE PISRV

;SYSTEM INITIALIZATION

;LINKAGE TO PAGEM AND SCHED

EXTERN BHC,DISKP,FORKX,INSKED,ISKED,PSKED,ITRAP,ITRAP1,MPCLRC
EXTERN JB0FLG,JOBSRT,LSTERR,MMSPTN,MPEINT,P7FOV,P7OV,P7POV
EXTERN PGRINI,PGRRST,PGRTRP,PI7P,PISC7,PWRDWN,SCDIN,SCDRQ,SCDRQ7
EXTERN SCDVE,SCHED0,SKEDF1,SWPCOR,SWPRST,TADSEC,JOBRTT
EXTERN SETMPG,SCDRN1
EXTERN BUGCHK

DDTST=100	;Entry vector for EDDT

;MANUAL START TRANSFER VECTOR

	LOC 140
	JRST SYSRST		;RESTART
	ASCII /TENEX/		;FINGERPRINT MON CORE IMAGE
	XWD MGTBSZ##,SYMTAB##	;SYM TAB POINTER
	0			;144/ MEXEC return when patching system
	0
	0
	JRST SYSGO		;146/ RELOAD AND START
	JRST SYSGO1		;147/ START

	RELOC

; Initialize microprocessor and Nvio.

MICINI:	PRES			; Reset processor
	MOVEI 10,0		; Run Checker, halt on bad microcode
	CHECK 10,0
	LEVOFF 177		; All channels off during init
	MOVEI A,TRAPS0-PSB
	SLOC A,0		; Set offset in PSB of pager trap status
				; Write data word = this value + 1
	MOVEI A,MMAP
	SLOC A,1		; Set address of monitor map
	MOVEI A,SPT
	SLOC A,2		; Set address of shared pages table
	MOVEI A,CST0
	SLOC A,3		; Set address of pager core status table
; Pager trap instruction (default 70) and base register word (default 71)
; are currently omitted here (SLOC 4 and SLOC 5)
	MOVEI A,JDV		; Set address of JSYS dispatch table
	SLOC A,6
	MOVEI A,LGBUF		; Instruction counting log buffer
	SLOC A,7
	MOVEI 1,MAXLOC
	WABS 1,MTBS		; Initialize MTBS
	MOVEI 1,DLSLOC
	WABS 1,DLSBS		; Initialize DLSBS
	MOVE 1,100
	WABS 1,7		; Set starting address to EDDT dispatch
	MOVEI 2,NVLOG##
	MOVEM 2,NVCHK		; Setup Nvio bugchk address
	SETOM NVCHKA		; Reset argument word
	CONO APR,634440		; Reset I/O and enable Nvio
	RET

; Initialize NVIO updating of TODCLK.  Should be called after I/O reset
; and after setting TODCLK to desired initial value, to prevent races.
CLKINI:	MOVE 1,[5B15+^D17B31]	; CDVS index, interval for clock in msec
	MOVEM 1,XCCHS		; Put in cell for Nvio to look at
	SIGNAL CDVS		; Signal Nvio task
	RET

;RELOAD SYSTEM FROM DISK AND RESTART

SYSGO::	SETOM SCDRQ		; Pick random spot for flag
	JRST SYSGO2

;START FROM SCRATCH AFTER LOADING RESIDENT MONITOR

SYSGO1::SETZM CRSTAD##
SYSGO2:	SKIPA 7,DIDSCI##
SYSLOD::SETZ 7,			;CLEAR DIDSCA## TO RELOAD DISK
	MOVE P,PI7P
	CALL MICINI		; Init and check microcode, init Nvio
	SETZM TODCLK		; Reset millisecond clock
	CALL CLKINI		; Enable NVIO updating of TODCLK
	MOVE 1,[XWD LGBUF,LGBUF+1] ;******CAREFUL******(See Params)
	SETZM -1(1)
	BLT 1,SCDVE
	MOVEM 7,DIDSCA##
	AOS INSKED
	CALL PGRINI		;INIT DST, CST, ETC.
	IFDEF DLSCHN,<CALL TTINIT##>	;TELETYPE MODULE
	IFDEF DRMCHN,<CALL DRMINI##>	;DRUM
	IFDEF DSKCHN,<CALL DSKINI##>	;DISK
	CALL SCDIN		;SCHEDULER
	CALL PIINIT		;PI MODULE - LAST INIT
	AOSE SCDRQ##		; Booting from disk?
	JRST .+3		; No
	CALL RLRMON##		; Yes
	JRST SYSGO2
	MOVE 1,[XWD CTYLIN,JOBSRT]
	CALL SCDRQ7		;INITIATE FIRST JOB
	JRST SCHED0		;TO SCHEDULER

;RESTART SYSTEM

	DEFINE DEVRST (A)
<	IFDEF A'CHN,<INTERN A'CHN
	CALL A'RST##>>

SYSRST::SETZM SOFTRS
	MOVE P,PI7P
	CALL MICINI		; Init and check microcode and init Nvio
	CALL CLKINI		; Enable NVIO update of TODCLK
	SETZM PWRDWN
	SETOM SCDRN1		;IN CASE ONLY ONE JOB WAS RUNNING.
	SETOM RSTFLG##		; Note that a restart was done
	AOS JB0FLG		; Cause job 0 to run soon
	MOVE 1,TODCLK		; Postpone job 0 alarm
	ADDI 1,^D120000
	MOVEM 1,CHKTM1##
	CALL PGRRST
	DEVRST DRM
	DEVRST DSK
	DEVRST MTA
	DEVRST LPT
	DEVRST DSP
	DEVRST DTA
	DEVRST PTR
	DEVRST PTP
	DEVRST PLT
	DEVRST IMP
	DEVRST MCA
	DEVRST PUP
	PUSH P,INSKED
	MOVEI 1,1
	MOVEM 1,INSKED
	SETZM SKEDF1
	CALL PIINIT
; TTRSET must come after PIINIT because of the ISB it does
	IFDEF DLSCHN,<CALL TTRSET##>
	CALL SWPRST		;SWAPPER CLEANUP
	POP P,1
	JUMPN 1,SCHED0		;RESUME SCHED IF THERE AT CRASH
	SETZM INSKED
	SETOM TRAPC
	MOVSI 1,UMODF		;CRASH PROCESS RUNNING AT CRASH
	MOVEM 1,FPC
	JRST ITRAP

;IMPOSSIBLE SITUATION HALT

LS HARDRS,1
LS SOFTRS,1
LS SYMPRS,1
LS DDTPRS,1

BUGH0::	AOS JB0FLG		;GET IT REPORTED SOON
	RPIP 1,0
	SKIPN INSKED		;IN SCHEDULER?
	TRNE 1,77777		; PI-in-progress, PI off, or PI levels off
	JRST .+2
	JRST EXBUGH##		;NO, CRASH THIS JOB
	PIOFF			;TURN OFF SYSTEM
	MOVEI 1,[SIXBIT '$BUGHLT AT /']
	JSYS BUGMSG##		;TYPE CRASH MESSAGE
	HRRZ 1,BUGHLT##
	JSYS BUGOPT##
	MOVEI 1,[SIXBIT '$/']
	JSYS BUGMSG
	SKIPN DBUGSW##		; Breakpoint already reached?
	SKIPE DDTPRS##		; EDDT not in core?
	JRST BUGH1		; Yes, skip following
	MOVEI 1,[SIXBIT 'HIT DEL TO ABORT RESTART AND ENTER EDDT$/']
	JSYS BUGMSG##		; Notify operator if he is there
	CONO TTY,1B25+1B26	; Clear input busy, input done
	MOVEI 2,^D20		; 20 bells to wake him up (about 30 sec)
BUGH1A:	MOVEI 1,7		; Ring bell
	JSYS BUGTYO##
	MOVSI 1,2		; Wait about 1.5 sec
	SOJG 1,.
	CONSZ TTY,1B30		; Anything typed?
	JSYS BUGTYI##		; Yes, get it
	CAIE 1,177		; Rubout?
	SOJG 2,BUGH1A		; No, keep waiting
	CAIE 1,177
	 JRST BUGH1		; Timed out without hitting rubout
	MOVSI 17,BUGBLK##	; Hit rubout, restore ac's
	BLT 17,17
	PION
	XCT BUGADR##		; Break to EDDT ($P continues restart)
BUGH1:	SKIPGE TADSEC		;TIME AND DATE NOW SET?
	JRST SYSGO		;NO
	MOVE 1,TODCLK		;YES, REMEMBER IT FOR RESTART
	IDIVI 1,^D1000
	ADD 1,TADSEC		;CONVERT TODCLK AND OFFSET TO
	IDIVI 1,^D24*^D3600	;INTERNAL FORM TIME AND DATE
	ADD 1,TADDAY##		;SEE GTAD
	HRLI 2,0(1)		;DAYS IN LH, SECONDS IN RH
	MOVE 1,2
	EXCH 2, CRSTAD		; Crash time and date
	JUMPE 2,BUGH2
	SUB 1,2
	CAIL 1,^D60*5		; If crashes < 5 min. apart
BUGH2:	SKIPE HARDRS		; Or if directed hard restart
	JRST SYSGO		; Reload & restart
	SKIPN SOFTRS		; Directed soft restart?
	SKIPE DBUGSW##		; Or system unattended?
	JRST SYSRST		; Then try soft restart
	JRST SYSGO2		; Otherwise try hard restart

;PI SYSTEM INITIALIZATION

PIINIT:	MOVSI 1,(JSYS)		;SETUP JSYS DISPATCHES IN LOWER CORE
	MOVSI 3,-NPISET
PII1:	HRR 1,PISETT(3)		;DISPATCH ADDRESS WITH JSYS
	HLRZ 2,PISETT(3)	;LOC OF WHERE IT GOES
	MOVEM 1,0(2)
	AOBJN 3,PII1
	CONO APR,473550+APRCHN	;SET APR FLAGS
	INCP			;ENTER INCOMPATIBLE MODE (USING CONO'S
				;TO CHANGE P.I.A. WON'T WORK)

; INITIALIZE DEVICES:
DEFINE	CHINIT(DEV,LEV,L)<
	IFB <L>,<MOVEI 1,40+2*LEV>
	IFNB <L>,<MOVEI 1,L>
	API	1,LEV*100+DEV
>

	CHINIT	10,SCDCHN	  ; APR CLOCK (17 MS) AND SCHEDULER
IFDEF MTACHN,<CHINIT 11,MTACHN>	; MAGTAPE CONTROL
	CHINIT	13,DLSCHN	; DATA LINE SCANNER
IFDEF MCACHN,<CHINIT 20,MCACHN,MCASV##>	; XNET
	CHINIT	26,APRCHN	; PDL OV
	CHINIT	37,APRCHN	; POWER FAILURE
	CHINIT	40,0,P1FOV	; FLOATING OVERFLOW
	CHINIT	41,APRCHN	; PARITY
	CHINIT	42,APRCHN	; NO MEMORY
	CHINIT	43,0,P1OV	; FIXED OVERFLOW
	CONO PI,602200+177	;CLEAR FLAGS, SET CHANNELS ON
	LEVON 177		; Channels on (CONO PI doesn't do it on Maxc)
	SETZM PSCAN		;INDICATE PREPARED FOR PARITY ERRS
	RET

;IMAGE OF LOW CORE PI LOCS

	DEFINE PILC (C,A)
<	XWD 40+2*C,A>

PISETT:	XWD 41,UUOH		;UUO'S AND ILLEG. INSTR'S
	PILC 1,BUGINT
	PILC 2,BUGINT
	PILC APRCHN,PIAPR	;APR CHANNEL
	PILC 4,PISC4		;GENERAL CHANNELS
	PILC 5,PISC5
	PILC 6,BUGINT
	PILC 7,PISC7
	XWD 61,UU60		;UNIMPLEMENTED INSTR'S
	XWD 70,PGRTRP		;PAGER TRAP
NPISET==.-PISETT

LS PIAPRX,1
LS PI1AC1,1

;CHANNEL DISPATCH ROUTINES

PIAPR:	XWD PIAPRX,.+1

PIAPR1:	MOVEM 1,PI1AC1
	CONSZ APR,1B19		;PDL OVF
	JRST P1POV
	CONSZ PI,1B18		;PWR FAIL?
	JRST ACFAIL		;YES
	SKIPN DEVMPE		;DEVICE DETECTED MPE?
	CONSZ PI,1B19		;PARITY ERROR?
	JRST MEMPAR		;YES
	CONSZ APR,1B23+1B22	;NXM, MEM PROT
	JRST P1NXM
	BUG(CHK,<FALSE APR INTERRUPT>)
	JRST OV0		;NOTHING, DEBREAK

;OVERFLOWS

P1FOV:	JSYS [XWD PIAPRX,.+1]
	MOVEM 1,PI1AC1
	MOVSI 1,(1B3)		; Prepare to clear floating overflow
	CONSZ APR,1B31		; Overflow also enabled?
	 TLO 1,(1B0)		; Yes, clear it too
	ANDCAM 1,PIAPRX		;CLEAR FLAG CAUSING INTERRUPT
	MOVEI 1,P7FOV
	JRST FOV1

P1OV:	JSYS [XWD PIAPRX,.+1]
	MOVEM 1,PI1AC1
	MOVSI 1,(1B0)
	ANDCAM 1,PIAPRX		;CLEAR FLAG
	MOVEI 1,P7OV
FOV1:	SKIPN INSKED		;IGNORE IF: IN SCHED, OR
	CONSZ PI,177B27-1B<APRCHN+20> ;IN PI SERVICE
	JRST OV0
	JFCL 17,.+1		;CLEAR FLAGS
	HLL 1,PIAPRX
	TLNN 1,UMODF		;IF IN USER MODE, OR
	SKIPE OVFLG		;IN MONITOR WITH FLAG SET,
	JRST OV1
	HRL 1,PIAPRX
	TLC 1,PGRTRP+1
	TLNE 1,-1		;CAME FROM FIRST INSTRUCTION OF PGR TRP?
	JRST OV0		;NO
	HLL 1,TRAPPC		;YES, SO REAL PC IS THERE
	TLNE 1,UMODF		;IS THAT USER?
	JRST OV1		;YES, REQUEST INTERRUPT
	JRST OV0

P1NXM:	BUG(CHK,<NXM DETECTED BY PROCESSOR>)
	SETZM PSCAN		; Clear memory error scan word for Nvio
	CONO APR,1B23+APRCHN	;THEN CLEAR FLAGS
	MOVE 1,PIAPRX
	TLNN 1,UMODF		;USER PC?
	BUG(HLT,<NXM IN MONITOR>)
	MOVEI 1,MPEINT		;GIVE USER MPE INTERRUPT
	JRST OV1

P1POV:	CONO APR,1B18+APRCHN	;CLEAR FLAG
	MOVE 1,PIAPRX
	TLNN 1,UMODF		;FROM MONITOR?
	JRST P1SOV
P1UPOV:	MOVEI 1,P7POV
OV1:	HRL 1,FORKX
	JSR SCDRQ		;REQUEST SCHEDULER ACTION
	RESKED
OV0:	MOVE 1,PI1AC1
	JEN @PIAPRX

P1SOV:	MOVEI 1,0(1)
	CAIE 1,PGRTRP+1		;FROM PAGER TRAP STARTING?
	JRST P1MSOV		;NO, REAL MSOV
	MOVE 1,TRAPPC		;MEM TRAP AS WELL AS SOV, GET PC
	TLNE 1,UMODF		;THIS ONE USER?
	JRST P1UPOV		;YES
P1MSOV:	MOVE 1,PIAPRX		; Simulate UUO entry for JRST ITRAP below
	MOVEM 1,FPC
	MOVE 1,PI1AC1
	JEN @[MSTKOV]

MSTKOV::CONSO PI,177B27		;BAD ONE?
	SKIPE INSKED
	BUG(HLT,<PDL OVERFLOW IN SCHEDULER OR WHILE PI IN PROGRESS>)
	BUG(CHK,<PDL OVERFLOW IN MONITOR>)
	SETOM TRAPC		;NOT SO BAD
	MOVE	P,UPP			;GET A REASONABLE STACK
	ADD	P,BHC+2
	MOVEM	P,MPP
	PUSH	P,1
	MOVE 1,ACBAS		; WHERE IS CURRENT AC BLOCK?
	CAIL	1,<EUACB>B39		;AC BLOCKS IN PSB?
	JRST	MSTKV2			;NO, ADJUST UACPG MAP ENTRY
MSTKV1:	POP	P,1
	MOVE	P,ACBAS1
	MOVEM	P,ACBAS
	SETACB	P
	SETZM	SLOWF
	MOVE	P,MPP
	JRST	ITRAP

MSTKV2:	PUSH	P,2
	SETZ	1,
	MOVEI	2,UACPGA
	CALL	SETMPG			;UNMAP AC BLOCK PAGE
	POP	P,2
	MOVE	1,PSB+PSBPG
	MOVEM	1,PSB+UACPG		;SET MAP ENTRY FOR UACPG TO PSB
	JRST	MSTKV1

;AC FAIL

ACFAIL:	CONO PI,1B18		;CLEAR FLAG
	AOS PWRDWN		;SET FLAG TO NOTIFY SCHED
	RESKD1			;NOW
	JRST OV0

;MEMORY PARITY ERROR DETECTED

MEMPAR:	PIOFF
	MOVEM 7,MEMPA+7		;SAVE SOME AC'S
	MOVEI 7,MEMPA
	BLT 7,MEMPA+6
	APIL 41			;DISABLE PARITY INTERRUPT
	MOVE 1,XMEMER		; Save NVIO data for original error
	MOVEM 1,MPEBTS##
	MOVE 1,[XMAR,,MPREGS##]	; Save memory register data left by NVIO
	BLT 1,MPREGS##+5
	MOVEI 1,[SIXBIT '$MEMORY PARITY ERROR DETECTED BY /']
	JSYS BUGMSG
	MOVE 6,[SIXBIT ', EXEC']
	MOVSI 2,UMODF
	TDNE 2,PIAPRX
	MOVE 6,[SIXBIT ', USER']
	MOVE 7,[SIXBIT ' PC= /']
	SKIPN 5,DEVMPE		;MESSAGE LEFT BY DEVICE?
	MOVE 5,[SIXBIT 'APR']	;NO, SAY APR
	MOVEI 1,5		;STRING IN 5-6-7
	JSYS BUGMSG
	HRRZ 1,PIAPRX
	JSYS BUGOPT##		;TYPE ADDRESS
	SETOB 7,MEMPA+1		;INIT ERROR COUNT
	MOVN 6,NHIPG##		; Get highest page # known about
	MOVSI 6,-1(6)		; Make AOBJN page counter
	CLRIR 41		;CLEAR PARITY FLAG
	CLRIR 42		;CLEAR NXM FLAG
	SETZM PSCAN		;PREVENT NVIO FROM HALTING DURING SCAN
MEMP0A:	MOVSI 2,RWXB		; Make PT pointer to page being scanned
	HRRI 2,(6)
	MOVEM 2,MMAP+PIPG	; Put page in monitor map
	MONCLR PIPG
	MOVSI 4,(1B0)		; Set legal age for page
	EXCH 4,CST0(6)		;  and save old CST0 contents
	MOVSI 5,-1000		; Count words in page
MEMP0B:	MOVE 2,PIPGA(5)		; Reference a word
	CONSZ APR,APNXM		;NXM ON THIS WORD?
	JRST MEMP9		;YES
	CONSZ PI,1B19		;PARITY ERROR ON THIS WORD?
	JRST PARTYP		;PRINT IT
MEMP0:	AOBJN 5,MEMP0B		; Repeat for all words in page
MEMP0C:	MOVEM 4,CST0(6)		; Restore old CST0 entry
	AOBJN 6,MEMP0A		; Repeat for all pages in system
	MOVEI 1,[SIXBIT '$/']
	JSYS BUGMSG
	MOVEI 1,1(7)
	JSYS BUGOPT##		;TYPE NO. ERRORS FOUND TOTAL
	CAILE 1,NMPERR##	; Overflowed table?
	MOVEI 1,NMPERR##	; Yes, limit count to table length
	MOVEM 1,MPECNT##	; Save error count for job 0 reporting
	MOVEI 1,[SIXBIT ' ERRORS FOUND ON MEMORY SEARCH/']
	JSYS BUGMSG
	AOS JB0FLG		;CAUSE JOB 0 TO RUN SOON
	APIL <APRCHN>*100+41	;REENABLE MPE INTERRUPT
	MOVSI 7,MEMPA		;RESTORE AC'S
	BLT 7,7
	PION

	JUMPGE 1,MEMP8		;FATAL ERRORS?
	SKIPE DEVMPE		;DEVICE DETECTED?
	JRST MEMP7		;YES, PROCEED
	MOVE 1,PIAPRX		;NO, APR
	TLNN 1,UMODF		;WAS IN MONITOR MODE?
	JRST MEMP8		;YES, RELOAD AND RESTART SYSTEM
	MOVEI 1,MPEINT		;GIVE INTERRUPT TO USER
	HRL 1,FORKX
	JSR SCDRQ
	RESKD1
MEMP7:	SETZM DEVMPE
	MOVE 1,TODCLK		;HERE TO PROCEED, UNLESS...
	EXCH 1,PARTIM		;SET TIME OF THIS MPE, GET TIME OF LAST
	SKIPE DBUGSW		;SYSTEM ATTENDED?
	JRST OV0		;YES, SKIP TIME CHECK
	ADD 1,[^D300000]	;WAS LAST ERROR WITHIN 5 MINUTES?
	CAML 1,TODCLK
	JRST MEMP8		;YES, FATAL
	JRST OV0		;NO, CONTINUE RUNNING

;HERE ON NXM DURING MEMORY SCAN
MEMP9:	CLRIR 42		; Clear NXM flag
	SETZM PSCAN		; Prevent Nvio from halting
	LDB 1,[POINT 6,4,5]	;SHOULD THIS NXM HAVE OCCURRED?
	CAIE 1,1
	 BUG(CHK,<Unexpected NXM during parity error scan>)
	JRST MEMP0C		; Skip rest of page

MEMP8:	SETOM HARDRS		;FORCE HARD RESTART
	BUG(HLT,<Unrecovered memory error>)

PARTYP:	SETZM PSCAN
	MOVEM 2,PIPGA(5)	; Store back bad word with good parity
	CLRIR 41		;CLEAR PARITY FLAG
	AOJG 7,MEMP1		;COUNT ERRORS
	MOVEI 1,[SIXBIT '$  LOC     CONTENTS$/']
	JSYS BUGMSG
MEMP1:	CAIL 7,NMPERR		;PRINT THE FIRST 20 ERRORS
	JRST MEMP1A
	MOVEM 2,MPECON##(7)	;SAVE BAD CONTENTS
	MOVE 1,XMEMER		;GET ERROR BITS PASSED BY NVIO
	MOVEM 1,MPEQAD##(7)	;SAVE QUADRANTS OF ERRORS, ETC.
	MOVEI 1,(6)		; Get page #
	LSH 1,9			; Compute full real core address
	IORI 1,(5)
	MOVEM 1,MPEADR##(7)	; Save it for job 0
	HLRZ 1,1		; Get high 3 bits of address
	ADDI 1,"0"		; Make digit
	JSYS BUGTYO##		; Print it
	HRRZ 1,MPEADR##(7)	; Get low 18 bits of address
	JSYS BUGOPT##		;TYPE ADDRESS
	MOVEI 1," "
	JSYS BUGTYO
	MOVE 1,2
	JSYS TNOCT##		;TYPE CONTENTS
	MOVEI 1,[SIXBIT '$/']
	JSYS BUGMSG
MEMP1A:	MOVEI 1,(6)
	TRZ 1,7			; Start at beginning of page group
	HRLI 1,-8		; 8 pages in group
MEMP1B:	MOVEI 2,(1)
	IDIVI 2,44		;COMPUTE POS. IN BAD SPOT TABLE
	MOVE 3,BITS##(3)
	IORM 3,BADMM##(2)	;MARK BAD SPOT
	AOBJN 1,MEMP1B		; Repeat for all pages in group
	MOVEI 1,(6)
	CAMGE 1,SWPCOR		;RESIDENT MONITOR
	JRST MEMP2		;YES, COUNT FATAL ERRORS
	MOVSI 3,SWPERR		;MARK ERROR IN PAGE
	IORM 3,CST3(1)
	MOVE 3,CST2(1)		;OWNER
	TLNE 3,-1		;SPT?
	JRST MEMP4		;NO
	CAIGE 3,NOFN		;YES, INDEX BLOCK?
	JRST MEMP2		;YES
	MOVE 3,SPTH(3)		;NO, GET OWING PT
	JUMPE 3,MEMP2		;DANGEROUS TO HAVE BAD PT'S OR PSB'S
MEMP4:	HLRZ 3,3		;OWNING PT
	CAMN 3,MMSPTN		;MON. MAP?
MEMP2:	AOS MEMPA+1		;COUNT FATAL ERRORS
	JRST MEMP0

LS MEMPA,10		;STORAGE FOR AC'S

GS DEVMPE,1		;AOS'D TO REQUEST CORE SCAN
LS PARTIM,1		;TIME OF LAST PAR ERR

; Device interrupt linkage DEV'CHR is restore-AC's-and dismiss,
; DEV'SV is jumped to after saving ac's

GS PI4ACP,1
LS PI4PDL,10
PI4STK::IOWD 10,PI4PDL
GS PI4AC,6		; DSKPAK saves AC's 0-5 and P
GS PI4R,1

PISC4:	XWD PI4R,.+1
	MOVEM 4,PI4AC+4
	MOVEI 4,PI4AC
	BLT 4,PI4AC+3
IFDEF MTACHN,<JSYS MTASV##>

MTACHR::MOVSI 4,PI4AC
	BLT 4,4
	JEN @PI4R


LS PI5PDL,30
PI5STK::IOWD 30,PI5PDL
GS PI5ACP,1
GS PISC5R,1
LS PI5AC,5

PISC5:	XWD PISC5R,.+1
	MOVEM 4,PI5AC+4		;SAVE AC'S 0-4
	MOVEI 4,PI5AC
	BLT 4,PI5AC+3
	JRST DLSSV##

MCACHR::
DLSCHR::MOVSI 4,PI5AC		;RETURN FROM DEVICE ROUTINES HERE
	BLT 4,4			;RESTORE AC'S 0-4
IMPCHR::JEN @PISC5R

LS BUGIR,1
BUGINT:	XWD BUGIR,.+1
	BUG(CHK,<FALSE INTERRUPT>)
	JEN @BUGIR

	INTERN MENTR,MRETN,MONUUO,UJSYS,MRETNE
	EXTERN GETPAT

UU60:	XWD FPC,ILUUO		;JSYS AT 61

IUUO:	MOVE 1,XMENTR		;RESTORE AC1
ILUUO:	JSYS MENTR
	ITERR ILINS1		;ILLEGAL UUO

;UUO DISPATCH

UUOH:	XWD FPC,.+1		;41 CONTAINS JSYS UUOH
	MOVEM 1,XMENTR		;SAVE AC1
	MOVE 1,FPC
	TLNE 1,UMODF		;USER CALL?
	JRST UUOHX		;YES
	MOVE 1,XMENTR
	BUG(CHK,<UUO FROM MONITOR>)
MONUUO:	JRST ILUUO

UUOHX:	TLNE 1,(7B10)		; In PDP-10 mode?
	 JRST IUUO		; No, all traps illegal in Byte Lisp
	HLRZ 1,40		;GET OP CODE
	LSH 1,-^D9
UUOHK:	CAIL 1,100		;OUT OF BOUNDS?
	JRST IUUO		;YES, ILLEGAL INSTRUCTION
	CAIL 1,40		;10/50 UUO?
	JRST UU1050		;YES
	JUMPE 1,IUUO		;0 IS ALWAYS ILLEG
	BUG(HLT,<01-37 UUO FROM USER MODE>)

REPEAT 0,<	;THIS WON'T BE USED UNLESS SOMEBODY WANTS
		;MON-MON OR USER-MON UUO'S INSTALLED
	SKIPL 1,UUOT(1)		;GET DISPATCH WORD, CHECK TYPE
	JRST UUOH2		;SLOW
	EXCH 1,XMENTR		;FAST, RESTORE AC1, SETUP DISPATCH ADR
	JRST @XMENTR		;COMMENCE ROUTINE
>

UU1050:	SKIPN PATADR		;GOT PAT NOW?
	JRST [	MOVE 1,XMENTR	;NO
		JRST GETPAT]	;GO GET IT
	MOVE 1,40		;MOVE STUFF FOR 10/50 COMPAT
	XCTUU PATU40		;CONTAINS UMOVEM 1,MONUUO
	MOVE 1,FPC
	XCTUU PATUPC		;CONTAINS UMOVEM 1,MONUPC
	MOVE 1,PATADR		;ENTRY VECTOR
	HRRM 1,FPC
	MOVE 1,XMENTR
	XCT MJRSTF

;ALL UNDEFINED JSYS'S

UJSYS:	JSYS MENTR
	ITERR ILINS2

;SLOW-CALL SETUP ROUTINE

MENTR:	XWD XMENTR,UUOH1	;SLOW JSYS'S BEGIN WITH  JSYS MENTR

UUOH2:	EXCH 1,XMENTR		;SLOW UUO'S ENTER HERE
UUOH1:	SETOM SLOWF
	EXCH 0,FPC		;GET RETURN PC
	TLNE 0,UMODF		;USER OR MONITOR MODE?
	JRST MENT1		;USER
	AOSGE INTDF		;INTDF ALLRIGHT?
	BUG(CHK,<AT MENTR - INTDF OVERLY DECREMENTED>)
	SOS INTDF
	PUSH P,INTDF
	PUSH P,MPP		;SAVE PREVIOUS ERRORSET
	PUSH P,0		;SAVE RETURN
	MOVEM P,MPP		;SAVE CURRENT STACK POINTER
	AOS P,ACBAS		;GET NEXT AC BASE ADR
	CAIL P,<EUACB>B39	;USED ALL BLOCKS OF AC'S?
	JRST MENT4		;USED ALL AC BLOCKS IN PSB
MENT3:	SETACB P		;GIVE IT TO PAGER
MENT2:	MOVE 0,XMENTR		;LOCAL RETURN => FPC
	EXCH 0,FPC		;AC0 => 0
	SETZ P,
	XCTMU [BLT P,P-1]	;MOVE FROM REAL AC'S TO USER BLOCK
	MOVE P,MPP		;RESTORE P
	SETZM SLOWF
	XCT MJRSTF		;JRSTF @FPC  OR INTERRUPT

MENT1:	MOVEM P,XMENT1		;SAVE USER'S AC-P
IFN KIFLG,<
	MOVSI P,(1B6)		;CALL FROM MON FLAG
	IORM P,XMENTR>		;ENSURE CALL FROM USER IS SET ON KI10
	MOVE P,UPP		;GET STACK POINTER
	PUSH P,0		;TWO RETURNS
	PUSH P,0		;SO ONE CAN BE DIDDLED
	MOVEM P,MPP
	SETOM INTDF
	MOVE P,ACBAS1		;FIRST AC BASE TO USE
	MOVEM P,ACBAS
	SETACB P		;SET PAGER
	MOVE P,XMENT1		;RESOTRE USER'S AC-P
	UMOVEM P,P		;PUT USER'S AC-P WHERE IT BELONGS
	JRST MENT2


MENT4:	CAIE	P,<EUACB>B39	;TIME TO SWITCH TO UACPG?
	JRST	MENT5		;NO, ALREADY SWITCHED
	MOVE	P,MPP		;YES, GET A PDL PTR
	SETZM	PSB+UACPG	;CLEAR MAP ENTRY FOR UACPG
	MONCLR UACPG
	PUSH	P,1
	PUSH	P,2
	LDB	1,[POINT 13,PSB+PSBPG,26]
	MOVSI	2,RCW
	HRRI	2,UACPGA	;SET MAP ENTRY FOR UACPG TO
	CALL	SETMPG		;COPY WRITE PTR TO PSB
	POP	P,2
	POP	P,1
	MOVE	P,ACBAS
	JRST	MENT3		;SET UP PAGER

MENT5:	CAIL	P,<EPSB>B39	;ANY MORE AC BLOCKS
	BUG(HLT,<MENTR - NO MORE AC BLOCKS>)
	JRST	MENT3

;SLOW-CALL RETURN

MRETNE:	MOVEM 1,LSTERR		;ERROR RETURN, SAVE ERROR CODE
	UMOVEM 1,1		;AND RETURN IT TO USER ALSO
MRETN:	SETOM SLOWF		;RESET FLAG
	AOSGE INTDF		;INTDF OK?
	BUG(CHK,<AT MRETN - INTDF OVERLY DECREMENTED>)
	MOVE P,MPP		;GET STACK POINTER AT LAST ENTRY
	POP P,0			;POP RETURN
	TLZ 0,37		;MAKE SURE NO CARRY INTO IDX FIELD
	MOVEM 0,FPC		;SETUP RETURN
	TLNN 0,UMODF		;USER MODE?
	JRST MRETN1		;NO
IFN PIESLC,<
	SKIPGE HIQCNT		; Ensure that we don't return to user
	SKIPL SPQCNT		;  while on HIQ or SPQ
	 BUG(HLT,<MRETN to user while on HIQ or SPQ>)
>
	SETZ P,
	XCTUM [BLT P,P]		;RESTORE USER AC'S
IFN KIFLG,<
	MOVEM P,XMENT1		;HAVE TO SET AC BLOCKS IN USER MODE
	SOS P,ACBAS		; TOO ON THE KI-10
	SETACB P
	MOVE P,XMENT1>
	XCT MJRSTF		;RETURN OR INTERRUPT

MRETN1:	MOVEM P,MPP		;SAVE P
	SETZ P,
	XCTUM [BLT P,P-1]	;RESTORE AC'S
	SOS P,ACBAS		;RESET AC BASE TO LAST ONE
	CAIGE P,<UACB>B39	;BEFORE BEGINNING OF AC BLOCKS?
	BUG(HLT,<MRETN - TRIED TO OVER-POP AC BLOCKS>)
	CAIN P,<EUACB-1>B39	;TRANSITION FROM UACPG TO PSB?
	JRST MRETN3		;YES
MRETN2:	SETACB P
	MOVE P,MPP
	POP P,MPP		;RESTORE PREVIOUS STACK POINTER
	POP P,INTDF		;RESTORE INTERRUPT DEFERRED STATE
	SETZM SLOWF
	XCT MJRSTF		;RETURN OR INTERRUPT

MRETN3:	MOVE P,MPP		;GET PDL PTR
	PUSH P,1
	PUSH P,2
	SETZ 1,
	MOVEI 2,UACPGA
	CALL SETMPG		;UNMAP UACPG
	MOVE 1,PSB+PSBPG	;AND THEN RESET MAP ENTRY
	MOVEM 1,PSB+UACPG	;TO BE SAME AS FOR PSB
	POP P,2
	POP P,1
	MOVE P,ACBAS		;GET AC BLOCK ADDR
	JRST MRETN2



REPEAT 0,<	;NOT USED UNLESS MON-MON OR USER-MON UUO'S INSTALLED

;UUO DISPATCH TABLE

	DEFINE UUD (N,T)
<	EXTERN N
	XWD T*400000,N>

UUOT:	REPEAT 40,<XWD 400000,ILUUO>

	REPEAT 40,<XWD 0,GETPAT> ;LOADS 10/50 COMPATIBILITY
>

;LAST PAGE

;NVIO BUGCHK STRINGS
NVBUG(2,<MEMORY ERROR REPORTED>)
NVBUG(3,<IORESET FOUND A MEMORY ERROR>)

	END
